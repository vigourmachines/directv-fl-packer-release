require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/shawn/Work/directv-fl/config.js":[function(require,module,exports){
window.name = 'directv-fl'

// window.package = require('package.json')
// console.log('wtf...', window.package)

module.exports = exports = require( 'vigour-js/util/config' )
              .inject
              ( { 'repository.branch': 'branches' }
              , require( 'vigour-js/util/config/ua' )
              )

exports( function( result ) {
  for(var key in result) {
    // console.log('\n', i, result[i])
    exports[key] = result[key] 
  }
  exports.parsed = true

}, false, window.package, true )
},{"vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js","vigour-js/util/config/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/ua.js"}],"/Users/shawn/Work/directv-fl/index.js":[function(require,module,exports){


// window.__ua__ = {
//   device:'tablet'
// }

window.package = require('package.json');
var config = require('/Users/shawn/Work/directv-fl//config')
  , remote


if( config.development && config.development.button )
{
  remote = require( 'vigour-js/util/debug' )
            .native( false, false, function(url) {} , 'bundle' )
}

if( !remote ) 
{
  var cases = require( 'vigour-js/browser/cases' )
    , ua = require( 'vigour-js/browser/ua' )

  // if(ua.device === 'tablet'){
  //   var viewport = document.querySelector("meta[name=viewport]")
  //   viewport.setAttribute('content', 'width=device-width, initial-scale=0.6, maximum-scale=1.0, user-scalable=0');
  // }

  require( './src/main' )
  
}
},{"./src/main":"/Users/shawn/Work/directv-fl/src/main/index.js","/Users/shawn/Work/directv-fl//config":"/Users/shawn/Work/directv-fl/config.js","package.json":"package.json","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/util/debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/domain-browser/index.js":[function(require,module,exports){
/*global define:false require:false */
module.exports = (function(){
	// Import Events
	var events = require('events')

	// Export Domain
	var domain = {}
	domain.createDomain = domain.create = function(){
		var d = new events.EventEmitter()

		function emitError(e) {
			d.emit('error', e)
		}

		d.add = function(emitter){
			emitter.on('error', emitError)
		}
		d.remove = function(emitter){
			emitter.removeListener('error', emitError)
		}
		d.bind = function(fn){
			return function(){
				var args = Array.prototype.slice.call(arguments)
				try {
					fn.apply(null, args)
				}
				catch (err){
					emitError(err)
				}
			}
		}
		d.intercept = function(fn){
			return function(err){
				if ( err ) {
					emitError(err)
				}
				else {
					var args = Array.prototype.slice.call(arguments, 1)
					try {
						fn.apply(null, args)
					}
					catch (err){
						emitError(err)
					}
				}
			}
		}
		d.run = function(fn){
			try {
				fn()
			}
			catch (err) {
				emitError(err)
			}
			return this
		};
		d.dispose = function(){
			this.removeAllListeners()
			return this
		};
		d.enter = d.exit = function(){
			return this
		}
		return d
	};
	return domain
}).call(this)
},{"events":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/events/events.js"}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/os-browserify/browser.js":[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/support/isBufferBrowser.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","inherits":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js":[function(require,module,exports){
// If `Date.now()` is invoked twice quickly, it's possible to get two
// identical time stamps. To avoid generation duplications, subsequent
// calls are manually ordered to force uniqueness.

var _last = 0
var _count = 1
var adjusted = 0
var _adjusted = 0

module.exports =
function timestamp() {
  /**
  Returns NOT an accurate representation of the current time.
  Since js only measures time as ms, if you call `Date.now()`
  twice quickly, it's possible to get two identical time stamps.
  This function guarantees unique but maybe inaccurate results
  on each call.
  **/
  //uncomment this wen
  var time = Date.now()
  //time = ~~ (time / 1000) 
  //^^^uncomment when testing...

  /**
  If time returned is same as in last call, adjust it by
  adding a number based on the counter. 
  Counter is incremented so that next call get's adjusted properly.
  Because floats have restricted precision, 
  may need to step past some values...
  **/
  if (_last === time)  {
    do {
      adjusted = time + ((_count++) / (_count + 999))
    } while (adjusted === _adjusted)
    _adjusted = adjusted
  }
  // If last time was different reset timer back to `1`.
  else {
    _count = 1
    adjusted = time
  }
  _adjusted = adjusted
  _last = time
  return adjusted
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/promise/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./lib')

},{"./lib":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js":[function(require,module,exports){
'use strict';

var asap = require('asap/raw');

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

module.exports = Promise;

function Promise(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('not a function');
  }
  this._32 = 0;
  this._8 = null;
  this._89 = [];
  if (fn === noop) return;
  doResolve(fn, this);
}
Promise._83 = noop;

Promise.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
};
function handle(self, deferred) {
  while (self._32 === 3) {
    self = self._8;
  }
  if (self._32 === 0) {
    self._89.push(deferred);
    return;
  }
  asap(function() {
    var cb = self._32 === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._32 === 1) {
        resolve(deferred.promise, self._8);
      } else {
        reject(deferred.promise, self._8);
      }
      return;
    }
    var ret = tryCallOne(cb, self._8);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}
function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(
      self,
      new TypeError('A promise cannot be resolved with itself.')
    );
  }
  if (
    newValue &&
    (typeof newValue === 'object' || typeof newValue === 'function')
  ) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (
      then === self.then &&
      newValue instanceof Promise
    ) {
      self._32 = 3;
      self._8 = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._32 = 1;
  self._8 = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._32 = 2;
  self._8 = newValue;
  finale(self);
}
function finale(self) {
  for (var i = 0; i < self._89.length; i++) {
    handle(self, self._89[i]);
  }
  self._89 = null;
}

function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return;
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) return;
    done = true;
    reject(promise, reason);
  })
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

},{"asap/raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/done.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this;
  self.then(null, function (err) {
    setTimeout(function () {
      throw err;
    }, 0);
  });
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/es6-extensions.js":[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js');
var asap = require('asap/raw');

module.exports = Promise;

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new Promise(Promise._83);
  p._32 = 1;
  p._8 = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) return value;

  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._32 === 3) {
            val = val._8;
          }
          if (val._32 === 1) return res(i, val._8);
          if (val._32 === 2) reject(val._8);
          val.then(function (val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","asap/raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/finally.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype['finally'] = function (f) {
  return this.then(function (value) {
    return Promise.resolve(f()).then(function () {
      return value;
    });
  }, function (err) {
    return Promise.resolve(f()).then(function () {
      throw err;
    });
  });
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./core.js');
require('./done.js');
require('./finally.js');
require('./es6-extensions.js');
require('./node-extensions.js');

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","./done.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/done.js","./es6-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/es6-extensions.js","./finally.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/finally.js","./node-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/node-extensions.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/node-extensions.js":[function(require,module,exports){
'use strict';

// This file contains then/promise specific extensions that are only useful
// for node.js interop

var Promise = require('./core.js');
var asap = require('asap');

module.exports = Promise;

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity;
  return function () {
    var self = this;
    var args = Array.prototype.slice.call(arguments);
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop();
      }
      args.push(function (err, res) {
        if (err) reject(err);
        else resolve(res);
      })
      var res = fn.apply(self, args);
      if (res &&
        (
          typeof res === 'object' ||
          typeof res === 'function'
        ) &&
        typeof res.then === 'function'
      ) {
        resolve(res);
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var callback =
      typeof args[args.length - 1] === 'function' ? args.pop() : null;
    var ctx = this;
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx);
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      } else {
        asap(function () {
          callback.call(ctx, ex);
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this;

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value);
    });
  }, function (err) {
    asap(function () {
      callback.call(ctx, err);
    });
  });
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-asap.js":[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-raw.js":[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js":[function(require,module,exports){
(function (process){
"use strict";

var domain; // The domain module is executed on demand
var hasSetImmediate = typeof setImmediate === "function";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to exit the domain, because domains exist on a stack.
    // To execute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy execute the domain module.
            // Only employed if the user elects to use domains.
            domain = require("domain");
        }
        domain.active = process.domain = null;
    }

    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.nextTick` started throwing recursion errors.
    if (flushing && hasSetImmediate) {
        setImmediate(flush);
    } else {
        process.nextTick(flush);
    }

    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}

}).call(this,require('_process'))

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","domain":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/domain-browser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js":[function(require,module,exports){
var Cloud = require('vigour-js/browser/network/cloud')
    .inject(
      require('vigour-js/browser/network/cloud/datacloud'),
      require('vigour-js/browser/network/cloud/authenticate')
    ),
  Value = require('vigour-js/value'),
  Data = require('vigour-js/data'),
  util = require('vigour-js/util'),
  cases = require('vigour-js/browser/cases'),
  ua = require('vigour-js/browser/ua'),
  raf = require('vigour-js/browser/animation/raf')

// var semver = require('vigour-js/util/semver')

require('vigour-js/value/flags/process') // mustbecome injectable on object ( all these extension should be located seperately )

function setClientInfo (cloud, base) {
  // todo: move client to cloud
  
  var oldclient = cloud.client.from.raw
  var obj = oldclient 
    ? { 
        title: oldclient.title,
        device: oldclient.device,
        info: oldclient.info
      }
    : {}
  filterEmpty(obj)

  var client = cloud.data.get(['clients', cloud.clientid]),
    title, device, castId

  var info = cases.touch 
    ? ua.device + ' ' + 
      ( ua.platform === 'ios' ? 'iOS' : ua.platform ) +
      ( ua.version ? ' ' + ua.version : '' )
    : ua.platform + ' ' + ua.browser + ' ' + ua.version

  if (cases.$isIos) {
    title = ua.device === 'phone' ? 'iphone' : 'ipad'
    device = ua.device
  } else {
    if (ua.platform === 'appletv') {
      title = 'Apple TV'
      device = 'cast'
    } else if (cases.$isChromecast) {
      title = 'Chromecast'
      device = 'cast'
      castId = window.sessionId
    } else {
      device = ua.device
      title = cases.$isDesktop ? ua.platform : ua.platform + ' ' + device
    }
  }

  util.merge( obj, {
    title: title,
    device: device,
    info: info
  }, false, false )

  if (castId) {
    obj.castId = castId || false
  }

  // client.merge(obj, false, false)
  client.val = obj
  cloud.client.val = client

  // DEBUG LOGS: 
  // cloud.client.on(function(val, stamp, from){
  //   // console.log('\n\n\n\nupdate kenker', val, from)
  //   var origin = from || this._updateOrigin
  //   if(val && val.token || (origin && origin._name === 'token')) {
  //     console.error('TOKENSETTOKENSETTOKENSET', val && (val.token || val) )
  //   }
  // })

  // user.clientUserToken = user.client.from.get('userToken') deze is duidelijk fucked up and has to be fixed
}

exports.extend = util.extend( require('./values'), function (base) {
  var _cloud = new Cloud(new Value())
    , _first //= true
  
  cases.$isConnected = new Value( _cloud.connected )

  // todo: move to cloud
  _cloud.client = new Value()

  _cloud.once('welcome', function (id) {
    setClientInfo(_cloud, base)
  })

  // _cloud.on('reconnect',)
  // console.error('>>> adding reconnect listener')
  _cloud.on('reconnect', function() {
    // console.log('>>>> reconnect set up reset client info!', _cloud.client.from.raw)
    var setObj = {}
    _cloud.client.from.each(function(i) {
      if(i !== 'key' && i !== 'type' && i !== 'ip'){
        setObj[i] = this._val
      }
    })
    _cloud.client.from.on('remove', function() {
      if(Object.keys(setObj).length) {
        // console.log('reset dat client info', setObj)
        _cloud.data.clients.set(_cloud.clientid, setObj)
      }
    })
  })

  base.define({
    cloud: {
      get: function () {
        return _cloud
      },
      set: function (val) {
        if (util.isObj(val)) {
          if (val.fastLogin) {
            _cloud.fastLogin.val = true
          }

          if (val.api) {
            _cloud.api.val = val.api
          }

          if (val.url) {
            _cloud.url.val = val.url
          }
        } else {
          _cloud.url.val = val
        }
      }
    }
  })

  var _version = new Data( _cloud.data.get('app'), { subscription: { $:true } } )

  //semvar -- APP VERSION DOES NOT WORK!
  base.versionData = new Value({
    val: _version,
    defer: function(update, args) {
      var doUpdate
      var t
      if(this.from.version) {
        console.log('hey hey hey')
        if( !window.package ) 
        {
          console.error( 'no window package', window.package )
        }
        else 
        {
          var newversion = this.from.version.val
            , oldversion = window.package.version

          if(newversion && oldversion) {
            newversion = newversion.split('.')
            oldversion = oldversion.split('.')
            newversion = Number(newversion[1])
            oldversion = Number((oldversion[1]||0))
            if( newversion > oldversion ) {
              doUpdate = true
              this.clearCache()
              window.package.version = this.from.version.val
            }
          }
        }
      } 
      update( doUpdate ? void 0 : true )
    }
  })

})


function filterEmpty(obj) {
  for(var f in obj) {
    if(obj[f] === void 0) {
      delete obj[f]
    }
  }
}

},{"./values":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/network/cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/index.js","vigour-js/browser/network/cloud/authenticate":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/authenticate.js","vigour-js/browser/network/cloud/datacloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/datacloud.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js":[function(require,module,exports){
var Value = require('../value')
  , CloudData = require( '../browser/network/cloud/data' )
  , util = require('../util')
  , vObj = require('../object')


util.define
( CloudData
, '_contentPath'
, { get: function() {
      var p = this._path
      for(var i in p ) {
        if( p[i] === 'shows' || p[i] === 'channels' ) {
          return p.slice( i )
        }
      }

      console.error('_contentPath used on non-content data', this, p)
      // throw new Error('_contentPath used on non-content data')
      // return this._path.slice( base.instances[0].data.from._path.length )
    }
  }
)

util.define(
  vObj
, '_contentType'
, { get:function() {
      var from = this.from
      if( from.cloud && from._parent ) return from._parent._name
    }
  }
)

exports.extend = util.extend( 
  require('./values')
, require('./cloud')
, function( app ) {
    var content = app.content = new Value({})
    // var get = Value.prototype.get
    util.define(content, 'get', function(){
        if( this._val && this._val.cloud ) { 
          return this._val.get.apply(this._val, arguments) 
        } else { 
          throw new Error( 'app.content , dont have cloud data!') 
        }
      })

    app.region.on(onChange)
    app.language.on(onChange)

    onChange()

    function onChange(){
      var region = app.region.val
        , language = app.language.val

      //TODO:make this configurable in the app
      if(language==='it') {
        language = 'en'
      }

      if(region && language){
        //TODO: make mtvData configurable
        // content.val = app.cloud.data.get(['mtvData', region, language])

        // content.val = app.cloud.data

      }
      content.val = app.cloud.data
    }
    
  }
)

},{"../browser/network/cloud/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","./cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js","./values":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * 
 * could think of something so style requires are parsed optionaly
 * maybe in vigour-js use dynamic script tags and parse those /w gaston if you are using gaston
 * this will make it more usable for others in the future and makes it compatible with pure browserify
 */

require('./style.less')
require('vigour-js/browser/animation/easing')

var Element = require('./ui/element')
  , cases = require('vigour-js/browser/cases')
  , animation = require('vigour-js/browser/animation')
  , events = require('vigour-js/browser/events/advanced')
  , ua = require('vigour-js/browser/ua')
  , raf = require('vigour-js/browser/animation/raf')
  , eventUtils = require('vigour-js/browser/events/util')
  , app
  , _ios = ua.platform==='ios'
  , _windows = ua.platform === 'windows'
  , arr = ['phone','tablet','tv','desktop','ios','android','windows','mac','$hasTouch','slow','chromecast'] //maybe make this configrable
  //ui/cases --
  , i = arr.length - 1

//hier process in requiren en added 'appStart' ofzoiets dergelijks
//add ook process aan base dingen dan word iets pas geadd na een bepaalde process update
//ultra mofo powerfull

cases.$isIosBrowser = _ios && ( 'standalone' in navigator && !navigator.standalone )
cases.$isIosFull = (!cases.$isIosBrowser&&_ios) || ((_ios || _windows) && !!window.cordova) || false
cases.$isRetina = window.devicePixelRatio > 1
cases.$isSlow = (_windows && ua.device === 'phone') || (ua.noRaf&&ua.hasTransition) || _ios && (window.screen.height === (960 / 2)) || ua.device === 'tv'
cases.$isNative = window.cordova ? true : false
cases.$isWindowsMobile = ua.platform === 'windows' && ua.device === 'phone' && !!window.cordova
cases.$isPhoneBrowser = ua.device === 'phone' && !( cases.$isNative || cases.$isIosFull )
//packer case voor web // native

app = module.exports = new Element({
  'x,y':{val:0,clean:true,translate:true}
, node: document.body
, w: window.innerWidth
, h: window.innerHeight
, css: 'app'
})

//if(cases.$isiosFull) {
  // app.y = {add:20}
  // app.h = {sub:20}
//}

var listener = function() {
//   console.log('resize!!','w:',window.innerWidth,'h:',window.innerHeight,'block?:',app.blockResize)
  if(!app.blockResize) {
    // animation.prevent = true
    app.w.val = window.innerWidth
    app.h.val = window.innerHeight
    // animation.prevent = false
  } else {
    app.blockResize = false
  }
}

function defaultCase(str) {
  if(str !== '$hasTouch'){
    var cssStr =  's' + str.charAt(0).toUpperCase() + str.slice(1);
    var caseStr = '$i' + cssStr
    if(cases[caseStr]===void 0) {
      cases[caseStr] = (ua.device === str || ua.platform === str) ? true : false
    }
    app.css = {addClass:cases[caseStr] ? 'i' + cssStr : 'notI'+ cssStr}
  }else{
    app.css = {addClass:cases.$hasTouch ? 'hasTouch' : 'notHasTouch'}
  }
}

// listener = eventUtils.throttle(listener,60)
// listener =
// cases.$isnoCalc = !util.hasCalc()
//case too see if app is running in a browser on ios (limits video capabilities)

if(cases.$istouch) events.document.addEvent('move',function(e) {
  if(!events._maybescroll && !events._setscroll) e.preventDefault()
},'app')

if('orientation' in window) window.addEventListener('orientationchange',listener)
if(!_ios) window.addEventListener('resize',listener)

//adding #<case> in url forces case, multiple hashes ==> multiple cases
//this is for testing purposes , add development indentifier for compiler

//this has to go
if(window.location.hash) {
  var hashCases = window.location.hash.split('#')[1]
    , x = hashCases.split(',')

  for(var j in x) {
    var y = x[j].split('=')
    ua[y[0]] = y[1]
  }
  
}

if(ua.device === 'tv') {
  cases.$isSlow = true
}

for(;i >= 0;) defaultCase(arr[i--])




},{"./style.less":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/style.less","./ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/animation":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js","vigour-js/browser/animation/easing":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/easing.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events/advanced":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/advanced.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Element = require('../../../browser/element')

require('../../../value/flags/parent')
require('../../../value/flags/self')
require('../../../value/flags/process')
require('../../../value/flags/util')
require('../../../browser/events')

module.exports =
  Element
  .inject
  ( require('../../../browser/element/properties/collection')
  , require('../../../browser/element/properties')
  , require('../../../browser/element/properties/scrollbar')
  , require('../../../browser/element/properties/process')
  , require('../../../value/on')
  )


},{"../../../browser/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../browser/element/properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","../../../browser/element/properties/collection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/index.js","../../../browser/element/properties/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/process.js","../../../browser/element/properties/scrollbar":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/scrollbar.js","../../../browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../../value/flags/parent":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/parent.js","../../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","../../../value/flags/self":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js","../../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../../../value/on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/on.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/sprite/index.js":[function(require,module,exports){
var Element = require('../element')
  , util = require('../../../browser/events/util') 
  , sprite = new Element({ 
    'w,h':50,
    x:{translate:true,val:0}
  })

sprite.extend({ name: 'params' //this has to come from ui (element)
  , type: false
  , set: function(val) {
    this._params = val
    this.Class.prototype._params = val //temp?
  }
})

sprite.setSetting({
  name:'spinner',
  render:function() {
    var t = this
      , params = this._params || {}
      , start = params.start || 0
      , speed = params.frames || 3
      , rows = params.rows || 1
      , cols = params.cols || 0 //ignore
      , once = params.once
      , cnt = start
      , steps = (params.steps || (rows*cols-start) || 19)
      , curRow = 0
      , curCol = 0

    if(!t.display || !t.display._base===t) {
      t.display = t.display && t.display.val || 'block'
    }
    t.display.addListener([displayListener,t],true)

    t.node.style.backgroundSize = this.w.val*cols+'px auto'
    //remeber where it was perhaps if re-rendered
    if(t.display.val==='none') return

    t._spinner = util.interval(function() { //test interval for leaks
      t.node.style.backgroundPosition = 
        (-t.w.val*curCol)+'px '+(rows ? (-t.h.val*curRow) : 0)+'px'
      cnt++
      if(cnt === steps) {
        cnt = start
        if(once) {
          // console.error('XXXXX')
          removeRaf.call(t)
          return
        }
      }
      curRow = rows ? ~~(cnt/cols) : 0
      curCol = cnt-(curRow)*cols
    },speed)
  },
  remove:removeRaf
})

function removeRaf() {
     // alert('lets remove this badboy')

  if(this._spinner) {
    this._spinner()
    this._spinner = null
  }
}

function displayListener (val) {
  if(val.val==='none') {
    removeRaf.call(this)
  } else {
    if(!this._spinner) this.setting('render')
  }
}

module.exports = sprite.Class



},{"../../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Base = require('vigour-js/base')
  , Element = require('vigour-js/browser/element')
  , Value = require('vigour-js/value')
  , VObject = require('vigour-js/object')
  , switcher = new Element()
  , cases = require('vigour-js/browser/cases')

function extendFactory( field ){
  return { name:field
  , type:false
  , set:function( fn ){
      if(fn instanceof Function)
      {
        var set = {}
        set['_'+field] = fn
        this.define(set)
      }
      else
      {
        console.error('property ' + field + ' needs to be a function')
      }
    }
  }
}

Value.flags.$params = {
  set:function( val ) {
    this.params = val
  }
}

Value.flags.$options = {
  set:function( val ) {
    this.options = val
  }
}

switcher.extend
( { loader:{}
  , animation:{}
  , delay:{}
  , done:{}
  , force:{}
  , backFallback:
    { cache:false
    // , set:function(){}
    }
  , onTransition:
    { cache:false
    // , set:function(){}
    }
  , transition:
    { cache:false
    , set:function( val ){
        var element = val.element && val.element._val
          , params = val.params
          , options = val.options || {}
          , force = options && options.force
          , children = this.children
          , last = this._swElem || children[0]
          , base = element && element.base
          , childrenLength = children.length
          , current
          , child
          , direction
          , _this = this

        //if there are old loading listeners remove these
        if( this._loading )
        {
          this._loading[1].removeListener( this._loading[0] )
          this._loading = void 0
        }

        // if( _this._timer ){
        //   clearTimeout( _this._timer )
        //   _this._timer = null
        // }

        // console.log('options?!'.green.inverse,options)
        //is it the same , is it not the same whatup!
        if( base && base instanceof Element || element === Element )
        { 
          if( !force && this._swElem && this._swElem instanceof element )
          {
            this._swElem.set( params )
          }
          else
          {

            // if there are still old pages, remove these
            if( childrenLength > 1 )
            {
              for ( i = childrenLength - 1; i >= 0; i-- ) 
              {
                child = children[i]
                if( child !== last ) child.remove()
              }
            }

            direction = this._direction = val.direction && val.direction._val
            if( options && options.loader && !options.loader.$loaded )
            {
              if( !this.loader )
              {
                console.error( 'no loader defined!' )
                return
              }

              var loader = new this.loader._val.Class()

              if( options.loader instanceof VObject ) //TODO: this has gotten VERY dirty > clean this up!
              {
                options.done = function(){
                  if( !current ) current = new element( params )
                  if( loader._remove )
                  {
                    options.done = void 0
                    options.delay = cases.tablet ? 400 : 200 //dit is natuurlijk absurd
                    
                    if( _this._swElem instanceof element )
                    {
                      _this._swElem.set( params )
                    }
                    else
                    {
                      _this.onTransition._val.call( _this, current, _this._swElem , 0, options )
                    }
                    options.delay = void 0
                  }
                }

                var path = options.loader._path
                this._loading = [ function() {
                  // if( _this._timer ){
                  //   clearTimeout( _this._timer )
                  //   _this._timer = null
                  // }
                  loader._remove = true
                  if( current && options.done ) options.done()

                }, options.loader ]

                // console.log('add the listener for',path)
                this._loading[1].is('loaded', this._loading[0] )
                // _this._timer = setTimeout( this._loading[0], 5000 )
              }
              else
              {
                options.done = function(){
                  if( !current ) current = new element( params )

                  options.done = void 0
                  options.delay = 200

                  if( _this._swElem instanceof element )
                  {
                    _this._swElem.set( params )
                  }
                  else
                  {
                    _this.onTransition._val.call( _this, current, _this._swElem , 0, options )
                  }

                  options.delay = void 0
                }
              }

              options.loader = void 0

              this.onTransition._val.call( this, loader, last, direction, options)
            }
            else
            {
              current = new element(params)
              options.done = void 0
              options.delay = void 0
              options.loader = void 0
              
              this.onTransition._val.call( this, current, last , direction, options )
            }

            if( options.animation !== void 0 ) options.animation = void 0
            if( options.delay ) options.delay = void 0

          }
        }
        else if(params)
        {
          console.error('only params defined!', params)
        }
        else if(params)
        {
          console.error('no params and no element defined!')
        }
      }
    }
  }
)

switcher.define
({ back:function(){ //remove back logic from switcher (you can't isolate it! ie when you land on page, what is back?)
      this.backFallback._val.call( this )
		}
  , add:function( element, previous ){
      console.log('add--->',element)
      this._swElem = element

      // try
      // {
        Element.prototype.add.apply( this, arguments )
      // }
      // catch(err)
      // {
      //   console.error('error adding the new element',err,arguments)
      // }
    }
	}
)

switcher.extend
( { name:'on'
  , set:function( val ) {
      // set history variable for all
      // val.each(function(){
      //   var from = this.$userOrigin.val
      //   if(!from) return
      //   if(!from._history) from.set('history',true)
      //   if(!this.__checked)
      //   {
      //     this.on(function(){
      //       var caller = this._parent._caller
            
      //       if(!caller._backStore)
      //       { 
      //         caller._backStore = [ this ]
      //       }
      //       else if(caller._direction === -1)
      //       {
      //         if(caller._backStore[1] !== void 0) caller._backStore.shift()
      //         else caller._backStore = [ this ]
      //       }
      //       else if(caller._direction === 1)
      //       {
      //         caller._backStore.unshift( this )
      //       }
            
      //     })
      //     this.__checked = true
      //   }
      // })
    }
  , remove:function(){ // create refs to original
      if( this._loading )
      {
        this._loading[1].removeListener(this._loading[0])
        this._loading = null
      }
      
      if( this._swTimer ) clearTimeout( this._swTimer )
      if( this._timer ) clearTimeout( this._timer )

      if( this.on.$remove ) this.on.$remove.update()
    }
  , new:function(){
      if( this.on.$new ) this.on.$new.update()
    }
  }
)

module.exports = new switcher.Class().Class
},{"vigour-js/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var app = require('vigour-js/app'),
  cases = require('vigour-js/browser/cases'),
  util = require('vigour-js/util')

exports.extend = util.extend(function(base) {
  base.set({
    onTransition: {
      defer: function(update) { //obscure transform
        if (exports[this._val]) this._val = exports[this._val]
        update()
      }
    }
  })
})

//slide transition
exports.slide = function(current, last, direction, options) {
  if (direction && last) animate(this, current, last, direction, options)
  else basic(this, current, last, direction, options)
}

//fade transition
exports.fade = function(current, last, direction, options) {
  basic(this, current, last, direction, options)
}

//basic transition
function basic(_this, current, last, direction, options) {
  var done = options.done,
    noAnimation = options.animation === false,
    delay = options.delay

  if (last) {
    add(_this, current, last)

    if (noAnimation) {
      remove(_this, last)
      add(_this, current)

      if (done) {
        if (delay) {
          timer(_this, function() {
            if (options.done) options.done()
          }, delay)
        } else done()
      }
    } else if (delay) {
      timer(_this, function() {
        fade(_this, last, options)
      }, delay)
    } else fade(_this, last, options)
  } else add(_this, current, false, done)
}

//animated transition
function animate(_this, current, last, direction, options) {
  var animationTime = 20 // make this configurable
    ,
    appWidth = app.w.val,
    currentStart, forward = direction === 1,
    lastEnd

  if (forward) {
    currentStart = appWidth
    lastEnd = appWidth / -3
  } else {
    currentStart = appWidth / -3
    lastEnd = appWidth
  }

  if (cases.$isWindows) {
    current.x = {
      translate: true,
      val: currentStart
    }

    last.x = {
      translate: true,
      val: 0
    }

    window.requestAnimationFrame(function() {
      current.x = 0
      last.x = lastEnd

      timer(_this, function() {
        remove(_this, last, options.done)
      }, 210)
    })
  } else {
    current.x = {
      animation: {
        start: currentStart,
        time: animationTime,
        delay: 1,
        easing: 'outCubic',
        done: function() {
          remove(_this, last, options.done)
        }
      },
      val: 0
    }

    last.x = {
      animation: {
        time: animationTime,
        delay: 2,
        easing: 'outCubic'
      },
      val: lastEnd
    }
  }

  if (!forward) add(_this, current, last)
  else add(_this, current)

}

function add(_this, toAdd, before, done) {
  if (toAdd) _this.add(toAdd, before)
  if (done) done()
}

function fade(_this, last, options) {
  last.opacity = 0
  last.node.pointerEvents = 'none'
  timer(_this, function() {
    remove(_this, last, options.done)
  }, 200)
}

function remove(_this, toRemove, done) {
  if (toRemove) toRemove.remove()
  if (done) done()
}

function timer(_this, fn, time) {
  if (_this._swTimer) {
    clearTimeout(_this._swTimer)
    _this._swTimer = null
  }
  _this._swTimer = setTimeout(function() {
    fn.call(_this)
    _this._swTimer = null
  }, time)
}

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/id.js":[function(require,module,exports){
var util = require('../../util')

require('../../value/flags/process')

exports.extend = util.extend
( function( base ) {
    // base
    base.extend
    ( 
      { id: function(val) {
          var id = val.val

          if( id && this.cloud ) 
          {
            this.data = this.cloud.data.get([ 'users', id ])
          } 
          else if( !id ) 
          {
            // this.data = void 0
            //TODO: this works buggy in values --- void 0 does not update data, maybe just use false for now
            console.log('base.mockdata')
            this.data = base.mockdata
          }
        }
      , data: {
          //mockdata on start can break everything down
          val: base.mockdata ,
          set:function( val ) {
            var user = this

            // if(!this.first) {
              // this.first = true
            // } else {

            if(user.instances && user.instances.length) {
              // console.error ('-- tmp fix data on base switch to instance[0]' )
              //TODO: this is a hacky solution! fix later
              user = user.instances[0]
            }

            if( val.from.cloud  ) 
            {
              if( user.___c !== val.from ) 
              {
                user.initialised = null
                user.___c = val.from
                for(var key in user.on.user) {
                  user.on.user[key].call( user, key )
                }
                user.initialised = true
              }
            }
            else 
            {
              if( user.___c === false ) return
              user.___c = false
              for(var key in user.on.user) {
                user.on.mock[key].call( user, key )
              }
              user.initialised = null
            }
          }
          // }
        }
      }
    )

})

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js":[function(require,module,exports){
require('../../value/flags/self')
require('../../value/flags/process')
require('../../value/flags/util')
  //TODO: clean these to work /w inject

var util = require('../../util'),
  Value = require('../../value'),
  Base = require('../../base'),
  Data = require('../../data'),
  vObject = require('../../object').inject(
    require('./origin')
  ),
  timestamp = require('monotonic-timestamp'),
  _subscriptions = {},
  MockData = require('./mockdata'),
  mockdata = new MockData({})
  // make mockdata vailable

var _extend = Base.prototype.extend

var user = new Base({
  defaultType: require('./type')
})

user.define({
  subscriptions: {
    get: function () {
      return _subscriptions
    },
    set: function (val) {
      if (val) util.merge(_subscriptions, val)
    }
  },
  mockdata: {
    get: function () {
      return mockdata
    },
    set: function (val) {
      if (val) mockdata.merge(val)
    }
  },
  on: {
    value: {
      mock: {},
      user: {}
    }
  }
, extend: function( settings ) {

    if(settings.mock) {
      this.mockdata = settings.mock
    }

    var ret = _extend.apply(this, arguments)

    if(settings.val !== void 0) {
      this[settings.name] = settings.val
    }

    if( settings.on ) {

      if( typeof settings.on === 'function' ) {
        settings.on.call( this, settings.name ) 
      } else {
        if( this.data && this.data.cloud ) {
          settings.on.user && settings.on.user.call( this, settings.name ) 
        } else {
          settings.on.mock && settings.on.mock.call( this, settings.name ) 
        }
      }    
    }

    return ret
  }
})

// user

exports.extend = util.extend(
  require('../cloud'),
  function (base) {
    var appuser = base.user = new user.Class().inject(
      require('./set'),
      require('./id')
      //inject pas op extend???
    )
    appuser.parent = base
    appuser.cases = base.cases
    appuser.cloud = base.cloud
  }
)
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","../../value/flags/self":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js","../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js","./id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/id.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","./origin":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/origin.js","./set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/set.js","./type":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/type.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js":[function(require,module,exports){
var util = require('../../util')
  , Data = require('../../data')

module.exports = exports = Data.new()  

util.define( exports,
'get', function( val, set, notself ) {
  return this.path
  ( (val instanceof Array) ? val : String(val).split('.')
  , set !== void 0 ? set : {}
  , false
  , false
  , false
  , false
  , true
  , !notself
  )
})


},{"../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/multiscreen/index.js":[function(require,module,exports){
var util = require('vigour-js/util'),
  Value = require('vigour-js/value'),
  cases = require('vigour-js/browser/cases'),
  Data = require('vigour-js/data').inject(
    require('vigour-js/data/selection')    
  ),
  Compound = require('vigour-js/object/compound'),
  events = require('vigour-js/browser/events'),
  ua = require('vigour-js/browser/ua'),
  raf = require('vigour-js/browser/animation/raf')

var VObject = require('vigour-js/object')
VObject.inject(
  require('vigour-js/value/length')
)

var INACTIVE = typeof window !== void 0 && window.INACTIVE

var deviceIsCandidate = /(desktop)|(tv)|(cast)|(tablet)|(airplay)/i
cases.$isCandidate = deviceIsCandidate.test(ua.device)

var deviceIsTvLike = /(tv)|(cast)|(airplay)/i

require('vigour-js/value/flags/process')

exports.extend = util.extend(function (user) {

  var content = user.parent.inject(require('../../content')).content

  content.on('self', function() {
    if( user.token.val ) {
      if(user.receiver.media.val && user.receiver.media.from !== user.receiver.media ) {
        if(user.receiver.media.from!== content.get( user.receiver.media.from._contentPath )) {
          // console.error('lets go change it!', user.receiver.media)
          user.receiver.media.$userOrigin = content.get( user.receiver.media.from._contentPath )
        }
      }
    } 
  })

  // extend basic properties
  user.extend({
    receiver: {
      mock: {
        receiver: {
          volume: 1,
          media: false,
          playing: false
        }
      },
      val: {
        media: {
          $bubble: {
            references:{
              $lte:1
            }
          },
          defer:function(update){
            var playing = this._parent.playing
            if(playing && !this.from.val) playing.from.val = false
            update()
          }
        }
      },
      subscription: {
        receiver: {
          volume: true,
          playing:true,
          media: {
            $: true
          }
        }
      },
      on: {
        mock: setMock_receiver,
        user: setUser_receiver
      }
    },
    clients: {
      subscription: {
        clients: {
          $: {
            $: true
          }
        }
      },
      on: {
        mock: setClients,
        user: setClients
      }
    },
    candidates: { val: {} },
    siblings: { val: {} },
    receiverClient: {
      val: {},
      on: {
        mock: setMock_receiverClient,
        user: setUser_receiverClient
      },
      subscription: {
        receiverClient:{
          $: true  
        }
      }
    },
    activeClient: {
      val: {},
      mock: {
        activeClient: true
      },
      subscription: {
        activeClient:{
          $: true  
        }
      },
      on: {
        mock: setMock_activeClient,
        user: setUser_activeClient
      }
    }
  })
  
  // extend devices (needs siblings)
  user.extend({
    devices: {
      val: new Compound(user.siblings)
    }
  })
  
  // extend case values
  user.extend({
    hasReceiver: {
      val: {
        val: user.receiverClient,
        transform: function(val, cv) {
          var endpoint = user.receiverClient.from
          return (
            endpoint && !endpoint._removed &&
            endpoint.cloud && endpoint._path[0] === 'clients'
          ) || 0
        }
      }
    },
    isReceiver: {      
      val: {
        defer: function(update, args){
          var origin = args[2] || this._updateOrigin
          if(!origin || 
             !(origin._prop || origin._name === 'receiverClient')
            ) {
            // console.log('block update', origin)
            return true
          }
          // console.log('no block')
          var stamp = args[1]
          if(stamp !== 'cleanup') {
            if(user._handleOldIsReceiver) {
              if( user._wasReceiver && 
                  !user.hasReceiver.val &&
                  !user.isActive.val
                ) {
                // console.error('i was receiver for this guy', user.data._val.raw)
                user.setReceiver(user.cloud.client.from)
              }
              user._handleOldIsReceiver = null
            }
            this.clearCache()
            user._wasReceiver = this.val
          }
          update()
        },
        val: user.receiverClient,
        transform: function(val, cv) {
          var endpoint = user.receiverClient.from
          return (
            endpoint && !endpoint._removed &&
            endpoint.cloud && endpoint === user.cloud.client.from
          ) || 0
        }
      }
    },
    hasCandidates: { 
      val: { 
        val: user.candidates.$length,
        $convertType: 'boolean'
      }
    },
    hasDevices: {
      val: { 
        val: user.devices.$length,
        $convertType: 'boolean'
      }
    },
    isActive: {
      val: {
        defer: function(update, args){
          // console.log('----- isActive check dat!')
          var origin = args[2] || this._updateOrigin
          if(!origin || 
             !(origin._prop || origin._name === 'activeClient')
            ) {
            // console.log('no blockit', 
            //   origin._path,
            //   origin,
            //   '\nval:', args[0]
            // )
            update(true)
            // return true
          }
          var stamp = args[1]

          if(stamp) {
            if(stamp !== 'cleanup') {
              if(user._handleOldIsActive) {
                if( user._wasActive && 
                    !( user.activeClient.$userOrigin && 
                       user.activeClient.$userOrigin._val
                     )
                  ) {
                  // console.error('i was activeClient for this guy RESET')
                  user.activeClient.$userOrigin = user.cloud.client._val
                }
                user._handleOldIsActive = null
              }
              this.clearCache()
              user._wasActive = this.val
            }
            
          }
          // console.log('go update!')
          update()
        },
        val: user.activeClient,
        // $bubble: {
        //   references: 2
        // },
        transform: function (c, cv) {
          var endpoint = user.activeClient.from
          return (
            (endpoint && endpoint.val === true) ||
            endpoint === user.cloud.client.from
          ) || 0
        }
      }
    },
    setReceiver: {
      type: false,
      val: function(client) {
        var user = this
        // console.error('setReceiver called lol')
        client = client.from
        if(!client) return

        var casttype = client.cast && client.cast.val

        if(casttype) {
          // console.log('setReceiver! user.cast[casttype]', user.cast[casttype])
          // console.log('setReceiver! user.cast[casttype].setReceiver', user.cast[casttype].setReceiver)
          user.cast[casttype].setReceiver(client)
        } else {
          client.set('token', user.token.val)
          user.receiverClient.$userOrigin = client
        }
      }
    }
  })
  
  // DEBUG:
  // user.activeClient.on(function(){
  //   console.error('activeClient happenin!', this.from && this.from.toString())
  // })
  
  // user.hasReceiver.on(function(){
  //   console.error('lol hasReceiver listener fires! val:', this.val)
  // })
  // user.isReceiver.on(function(){
  //   console.error('lol isReceiver listener fires! val:', this.val)
  // })
  // user.activeClient.on(function(){
  //   console.error('lol activeClient listener fires! val:\n', this.from.toString())
  // })

  // listeners:

  // on activity: make me activeClient
  if(!cases.$isChromecast && !INACTIVE) {
    var activeEvent = cases.$isTv ? 'keydown' : 'down'
    events.document.addEvent(activeEvent, function () {
      if( user.cloud.client._val &&
          !(cases.$isFullscreen && cases.$isFullscreen.val)
        ) {
        user.activeClient.$userOrigin = user.cloud.client.from
      }
    })  
  }
  

  // re-establish old setup after reconnect
  user.cloud.on('welcome', function(){
    if(user.cloud._status > 2){
      user._handleOldIsActive = true
      user._handleOldIsReceiver = true
      user.cloud.data.once(function(){
        // console.log('ok go reset dat old situation')
        user.isActive.update()
        user.isReceiver.update()
      })
    }
  })

  /*
  * when I become active, unset myself as receiver
  * and if not iplogin > select new receiver
  */
  user.isActive.on(true, function() {
    var isReceiver = user.isReceiver.val
    // console.log('isReceiver?!', isReceiver)

    if(user.hasCandidates.val) { //  && !user.iplogin.val
      // console.log('user.hasCandidates.val', user.hasCandidates.val)
      // console.log('isReceiver', 
      //   isReceiver, 
      //   '\nuser.hasReceiver.val', user.hasReceiver.val
      //   )
      if(isReceiver || !user.hasReceiver.val) {
        // console.log('ok select receiver because i became active!')
        var newreceiver = selectReceiver(user, user.candidates)
        if(newreceiver) {
          // wait for my own isactive set
          raf(function(){
            user.setReceiver(newreceiver)
          })
        } else if(isReceiver) {
          user.receiverClient.$userOrigin = null
        }
      }
    } else if(isReceiver){
      user.receiverClient.$userOrigin = null
    }
  })  
  

  // when receiver leaves, I might have to become the new receiver
  if(cases.$isCandidate) {
    user.hasReceiver.on(0, function(val, stamp, from){
      if(stamp === user.cloud.stamp) {
        // console.log('yes update is ok')
        if(!user.isActive.val){
          // wait for all removes to finish
          raf(function(){
            // select receiver
            // console.log('ok select receiver because receiver left!')
            var newreceiver = selectReceiver(user, user.clients)
            // if its me > update user
            if(newreceiver === user.cloud.client.from) {
              user.setReceiver(newreceiver)
            } else {
              // console.log('i am not new receiver! newreceiver is', newreceiver && newreceiver.raw)
            }
          })
        }
      } else {
        // console.log('update not from the cloud')
      }
    })
  }

  // when a tv joins, I might want to grab it
  if(!user.iplogin.val){
    user.candidates.on(function(val, stamp, from, remove, added){
      // console.error('-------- check for tv joiner\n',
      //   'user.hasCandidates.val', user.hasCandidates.val, '\n',
      //   'user.isActive.val', user.isActive.val, '\n',
      //   'user.initialised', user.initialised
      // )
      // console.log(user.candidates.toString())
      if(user.hasCandidates.val && user.isActive.val &&
          user.initialised
        ) {
        grabTV(user)
      } else {
        // console.error('no candidates')
      }
    })
  }

  
  // make cases
  cases.$isActive = user.isActive
  // cases.$hasCandidates = user.hasCandidates
  cases.$hasDevices = user.hasDevices
  cases.$hasReceiver = user.hasReceiver
  cases.$isReceiver = user.isReceiver


})

// clients
function updateClients() {
  this.clients.update()
}

function setClients () {
  var user = this
  var linked = user.data._val

  // clients
  var linkedclients = linked.get('clients')
  // cache old, set new, and remove listener if cached old
  var oldclients = user.clients._val
  user.clients = linkedclients
  linkedclients.addListener([updateClients, user], true)
  if( oldclients ) {
    oldclients.removeListener(updateClients, user)
  }

  // candidates
  // cache previouse value
  var oldcandidates = user.candidates && user.candidates._val
  // make candidates
  var candidates = user.candidates = new Data( linkedclients, {
    condition: { 
      device: {
        $contains: '(desktop)|(tv)|(cast)|(tablet)|(airplay)'
      },
      key: {
        $exists: true,
        $ne: this.cloud.clientid
      }
    }
  })
  // add listener because of reasons
  candidates.on(function(){
    user.candidates.update()
  })
  // clean up dat old selection
  if(oldcandidates) {
    oldcandidates.remove()
  }
  
  // siblings
  // cache previouse value
  var oldsiblings = user.siblings && user.siblings._val
  // make siblings
  var siblings = user.siblings = new Data( linkedclients, {
    condition: {
      key: {
        $exists: true,
        $ne: this.cloud.clientid
      }
    }
  })
  // add listener because of reasons
  siblings.on(function(){
    // console.log('update on candidates > update user.candidates')
    user.siblings.update()
  })
  // clean up dat old selection
  if(oldsiblings) {
    oldsiblings.remove()
  }
}

// activeClient

var acRemoveTarget
var acAddedTarget

function setMock_activeClient () {
  // console.log('---------- setMock_activeClient!')

  var user = this

  if(acRemoveTarget) {
    acRemoveTarget.removeListener(acRemoveCheck, user)
    acRemoveTarget = null
  }
  if(acAddedTarget) {
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
  }

  var linked = user.data._val

  user.activeClient = linked.get('activeClient', {})
  user.activeClient.$userOrigin = user.cloud.client.from

}



function setUser_activeClient () {
  // console.log('---------- setUser_activeClient!')

  var user = this

  // console.log('dat activeClient:', 
  //   user.data._val.activeClient
  //   ? 'yes activeclient\n' + user.data._val.activeClient.toString()
  //   : 'no activeClient in ma new user!!\n' + user.data._val.toString()
  // )

  if(acAddedTarget) {
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
  }
  
  var linked = user.data._val
  var linkedRef = linked.get('activeClient', {})

  if(acRemoveTarget) {
    acRemoveTarget.removeListener(acRemoveCheck, user)
  }
  acRemoveTarget = linkedRef
  acRemoveTarget.addListener([acRemoveCheck, user], true)

  user.activeClient = linkedRef
  
  // console.error('USERSWITCH ACTIVECLIENT')
  if(!INACTIVE){
    if(cases.$isTv) {
      // console.error('IM TV USERSWITCH WAT TO DO')
      // user.activeClient.$userOrigin = user.cloud.client.from
      // TODO: fix this:
      var activeClient = linkedRef.from
      // console.error('activeClient is', activeClient)
      // console.log('i am', user.cloud.client.from.raw)
      if(!(activeClient && activeClient._name !== 'activeClient')) {
        // console.error('set maself active')
        // console.error('SET ME TO DAT activeClient (TV)')
        user.activeClient.$userOrigin = user.cloud.client.from
      }else {
        // console.log('udpate activeClient because do it')
        user.activeClient.update()
      }
    } else if(!cases.$isChromecast) {
      // console.error('SET ME TO DAT activeClient')
      user.activeClient.$userOrigin = user.cloud.client.from
    }
  }
  

  if(user.hasCandidates.val) {
    // console.log('check for tv to grab on setUser_activeClient')
    grabTV(user)
  }

  user.activeClient.update()

}
function acRemoveCheck (firer, val, stamp, from, remove) {
  var user = this
  if(firer._removed) {
    if(acAddedTarget) {
      acAddedTarget.removeListener(acAddedCheck, user)
    }
    acAddedTarget = firer._parent
    acAddedTarget.addListener([acAddedCheck, user], true)
  }
}
function acAddedCheck (firer, val, stamp, from, remove, added) {
  var user = this,
    linkeduser = firer

  if(linkeduser.activeClient){
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
    
    acRemoveTarget = linkeduser.activeClient
    acRemoveTarget.addListener([acRemoveCheck, user], true)

    user.activeClient = linkeduser.activeClient
  }
}

// receiverClient
var rcAddedTarget
var rcRemoveTarget

function setMock_receiverClient () {
  var user = this

  if(rcAddedTarget) {
    rcAddedTarget.removeListener(rcAddedCheck, user)
  }
  if(rcRemoveTarget) {
   rcRemoveTarget.removeListener(rcRemoveCheck, user) 
  }

  var linked = user.data._val
  user.receiverClient = linked.get('receiverClient', false)
}
function setUser_receiverClient () {
  var user = this

  if(rcAddedTarget) {
    rcAddedTarget.removeListener(rcAddedCheck, user)
    rcAddedTarget = null
  }

  var linked = user.data._val
  var linkedRef = linked.get('receiverClient', {})

  if(rcRemoveTarget) {
    rcRemoveTarget.removeListener(rcRemoveCheck, user)
  }
  rcRemoveTarget = linkedRef
  rcRemoveTarget.addListener([rcRemoveCheck, user], true)

  user.receiverClient = linkedRef

  if(cases.$isTv) {
    // set tv to receiver if activeclient and no receiver
    var activeClient = user.activeClient.from
    if( activeClient && activeClient.__t === 2 &&
        activeClient !== user.cloud.client.from &&
        !user.hasReceiver.val
      ) {
      user.setReceiver(user.cloud.client.from)
    }
  } else if (cases.$isChromecast) {
    // always set chromecast to receiver
    user.setReceiver(user.cloud.client.from)
  }

}
function rcRemoveCheck (firer, val, stamp, from, remove) {
  var user = this
  if(firer._removed) {
    if(rcAddedTarget) {
      rcAddedTarget.removeListener(rcAddedCheck, user)
    }
    rcAddedTarget = firer._parent
    rcAddedTarget.addListener([rcAddedCheck, user], true)
  }
}
function rcAddedCheck (firer, val, stamp, from, remove, added) {
  var user = this,
    linkeduser = firer

  if(linkeduser.receiverClient){
    rcAddedTarget.removeListener(rcAddedCheck, user)
    rcAddedTarget = null

    rcRemoveTarget = linkeduser.receiverClient
    rcRemoveTarget.addListener([rcRemoveCheck, user], true)

    user.receiverClient = linkeduser.receiverClient
  }
}
// receiver
function setMock_receiver () {
  var user = this
  linkReceiver(user)
}
function setUser_receiver () {
  var user = this
  linkReceiver(user)
}
function linkReceiver (user) {
  var linked = user.data._val
    , linkedreceiver = linked.get('receiver', {})

  user.receiver = {
    volume: linkedreceiver.get('volume', 1),
    media: linkedreceiver.get('media', false),
    playing: linkedreceiver.get('playing', false)
  }
}

function selectReceiver(user, list) {
  // console.error('\n\n=========================selectReceiver!!!\n\n')
  while(list && list.__t === 4 && !list._filter){
    list = list._val
  }
  if(!list) {
    return console.error('could not determine list to select from')
  }
  var winner
  list.each(function(){
    var client = this._val
    // sanity check
    if(!client || client._removed || !client.device) {
      return console.error('bad client', 
        'path:', client && client._path,
        'client:', client && client.raw || client
      )
    }
    // skip if client is the activeClient
    if(client === user.activeClient.from) {
      return
    }
    var device = client.device.val
    // skip if client is not a candidate
    if(!deviceIsCandidate.test(device)) {
      return
    }

    // skip if client is in use by other user
    if(client.token && client.token.val !== user.token.val) {
      return
    }
    // client is a possible winner
    winner = client
    // stick if client is tv-like
    if(deviceIsTvLike.test(device)) {
      return true
    }
  })
  // console.error('\n\n========================= winner:',winner,user.cloud.clientid,'\n\n')

  return winner
}

function grabTV(user){
  // console.error('============= grabTV!')
  user.candidates._val.each(function(){
    var candidate = this.from
    // console.error('candidate', 
    //   'deviceIsTvLike', deviceIsTvLike.test(candidate.device.val),
    //   '!candidate.token', !(candidate.token && candidate.token.val),
    //   'candidate.token', (candidate.token && candidate.token.val)
    // )
    if(candidate.device.val === 'tv' &&
        !(candidate.token && candidate.token.val)
      ) {
      // console.error('grab dat!')
      candidate.set('token', user.token.val)
      if(!user.hasReceiver.val) {
        user.setReceiver(candidate)
      }
    }
  })
}

// function log(){
//   console.log('--------------------\n\n\n\n')
//   console.log(window.FLAG,':')
//   console.log.apply(console, arguments)
//   console.log('\n\n\n\n--------------------')
// }
// log.start = function(flag){
//   console.log('\n\n\n====================== START',
//     window.FLAG ? window.FLAG : '', flag, '\n\n'
//   )
// }
// log.end = function(flag){
//   console.log('\n\n====================== END',
//     window.FLAG ? window.FLAG : '', flag, '\n\n'
//   )
// }

},{"../../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/object/compound":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/compound.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","vigour-js/value/length":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/navigation.js":[function(require,module,exports){
var util = require('vigour-js/util')
var vObject = require('vigour-js/object')
var MockData = require('./mockdata')

require('vigour-js/value/flags/process')

//nav is taking care of: 
// double updates on the same thing with the same value (syncing in it trough the cloud)
// updating navigation
// mock and user data, subscriptions

//TODO: add view

// content en switch op content pakken
//   page
//   content
// ook bubble: 1 op alle dingen
// function updateNavigation

exports.extend = util.extend
( function( user ) {

  var content = user.parent.inject(require('../content')).content

  content.on('self', function() {
    var nav = user.navigation
    var content = this
    var contentNav = nav.content.from
    var misc = nav.misc.from

    if(contentNav._contentPath) {
      nav.content.$userOrigin.val = content.from.get(contentNav._contentPath) //DIT IN NAVIGATION
    }

    if(misc._contentPath) {
      nav.content.$userOrigin.val = content.from.get(misc._contentPath) //DIT IN NAVIGATION
    }
  })

  user.define({
    updateNavigation: function( key ) {
      if(this.navigation.last && this.navigation.last.$userOrigin) {
        key = key || this.navigation.last.$userOrigin.get('key').val
        if( typeof key === 'string' ) {
          this.navigation[key]._update( this.navigation[key]._val._val , 'l'+Math.floor(Math.random()*9999) )
          return
        }
      }
      this.navigation.page.$userOrigin = 'discover'
    }
  })

  user.extend({
    navigation: {
      mock: {
        navigation: 
        { content: false
        , page: false 
        , misc: false
        , last: { key: 'page', time: 0 }
        }
      },
      subscription: {
        navigation: 
        { content:true
        , page:true
        , misc: true
        , last: 
          { key:true
          , time:true
          }
       }
      },
      val: 
      { page: { defer: deferNavigation }
      , content: { defer: deferNavigation }
      , misc: { defer: deferNavigation }
      },
      on: {
        user: function navigationToUserData( key ) {

          resolveLastListener(this)
          
          this.navigation = {
            last: this.data._val.get( [ key, 'last' ] )
          }
          this.__first = true

          var nav = this.navigation
            , userData = this.data.$userOrigin

          this._lastupdate = function lastUpdateUser( val, stamp, from ) {
                          // console.log('hey this should do the update')

            if( this.key && nav[this.key.val] )  
            {

              // console.log('hey this should do the update!1')

              nav[this.key.val].$userOrigin._update( void 0, 'l'+stamp  )
              nav.update()
            }
          }

          nav.last.from.on(this._lastupdate)

          // console.error('KEY',key)
          // debugger

          this.navigation = 
          { page: userData.get( [ key, 'page' ], 'discover' ) 
          , content: userData.get( [ key, 'content' ] )
          , misc: userData.get( [ key, 'misc' ] )
          }

          if(nav.last.from.key) {
            // debugger
            nav.last.from._update( void 0, vObject.stamp() )
          } else if(!nav.last.from.key) {
            //no page switch to default ( make a default possilbe )
            nav.page.$userOrigin = 'discover'
          }

        },
        mock: function navigationToMockData() {

          resolveLastListener(this)
    
          var nav = this.navigation

           var mock = this.mockdata.navigation
            , set = 
              { page: mock.page
              , content: mock.content
              , misc: mock.misc
              // , last: mock.last 
              }

          this.navigation = { last: mock.last }

          //TODO: this is a temp fix should go back to page you logout from!
          if(this.__first) {
            mock.page.val = 'discover'
          } 
    
          this._lastupdate = function lastUpdateMock( val, stamp, from ) {
            if( nav[this.key.val] ) 
            {
              nav[this.key.val].$userOrigin._update( void 0, 'l'+stamp  )
            }
          }

          nav.last.from.on( this._lastupdate )
          // var nav = hoe kom ik hier aan mn user???
          // console.error('?????',this.token._lval, this.token.val)
          // need to use setter (not nav ref)
          this.navigation = set
        }
      }
    }
  })

  function resolveLastListener( user ) {
    if( user._lastupdate 
        && user.navigation.last 
        && user.navigation.last.from !== user.navigation.last
     ){
      user.navigation.last.from.removeListener(user._lastupdate)
      user._lastupdate = null
     }
  }      

  function deferNavigation( update, args ) {
    if( args[1] && args[1][0] === 'l' && 
      this._name === this._parent.last.from.key.val
    ) {

      this.clearCache()
      //TODO: more specific may be too many updates???
      // console.log('lezz update it', this._parent._path, this._path)

      update()

      // this._parent._update.apply( this._parent, args )


    } 
    else 
    {
      update( true )
    }
  } 

})

},{"../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/origin.js":[function(require,module,exports){
//userOrigin
var util = require('../../util')
  , MockData = require('./mockdata')
  , timestamp = require('monotonic-timestamp')

exports.extend = util.extend( function( vObject ) {

  var _coreSet = vObject.set
    , _fromUser = function( obj ) {
        var val = obj
          , nav
          , last

        while (val && !val._removed && val instanceof vObject) {

          if( val._parent && val._parent._prop && val._parent._prop.name === 'navigation' ) {
            nav = val
          } 

          if( ( val.cloud && val._path[0] === 'users' ) 
              || val instanceof MockData 
            ) {
            return [ val, nav ]
          }
          last = val;
          val = val._val;
        }

        var result = last && !last._removed && last !== obj
          ? last 
          : false

        return [ result, nav ]

      }

  util.define( vObject, 
    '$userOrigin', {
    set: function( val ) {

      var search = _fromUser(this)
        , found = search[0] //|| this
        , nav = search[1]
        , same

      if(!found) {
        var propname = this._prop && this._prop.name

        if(propname) {
          // console.error('>>>>>>>> making and linking', propname)

          var user = this._caller,
            linkeduser = user.data._val

          if(!linkeduser) {
            console.error('????', val)
            debugger
          }

          found = linkeduser.get(propname, {})
          this.val = found
        }
      } else {
        // console.error('FOUND', this._prop && this._prop.name, found._path, found.raw, found)
      }

      if(!found) {

        // console.error('no user but do from')
        // return _coreSet( this.from, val )

        throw new Error('cannot find correct $userOrigin for '+ ( this._name || this._prop && 'propety '+this._prop.name ) )
      }

      _coreSet.call( found , val)

      if(nav && nav._name ) {
        nav._parent.last.from.val = 
        { time: timestamp()
        , key: nav._name
        }
      } 

    },
    get: function() {
      return _fromUser( this )[0] //|| this
    }
  })
})
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , user = require('./')
  , vObj = require('../../object')

exports.extend = util.extend( 
function( base ) {

  function setUser(i) {
    //make these 2 more defualt
    // console.log(i)
    // console.log( 'swtich to user', i, this.data._val )
    this[i] = this.data.$userOrigin.get( i, this[i]._prop.$default )
  }

  function setMock(i) {
    // console.log( 'swtich to mock', i, this.mockdata[i] )
    this[i] = this.mockdata[i]
  }

  base.define({
    _set: function(val, i ) 
    {
      if ( this[i] instanceof vObj ) 
      {
        //TODO: torough testing
        this[i].val = val[i]
      } 
      if (typeof this[i] === 'function') 
      {
        if (val[i] instanceof Array) 
        {
          this[i].apply(this,val[i])
        } else 
        {
          this[i](val[i])
        }
      } 
      else 
      {
        if ( this.isProperty( i, val ) ) {
          // console.warn('this is a property!', i , val )
          this[i] = val[i]
        } else {
          if( this[i] ) 
          {
            // merge? check ook voor cloud bijvoorbeeld
            this[i] = val[i]
          }
          else 
          {
            // console.error('NOW LETS MAKE A BASIC TYPE', i, this)

            var mock = {}

            mock[i] = val[i]

            var subscription = {}
            subscription[i] = true

            // this.mockdata = mock

            this.extend({
              name:i
            , mock: mock
            , $default: val[i]
            , subscription: subscription //maybe do this if not specified
            , on: {
                mock: setMock
              , user: setUser
              }
            })

            //dit beter---- moet namelijk niet val[i] worden maar mockdata (of meteen switchen naar userData)
            
           

          }
        }

        // console.log('hey', i, this[i] )
        
      }
    }
  })

})
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/token.js":[function(require,module,exports){
var util = require('../../util')
  , Value = require('../../value')
  , cases = require('../../browser/cases')

require('../../value/flags/process')

//TODO: url error on start up (set from cloud)
exports.extend = util.extend
( function( base ) {

  base.define({
    updateId: function( res ) {
      this.id = res instanceof Array ? res[ res.length -1 ] : res
      
      //hier ff voor navigation
      //get last?
    }
  , authenticate: function authenticate( _this, request, val, update ) {
      var user = this
        , cloud = user.cloud

      if(cloud.params.fastLogin && typeof localStorage !== "undefined"){
        var userId = localStorage.getItem('userId')
        if(userId){
          request.id = userId
        }
      }
      // console.log('go cloud.authenticate!!')
      cloud.authenticate( request, function( res ) {
        
        if(res.error && typeof localStorage !== "undefined"){
          localStorage.removeItem('userId')
        }
        _this.clearCache()

        if(val !== _this.val){
          // console.error('\n\n\ndid a fast re-login! -- double check')
        }

        if( res.error || !_this.val ){
          _this.val = false
          user.id = false
          update()
          if( res.error ){
            console.error('authenticate error:', res.error)
          }else{
            if(! (user.iplogin && user.iplogin.val) ){
              user.cloud.emit('logout', res )

              if(typeof localStorage !== "undefined" ){
                localStorage.removeItem('userId')
              }
            } 
            // console.error('token is set to false while authenticating (logout! -- need to get a method to break it while in progress)')
          }
        }else{
          // console.log('AUTH SUC6', user, res )
          //dit is ook wrong completely! -- dit alleen doen met een usertoken!!!!
          // anders wachten tot een overtake actie
          if( _this.val !== true ) {
            user.updateId( res )
          }

          if(cloud.params.fastLogin && typeof localStorage !== "undefined"){
            var userId
            if(res instanceof Array)
              userId = res[res.length-1]
            else
              userId = res
            localStorage.setItem('userId', userId)  
          }

          if(user.iplogin && user.iplogin.val) {
            // console.log('TV LOGIN SUCCESS! maybe go make maself dat user')
            // console.log('>>> token', user.token.val)
            
          }
          
          update()
        }
      })
    }
  })
  
  // console.log('????????????? set iplogin', cases.$isTv || cases.$isChromecast)
  // base.iplogin = cases.$isTv || cases.$isChromecast
  
  base.extend(
  { //primary
    iplogin: { val: cases.$isTv || cases.$isChromecast },
    token:{
      // TODO: when IP based connectivity is fixed this is not needed
      subscription: {
        token: true
      },
      val:{
        transform: function( val, cv ) {
          return ( cv instanceof Object ) ? false : cv
        },
        defer:function( update, args, tempdefer ) {

          if(args[0] && args[0].defer) return true

          var token = this
          var user = token._caller

          // console.error('TOKEN SET!xxx', token)

          user.cloud.connected.is(true, function() {
            var oldval = args
              , val = token.val
              , userId = user.id && user.id.val
              , iplogin = user.iplogin && user.iplogin.val

            // if( user.iplogin && user.iplogin.val ){
            //   iplogin = true
            // }
            //DOUBLE CHECK --- this was in there to allways make sure this stuff did not happen...
            // if( user.activeClient && user.activeClient.$userOrigin && user.activeClient.from === user.client.from  ) {
              // console.log('mc dirty lets fix this here! on logout set false to be certain', user.activeClient.$userOrigin )
              // user.activeClient.$userOrigin = false
            // }

            token.clearCache()

            // console.error('token is set!', val)
            // console.log('token is set!', iplogin)

            if( userId && !iplogin ){
              // console.log('LOGOUT ---> EMIT'.red.inverse, userId )
              var _last = user.cloud.logout( userId )
              if(typeof localStorage !== "undefined"){
                localStorage.removeItem('userId')
              }
            }

            if( val ){

              var url = user.cloud.api.get('auth')

              var request = 
              { url: url
              , subs: user.subscriptions
              , token: val
              //TODO: also add tv
              }
              , auth = user.__authenticated__

              if( iplogin ){
                // this is all tv vibes
                if( val === true ) {
                  delete request.token
                }
                request.tv = true

                if( !auth ){
                  // console.log('IPLOGIN FIRST TIME POP DAT AUTHENTICATE')
                  user._authrequest = request
                  user.authenticate( token, request, val, update )
                  user.__authenticated__ = true
                }else{
                  var users = user.cloud.data.get('users')
                    , set

                  // console.error('IPLOGIN USERSWITCH')
                  // find the user I should switch to
                  users.each(function( key ) {

                    // console.log('>> HAVE USER', this)
                    var clouduser = this

                    if(clouduser.token && clouduser.token.val === token.val) {
                      // im switching to this user
                      set = clouduser._name
                      // console.log('switch to this usert!')
                    } else {
                      if(
                        clouduser.receiverClient && 
                        clouduser.receiverClient.from === user.cloud.client.from
                        ){
                        // console.error('this other user has me as receiverClient, better remove')
                        clouduser.receiverClient.$userOrigin = null
                      }
                      if(clouduser.activeClient && 
                        clouduser.activeClient.from === user.cloud.client.from
                        ){
                        // console.error('this other user has me as receiverClient, better remove')
                        clouduser.activeClient.$userOrigin = null
                      }
                    }
                  })
                  if(!set) {
                    user.id = false
                  }else{
                    user.id = set

                  }
                  update() 
                }

              }else{
                user._authrequest = request
                user.authenticate( token, request, val, update )
              }
            }else{
              user.id = false
              update() 
            }
          })
        }
      }
    },
    localStorageToken: {
      val: {
        defer:function(update, args) {
          var user = this._caller
          if(!user._readLocalStorage && typeof this.val === 'string') {
            user._readLocalStorage = this.val
            var token = localStorage.getItem(user._readLocalStorage)
            if(token && token !== 'true') {
              user.token = token
            }
            user.token.on(function() {
              var tokenval = this.val
              if(typeof tokenval === 'string') {
                localStorage.setItem(user._readLocalStorage, tokenval)
              } else {
                localStorage.removeItem(user._readLocalStorage)
              }
            })
            update()
          } else {
            update(true)
          }
        }
      }
    }
  })

  // base.token = false

  base.cases.$isLoggedIn = new Value(
  { val: base.token
  , transform:function(val, cv) {
      if(cv === true) return 0
    }
  })

  var myclient = base.cloud.client

  myclient.on(function(val, stamp, from){
    // console.log('something happened on my cloud client!')
    origin = from || this._updateOrigin
    if(stamp === base.cloud.stamp) {
      var cloudclient = myclient.from
      if(cloudclient.token){
        // console.log('-------- token on user is now', base.token.val, 'set with', cloudclient.token.val)
        base.token.val = base._authrequest.token = cloudclient.token.val

        // console.log('-------- did set token on user')
      }
    }
  })

  base.token._name = 'token'

})




},{"../../browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/type.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , Value = require('../../value')//.new()
  , objectSet = require('../../object').set
  , util = require('../../util')

// Value.inject(require('./listen_fix'))

module.exports = {
  type: Value,
  create: function(val, prop, settings, noupdate) {

    // console.log('create it', val, settings )
    var v = new Value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings) {

      if (!settings._vset) {

        //can also add a thing to set on get by default?

        if(settings.mock) {
          //if not set add some efficiency plz
          this.mockdata = settings.mock
        }

        if(settings.subscription) {
          this.subscriptions = settings.subscription
        }

        if(settings.on) {
          if( typeof settings.on === 'function' ) {
            this.on.mock[settings.name] = settings.on
            this.on.user[settings.name] = settings.on
          } else {
            if(settings.on.mock && !this.on.mock[settings.name]) {
              // console.log(base, base.on)
              this.on.mock[settings.name] = settings.on.mock
            }
            if(settings.on.user && !this.on.user[settings.name]) {
              this.on.user[settings.name] = settings.on.user
            }
          }
        }

        settings._vset = function(stamp, from, remove, cval) {
          
          var base = this._caller
                || this._base
                || this


          //if !base --
          // if(!base.)

          if(settings.set) {
            settings.set.call(
              base, this, stamp, from, remove, cval
            )
          }
        }
      }

      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  set: function(val, prop, settings) {
    // console.error('set it', val )
    this._caller = this
    return val
  },
  get: function(prop, settings) {
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/usage.js":[function(require,module,exports){
var util = require('vigour-js/util')

var vObject = require('vigour-js/object')

var MockData = require('./mockdata')

var cases = require('vigour-js/browser/cases')

var Data = require('vigour-js/data')
      .inject( require('vigour-js/data/selection') )


require('vigour-js/value/flags/process')

exports.extend = util.extend
( function( user ) {

  var content = user.parent.inject(require('../content')).content

  user.extend({
    usage: {
      mock: {
        usage:{}
      },
      subscription: {
        usage: {
          shows: {
            $: {
              media:{
                //dit moet sowieso niet title worden! liever gewoon true of id ofzo
                $:true
              },
              favourite:true,
              timestamp:true
            }
          }
        }
      },
      on: {
        mock:function() {
          this.usage = this.mockdata.usage
        },
        user:function() {
          this.usage = this.data.from.get('usage',{})
        }
      }
    },

    watched:{
      on: {
        //mischien eigen , nieuwe selection maken alvast
        mock: function() {
          if(this.__watched) {
            this.__watched.remove()
            this.__watched = null
          }
          if(this.watched) this.watched.$empty()
          this.watched = {}
        },
        user:function() {
          var user = this
          if(this.__watched) {
            this.__watched.remove()
            this.__watched = null
          }

          var selection = this.__watched = new Data( user.usage.from.get('shows') , {
            condition: { 
              media: {
                title: {
                  $exists: true
                }
              }
            }
          })

          user.watched = {}

          selection.on(function() {
            var sets = {}

            selection.each(function(i) {
              var bla =  content.get(this._path.slice(-2))
              var obj = {}
              
              util.path(obj, bla._path, {
                img:true,
                title:true
              })

             var _cloud =  user.parent.cloud
             _cloud.subscribe(obj)

              user.watched.set(this._name, 
              { show: bla
              , media: this.media.from
              })

              user.watched[this._name].once('remove', function() {
                _cloud.unsubscribe(obj)
              })

              sets[this._name] = true
            })

            user.watched.each(function(name) {
              if(!sets[name]) {
                if(user.watched)
                this.remove()
              }
            })

            sets = false

            user.watched.update()
          })
          selection._update()

        }
      } 
    },

    favourites:{
      on: {
        //mischien eigen , nieuwe selection maken alvast
        mock: function() {
          if(this.__favourites) {
            this.__favourites.remove()
            this.__favourites = null
          }
          if(this.favourites) this.favourites.$empty()
          this.favourites = {}
        },
        user:function() {
          var user = this
          if(user.__favourites) {
            user.__favourites.remove()
            user.__favourites = null
          }
          this.favourites.$empty()
          var selection = user.__favourites = new Data( user.usage.from.get('shows') , {
            condition: { 
              favourite: true
            }
          })

          user.favourites = {}

          selection.on(function() {
            var sets = {}

            selection.each(function(i) {
              var bla =  content.get(this._path.slice(-2))

              user.favourites.set(this._name,bla)
              sets[this._name] = true
            })

            user.favourites.each(function(name) {
              if(!sets[name]  ) {
                this.remove()
              }
            })

            sets = false

            user.favourites.update()
          })
          selection._update()

        }
      } 
    }
  })

  user.extend({
    hasWatched: {
      val: {
        val: user.watched,
        transform: hasTransform
      }
    },
    hasFavourites: {
      val: {
        val: user.favourites,
        transform: hasTransform
      }
    }
  })

  var oldContent = content._val

  content.on('self', function() {
    // console.log('content is changing from', oldContent && oldContent._path, 'to', this._val._path)
    if( user.token.val ) {
      resolveWatchedMedia( user )
      user.favourites._prop.on.user.call(user)
      user.watched._prop.on.user.call(user)
    } else {
      resolveWatchedMedia( user )
      user.favourites._prop.on.mock.call(user)
      user.watched._prop.on.user.call(user)
    }
  })

  cases.$hasFavourites = user.hasFavourites
  cases.$hasWatched = user.hasWatched

})

function resolveWatchedMedia( user ) {
  user.watched.from.each(function() {
    var media = this.media && this.media.from
    if(media) {

      var newPath = user.parent.content.from._path.concat( media._contentPath )       
      var oldPath = media._path

      if( !util.compareArrays( oldPath, newPath ) ) {
        console.log('resolve', oldPath, newPath)
        this.media.val = user.parent.content.get( newPath )
      }
    }
  })
}

function hasTransform( c, cv) {
  var selection = c._parent._val
  if(selection) {
    if(selection.$length.val>0) {
      return true
    }
  }
  return 0
}
  
},{"../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js":[function(require,module,exports){
var util = require('../util')
  , Value = require('../value')
  , url = require('../browser/network/url')
  , ua = require('../browser/ua')

require('../value/flags/process')

//---------------------------------------


//---------------------------------------

exports.extend = util.extend( function( app ) {

  //use cases reference on app
  var cases = app.cases || ( app.cases = require('../browser/cases') )

  app.initialised = new Value( false )

  app.overlay = new Value( false )

  app.focusState = new Value('menu')

  app.region = new Value({ init: app.initialised })
  //browser
  //ua.browser

  app.url = ua.device === 'tv' && ua.platform === 'lg' 
        ?  new Value({defer:function(){}, params:{}, string:''}) 
        :  url 
  //ook pas op app initilised!

  app.ready = new Value()

  app.menu = new Value({ init: app.ready })

  //TODO:network
  //move network api file to here perhaps
  app.network = new Value()

  //TODO: double check this is efficient
  app.loading = new Value({ 
    init: app.ready
  , defer: function( update, args ) {
      //TODO: cached updatePath ?
      var id = this.updatePath.join('.')
      if( args[0]===false && ( (id && id === this.id) || !this.id ) ) {
        this.val = args[0]
        this.id = false
      } else if( args[0] === true ) {
        this.id = id
        this.val = true
      }
      update()
    }
    //add defered later (maybe dont show a loader for less then xxx sec) 
  })

  // '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //add localstorage

  var guessLanguage = app.guessLanguage = function guessLanguage(){
    //TODO: cordova language
    var guess = window.navigator.userLanguage
             || window.navigator.language
             || app.region.val 
    if(guess)
      return guess.slice(0,2).toLowerCase()
  }

 app.language = new Value(  
  { transform: function( val, cv ) {
      if(!cv || typeof cv !== 'string') {
        cv = guessLanguage()
      } 
      return cv ? cv.slice(0,2).toLowerCase() : false
    }
  , init: app.initialised 
  })

  app.fullscreen = new Value({ force: true })

  app.loader = new Value()

  app.volume = new Value(
  { val:1
  , transform:function(v,cv){
      // console.log('volume?',cv,isNaN(cv) ? 1 : cv)
      //TODO: use loDash for isNan
      return isNaN(cv) ? 1 : cv
    }
  })

  app.popup = new Value({ init: app.ready })

  app.preview = new Value({ init: app.ready })

  app.highlight = new Value({ init: app.ready })

  app.state = new Value({ init: app.ready })
  
  app.notification = new Value( 
  { init: app.ready  
  , force: true //TODO: make this better
  })

  app.isPlaying = new Value(
  { init: app.ready
  , val:false
  })

  app.restrictPlayback = new Value()

  //make injectable
  app.wifiOnly = new Value(
    localStorage 
    ? { val: localStorage.getItem('wifiOnly') || false
      , defer:function( update ){
          if(this._val) localStorage.setItem('wifiOnly',true)
          else localStorage.removeItem('wifiOnly')
          update()
        }
      }
    : false
  )

  app.restrictPlayback.val = 
  { val: app.wifiOnly
  , transform:function(v,cv){
      return ( cv && cases.$isNative && api.network.val !== 'wifi' )
        ? true
        : false
    }
  }

  // TODO: move this (setting case value) out of app values
  cases.$storeAvailable = new Value( 
    cases.$isNative && ( cases.$isIos || cases.$isAndroid || cases.$isWindowsMobile ) //&& window.Store
  )

})
},{"../browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../browser/network/url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js","../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('../')
  , util = require('../util')
  , inject = require('../util/inject')
// , raf = require('../browser/animation/raf')


/*
  util.define( extend, 'extensions',{val:[], setClass:true} )
*/

/**
 * Base is used as a class constructor.
 * @constructor V.Base
 * @param  {*} [val] Startvalue for new V.Base
 */
var base = V.Base = module.exports = exports = function(val) {
  this._from = this.constructor
  if (val) this.set(val)
}

exports.settings = require('./settings')

/**
 * Sets properties defined in an object.
 * Define a _set method on a base instance to get custom method per set.
 * @function _set
 * @param  {*} val         Any value
 * @param  {*} [params]    Added parameters
 * @param {Boolean} noset  When true returns a parsed val object but set nothing
 * @return {Object}        return self for chaining
 */
var _set = exports.set = function(val, params, noset) {
  for (var i in val) {
    if (~i.indexOf(',')) {
      for (var arr = i.split(','), multiobj = {}, m = 0, ml = arr.length; m < ml; m++) {
        multiobj[arr[m]] = util.clone(val[i])
      }
      if (!noset) {
        _set.call(this, multiobj, params, noset)
      } else {
        delete val[i]
        for (var n in multiobj) {
          val[n] = multiobj[n]
        }
      }
    } else {
      i = util.dotField(val, i)

      // console.error( 'SET', this, this._set)

      if (this._set && !noset) {
        this._set.call(this, val, i, params)
      } else {
        //TODO: check for property move from element set to here
        // if( V.Object && this.isProperty( i, val ) && this[i] instanceof V.Object )
        // {
        //   console.log('??', i, val, this.isProperty( i, val ) )
        //   this[i].val = val[i]
        // }
        // else
        // {
          this[i] = val[i]
        // }
      }
    }
  }
  return noset ? val : this
};

util.define(base,
  /**
   * When a Base is extended without defining the type this is the default type.
   * @property defaultType
   */
  'isProperty', function( i, val) {
    var t = this
      , result = 

      
    // val[i] instanceof Object  //THIS MAY GO AWAY LATER
           //TODO: check if this is really nesseracy ( void 0 )
           // && 

      //SUPER DANGERGOUS THING

          !( t._[i] === void 0 //--- danger resolve when define _ is fixed
           && !util.lookup.call(t, i) 
           && typeof t[i]!=='function' 
          )

    // console.log( val[i] instanceof Object, t._[i] === void 0, 'val:',t._[i], !util.lookup.call(t, i), typeof t[i]!=='function'  )

    // console.log( 'IS PROPERTY', i, result )

    return result
  },
  'defaultType', false,
  'extensions', false,
  'define', function(val) {
    for(var i in val) {
      util.define( this, i, val[i] )
      util.define( this.Class, i, val[i] )
    }
  },
  /**
   * Extend is used to add properties to base.
   * Settings are similar to standard defineProperty.
   * @method extend
   * @param   {Object}   settings        Define the following fields: name, type, set, new, remove.
   * @param   {String}   settings.name   Define the name of the property
   * @param   {Object}   [settings.type] Define the type of object e.g. V.Value, set type to false if you want to use standard defineProperty
   * @param   {Function} settings.set    Define a function on set
   * @param   {Function} settings.new    Define a function on construct
   * @param   {Function} settings.remove Define a function on remove
   * @return  {[type]}                   [description]
   */
  'extend', function(settings) {

    //TODO: add to instance as well , have a dictionary of extenstions -- get to orginal easyly
    var args = util.arg(arguments)
      , l = args.length
      , i

    if (l > 1) {
      for (i = 0; i < l; this.extend( args[i++] ));
    } else if (!settings.name) {
      for (i in settings) {

        if( typeof settings[i] === 'function' ) 
        {
          this.extend( { name: i, set: settings[i] } )
        }
        else
        {
          settings[i].name = i
          this.extend( settings[i] )
        }

      }
    } else {

      if( settings === true ){
        alert()
      }


      if (!settings.def && settings.def !== 0) settings.def = false;
  
      if (this.Class.prototype._settings) {
        exports.settings.parse.call(this, settings)
        if (settings._settings) exports.settings.create.call(this, settings)
      }
      //1. normal extensions
      if (settings.type === false || ( !settings.type && !this.defaultType ) ) {

        //TODO: test if double define is actually ok!
        // util.define(this, settings.name, settings)

        util.define(this.Class, settings.name, settings)

      } else {
        //2. V.Values
        if (!settings.type) settings.type = this.defaultType
          //a type has fields type, set ,get, create
        var get =  function(prop) {
            //custom get
            return settings.type.get 
              ? settings.type.get.call(this, prop, settings)
              : prop
          }
          , set =  function(val) {

            var prop = this[settings.name]
            if(prop===null) return
            if (prop===settings.def) { //(prop instanceof V.Object)
              //return is hier mischien niet nodig;
              return settings.type.create.call(this, val, prop, settings)
            } else {
              val = settings.type.set.call(this, val, prop, settings)
              if (val!== null) prop.val = val
            }
          }

        //TODO: test if double define is actually ok!
        util.define(
          this,
          settings.name,
          settings.def,
          set,
          get,
          true
        )
        //dit breaked wat shit

        //or on value ? value.prop

        //make extended prototype object perhaps
        // this.Class.prototype['__'+settings.name+'__'] = settings

        util.define(
          this.Class,
          settings.name,
          settings.def,
          set,
          get
        )
      }
    }
  },
  /**
   * Removes this Base. Also removes all listeners added to extensions.
   * Instances true will remove all instances as well.
   * @method remove
   * @param  {[type]} instances  [description]
   * @param  {[type]} fromremove [description]
   * @param  {[type]} params     [description]
   */
  'remove', function(instances, fromremove, params) {

    // this._removing = true

    if(!this._from) return

    this.setting('remove', [params]);

    if (!fromremove) {
      var ins = this._from.base.instances
      if(ins) {
        for (var n = 0, l = ins.length; ins[n] !== this || !ins.splice(n, 1); n++);
      }
    }

    for (var i in this.__) {
      if (this.__[i] instanceof V.Object) {
        //nested, blacklist, not (fields in object), from, stamp, noupdate
//         console.log('---------', i, this.__[i], this.__[i]._path )
        this.__[i].remove(false, false, false, false, false, true);
        this.__[i] = null
      } else {
        this.__[i] = null
      }
    }
    this.__ = null

    if (instances && this.instances) {
      for (j = this.instances.length - 1; j >= 0; this.instances[j--].remove(true, true));
    }

    for (var j in this) {
      // if(this[j] instanceof V.Base) {
      //   this[j].remove()
      // } 
      this[j] = null;
    }

    this._settings = null
    this._ = null
    delete this._settings
    delete this._
    delete this.__
    // delete this._class; may not be nessecary
  },
  /*set on prototype*/
  'set', _set,
  'get', function( path, self ) {
    return util.get( this, path, self )
  },

  'inject', inject,
  /**
   * Passes field parameter only for instances matching a field
   * @method
   * @param  {Function} fn    [description]
   * @param  {String}   field [description]
   * @param  {*}        val   [description]
   * @param  {*}        p     [description]
   * @return {Boolean}        [description]
   */
  'eachInstance', function(fn, field, val, p) {
    var instances = this.instances;
    if (instances) {
      for (var i = 0, l = instances.length, instance; i < l; i++) {
        instance = instances[i];


//problem! has to correct for missing instances!!!
//   console.log(instance, instances)

          

        if (instance && (!field || !instance.__ || !instance.__[field])) {
          if (fn.call(instance, val, p)) {
            return true;
          }
          if (instance.eachInstance(fn, field, val)) {
            return true;
          }
        } else if(!instance) {
          console.error('\n\n\n\ninstance in base gone?', i , instances)
          // debugger
        }
      }
    }
  },
  /**
   * Creates a class from the current Base instance
   * @constructor Class
   * @return {Object}
   */
  'Class', {
    get: function() {
      if (!this._class) {
        this.instances = [];
        this._class = function(val, proto, setting) {
          if (!proto) {
            var from = this._from.base;
            from.instances.push(this);
            if (this.setting) {
              this.setting('new', [from, setting]);
            }
            if (val) {
              this.set(val);
            }
          }
        };
        this._class.base = this;
        this._class.prototype = new this._from(false, true);
        this._class.prototype.__ = null;
        util.setstore.call(this);
        var i, _proto = this._class.prototype._ = {};
        for (i in this.__) {
          _proto[i] = this.__[i];
        }
        for (i in this._) {
          if (_proto[i] === void 0) {
            _proto[i] = this._[i];
          }
        }
        this._class.prototype._from = this._class;
        this._class.inject = inject
      }
      return this._class;
    }
  });
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./settings":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/settings.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/settings.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('./'),
  util = require('../util');

/**
 * Settings are used for special cases e.g. onRemove or onNew instance
 * @property
 */
util.define(base, '_settings');

base.prototype._._settings = {};

/**
 * Set settings on Base
 * @function _set
 * @param  {Object}  set      Object to set
 * @param  {Boolean} [remove]
 * @param  {Boolean} [force]  True/false
 */
var _set = function(set, remove, force) {
  var _s = set._settings //e.g. node , remove and parent
    , t = this
    , __t = t._._settings
    , setting
    , i
    , _t

  util.setstore.call(t)

  if (!t.__._settings) {
    // console.log('create my own settings')
    t.__._settings = {}
    for (var j in __t) {
      t._settings[j] = __t[j]
    }
  }

  _t = t.__._settings

  // console.log('SETTINGS?'.inverse, set, __t)

  for (i in _s) {
    setting = _s[i]
    //efficient memory management only make own if absolutely nessecary
    if ((remove && _t[setting][set.name]) || (!remove && !_t[setting][set.name]) || force) {
      
      if (_t[setting] === __t[setting]) {
        _t[setting] = {}
        for (var n in __t[setting]) {
          _t[setting][n] = __t[setting][n]
        }
      }

      if (remove) {
        this.eachInstance(function() {
          if (this[set.name] !== t[set.name]) {
            if (this._setting !== _t && this._settings[setting] === _t[setting]) {
              // console.log('found that the settings are the same and not the same property make my own');
              // console.log('------ SETTING')
              _set.call(this, _t[setting][set.name], false, true);
            }
          } else {
            if (this._setting !== _t && this._settings[setting] !== _t[setting]) {
              // console.log('------ REMOVE SETTING')

              // console.log(this.name,set.name,'found that the property is the same but settings are not!');
              this.removeSetting(set.name, setting);
            }
          }
        });
        _t[setting][set.name] = null;
        delete _t[setting][set.name]; //delete is kut!;
        if (util.empty(_t[setting])) {
          // console.log('lets put this to true!')
          _t[setting] = true;
        }
      } else {
        // console.log('------ DO SETTING', set, _t, setting, set.name)
        if(_t[setting]===true) {
          _t[setting]={}
        }
        _t[setting][set.name] = set;
        // console.log('RESULT?', setting, _t[setting])
      }
    }
  }

  // console.log('SETTINGS? -- result'.inverse, _t, this._settings===_t, this.BLUXEN)

};

/**
 * Creates a setting
 * @method create
 * @param  {[type]} set [description]
 * @return {[type]}     [description]
 */
exports.create = function(set) {
  set._set = set.set;
  set.set = function(val, prop) {
    _set.call(this, set)
    set._set.apply(this, arguments)
  }
}

/**
 * Extracts settings from settingsobject and stores them in an array.
 * @method parse
 * @param  {Object} settings Settingobject
 * @param  {Object} object   Settingsobject
 */
exports.parse = function(settings, object) {
  if (!object) {
    object = this._settings
  }
  for (var i in object) {
    if (settings[i]) {
      if (!settings._settings) {
        settings._settings = [];
      }
      settings._settings.push(i);
    }
  }
};

/**
 * Adds setting(s) to Base prototype
 * @method add
 * @param  {String[]}    name  Array of settingnames
 * @param  {Prototype}   proto Prototype eg. myBase class
 */
exports.add = function(name, proto) { //start using this sometimes!;
  if (name instanceof Array) {
    for (var i in name) {
      if (proto) {
        this.add(name[i], proto);
      } else {
        this.addSetting(name[i], false);
      }
    }
  } else {
    if (!proto) {
      util.setstore.call(this);
      if (!this.__._settings) {
        this.__._settings = {};
      }
      for (var j in this._._settings) {
        this._settings[j] = this._._settings[j];
      }
      this._settings[name] = true;
    } else {
      proto.prototype._settings[name] = true;
    }
  }
};

/**
 * Add settings to instances of Base
 * settings only work for instances of the added Basesettings
 * @method
 */
util.define(base,
  'addSetting', function(name) {
    exports.add.call(this, name);
    if (this._class) {
      this._class.prototype._._settings = this._settings;
    }
  },
  /**
   * Simple implementation of setting.create
   * @method setSetting
   * @param  {Object} set Settingobject
   */
  'setSetting', function(set) {
    //eerst checken of ie al bestaat anders kan het voorkomen dat het teveel is
    exports.parse.call(this, set);

    // console.log('SET SETTING'.yellow.inverse, set, this._settings )

    //get gebruiken --- object is een check op meerdere fields returns true of false // bij get ook mogelijk om field mee te geven
    _set.call(this, set);

    // console.log('SET SETTING -- result'.yellow.inverse, this._settings )

  },
  /**
   * [description]
   * @method removeSetting
   * @param  {String}       name     Name of the setting to remove
   * @param  {Array|Object} settings Settingobject
   */
  'removeSetting', function(name, settings) {

    // if(!settings) {
    //   //this may all be not nessecary!
    //   for(var i in this._settings) {
    //     for(var j in this._settings[i]) {
    //       if(this._settings[i][j].name===name) {
    //         settings=this._settings[i][j]
    //         break;
    //       }
    //     }
    //   }
    // }

    if (!(settings instanceof Array)) {
      //this may all be not nessecary!
      // if(settings instanceof Object) {
      //   settings = settings._settings
      // } else {
        settings = [settings];
      // }
    }

    for (var i = settings.length - 1, found, _settings = this._settings; i >= 0; i--) {
      if (_settings && _settings[settings[i]] && _settings[settings[i]][name]) {
        found = true;
        break;
      }
    }
    if (found) {
      _set.call(this, {
        name: name,
        _settings: settings
      }, true);
    }
  },

  /**
   * Checks if object has settings and executes them. Arguments are passed to settings.
   * @method setting
   * @param  {String}    name Name of the setting
   * @param  {Arguments} arg  Arguments to pass to settings
   */
  'setting', function(name, arg) { //misschien arg
    var _s = this._settings;
    if (_s && _s[name] && _s[name] !== true) {
      for (var i in _s[name]) {
        _s[name][i][name].apply(this, arg);
      }
    }
  });

/**
 * Base has two default settings
 * new is invoked on construction , remove on removal;
 * @settings
 */
exports.add(['new', 'remove'], base)

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/easing.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var animation = require('./');
animation.easing = exports;
// t: current time, b: beginning value, c: change In value, d: duration
// courtesy of Robert Penner
exports.inCubic = function(t, b, c, d) {
  return c * (t /= d) * t * t + b;
};

exports.outCubic = function(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
};

exports.outBack = function(t, b, c, d, s) {
  var s = 1.70158;
  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
};
},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/frame.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var Value = require('../../value')
  , frame = new Value(1)
  , util = require('../../util')
  , _on = function() {
    // console.group()
    // console.log('\n\n----RAF----'.magenta.bold)
    exports.rafId = window.requestAnimationFrame(_on)
    frame.val++
    // console.groupEnd()
  }

frame.done = new Value(true)

util.define(frame,
  'addListener', function(val, mark, remove) {
    if (!this._listeners){
      this.done.val = false
      _on()
    }
    Value.prototype.addListener.call(this, val, mark, remove)
  }
, 'removeListener', function(val, mark, remove) {
    var t = this
    Value.prototype.removeListener.call(t, val, mark, remove)
    if (!this._listeners) {
      window.cancelAnimationFrame(exports.rafId)
      this.val = 1
      this.done.val = true
    }
  }
)

module.exports = frame
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var element = require('../element').inject(require('../element/properties')) //element added (extend) //call extend on flags (make buffer if already extended)
  , object = require('../../object')
  , util = require('../../util')
  , flags = require('../../value/flags/util')
  , operators = require('../../value/operators')
  , frame = require('./frame')
  , _linear = function(t, b, c, d) {
    return c * t / d + b
  }
//-------------------------------------------------------------------
operators._a = function (val, operator) {
  return operator
}

function preventSet(val) {
  this._p = true
  this.val = val
  this._p = false
}

operators._a.order = 2

flags.animation = {
  set: function (val) {
    
    var thisObject = this
      , _p = thisObject.checkParent('_prop')

    if (val) {

      if (!thisObject._val) thisObject.val = 0

      var name = _p._prop.name
        , element = _p._caller
        , noListener = val.noListener
        , path = thisObject._path
        , id = name.concat(path.join(''))
        , skip = val.skip
        , easing = val.easing 
          && exports.easing[val.easing] 
          || val.easing 
          || _linear
        , time, start, ready

      if(!_p._animListen) _p._animListen = function (val) {
        var tn = this[name]
        if(tn) tn.update(this, true)
        else {
          var FORTESTING = frame._listeners && frame._listeners.length
          console.log('_animListen setting',frame._listeners && frame._listeners.length)
          frame.removeListener(void 0, this)
          console.log('>> _animListen setting',frame._listeners && frame._listeners.length)
          if(FORTESTING && FORTESTING === (frame._listeners && frame._listeners.length))
          {
            console.error('this >>',this)
            // debugger
          }
        }
      }

      element.setSetting({
        name:'animation',
        remove:function() {
          var FORTESTING = frame._listeners && frame._listeners.length
          // console.log('remove setting',frame._listeners && frame._listeners.length)
          

          frame.removeListener( void 0, this)


          if(frame._listeners && FORTESTING && FORTESTING === (frame._listeners && frame._listeners.length))
          {
            for(var i in frame._listeners ) {
              if( frame._listeners[i] instanceof Array ) {
//                 console.log('COMPARE',frame._listeners[i][1]===this, frame._listeners[i][1], 'vs', this )
                if( frame._listeners[i][1]===this, frame._listeners[i][1] ) {
                    // frame._listeners.splice(i,1)
//                     console.error('this >>',this.node)
                    // debugger
                }
              }
            }
          }


        }
      })

      _p.preventSet = preventSet

      _p.set('translate', true)

      thisObject.set('_a', {
        time: val.time || 60,
        val: function(v, cv, b) {
          
          var t = this
            , a
            , prop = _p //t[name] ||
            , pr = t[name]

          if (!t._a) t._a = {}
        
          if (!t._a[id]) {

            start = val.start === void 0 
              ? t.rendered && (thisObject.__lval !== void 0)
                ? thisObject.__lval
                : cv
              : val.start instanceof object 
                ? val.start.val
                : val.start

            t._a[id] = {
              _start: start,
              _end: start,
              _current: start,
              _count: 0
            }

            if (!t.rendered) return start
          }

          if (t.rendered) {
            if(skip) {
              t._a[id]._current = cv
              skip = false
              return cv
            }

            a = t._a[id]
            if (pr._p || exports.prevent) {
              a._frame = 0
//               console.log('remove prevent',frame._listeners && frame._listeners.length)
              frame.removeListener(prop._animListen, this, true)
//               console.log('>> remove prevent',frame._listeners && frame._listeners.length)
              if (pr._p !== 1) {
                a._current = a._end = cv
                if (val.complete) noListener = val.complete.call(t, cv)
                if (val.done) setTimeout( function() { val.done.call(t,cv) }, 0)
                if (val.once) {
                  setTimeout( function() { 
                    if(val.once) val.once.call(t,cv) 
                    val.once = null
                  }, 0)
                }
              }
            } else if (a._frame !== frame.val) {
              if (a._frame || (cv !== void 0 && a._current !== cv)) { //checking a.frame faster than comparing a.current to cv
                if (a._end !== cv) {

                  if (val.init) val.init.call(t, a._current)
                  if(!noListener) {
                    frame.addListener([prop._animListen, this, name]
                      , function (listenArray, listeners) {
                        for(var i in listeners) {
                          if(listeners[i].pop) {
                            if(listeners[i].pop && listeners[i][1]===t && listeners[i][2]===name) {
                              return false
                            }
                          }
                        }
                       return true 
                      }
                    )
                  }
                  a._start = a._current
                  a._end = cv
                  a._count = 0
                  time = ~~v.time.val
                }
                a._frame = frame.val

                if(val.delay){
                  val.delay--
                  return a._start
                }

                var cnt = ++a._count
                a._current = easing.call(t, cnt, a._start, a._end - a._start, time || (time = ~~v.time.val))
                if(val[cnt]) val[cnt].call(this,a._current,cv)
              }
              if (a._count === time) {              
                a._current = cv
                a._frame = 0
                a._count = 0

                if (val.complete) noListener = val.complete.call(t, cv)
                if (val.done) setTimeout( function() { val.done.call(t,cv) }, 0)
                if (val.once) {
                  setTimeout( function() { 
                    if(val.once) val.once.call(t,cv) 
                    val.once = null
                  }, 0)
                }

                if(!noListener)
                {
//                   console.log('remove nolistener',frame._listeners && frame._listeners.length)
                  frame.removeListener(prop._animListen, this, true)
//                   console.log('>> remove nolistener',frame._listeners && frame._listeners.length)
                }
              }
            }
            return a._current
          } 
        }
      })
            
      _p._skip = true
      thisObject._skip = true
      
      if (val.start !== void 0) {
        var caller = this._caller
        if(!caller) caller = this.checkParent('_prop')._caller
        caller.setRender(name, function(parent) {
          this.update(name)
        })
      }
    } 
    else {
      thisObject.remove('_a')
      thisObject._skip = void 0
      _p._skip = void 0
      _remove(_p)
    }

  }
}
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../../value/operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../element/properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","./frame":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/frame.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var ua = require('../ua'),
  RAF = 'equestAnimationFrame',
  CAP = 'R' + RAF,
  util = require('../../util')
  lastFrame = 0;

util.define(ua, 'hasTransition', {
  get:function() {
    if(!ua._hasTransition) {
       var b = document.body || document.documentElement
        , s = b.style
        , p = 'ransition';
      ua._hasTransition = typeof s['t'+p] === 'string' 
        || typeof s[ua.prefix + 'T'+p] === 'string'
    }
    return ua._hasTransition
  }
})
  
RAF = 'r' + RAF;
if (!window[RAF]) { 

  ua.noRaf = true

  //window[ua.prefix + CAP] || 

  window[RAF] = function(callback) {
    return setTimeout(callback, 20);
  };
  window.cancelAnimationFrame = function(id) {
    clearTimeout(id);
  };
}



module.exports = exports = window[RAF]

exports.timer = function( fn, frames, repeat ){
  if( --frames ){
    exports(function(){
      if( repeat ) fn()
      exports.timer( fn, frames, repeat )
    })
  } else {
    exports( fn )
  }
}

exports.repeat = function( fn, frames ){
  exports.timer( fn, frames, true )
}

//check ios 6 paul irish says stuff goes wrong there...
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var cases = require('./'),
  element = require('../element'),
  setFlags = require('../element/set'),
  base = require('../../base'),
  util = require('../../util');

//------------------CASES FOR SET-------------------------------
var _css = function(t, name, invert, remove) {
    if (!invert) {
      if(!t.css) { t.css = '' }
      t.css.set( remove ? 'removeClass' : 'addClass', name ) 
      t.css.update(t)
                  // console.error('\n\n\nset css!!!!!xxx', name, t.node)

      t.eachInstance(function() {
            console.error('\n\n\ninstance! set css!!!!!', name, t.node)

        // if(this.css !== t.css) {
          this.css.set( remove ? 'removeClass' : 'addClass', name ) 
          this.css.update(this)
        // }
      })
    }
  },
  methods = cases.methods;

setFlags.remove = function(i, val, copy, top) {
  //this could become a seperate module since remove may be usefull for different purposes
  if (val && val.__remove__) {
    if (this[i] instanceof base) {
      top[i] = false;
    } else if (util.lookup.call(this, i)) {
      delete val.__remove__;
    } else {
      delete val[i];
      return true;
    }
  }
};

setFlags.cases = methods.reader(function caseReaderBase(name, val, dynamic, invert) {
  var t = this,
    f = function(obj) {
      obj = base.set(obj, false, true);
      for (var i in obj) {
        if (util.isObj(obj[i])) {
          obj[i] = f(obj[i]);
        }
      }
      return obj;
    },
    method,
    parsed,
    set,
    sVal,
    original;
  val = f(val);

  if (dynamic) {
    if (!t._cases) {
      t._cases = {};
    }
    if (val === null) {
      if (t._cases[name].method) {
        // console.error(name, 'case === null , remove it');
        cases[name].removeListener(t._cases[name].method);
      }
      if (cases[name].val) {
        t.css = {
          removeClass: name
        };
         t.eachInstance(function() {
            this.css = {
              removeClass: name
            };
         })
      }
      delete t._cases[name]; //removes case orginal
    } else {
      // console.error('SET CASE',name,t._cases[name]&&t._cases[name].method);
      parsed = methods.original(t, true, val, t._cases, true, name);
      t._cases[name] = {
        val: val,
        orig: parsed[0],
        nested: parsed[1]
      };

      if (!t._cases[name].method) {
        // console.error('this is what i have set for original', t._cases);
        method = t._cases[name].method = function() {

          // console.log('LETS TRY TO RUN METHOD',name,val);

          if (val) {
            set = methods.merge(true, name, val, t._cases); //arg no val;
            sVal = set [0];
            original = set[1];
            delete sVal.val;
            delete original.val;
            if (cases[name].val) {
              _css(t, name, invert);
              t.set(sVal, true);
            } else {
              _css(t, name, invert, true);
              t.set(original, true);
            }
          }
        };
        // console.error('ADD LISTENER TO',name,  t._cases[name]);
        cases[name].addListener(method);
        //remove setting on remove (saves memory)
        t.setSetting({
          name: '_c' + name,
          remove: function() {
            if(this === t ) {
              cases[name].removeListener(method); //if(!this.css === this._from.base.css) 
              this._cases[name].method = null
            }
          }
        });
        // } else {
        // console.log(name, 'already got listeners for case',name);
      }
      if (cases[name].val) {
        _css(t, name, invert);
        t.set(val, true);
      }
    }
  } else {
    _css(t, name, invert);
    t.set(val); //maybe copy args?
  }
  return true;
});
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../element/set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var object = require('../../object'),
  util = require('../../util'),
  element = require('../element'), //element /w extend
  value = require('../../value'),
  flags = require('../../value/flags');

/**
 * cases
 * cases are used to set one or more values when a specific case is true
 * there are 2 types of cases , static and dynamic ,
 * static cases are set at initialization of the application , usefull for things such as device type (phone, desktop, tv)
 * dynamic cases can be changed dynamicly and Objects or Bases that use the case will be changed dynamicly as well
 */

util.define(exports, 'methods', {});
//multiple, recursive and original have to become extensions on V.Object.convert so it's possible to use the same for data and events

var _isObj = util.isObj,
  /*
    _recur
    special merge that adds __remove__ if a field has to be removed
  */
  _recur = function(original, merge, fieldExists) {

    // console.log(original, merge, fieldExists)

    var keys, i, key, originalChild, mergeChild;
    if (fieldExists) {
      keys = {};
      for (key in original) {
        keys[key] = true; //keys can be undefined -- code can become shorter
      }
    }
    for (i in merge) {
      if (!fieldExists || keys[i]) {
        originalChild = original[i];
        mergeChild = merge[i];
        if (originalChild instanceof Object) {
          if (originalChild.__remove__ && (mergeChild && !mergeChild.__remove__)) {
            delete originalChild.__remove__;
          }
          if (!(mergeChild instanceof Object)) {
            merge[i] = {
              val: mergeChild
            };
          }
          _recur(originalChild, mergeChild, fieldExists);
        } else {
          original[i] = mergeChild;
          originalChild = 'burn';
        }
      }
    }
  },
  /*
          _multiple
          merge multiple orginals into a new orginal object also resolve nested cases
      */
  _multiple = function(t, nested, cases, currentObj, currentVal, base, name, path, orig) {

    if (!path) {
      orig = t;
      path = [];
    }
    var j, _case, cvChild;

    if((currentVal instanceof object) && !base) {

      // currentObj.val = t._val
      // console.error('VOBJ', currentObj)


    } else if (currentVal instanceof Object) {
      for (j in currentVal) {
        cvChild = currentVal[j];
        if (exports[j]) {
          _case = exports[j];
          if (_case instanceof object) {
            if (!base || !element.set.lookup.call(orig, path[path.length - 1])) { //element is required in cases.base, make this part extendable
              nested[j] = true;
            }
          }
          if (!_isObj(cvChild)) {
            currentObj.val = t && (t._val !== void 0 ? t._val : void 0);
          } else {
            path.push(j);
            //should be possible to use nested for current nested case;
            _multiple(t, nested, cases, currentObj, cvChild, base, name, path, orig);
          }
          currentObj[j] = null;
        } else {
          if (_isObj(cvChild)) {
            if (!currentObj[j]) {
              currentObj[j] = (t && t[j] && t[j].convert && t[j].convert(cvChild)) || (cvChild instanceof Array ? [] : {});
            }
            path.push(j);
            _multiple(t && t[j], nested, cases, currentObj[j], cvChild, base, name, path, orig);
            if (base && (!t || !t[j])) {
              currentObj[j].__remove__ = true;
            }
          } else {
            if (t && currentObj && !currentObj[j]) {
              if (flags[j]) {
                delete currentObj[j];
                currentObj.val = t._val !== void 0 ? t._val : void 0;
              } else {
                currentObj[j] = j === 'val' 
                  ? (t._val !== void 0 ? t._val : void 0) 
                  : (t[j]!==void 0 && t[j].convert && t[j].convert())
              }
            }
          }
        }
      }
    }
  };

/*
      original
      create a orginal store for a new case
    */
exports.methods.original = function(t, isObj, val, cases, base, name) {



  var obj = isObj ? t.convert(val) : t._val,
    i, cflag, nested = {};

  _multiple(t, nested, cases, obj, val, base, name);

  // for(var i in nested) {
  //   console.error('NESTED:::',i);
  // }
  // console.log(base ? 'BASE:': 'PROPERTY:' , name,'ORIGINAL GENERATION','\nval:',val,'\nobj:',obj,'\nnested:',nested,'\ncases:',cases);

  for (i in cases) {
    if (!nested[i]) {
      cflag = cases[i].orig;
      if (!isObj) {
        if (_isObj(cflag)) {
          if (cflag.val) {
            obj = cflag.val;
          }
        } else {
          obj = cflag;
        }
      } else {
        if (_isObj(cflag)) {
          if (!cases[i].nested[name]) {
            _recur(obj, cflag, name);
          }
        } else if (obj.val) {
          obj.val = cflag;
        }
      }
    }
  }



  return [obj, nested];
};
/*
  merge
  merge dynamic cases (overwrite /w cases that are true and further in the order of cases)
*/
exports.methods.merge = function(isObj, name, val, cases) {
  var original = util.clone(cases[name].orig),
    sVal = val,
    overwrite,
    i,
    merge,
    originalChild;
  for (i in cases) {
    if (i !== name && !cases[name].nested[i]) {
      if (exports[i].val) {
        merge = cases[i].val;
        if (_isObj(original) || _isObj(merge)) {
          if (!_isObj(original)) {
            original = {
              val: original
            };
          }
          if (!_isObj(merge)) {
            merge = {
              val: merge
            };
          }
          _recur(original, merge, true);
          for (i in exports) {
            originalChild = original[i];
            if (originalChild !== null && originalChild !== void 0) {
              delete original[i]; //delete is pretty slow
            }
          }
          if (overwrite) {
            if (isObj) {
              if (sVal === val) {
                sVal = util.clone(sVal);
              }
              merge = util.clone(merge);
              for (i in exports) {
                if (merge[i] !== null && merge[i] !== void 0) {
                  // console.error('REMOVE FIX', i);
                  delete merge[i]; //delete is pretty slow
                }
              }
              _recur(sVal, merge, true);
            } else {
              if (merge.val) {
                sVal = merge.val;
              }
            }
          }
        } else {
          original = merge;
        }
      }
    } else {
      overwrite = true;
    }
  }
  return [sVal, original];
};
/*
  reader
  abstraction for use in cases.object and cases.base
*/
exports.methods.reader = function(fn, dynamic, _static) {
  return function reader(name, val) {
    var invert = (name[0] === '!'),
      vCase = invert ? exports[(name.slice(1))] : exports[name],
      ret;
    if (vCase) {
      if (vCase instanceof object) {
        if (invert && !exports[name]) {
          exports[name] = new value({
            val: function() {
              return !vCase.val;
            },
            listen: vCase
          });
        }
        ret = fn ? fn.call(this, name, val, true, invert) : dynamic;
      } else {
        ret = invert ? !!fn : fn ? fn.call(this, name, val) : _static
      }
    } else if (invert) {
      ret = fn ? fn.call(this, name, val, false, invert) : _static;
    }
    if (vCase === false && fn) {
      ret = true;
    }
    return ret;
  };
};

require('./object');
require('./base');
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","./base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/base.js","./object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/object.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = require('../../value/flags'),
  Cases = require('./'),
  object = require('../../object'),
  util = require('../../util'),
  methods = Cases.methods,
  dynamic = {
    set: function(val, stamp, reset, name) {

      if(!this._flag) this._flag = {}

      var t = this,
          //selection for t._flag easy maken
          
          
        flags = t._flag.case || (t._flag.case = [
          'case',
          t._val,
          false, {},
          dynamic
        ]),
        cases = flags[3],
        isObj = util.isObj(val),
        setVal = (isObj && !val.val) ? false : true;
      if (val === null) {
        if (cases[name]) {
          Cases[name].removeListener(cases[name].method);
        }
        delete cases[name];
      } else {
        flags[5] = true;
        if (!cases[name]) {
          var x = methods.original(t, isObj, val, cases, false, name);
          cases[name] = {
            val: val,
            orig: x[0],
            nested: x[1],
            method: function() {
              var set = methods.merge(isObj, name, val, cases),
              sVal = set[0],
              original = set[1];
              // console.log(name)
              // if(name === '$isActive' )console.error('boeloe boeloe boeloe!!!',sVal,original)

              flags[5] = true; //the closures here are not really nessecary better to avoid
              if (Cases[name].val) {

                if(!sVal) console.warn(name,'wrong in cases!', sVal, Cases, flags)
                if (setVal && sVal) {
                  // if(name === '$isActive' )console.log('yee its true')
                  flags[1] = sVal.val || sVal;
                }
                t.val = sVal;
              } else {
                                  // if(name === '$isActive' )console.log('no way gozee')

                if (setVal) flags[1] = original && original.val || original

                if(name === '$isActive' )console.log('no way gozee 2',original, t)

                t.val = original;
              }
              flags[5] = null;
            }
          };
          Cases[name].addListener(flags[3][name].method);
        }
        if (Cases[name].val) {
          if (setVal) {
            flags[1] = val.val || val;
          }
          object.set.call(t, val, stamp, false, true);
          //not always
          t._ignorefornow = true

        }
        flags[5] = null;
      }
    },
    // reset:function() {
      // console.error('reset')
    // },
    //add reset later
    remove: function(flags, name) {
      // console.log(flags, name)
      var cnt = 0
      for (var i in flags[3]) {
        // if(flags[3])
        cnt++
        if(!this._ignorefornow && !name || i===name) {
          cnt --
          Cases[i].removeListener(flags[3][i].method);
        } else {
          delete this._ignorefornow
        }
      }
      if(cnt) {
        // console.log('CASE OBJECT REMOVAL --- IT IS NOT EMPY')
        return true
      }
    },
    stack: 'case'
  },
  _static = {
    set: function(val, stamp, reset, name) {
      if (val !== null) {
        object.set.call(this, val, stamp, false, true);
      }
    }
  };

flags.dynamic.cases = methods.reader(false, dynamic, _static);
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

/*
  gets and caches values for css classes, also possible to change styles of classes
  return an array of multiple css objects corresponding to the class name
  when you pass field it searches the field trough all the classes selected, always takes first argument
  maybe have to make this for things such as div selectors / nested stuff --- will be cpu intensive!;
*/
var selector = 'cssRules',
  parseclass = function(slctr) {
    slctr = '.' + slctr.replace(/\./g, ' .').toLowerCase();
    for (var robj, select = document.styleSheets, length = select.length, i = 0, selectItem; i < length; i++) {
      selectItem = select[i][selector] || select[i][(selector = 'rules')]; //location of this polyfill can be improved
      if(selectItem) {
        for (var j = 0, l = selectItem.length, item; selectItem, j < l; item = selectItem[j++], item.selectorText === slctr && (robj = item.style));
      }
    }
    return robj;
  },
  c = function(cssClass, cache) {
    var t = exports;
    cache.push(t[cssClass] || (t[cssClass] = parseclass(cssClass)) || {});
    return cssClass;
  };

module.exports = function(slctr, field) {
  if (slctr) {
    var cache = this[slctr];
    if (!cache) {
      cache = [];
      for (var selectarray = slctr.split(' '), i = 0, l = selectarray.length, cssClass; i < l; i++) {
        if ((cssClass = c(selectarray[i], cache).split('.')) instanceof Array) {
          c(cssClass[cssClass.length - 1], cache);
        }
      }
      this[slctr] = cache;
    }
    if (field) {
      if(!(cache instanceof Array))
        return
      for (var ret, i = cache.length - 1; !ret && i >= 0; ret = cache[i--][field]);
      cache = ret;  
    }
    return cache;
  }
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , valueBase = require('../../value/base')
  , vigour = require('../../')
  , util = require('../../util')
  , elementBase = new base()

elementBase.defaultType = valueBase.type

module.exports = exports = vigour.Element = elementBase.Class
exports.base = elementBase

var _doc = typeof document !== 'undefined' ? document : 'no document', //reference to document is faster than using window.document;
  /**
   * Removes children from parent node
   * @method _removeChildren
   */
  _removeChildren = function() {
    for (var c = this._node.childNodes, i = 0, l = c.length; i < l; i++) {
      if (c[i].base) {
        // console.log
        c[i].base.remove(false, false, true);
      }
    }
  };

/**
 * node
 * adds and clones html nodes;
 * @attribute
 */
exports.base.extend({
    name: 'node',
    type: false ,
    /**
     * Defines what happens when node is set
     * @method set
     * @param  {*} val Defines the value of this._node
     */
    set: function(val) {
      //changing node bugs /w conversions
      //iframe selectors dont evaluate to a string
      if (val instanceof Object || !val.length) {
        this._node = val;
      } else {
        this._node = _doc.createElement(val);
      }
      this._node.base = this;
    },
    /**
     * Defines what happens when you get node
     * @method get
     */
    get: function() {
      if (!this._node) {
        this.node = _doc.createElement('div');
      }
      return this._node;
    },
    /**
     * Defines what happens when you create a new node
     * @method new
     * @param  {Object} from    Target
     * @param  {[type]} newnode [description]
     */
    "new": function(from, newnode) {
      if (!newnode) {
        var node = from._node;
        if (node) {
          this._node = node.cloneNode(true); //especialy good to do for memory (also saves 20% on cpu)
          this._node.base = this;
        }
      } else {
        this._node = newnode;
      }
      if (from._node && from._node.hasChildNodes()) {
        var i, c = this._node.childNodes,
          cf = from._node.childNodes,
          l = c.length,
          ci, cfb;
        for (i = 0; i < l; i++) {
          cfb = cf[i].base;
          if (cfb) {
            c[i].base = new cfb.Class(false, false, c[i]);
            //maybe call children new stuff with a custom setting as well?
            if (cfb._name) {
              c[i].base._name = cfb._name;
              this[cfb._name] = c[i].base;
            }
            c[i].base.setting('parent', [this]);
          }
        }
      }
    },
    /**
     * Defines what happens when you remove a node
     * @method remove
     * @param  {*}  [param] If param doesn't remove node from parent
     */
    remove: function(param) {
      _removeChildren.call(this);
      if(this._node) this._node.base = null //little slow optimize later
      if (!param) {
        var _p = this._node.parentNode;
        if (_p) {
          _p.removeChild(this._node);
          if (this._name && _p.base) {
            _p.base[this._name] = null;
          }
        }
      }
    }
  },
  /**
   * Set css class of a div
   * Use addClass or removeClass to add/remove a class
   * @attribute css
   * @param  {Object} val [description]
   * warning: the add operator in css is currently used by .name,
   * and will be replaced when you try to build a string
   * using {val: .... add: ....}
   */
  {
    // __$css: function(val) {
      // this.css
    // }
    css: function(val) {
      var _val = val.val || '';
      val._skip = true; //_skip is an ugly name
      if(val.addClass){
        if (!~_val.indexOf(val.addClass.val)) {
          val._val = ((_val.length > 0 ? _val + ' ' : '') + val.addClass.val);
          if(val.add) val._val = val._val.replace(val.add.val,'')
          val._lval = false;
          val.__lval = false;
          val.___lval = false;
          _val = val.val;
        }
        val.addClass.remove();
      }

      if(val.removeClass){
        if (_val && val._val) {
          val._val = val._val.replace(new RegExp(' ?' + val.removeClass.val), '');
          val._lval = false;
          val.__lval = false;
          val.___lval = false;
          _val = val.val;
        }
        val.removeClass.remove();
      }

      if( _val ) {
        this.node.className = _val.replace('$','')
      } else {
        this.node.className = ''
      }
    }
  },
  /**
   * Makes it possible to reference a child by name
   * Setting on a class does not update names of instances
   * Element[NAME]
   * @attribute name
   */
  {
    name: 'name',
    type: false,
    set: function(val) {
      var _p = this.parent;
      if (this._name) {
        if (_p) {
          _p[this._name] = null;
        }
      }
      this._name = val;
      if (!this._node || val !== this.node.nodeName.toLowerCase()) {
        //name does not inherit, beware!
        // console.log('WHATS THIS?',val);
        // this.css = {addClass:val};
        // this.className = this._name;
        if(!this.css || this.css._val!==val)this.css = { add: ' ' + val }
        //special name field?
      }
      if (_p) {
        _p[val] = this;
      }
    },
    get: function() {
      return this._name;
    }
  },
  /**
   * Returns parent base element
   * @attribute parent
   */
  {
    name: 'parent',
    type: false,
    get: function() {
      if (this._node) {
        var _p = this._node.parentNode || this._p;
        return _p ? _p.base || _p._p : false;
      }
    }
  },
  /**
   * Returns childNodes /w base classes array slow, cache if possible
   * @attribute children
   */
  {
    name: 'children',
    type: false,
    get: function() {
      if(!this._node) return []
      var c = this._node.childNodes,
        l = c.length,
        _c = new Array(l),
        i;
      for (i = 0; i < l; i++) {
        _c[i] = c[i].base || c[i];
      }
      return _c;
    }
  });

var recurRender = function(parent) {

  if (!this.lastindex) this.setting('render', [parent]) //execute render settings

  if (this.renders) {

    // console.error('RENDER ---', this.name, this.renders)

    for (var p
      , c = this.node.childNodes
      , cl
      , arr = this.renders
      , obj
      , i = this.lastindex || 0, l = arr.length; i < l; i++) {
      obj = arr[i]

     if(obj) {
        p = util.checkArray(c, obj, 'base')
        if (p !== false) {
          recurRender.call(obj, this)
        } else if(obj._from) {

          // console.log('CLASS!',obj, obj.name && this[obj.name] && this[obj.name] === cl)

          cl = obj.Class

          if(obj.name && this[obj.name] && this[obj.name] === cl) {
            recurRender.call(this[obj.name], this)
          } else {
           for (var j in c) {
             if (c[j].base && c[j].base instanceof cl) {
               recurRender.call(c[j].base, this)
               break;
             }
            }
          }
        }
      }
      // arr.splice(i,1)
    }
  }

  this.lastindex = l
},

setRender = function() {
  var p, pp;
  if (this.parent) {
    p = this.parent;
    if (p.renders) {
      p.renders.push(this);
    } else {
      p.renders = [this];
      pp = p.parent;
      if (pp && !(pp._settings && pp._settings.render !== true)) {
        setRender.call(p);
      }
    }
  }
},

valRender = function(val) {
  var _settings = (val.__ && val.__._settings || val._._settings)
  if (val._.renders || val.__ && val.__.renders || _settings.render !== true) {
    if (!this.renders) this.renders = []
    if (!(this.__ && this.__.renders)) this.renders = util.clone(this.renders)
    // console.log(this.renders===this.__.renders, this.__.renders, this._.renders)

    // console.log(util.checkArray(this.renders,val._from))
    // console.log('XXXXXX',val)
    // if(util.checkArray(this.renders,val._from._from,'_from._from')===false&&util.checkArray(this.renders,val._from,'_from')===false) {
      this.renders.push(val)
    // }
    // console.log('renders push --- creates leaks!')
  }
}

//define vanuit base (korter!)
util.define(exports,
   'append', function(arr) {

    // alert('APPEND')
    // console.log('APPEND'.inverse,arr)

      var args = arguments

      if(arguments.length>1) {
        arr = util.arg(arguments)
      } //else if(arr )

      var insertbefore
      if(!arr.length && !(arr instanceof exports) && arr.val) {
        insertbefore = arr.before
        arr = arr.val
      }
      var Class = arr[0]
      , i = 0
      , l = arr.length
      if(!arr.length) {
        this.add(arr, insertbefore)
      } else if(typeof Class === 'function') {
        for(var i=1, l = arr.length;i<l;i++) {
          this.add(new Class(arr[i]), insertbefore)
        }
      } else {
        for(;i<l;i++) {
          this.add(arr[i], insertbefore)
        }
      }
  },
  'checkRender', function(val, notRendered) {
    if (val) valRender.call(this, val)
    if (!notRendered) {
      var _renders = (this.__ && this.__.renders || this._.renders)
      if ( ( (_renders  || ((this.__ && this.__._settings)  || this._._settings).render !== true)
          && (!this.lastindex || (_renders && this.lastindex < _renders.length))
        ) && this.rendered) {
        recurRender.call(this, this)
      } else {
        if(this.parent) valRender.call(this.parent, this)
      }
    }
  },
  'checkParent', util.checkParentFactory('parent'),
  'get',function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },
  'find', function(get, match, level) {
    if(level === void 0) level = true
    var children = this.node.childNodes
      , i = 0
      , found
      , child
      , len = children.length
      , passOn = level===true ? true : level-1
    for(;i<len;i++) {
      child = children[i].base
      if(child) {
        if(child.get(get, true)==match) {
          return child
        } else if(level) {
          found = child.find(get, match, passOn)
          if(found) return found
        }
      }
    }
  },
  'setRender', function(name, val) {
    this.setSetting({
      name: name,
      render: val
    });
    setRender.call(this);
    this.eachInstance(function() { //look for current caller instance perhaps?
      setRender.call(this)
    }, name);
  },
  'renders', false,
  /**
   * Add element as child
   * @method
   * @param  {Object}  val  Object to be added
   * @return {Object}       Returns the V.element
   */
  'add', function(val, insertbefore) {
    
    if(insertbefore) {
      if(typeof insertbefore === 'string') insertbefore = this[insertbefore]
      if(insertbefore) {
        this.node.insertBefore(val.node, insertbefore.node || insertbefore)
      } else {
        console.error('cannot find insertbefore')
      }
    } else {
              // console.error(val)

      this.node.appendChild(val.node)
    }

    val.setting('parent', [this]) //execute parent settings
    if (val.name) this[val.name] = val
    //--------------------
    //needs cleaning costs 3% now...
    this.checkRender(val)
    //--------------------
    return this
  },
  /**
   * Removes all children
   * @method empty
   * @param  {Boolean} instances True will remove all instances of children removed
   */
  'empty',
  function(instances) {
    var c = this.node.childNodes
      , i
    this.node.innerHtml = ''
    for (i = c.length - 1; i >= 0; i--) {
      if (c[i].base) c[i].base.remove(instances)
    }
  });

exports.base.addSetting('parent')
exports.base.addSetting('render')
require('./set')
},{"../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js","./set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/display.js":[function(require,module,exports){
var collection = require('./util')

exports.prepare = function(el) {
  if(!el.display) el.display = 'block'
}

exports.newElement = function(data, element, t) {
  var c = collection.children(t)
  for(var i in c) {
    if(c[i]._d && c[i]._d===data) {
      c[i].display = element.display.val
      return true
    }
  }
}
 
exports.rem = function (el, t, hasFilter, noResolve) {
 el.display = 'none'
 return true
}

exports.fragment = function(a,b,exclude,i) {
  //since it never removes excludes should never be applied
  //exclude is normally used to not add things again if they already exist
  if(exclude) exclude[i]=null
}

},{"./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/index.js":[function(require,module,exports){

var collection = require('./util')
  , util = require('../../../../util')

/**
 * collection
 * links arrays or object to elements
 * use filter if you want to convert
 * @attribute
 */

exports.extend = util.extend(
  require('../data'),
  function(base){

    base.extend({
      name:'collection',
      // render:function() {
      //   this.update('collection') 
      // },
      remove:function() {
        if(this._colElem) this._colElem.remove()
      },
      set: function(val, stamp, from, remove, change, added) {

        // console.error('xxxx!@#!!@#!#', this.data && this.data.toString())

        val._skip = true

        var hasFilter = collection.filter(val, this)
          , data = this.filter || val.val
          , options = this._colOptions || val.options 
              && (this._colOptions = val.options.convert())
          , orig =  val.element
          , el = this._colElem 
              || (orig && orig._val) && (this._colElem = new (orig._val.Class || orig._val)())
          , firstRun = !this._colInit
          , slStamp
          , elVal
          , colElem = this._colElem

          // console.log('!!!OPTIONS!', options)

        //dirty block! clean it FAST

        // || !this.rendered 

        if(!(data && el)) return //||!this.rendered
        
        slStamp = orig._slStamp
        elVal = orig._val

        if(slStamp) {
          orig._slStamp = stamp
        } else if(colElem && orig._slStamp !== stamp) {
          if(!(elVal.Class && (colElem instanceof elVal.Class)) 
            && !(!elVal.Class && (colElem instanceof elVal))) {
            el = this._colElem = new (elVal.Class || elVal)()
            orig._slStamp = stamp
          }
        }



        // console.log('ook leuk ff update', val, stamp, from, remove, change, added)
          // console.log('pass!')
          
        if(firstRun) {

          options && options.prepare && options.prepare(el)

          this._colInit = true
          this.node.appendChild(collection.fragment( data, el, this, false, options
            , hasFilter ))

        } else {

          if(from && from._parent === data.from) {
            if(remove) {
              var r = util.checkArray(collection.children(this),from,'_d',true)
              if(r) {
                if(!(options && options.rem && options.rem(r, this, hasFilter))) {
                  r.remove()
                }
              }
            } else if(util.checkArray(collection.children(this),from,'_d')===false) {

              collection.element( from, el, this, true, this.node, options, hasFilter, true )
            } else if(hasFilter && options && options.indexChange) {

                options.indexChange(
                  util.checkArray(collection.children(this),from,'_d',true)
                  , this, hasFilter )
            }
            
          } else {
            
            // console.log('122XXXXX', from, hasFilter, collection.filter(val, this)) //try to fix order by name better

            if(!from) {

              if(remove) {
                collection.clear(this, options)
              } else {

                var c = collection.children(this)
                  , exclude = {}
                  , name
                  , fField
                  , keys
                  , child

                // console.log('XXXXX',hasFilter) //try to fix order by name better
                if(hasFilter===true) {
                  keys = data.keys
                }

                for(var j in c) {
                  child = c[j]
                  name = c[j]._d._name

                  // console.log(c[j], hasFilter, keys, util.checkArray(data,child._d) === false)

                  if(hasFilter && !keys ? util.checkArray(data,child._d) === false : !data[name] || data[name]!==child._d ) {

                    // console.log('CHECK!---',j)

                    if(!(options && options.rem && options.rem(child, this, hasFilter, hasFilter))) {
                      child.remove()
                    }
                  } else {
                    //this is more efficient
                    // if(data[name]!==c[j]._d) c[j].data = data[name] 
                    exclude[name]=true
                    if(hasFilter) {
                      if(options && options.indexChange) {
                        if(child._d._indexCache[hasFilter][0]!==child.i) {
                          options.indexChange(child, this, hasFilter, true)
                        }
                      } else if(hasFilter===true) {
                        if(j!=util.checkArray(keys,name,true)) {
                          delete exclude[name]
                          if(!(options && options.rem && options.rem(c[j], this, hasFilter, hasFilter))) {
                            child.remove()
                          }
                        } 
                      }
                    }
                  }
                }

                this.node.appendChild(
                  collection.fragment(data, el, this, exclude, options, hasFilter)
                )
              }

            }
          }
        }
      }
    })
})
},{"../../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/data.js","./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js":[function(require,module,exports){
var element = require('../')
  , Data = require('../../../../data').inject(require('../../../../data/selection'))
  , util = require('../../../../util')

var r = function() {
  return String(~~(Math.random()*9))+''
}

exports.element = function (data, element, t, update, node, options, hasFilter, resolve) {
  var elem
  if(options && options.newElement) {
    elem = options.newElement.apply(this,arguments)
    if(elem===true) return
  }
  elem = elem || new element.Class()
  
  elem._col = true

//   console.log( '---->', data )

  if (data !== void 0) elem._dSet(data)
  if (node) node.appendChild(elem.node)
  elem.setting('parent', [t])
  ;options&&options.element&&options.element(elem, t, hasFilter, resolve)
  if (update && data !== void 0) elem.updateData()
  t.checkRender(elem, true)
  return elem
}

exports.fragment = function (data, element, t, exclude, options, hasFilter) {
  var frag = document.createDocumentFragment()
    , item = function(i) {
        //if you use the passed i it is a different value for selections
        if(this._name) i = this._name
        if(!(options&&options.fragment&&options.fragment(t,this,exclude,i))
          && (!exclude || !exclude[i]) ) {
          var elem = exports.element( this || null, element, t, false, frag, options
              , hasFilter)
          if(elem) frag.appendChild( elem.node )
          elem.updateData()
        }
      }
  frag._p = t

  if(data.each) {
    data.each(item)
  } else {
    //normal data
    for(var i in data) {
      item.call( data[i] ,i )
    }
  }

  // element.updateData(true)
  return frag
}

exports.children = function (t, options) {
  if(!t) return
  var ch = []
  for(var i in t.node.childNodes) {
    var child = t.node.childNodes[i].base
    if(child && child._col) {
      ch.push(child)
    }
  }
  ;options&&options.children&&options.children(ch)
  return ch
}

exports.clear = function (t, options) {
  t.colInit = null
  var c = exports.children(t)
  for(var i in c) { c[i].remove() }
  ;options&&options.clear&&options.clear(t)
}

exports.filter = function (val,t) {


  var data = val.val


  // console.log('DO I HAVE FULTER!>?',data,  val, t)


  if(val.filter && val.filter.val===true) {
    // console.log('sort by name') moet beter
        // console.log('got it!DATAx!')

    return true
    //different vibes
  }

  if (data && val.filter && !t.filter) {

    // console.log('MAKE NEW STYUFFF')

    var a = val.filter.raw
    //dit is kapot
    data = t.filter = new Data(data, a)

    // console.log('FILTERSSSS!', a, t)
    // debugger

    a._col = true
    
    data.addListener(function (val, stamp, from, remove) {
      t.collection._update(val, stamp, from, remove)
    })
    
    t.setSetting({
      // name: 'collecitonfilter',
      remove: function () {
        t.filter.remove()
        t.filter = null
      }
    })

    // console.log('DATAx!')
    return data._uid
    // return t.filter._uid//data is filter
  } else if(data && data._filter) {
        // console.log('DxxxATAx!')

    return data._uid
  } 
  else if(t.filter) {

    return t.filter._uid
  }

    // console.log('NO DATAX! FILTER', t)

}

// exports.indexChange = function(el, t, hasFilter, noResolve) {
// var oldIndex = el._d._indexCache[hasFilter][1]
//     , newIndex = el._d._indexCache[hasFilter][0]
//     , ch = !noResolve && collection.children(t,exports)
//     , l


//   exports.xy(el)

//   if(noResolve) return

//   l = ch.length
  
  
//   var clone = el.node.cloneNode(true)
//   t.node.removeChild(el)
//   el._node = clone


   
//   // t.h = t.node.scrollHeight
// }
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","../../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../../data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","../../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var data = require('../../../data/base')
  , util = require('../../../util')
  , flags = require('../../../value/flags')

/**
  * extends updateData to take childNodes into account
  * may need to add extra argument for go deep
  * @method
*/
exports.extend = util.extend([ data, {
  updateData: function ( instances, data, fmodel ) {

    // if( instances ) console.error('????----------->>>>>')

    if (this._d) {
      this._subscribed = false
      data = this._d
    }

    var ffmodel = false
    var parsed = false
    if (!fmodel && !this.model && !this._fmodel) ffmodel = true
    //fmodel is first model
    for (var children = this.node.childNodes
      , i = children.length - 1
      , base; i >= 0; i--) {

      base = children[i].base
      
      // if(base && base.model && base.model.field && base.modelParsed !== base.model.field.val && base.instances && instances) {
      //   // console.error('1', base && base.name, base.instances)
      //       if(!data && instances) {
      //         if(!data) {
      //           data = base.checkParent('_d',true) || this.checkParent('_d',true)
      //           // console.log('hey hey hey', data, this._d, base._d, base)
      //         }
      //         console.error('lezzgo instances', data)
      //         // base._d = data = data.get(this.model.field.val) //util.path(data,this.model.field.val.split('.'))
      //         for(var i in base.instances) {
      //           if(!base.instances[i].model.parsed) {
      //             // console.error('?',base.instances[i].model.parsed)
      //             base.instances[i].updateData(false, data)
      //           }
      //         }
      //         // base.modelParsed = 
      //         // base.model = {}
      //         // base.model.parsed = base.model.field.val 
      //         // return
      //       }
      // }

      // if(base && base.model && base.model.field && !base._d) {
        // base._dSet(data, true)
      // }

      if (base
      && (!(base.model && base.model.inherit && base.model.inherit.val===false))
      && (base._d === void 0 || base._dfrom || (base.model && base.model.field) )) {
        var tdata = data

        if (base.model && (data || base.model && base.model.field)) {
          if (ffmodel) base._fmodel = true

          //hier ook ff model parsen!
          if(base.model && base.model.field) {
            tdata = data.get(base.model.field.val)
            base.modelParsed = base.model.field.val
            // console.error(tdata)
          }
            // console.error(tdata._cachedPath)

          base._dSet(tdata, true)
        }

        base.updateData(false, tdata, base._fmodel || fmodel)
      }
    }
  }
}])
},{"../../../data/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/base.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    here some basic html properties are added to V.Element.Nessecary
    for values that you want to be able to bind to V.Objects
    Uses base.extend -- see core.base for more information
  */

var ua = require('../../ua')
var css = require('../../css')
var Value = require('../../../value')
var util = require('../../../util')
var hash = require('../../../util/hash')
var raf = require('../../animation/raf')
var _load = require('../').images = {}
var _transform = ua.prefix + 'Transform'
var _cssTransform = ua.prefix + '-transform'
var postpone = require('vigour-js/browser/events/util').postpone
var body = document.body.style
    //think about doc ready event or fallback if no body
var _translate = body.perspectiveProperty != void 0
                 || body.WebkitPerspective != void 0
                    ? ['translate3d(', ',0px)']
                    : ['translate(', ')']
var _coordinate = function(style) {
      var margin = 'margin' + (style[0].toUpperCase() + style.slice(1));
      return function(val) {
        if(val.clean) {
          _cleanCoordinate.call(this,style,margin)
          val.clean = null
        }
        if (val.translate) {
          this.translate(val)
        } else {
          this.node.style[this.relative ? margin : style] = val.val + 'px'
        }
      }
    }
var _clearTransform = new RegExp(_cssTransform+'(.*?);')
var _clear =
    { x: /(margin-left(.*?);)|(left(.*?);)/g
    , y: /(margin-top(.*?);)|(top(.*?);)/g
    }
var _cleanCoordinate = function( check ) {
      var t = this._t
      , keep = false
      , val = this[check]
      , cssText = this.node.style.cssText.replace( _clear[check], '' )

    if( val && val.translate && val.translate.val===false) val.translate = null

    if(this.node.style[_transform] && !val.translate) {
      if(t) {
        if(!this[check].translate) {
          for(var i = 2 ; i < 6 ; i++) {
            if(t[i])keep=true
          }
        } else {
          keep=true
        }
      }
      if(!keep) cssText = cssText.replace(_clearTransform,'')
    }
    this.node.style.cssText = cssText
  }

var setTimers, removeTimers, _setTimeout

exports.extend = util.extend(function(base) {
  util.define(base.Class,
    'cleanCoordinates', function(coord) {
       if(this._node) {
        if(!coord) {
          _cleanCoordinate.call(this,'x')
          _cleanCoordinate.call(this,'y')
        } else {
          _cleanCoordinate.call(this,coord)
        }
      }
    },
    'translate', function(val) {
    var _x
      , _y
      , _val =  val.val
      , _scale
      , _rotate
      , _rotateY
      , _rotateX
      , _str = ''
      , _name = val && val._prop.name
      , _t = this._t = this._t || []
      , nope = false

    //cirtical performance point hence use of | 0
    if (_name === 'x') {
      _x = _val | 0
      if (_x === _t[0]) nope = true
    } else if (_name === 'y') {
      _y = _val | 0
      if (_y === _t[1]) nope = true
    } else if (_name === 'rotate') {
      _rotate = _val
      if (_rotate === _t[2]) nope = true
    } else if (_name === 'scale') {
      _scale = _val
      if (_scale === _t[3]) nope = true
    } else if (_name === 'rotateY') {
      _rotateY = _val
      if (_rotateY === _t[4]) nope = true
    } else if (_name === 'rotateX') {
      _rotateX = _val
      if (_rotateX === _t[4]) nope = true
    }

    if (!nope) {
      _t[0] =  _x || (this.x.translate && this.x.val | 0) || 0
      _t[1] =  _y || (this.y.translate && this.y.val | 0) || 0
      _t[2] = _rotate || this.rotate.val
      _t[3] = _scale || this.scale.val
      _t[4] = _rotateY || this.rotateY.val
      _t[5] = _rotateX || this.rotateX.val
      if (_t[0] || _t[1]) {
        _str = _str
          .concat(
            _translate[0]
          + _t[0] + 'px,'
          + _t[1] + 'px'
          + _translate[1]
          )
      }
      if (_t[2]) { _str = _str.concat(' rotate(' + _t[2] + 'deg)') }
      if (_t[3]) { _str = _str.concat(' scale(' + _t[3] + ')') }
      if (_t[4]) { _str = _str.concat(' rotateY(' + _t[4] + 'deg)') }
      if (_t[5]) { _str = _str.concat(' rotateX(' + _t[5] + 'deg)') }
      this.node.style[_transform] = _str
    }
    return this
  }, 'update', function() {
    for (var i = 0, _args = util.arg(arguments), l = _args.length, p; i < l; i++ ) {
      if (_args[i] instanceof Array) {
        this.update.apply(this, _args[i]);
      } else {
        p = util.get(this, _args[i]);
        if (p) {
          p.update(this);
        }
      }
    }
    return this;
  });

  var done = postpone(function(val,self,sdir){
    if(self){
      if(val._listeners !== void 0) val.val = self.node[sdir]
      else self[sdir].__lval = void 0
    }
  },20)

  function createScroll(dir){
    var s = 'scroll'
      , sdir = s + dir //scrollLeft or scrollTop

    return {
      name:sdir,
      set:function(val) {
        var v = val.val
          , self = this
        if(v !== void 0) self.node[sdir] = v
        if(!self.__sT){
          self.__sT = true
          self.addEvent(s,function(){
            done(val,self,sdir)
          })
        }

      },
      get:function(val){
        if(val.__lval === void 0) val.val = this.node[sdir]
        return val
      },
      render:function() {
        var self = this
          , val = self[sdir].__lval
        if(val){
          raf(function(){
            self.node[sdir] = val
          })
        }
      }
    }

  }

  base.extend({
    name: 'relative',
    type: false,
    get: function() {
      var s = this.position !== false ? this.position.val : (this.position = {
        css: true,
        val: css(this.css.val, 'position')
      })
      return s !== 'absolute'
    }
  },
  {
    type: false,
    name: 'rendered',
    get: function() {
      var ret = this._rendered || (this.node === document.body),
        parent;
      if (!ret) {
        parent = this.node.parentNode;
        while (!ret && parent) {
          if (parent.base && parent._rendered) {
            ret = true;
          }
          if (parent == document.body) {
            ret = true;
          }
          parent = parent.parentNode;
        }
        if (ret) {
          this._rendered = true;
        }
      }
      return ret;
    }
  },
  createScroll('Left'),
  createScroll('Top'),
  {
    position: function(val) {
      // console.log('?????',val.css.val)
      // if (!val.css) { //check when ignoring this becomes a problem
        this.node.style.position = val.val;
      // }
    },
    // scrollTop:function(val) {
    //   console.error(val.val)
    //   this.node.scrollTop = val.val
    // },
    rotate: function(val) {
      this.translate(val);
    },
    rotateY: function(val) {
      this.translate(val);
    },
    rotateX: function(val) {
      this.translate(val);
    },
    scale: function(val) {
      this.translate(val);
    },
    src: function(val) {
      var v = val.val;
      if (v && v[v.length - 1] !== '/') {
        this.node.src = v;
      }
    },
    attr:function(val) {
      var t = this
      val.each(function(i) {
        t.node.setAttribute(i,this.val)
      })
    },
    backgroundPos: function(val) {
      this.node.style.backgroundPosition = val.val
    },
    backgroundBatch: function(val) {


    },
    background: function(val) { //optional maybe in a seperate module
      var v = val.val
        , t = this
        , style = this.node.style
        , url
        , hashed
        , parentBatch
        , batch

      if(val.gone && val.gone.val) {
        val._skip = true
        style.backgroundImage = ''
      } else if (v && v[v.length - 1] !== '/') {
        url = 'url(' + v + ')'
        if(style.backgroundImage===url) return

        //Value
        if (val.size) style.backgroundSize = val.size.val

        if (val.load) {

          hashed = hash(v)
          parentBatch = this.checkParent('backgroundBatch')
          if(parentBatch) batch = parentBatch.backgroundBatch

          if(!_load[hashed]) {
            this._loaded = null
            //also remove setting

            if(batch) {
              window.cancelAnimationFrame(batch._raf)
              if(!batch.batch) batch.batch = []
              batch.batch.push(hash)
            }

            _load[hashed]=new Value(false)
            var img = document.createElement('img')
            img.onload = function() {

             if(batch) {
               batch.batch.splice(util.checkArray(batch.batch,hashed),1)
               if(batch.batch.length===0) {
                batch.batch = null
                batch._raf = raf(function() {
                  if(parentBatch._node) batch._val.call(parentBatch)
                })
               }
             }

              _load[hashed].val = true
              img.onload = null
              img = null
              _load[hashed].remove(false,false,false,false,false,true)
              _load[hashed] = true
            }
            img.src = v
          }

          if(_load[hashed]!==true) {
             this._loaded = null

            _load[hashed].addListener([function() {
              if(val.load && val.load.val!==true) val.load._val.call(this, t);
            },val._base], true)
          } else {

            this._loaded = true

            if(batch) {
              if((!batch.batch) || batch.batch.length===0) {
                batch.batch = null
                window.cancelAnimationFrame(batch._raf)
                batch._raf = raf(function() {
                   if(parentBatch._node) batch._val.call(parentBatch)
                })
              }
            }

            if(val.load.val!==true) val.load._val.call(this, t);

          }
        }

        style.backgroundImage = url

      }
    },
    padding: function(val) {
      this.node.style.padding = val.val + 'px';
    },
    y: _coordinate('top'),
    x: _coordinate('left'),
    display: function(val) {
      this.node.style.display = val.val;
    },
    w: function(val) {
      // console.log('w');
      var v = val.val
      this.node.style.width = (v > -1 ? (v | 0)  + 'px' : v ) || '100%' 
    },
    h: function(val) {
      // var v = val.val | 0 typo or bug?
      var v = val.val
      this.node.style.height = (v > -1 ? (v | 0)  + 'px' : v ) || '100%'
    },
    opacity: function(val) {
      var v = val.val;
      if(v===false) this.node.style.opacity = null
      else this.node.style.opacity = v > -1 ? v : 1;
    },
    html: function(val) {
      var v = val.val || ''
      if( v.replace )
      {
        //add some injection prevention as option? (no script etc)
        v = v.replace(/\t/g, '    ')
             .replace(/\r\n|\n|\r/g, '<br/>')
             .replace(/  /g, '&nbsp; ')
             .replace(/  /g, ' &nbsp;') // second pass
                                        // handles odd number of spaces, where we
                                        // end up with "&nbsp;" + " " + " "
        this.node.innerHTML = v
      }

    },
    href: function(val) {
      this.node.href = val.val;
    },
    text: function(val) {

      // console.log('SETTING TEXT'.green.inverse. val.val, val)

      var node = this.node
        , nodes = node.childNodes
        , v = val.val || val.val === 0 ? val.val : ''

      if(v instanceof Object) v = ''

      if (/text/.test(node.type)) {
        node.value = v;
        return;
      }

      if (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].nodeType === 3) {
            // console.log('BLABLA'.inverse,v)
            nodes[i].nodeValue = v;
            return;
          }
        }
      }
      node.appendChild(document.createTextNode(v));
    },
    $timeout: function( val ) {
      if(setTimers === void 0){
        setTimers = function() {
          var _this = this
          var timeout = this.$timeout
          if( timeout ) {
            if(_setTimeout === void 0){
              _setTimeout = function( _this, timeout, keys, i ) {
                var time = keys[ i ] - ( keys[ i - 1 ] || 0 )
                var fn = timeout[ keys[ i ] ]._val
                fn.id = setTimeout( function() {
                  fn.id = null
                  if( !fn.done || !_this.done ) {
                    fn.call( _this )
                    fn.done = true
                    _this.done = null
                  }
                  if( keys[ ++i ] ) _setTimeout( _this, timeout, keys, i )
                }, time )
              }

            }

            _setTimeout( _this, timeout, timeout.keys, 0 )
          }
        }
      }
      if( this.rendered ) {
        setTimers.call( this )
      } else {
        this.setSetting( {
          name: 'setTimers',
          render: setTimers
        } )
      }

      this.setSetting( {
        name: 'removeTimers',
        remove: removeTimers || (removeTimers = function() {
          console.error('--------REMOVE',this._node)
          var timers = this.$timeout
          if( timers ) {
            timers.each( function() {
              var fn = this._val
              console.error('---------removing',fn,fn.done)
              if( this.done ) this.done = null
              if( fn.id ) clearTimeout( fn.id )
              if( fn.done ) fn.done = null
            } )
          }
        })
      } )
    }
  });
});
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","../../css":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(function(base) {
  var proto = base.Class.prototype
    , add = proto.add

  util.define
  ( proto
  , 'add'
  ,  function(val) {
       if( !val.process )
       {
          add.apply( this, arguments )
       } else
       {
          val.__tempAdd = util.arg( arguments )
          val.__tempAdd.unshift(this)
       }
     }
  )

  base.extend({
    process: function(val) {
      console.log('xxxx___xxxx')
      if(this.__tempAdd && !this.parent) {
        add.apply(this.__tempAdd[0], this.__tempAdd.slice(1))
        this.__tempAdd = null
      }
    }
  })

})

//process wordt mischien meer een operator?
//soort field eigenlijk
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/scrollbar.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = require('../../events')
  , cases = require('../../cases')
  , ua = require('../../ua')
  , global = false
  , NONE = 'none'
  , _ios = ua.platform==='ios'
  , _android = ua.platform==='android'
  , VISIBLE = 'visible'
  , extend = require('../../../util').extend
  , doc = events.document
  , timer
  , fn

if(cases.$hasTouch){

  function blur (e){
    if(!document.activeElement){
      doc.removeEvent(false,'blur')
    }else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM'){
      document.activeElement.blur()
      doc.removeEvent(false,'blur')
    }
  }

  events.preventDown = 
  { val:
    { down:function(e,method) {
        if(document.activeElement) doc.addEvent('up',blur,'blur')
        else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM' && !events._maybescroll) e.preventDefault()
      }
    }
  }

  events.scrollbar = 
  { val: 
    { down:function(e,method,val) {

        var scrollStart
          , t = this
          , scrollStr
          , xAxis = (val._val === 'x')
          , axis
          , otheraxis
          , move
          , d
          , bottomPrevent
          
        if(xAxis) {
          axis = 'x'
          otheraxis = 'y'
          scrollStr = 'scrollLeft'
          d = t.node.scrollWidth - t.node.offsetWidth
        }else{
          axis = 'y'
          otheraxis = 'x'
          scrollStr = 'scrollTop'
          d = t.node.scrollHeight - t.node.offsetHeight
        }

        scrollStart = t.node[scrollStr] //<======== less efficient but more predictable for compensation

        if(d > 0){
          events[axis] = true
          events._maybescroll = true
          if(!xAxis){
            if (!scrollStart){
              scrollStart = t.node[scrollStr] =  1
            }else if(scrollStart===d) {
              scrollStart = t.node[scrollStr] = d - 1
            }else if(scrollStart > d){
              bottomPrevent = true
            }
          }

          var y = e.y
            , x = e.x
            , moveid = scrollStr + axis
          
          doc.addEvent('move',function(e){
            var dx = Math.abs(x-e.x)
              , dY = y-e.y
              , dy = Math.abs(dY)

            if(xAxis){
              if(dy > dx){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
            }else{
              if(dx > dy){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
              if(bottomPrevent && dY > 0){
                e.preventDefault()
              }
            }

            move = true
            blur(e)
            doc.removeEvent(false,moveid)
          },moveid)

          doc.addEvent('up',function(e) {
            var ms = events._maybescroll, msl, arr

            if(!move){
              var scrll = t.node[scrollStr]
              move = !(scrll === scrollStart) || scrll < 0 || ( scrll > d && !bottomPrevent )
            }

            if(!move && !events[otheraxis] && !events.click.block && ms && ms.length){
              msl = ms.length
              while(msl--) if(!e.prevent){
                arr = ms[msl]
                arr[0].call(arr[1],e)
              }
            }

            if(!events[otheraxis] || move) events._maybescroll = false

            events[axis] = false
            doc.removeEvent(false,scrollStr)

            window.requestAnimationFrame(function(){
              document.body.scrollTop = 0
            })
          },scrollStr)
        }
      }
    }
  }

  fn = function (val) {
      
    var style = this.node.style

    style.overflow = 'scroll'
    style.webkitOverflowScrolling = 'touch'
    style.msTouchAction = 'auto'
    style.touchAction = 'auto'

    if (val.val === 'x') {
      style.msTouchAction = 'pan-x'
      style.touchAction = 'pan-x'
      style.overflowY = 'hidden'
      style.overflowX = 'scroll'
    }else if (val.val === 'y') {
      style.msTouchAction = 'pan-y'
      style.touchAction = 'pan-y'
      style.overflowX = 'hidden'
      style.overflowY = 'scroll'
    }

    this.events = { scrollbar:val.val }
    if(!global) {
      global = true
      doc.events = { preventDown:true }
    }
  }

}else{

  fn = function (val) {
    console.error('nunu hey!')

    var style = this.node.style;
    style.overflow = 'auto';
    style.overflowY = val.val !== 'x' ? 'scroll' : 'hidden';
    style.overflowX = val.val !== 'y' ? 'scroll' : 'hidden';
  }

}

exports.extend = extend(function(base) {
  base.extend({ scrollbar:fn })
})  
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../../events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/util.js":[function(require,module,exports){
var ua = require('../../ua')
  , _prefix = '-'+ua.prefix.toLowerCase()
  , _transform = _prefix + '-transform'

exports.getMatrix = function(node) {
  if(node.style[_transform]) {
    var arr = window.getComputedStyle(node, null)
      .getPropertyValue(_transform).replace('matrix(', '').split(',')
    return arr
  }
}

// exports.hasCalc = function() {
//   var dummy = document.createElement('div')
//     , props = [ _prefix+'-calc', 'calc' ]
//     , i = props.length
//   while(i-1) {
//     dummy.style.cssText = 'width:' + props[i-1] + '(1px);'
//     if (dummy.style.length) return props[i-1]
//     i--
//   }
// }
},{"../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , element = require('./')
  , object = require('../../object')

/**
 * flags
 * add keywords to set objects which are checked using a function in flags
 * simply add fields to the set module
 */
var flags = exports
  /**
   * _flag
   * function that calls flag functions on element.set.flags
   */
  , _flag = function(name, val, copy, top) {
      var f;
      for (var i in flags) {
        f = flags[i].call(this, name, val, copy, top);
        if (f) {
          return f;
        }
      }
    }

util.define(element,
  /**
   * set
   * adds children for non existing attributes
   * _original are original values changed by cases and events
   * instances - add or remove children from instances;
   */
  '_set', function(val, i, instances) {
    //this
    if (!_flag.call(this, i, val[i], instances, val)) {

      if ( !this.isProperty( i, val ) ) {

        if (val[i] instanceof element) {
          var before
          if (this[i]) {
            for(var c=this.node.childNodes,node$=0,len=c.length;node$<len;node$++) {
              if(c[node$]===this[i].node) {
                before = c[(node$+1)]
                break;
              }
            }
            this[i].remove && this[i].remove();
          }
          //replace element if its already there
          // console.error(add, instances, val[i])
          var add = instances ? new val[i].Class : val[i];
          add.name = i;
          this.add(add, before);
          if (instances) {
            this.eachInstance(function() {
              var a = new add.Class();
              a._name = i;
              this.add(a);
            });
          }
        } else {
          
          if( this[i] instanceof object ) 
          {
            //TODO: torough testing
            this[i].val = val[i]
          } 
          else if( val[i] instanceof object ) 
          {
            console.warn('are you sure you want to set using a vObject? maybe require some stuff (e.g. data)')
            this[i] = val[i]
          } 
          else if( this[i] instanceof element ) 
          {
            if( val[i] ) {
              this[i].set(val[i], instances)
            } else if( val[i] === false ){
              if ( instances ) {
                this.eachInstance(function() {
                  if (this[i]) this[i].remove()
                })
              }
              this[i].remove()
              this[i] = null
            }
          } 
          else 
          {
            if(val[i] instanceof Object ) {
              var add = new element().set(val[i], instances)
              add.name = i;
              this.add(add)
              if (instances)
              {
                this.eachInstance( function() {
                  var a = new add.Class()
                  a._name = i
                  this.add(a)
                })
              }
            } else {
              console.warn('"' + i + '" is not an existing property. "' + val[i] + '" is a primitive. Adding as primitive.' )
              this[i] = val[i]
            }

          }
        }
      } else {
        if(typeof this[i] === 'function') {
          if(val[i] instanceof Array) {
            this[i].apply(this,val[i])
          } else {
            this[i](val[i])
          }
        } else {
          this[i] = val[i]
        }
      }
      //dynamic changes to the _original set object pool
      //if (!copy && this._original) {
      //this._original[i] = val[i]; //check if stuff /w classes is nessecary;
      //}
    }
  },
  /**
   * convert
   * for each fields in val convert back to a setObject;
   */
  'convert', function(val) {
    var setObj = {},
      isObj;
    for (var i in val) {
      isObj = util.isObj(val[i])
      if (this[i] instanceof element) {
        setObj[i] = isObj ? this[i].convert(val[i]) : this[i]
      } else if (this[i] instanceof object) {
        setObj[i] = this[i].convert(isObj && val[i])
      } else if (this[i] === void 0 || (util.lookup.call(this, i) && this[i] === false)) {
        setObj[i] = false
      } else {
        setObj[i] = this[i]
      }
    }
    return setObj
  })
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
//duration in a V.Value --> update if nessecary?
var ua = require('../../ua')
  , video = require('./')
  , postpone = require('../../../browser/events/util').postpone
  , _winPhone = ua.platform === 'windows' && ua.device === 'phone'
  , _ios = ua.platform === 'ios'
  , _android = ua.platform === 'android'
  , _ios7 = _ios && navigator.userAgent.split('OS')[1][1] === '7' // TEMP FIX UNTIL WE DO UA
  , _canplay = 'canplay'//_ios7 ? 'canplaythrough' : 'canplay' 

function createListener () {
  var args = arguments
    , l = args.length

  return function(type) {
    for (var i = 0, _this = this; i < l; this.node.addEventListener(args[i++]
      , function(e) { type._val.call(_this,e) }));
  }

}

function _canplayListener () {
  if ( !this._canplay && !_winPhone ) { //later versions (if fixedin 9)
    
    var _this = this
      , node = this.node
    
    this._canplay = true
    
    // if(_ios) node.style.visibility = 'hidden'

    function canPlay() {
      if ( _this.time ) {
        
        if (!_this.time.val) this._firstT = true
          //fixes for phonegap! windowsmobile
        if (_android && ua.browser !== 'chrome') { 
          //and special browser!; check firefox; //identify more browsers that do not need this crap
          var tries = 0
          clearInterval( _this._timeFixInterval )
          _this._timeFixInterval = setInterval(function() {
            _this.updateTime()
            if (tries === 3) {
              _this._canplay = null
              clearInterval(_this._timeFixInterval)
            }
            if (_this.node.duration !== 1) { //android sets duration to 1 as default instead of 0
              tries++
              if (_this.playing) _this.node.play()
            }
          }, 200)
        } else {

          if (_this.time.val) {
            if (_ios7) {
              setTimeout(function() { _this.updateTime() }, 0)
            } else {
              _this.updateTime()
            }
          } else {
            _this._forceTime = true 
          }

          if( _ios && this.playing ){
            var time = _this.time.val * _this.duration.val
            function timeupdate(){
              if(~~node.currentTime >= ~~time){
                node.removeEventListener('timeupdate', timeupdate)
                if(_ios7){
                  function canplaythrough(){
                    node.play()
                    node.style.visibility = 'visible'
                    node.removeEventListener('canplaythrough',canplaythrough)
                  }
                  node.addEventListener('canplaythrough',canplaythrough)
                }else{
                  node.play()
                }
              }
            }

            node.addEventListener('timeupdate', timeupdate)
            node.pause()
          }

          _this._canplay = null

        }
      }

      node.removeEventListener(_canplay, canPlay)
    }

    this._canPlay = canPlay
    node.addEventListener(_canplay, canPlay)
  }
}

function setTime (val) {
  if (this.node.readyState) {
    this.node.currentTime = val
    if (_ios) this._correctTime = val
  } else {
    _canplayListener.call(this)
  }
}


module.exports =  
{ progress: {
    set: function() {
      var _this = this
      this.node.addEventListener('end', (_this._prEnd = function() {
        _this.clearProgress()
      }))
    },
    remove: function() {
      this.node.removeEventListener('canplay',this._canPlay)
      this.node.removeEventListener('end', this._prEnd) //maybe no play and pause!;
    }
  }
, buffer: function(val) {
    var buffered = this.node && this.node.buffered
    if (buffered) {
      var l = buffered.length
        , piv = -1
        , t = this.node.currentTime || 0
        , ls
        , tt
        , i = 0
      
      for (; i < l; i++) {
        ls = buffered.start(i)
        if (ls > piv && ls < t) {
          piv = i
          tt = ls
        } else {
          break
        }
      }
      if (piv > -1) {
        piv = buffered.end(piv)
        return piv < t ? 0 : piv / this.duration.val
      } else {
        return 0
      }
    }
    return 0
  }
, play: function(val) {
    if(this.node && this.node.pause) {
      if (val) {
        this.node.play()
      }
      else {
        this.node.pause()
      }
    }
  }
, time: 
  //tests for android , winphone, firefoxphone (seeking on winphone is not possible anyways)
  { set   //_ios  || _android //ua.device === 'phone' || ua.device === 'tablet'
      // postpone(setTime)
    : setTime
  , get: function(val) {
      var time = this.node && this.node.currentTime
      if (this._correctTime) {
        if (this._correctTime > time - 2 && this._correctTime < time + 2) { //|| this.cnt
          time = this._correctTime
          if (!this.cnt) {
            this.cnt = 3
          } else if (this._cnt < 2) {
            this._correctTime = false
            this._cnt = false
          } else {
            this._correctTime+=0.5 //should be interval of progress updates
            this._cnt--
          }
        } else {
          time = this._correctTime
        }
      }
      return time / this.duration.val || val.val
    }
  }
, duration: function(val) {
    var node = this.node
    return node && node.readyState ? node.duration : val && val.val
  }
, autoplay: function(val) {
    if(this.node) this.node.autoplay = val.val
  }
, loop: function(val) {
    if(this.node) this.node.loop = val.val
  }
, volume: function(val) {
    var volume = val.val
    if(this.node && !isNaN(volume)) this.node.volume = volume
  }

, "new": function() {
    this.addEvent('down',function(e){ e.preventDefault() })
    _canplayListener.call(this)
    if (this.volume) this.volume.update(this)
  }
, events: {
    pause:function(val) {
      var _this = this
      if(_ios && _this.node) { 
       _this.node.addEventListener('pause', function(e) {
         if(!_this.ignoreevents) _this.pause()     
       })
      }
    }
  , progress: video.progress
  , ready: createListener('loadedmetadata')
  , canplay: function(val) {
      var _this = this
      if(_this.node) _this.node.addEventListener(_canplay, function(e) {
        if(_this.node && _this.node.readyState===4) {
          _this._stalled = false
          val._val.call(_this,e)
        }
      })
    }
  , stalled: function(val) {
      var _this = this
        , node = this.node
        , listen = function(e) {
          var time = _this.getTime()
          if(!(_this.getBuffer(time)-time > 0.05)) {
            _this._stalled = true
            val._val.call(_this,e)
          }
        }
      if(node){
        node.addEventListener('stalled', listen )
        node.addEventListener('waiting', listen )
      }
    }
  , play: 
    { play: function() {
        if (this.events.play) this.events.play._val.call(this)
      }
    , set: false
    }
  , end: createListener('ended')
  }
, src: function(val) {
    var src = this.node.src
    if (src !== val || val || !val && src) this.node.src = val.val
  }
}

if (!video.player) video.player = module.exports
},{"../../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var element = require('../')
  .inject
  ( require('../properties')
  )

  , events = require('../../events')
  , util = require('../../../util')
  , postpone = require('../../events/util').postpone
  , base = new element({
      node: 'video'
  })
  
module.exports = exports = base.Class
var video = exports
exports.base = base

base.setSetting(
{ name: '_videoSettings'
, new: function() {
    if (this.player.new) this.player.new.call(this)
  }
, remove:function() {
    if (this.player.remove) this.player.remove.call(this)
  }
, render:function() {
     if (this.player.render) this.player.render.call(this)
  }
})
//proxy adden --> should be an extension on src
base.node.setAttribute('webkit-playsinline', '')

//cloud shorten these 3 functions
function _vidEvents (val) {

  this._readyForEvents = true

//   console.log('\n\n\n\n\nn\n\n\nSET VIDEVENTS')

  var t = this
    , e = (this.player || video.player).events
  val.each(function(i) {
    if (e[i] && e[i].set !== false) (e[i].set || e[i]).call(t, this, i)
  })
  return e
}

function _removeVidEvents (val) {
  var t = this
    , e = (this.player || video.player).events

  val.each(function(i) {
    if (e[i] && e[i].remove) e[i].remove.call(t, this, i)
  })
}

function _playHook (param) {
  var val = this.events
  if (val) {
    var t = this
      , e = (this.player || video.player).events
    val.each(function(i) {
      if (e[i] && e[i].play) e[i].play.call(t, this, i, param)
    })
  }
}

function _progress(val) {

  // console.error('SET progress',this._progress)

  if (!this._progress) {

      // console.error('SET progress for REAL',this._progress)

    //maybe do this with requestAnimationFrame -- danger lies in incosistency with timing
    var params = val
      , interval = params.interval && params.interval.val || 500 
      , fn = params._val
      , t = this
      , pr = (this.player || video.player).progress

    if (pr && pr.set) pr.set.call(t)

    t._progress = setInterval(function() {

      // console.log('before progress call!',t.src.val)
      // if(t.playing&&!t.__paused) {
      //   // t.play()
      //   // no src!
      // }

      var p = Number(t.getTime())
        , b = t.getBuffer(p)
        , d = Number(t.duration.val)

      if(d===1) d=0 //android fix -- maybe remove

      if (p >= 1 && d) {
        t.pause()
        t.playing = false //should this be removed an go to end? 
        //call pause and set time in here?
        t.clearProgress()
      } else {

        if(t._stalled && d) { //just to make sure buffering always dissapaers    
          if(b>0.85 || (t.__lp && t.events.canplay && (p > t.__lp+(1/d)))) { //in seconds
            t._stalled = false
            t.events.canplay._val.call(t)
            t.__lp = null
          } else if( (!t.__lp) && p>-1) {
            t.__lp = p
          } 
        }

        if(!t.ignoreevents) fn.call(t, p, b)
      }
    }, interval)
  }
}

this._progress = _progress

exports.progress = 
{ play: function(i, p, pa) {
    if (pa) {
      _progress.call(this, this.events.progress)
    } else {
      this.clearProgress()
    }
  }
, set: function(val) {
    if (this.playing) _progress.call(this, val)
  }
, remove: function() {
    this.clearProgress()
  }
}

util.define(exports
, 'resumePlay', postpone(function() {
    if(this.node) {
      if(this.$playing.val===true) {
        this.play()
      }
      this.isSeeking = null
      // console.error('RESUME!')
    }
  },1001)
, 'setEvents', function() {
    _vidEvents.call(this, this.events)
  }
, 'play', function(clear, ignore) {

    if (clear) delete this.ignoreevents
    if (!ignore && !this.ignoreevents && this.playing !== true) {
        this.playing = true
        _playHook.call(this, true)
    } else if(this.__paused && this.events.progress) {
      this.playing = true
      _progress.call(this,this.events.progress)
    }
    this.__paused = null
    ;(this.player || video.player).play.call(this, true)
  }
, 'pause', function(ignore) {

    if(ignore) this.ignoreevents = true

    if (!this.ignoreevents && this.playing !== false) {
      this.playing = false
      _playHook.call(this, false)
      if(this.events.pause) {
        this.events.pause._val.call(this)
      }
    } else {
      this.clearProgress()
    }

    this.__paused = true
    ;(this.player || video.player).play.call(this, false)
  }
, 'toggle', function(val) {
    if (this.playing) {
      this.pause()
    } else {
      this.play()
    }
  }
, 'updateTime', function() {
    this._firstT = false
    exports.setTime.call(this, this.time)
  }
, 'getTime', function() {

    // console.error(this.isSeeking)

    return this.isSeeking 
      || (this.rendered && this.player 
      || video.player).time.get.call(this, this.time) 
      || 0
  }
, 'getBuffer', function(val) {
    return (this.rendered && this.player || video.player).buffer.call(this, val || 0)
  }
, 'clearProgress', function() {
    if (this._progress) {
      // console.log('remove that progress')
      clearInterval(this._progress)
      this._progress = null
      var pr = (this.player || video.player).progress
      if (pr && pr.remove) pr.remove.call(this)
    }
  }
)

base.extend(
{ name: 'player'
, type: false
, set: function(val) {
    util.setstore.call(this)
    this.__.player = val
    if (val.element) this.node = val.element
    if (this._class) this._class.prototype._.player = val
  }
, get: function(val) {
    return util.getStore.call(this, 'player') || video.player || {}
  }
}
, 
{ name: 'duration'
, set: function(val) {}
, get: function(val) {
    val._overwrite = (this.player || video.player).duration.call(this, val)
    return val
  }
}
,
{
  name:'$playing'
, set:function( val ) {
    //stamp info
    // if( this.rendered ) //TODO avoid heavy check
    // {
      // console.error('!!!!!!!!!!!set $playing', val.val)
      if( val.val )
      {
        this.play()
      }
      else
      {
        this.pause()
      }
    // }
  }
}
, 
{ name: 'time'
, set: 
  (exports.setTime = function(val) {
    if (!this._ignore) {


      val._overwrite = null
    
      var v = val.val
        , i = false

      if (v !== void 0) {
        if (!this._firstT || this._forceTime === true) { 
          v = Math.abs(v)
          i = true;
          this._firstT = true
          this._forceTime = null
        }

        if (v >= 0) {



          if(this.duration){
            this.isSeeking = v

            // if(playing) this.pause()

            if(this.__lp) this.__lp = null
            ;(this.player || video.player).time.set.call(this, v * this.duration.val)
            if(this.events.seeking && !i)  this.events.seeking._val.call(this,v)

            this.resumePlay()

          }else{
            console.error('can\'t set time, no duration defined!')
          }

          

        }
      }

    }
  })
}
, 
{ autoplay: function(val) {
    (this.player || video.player).autoplay.call(this, val)
  }
, loop: function(val) {
    (this.player || video.player).loop.call(this, val)
  }
, volume: function(val) {
    (this.player || video.player).volume.call(this, val)
  }
, src: function(val) {
    if(val.val!==this.___Src) {
      this.___Src = val.val
      if(this.events.src)  this.events.src._val.call(this,val)
      ;(this.player || video.player).src.call(this, val)
      // console.error('!!!!!!!!!!!set src')

      if(this.$playing.val === true) {
        this.play()
      }

    }
  }
}
, 
{ name: 'events'
, "new": function() {
    //deze functie kunnen instellen
    if(  (this.player && this.player.setEvents !== false)) {
      _vidEvents.call(this, this.events)
    }
  }
, remove: function() {
    if(this.rafId)
    { 
      window.cancelAnimationFrame(this.rafId)
      this.rafId = null
    }
    _removeVidEvents.call(this, this.events)
  }
, set: function(val) {
//   console.log('EVENTS!')
    
    var a = util.arg(arguments)
    
      a[5] = this._readyForEvents 
           ? _vidEvents.call(this, val) 
           : (this.player || video.player).events 

      if(!a[5].seeking) a[5].seeking = {set:false}
      if(!a[5].src) a[5].src = {set:false}
    
    events._set.apply(this, a)
  }
})

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
exports.time = function(time, decimals) {
  var hrs = ~~ (time / 3600),
    mins = ~~ ((time % 3600) / 60),
    secs = decimals ? (time % 60).toFixed(decimals) : ~~(time % 60);
  ret = "";
  if (hrs > 0) ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
  ret += "" + mins + ":" + (secs < 10 ? "0" : "");
  ret += "" + secs;
  return ret || 0;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/advanced.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var events = require('./')
  , operators = require('../../value/operators')
  , doc = events.document

module.exports = events

operators._e = function(val, operator) {
  return val + operator
}

operators._esub = function(val, operator) {
  return val - operator
}

operators._e.order = 3
  
function chooseMove (val, method) {
  return val.move && val.move._val 
    || !method.__t && method !== true && method 
    || method._val;
}

function drag (e, method, val) {
  var t = val.bind ? val.bind._val : this
    , move = chooseMove(val, method)
    , id = 'drag'
  e.preventDefault()
  if (move) doc.addEvent('move', function(e) {
    move.call(t, e, val)
  }, id)

  if (val.down) val.down._val.call(t, e, val)
  
  doc.addEvent('up', function(e) {
    if (val.up) val.up._val.call(t, e, val)
    doc.removeEvent(false, id)
  }, id)
}

function active (e, method, val) {
  var self = this
    , id = 'active'
    , timer = setTimeout(function(){
        self.css = {addClass:val._val}
        timer = null
      },50)

  if(exports._deactivate) exports._deactivate()

  exports._deactivate = function(){
    if(timer) clearTimeout(timer)
    doc.removeEvent(false,id)
    exports._deactivate = null
    window.requestAnimationFrame(function(){
      if(!self) return
      if(!self._stayActive) self.css = {removeClass:val._val}
      else self.css = {addClass:val._val}
    })
  }

  doc.addEvent('move',exports._deactivate,id)
  doc.addEvent('up',exports._deactivate,id)
}

function shallowRaw (vobj) {
  var obj = {}
    , keys = vobj.keys
    , key
    , i = keys.length - 1
  for (; i >= 0; i--) {
    key = keys[i]
    obj[key] = vobj[key]
  }
  return obj
}

function initGrab (t, e, val, name) {
  if (!t[name] || !t[name]._e) t[name] = { _e: 0 }
  if (val[name]._val !== true) t[name].set('_e', shallowRaw(val[name]))
  return e[name] - (t[name]._e.val)
}

function grab (e, method, val, nested) {
  var t = val.bind && !nested ? val.bind.val : this
    , id = ( val.y 
      ? 'y' 
      : val.x 
        ? 'x' 
        : 'xy') 
        + 'Grab' 
        + (nested || '')
  if (t) {
    if (t._node) {
      var move = chooseMove(val, method)
        , startX = e.x
        , startY = e.y
        , ready
        , cX
        , cY
        , oldX
        , oldY
        , newX = startX
        , newY = startY
        , pass
        , upFn = function(e) {
            t.x._p = false
            t.y._p = false
            if (val.up && pass) {
              val.up._val.call(t, e, {
                x: newX - startX,
                y: newY - startY
              },
              { x: newX - oldX
              , y: newY - oldY
              })
            }
            events.click.block = false
            doc.removeEvent(false, id)
          }
      if (!val.x && !val.y){ //this needs revision
        val.x = {_val: true}
        val.y = {_val: true}
      }
      if (val.down) val.down._val.call(t, e, val);
      doc.addEvent('move', function(e) {
        oldX = newX
        oldY = newY
        newX = e.x
        newY = e.y

        events.click.block = true

        if (!ready) {
          pass = val.pass ? val.pass._val.call(t, e, {
            x: newX - startX,
            y: newY - startY
          }) : true
          if(!pass) {
            upFn(e)
            move = false
            doc.removeEvent(false, id)
          } else {
            e.preventDefault()
            if (val.x) {
              cX = initGrab(t, e, val, 'x')
              t.x._p = 1
            }
            if (val.y) {
              cY = initGrab(t, e, val, 'y')
              t.y._p = 1
            }
            if (val.start) val.start._val.call(t, e, val)
            ready = true
          }
        }else{
          e.preventDefault() //for android
          if (cX) t.x = { _e: newX - cX }
          if (cY) t.y = { _e: newY - cY }
          if (move) move.call(t, e, {
              x: newX - startX,
              y: newY - startY
            },val) //check for speed
        }
      }, id)
      doc.addEvent('up', upFn, id)
    } else {
      for (var i = t.length - 1; i >= 0; i--) {
        grab.call(t[i], e, method, val, i + 1)
      }
    }
  }
}
//add the events
events.drag = { val: { down: drag } }
events.grab = { val: { down: grab } }
events.active = { val: { down: active } }
},{"../../value/operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/basic.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = module.exports = require('./')
  , cases = require('../cases')
  , util = require('../../util')
  , ua = require('../ua')

cases.$hasTouch =
( ( 'ontouchstart' in window )
  || window.DocumentTouch
  && document instanceof DocumentTouch
)
|| navigator.msMaxTouchPoints
|| false

function _basic(e, method, val) {
  e.x = e.pageX
  e.y = e.pageY
  method.call(this, e, val)
}

util.define
( events
, '_out'
, { value: [] }
)
//clickout cannot be used to create complex events! it's too custom 
//tried to fix

function keyBoardEvent( name, domEvent, wrapper ) {

  var _name = '_'+name

  util.define( events, _name, { value:[] } )

  var event = 
  {
    create: function( field, from ) {
      var exec = function( e ) {

        //dit gaat heel snel fout hiero
        // console.log('nu ff ook de wrapper callen!', field, from, events[from])
         if( this.rendered ) {

          if( wrapper ) {
            wrapper.call(this, e, this.events[from]._val )
            //this.events[from]._val.call(this, e)
          }
          else if( events[from] && events[from].val) {
            var method = events[from].val
            for(var i in events[from]) {
              if( cases[i]) {
                method = events[from][i]
              }
            }
            method = method[field]
            if( method ) {
              method.call(this, e, this.events[from]._val )
            } 
          } else if( this.events[from] ) {
            this.events[from]._val.call(this, e)
          }

        }
      }
      events.document.addEvent( domEvent, function(e) {

        for ( var arr = events[ _name ], i = arr.length - 1; i >= 0; i-- ) {
          exec.call( arr[i], e )
          
          if( arr[i] ) {
            // console.log( 'do it now!', _name, arr, arr[i], e)
            arr[i].eachInstance( exec, 'events', e )
          }

        }
      }, name )
    },
    add: function( id, field ) {

      field = _name

      this.setSetting(
      { name: field
      , remove: events[ name ].remove
      })

      if ( !util.checkArray( events[ _name ], this ) ) 
      {
        events[ _name ].push(this)
      }

    },
    remove: function() {
      // console.log('WRONGWRONGWRONG!!!!!', _name, events[_name], events)
      //selected moet mischein alleen vanuit Value $focused -- niet op elk item op key up....
      //doe dit smart -- for now zou auto remove kunnen doen als iets er niet meer is?
      var index = util.checkArray( events[ _name ], this, true ) 
      if( ~index ) {

        var noRemove

        // console.log('this:', this )
        // console.log('from base:', this._from.base)
        // console.log('event name:', name)
        // console.log('events:', this.events )
        if(this.events && this._from.base.events) { 
          noRemove = this.events[name] === this._from.base.events[name]
          // console.log('events equals class:', noRemove )
        } else {
          // console.error('no nice events')
        }
        
        if(!noRemove) {
          events[ _name ].splice( index, 1 )
        }
        else {
          console.log(noRemove, 'noRemove evnt, are we sure - fix this asap')
        }
        // debugger
        // this.removeSetting( name ) --- redo this later
      }
    }
  }

  events[ name ] = event

}

events.$makeKeyBoardEvent = keyBoardEvent

keyBoardEvent( 'keyboard', 'keyup' )
keyBoardEvent( 'keyboardDown', 'keydown' )
keyBoardEvent( 'keyboardDown$down', 'keydown' )
keyBoardEvent( 'keyboardDown$click', 'keydown' )

//-----dit ff echt goed fixen!

function basicDown(e, method, val) {
  if( e.which!==1 || events.down.block ) return
   _basic.call(this,e, method, val)
}

events.down =
{ $hasTouch:
  { touchstart: function(e, method, val) {
      if(events.down.block) return
      var targetTouches = e.targetTouches[0] || {}
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
    }
  }
, val: { mousedown: basicDown }
// , tv: 
//   {  // mousedown: basicDown //combineren binnen kort moet voor LG
//      keyboardDown$down: function( e, method, val ) {
//       //this._$focused && 
//       if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) 
//       {
//         method.call(this, e, val)
//       }

//     }
//   }
}

//right-down
events.rdown =
{ $hasTouch:
  { touchstart: function () {
      //2 fingers?
    }
  }
, val:
  { mousedown: function (e, method, val) {
      if(e.which===3) {
        document.oncontextmenu = function() { return false }
        e.preventDefault()
        // e.rdown = true
        _basic.call(this,e,method,val)
        setTimeout(function() { document.oncontextmenu = false }, 0)
      }
    }
  }
}

//move
events.move = {
  $hasTouch:
  { touchmove: function (e, method, val) {
      var targetTouches = e.targetTouches[0]
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
      // document.write(e.targetTouches[0].pageX);
    }
  }
  , val: {
    mousemove: _basic
  }
}

//up
events.up = {
  //keyUp
  $hasTouch: {
    touchend: function(e, method, val) {
      var ct = e.changedTouches
      e.x = ct[0].pageX
      e.y = ct[0].pageY
      method.call(this, e, val)
    }
  }
, val: {
    mouseup: _basic
  }
}

//click
events.click = {
  // tv: {
  //   keyboardDown$click: function(e, method, val ) {

  //     if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) {
  //       method.call(this, e, val)
  //     }

  //   }
  // },
  val: {
    down: function(e, method, val) {

      // console.log('CLICK IT!')

      var t = this
        , name = 'click'
      if(!events.click.block){
        t.addEvent('up', function(e) {
          t.removeEvent('up', name)
          var ms = events._maybescroll
          if(ms){
            if(ms.length) events._maybescroll.unshift([method,t])
            else events._maybescroll = [[method,t]]
          }else if(!events.click.block) method.call(t, e, val)
        }, name);
        setTimeout(function() {
          t.removeEvent('up', name)
        }, 300)
      }
    }
  }
}

events.rclick = {
  val: {
    rdown:events.click.val.down
  }
}

var _outRemove = function() {
    var index = util.checkArray(events._out, this, true)
    if (~index) {
      events._out.splice(index, 1)
      this.removeSetting('_out', _outSetting)

      // debugger

    }
  }
, _outSetting = {
  name: '_out',
  render: function() {
    if (!util.checkArray(events._out, this)) {
      events._out.push(this)
    }
  },
  remove: _outRemove
}

events.out = {
  create: function() {
    this.m = true;
    events.document.addEvent('up', function(e) {

      var base = e.target,
        exec = function() {
          var p = base
            , t
          while (p && !t) {
            if (p.base && this === p.base) {
              t = true;
            } else {
              p = p.parentNode;
            }
          }
          if (!t && this.rendered) this.events.out._val.call(this, e)
        }
      for (var arr = events._out, i = arr.length - 1; i >= 0; i--) {
        exec.call(arr[i])
        if (arr[i]) arr[i].eachInstance(exec, 'events')
      }
    },'out')
  },
  add: function() {
    var t = this
     // events._out.push(this)
    this.setSetting(_outSetting)
  },
  remove:_outRemove
};
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var element = require('../element')
  , cases = require('../cases')
  , util = require('../../util')
  , FieldStore = function () {}

util.define(FieldStore, '_uid', { value: 0 })

exports._r = {} //list of basic (raw) events e.g. 'mousedown'

//remove events if there are no children that use them anymore

exports.document = new element({ node: document })

exports.document.exec = function( event ) {
  if( this.__e[event] )
  {
    var args = util.arg( arguments, 1 )
    for( var i in this.__e[event] )
    {
      this.__e[event][i].apply( this, args )
    }
  }
}

function _create( i, from ) {
  if( exports[i] )
  {
    // console.log('complex', i, from)
    _createComplex( i, from )
  }
  else
  {
    // console.log('_basic', i)

    exports[i] = { _basic: true }
    _createBasic( i )
  }
}

function _createWhile (i, m) {
  return function(e) {
    var parent = e.target
      , base, events
    while (parent) {
      base = parent.base
      if (base) {
        events = base.events
        if (events[i]) {
          if (m) {
            exports[i]._m.call(base, e, events[i])
          } else if (events[i]._val) {
            events[i]._val.call(base, e)
          }
          if (e.prevent) return
        }
        events = base.__e
        if (events && events[i]) {

          for (var j in events[i]) {
            if(j!=='_uid') {
              if (m) {
                exports[i]._m.call(base, e, events[i][j])
              } else {
                // console.log('?what', i, j, base, base._node)
                events[i][j].call(base, e)
              }
              if (e.prevent) return
            }
          }
        }
      }
      parent = parent.parentNode
    }
  }
}

function _createBasic (i, r) {
  var type = i || r

  // console.log('createBasic', type,i)

  exports._r[i] = true
  if(type === 'scroll') {
    document.addEventListener(type, function(e){
      var base = e.target.base
        , events

      if(base) {
        events = base.events
        if(events && events[i]) events[i]._val.call(base, e)
        events = base.__e
        if (events && events[i]) {
          for (var j in events[i]) {
            if(j!=='_uid') events[i][j].call(base, e)
          }
        }
      }
    },true)
  }else document.addEventListener(type, (exports[i].m = _createWhile(i)))
}

function _setComplex ( i, m, r, from ) {
  var met = exports[i]._m = function (e, val) {
    if (e.prevent) return
    m.call(this, e, (val._val || val.val || val), val)
  }
  exports[i].m = _createWhile(i, true)
  exports._r[i] = true
  if (exports[r]) {
    if (!exports[r].m) {
      _create(r, from )
    }
    if (!exports[r]._basic) {
      exports[i].__e = exports[r].__e
      exports[i]._m = function (e, m) {
        exports[r]._m.call(this, e, function(e) {
          met.call(this, e, m)
        })
      }
    } else {
      exports[i].__e = r
    }
  }
  document.addEventListener((exports[r] && exports[r].__e) || r, exports[i].m)
}

var addWrapper = function( add, field, orig ) {
  return function() {
    // console.log( 'ADD WRAP!', field, orig , arguments )
    return add.apply(this, arguments)
  }
}

function _createComplex( field, from ) {

  // console.log('_createComplex' ,field, from )

  if( exports[field].create ) exports[field].create( field, from)
  var m
    , i
    , j
  for ( i in exports[field] ) {
    if (cases[i] === true) m = exports[field][i]
  }
  if ( m || ( m = exports[field].val ) ) {
    for (j in m) //only one
    ;exports[field].__e = j

    if (m[j] === true) 
    {
      exports[field]._basic = true
      _createBasic(field, j)
    } 
    else 
    {
      //basic en non basic ijn niet te combineren -- combineren nog kapot
      // console.log('set complex field', field, m, j,  exports[j]) 
      //!!!tripple check dit!!!
       for( j in m ) 
       { 
        if( exports[j] && exports[j].add 
         && exports[field] && !exports[field].add
        ) 
        {
          exports[field].add = addWrapper( exports[j].add, field, j )
        }
        _setComplex(field, m[j], j, from )
      }
      //!!!danger loop!!!
    }

  }
}

exports._set = function (val, stamp, from, remove, cval, blacklist) {
  var t = this
  val.each(function (i) {
    if (!blacklist || !blacklist[i]) {
      if (this._val === false) {
        if (exports[i]) {
          if (exports[i].remove) exports[i].remove.call(t)
          t.eachInstance(exports[i].remove, val._prop.name)
          this.remove()
        }
      } else {
        
        // console.log('_cre', i, exports[i])

        if (!(exports[i] && exports[i].m)) {
          // console.log('---pass', i)
          _create(i, i)
        }
        //add wrapper?


        // console.log('_set',i, exports[i].add, exports[i])

        if (exports[i].add) exports[i].add.call( t, false, i )
      }
    }
  })
}

element.base.extend(
{ name: 'events'
, set: exports._set
})

util.define(element
, 'addEvent', function(field, fn, id) {
          // console.log('XXXX',field)

    if (!(exports[field] && exports[field].m)) _create(field)
    var events = this.__e || (this.__e = {})
      , f = events[field] || (events[field] = new FieldStore())

    if (!id) {
      f._uid++
      id = f._uid
    }
    f[id] = fn

    // console.log('addEvent!!!', field)

    if (exports[field].add) exports[field].add.call(this, id, field)
    return this
  }
, 'removeEvent', function (field, id, fn) {
    var events = this.__e
      , remove
    if (events) {
      if (field && events[field]) {
        remove = (exports[field] && exports[field].remove)
        if (id) {
          if (events[field][id] && (!fn || events[field][id] === fn)) {
            if (remove) exports[field].remove.call(this, id)
            delete events[field][id]
          }
        } 
        else {
          for (id in events[field]) {
            if (!fn || events[field][id] === fn) {
              if (remove) exports[field].remove.call(this, id)
              delete events[field][id]
            }
          }
        }
        if (util.empty(events[field])) delete events[field]
      } 
      else if (!field) {
        for (field in events) {
          this.removeEvent(field, id, fn)
        }
      }
    }
    if (util.empty(events)) delete this.__e
    return this
  })

require('./basic')

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","./basic":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/basic.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js":[function(require,module,exports){
var matrix = require('../element/properties/util').getMatrix
  , vigour = require('../../')
  , css = require('../css')

exports.left = exports.x = function ( object, arr ) {
  return offset(object,arr,'left','offsetLeft', 4)
}

exports.top = exports.y = function ( object, arr ) {
  return offset(object,arr,'top','offsetTop', 5)
} 

function offset ( object, arr, prop, propL, matrixIndex ) {
  if(!object) return 0
  var start = false
  if(!arr) {
    arr = []
    start = true
  }
  
  if(vigour.Element && object instanceof vigour.Element) object = object.node

  var amount = object[propL]
    , temp = 0
  if(typeof(amount) !== 'number') amount = 0
  if(object.parentNode) exports[prop](object.parentNode, arr)
    if( ( (object.style && object.style.position)
      ||object.__preCss
      ||object.className 
        && (object.__preCss = css(object.className, 'position')||true)) 
      !== 'absolute' ) {
        arr.push(['rel', amount])
    } else {
      var matrixArray = matrix(object)
      arr.push(['abs', matrixArray 
        ? parseInt(matrixArray[matrixIndex],10)+amount //normal amount as well
        : amount ])
    }
  
  if(start) {
    var lastrel
      , abs = 0
      , i
    for(i in arr) {
      if(arr[i][0] == 'abs') {
        abs += arr[i][1]
      } else {
        lastrel = arr[i][1]
      }
    }
    amount = arr[arr.length - 1][0] === 'rel' ? abs+lastrel : abs
  }
  return amount || 0
}

  



},{"../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../css":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js","../element/properties/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js":[function(require,module,exports){
var raf = require('../animation/raf')
  , util = require('../../util')

exports.throttle = function(fn, frames, bind) {
  frames || (frames = 20) //~0.4sec
  var timer
    , arg
    , nobind = !bind
  return function() {
    arg = arguments
    if(nobind) bind = this
    if(!timer) {
      timer = frames
      raf(function repeat() {
        timer--
        if(!timer) {
          fn.apply(bind,arg) 
        } else {
          raf(repeat)
        }
      })
    }
  }
}

//TODO: postpone based on frames
exports.postpone = function(fn, time, bind) {
  time || (time = 200) //no raf!
  var timer
    , arg
    , nobind = !bind
  return function() {
    arg = arguments
    if(nobind) bind = this
    if(timer) clearTimeout(timer)
    timer = setTimeout(function() {
      fn.apply(bind,arg)
    },time)
    return timer
  }
}

//TODO: test for leaks...
exports.interval = function(fn, frames, bind) {
  frames || (frames = 30) //~0.5sec
  var timer
    , clear
    , arg = util.arg(arguments,3)
  if(!timer) {
    timer = frames
    raf(function repeat() {
      timer--
      if(!timer) {
        timer = frames
        fn.apply(bind,arg)
      } 
      if(!clear) raf(repeat)
    })
  }
  return function() {
    clear=true
  }
}

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var _a = 'addEventListener'
  , util = require('../../util')
  , ua = require('../ua')
  , cnt = 0

/**
 * xhr wrapper, adds some nice extras such as multiple requests to a single api call
 * xhr wrapper will include jsonp in a later stage
 * @method extend
 * @param   {String|Array} params.url         Specifiy the url, array fetches multiple url's
 * @param   {String}   [params.api]           Repeat this string for the url that needs to be called
 * @param   {Function} [params.complete]      Specify a callback when an array is passed to url complete is called when all items are complete
 * @param   {Function} [params.error]         On error callback
 * @param   {Function} [params.change]        Function called on xhr.onreadystatechange
 * @param   {Boolean}  [params.async]         If set to false will call an syncronous request (not recommended!)
 * @param   {String}   [params.user]          User parameter
 * @param   {String}   [params.pass]          Password parameter
 * @param   {Boolean}  [params.parse]         If set to false will not try to parse response to JSON
 * @param   {String}   [params.type|.method]  POST or GET, default is get;
 * @param   {String}   [params.contentType]   request content type default id "application/x-www-form-urlencoded"
 * @param   {String}   [params.mime]          defines mime type
 * @param   {Function} [params.progress]      Progress callback
 * @param   {Boolean|String} [params.jsonp]   Use jsonp , if passed as a string determines script+?callback=
 * @param   {Object}   [params.header]        Sets request headers
 * @param   {*}        [params.data]          Pass data to the request, defaults to ? on get;
 */

var iframes
  , ajax = module.exports = function(params, urlset) {
    var _url = params.url;
    if (!urlset && _url instanceof Array) {
      params.m = function() {
        if ((++params.r) === params.n) {
          for (var i = 0, arr = [], l = _url.length; i < l; arr.push(params.d[_url[i++]]));
          params.complete(arr);
        }
      };
      params.r = 0;
      params.d = {};
      for (var i = 0, l = params.n = _url.length; i < l; module.exports(params, _url[i++]));
    } else {
      var data = params.data
        , encode = params.encode
        , url = (params.api || '') + (urlset || _url)
        , headers = params.headers
        , success = params.complete
        , progress = params.progress
        , error = params.error
        , change = params.change
        , mime = params.mime
        , user = params.user
        , pass = params.pass
        , jsonp = params.jsonp
        , parse = params.parse
        , iframe = params.iframe
        , reqdata = null
        , fallback = params.fallback
        , fallbackIndex = params._fallbackIndex
        , method = params.type || params.method || 'GET'
        , contentType = params.contentType || encode === 'json'
          ? 'application/json'
          : 'application/x-www-form-urlencoded'
        , async = (params.async === false) ? false : true
        
      if( jsonp ) 
      {
        ajax.jsonp( url, success, error )  
        //function( url, success, error, context, cbName ) {
      } 
      else 
      {
        // ------------------------------------------------------------ DATA
        var xhr = new XMLHttpRequest()
        if(iframe) {
          cnt++
          var elem
            , msg = {}
            , reqid = cnt

          for(var field in params) {
            if(field!=='error'&&field!=='iframe'&&field!=='complete') {

              msg[field]=params[field]
            }
          }
          var setmsg = function() {
            var elem
            iframes[iframe].onload = null
            var msgcomplete = function(e) {
              // console.error('IFRAME REQ MSG COMPLETE',e.data)
              if(e.data) {
                var d
                try {
                  d = JSON.parse(e.data)
                } catch(e) {
                  if(error) error(e)
                  return
                }
                if(d.id!==reqid) return
                if(d.err) {
                  if(error) {
                    error(d.err)
                  }
                  return
                }
                var resp = d.msg
                if(success) {
                  if (parse !== false) {
                    try {
                      resp = JSON.parse(resp)
                    } catch (e) {}
                  }
                  success(resp,e)
                }
                removeEventListener('message', msgcomplete)
              }
            }
            if(window.addEventListener) {
              addEventListener("message", msgcomplete, false)
              elem = iframes[iframe].contentWindow
              msg = JSON.stringify({
                msg:msg,
                id:reqid
              })
              elem.postMessage(msg, '*')
            }
          }

          if(!iframes) iframes = {}
          if(!iframes[iframe]) {
            elem = iframes[iframe] = document.createElement('iframe')
            elem.src = iframe
            elem.cListeners = [
              setmsg
            ]
            elem.onload = function() {
              for(var h in elem.cListeners) {
                elem.cListeners[h]()
              }
              elem.cListeners = null
            }
            elem.style.visibility='hidden'
            elem.style.width = '0px'
            elem.style.height = '0px'
            elem.style.position = 'absolute'
            document.body.appendChild(elem)
          } else if(iframes[iframe].cListeners) {
            iframes[iframe].cListeners.push(setmsg)
            //elem.cListeners[i]
          } else {
            setmsg()
          }
          return;
        }

        if (data) {

          if (method === 'GET') {
            url += '?' + enCode(data, 'GET', encode)
          } else {
            reqdata = enCode(data, 'POST', encode)
  //           console.log( reqdata )
          }
        }

        // ------------------------------------------------------------ METHOD, URL, ASYNC, USER & PASS
        xhr.open(method, url, async, user, pass)
        // ------------------------------------------------------------ HEADERS
        xhr.setRequestHeader('Content-Type', contentType)
        if (headers) {
          for (var f in headers) {
            xhr.setRequestHeader(f, headers[f]);
          }
        }

        // ------------------------------------------------------------ EVENTS
        if (success) {
          xhr[_a]("load", function(e) {
            var resp = (e.target || e.srcElement).response;
            if (parse !== false) {
              try {
                resp = JSON.parse(resp)
              } catch (e) {}
            }
            if (params.m) {
              params.d[urlset] = resp
              params.m()
            } else {
              success(resp, e)
            }
          }, false)
        }
        if (error) {
          if(!fallbackIndex) params._fallbackIndex = 0
          if(fallback && fallbackIndex!==fallback.length) {
            params._fallbackIndex++
            params = util.merge(params,fallbackIndex)
            ajax(params, urlset)
          } else {
            xhr[_a]("error", error, false)
          }
        }
        if (progress) {
          xhr[_a]("progress", progress, false)
        }
        if (change) {
          xhr.onreadystatechange = change
        }
        // ------------------------------------------------------------ MIME
        if (mime) {
          xhr.overrideMimeType(mime)
        }
        // ------------------------------------------------------------ SEND

        xhr.send(reqdata)
      }
    }
  }

var jsonpStamp = 0

ajax.jsonp = function( url, success, error, context, cbName ) {

  if( !cbName || cbName === true ) cbName = 'callback'

  var name = '_jsonp_' + jsonpStamp++
    , script = document.createElement('script')
  
  if (url.match(/\?/)) 
  { 
    url += '&'+cbName+'='+name
  }
  else 
  {
    url += '?'+cbName+'='+name
  }
  
  script.type = 'text/javascript'
  script.src = url
  
  if(error) {
    script.onerror = function( e ) {
      error( e )
    }
  }

  window[name] = function(data){
    success.call(( context || window ), data)
    document.getElementsByTagName('head')[0].removeChild(script)
    script = null
    delete window[name]
  }
  
  document.getElementsByTagName('head')[0].appendChild(script)

}

var enCode = ajax.encode = function(data, method, encode) {
  var result = ''

  if(encode === 'json'){
    result = JSON.stringify(data)
  } else if(data instanceof Object) {
    if (!util.isNode && (window.FormData && data instanceof FormData) && method !== 'GET') {
      result = data
    } else if (data instanceof Array) {
      result = JSON.stringify(data[f])
      if(encode === 'uri') result = encodeURIComponent(result)
    } else {
      for (var f in data) {
        var val = data[f]
        if(val instanceof Object) val = JSON.stringify(val)
        if(encode === 'uri'){
          f = encodeURIComponent(f)
          val = encodeURIComponent(val)
        }
        result += f + '=' + val + '&'
      }
      result = result.slice(0, -1)

    }
  } else {
    result = (encode === 'uri') ? encodeURIComponent(data) : data
  }
  // console.log('encoded:', result)
  return result
}
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/authenticate.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(extend)

function extend(Cloud) {
  util.define( Cloud
  , 'authenticate', function authenticate(req, cb, re){
      window.authrequest = req
      var cloud = this

      if(typeof req === 'function')
        req = req()

      if(!req)
        return cloud.socket.removeListener('connect', reAuth)

      cloud.emit('authenticate', req, function(res){
        if(res.hop)
          cloud.hop(res.hop)
        else if(cb)
          cb(res)
      })
     
      if(!re){
        cloud.on('connect', reAuth)
      }

      function reAuth(){
        console.error('connect ->>> reAuth?')
        if(cloud._status > 2){
          console.error('reconnect ->>> reAuth!', req)
          cloud.authenticate(req, cb, true)
        }
      }
      cloud._reAuth = reAuth
    }
  , 'logout', function logout(userid){
      var cloud = this

      cloud.emit('logout', userid)

      if(
        cloud.data.users[userid] && 
         cloud.data.users[userid].activeClient 
         && cloud.data.users[userid].activeClient.from._name === cloud.clientid
       ) 
       {
         cloud.data.users[userid].activeClient.remove()
       }

      
      var stamp = cloud.stamp

      if(userid){
        if(cloud.data.users[userid])

        if( 
          cloud.data.users[userid].activeClient 
          && cloud.data.users[userid].activeClient.from._name === cloud.clientid) 
        {
          cloud.data.users[userid].activeClient.from = cloud.data.users[userid].activeClient
        }

        cloud.data.users[userid].remove(void 0, void 0, void 0, void 0, stamp)
        // else
        //   console.error('that user does not exist')
      } else{
        cloud.data.users.each(function(userid){
          this.remove(void 0, void 0, void 0, void 0, stamp)
        })
      }

      cloud.socket.removeListener('connect', cloud._reAuth)
      cloud._reAuth = null

    }
  )
}
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var util = require( '../../../util' )
  , NetworkData = require( '../data' )
    .inject( require( '../../../object/hashpath' ) )
    //TODO: add localstorage --> , !util.isNode && require('../../../object/localstorage')
  , networkDataElement = require( '../data/element' )
  , Data = require( '../../../data' )
  , preventUpdate
  , vObject = require( '../../../object' )
  , monoStamp = require( 'monotonic-timestamp' )
  , CloudData = NetworkData.new
    ( false //put some settings!
    , function CloudData( val, hook, parent, cloud ) {
        var _this = this

        if( cloud )
        {
          _this.cloud = cloud
          _this.addListener(cdListener)

          if(!util.isNode && !!window.cordova) 
          {

            document.addEventListener('pause', function() {
              //TODO: this does not work yet -- make prevent update a usable thing in app logic ( e.g. in device lists or clients )
              _this.preventUpdate = true
            }, false)

            document.addEventListener('resume', function() {
              
              cloud.kickPing()

              if( _this.timeout )
              {
                clearTimeout( _this.timeout )
              }

              _this.timeout = setTimeout( function() {
                if( _this.defered ) 
                {
                  _this.merge( _this.defered.data, false, _this.defered.stamp )
                }
                _this.preventUpdate = null
                _this.defered = null
                _this.timeout = null
              }, 100 )
              // _this.preventUpdate = true //wait for another update and timeout
            }, false)
          }

          cloud.on
          ( 'set'
          , function( data ) {
 
            // console.clear()
            
            // console.group()
            // console.log('\n-----------INCOMING CLOUD-------\n', data )

            // if()

            // console.log(JSON.stringify(data, false, 2).slice(0,200))
            // console.groupCollapsed()
            // console.log(JSON.stringify(data, false, 2))
            // console.groupEnd()
              // console.log('INCOMING!\n', JSON.stringify(data))
              var set = data.s
                , vclock = data.v
                // , stamps = vclock[1]
                , subs = cloud.state.subs.map
                , substamp = vclock[1]

              if( vclock[0] instanceof Array )
              {

                //vclock where is it??????

                for( var i = vclock[0].length; hash = vclock[0][--i]; )
                {
                  updateSub( subs[hash], substamp )
                }

              }
              else
              {
                updateSub( subs[data.v[0]], substamp )
              }

              // substamp = 0

              // for( var s in stamps )
              // {
              //   console.log('burrr', stamps[s])
              //   if( stamps[s] > stamp ) stamp = stamps[s]
              // }

              var stamp = monoStamp()
              cloud.stamp = stamp

              // _this._time

              if( !_this.preventUpdate ) 
              {
                _this.merge( data.s, false, stamp )
              } 
              else
              {
                if(!_this.defered)
                {
                  //pause geen timeout alleen maar uitstellen
                  _this.defered = 
                  { data: data.s
                  , stamp: stamp
                  }
                }
                else 
                {
                  _this.defered.stamp = stamp
                  _this.defered.data = util.merge( _this.defered.data, data.s)
                  // _this.defered.data._update( data.s )

                }
              }

            }
          )

        }
        else if( parent )
        {
          _this.cloud = parent.cloud
        }

      }
    )
  , __update

module.exports = CloudData

function updateSub( cached, vclock ) {
  if( !cached ) return

  return // not implemented

  // var sub = cached.subsobj
  // if( !sub._v ) sub.set( '_v', {} )

  // for( var f in vclock )
  // {
  //   sub._v.set( f, vclock[f] )
  // }

}

function createSub( path, sub, partialSub ) {

  if( path.length )
  {
    util.path( sub, path, partialSub, true )
    return sub
  }
  else
  {
    return partialSub
  }

}

function t4walker( val ) {
//TODO: remove $t:4
  for( var i in val )
  {

    if(val[i] instanceof Object)
    {

      if(val[i] instanceof vObject)
      {
        val[i] = { $path: val[i]._path } // $t: 4 
      }
      else
      {
        t4walker( val[i] )
      }

    }

  }

}

function cdListener( val, stamp, from, remove, added, old ){
  var cloud = this.cloud
  // console.log('OOOO cloudata listenerbur', this._path, val)
  if( stamp === 'localStorage' || stamp===false  )
  {
    // console.log('I WILL NOT UPDATE'.red.inverse)
    // console.log('Cloud from localstorage'.inverse.red)
    return
  }


  if( stamp !== cloud.stamp && val !== void 0 )
  {

    // console.log('>>>>>> shiner')

    // console.log('\n\n\n\n\nupdate cloud', val)



    if( remove && from )
    {
      if( from._removed )
      {
          // console.log('!!!!!!UPDATE CLOUD!!!', from && from._path, val, stamp)

        cloud.set(from._hashpath, [from._path, null, cloud.timeStamp()])
      }

    }
    else if ( from && !this._cloudignore )
    {


      // if( stamp === void 0 ) {
      //   alert('X')
      // }

      // console.log( 'cccccccccccc update!', this._path , from._updateOrigin, from._cachedPath)

      // console.error('_update Origin call from cloud.data') 
      if( from._updateOrigin === from ) //hier gaat iets mis
      {
        if( from.__t === 2 && val instanceof Object ) {
//           console.log(from, val)
          t4walker(val)
        }


        //["users", "U_fe7cc800136b7608", "clients", "V_kuco2zs2qf"]
        var p = from&&from._path
        if(p && p[0] === 'users' && p[p.length-2] && p[p.length-2] === 'clients' ) {
          //TODO: very dirty fix!
          // console.error('break it down!', p, p, val )
          return
        }

        if(p && p[0] === 'users' && p[1] === 'media') {
          throw(new Error('THIS IS WRONG ABORT!---> setting users.media '+p.join('.')))
          // console.error('THIS IS WRONG ABORT!---> setting users.media', p)
          return
        }


        cloud.set
        ( from._hashpath
        , [ from._path
          , from.__t === 4 ? {  $path: val._path } : val //$t: 4,
          , cloud.timeStamp()
          ]
        )

      }

    }

  }

}

CloudData.prototype._blacklist.push('cloud', 'datacloud', '_batchUnsub','_cloudignore', '_lstamp', '$t', '$loaded', '_fromlfrom')

__update = CloudData.prototype.__update

CloudData.inject( require('vigour-js/object/flags') )

CloudData.flags.$path = {
  reset:true,
  set: function(val, stamp, reset) {
    
    if( reset ) {
      throw new Error('cloud data $path flag reset???')
    }
  
    var t = this
    if(stamp !== this.cloud.stamp) {
      throw new Error('set with $path only allowed from the hub')
    }

    var path = util.changeType( val )
    if(path.length){
      // console.log('___________ $path set')
       // val, set, notself, stamp 
       // noupdate
      this._$setVal( this.cloud.data.get( path, {}, void 0, stamp ) ,stamp,false,true)
    }

    if(this.__t!==4) {
      throw new Error('cloud data $path flag __t !== 4')
    }

  }
}


var _set = CloudData.prototype.set

var _$setVal = CloudData.prototype._$setVal

//CloudData add flags

//( name, val, vobj, stamp, noupdate, from )
util.define
( CloudData
, '_$setVal', function( val, stamp ) {
   //setVal

   // console.log('.............', this._path, stamp, stamp && this.cloud.stamp === stamp)
   if(this.cloud.stamp === stamp && !this.$loaded) {
    //TODO: faster to do ! loaded
    var parent = this
    while(parent && !parent.$loaded) {
      parent.$loaded = true
      parent = parent._parent
    }
   }

   _$setVal.apply( this, arguments )
  }
, 'set', function(name, val, vobj, stamp){
  if (stamp !== this.cloud.stamp &&
      this._name === 'clients' &&
      !this[name] && 
      name !== this.cloud.clientid
     ) {
    console.error('\n\nI WANT TO BLOCK THIS YA DURK',
      '\nstamp !== this.cloud.stamp', stamp !== this.cloud.stamp,
      "\nthis._name === 'clients'", this._name === 'clients',
      "\n!this[name]", !this[name],
      "\nname !== this.cloud.clientid", name !== this.cloud.clientid
    )
    debugger
    // return false
  }
  return _set.apply(this, arguments)
}
, 'updateQueue'
, function() {
    // why this???
  }
, 'stamp'
, function(){
    if( !this.cloud ) {
      console.error( 'WAT NO CLOUD?! in this:\n', this )
      return
    }
    return this.cloud.timeStamp()
  }
, '__update'
, function( val, stamp, from, remove, added, oldval ) {

    // if(stamp && this._lstamp === stamp) return


    // console.log(from, '\n', this._lfrom, from, from&&from._lfrom._cachedPath, this._cachedPath, this._lfrom)
    if(from && from._lfrom) {

      this._fromlfrom = from._lfrom
      // console.error(this._fromlfrom)
      // return
    }

    if(this._fromlfrom && this._fromlfrom === (from && from._lfrom) && this._lstamp===stamp) {
      //TODO: this is a memory leak get rid of it circ refs should be resolved from vobj itself
      delete this._fromlfrom
      return
    }

    this._lstamp = stamp

    // if(this._path[0]==='clients') {
    //   console.log('2', this._path, stamp===this.cloud.stamp)
    // }
    // console.log('1 lets __update', this._path, arguments)
    // if( this._ignore  ) {
      // console.log('21 lets __update', this._path, arguments)
      // delete this._ignore
      // return false
    // }
    //most nested update hier addition maken voor process
    // console.log(val, stamp, from)
    //is dit maybe weird???
    return __update.call( this, val, stamp, from, remove, added, oldval )
  }
, '_set'
, function (val, stamp) {
    if( !stamp ) return
    if( this._lstamp > stamp )
    {
      return
    }
    // console.log('lets set it!!!', this._path, arguments)

    return NetworkData.prototype._set.apply( this,arguments )
  }
, 'subscribe'
, function( val, from, parentFixer ) {
              // console.log('start')

    if( from && from.cloud  && from._val === this ) {

        //BUG: dit kan heel veel broken maken!!!!!!!
//         console.log('\n\nHURK!!!!!! DIT IS TEMP MOET NIET EEN EXTRA SUB GEMAAKT WORDEN!' )

        // from = void 0

        //TODO: dit is helemaal wrong GET RID OF IT!!!!
        // return
    }

    // console.log( 'lets do it sub sub'.cyan.inverse, this, val, from, parentFixer )
    // if(from) {
      // console.log('GOT FROM', from , 'SUBSCRIBE')
    // }
     if (!val || typeof val === 'function') { return; }
     // if(val instanceof vObject) {
     //    val = val.from
     // }


     var path = this._path
       , elem = val[1]
       , sub
       , partialSub
       , stringified
       , subsArray
       , exists
       , listeners
       , fromName

      var found = path && util.checkArray( path , 'usage' )
    


    // if( found || found===0) {
            // console.log('lets try to sub', val && val._path, ':', this._path )
      // }
   

    // if(elem) {
    //   console.error(elem, elem._col, elem._dfrom, elem._fmodel)
    // }

    // console.log('SUBSCRIBE', elem._dfrom, elem._fmodel, 'DFROM, FMODEL!')

    // if (elem && !elem._col && (!elem._dfrom || elem._fmodel)) {
    var isElem = (elem && !elem._col && (!elem._dfrom || elem._fmodel))

    if( isElem && !elem.getModel) {
      // console.error('be carefull! cloud data elem does not have getModel')
    } else if( isElem ) {

      // console.error('XXX!')
      //hier dingen vinden voor
      // console.log('!DFROM!')

    //isElem

    //val, from, parentFixer

    // if(val[3] && val[3] instanceof Array) {
    //       console.log( 'YES!!!' )

    // }

          // console.log( '!!!!!!111111', arguments, val[3], from, parentFixer, this, path )

    var fieldignore
    if( val[1]._ignoreFieldInSubscription ) {
      // alert('!'+val[3])
      if(!val[3]) {
        // console.log('FIELDIGNORE'.blue.inverse, val, this, path )
        // debugger

        // if(fi)

        fieldignore = true
      }
    }

    //TODO: has to become val[2]!!!
    //typeof from === 'string' ? from :
      //dit is niet goed!!!!
      fromName = val[3]

    // console.log( '--------22!!!!!!111111', partialSub, val[3], '\n\n?', val[3]._name  )

      //val[3] instanceof Data
      partialSub = elem.getModel( this,  val[3] , fieldignore )
      // console.clear()
    // console.log( '----!!!!!!111111', partialSub )
      // if(partialSub && partialSub.specialFix) {
      //   console.log('LETS DO IT ITI IT', partialSub, partialSub.specialFix, path)
        
      //   // if(partialSub.specialFix instanceof Array ) {

      //   //   console.log( path, partialSub.specialFix, partialSub )
      //   //   if(path[path.length-1] === partialSub.specialFix[0]) {

      //   //     if(partialSub.$ && partialSub.$[partialSub.specialFix[1]]) {
      //   //         console.log('do it!')
      //   //         partialSub = partialSub.$[partialSub.specialFix[1]]
      //   //     }

      //   //   }

      //   // } else 

      //   if(path[path.length-1]===partialSub.specialFix) {
      //     path.pop()
      //   }
        
      //   delete partialSub.specialFix
      // }

      // console.log('LETS DO IT ITI IT'.green.inverse, partialSub)

      // partialSub.DEBUG$log('partial')

    } else if (val instanceof Data && val.__sub) {
    //isData+Subscription
      //dit moet ook gefixed!!!!!!!!!
      partialSub = networkDataElement.parseData(val)

    } else if (val instanceof vObject ) {
    //vObject
      listeners = val._listeners

      // console.log(this._path, 'LISTENER', from )

      if(listeners) {
        for( var listener$=0, len$=listeners.length; listener$<len$; listener$++ ) {
                // console.log('!!!!!!!!!!! listner$333333'.red.inverse, listeners[listener$])
                  // console.log('--------->',this._path, 'LISTENER, ' , listeners[listener$]._path, val)
          this.subscribe( listeners[listener$], val )
        }
      }

      // if(val._parent && !val._parent.cloud) {
        // console.log('parent',val._parent, val._parent._listeners)
      //   listeners = val._parent._listeners

      //   // val._pa
      //   if(listeners) {
      //     for (var listener$=0, len$=listeners.length; listener$<len$; listener$++) {
      //       this.subscribe(listeners[listener$], false, true)
      //     }
      //   }
      // }

      return;
    } else if (val && util.isObj(val) && !(val instanceof Array)) {
      //isNormalSubscription
      // console.log('IS OBJ'.cyan)
      partialSub = val
      val = JSON.stringify(val)
    }

    if (partialSub) {

     //if! empty
     // console.log('2 LETS DO IT ITI IT 2',this , path, 'from:', from, 'sub:', networkDataElement.parseData(from, partialSub, this._subs ) )

     var fromCheck
     if(from) partialSub = networkDataElement.parseData(from, partialSub, this._subs)
      //de check moet nu in from gebeuren
      // console.log('.subscribe cloud.data partialSub are we sure this is from a ref in the cloud'.blue.inverse, partialSub, path) //replace /w from

      if(from && from.cloud && from._val === this) {
        path = from._path //if from is cloud
        // alert('!')
        fromCheck = true
        // console.warn('do nothing prop from cloud', from)
      }

     sub = createSub(path, {}, partialSub)
     stringified = JSON.stringify(sub)

     var substarget =  fromCheck ? from : this

     if(!substarget._subs) substarget._subs = []
     if(elem) elem._subscribed = true
     // console.log('3LETS DO IT ITI IT 3'.red.inverse, networkDataElement.parseData(from, partialSub) )

      subsArray = [ partialSub, elem || val , stringified ]

      if(fromName) {
        subsArray.push(fromName)
      }

      exists = util.checkArray( substarget._subs, stringified, 2)
      //maybe check if val already exists
      // console.log(' TEST TRUE ----- SUBSCRIBE', from, exists, this._subs, stringified, partialSub, sub )
      //TODO: check if not exists subsArray each field
      // console.log('PUSH! SUBS'.green.inverse, subsArray ,stringified, exists )
      var same
      for(var i in substarget._subs ) {

        // console.log(substarget._subs[i], i, substarget._path)
        //compare objects

        if( substarget._subs[i][1] === (elem || val) && substarget._subs[i][2] === stringified ) {
          //distincation!!!!
          // console.log('THE SAME'.cyan.inverse)
          same = true
        }

      }

      if(!same) {
      substarget._subs.push( subsArray )
        //just dont subscribe ---
        if ( exists===false ) {

          // console.log(' TRUE ----- SUBSCRIBE', JSON.stringify(sub,false,2) )
          this.cloud.subscribe(sub, stringified)
        }
        else {
          // console.warn('ALLREADY EXISTS!', sub, stringified)
        }
      }
    }

  }
, 'unsubscribe'
, function( val, from ) {

    //todo: double check if this goes well
    // console.error('1unsubscribe!')

    //doundle remove

    if 
    ( !val
      || val._col
      || (val._filter && val._filter._col)
      || !(!val._dfrom || val._fmodel)
    ) 
    { 
      return 
    }

     var path = this._path
       , stringified
       , subsArray
       , sub
       , exists
       , partialSub
       , index
       , field
       , listeners = val._listeners

    // console.log('unsubscriblex','path:'.blue, path, 'stringified:'.blue,  sub, 'this:'.blue,this, 'val:'.blue, val, 'from:',from )

    if ( util.isObj( val ) && !( val instanceof Array ) ) val = JSON.stringify( val )

    index = this._subs && util.checkArray( this._subs, val, 1 )
    //niet alle 1's weghalen

        // console.log('unsubs??????'.red.inverse, util.clone(this._subs), val, index, this )
        //missing index!


    if ( index!==false && index !== void 0 ) {




      if(val.model && val.model.parsing) {

        // console.log('MODEL unsubs??????'.red.inverse)
        // var removeI

        //block unsubs on model parsing
        if(val.model && val.model.field ) {
          // console.clear()
          // console.log('WARN! unsubs field WARN!'.red.inverse, from, this._subs[index] )

          //reapply if field
          field = this.get(val.model.field.val)
          if(!field._subs) field._subs = []

          // console.log('WARN! unsubs field WARN!'.red.inverse,field===this, field, from, this._subs[index] )


          var __subs = util
            .get( this._subs[index][0], val.model.field.val )

            // console.log( 'subs[0]'.blue,  this._subs[index][0] )

          if( __subs ) {
          this._subs[index][0] = __subs
          // field._subs.push(this._subs[index])
          // console.log('REMOVE SUBS and push'.red.inverse, index,field._subs, __subs, this._subs[index], this._path)
          // debugger
          // this._subs.splice(index, 1)
        } else {
          // console.log('warn'.red)

        }
          // console.log( __subs )


         
          //dit ff beter doen (meerdere _subs)
          //tel counts
          
          //voor deze splice check op index en stringified!

         
        }

        return
      }

      subsArray = this._subs[index]
      stringified = subsArray[2]
      partialSub = subsArray[0]
      // if(from) partialSub = networkDataElement.parseData(from, partialSub)

      // console.log( 'partialSub'.inverse, partialSub )

      sub = createSub(path, {}, partialSub)

      //voor deze splice check op index en stringified!
      //kan dus ook efficienter
      // if( removeI !== void 0 ) {
        // console.log('REMOVE', index)
         // console.log('REMOVE SUBS'.red.inverse, index, this._subs, this._path )
          // debugger
        this._subs.splice(index, 1)

      // }



      exists = util.checkArray(this._subs, stringified, 2)

      if(exists!==false) {
        // console.log('EXISTS????'.cyan.inverse, exists, stringified, this._subs, this._path, this)
      } else {
        // console.log('!EXISTS' , exists, stringified)
      }

      if ( exists === false ) this.cloud.unsubscribe(sub, stringified)
        // this._subsRAF.push([sub, stringified])
        // this._subsRAF = [] search & remove use different identifiers e.g. subs array

    } else if( val._removed ) {

            // console.log('unsubs??22222???? 2222222'.red.inverse)

      // console.error('is this really nessecary? _removed , froce all listeners remove tagets etc')
    } else if(listeners) {

                  // console.log('unsubs??333333333???? 2222222'.red.inverse)

      // console.log('----> this is also pretty different! _listeners')
      for (var listener$=0, len$=listeners.length; listener$<len$; listener$++) {
        if (listeners[listener$] instanceof Array) {
          this.unsubscribe(listeners[listener$][1], val)
        } else if (listeners[listener$].__t) {
          this.unsubscribe(listeners[listener$], val)
        }
      }
      return
    }

  }
)

},{"../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../object/hashpath":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/hashpath.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/index.js","../data/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/element.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js","vigour-js/object/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/datacloud.js":[function(require,module,exports){
module.exports = DataCloud

var timestamp = require('monotonic-timestamp'),
  util = require('../../../util/object'),
  CloudData = require('./data'),
  VObject = require('../../../object'),
  Batch = VObject.new({
    merge: true
  }),
  CloudState = VObject.new({
    merge: true
  }),
  makeHash = require('../../../util/hash'),
  batchtime = 20,
  SUBS = 'subs',
  SETS = 'sets',
  UNSUBS = 'unsubs'

function DataCloud () {
  // window.datacloud = this
  var cloud = this
  cloud._joins = {}
  cloud._status = 1

  cloud.on('connect', function () {
    // console.error('---- cloud connect >> cloud._status++ call _reconnect')
    cloud._status++
    cloud._reconnect()
  })

  // console.log('start making state')
  cloud.state = new CloudState({
        subs: {
          map: {},
          tree: {}
        },
        sets: {
          map: {} /*, list:[]*/
        }
      }
      // , { localstorage: 'VC$' }
    )
    // console.log('done making state', JSON.stringify(cloud.state.raw,false,2))

  if (!cloud.state.sets.list) cloud.state.sets.set('list', [])
    // ^^ set met lege array merged niet

  cloud.batch = {
    maps: {
      sets: {},
      subs: {},
      unsubs: {}
    }
  }

  // console.log('------SET C DATA')

  cloud.data = new CloudData({}, false //{localstorage:'cloudData'}
    , false, this)

  // console.log('------LOG')


  // console.log(JSON.stringify( cloud.data.raw,false,2))
  // ^^ dit kan door weirde shit in localStorage de constructor laten kappen!

  // cloud.on('incoming::pong', this._clearCache)
  // cloud.on('data', this._clearCache)

  cloud._qTimer = setInterval(function _qTimer () {
    cloud._doBatch()
  }, batchtime)


  // cloud.on('welcome', function onWelcome(){

  // })

  cloud.on('subscribed', function (msg) {
    // console.error('>>> Hey Cloud says im subscribed to', msg)
  })

}

DataCloud.prototype.timeSync = function timeSync () {
  // console.log('timeSync!')
  var cloud = this,
    outstamp = Date.now()
  cloud.emit('time', function (cloudstamp) {

    var traveltime = Date.now() - outstamp,
      arrival = outstamp + traveltime / 2,
      offset = cloudstamp - arrival
      // console.log('timestamp in', traveltime, 'offset', offset)
    if (traveltime < cloud._timeTravel) {
      cloud._timeTravel = traveltime
      cloud._timeOffset = offset
    }
    var tries = cloud._timeTries++
      if (traveltime > 75 && tries < 10 || traveltime > 50 && tries < 5 || traveltime > 20 && tries < 2) {
        cloud.timeSync()
      }
  })
}

DataCloud.prototype.outList = function (label) {
  var batch = this.batch
  if (!batch.lists) {
    batch.lists = {}
    return batch.lists[label] = []
  } else if (!batch.lists[label]) {
    return batch.lists[label] = []
  } else {
    return batch.lists[label]
  }
}

DataCloud.prototype._doBatch = function _doBatch () {
  var cloud = this,
    out = cloud.batch.lists

  if (out) {
    // console.log('emit dat batch out!')
    // console.log('EMITTING!',out)
    // if(typeof window !== 'undefined'){
    //   console.log('writing out', JSON.stringify(out).slice(0,50))
    //   console.groupCollapsed()
    //   console.log(JSON.stringify(out,false,2))
    //   console.groupEnd()
    // }
    cloud.emit('batch', out)
      // cloud.write(out)
      // cache sets untill next heartbeat
      // var setslist = out.sets
      // if(setslist) {
      //   var cache = cloud.state.sets
      //     , setsmap = cloud.batch.maps.sets

    //   for(var hash in setsmap) {
    //     var update = setsmap[hash].update
    //     if(update[1] === null)
    //       update[1] = '$$null'
    //     storeSet(hash, update, cache.list, cache.map)
    //   }
    // }
    cloud.batch.lists = null
    cloud.batch.maps = {
      subs: {},
      sets: {},
      unsubs: {}
    }
  }
}

DataCloud.prototype._clearCache = function _clearCache () {
  // if(this.state.sets.list.length){
  //   this.state.sets.remove()
  //   this.state.set('sets', {map:{},list:[]})
  // }
  // could be nicer if we have a good way of clearing arrays
}

DataCloud.prototype.subscribe = function subscribe (subsobj, str) {
  // console.log('subscribe!', str)
  var cloud = this,
    state = cloud.state,
    hash, cached

  if (subsobj.hash && subsobj.subsobj) {
    // console.log('das cached!')
    hash = subsobj.hash
    cached = subsobj
  } else {
    if (!str)
      str = JSON.stringify(subsobj)
    hash = makeHash(str)
    cached = state.subs.map[hash]
  }
  // console.log('hash', hash)


  if (!cached) { // place in tree

    // console.log('set active!')

    state.subs.map.set(hash, {
      hash: hash,
      subsobj: subsobj,
      active: cloud._status,
      cleared: false
    })
    cached = state.subs.map[hash]
    var tree = state.subs.tree
    insertLeaf(tree, cached.subsobj, cached)
  } else if (!cached.active || cached.active._val) {
    // console.warn('subscription already active!', cached, cached.active)
    return
  } else {
    cached.active.val = cloud._status
  }

  var unsubsmap = cloud.batch.maps.unsubs,
    unsubindex = unsubsmap[hash]

  if (unsubindex !== void 0) {
    cloud.cancel(hash, unsubindex, UNSUBS)
    return
  }

  var subslist = cloud.outList(SUBS),
    subsmap = cloud.batch.maps.subs,
    out

  if (!cached.cleared._val) {
    cached.cleared.val = cloud._status
    var depends = cloud.getDeps(state.subs.tree, cached.subsobj, cached, {})
    if (!util.empty(depends)) {
      out = {
        $subsobj: cached.subsobj.raw,
        $depends: depends
      }
    } else {
      out = cached.subsobj.raw
    }
  } else {
    out = cached.subsobj.raw
    cached.cleared.val = cloud._status
  }

  subsmap[hash] = subslist.length
  subslist.push(out)
}

DataCloud.prototype.getDeps = function getDeps (tree, walker, cached, list) {
  walker.each(function (f) {
    var branch = tree[f]
    if (branch) {
      if (branch._subs) {
        branch._subs.each(function (i) {
          var found = this._val
          if (found.subsobj._v && found.hash._val !== cached.hash._val && !found.cleared._val && !list[found.hash._val]) {
            found.cleared.val = cached.cleared._val
            list[found.hash._val] = found.subsobj.raw
          }
        })
      }
      getDeps(branch, walker[f], cached, list)
    }
  })
  return list
}

DataCloud.prototype.unsubscribe = function unsubscribe (subsobj, str) {
  // still do
  var cloud = this
  // console.error('unsubscribe!', subsobj)
  if (subsobj instanceof Array) {
    // console.log('unsub with array', subsobj)
    var tree = cloud.state.subs.tree,
      spot = tree.get(subsobj)

    if (spot) {
      // console.log('OK UNSUBSCRIBE TO THIS CRAP', spot)
      recurUnsub(cloud, spot, str)
    }
  } else {

    var batchmap = cloud.batch.maps.subs,
      hash,
      cached

    if (subsobj.hash) {
      hash = subsobj.hash.val
      cached = subsobj
    } else {
      if (!str) {
        str = JSON.stringify(subsobj)
      }
      hash = makeHash(str)

      var statemap = cloud.state.subs.map

      cached = statemap[hash]
    }

    var index = batchmap[hash]

    if (index !== void 0) {
      cloud.cancel(hash, index, SUBS)

    } else {
      var list = cloud.outList('unsubs')
      cloud.batch.maps.unsubs[hash] = list.length
      list.push(hash)
    }

    cached.active.val = false
  }

}

function recurUnsub (cloud, spot, clear) {
  // console.log('recurUnsub!', spot._path)
  spot.each(function (f) {
    if (this._subs) {
      this._subs.each(function () {
        // console.log('unsub on this!', this.raw, 'clear?', clear)
        if (clear && this.from.subsobj._v) {
          this.from.subsobj._v.remove()
        }
        cloud.unsubscribe(this.from)
      })
    }
    if (f !== '_subs') {
      recurUnsub(cloud, this, clear)
    }
  })
}

DataCloud.prototype.cancel = function cancel (hash, index, label) {
  var batch = this.batch,
    list = batch.lists[label]
  removeIndex(list, index)
  if (!list.length) {
    delete batch.lists[label]
    if (util.empty(batch.lists)) {
      delete batch.lists
    }
  }
  var map = batch.maps[label]
  delete map[hash]
  for (hash in map)
    if (map[hash] > index) {
      map[hash] --
    }
}

DataCloud.prototype.set = function set (hash, update) {

  // console.log('SET CLOUD!')

  if (!update[0].length) {
    // console.error('EMPTY PATH', update)
  }

  var cloud = this,
    list = cloud.outList(SETS),
    map = cloud.batch.maps.sets

  storeSet(hash, update, list, map)
}

function storeSet (hash, update, list, map) {
  // console.log('storeset?!')
  var V = list.__t,
    stored = map[hash]

  if (stored) {
    var val = update[1],
      ts = update[2],
      oldval = stored.update[1]

    if (V) oldval = oldval.raw

    if (val instanceof Object && oldval instanceof Object && !(val.$path) && !(oldval.$path)) {
      if (!V) oldval = util.clone(oldval)
      val = util.merge(oldval, val)
    }

    if (V) {
      stored.update.set(1, val)
      stored.update.set(2, ts)
    } else {
      stored.update[1] = val
      stored.update[2] = ts
    }

    if (!V) {
      var i = stored.i,
        end = list.length - 1
      if (i !== end) {
        moveToEnd(list, i)
        for (var maphash in map) {
          if (map[maphash].i >= i) map[maphash].i--
        }
        stored.i = end
      }
    }
  } else {
    var setobj = {
      update: update,
      i: list.length
    }
    if (V) {
      map.set(hash, setobj)
    } else {
      map[hash] = setobj
    }

    stored = map[hash]
    list.push(stored.update)
  }
}

DataCloud.prototype._reconnect = function _reconnect () {

  // alert('(RE)CONNECT!')
  // console.error('------------- (RE)CONNECT!')

  var cloud = this,
    state = cloud.state,
    subs = state.subs.map

  cloud._timeTries = 0
  cloud._timeTravel = Infinity
  cloud.timeSync()

  // clean data
  cloud.stamp = 'cleanup'
  if (cloud.data.clients) {
    var myclient = cloud.data.clients[cloud.clientid]

    if(myclient) {
      myclient = myclient.raw
      delete myclient.key
      delete myclient.type
      delete myclient.ip
      delete myclient.token
    }

    cloud.data.set('clients', {
      clear: true
    }, void 0, cloud.stamp)

    // TODO: put all cloud.client logic in one place
    if(cloud.clientid && cloud.client) {
      cloud.client.val = cloud.data.clients.get(cloud.clientid, {})
      if(myclient) {
        cloud.client.from.val = myclient
      }
    }
  }

  if (cloud.data.users) {
    cloud.data.users.each(function () {
      // console.log('CLEAN CLOUD: clean usrt!!', this._name)

      this.set('clients', {
        clear: true
      }, void 0, cloud.stamp)

      // CLEAN MAINSCREEN AND ACTIVE CLIENT?!

      // this.mainscreen.set('clientRef', false, void 0, cloud.stamp)
      // this.mainscreen.clientRef.remove(void 0, void 0, void 0, void 0, cloud.stamp)

      // this.activeClient.remove(void 0, void 0, void 0, void 0, cloud.stamp)

    })
  }

  // if(sets.length){
  //   sets.sort(byTs)
  //   for(var i = 0, set ; set = sets[i++];){
  //     if(set[1] === '$$null')
  //       set[1] = null
  //   }
  //   cloud.write({sets:sets})
  //   // would be nicer to insert them into current batch
  // }

  var resubs = []
  subs.each(function (f) {
    // console.log('resub?', f)
    var cached = this,
      active = cached.active,
      cleared = cached.cleared

    if (active._val === 1) {
      active.val = true
      cleared.val = true
    } else if (active._val) {
      // active._val = false

      active.val = false
      // dit wordt niet in ls opgelsagen

      if (cleared._val === 1) {
        cleared.val = true
      } else if (cleared._val) {
        cleared.val = false
      }
      resubs.push(cached)
    } else if (cleared._val) {
      if (cleared._val === 1) {
        cleared.val = true
      } else {
        cleared.val = false
      }
    }

  })
  for (var i = 0, resub; resub = resubs[i]; i++) {
    // console.error('resubscribe!!', resub.subsobj.raw)
    cloud.subscribe(resub)
  }
  // console.error('done resubscribin')

  for (var j in cloud._joins) {
    cloud.join(cloud._joins[j], true)
  }

}

DataCloud.prototype.timeStamp = function () {
  var ts = timestamp()
  if (this._timeOffset) {
    ts += this._timeOffset
  }
  return ts
}

function insertLeaf (tree, subsobj, cached) {
  subsobj.each(function (f) {
    if (f === '*') {
      if (!tree.$) {
        tree.set('$', {})
      }
      subsobj['*'].each(function (s) {
        subsobj['*'][s][1].each(function (ss) {
          insertLeaf(tree.$, subsobj['*'][s][1][ss], cached)
        })
      })
      return
    }
    if (!tree[f]) {
      tree.set(f, {})
    }
    if (subsobj[f].val === true) {
      if (!tree[f]._subs) {
        tree[f].set('_subs', [cached])
      } else {
        tree[f]._subs.push(cached)
      }
    } else {
      insertLeaf(tree[f], subsobj[f], cached)
    }
  })
}

function moveToEnd (arr, i) {
  var tmp = arr[i]
  while (arr[i + 1]) {
    arr[i] = arr[++i]
  }
  arr[i] = tmp
}

function removeIndex (arr, i) {
  while (arr[i + 1]) {
    arr[i] = arr[++i]
  }
  arr.pop()
}

// function byTs (a, b) {
//   return a[2] - b[2]
// }

},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../../util/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js","./data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js":[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var util = require('../../../util'),
  io = util.isNode 
    ? require('socket.io-client') 
    : require('./socket.io.min.js'),
  G = require('../../../util/global'),
  id = require('../../../util/id'),
  urlEncode = require('../ajax').encode,
  VObject = require('../../../object'),
  Value = require('../../../value'),
  Emitter = require('./emitter')

var Cloud = module.exports = function Cloud (url, params) {
  
  if (!params) {
    params = {}
  }

  var cloud = this
  cloud.params = params
  cloud.url = url
  cloud.VID = params.VID = fixVID(params.VID)
    // var HID = params.HID || G.env('HID')
    // if(HID)
    //   cloud.HID = params.HID = HID
  cloud.connected = new Value(false)

  // cloud.connected.addListener(function(){
  //   console.log('connected: state change >', this.val)
  // })

  cloud.api = new Value({
    defer: function (update, args) {
      var type = this.from.__t
      if (type !== 2) {
        throw new Error('cloud.api needs to be an Object')
      }
      update()
    }
  })

  // cloud.api.on(function(){
  //  console.error('lolk cloud.api is set!! on', this.val)
  // })

  if (params.api) {
    cloud.api.val = params.api
  }

  cloud.addDocumentListeners()

  if (url instanceof VObject) {
    var current = url.val
      // console.log('current', current)

    if (current) {
      cloud.init(url, params)
    } else {
      var placeholder = new Emitter()
      placeholder.emit = function () {
        var buffer = cloud.emitbuffer || (cloud.emitbuffer = [])
        buffer.push(arguments)
      }
      placeholder.placeholder = true
      cloud.socket = placeholder
      url.addListener(function (val, p1, p2, p3) {
        // console.log('URL VAL CHANGE', this.val)
        if (this.val) {
          cloud.init(url, params)
        }
      })
    }
  } else {
    // console.log('normal burk just init', url)
    cloud.init(url, params)
  }

}

Cloud.inject = require('../../../util/inject')

Cloud.prototype.addDocumentListeners = function () {
  var cloud = this
  if (!util.isNode && window.cordova) {
    document.addEventListener('resume', function () {
      // console.log('connected: RESUME')
      cloud.connected.val = false
    }, false)
    document.addEventListener('pause', function () {
      // console.log('connected: PAUSE')
      cloud.connected.val = false
    }, false)
  }
}

Cloud.prototype.init = function (url, params) {
  // console.log('CLOUD INIT!')
  var cloud = this,
    socket = cloud.connect(url, params,
      { disconnect: function () {
          log('disconnect')
          cloud.connected.val = false
        },
        connect: function () {
          log('connect')
          cloud.connected.val = true
          socket.io.engine.on('heartbeat', function () {
            cloud.connected.val = true
          })          
        },
        welcome: function (address) {
          log('welcome')
          address = address.split('@')

          var clientid = cloud.clientid = address[0],
            hubid = address[1],
            state = cloud.state

          cloud.hub = params.h = hubid

          cloud.socket.io.uri = fixUrl(cloud.socket.io.uri, params)
        },
        hop: function (newhub) {
          log('hop')
          cloud.hop(newhub)
        },
        err: function (err) {
          log.error(err)
          if (err.type === 'tokenCheck') {
            if (typeof localStorage !== 'undefined') {
              localStorage.removeItem('productionuserToken')
              localStorage.removeItem('userId')
            }
          }
        },
        reconnecting: logger('reconnecting'),
        reconnect_attempt: logger('reconnect_attempt'),
        reconnect: logger('reconnect'),
        reconnect_failed: logger('reconnect_failed')
      }
    )

  var emitbuffer = cloud.emitbuffer
  if (emitbuffer) {
    for (var e in emitbuffer) {
      socket.emit.apply(socket, emitbuffer[e])
    }
    cloud.emitbuffer = null
  }

}

Cloud.prototype.connect = function (url, params, listeners) {

  var cloud = this

  if (!url)
    url = cloud.url
  if (!params)
    params = cloud.params

  if (url instanceof VObject) {
    url = url.val
  }

  url = fixUrl(url, params)

  var oldsocket = cloud.socket

  if (oldsocket && !oldsocket.placeholder) {
    oldsocket.disconnect()
    oldsocket.io.disconnect()
  }

  // console.log('---------- cloud.connect!', url, params)

  var socket = cloud.socket = new io(url, {
    forceNew: true,
    timeout: 5e3
  })

  if (listeners) {
    for (var l in listeners) {
      socket.on(l, listeners[l])
    }
  }

  if (oldsocket) {
    // console.error('------------- transferring old listeners', socket._callbacks)
    passOn(oldsocket, socket)
  }

  // ------- these extentions are only for logging
  // window.cloudmessages = []
  // var _onevent = cloud.socket.onevent
  // cloud.socket.onevent = function (packet) {
  //   window.cloudmessages.push(JSON.stringify(packet.data, false, 2))
  //   console.log('incoming cloud message!', JSON.stringify(packet.data, false, 2))
  //   _onevent.apply(this, arguments)
  // }
  // var _emit = cloud.socket.emit
  // cloud.socket.emit = function (event, data) {
  //   if (typeof data !== 'function') {
  //     console.log('\ncloud.socket.emit:', event, data)
  //     if (event === 'batch') {
  //       if (data.subs) {
  //         for (var s in data.subs) {
  //           if (data.subs[s].mtvData) {
  //             // console.log('\nsubscribin to mtvData!', data.subs[s].mtvData)
  //           }
  //         }
  //       }
  //       if (data.sets) {
  //         for (var s in data.sets) {
  //           // console.error('set:', JSON.stringify(data.sets[s]))
  //         }
  //       }
  //     }
  //   }
  //   _emit.apply(this, arguments)
  // }
  // ------- these extentions are only for logging
  
  return socket

}

Cloud.prototype.hop = function hop (newhub) {

  // console.log('GOT ORDER TO HOP TO', newhub)

  var cloud = this,
    params = cloud.params
    // --------------- dev
  if (newhub.indexOf('@') !== -1)
    cloud.url = 'ws://' + newhub.split('@')[1]
    // --------------- /dev
  cloud.hub = params.h = newhub
  cloud.connect()
}

Cloud.prototype.whenReady = function whenReady (fn) {
  if (this.clientid)
    fn()
  else
    this.once('welcome', fn)
}

Cloud.prototype.kickPing = function kickPing (time) {
  var e = this.socket.io.engine
  e.ping()
  e.onHeartbeat(time || e.pingTimeout)
  e.setPing()
}

Cloud.prototype.disconnect = function disconnect () {
  var socket = this.socket
  if (socket) {
    socket.disconnect()
    socket.io.disconnect()
  }
}

delegateList(Cloud.prototype, 'socket', ['on', 'once', 'emit'])

function delegateList (obj, target, list) {
  for (var i = list.length - 1; i >= 0; i--) {
    delegate(obj, target, list[i])
  }
}

function delegate (obj, target, field) {
  obj[field] = function delegated () {
    var thing = this[target]
    thing[field].apply(thing, arguments)
  }
}

function logit (flag) {
  return function logger () {
    if(window.gaston){
      console.log(':: vigour-cloud ::', flag, arguments)
    }
  }
}

var vflag = ':: vigour-cloud ::'
function log () {
  if(window.gaston){
    var args = util.arg(arguments)
    args.unshift(vflag)
    console.log.apply(console, args)
  }
}
log.error = function (flag, err){
  console.error(vflag, flag, '\n', err)
}
function logger (flag){
  return function logger () {
    var args = util.arg(arguments)
    args.unshift(vflag, flag)
    console.log.apply(console, args)
  }
}

function fixVID (VID) {
  VID = VID || G.session('VID') || id('V_')
  return G.session('VID', VID)
}

function passOn (from, to) {
  for (var e in from._callbacks) {
    var fromlist = from._callbacks[e]
    for (var i = 0, fn; fn = fromlist[i]; i++) {
      // console.log('hand over dat listner', fn.name === 'on' && fn.fn ? 'once' : 'on',e, fn.fn || fn)
      if (fn.name === 'on' && fn.fn) {
        to.once(e, fn.fn)
      } else {
        to.on(e, fn)
      }
    }
  }
  from.off()
}

function fixUrl (url, params) {
  var cutoff = url.indexOf('?')
  if (cutoff > -1) {
    url = url.slice(0, cutoff)
  }
  return url + '?' + urlEncode(params, 'GET', 'uri')
}
},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/global":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/global.js","../../../util/id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js","../../../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js","./emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js","./socket.io.min.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/socket.io.min.js","socket.io-client":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/socket.io.min.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){module.exports=_dereq_("./lib/")},{"./lib/":2}],2:[function(_dereq_,module,exports){var url=_dereq_("./url");var parser=_dereq_("socket.io-parser");var Manager=_dereq_("./manager");var debug=_dereq_("debug")("socket.io-client");module.exports=exports=lookup;var cache=exports.managers={};function lookup(uri,opts){if(typeof uri=="object"){opts=uri;uri=undefined}opts=opts||{};var parsed=url(uri);var source=parsed.source;var id=parsed.id;var io;if(opts.forceNew||opts["force new connection"]||false===opts.multiplex){debug("ignoring socket cache for %s",source);io=Manager(source,opts)}else{if(!cache[id]){debug("new io instance for %s",source);cache[id]=Manager(source,opts)}io=cache[id]}return io.socket(parsed.path)}exports.protocol=parser.protocol;exports.connect=lookup;exports.Manager=_dereq_("./manager");exports.Socket=_dereq_("./socket")},{"./manager":3,"./socket":5,"./url":6,debug:10,"socket.io-parser":46}],3:[function(_dereq_,module,exports){var url=_dereq_("./url");var eio=_dereq_("engine.io-client");var Socket=_dereq_("./socket");var Emitter=_dereq_("component-emitter");var parser=_dereq_("socket.io-parser");var on=_dereq_("./on");var bind=_dereq_("component-bind");var object=_dereq_("object-component");var debug=_dereq_("debug")("socket.io-client:manager");var indexOf=_dereq_("indexof");var Backoff=_dereq_("backo2");module.exports=Manager;function Manager(uri,opts){if(!(this instanceof Manager))return new Manager(uri,opts);if(uri&&"object"==typeof uri){opts=uri;uri=undefined}opts=opts||{};opts.path=opts.path||"/socket.io";this.nsps={};this.subs=[];this.opts=opts;this.reconnection(opts.reconnection!==false);this.reconnectionAttempts(opts.reconnectionAttempts||Infinity);this.reconnectionDelay(opts.reconnectionDelay||1e3);this.reconnectionDelayMax(opts.reconnectionDelayMax||5e3);this.randomizationFactor(opts.randomizationFactor||.5);this.backoff=new Backoff({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()});this.timeout(null==opts.timeout?2e4:opts.timeout);this.readyState="closed";this.uri=uri;this.connected=[];this.encoding=false;this.packetBuffer=[];this.encoder=new parser.Encoder;this.decoder=new parser.Decoder;this.autoConnect=opts.autoConnect!==false;if(this.autoConnect)this.open()}Manager.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var nsp in this.nsps){this.nsps[nsp].emit.apply(this.nsps[nsp],arguments)}};Manager.prototype.updateSocketIds=function(){for(var nsp in this.nsps){this.nsps[nsp].id=this.engine.id}};Emitter(Manager.prototype);Manager.prototype.reconnection=function(v){if(!arguments.length)return this._reconnection;this._reconnection=!!v;return this};Manager.prototype.reconnectionAttempts=function(v){if(!arguments.length)return this._reconnectionAttempts;this._reconnectionAttempts=v;return this};Manager.prototype.reconnectionDelay=function(v){if(!arguments.length)return this._reconnectionDelay;this._reconnectionDelay=v;this.backoff&&this.backoff.setMin(v);return this};Manager.prototype.randomizationFactor=function(v){if(!arguments.length)return this._randomizationFactor;this._randomizationFactor=v;this.backoff&&this.backoff.setJitter(v);return this};Manager.prototype.reconnectionDelayMax=function(v){if(!arguments.length)return this._reconnectionDelayMax;this._reconnectionDelayMax=v;this.backoff&&this.backoff.setMax(v);return this};Manager.prototype.timeout=function(v){if(!arguments.length)return this._timeout;this._timeout=v;return this};Manager.prototype.maybeReconnectOnOpen=function(){if(!this.reconnecting&&this._reconnection&&this.backoff.attempts===0){this.reconnect()}};Manager.prototype.open=Manager.prototype.connect=function(fn){debug("readyState %s",this.readyState);if(~this.readyState.indexOf("open"))return this;debug("opening %s",this.uri);this.engine=eio(this.uri,this.opts);var socket=this.engine;var self=this;this.readyState="opening";this.skipReconnect=false;var openSub=on(socket,"open",function(){self.onopen();fn&&fn()});var errorSub=on(socket,"error",function(data){debug("connect_error");self.cleanup();self.readyState="closed";self.emitAll("connect_error",data);if(fn){var err=new Error("Connection error");err.data=data;fn(err)}else{self.maybeReconnectOnOpen()}});if(false!==this._timeout){var timeout=this._timeout;debug("connect attempt will timeout after %d",timeout);var timer=setTimeout(function(){debug("connect attempt timed out after %d",timeout);openSub.destroy();socket.close();socket.emit("error","timeout");self.emitAll("connect_timeout",timeout)},timeout);this.subs.push({destroy:function(){clearTimeout(timer)}})}this.subs.push(openSub);this.subs.push(errorSub);return this};Manager.prototype.onopen=function(){debug("open");this.cleanup();this.readyState="open";this.emit("open");var socket=this.engine;this.subs.push(on(socket,"data",bind(this,"ondata")));this.subs.push(on(this.decoder,"decoded",bind(this,"ondecoded")));this.subs.push(on(socket,"error",bind(this,"onerror")));this.subs.push(on(socket,"close",bind(this,"onclose")))};Manager.prototype.ondata=function(data){this.decoder.add(data)};Manager.prototype.ondecoded=function(packet){this.emit("packet",packet)};Manager.prototype.onerror=function(err){debug("error",err);this.emitAll("error",err)};Manager.prototype.socket=function(nsp){var socket=this.nsps[nsp];if(!socket){socket=new Socket(this,nsp);this.nsps[nsp]=socket;var self=this;socket.on("connect",function(){socket.id=self.engine.id;if(!~indexOf(self.connected,socket)){self.connected.push(socket)}})}return socket};Manager.prototype.destroy=function(socket){var index=indexOf(this.connected,socket);if(~index)this.connected.splice(index,1);if(this.connected.length)return;this.close()};Manager.prototype.packet=function(packet){debug("writing packet %j",packet);var self=this;if(!self.encoding){self.encoding=true;this.encoder.encode(packet,function(encodedPackets){for(var i=0;i<encodedPackets.length;i++){self.engine.write(encodedPackets[i])}self.encoding=false;self.processPacketQueue()})}else{self.packetBuffer.push(packet)}};Manager.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var pack=this.packetBuffer.shift();this.packet(pack)}};Manager.prototype.cleanup=function(){var sub;while(sub=this.subs.shift())sub.destroy();this.packetBuffer=[];this.encoding=false;this.decoder.destroy()};Manager.prototype.close=Manager.prototype.disconnect=function(){this.skipReconnect=true;this.backoff.reset();this.readyState="closed";this.engine&&this.engine.close()};Manager.prototype.onclose=function(reason){debug("close");this.cleanup();this.backoff.reset();this.readyState="closed";this.emit("close",reason);if(this._reconnection&&!this.skipReconnect){this.reconnect()}};Manager.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var self=this;if(this.backoff.attempts>=this._reconnectionAttempts){debug("reconnect failed");this.backoff.reset();this.emitAll("reconnect_failed");this.reconnecting=false}else{var delay=this.backoff.duration();debug("will wait %dms before reconnect attempt",delay);this.reconnecting=true;var timer=setTimeout(function(){if(self.skipReconnect)return;debug("attempting reconnect");self.emitAll("reconnect_attempt",self.backoff.attempts);self.emitAll("reconnecting",self.backoff.attempts);if(self.skipReconnect)return;self.open(function(err){if(err){debug("reconnect attempt error");self.reconnecting=false;self.reconnect();self.emitAll("reconnect_error",err.data)}else{debug("reconnect success");self.onreconnect()}})},delay);this.subs.push({destroy:function(){clearTimeout(timer)}})}};Manager.prototype.onreconnect=function(){var attempt=this.backoff.attempts;this.reconnecting=false;this.backoff.reset();this.updateSocketIds();this.emitAll("reconnect",attempt)}},{"./on":4,"./socket":5,"./url":6,backo2:7,"component-bind":8,"component-emitter":9,debug:10,"engine.io-client":11,indexof:42,"object-component":43,"socket.io-parser":46}],4:[function(_dereq_,module,exports){module.exports=on;function on(obj,ev,fn){obj.on(ev,fn);return{destroy:function(){obj.removeListener(ev,fn)}}}},{}],5:[function(_dereq_,module,exports){var parser=_dereq_("socket.io-parser");var Emitter=_dereq_("component-emitter");var toArray=_dereq_("to-array");var on=_dereq_("./on");var bind=_dereq_("component-bind");var debug=_dereq_("debug")("socket.io-client:socket");var hasBin=_dereq_("has-binary");module.exports=exports=Socket;var events={connect:1,connect_error:1,connect_timeout:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1};var emit=Emitter.prototype.emit;function Socket(io,nsp){this.io=io;this.nsp=nsp;this.json=this;this.ids=0;this.acks={};if(this.io.autoConnect)this.open();this.receiveBuffer=[];this.sendBuffer=[];this.connected=false;this.disconnected=true}Emitter(Socket.prototype);Socket.prototype.subEvents=function(){if(this.subs)return;var io=this.io;this.subs=[on(io,"open",bind(this,"onopen")),on(io,"packet",bind(this,"onpacket")),on(io,"close",bind(this,"onclose"))]};Socket.prototype.open=Socket.prototype.connect=function(){if(this.connected)return this;this.subEvents();this.io.open();if("open"==this.io.readyState)this.onopen();return this};Socket.prototype.send=function(){var args=toArray(arguments);args.unshift("message");this.emit.apply(this,args);return this};Socket.prototype.emit=function(ev){if(events.hasOwnProperty(ev)){emit.apply(this,arguments);return this}var args=toArray(arguments);var parserType=parser.EVENT;if(hasBin(args)){parserType=parser.BINARY_EVENT}var packet={type:parserType,data:args};if("function"==typeof args[args.length-1]){debug("emitting packet with ack id %d",this.ids);this.acks[this.ids]=args.pop();packet.id=this.ids++}if(this.connected){this.packet(packet)}else{this.sendBuffer.push(packet)}return this};Socket.prototype.packet=function(packet){packet.nsp=this.nsp;this.io.packet(packet)};Socket.prototype.onopen=function(){debug("transport is open - connecting");if("/"!=this.nsp){this.packet({type:parser.CONNECT})}};Socket.prototype.onclose=function(reason){debug("close (%s)",reason);this.connected=false;this.disconnected=true;delete this.id;this.emit("disconnect",reason)};Socket.prototype.onpacket=function(packet){if(packet.nsp!=this.nsp)return;switch(packet.type){case parser.CONNECT:this.onconnect();break;case parser.EVENT:this.onevent(packet);break;case parser.BINARY_EVENT:this.onevent(packet);break;case parser.ACK:this.onack(packet);break;case parser.BINARY_ACK:this.onack(packet);break;case parser.DISCONNECT:this.ondisconnect();break;case parser.ERROR:this.emit("error",packet.data);break}};Socket.prototype.onevent=function(packet){var args=packet.data||[];debug("emitting event %j",args);if(null!=packet.id){debug("attaching ack callback to event");args.push(this.ack(packet.id))}if(this.connected){emit.apply(this,args)}else{this.receiveBuffer.push(args)}};Socket.prototype.ack=function(id){var self=this;var sent=false;return function(){if(sent)return;sent=true;var args=toArray(arguments);debug("sending ack %j",args);var type=hasBin(args)?parser.BINARY_ACK:parser.ACK;self.packet({type:type,id:id,data:args})}};Socket.prototype.onack=function(packet){debug("calling ack %s with %j",packet.id,packet.data);var fn=this.acks[packet.id];fn.apply(this,packet.data);delete this.acks[packet.id]};Socket.prototype.onconnect=function(){this.connected=true;this.disconnected=false;this.emit("connect");this.emitBuffered()};Socket.prototype.emitBuffered=function(){var i;for(i=0;i<this.receiveBuffer.length;i++){emit.apply(this,this.receiveBuffer[i])}this.receiveBuffer=[];for(i=0;i<this.sendBuffer.length;i++){this.packet(this.sendBuffer[i])}this.sendBuffer=[]};Socket.prototype.ondisconnect=function(){debug("server disconnect (%s)",this.nsp);this.destroy();this.onclose("io server disconnect")};Socket.prototype.destroy=function(){if(this.subs){for(var i=0;i<this.subs.length;i++){this.subs[i].destroy()}this.subs=null}this.io.destroy(this)};Socket.prototype.close=Socket.prototype.disconnect=function(){if(this.connected){debug("performing disconnect (%s)",this.nsp);this.packet({type:parser.DISCONNECT})}this.destroy();if(this.connected){this.onclose("io client disconnect")}return this}},{"./on":4,"component-bind":8,"component-emitter":9,debug:10,"has-binary":38,"socket.io-parser":46,"to-array":50}],6:[function(_dereq_,module,exports){(function(global){var parseuri=_dereq_("parseuri");var debug=_dereq_("debug")("socket.io-client:url");module.exports=url;function url(uri,loc){var obj=uri;var loc=loc||global.location;if(null==uri)uri=loc.protocol+"//"+loc.host;if("string"==typeof uri){if("/"==uri.charAt(0)){if("/"==uri.charAt(1)){uri=loc.protocol+uri}else{uri=loc.hostname+uri}}if(!/^(https?|wss?):\/\//.test(uri)){debug("protocol-less url %s",uri);if("undefined"!=typeof loc){uri=loc.protocol+"//"+uri}else{uri="https://"+uri}}debug("parse %s",uri);obj=parseuri(uri)}if(!obj.port){if(/^(http|ws)$/.test(obj.protocol)){obj.port="80"}else if(/^(http|ws)s$/.test(obj.protocol)){obj.port="443"}}obj.path=obj.path||"/";obj.id=obj.protocol+"://"+obj.host+":"+obj.port;obj.href=obj.protocol+"://"+obj.host+(loc&&loc.port==obj.port?"":":"+obj.port);return obj}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{debug:10,parseuri:44}],7:[function(_dereq_,module,exports){module.exports=Backoff;function Backoff(opts){opts=opts||{};this.ms=opts.min||100;this.max=opts.max||1e4;this.factor=opts.factor||2;this.jitter=opts.jitter>0&&opts.jitter<=1?opts.jitter:0;this.attempts=0}Backoff.prototype.duration=function(){var ms=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var rand=Math.random();var deviation=Math.floor(rand*this.jitter*ms);ms=(Math.floor(rand*10)&1)==0?ms-deviation:ms+deviation}return Math.min(ms,this.max)|0};Backoff.prototype.reset=function(){this.attempts=0};Backoff.prototype.setMin=function(min){this.ms=min};Backoff.prototype.setMax=function(max){this.max=max};Backoff.prototype.setJitter=function(jitter){this.jitter=jitter}},{}],8:[function(_dereq_,module,exports){var slice=[].slice;module.exports=function(obj,fn){if("string"==typeof fn)fn=obj[fn];if("function"!=typeof fn)throw new Error("bind() requires a function");var args=slice.call(arguments,2);return function(){return fn.apply(obj,args.concat(slice.call(arguments)))}}},{}],9:[function(_dereq_,module,exports){module.exports=Emitter;function Emitter(obj){if(obj)return mixin(obj)}function mixin(obj){for(var key in Emitter.prototype){obj[key]=Emitter.prototype[key]}return obj}Emitter.prototype.on=Emitter.prototype.addEventListener=function(event,fn){this._callbacks=this._callbacks||{};(this._callbacks[event]=this._callbacks[event]||[]).push(fn);return this};Emitter.prototype.once=function(event,fn){var self=this;this._callbacks=this._callbacks||{};function on(){self.off(event,on);fn.apply(this,arguments)}on.fn=fn;this.on(event,on);return this};Emitter.prototype.off=Emitter.prototype.removeListener=Emitter.prototype.removeAllListeners=Emitter.prototype.removeEventListener=function(event,fn){this._callbacks=this._callbacks||{};if(0==arguments.length){this._callbacks={};return this}var callbacks=this._callbacks[event];if(!callbacks)return this;if(1==arguments.length){delete this._callbacks[event];return this}var cb;for(var i=0;i<callbacks.length;i++){cb=callbacks[i];if(cb===fn||cb.fn===fn){callbacks.splice(i,1);break}}return this};Emitter.prototype.emit=function(event){this._callbacks=this._callbacks||{};var args=[].slice.call(arguments,1),callbacks=this._callbacks[event];if(callbacks){callbacks=callbacks.slice(0);for(var i=0,len=callbacks.length;i<len;++i){callbacks[i].apply(this,args)}}return this};Emitter.prototype.listeners=function(event){this._callbacks=this._callbacks||{};return this._callbacks[event]||[]};Emitter.prototype.hasListeners=function(event){return!!this.listeners(event).length}},{}],10:[function(_dereq_,module,exports){module.exports=debug;function debug(name){if(!debug.enabled(name))return function(){};return function(fmt){fmt=coerce(fmt);var curr=new Date;var ms=curr-(debug[name]||curr);debug[name]=curr;fmt=name+" "+fmt+" +"+debug.humanize(ms);window.console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}}debug.names=[];debug.skips=[];debug.enable=function(name){try{localStorage.debug=name}catch(e){}var split=(name||"").split(/[\s,]+/),len=split.length;for(var i=0;i<len;i++){name=split[i].replace("*",".*?");if(name[0]==="-"){debug.skips.push(new RegExp("^"+name.substr(1)+"$"))}else{debug.names.push(new RegExp("^"+name+"$"))}}};debug.disable=function(){debug.enable("")};debug.humanize=function(ms){var sec=1e3,min=60*1e3,hour=60*min;if(ms>=hour)return(ms/hour).toFixed(1)+"h";if(ms>=min)return(ms/min).toFixed(1)+"m";if(ms>=sec)return(ms/sec|0)+"s";return ms+"ms"};debug.enabled=function(name){for(var i=0,len=debug.skips.length;i<len;i++){if(debug.skips[i].test(name)){return false}}for(var i=0,len=debug.names.length;i<len;i++){if(debug.names[i].test(name)){return true}}return false};function coerce(val){if(val instanceof Error)return val.stack||val.message;return val}try{if(window.localStorage)debug.enable(localStorage.debug)}catch(e){}},{}],11:[function(_dereq_,module,exports){module.exports=_dereq_("./lib/")},{"./lib/":12}],12:[function(_dereq_,module,exports){module.exports=_dereq_("./socket");module.exports.parser=_dereq_("engine.io-parser")},{"./socket":13,"engine.io-parser":25}],13:[function(_dereq_,module,exports){(function(global){var transports=_dereq_("./transports");var Emitter=_dereq_("component-emitter");var debug=_dereq_("debug")("engine.io-client:socket");var index=_dereq_("indexof");var parser=_dereq_("engine.io-parser");var parseuri=_dereq_("parseuri");var parsejson=_dereq_("parsejson");var parseqs=_dereq_("parseqs");module.exports=Socket;function noop(){}function Socket(uri,opts){if(!(this instanceof Socket))return new Socket(uri,opts);opts=opts||{};if(uri&&"object"==typeof uri){opts=uri;uri=null}if(uri){uri=parseuri(uri);opts.host=uri.host;opts.secure=uri.protocol=="https"||uri.protocol=="wss";opts.port=uri.port;if(uri.query)opts.query=uri.query}this.secure=null!=opts.secure?opts.secure:global.location&&"https:"==location.protocol;if(opts.host){var pieces=opts.host.split(":");opts.hostname=pieces.shift();if(pieces.length){opts.port=pieces.pop()}else if(!opts.port){opts.port=this.secure?"443":"80"}}this.agent=opts.agent||false;this.hostname=opts.hostname||(global.location?location.hostname:"localhost");this.port=opts.port||(global.location&&location.port?location.port:this.secure?443:80);this.query=opts.query||{};if("string"==typeof this.query)this.query=parseqs.decode(this.query);this.upgrade=false!==opts.upgrade;this.path=(opts.path||"/engine.io").replace(/\/$/,"")+"/";this.forceJSONP=!!opts.forceJSONP;this.jsonp=false!==opts.jsonp;this.forceBase64=!!opts.forceBase64;this.enablesXDR=!!opts.enablesXDR;this.timestampParam=opts.timestampParam||"t";this.timestampRequests=opts.timestampRequests;this.transports=opts.transports||["polling","websocket"];this.readyState="";this.writeBuffer=[];this.callbackBuffer=[];this.policyPort=opts.policyPort||843;this.rememberUpgrade=opts.rememberUpgrade||false;this.binaryType=null;this.onlyBinaryUpgrades=opts.onlyBinaryUpgrades;this.pfx=opts.pfx||null;this.key=opts.key||null;this.passphrase=opts.passphrase||null;this.cert=opts.cert||null;this.ca=opts.ca||null;this.ciphers=opts.ciphers||null;this.rejectUnauthorized=opts.rejectUnauthorized||null;this.open()}Socket.priorWebsocketSuccess=false;Emitter(Socket.prototype);Socket.protocol=parser.protocol;Socket.Socket=Socket;Socket.Transport=_dereq_("./transport");Socket.transports=_dereq_("./transports");Socket.parser=_dereq_("engine.io-parser");Socket.prototype.createTransport=function(name){debug('creating transport "%s"',name);var query=clone(this.query);query.EIO=parser.protocol;query.transport=name;if(this.id)query.sid=this.id;var transport=new transports[name]({agent:this.agent,hostname:this.hostname,port:this.port,secure:this.secure,path:this.path,query:query,forceJSONP:this.forceJSONP,jsonp:this.jsonp,forceBase64:this.forceBase64,enablesXDR:this.enablesXDR,timestampRequests:this.timestampRequests,timestampParam:this.timestampParam,policyPort:this.policyPort,socket:this,pfx:this.pfx,key:this.key,passphrase:this.passphrase,cert:this.cert,ca:this.ca,ciphers:this.ciphers,rejectUnauthorized:this.rejectUnauthorized});return transport};function clone(obj){var o={};for(var i in obj){if(obj.hasOwnProperty(i)){o[i]=obj[i]}}return o}Socket.prototype.open=function(){var transport;if(this.rememberUpgrade&&Socket.priorWebsocketSuccess&&this.transports.indexOf("websocket")!=-1){transport="websocket"}else if(0==this.transports.length){var self=this;setTimeout(function(){self.emit("error","No transports available")},0);return}else{transport=this.transports[0]}this.readyState="opening";var transport;try{transport=this.createTransport(transport)}catch(e){this.transports.shift();this.open();return}transport.open();this.setTransport(transport)};Socket.prototype.setTransport=function(transport){debug("setting transport %s",transport.name);var self=this;if(this.transport){debug("clearing existing transport %s",this.transport.name);this.transport.removeAllListeners()}this.transport=transport;transport.on("drain",function(){self.onDrain()}).on("packet",function(packet){self.onPacket(packet)}).on("error",function(e){self.onError(e)}).on("close",function(){self.onClose("transport close")})};Socket.prototype.probe=function(name){debug('probing transport "%s"',name);var transport=this.createTransport(name,{probe:1}),failed=false,self=this;Socket.priorWebsocketSuccess=false;function onTransportOpen(){if(self.onlyBinaryUpgrades){var upgradeLosesBinary=!this.supportsBinary&&self.transport.supportsBinary;failed=failed||upgradeLosesBinary}if(failed)return;debug('probe transport "%s" opened',name);transport.send([{type:"ping",data:"probe"}]);transport.once("packet",function(msg){if(failed)return;if("pong"==msg.type&&"probe"==msg.data){debug('probe transport "%s" pong',name);self.upgrading=true;self.emit("upgrading",transport);if(!transport)return;Socket.priorWebsocketSuccess="websocket"==transport.name;debug('pausing current transport "%s"',self.transport.name);self.transport.pause(function(){if(failed)return;if("closed"==self.readyState)return;debug("changing transport and sending upgrade packet");cleanup();self.setTransport(transport);transport.send([{type:"upgrade"}]);self.emit("upgrade",transport);transport=null;self.upgrading=false;self.flush()})}else{debug('probe transport "%s" failed',name);var err=new Error("probe error");err.transport=transport.name;self.emit("upgradeError",err)}})}function freezeTransport(){if(failed)return;failed=true;cleanup();transport.close();transport=null}function onerror(err){var error=new Error("probe error: "+err);error.transport=transport.name;freezeTransport();debug('probe transport "%s" failed because of error: %s',name,err);self.emit("upgradeError",error)}function onTransportClose(){onerror("transport closed")}function onclose(){onerror("socket closed")}function onupgrade(to){if(transport&&to.name!=transport.name){debug('"%s" works - aborting "%s"',to.name,transport.name);freezeTransport()}}function cleanup(){transport.removeListener("open",onTransportOpen);transport.removeListener("error",onerror);transport.removeListener("close",onTransportClose);self.removeListener("close",onclose);self.removeListener("upgrading",onupgrade)}transport.once("open",onTransportOpen);transport.once("error",onerror);transport.once("close",onTransportClose);this.once("close",onclose);this.once("upgrading",onupgrade);transport.open()};Socket.prototype.onOpen=function(){debug("socket open");this.readyState="open";Socket.priorWebsocketSuccess="websocket"==this.transport.name;this.emit("open");this.flush();if("open"==this.readyState&&this.upgrade&&this.transport.pause){debug("starting upgrade probes");for(var i=0,l=this.upgrades.length;i<l;i++){this.probe(this.upgrades[i])}}};Socket.prototype.onPacket=function(packet){if("opening"==this.readyState||"open"==this.readyState){debug('socket receive: type "%s", data "%s"',packet.type,packet.data);this.emit("packet",packet);this.emit("heartbeat");switch(packet.type){case"open":this.onHandshake(parsejson(packet.data));break;case"pong":this.setPing();break;case"error":var err=new Error("server error");err.code=packet.data;this.emit("error",err);break;case"message":this.emit("data",packet.data);this.emit("message",packet.data);break}}else{debug('packet received with socket readyState "%s"',this.readyState)}};Socket.prototype.onHandshake=function(data){this.emit("handshake",data);this.id=data.sid;this.transport.query.sid=data.sid;this.upgrades=this.filterUpgrades(data.upgrades);this.pingInterval=data.pingInterval;this.pingTimeout=data.pingTimeout;this.onOpen();if("closed"==this.readyState)return;this.setPing();this.removeListener("heartbeat",this.onHeartbeat);this.on("heartbeat",this.onHeartbeat)};Socket.prototype.onHeartbeat=function(timeout){clearTimeout(this.pingTimeoutTimer);var self=this;self.pingTimeoutTimer=setTimeout(function(){if("closed"==self.readyState)return;self.onClose("ping timeout")},timeout||self.pingInterval+self.pingTimeout)};Socket.prototype.setPing=function(){var self=this;clearTimeout(self.pingIntervalTimer);self.pingIntervalTimer=setTimeout(function(){debug("writing ping packet - expecting pong within %sms",self.pingTimeout);self.ping();self.onHeartbeat(self.pingTimeout)},self.pingInterval)};Socket.prototype.ping=function(){this.sendPacket("ping")};Socket.prototype.onDrain=function(){for(var i=0;i<this.prevBufferLen;i++){if(this.callbackBuffer[i]){this.callbackBuffer[i]()}}this.writeBuffer.splice(0,this.prevBufferLen);this.callbackBuffer.splice(0,this.prevBufferLen);this.prevBufferLen=0;if(this.writeBuffer.length==0){this.emit("drain")}else{this.flush()}};Socket.prototype.flush=function(){if("closed"!=this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){debug("flushing %d packets in socket",this.writeBuffer.length);this.transport.send(this.writeBuffer);this.prevBufferLen=this.writeBuffer.length;this.emit("flush")}};Socket.prototype.write=Socket.prototype.send=function(msg,fn){this.sendPacket("message",msg,fn);return this};Socket.prototype.sendPacket=function(type,data,fn){if("closing"==this.readyState||"closed"==this.readyState){return}var packet={type:type,data:data};this.emit("packetCreate",packet);this.writeBuffer.push(packet);this.callbackBuffer.push(fn);this.flush()};Socket.prototype.close=function(){if("opening"==this.readyState||"open"==this.readyState){this.readyState="closing";var self=this;function close(){self.onClose("forced close");debug("socket closing - telling transport to close");self.transport.close()}function cleanupAndClose(){self.removeListener("upgrade",cleanupAndClose);self.removeListener("upgradeError",cleanupAndClose);close()}function waitForUpgrade(){self.once("upgrade",cleanupAndClose);self.once("upgradeError",cleanupAndClose)}if(this.writeBuffer.length){this.once("drain",function(){if(this.upgrading){waitForUpgrade()}else{close()}})}else if(this.upgrading){waitForUpgrade()}else{close()}}return this};Socket.prototype.onError=function(err){debug("socket error %j",err);Socket.priorWebsocketSuccess=false;this.emit("error",err);this.onClose("transport error",err)};Socket.prototype.onClose=function(reason,desc){if("opening"==this.readyState||"open"==this.readyState||"closing"==this.readyState){debug('socket close with reason: "%s"',reason);var self=this;clearTimeout(this.pingIntervalTimer);clearTimeout(this.pingTimeoutTimer);setTimeout(function(){self.writeBuffer=[];self.callbackBuffer=[];self.prevBufferLen=0},0);this.transport.removeAllListeners("close");this.transport.close();this.transport.removeAllListeners();this.readyState="closed";this.id=null;this.emit("close",reason,desc)}};Socket.prototype.filterUpgrades=function(upgrades){var filteredUpgrades=[];for(var i=0,j=upgrades.length;i<j;i++){if(~index(this.transports,upgrades[i]))filteredUpgrades.push(upgrades[i])}return filteredUpgrades}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./transport":14,"./transports":15,"component-emitter":9,debug:22,"engine.io-parser":25,indexof:42,parsejson:34,parseqs:35,parseuri:36}],14:[function(_dereq_,module,exports){var parser=_dereq_("engine.io-parser");var Emitter=_dereq_("component-emitter");module.exports=Transport;function Transport(opts){this.path=opts.path;this.hostname=opts.hostname;this.port=opts.port;this.secure=opts.secure;this.query=opts.query;this.timestampParam=opts.timestampParam;this.timestampRequests=opts.timestampRequests;this.readyState="";this.agent=opts.agent||false;this.socket=opts.socket;this.enablesXDR=opts.enablesXDR;this.pfx=opts.pfx;this.key=opts.key;this.passphrase=opts.passphrase;this.cert=opts.cert;this.ca=opts.ca;this.ciphers=opts.ciphers;this.rejectUnauthorized=opts.rejectUnauthorized}Emitter(Transport.prototype);Transport.timestamps=0;Transport.prototype.onError=function(msg,desc){var err=new Error(msg);err.type="TransportError";err.description=desc;this.emit("error",err);return this};Transport.prototype.open=function(){if("closed"==this.readyState||""==this.readyState){this.readyState="opening";this.doOpen()}return this};Transport.prototype.close=function(){if("opening"==this.readyState||"open"==this.readyState){this.doClose();this.onClose()}return this};Transport.prototype.send=function(packets){if("open"==this.readyState){this.write(packets)}else{throw new Error("Transport not open")}};Transport.prototype.onOpen=function(){this.readyState="open";this.writable=true;this.emit("open")};Transport.prototype.onData=function(data){var packet=parser.decodePacket(data,this.socket.binaryType);this.onPacket(packet)};Transport.prototype.onPacket=function(packet){this.emit("packet",packet)};Transport.prototype.onClose=function(){this.readyState="closed";this.emit("close")}},{"component-emitter":9,"engine.io-parser":25}],15:[function(_dereq_,module,exports){(function(global){var XMLHttpRequest=_dereq_("xmlhttprequest");var XHR=_dereq_("./polling-xhr");var JSONP=_dereq_("./polling-jsonp");var websocket=_dereq_("./websocket");exports.polling=polling;exports.websocket=websocket;function polling(opts){var xhr;var xd=false;var xs=false;var jsonp=false!==opts.jsonp;if(global.location){var isSSL="https:"==location.protocol;var port=location.port;if(!port){port=isSSL?443:80}xd=opts.hostname!=location.hostname||port!=opts.port;xs=opts.secure!=isSSL}opts.xdomain=xd;opts.xscheme=xs;xhr=new XMLHttpRequest(opts);if("open"in xhr&&!opts.forceJSONP){return new XHR(opts)}else{if(!jsonp)throw new Error("JSONP disabled");return new JSONP(opts)}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,xmlhttprequest:20}],16:[function(_dereq_,module,exports){(function(global){var Polling=_dereq_("./polling");var inherit=_dereq_("component-inherit");module.exports=JSONPPolling;var rNewline=/\n/g;var rEscapedNewline=/\\n/g;var callbacks;var index=0;function empty(){}function JSONPPolling(opts){Polling.call(this,opts);
this.query=this.query||{};if(!callbacks){if(!global.___eio)global.___eio=[];callbacks=global.___eio}this.index=callbacks.length;var self=this;callbacks.push(function(msg){self.onData(msg)});this.query.j=this.index;if(global.document&&global.addEventListener){global.addEventListener("beforeunload",function(){if(self.script)self.script.onerror=empty},false)}}inherit(JSONPPolling,Polling);JSONPPolling.prototype.supportsBinary=false;JSONPPolling.prototype.doClose=function(){if(this.script){this.script.parentNode.removeChild(this.script);this.script=null}if(this.form){this.form.parentNode.removeChild(this.form);this.form=null;this.iframe=null}Polling.prototype.doClose.call(this)};JSONPPolling.prototype.doPoll=function(){var self=this;var script=document.createElement("script");if(this.script){this.script.parentNode.removeChild(this.script);this.script=null}script.async=true;script.src=this.uri();script.onerror=function(e){self.onError("jsonp poll error",e)};var insertAt=document.getElementsByTagName("script")[0];insertAt.parentNode.insertBefore(script,insertAt);this.script=script;var isUAgecko="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);if(isUAgecko){setTimeout(function(){var iframe=document.createElement("iframe");document.body.appendChild(iframe);document.body.removeChild(iframe)},100)}};JSONPPolling.prototype.doWrite=function(data,fn){var self=this;if(!this.form){var form=document.createElement("form");var area=document.createElement("textarea");var id=this.iframeId="eio_iframe_"+this.index;var iframe;form.className="socketio";form.style.position="absolute";form.style.top="-1000px";form.style.left="-1000px";form.target=id;form.method="POST";form.setAttribute("accept-charset","utf-8");area.name="d";form.appendChild(area);document.body.appendChild(form);this.form=form;this.area=area}this.form.action=this.uri();function complete(){initIframe();fn()}function initIframe(){if(self.iframe){try{self.form.removeChild(self.iframe)}catch(e){self.onError("jsonp polling iframe removal error",e)}}try{var html='<iframe src="javascript:0" name="'+self.iframeId+'">';iframe=document.createElement(html)}catch(e){iframe=document.createElement("iframe");iframe.name=self.iframeId;iframe.src="javascript:0"}iframe.id=self.iframeId;self.form.appendChild(iframe);self.iframe=iframe}initIframe();data=data.replace(rEscapedNewline,"\\\n");this.area.value=data.replace(rNewline,"\\n");try{this.form.submit()}catch(e){}if(this.iframe.attachEvent){this.iframe.onreadystatechange=function(){if(self.iframe.readyState=="complete"){complete()}}}else{this.iframe.onload=complete}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling":18,"component-inherit":21}],17:[function(_dereq_,module,exports){(function(global){var XMLHttpRequest=_dereq_("xmlhttprequest");var Polling=_dereq_("./polling");var Emitter=_dereq_("component-emitter");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:polling-xhr");module.exports=XHR;module.exports.Request=Request;function empty(){}function XHR(opts){Polling.call(this,opts);if(global.location){var isSSL="https:"==location.protocol;var port=location.port;if(!port){port=isSSL?443:80}this.xd=opts.hostname!=global.location.hostname||port!=opts.port;this.xs=opts.secure!=isSSL}}inherit(XHR,Polling);XHR.prototype.supportsBinary=true;XHR.prototype.request=function(opts){opts=opts||{};opts.uri=this.uri();opts.xd=this.xd;opts.xs=this.xs;opts.agent=this.agent||false;opts.supportsBinary=this.supportsBinary;opts.enablesXDR=this.enablesXDR;opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;return new Request(opts)};XHR.prototype.doWrite=function(data,fn){var isBinary=typeof data!=="string"&&data!==undefined;var req=this.request({method:"POST",data:data,isBinary:isBinary});var self=this;req.on("success",fn);req.on("error",function(err){self.onError("xhr post error",err)});this.sendXhr=req};XHR.prototype.doPoll=function(){debug("xhr poll");var req=this.request();var self=this;req.on("data",function(data){self.onData(data)});req.on("error",function(err){self.onError("xhr poll error",err)});this.pollXhr=req};function Request(opts){this.method=opts.method||"GET";this.uri=opts.uri;this.xd=!!opts.xd;this.xs=!!opts.xs;this.async=false!==opts.async;this.data=undefined!=opts.data?opts.data:null;this.agent=opts.agent;this.isBinary=opts.isBinary;this.supportsBinary=opts.supportsBinary;this.enablesXDR=opts.enablesXDR;this.pfx=opts.pfx;this.key=opts.key;this.passphrase=opts.passphrase;this.cert=opts.cert;this.ca=opts.ca;this.ciphers=opts.ciphers;this.rejectUnauthorized=opts.rejectUnauthorized;this.create()}Emitter(Request.prototype);Request.prototype.create=function(){var opts={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;var xhr=this.xhr=new XMLHttpRequest(opts);var self=this;try{debug("xhr open %s: %s",this.method,this.uri);xhr.open(this.method,this.uri,this.async);if(this.supportsBinary){xhr.responseType="arraybuffer"}if("POST"==this.method){try{if(this.isBinary){xhr.setRequestHeader("Content-type","application/octet-stream")}else{xhr.setRequestHeader("Content-type","text/plain;charset=UTF-8")}}catch(e){}}if("withCredentials"in xhr){xhr.withCredentials=true}if(this.hasXDR()){xhr.onload=function(){self.onLoad()};xhr.onerror=function(){self.onError(xhr.responseText)}}else{xhr.onreadystatechange=function(){if(4!=xhr.readyState)return;if(200==xhr.status||1223==xhr.status){self.onLoad()}else{setTimeout(function(){self.onError(xhr.status)},0)}}}debug("xhr data %s",this.data);xhr.send(this.data)}catch(e){setTimeout(function(){self.onError(e)},0);return}if(global.document){this.index=Request.requestsCount++;Request.requests[this.index]=this}};Request.prototype.onSuccess=function(){this.emit("success");this.cleanup()};Request.prototype.onData=function(data){this.emit("data",data);this.onSuccess()};Request.prototype.onError=function(err){this.emit("error",err);this.cleanup(true)};Request.prototype.cleanup=function(fromError){if("undefined"==typeof this.xhr||null===this.xhr){return}if(this.hasXDR()){this.xhr.onload=this.xhr.onerror=empty}else{this.xhr.onreadystatechange=empty}if(fromError){try{this.xhr.abort()}catch(e){}}if(global.document){delete Request.requests[this.index]}this.xhr=null};Request.prototype.onLoad=function(){var data;try{var contentType;try{contentType=this.xhr.getResponseHeader("Content-Type").split(";")[0]}catch(e){}if(contentType==="application/octet-stream"){data=this.xhr.response}else{if(!this.supportsBinary){data=this.xhr.responseText}else{data="ok"}}}catch(e){this.onError(e)}if(null!=data){this.onData(data)}};Request.prototype.hasXDR=function(){return"undefined"!==typeof global.XDomainRequest&&!this.xs&&this.enablesXDR};Request.prototype.abort=function(){this.cleanup()};if(global.document){Request.requestsCount=0;Request.requests={};if(global.attachEvent){global.attachEvent("onunload",unloadHandler)}else if(global.addEventListener){global.addEventListener("beforeunload",unloadHandler,false)}}function unloadHandler(){for(var i in Request.requests){if(Request.requests.hasOwnProperty(i)){Request.requests[i].abort()}}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling":18,"component-emitter":9,"component-inherit":21,debug:22,xmlhttprequest:20}],18:[function(_dereq_,module,exports){var Transport=_dereq_("../transport");var parseqs=_dereq_("parseqs");var parser=_dereq_("engine.io-parser");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:polling");module.exports=Polling;var hasXHR2=function(){var XMLHttpRequest=_dereq_("xmlhttprequest");var xhr=new XMLHttpRequest({xdomain:false});return null!=xhr.responseType}();function Polling(opts){var forceBase64=opts&&opts.forceBase64;if(!hasXHR2||forceBase64){this.supportsBinary=false}Transport.call(this,opts)}inherit(Polling,Transport);Polling.prototype.name="polling";Polling.prototype.doOpen=function(){this.poll()};Polling.prototype.pause=function(onPause){var pending=0;var self=this;this.readyState="pausing";function pause(){debug("paused");self.readyState="paused";onPause()}if(this.polling||!this.writable){var total=0;if(this.polling){debug("we are currently polling - waiting to pause");total++;this.once("pollComplete",function(){debug("pre-pause polling complete");--total||pause()})}if(!this.writable){debug("we are currently writing - waiting to pause");total++;this.once("drain",function(){debug("pre-pause writing complete");--total||pause()})}}else{pause()}};Polling.prototype.poll=function(){debug("polling");this.polling=true;this.doPoll();this.emit("poll")};Polling.prototype.onData=function(data){var self=this;debug("polling got data %s",data);var callback=function(packet,index,total){if("opening"==self.readyState){self.onOpen()}if("close"==packet.type){self.onClose();return false}self.onPacket(packet)};parser.decodePayload(data,this.socket.binaryType,callback);if("closed"!=this.readyState){this.polling=false;this.emit("pollComplete");if("open"==this.readyState){this.poll()}else{debug('ignoring poll - transport state "%s"',this.readyState)}}};Polling.prototype.doClose=function(){var self=this;function close(){debug("writing close packet");self.write([{type:"close"}])}if("open"==this.readyState){debug("transport open - closing");close()}else{debug("transport not open - deferring close");this.once("open",close)}};Polling.prototype.write=function(packets){var self=this;this.writable=false;var callbackfn=function(){self.writable=true;self.emit("drain")};var self=this;parser.encodePayload(packets,this.supportsBinary,function(data){self.doWrite(data,callbackfn)})};Polling.prototype.uri=function(){var query=this.query||{};var schema=this.secure?"https":"http";var port="";if(false!==this.timestampRequests){query[this.timestampParam]=+new Date+"-"+Transport.timestamps++}if(!this.supportsBinary&&!query.sid){query.b64=1}query=parseqs.encode(query);if(this.port&&("https"==schema&&this.port!=443||"http"==schema&&this.port!=80)){port=":"+this.port}if(query.length){query="?"+query}return schema+"://"+this.hostname+port+this.path+query}},{"../transport":14,"component-inherit":21,debug:22,"engine.io-parser":25,parseqs:35,xmlhttprequest:20}],19:[function(_dereq_,module,exports){var Transport=_dereq_("../transport");var parser=_dereq_("engine.io-parser");var parseqs=_dereq_("parseqs");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:websocket");var WebSocket=_dereq_("ws");module.exports=WS;function WS(opts){var forceBase64=opts&&opts.forceBase64;if(forceBase64){this.supportsBinary=false}Transport.call(this,opts)}inherit(WS,Transport);WS.prototype.name="websocket";WS.prototype.supportsBinary=true;WS.prototype.doOpen=function(){if(!this.check()){return}var self=this;var uri=this.uri();var protocols=void 0;var opts={agent:this.agent};opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;this.ws=new WebSocket(uri,protocols,opts);if(this.ws.binaryType===undefined){this.supportsBinary=false}this.ws.binaryType="arraybuffer";this.addEventListeners()};WS.prototype.addEventListeners=function(){var self=this;this.ws.onopen=function(){self.onOpen()};this.ws.onclose=function(){self.onClose()};this.ws.onmessage=function(ev){self.onData(ev.data)};this.ws.onerror=function(e){self.onError("websocket error",e)}};if("undefined"!=typeof navigator&&/iPad|iPhone|iPod/i.test(navigator.userAgent)){WS.prototype.onData=function(data){var self=this;setTimeout(function(){Transport.prototype.onData.call(self,data)},0)}}WS.prototype.write=function(packets){var self=this;this.writable=false;for(var i=0,l=packets.length;i<l;i++){parser.encodePacket(packets[i],this.supportsBinary,function(data){try{self.ws.send(data)}catch(e){debug("websocket closed before onclose event")}})}function ondrain(){self.writable=true;self.emit("drain")}setTimeout(ondrain,0)};WS.prototype.onClose=function(){Transport.prototype.onClose.call(this)};WS.prototype.doClose=function(){if(typeof this.ws!=="undefined"){this.ws.close()}};WS.prototype.uri=function(){var query=this.query||{};var schema=this.secure?"wss":"ws";var port="";if(this.port&&("wss"==schema&&this.port!=443||"ws"==schema&&this.port!=80)){port=":"+this.port}if(this.timestampRequests){query[this.timestampParam]=+new Date}if(!this.supportsBinary){query.b64=1}query=parseqs.encode(query);if(query.length){query="?"+query}return schema+"://"+this.hostname+port+this.path+query};WS.prototype.check=function(){return!!WebSocket&&!("__initialize"in WebSocket&&this.name===WS.prototype.name)}},{"../transport":14,"component-inherit":21,debug:22,"engine.io-parser":25,parseqs:35,ws:37}],20:[function(_dereq_,module,exports){var hasCORS=_dereq_("has-cors");module.exports=function(opts){var xdomain=opts.xdomain;var xscheme=opts.xscheme;var enablesXDR=opts.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!xdomain||hasCORS)){return new XMLHttpRequest}}catch(e){}try{if("undefined"!=typeof XDomainRequest&&!xscheme&&enablesXDR){return new XDomainRequest}}catch(e){}if(!xdomain){try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}}}},{"has-cors":40}],21:[function(_dereq_,module,exports){module.exports=function(a,b){var fn=function(){};fn.prototype=b.prototype;a.prototype=new fn;a.prototype.constructor=a}},{}],22:[function(_dereq_,module,exports){exports=module.exports=_dereq_("./debug");exports.log=log;exports.formatArgs=formatArgs;exports.save=save;exports.load=load;exports.useColors=useColors;exports.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"];function useColors(){return"WebkitAppearance"in document.documentElement.style||window.console&&(console.firebug||console.exception&&console.table)||navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31}exports.formatters.j=function(v){return JSON.stringify(v)};function formatArgs(){var args=arguments;var useColors=this.useColors;args[0]=(useColors?"%c":"")+this.namespace+(useColors?" %c":" ")+args[0]+(useColors?"%c ":" ")+"+"+exports.humanize(this.diff);if(!useColors)return args;var c="color: "+this.color;args=[args[0],c,"color: inherit"].concat(Array.prototype.slice.call(args,1));var index=0;var lastC=0;args[0].replace(/%[a-z%]/g,function(match){if("%"===match)return;index++;if("%c"===match){lastC=index}});args.splice(lastC,0,c);return args}function log(){return"object"==typeof console&&"function"==typeof console.log&&Function.prototype.apply.call(console.log,console,arguments)}function save(namespaces){try{if(null==namespaces){localStorage.removeItem("debug")}else{localStorage.debug=namespaces}}catch(e){}}function load(){var r;try{r=localStorage.debug}catch(e){}return r}exports.enable(load())},{"./debug":23}],23:[function(_dereq_,module,exports){exports=module.exports=debug;exports.coerce=coerce;exports.disable=disable;exports.enable=enable;exports.enabled=enabled;exports.humanize=_dereq_("ms");exports.names=[];exports.skips=[];exports.formatters={};var prevColor=0;var prevTime;function selectColor(){return exports.colors[prevColor++%exports.colors.length]}function debug(namespace){function disabled(){}disabled.enabled=false;function enabled(){var self=enabled;var curr=+new Date;var ms=curr-(prevTime||curr);self.diff=ms;self.prev=prevTime;self.curr=curr;prevTime=curr;if(null==self.useColors)self.useColors=exports.useColors();if(null==self.color&&self.useColors)self.color=selectColor();var args=Array.prototype.slice.call(arguments);args[0]=exports.coerce(args[0]);if("string"!==typeof args[0]){args=["%o"].concat(args)}var index=0;args[0]=args[0].replace(/%([a-z%])/g,function(match,format){if(match==="%")return match;index++;var formatter=exports.formatters[format];if("function"===typeof formatter){var val=args[index];match=formatter.call(self,val);args.splice(index,1);index--}return match});if("function"===typeof exports.formatArgs){args=exports.formatArgs.apply(self,args)}var logFn=enabled.log||exports.log||console.log.bind(console);logFn.apply(self,args)}enabled.enabled=true;var fn=exports.enabled(namespace)?enabled:disabled;fn.namespace=namespace;return fn}function enable(namespaces){exports.save(namespaces);var split=(namespaces||"").split(/[\s,]+/);var len=split.length;for(var i=0;i<len;i++){if(!split[i])continue;namespaces=split[i].replace(/\*/g,".*?");if(namespaces[0]==="-"){exports.skips.push(new RegExp("^"+namespaces.substr(1)+"$"))}else{exports.names.push(new RegExp("^"+namespaces+"$"))}}}function disable(){exports.enable("")}function enabled(name){var i,len;for(i=0,len=exports.skips.length;i<len;i++){if(exports.skips[i].test(name)){return false}}for(i=0,len=exports.names.length;i<len;i++){if(exports.names[i].test(name)){return true}}return false}function coerce(val){if(val instanceof Error)return val.stack||val.message;return val}},{ms:24}],24:[function(_dereq_,module,exports){var s=1e3;var m=s*60;var h=m*60;var d=h*24;var y=d*365.25;module.exports=function(val,options){options=options||{};if("string"==typeof val)return parse(val);return options.long?long(val):short(val)};function parse(str){var match=/^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);if(!match)return;var n=parseFloat(match[1]);var type=(match[2]||"ms").toLowerCase();switch(type){case"years":case"year":case"y":return n*y;case"days":case"day":case"d":return n*d;case"hours":case"hour":case"h":return n*h;case"minutes":case"minute":case"m":return n*m;case"seconds":case"second":case"s":return n*s;case"ms":return n}}function short(ms){if(ms>=d)return Math.round(ms/d)+"d";if(ms>=h)return Math.round(ms/h)+"h";if(ms>=m)return Math.round(ms/m)+"m";if(ms>=s)return Math.round(ms/s)+"s";return ms+"ms"}function long(ms){return plural(ms,d,"day")||plural(ms,h,"hour")||plural(ms,m,"minute")||plural(ms,s,"second")||ms+" ms"}function plural(ms,n,name){if(ms<n)return;if(ms<n*1.5)return Math.floor(ms/n)+" "+name;return Math.ceil(ms/n)+" "+name+"s"}},{}],25:[function(_dereq_,module,exports){(function(global){var keys=_dereq_("./keys");var hasBinary=_dereq_("has-binary");var sliceBuffer=_dereq_("arraybuffer.slice");var base64encoder=_dereq_("base64-arraybuffer");var after=_dereq_("after");var utf8=_dereq_("utf8");var isAndroid=navigator.userAgent.match(/Android/i);var isPhantomJS=/PhantomJS/i.test(navigator.userAgent);var dontSendBlobs=isAndroid||isPhantomJS;exports.protocol=3;var packets=exports.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6};var packetslist=keys(packets);var err={type:"error",data:"parser error"};var Blob=_dereq_("blob");exports.encodePacket=function(packet,supportsBinary,utf8encode,callback){if("function"==typeof supportsBinary){callback=supportsBinary;supportsBinary=false}if("function"==typeof utf8encode){callback=utf8encode;utf8encode=null}var data=packet.data===undefined?undefined:packet.data.buffer||packet.data;if(global.ArrayBuffer&&data instanceof ArrayBuffer){return encodeArrayBuffer(packet,supportsBinary,callback)}else if(Blob&&data instanceof global.Blob){return encodeBlob(packet,supportsBinary,callback)}if(data&&data.base64){return encodeBase64Object(packet,callback)}var encoded=packets[packet.type];if(undefined!==packet.data){encoded+=utf8encode?utf8.encode(String(packet.data)):String(packet.data)}return callback(""+encoded)};function encodeBase64Object(packet,callback){var message="b"+exports.packets[packet.type]+packet.data.data;return callback(message)}function encodeArrayBuffer(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}var data=packet.data;var contentArray=new Uint8Array(data);var resultBuffer=new Uint8Array(1+data.byteLength);resultBuffer[0]=packets[packet.type];for(var i=0;i<contentArray.length;i++){resultBuffer[i+1]=contentArray[i]}return callback(resultBuffer.buffer)}function encodeBlobAsArrayBuffer(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}var fr=new FileReader;fr.onload=function(){packet.data=fr.result;exports.encodePacket(packet,supportsBinary,true,callback)};return fr.readAsArrayBuffer(packet.data)}function encodeBlob(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}if(dontSendBlobs){return encodeBlobAsArrayBuffer(packet,supportsBinary,callback)}var length=new Uint8Array(1);length[0]=packets[packet.type];var blob=new Blob([length.buffer,packet.data]);return callback(blob)}exports.encodeBase64Packet=function(packet,callback){var message="b"+exports.packets[packet.type];if(Blob&&packet.data instanceof Blob){var fr=new FileReader;fr.onload=function(){var b64=fr.result.split(",")[1];callback(message+b64)};return fr.readAsDataURL(packet.data)}var b64data;try{b64data=String.fromCharCode.apply(null,new Uint8Array(packet.data))}catch(e){var typed=new Uint8Array(packet.data);var basic=new Array(typed.length);for(var i=0;i<typed.length;i++){basic[i]=typed[i]}b64data=String.fromCharCode.apply(null,basic)}message+=global.btoa(b64data);return callback(message)};exports.decodePacket=function(data,binaryType,utf8decode){if(typeof data=="string"||data===undefined){if(data.charAt(0)=="b"){return exports.decodeBase64Packet(data.substr(1),binaryType)}if(utf8decode){try{data=utf8.decode(data)}catch(e){return err}}var type=data.charAt(0);if(Number(type)!=type||!packetslist[type]){return err}if(data.length>1){return{type:packetslist[type],data:data.substring(1)}}else{return{type:packetslist[type]}}}var asArray=new Uint8Array(data);var type=asArray[0];var rest=sliceBuffer(data,1);if(Blob&&binaryType==="blob"){rest=new Blob([rest])}return{type:packetslist[type],data:rest}};exports.decodeBase64Packet=function(msg,binaryType){var type=packetslist[msg.charAt(0)];if(!global.ArrayBuffer){return{type:type,data:{base64:true,data:msg.substr(1)}}}var data=base64encoder.decode(msg.substr(1));if(binaryType==="blob"&&Blob){data=new Blob([data])}return{type:type,data:data}};exports.encodePayload=function(packets,supportsBinary,callback){if(typeof supportsBinary=="function"){callback=supportsBinary;supportsBinary=null}var isBinary=hasBinary(packets);if(supportsBinary&&isBinary){if(Blob&&!dontSendBlobs){return exports.encodePayloadAsBlob(packets,callback)}return exports.encodePayloadAsArrayBuffer(packets,callback)}if(!packets.length){return callback("0:")}function setLengthHeader(message){return message.length+":"+message}function encodeOne(packet,doneCallback){exports.encodePacket(packet,!isBinary?false:supportsBinary,true,function(message){doneCallback(null,setLengthHeader(message))})}map(packets,encodeOne,function(err,results){return callback(results.join(""))})};function map(ary,each,done){var result=new Array(ary.length);var next=after(ary.length,done);var eachWithIndex=function(i,el,cb){each(el,function(error,msg){result[i]=msg;cb(error,result)})};for(var i=0;i<ary.length;i++){eachWithIndex(i,ary[i],next)}}exports.decodePayload=function(data,binaryType,callback){if(typeof data!="string"){return exports.decodePayloadAsBinary(data,binaryType,callback)}if(typeof binaryType==="function"){callback=binaryType;binaryType=null}var packet;if(data==""){return callback(err,0,1)}var length="",n,msg;for(var i=0,l=data.length;i<l;i++){var chr=data.charAt(i);if(":"!=chr){length+=chr}else{if(""==length||length!=(n=Number(length))){return callback(err,0,1)}msg=data.substr(i+1,n);if(length!=msg.length){return callback(err,0,1)}if(msg.length){packet=exports.decodePacket(msg,binaryType,true);if(err.type==packet.type&&err.data==packet.data){return callback(err,0,1)}var ret=callback(packet,i+n,l);if(false===ret)return}i+=n;length=""}}if(length!=""){return callback(err,0,1)}};exports.encodePayloadAsArrayBuffer=function(packets,callback){if(!packets.length){return callback(new ArrayBuffer(0))}function encodeOne(packet,doneCallback){exports.encodePacket(packet,true,true,function(data){return doneCallback(null,data)})}map(packets,encodeOne,function(err,encodedPackets){var totalLength=encodedPackets.reduce(function(acc,p){var len;if(typeof p==="string"){len=p.length}else{len=p.byteLength}return acc+len.toString().length+len+2},0);var resultArray=new Uint8Array(totalLength);var bufferIndex=0;encodedPackets.forEach(function(p){var isString=typeof p==="string";var ab=p;if(isString){var view=new Uint8Array(p.length);for(var i=0;i<p.length;i++){view[i]=p.charCodeAt(i)}ab=view.buffer}if(isString){resultArray[bufferIndex++]=0}else{resultArray[bufferIndex++]=1}var lenStr=ab.byteLength.toString();for(var i=0;i<lenStr.length;i++){resultArray[bufferIndex++]=parseInt(lenStr[i])}resultArray[bufferIndex++]=255;var view=new Uint8Array(ab);for(var i=0;i<view.length;i++){resultArray[bufferIndex++]=view[i]}});return callback(resultArray.buffer)})};exports.encodePayloadAsBlob=function(packets,callback){function encodeOne(packet,doneCallback){exports.encodePacket(packet,true,true,function(encoded){var binaryIdentifier=new Uint8Array(1);binaryIdentifier[0]=1;if(typeof encoded==="string"){var view=new Uint8Array(encoded.length);for(var i=0;i<encoded.length;i++){view[i]=encoded.charCodeAt(i)}encoded=view.buffer;binaryIdentifier[0]=0}var len=encoded instanceof ArrayBuffer?encoded.byteLength:encoded.size;var lenStr=len.toString();var lengthAry=new Uint8Array(lenStr.length+1);for(var i=0;i<lenStr.length;i++){lengthAry[i]=parseInt(lenStr[i])}lengthAry[lenStr.length]=255;if(Blob){var blob=new Blob([binaryIdentifier.buffer,lengthAry.buffer,encoded]);doneCallback(null,blob)}})}map(packets,encodeOne,function(err,results){return callback(new Blob(results))})};exports.decodePayloadAsBinary=function(data,binaryType,callback){if(typeof binaryType==="function"){callback=binaryType;binaryType=null}var bufferTail=data;var buffers=[];var numberTooLong=false;while(bufferTail.byteLength>0){var tailArray=new Uint8Array(bufferTail);var isString=tailArray[0]===0;var msgLength="";for(var i=1;;i++){if(tailArray[i]==255)break;if(msgLength.length>310){numberTooLong=true;break}msgLength+=tailArray[i]}if(numberTooLong)return callback(err,0,1);bufferTail=sliceBuffer(bufferTail,2+msgLength.length);msgLength=parseInt(msgLength);var msg=sliceBuffer(bufferTail,0,msgLength);if(isString){try{msg=String.fromCharCode.apply(null,new Uint8Array(msg))}catch(e){var typed=new Uint8Array(msg);msg="";for(var i=0;i<typed.length;i++){msg+=String.fromCharCode(typed[i])}}}buffers.push(msg);bufferTail=sliceBuffer(bufferTail,msgLength)}var total=buffers.length;buffers.forEach(function(buffer,i){callback(exports.decodePacket(buffer,binaryType,true),i,total)})}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./keys":26,after:27,"arraybuffer.slice":28,"base64-arraybuffer":29,blob:30,"has-binary":31,utf8:33}],26:[function(_dereq_,module,exports){module.exports=Object.keys||function keys(obj){var arr=[];var has=Object.prototype.hasOwnProperty;for(var i in obj){if(has.call(obj,i)){arr.push(i)}}return arr}},{}],27:[function(_dereq_,module,exports){module.exports=after;function after(count,callback,err_cb){var bail=false;err_cb=err_cb||noop;proxy.count=count;return count===0?callback():proxy;function proxy(err,result){if(proxy.count<=0){throw new Error("after called too many times")}--proxy.count;if(err){bail=true;callback(err);callback=err_cb}else if(proxy.count===0&&!bail){callback(null,result)}}}function noop(){}},{}],28:[function(_dereq_,module,exports){module.exports=function(arraybuffer,start,end){var bytes=arraybuffer.byteLength;start=start||0;end=end||bytes;if(arraybuffer.slice){return arraybuffer.slice(start,end)}if(start<0){start+=bytes}if(end<0){end+=bytes}if(end>bytes){end=bytes}if(start>=bytes||start>=end||bytes===0){return new ArrayBuffer(0)}var abv=new Uint8Array(arraybuffer);var result=new Uint8Array(end-start);for(var i=start,ii=0;i<end;i++,ii++){result[ii]=abv[i]}return result.buffer}},{}],29:[function(_dereq_,module,exports){(function(chars){"use strict";exports.encode=function(arraybuffer){var bytes=new Uint8Array(arraybuffer),i,len=bytes.length,base64="";for(i=0;i<len;i+=3){base64+=chars[bytes[i]>>2];base64+=chars[(bytes[i]&3)<<4|bytes[i+1]>>4];base64+=chars[(bytes[i+1]&15)<<2|bytes[i+2]>>6];base64+=chars[bytes[i+2]&63]}if(len%3===2){base64=base64.substring(0,base64.length-1)+"="}else if(len%3===1){base64=base64.substring(0,base64.length-2)+"=="}return base64};exports.decode=function(base64){var bufferLength=base64.length*.75,len=base64.length,i,p=0,encoded1,encoded2,encoded3,encoded4;if(base64[base64.length-1]==="="){bufferLength--;if(base64[base64.length-2]==="="){bufferLength--}}var arraybuffer=new ArrayBuffer(bufferLength),bytes=new Uint8Array(arraybuffer);for(i=0;i<len;i+=4){encoded1=chars.indexOf(base64[i]);encoded2=chars.indexOf(base64[i+1]);encoded3=chars.indexOf(base64[i+2]);encoded4=chars.indexOf(base64[i+3]);bytes[p++]=encoded1<<2|encoded2>>4;bytes[p++]=(encoded2&15)<<4|encoded3>>2;bytes[p++]=(encoded3&3)<<6|encoded4&63}return arraybuffer}})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")},{}],30:[function(_dereq_,module,exports){(function(global){var BlobBuilder=global.BlobBuilder||global.WebKitBlobBuilder||global.MSBlobBuilder||global.MozBlobBuilder;var blobSupported=function(){try{var b=new Blob(["hi"]);return b.size==2}catch(e){return false}}();var blobBuilderSupported=BlobBuilder&&BlobBuilder.prototype.append&&BlobBuilder.prototype.getBlob;function BlobBuilderConstructor(ary,options){options=options||{};var bb=new BlobBuilder;for(var i=0;i<ary.length;i++){bb.append(ary[i])}return options.type?bb.getBlob(options.type):bb.getBlob()}module.exports=function(){if(blobSupported){return global.Blob}else if(blobBuilderSupported){return BlobBuilderConstructor}else{return undefined}}()}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],31:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");module.exports=hasBinary;function hasBinary(data){function _hasBinary(obj){if(!obj)return false;if(global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer||global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){return true}if(isArray(obj)){for(var i=0;i<obj.length;i++){if(_hasBinary(obj[i])){return true}}}else if(obj&&"object"==typeof obj){if(obj.toJSON){obj=obj.toJSON()}for(var key in obj){if(obj.hasOwnProperty(key)&&_hasBinary(obj[key])){return true}}}return false}return _hasBinary(data)}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{isarray:32}],32:[function(_dereq_,module,exports){module.exports=Array.isArray||function(arr){return Object.prototype.toString.call(arr)=="[object Array]"}},{}],33:[function(_dereq_,module,exports){(function(global){(function(root){var freeExports=typeof exports=="object"&&exports;var freeModule=typeof module=="object"&&module&&module.exports==freeExports&&module;var freeGlobal=typeof global=="object"&&global;if(freeGlobal.global===freeGlobal||freeGlobal.window===freeGlobal){root=freeGlobal}var stringFromCharCode=String.fromCharCode;function ucs2decode(string){var output=[];var counter=0;var length=string.length;var value;var extra;while(counter<length){value=string.charCodeAt(counter++);if(value>=55296&&value<=56319&&counter<length){extra=string.charCodeAt(counter++);if((extra&64512)==56320){output.push(((value&1023)<<10)+(extra&1023)+65536)}else{output.push(value);counter--}}else{output.push(value)}}return output}function ucs2encode(array){var length=array.length;var index=-1;var value;var output="";while(++index<length){value=array[index];if(value>65535){value-=65536;
output+=stringFromCharCode(value>>>10&1023|55296);value=56320|value&1023}output+=stringFromCharCode(value)}return output}function createByte(codePoint,shift){return stringFromCharCode(codePoint>>shift&63|128)}function encodeCodePoint(codePoint){if((codePoint&4294967168)==0){return stringFromCharCode(codePoint)}var symbol="";if((codePoint&4294965248)==0){symbol=stringFromCharCode(codePoint>>6&31|192)}else if((codePoint&4294901760)==0){symbol=stringFromCharCode(codePoint>>12&15|224);symbol+=createByte(codePoint,6)}else if((codePoint&4292870144)==0){symbol=stringFromCharCode(codePoint>>18&7|240);symbol+=createByte(codePoint,12);symbol+=createByte(codePoint,6)}symbol+=stringFromCharCode(codePoint&63|128);return symbol}function utf8encode(string){var codePoints=ucs2decode(string);var length=codePoints.length;var index=-1;var codePoint;var byteString="";while(++index<length){codePoint=codePoints[index];byteString+=encodeCodePoint(codePoint)}return byteString}function readContinuationByte(){if(byteIndex>=byteCount){throw Error("Invalid byte index")}var continuationByte=byteArray[byteIndex]&255;byteIndex++;if((continuationByte&192)==128){return continuationByte&63}throw Error("Invalid continuation byte")}function decodeSymbol(){var byte1;var byte2;var byte3;var byte4;var codePoint;if(byteIndex>byteCount){throw Error("Invalid byte index")}if(byteIndex==byteCount){return false}byte1=byteArray[byteIndex]&255;byteIndex++;if((byte1&128)==0){return byte1}if((byte1&224)==192){var byte2=readContinuationByte();codePoint=(byte1&31)<<6|byte2;if(codePoint>=128){return codePoint}else{throw Error("Invalid continuation byte")}}if((byte1&240)==224){byte2=readContinuationByte();byte3=readContinuationByte();codePoint=(byte1&15)<<12|byte2<<6|byte3;if(codePoint>=2048){return codePoint}else{throw Error("Invalid continuation byte")}}if((byte1&248)==240){byte2=readContinuationByte();byte3=readContinuationByte();byte4=readContinuationByte();codePoint=(byte1&15)<<18|byte2<<12|byte3<<6|byte4;if(codePoint>=65536&&codePoint<=1114111){return codePoint}}throw Error("Invalid UTF-8 detected")}var byteArray;var byteCount;var byteIndex;function utf8decode(byteString){byteArray=ucs2decode(byteString);byteCount=byteArray.length;byteIndex=0;var codePoints=[];var tmp;while((tmp=decodeSymbol())!==false){codePoints.push(tmp)}return ucs2encode(codePoints)}var utf8={version:"2.0.0",encode:utf8encode,decode:utf8decode};if(typeof define=="function"&&typeof define.amd=="object"&&define.amd){define(function(){return utf8})}else if(freeExports&&!freeExports.nodeType){if(freeModule){freeModule.exports=utf8}else{var object={};var hasOwnProperty=object.hasOwnProperty;for(var key in utf8){hasOwnProperty.call(utf8,key)&&(freeExports[key]=utf8[key])}}}else{root.utf8=utf8}})(this)}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],34:[function(_dereq_,module,exports){(function(global){var rvalidchars=/^[\],:{}\s]*$/;var rvalidescape=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;var rvalidtokens=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;var rvalidbraces=/(?:^|:|,)(?:\s*\[)+/g;var rtrimLeft=/^\s+/;var rtrimRight=/\s+$/;module.exports=function parsejson(data){if("string"!=typeof data||!data){return null}data=data.replace(rtrimLeft,"").replace(rtrimRight,"");if(global.JSON&&JSON.parse){return JSON.parse(data)}if(rvalidchars.test(data.replace(rvalidescape,"@").replace(rvalidtokens,"]").replace(rvalidbraces,""))){return new Function("return "+data)()}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],35:[function(_dereq_,module,exports){exports.encode=function(obj){var str="";for(var i in obj){if(obj.hasOwnProperty(i)){if(str.length)str+="&";str+=encodeURIComponent(i)+"="+encodeURIComponent(obj[i])}}return str};exports.decode=function(qs){var qry={};var pairs=qs.split("&");for(var i=0,l=pairs.length;i<l;i++){var pair=pairs[i].split("=");qry[decodeURIComponent(pair[0])]=decodeURIComponent(pair[1])}return qry}},{}],36:[function(_dereq_,module,exports){var re=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;var parts=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];module.exports=function parseuri(str){var src=str,b=str.indexOf("["),e=str.indexOf("]");if(b!=-1&&e!=-1){str=str.substring(0,b)+str.substring(b,e).replace(/:/g,";")+str.substring(e,str.length)}var m=re.exec(str||""),uri={},i=14;while(i--){uri[parts[i]]=m[i]||""}if(b!=-1&&e!=-1){uri.source=src;uri.host=uri.host.substring(1,uri.host.length-1).replace(/;/g,":");uri.authority=uri.authority.replace("[","").replace("]","").replace(/;/g,":");uri.ipv6uri=true}return uri}},{}],37:[function(_dereq_,module,exports){var global=function(){return this}();var WebSocket=global.WebSocket||global.MozWebSocket;module.exports=WebSocket?ws:null;function ws(uri,protocols,opts){var instance;if(protocols){instance=new WebSocket(uri,protocols)}else{instance=new WebSocket(uri)}return instance}if(WebSocket)ws.prototype=WebSocket.prototype},{}],38:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");module.exports=hasBinary;function hasBinary(data){function _hasBinary(obj){if(!obj)return false;if(global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer||global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){return true}if(isArray(obj)){for(var i=0;i<obj.length;i++){if(_hasBinary(obj[i])){return true}}}else if(obj&&"object"==typeof obj){if(obj.toJSON){obj=obj.toJSON()}for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)&&_hasBinary(obj[key])){return true}}}return false}return _hasBinary(data)}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{isarray:39}],39:[function(_dereq_,module,exports){module.exports=_dereq_(32)},{}],40:[function(_dereq_,module,exports){var global=_dereq_("global");try{module.exports="XMLHttpRequest"in global&&"withCredentials"in new global.XMLHttpRequest}catch(err){module.exports=false}},{global:41}],41:[function(_dereq_,module,exports){module.exports=function(){return this}()},{}],42:[function(_dereq_,module,exports){var indexOf=[].indexOf;module.exports=function(arr,obj){if(indexOf)return arr.indexOf(obj);for(var i=0;i<arr.length;++i){if(arr[i]===obj)return i}return-1}},{}],43:[function(_dereq_,module,exports){var has=Object.prototype.hasOwnProperty;exports.keys=Object.keys||function(obj){var keys=[];for(var key in obj){if(has.call(obj,key)){keys.push(key)}}return keys};exports.values=function(obj){var vals=[];for(var key in obj){if(has.call(obj,key)){vals.push(obj[key])}}return vals};exports.merge=function(a,b){for(var key in b){if(has.call(b,key)){a[key]=b[key]}}return a};exports.length=function(obj){return exports.keys(obj).length};exports.isEmpty=function(obj){return 0==exports.length(obj)}},{}],44:[function(_dereq_,module,exports){var re=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;var parts=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];module.exports=function parseuri(str){var m=re.exec(str||""),uri={},i=14;while(i--){uri[parts[i]]=m[i]||""}return uri}},{}],45:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");var isBuf=_dereq_("./is-buffer");exports.deconstructPacket=function(packet){var buffers=[];var packetData=packet.data;function _deconstructPacket(data){if(!data)return data;if(isBuf(data)){var placeholder={_placeholder:true,num:buffers.length};buffers.push(data);return placeholder}else if(isArray(data)){var newData=new Array(data.length);for(var i=0;i<data.length;i++){newData[i]=_deconstructPacket(data[i])}return newData}else if("object"==typeof data&&!(data instanceof Date)){var newData={};for(var key in data){newData[key]=_deconstructPacket(data[key])}return newData}return data}var pack=packet;pack.data=_deconstructPacket(packetData);pack.attachments=buffers.length;return{packet:pack,buffers:buffers}};exports.reconstructPacket=function(packet,buffers){var curPlaceHolder=0;function _reconstructPacket(data){if(data&&data._placeholder){var buf=buffers[data.num];return buf}else if(isArray(data)){for(var i=0;i<data.length;i++){data[i]=_reconstructPacket(data[i])}return data}else if(data&&"object"==typeof data){for(var key in data){data[key]=_reconstructPacket(data[key])}return data}return data}packet.data=_reconstructPacket(packet.data);packet.attachments=undefined;return packet};exports.removeBlobs=function(data,callback){function _removeBlobs(obj,curKey,containingObject){if(!obj)return obj;if(global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){pendingBlobs++;var fileReader=new FileReader;fileReader.onload=function(){if(containingObject){containingObject[curKey]=this.result}else{bloblessData=this.result}if(!--pendingBlobs){callback(bloblessData)}};fileReader.readAsArrayBuffer(obj)}else if(isArray(obj)){for(var i=0;i<obj.length;i++){_removeBlobs(obj[i],i,obj)}}else if(obj&&"object"==typeof obj&&!isBuf(obj)){for(var key in obj){_removeBlobs(obj[key],key,obj)}}}var pendingBlobs=0;var bloblessData=data;_removeBlobs(bloblessData);if(!pendingBlobs){callback(bloblessData)}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./is-buffer":47,isarray:48}],46:[function(_dereq_,module,exports){var debug=_dereq_("debug")("socket.io-parser");var json=_dereq_("json3");var isArray=_dereq_("isarray");var Emitter=_dereq_("component-emitter");var binary=_dereq_("./binary");var isBuf=_dereq_("./is-buffer");exports.protocol=4;exports.types=["CONNECT","DISCONNECT","EVENT","BINARY_EVENT","ACK","BINARY_ACK","ERROR"];exports.CONNECT=0;exports.DISCONNECT=1;exports.EVENT=2;exports.ACK=3;exports.ERROR=4;exports.BINARY_EVENT=5;exports.BINARY_ACK=6;exports.Encoder=Encoder;exports.Decoder=Decoder;function Encoder(){}Encoder.prototype.encode=function(obj,callback){debug("encoding packet %j",obj);if(exports.BINARY_EVENT==obj.type||exports.BINARY_ACK==obj.type){encodeAsBinary(obj,callback)}else{var encoding=encodeAsString(obj);callback([encoding])}};function encodeAsString(obj){var str="";var nsp=false;str+=obj.type;if(exports.BINARY_EVENT==obj.type||exports.BINARY_ACK==obj.type){str+=obj.attachments;str+="-"}if(obj.nsp&&"/"!=obj.nsp){nsp=true;str+=obj.nsp}if(null!=obj.id){if(nsp){str+=",";nsp=false}str+=obj.id}if(null!=obj.data){if(nsp)str+=",";str+=json.stringify(obj.data)}debug("encoded %j as %s",obj,str);return str}function encodeAsBinary(obj,callback){function writeEncoding(bloblessData){var deconstruction=binary.deconstructPacket(bloblessData);var pack=encodeAsString(deconstruction.packet);var buffers=deconstruction.buffers;buffers.unshift(pack);callback(buffers)}binary.removeBlobs(obj,writeEncoding)}function Decoder(){this.reconstructor=null}Emitter(Decoder.prototype);Decoder.prototype.add=function(obj){var packet;if("string"==typeof obj){packet=decodeString(obj);if(exports.BINARY_EVENT==packet.type||exports.BINARY_ACK==packet.type){this.reconstructor=new BinaryReconstructor(packet);if(this.reconstructor.reconPack.attachments===0){this.emit("decoded",packet)}}else{this.emit("decoded",packet)}}else if(isBuf(obj)||obj.base64){if(!this.reconstructor){throw new Error("got binary data when not reconstructing a packet")}else{packet=this.reconstructor.takeBinaryData(obj);if(packet){this.reconstructor=null;this.emit("decoded",packet)}}}else{throw new Error("Unknown type: "+obj)}};function decodeString(str){var p={};var i=0;p.type=Number(str.charAt(0));if(null==exports.types[p.type])return error();if(exports.BINARY_EVENT==p.type||exports.BINARY_ACK==p.type){var buf="";while(str.charAt(++i)!="-"){buf+=str.charAt(i);if(i+1==str.length)break}if(buf!=Number(buf)||str.charAt(i)!="-"){throw new Error("Illegal attachments")}p.attachments=Number(buf)}if("/"==str.charAt(i+1)){p.nsp="";while(++i){var c=str.charAt(i);if(","==c)break;p.nsp+=c;if(i+1==str.length)break}}else{p.nsp="/"}var next=str.charAt(i+1);if(""!==next&&Number(next)==next){p.id="";while(++i){var c=str.charAt(i);if(null==c||Number(c)!=c){--i;break}p.id+=str.charAt(i);if(i+1==str.length)break}p.id=Number(p.id)}if(str.charAt(++i)){try{p.data=json.parse(str.substr(i))}catch(e){return error()}}debug("decoded %s as %j",str,p);return p}Decoder.prototype.destroy=function(){if(this.reconstructor){this.reconstructor.finishedReconstruction()}};function BinaryReconstructor(packet){this.reconPack=packet;this.buffers=[]}BinaryReconstructor.prototype.takeBinaryData=function(binData){this.buffers.push(binData);if(this.buffers.length==this.reconPack.attachments){var packet=binary.reconstructPacket(this.reconPack,this.buffers);this.finishedReconstruction();return packet}return null};BinaryReconstructor.prototype.finishedReconstruction=function(){this.reconPack=null;this.buffers=[]};function error(data){return{type:exports.ERROR,data:"parser error"}}},{"./binary":45,"./is-buffer":47,"component-emitter":9,debug:10,isarray:48,json3:49}],47:[function(_dereq_,module,exports){(function(global){module.exports=isBuf;function isBuf(obj){return global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],48:[function(_dereq_,module,exports){module.exports=_dereq_(32)},{}],49:[function(_dereq_,module,exports){(function(window){var getClass={}.toString,isProperty,forEach,undef;var isLoader=typeof define==="function"&&define.amd;var nativeJSON=typeof JSON=="object"&&JSON;var JSON3=typeof exports=="object"&&exports&&!exports.nodeType&&exports;if(JSON3&&nativeJSON){JSON3.stringify=nativeJSON.stringify;JSON3.parse=nativeJSON.parse}else{JSON3=window.JSON=nativeJSON||{}}var isExtended=new Date(-0xc782b5b800cec);try{isExtended=isExtended.getUTCFullYear()==-109252&&isExtended.getUTCMonth()===0&&isExtended.getUTCDate()===1&&isExtended.getUTCHours()==10&&isExtended.getUTCMinutes()==37&&isExtended.getUTCSeconds()==6&&isExtended.getUTCMilliseconds()==708}catch(exception){}function has(name){if(has[name]!==undef){return has[name]}var isSupported;if(name=="bug-string-char-index"){isSupported="a"[0]!="a"}else if(name=="json"){isSupported=has("json-stringify")&&has("json-parse")}else{var value,serialized='{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';if(name=="json-stringify"){var stringify=JSON3.stringify,stringifySupported=typeof stringify=="function"&&isExtended;if(stringifySupported){(value=function(){return 1}).toJSON=value;try{stringifySupported=stringify(0)==="0"&&stringify(new Number)==="0"&&stringify(new String)=='""'&&stringify(getClass)===undef&&stringify(undef)===undef&&stringify()===undef&&stringify(value)==="1"&&stringify([value])=="[1]"&&stringify([undef])=="[null]"&&stringify(null)=="null"&&stringify([undef,getClass,null])=="[null,null,null]"&&stringify({a:[value,true,false,null,"\x00\b\n\f\r "]})==serialized&&stringify(null,value)==="1"&&stringify([1,2],null,1)=="[\n 1,\n 2\n]"&&stringify(new Date(-864e13))=='"-271821-04-20T00:00:00.000Z"'&&stringify(new Date(864e13))=='"+275760-09-13T00:00:00.000Z"'&&stringify(new Date(-621987552e5))=='"-000001-01-01T00:00:00.000Z"'&&stringify(new Date(-1))=='"1969-12-31T23:59:59.999Z"'}catch(exception){stringifySupported=false}}isSupported=stringifySupported}if(name=="json-parse"){var parse=JSON3.parse;if(typeof parse=="function"){try{if(parse("0")===0&&!parse(false)){value=parse(serialized);var parseSupported=value["a"].length==5&&value["a"][0]===1;if(parseSupported){try{parseSupported=!parse('"  "')}catch(exception){}if(parseSupported){try{parseSupported=parse("01")!==1}catch(exception){}}if(parseSupported){try{parseSupported=parse("1.")!==1}catch(exception){}}}}}catch(exception){parseSupported=false}}isSupported=parseSupported}}return has[name]=!!isSupported}if(!has("json")){var functionClass="[object Function]";var dateClass="[object Date]";var numberClass="[object Number]";var stringClass="[object String]";var arrayClass="[object Array]";var booleanClass="[object Boolean]";var charIndexBuggy=has("bug-string-char-index");if(!isExtended){var floor=Math.floor;var Months=[0,31,59,90,120,151,181,212,243,273,304,334];var getDay=function(year,month){return Months[month]+365*(year-1970)+floor((year-1969+(month=+(month>1)))/4)-floor((year-1901+month)/100)+floor((year-1601+month)/400)}}if(!(isProperty={}.hasOwnProperty)){isProperty=function(property){var members={},constructor;if((members.__proto__=null,members.__proto__={toString:1},members).toString!=getClass){isProperty=function(property){var original=this.__proto__,result=property in(this.__proto__=null,this);this.__proto__=original;return result}}else{constructor=members.constructor;isProperty=function(property){var parent=(this.constructor||constructor).prototype;return property in this&&!(property in parent&&this[property]===parent[property])}}members=null;return isProperty.call(this,property)}}var PrimitiveTypes={"boolean":1,number:1,string:1,undefined:1};var isHostType=function(object,property){var type=typeof object[property];return type=="object"?!!object[property]:!PrimitiveTypes[type]};forEach=function(object,callback){var size=0,Properties,members,property;(Properties=function(){this.valueOf=0}).prototype.valueOf=0;members=new Properties;for(property in members){if(isProperty.call(members,property)){size++}}Properties=members=null;if(!size){members=["valueOf","toString","toLocaleString","propertyIsEnumerable","isPrototypeOf","hasOwnProperty","constructor"];forEach=function(object,callback){var isFunction=getClass.call(object)==functionClass,property,length;var hasProperty=!isFunction&&typeof object.constructor!="function"&&isHostType(object,"hasOwnProperty")?object.hasOwnProperty:isProperty;for(property in object){if(!(isFunction&&property=="prototype")&&hasProperty.call(object,property)){callback(property)}}for(length=members.length;property=members[--length];hasProperty.call(object,property)&&callback(property));}}else if(size==2){forEach=function(object,callback){var members={},isFunction=getClass.call(object)==functionClass,property;for(property in object){if(!(isFunction&&property=="prototype")&&!isProperty.call(members,property)&&(members[property]=1)&&isProperty.call(object,property)){callback(property)}}}}else{forEach=function(object,callback){var isFunction=getClass.call(object)==functionClass,property,isConstructor;for(property in object){if(!(isFunction&&property=="prototype")&&isProperty.call(object,property)&&!(isConstructor=property==="constructor")){callback(property)}}if(isConstructor||isProperty.call(object,property="constructor")){callback(property)}}}return forEach(object,callback)};if(!has("json-stringify")){var Escapes={92:"\\\\",34:'\\"',8:"\\b",12:"\\f",10:"\\n",13:"\\r",9:"\\t"};var leadingZeroes="000000";var toPaddedString=function(width,value){return(leadingZeroes+(value||0)).slice(-width)};var unicodePrefix="\\u00";var quote=function(value){var result='"',index=0,length=value.length,isLarge=length>10&&charIndexBuggy,symbols;if(isLarge){symbols=value.split("")}for(;index<length;index++){var charCode=value.charCodeAt(index);switch(charCode){case 8:case 9:case 10:case 12:case 13:case 34:case 92:result+=Escapes[charCode];break;default:if(charCode<32){result+=unicodePrefix+toPaddedString(2,charCode.toString(16));break}result+=isLarge?symbols[index]:charIndexBuggy?value.charAt(index):value[index]}}return result+'"'};var serialize=function(property,object,callback,properties,whitespace,indentation,stack){var value,className,year,month,date,time,hours,minutes,seconds,milliseconds,results,element,index,length,prefix,result;try{value=object[property]}catch(exception){}if(typeof value=="object"&&value){className=getClass.call(value);if(className==dateClass&&!isProperty.call(value,"toJSON")){if(value>-1/0&&value<1/0){if(getDay){date=floor(value/864e5);for(year=floor(date/365.2425)+1970-1;getDay(year+1,0)<=date;year++);for(month=floor((date-getDay(year,0))/30.42);getDay(year,month+1)<=date;month++);date=1+date-getDay(year,month);time=(value%864e5+864e5)%864e5;hours=floor(time/36e5)%24;minutes=floor(time/6e4)%60;seconds=floor(time/1e3)%60;milliseconds=time%1e3}else{year=value.getUTCFullYear();month=value.getUTCMonth();date=value.getUTCDate();hours=value.getUTCHours();minutes=value.getUTCMinutes();seconds=value.getUTCSeconds();milliseconds=value.getUTCMilliseconds()}value=(year<=0||year>=1e4?(year<0?"-":"+")+toPaddedString(6,year<0?-year:year):toPaddedString(4,year))+"-"+toPaddedString(2,month+1)+"-"+toPaddedString(2,date)+"T"+toPaddedString(2,hours)+":"+toPaddedString(2,minutes)+":"+toPaddedString(2,seconds)+"."+toPaddedString(3,milliseconds)+"Z"}else{value=null}}else if(typeof value.toJSON=="function"&&(className!=numberClass&&className!=stringClass&&className!=arrayClass||isProperty.call(value,"toJSON"))){value=value.toJSON(property)}}if(callback){value=callback.call(object,property,value)}if(value===null){return"null"}className=getClass.call(value);if(className==booleanClass){return""+value}else if(className==numberClass){return value>-1/0&&value<1/0?""+value:"null"}else if(className==stringClass){return quote(""+value)}if(typeof value=="object"){for(length=stack.length;length--;){if(stack[length]===value){throw TypeError()}}stack.push(value);results=[];prefix=indentation;indentation+=whitespace;if(className==arrayClass){for(index=0,length=value.length;index<length;index++){element=serialize(index,value,callback,properties,whitespace,indentation,stack);results.push(element===undef?"null":element)}result=results.length?whitespace?"[\n"+indentation+results.join(",\n"+indentation)+"\n"+prefix+"]":"["+results.join(",")+"]":"[]"}else{forEach(properties||value,function(property){var element=serialize(property,value,callback,properties,whitespace,indentation,stack);if(element!==undef){results.push(quote(property)+":"+(whitespace?" ":"")+element)}});result=results.length?whitespace?"{\n"+indentation+results.join(",\n"+indentation)+"\n"+prefix+"}":"{"+results.join(",")+"}":"{}"}stack.pop();return result}};JSON3.stringify=function(source,filter,width){var whitespace,callback,properties,className;if(typeof filter=="function"||typeof filter=="object"&&filter){if((className=getClass.call(filter))==functionClass){callback=filter}else if(className==arrayClass){properties={};for(var index=0,length=filter.length,value;index<length;value=filter[index++],(className=getClass.call(value),className==stringClass||className==numberClass)&&(properties[value]=1));}}if(width){if((className=getClass.call(width))==numberClass){if((width-=width%1)>0){for(whitespace="",width>10&&(width=10);whitespace.length<width;whitespace+=" ");}}else if(className==stringClass){whitespace=width.length<=10?width:width.slice(0,10)}}return serialize("",(value={},value[""]=source,value),callback,properties,whitespace,"",[])}}if(!has("json-parse")){var fromCharCode=String.fromCharCode;var Unescapes={92:"\\",34:'"',47:"/",98:"\b",116:"  ",110:"\n",102:"\f",114:"\r"};var Index,Source;var abort=function(){Index=Source=null;throw SyntaxError()};var lex=function(){var source=Source,length=source.length,value,begin,position,isSigned,charCode;while(Index<length){charCode=source.charCodeAt(Index);switch(charCode){case 9:case 10:case 13:case 32:Index++;break;case 123:case 125:case 91:case 93:case 58:case 44:value=charIndexBuggy?source.charAt(Index):source[Index];Index++;return value;case 34:for(value="@",Index++;Index<length;){charCode=source.charCodeAt(Index);if(charCode<32){abort()}else if(charCode==92){charCode=source.charCodeAt(++Index);switch(charCode){case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:value+=Unescapes[charCode];Index++;break;case 117:begin=++Index;for(position=Index+4;Index<position;Index++){charCode=source.charCodeAt(Index);if(!(charCode>=48&&charCode<=57||charCode>=97&&charCode<=102||charCode>=65&&charCode<=70)){abort()}}value+=fromCharCode("0x"+source.slice(begin,Index));break;default:abort()}}else{if(charCode==34){break}charCode=source.charCodeAt(Index);begin=Index;while(charCode>=32&&charCode!=92&&charCode!=34){charCode=source.charCodeAt(++Index)}value+=source.slice(begin,Index)}}if(source.charCodeAt(Index)==34){Index++;return value}abort();default:begin=Index;if(charCode==45){isSigned=true;charCode=source.charCodeAt(++Index)}if(charCode>=48&&charCode<=57){if(charCode==48&&(charCode=source.charCodeAt(Index+1),charCode>=48&&charCode<=57)){abort()}isSigned=false;for(;Index<length&&(charCode=source.charCodeAt(Index),charCode>=48&&charCode<=57);Index++);if(source.charCodeAt(Index)==46){position=++Index;for(;position<length&&(charCode=source.charCodeAt(position),charCode>=48&&charCode<=57);position++);if(position==Index){abort()}Index=position}charCode=source.charCodeAt(Index);if(charCode==101||charCode==69){charCode=source.charCodeAt(++Index);if(charCode==43||charCode==45){Index++}for(position=Index;position<length&&(charCode=source.charCodeAt(position),charCode>=48&&charCode<=57);position++);if(position==Index){abort()}Index=position}return+source.slice(begin,Index)}if(isSigned){abort()}if(source.slice(Index,Index+4)=="true"){Index+=4;return true}else if(source.slice(Index,Index+5)=="false"){Index+=5;return false}else if(source.slice(Index,Index+4)=="null"){Index+=4;return null}abort()}}return"$"};var get=function(value){var results,hasMembers;if(value=="$"){abort()}if(typeof value=="string"){if((charIndexBuggy?value.charAt(0):value[0])=="@"){return value.slice(1)}if(value=="["){results=[];for(;;hasMembers||(hasMembers=true)){value=lex();if(value=="]"){break}if(hasMembers){if(value==","){value=lex();if(value=="]"){abort()}}else{abort()}}if(value==","){abort()}results.push(get(value))}return results}else if(value=="{"){results={};for(;;hasMembers||(hasMembers=true)){value=lex();if(value=="}"){break}if(hasMembers){if(value==","){value=lex();if(value=="}"){abort()}}else{abort()}}if(value==","||typeof value!="string"||(charIndexBuggy?value.charAt(0):value[0])!="@"||lex()!=":"){abort()}results[value.slice(1)]=get(lex())}return results}abort()}return value};var update=function(source,property,callback){var element=walk(source,property,callback);if(element===undef){delete source[property]}else{source[property]=element}};var walk=function(source,property,callback){var value=source[property],length;if(typeof value=="object"&&value){if(getClass.call(value)==arrayClass){for(length=value.length;length--;){update(value,length,callback)}}else{forEach(value,function(property){update(value,property,callback)})}}return callback.call(source,property,value)};JSON3.parse=function(source,callback){var result,value;Index=0;Source=""+source;result=get(lex());if(lex()!="$"){abort()}Index=Source=null;return callback&&getClass.call(callback)==functionClass?walk((value={},value[""]=result,value),"",callback):result}}}if(isLoader){define(function(){return JSON3})}})(this)},{}],50:[function(_dereq_,module,exports){module.exports=toArray;function toArray(list,index){var array=[];index=index||0;for(var i=index||0;i<list.length;i++){array[i-index]=list[i]}return array}},{}]},{},[1])(1)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/element.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')
  , element = require('../../element')
  , utilHash = require('../../../util/hash')
  , vObject = require('../../../object')

/*this file has nothing to do with the networkdata Class
  it only reads out models for elements so you can make a subscription
*/

function sortField( filter, obj ) {
  if( filter.sort && filter.sort.field ) 
  {
    var sort = { $:{} }
    sort.$[filter.sort.field] = true
    util.merge( obj, sort )
  }

  return obj
}

//TODO: has to work in the hub
var disableSelections = true

exports.parseData = function( val, fromtargets, logger ) {


  //important for unSubscribe ???
    // console.log('LETS PARSE DATA!'.cyan.inverse , val, JSON.stringify(fromtargets))
  

  // console.log('LETS PARSE DATA!'.cyan.inverse , val, JSON.stringify(fromtargets))

  if(!val) return
    // console.log('LETS PARSE DATA!2'.cyan.inverse , val, JSON.stringify(fromtargets))

  var subsobj = {}
    , f = val._filter
    , targets = fromtargets || val.__sub

  if (targets) {
    // console.log('targets', targets)
    if (f && !disableSelections) {
      if(!subsobj['*']) subsobj['*']=[]
      subsobj['*'].push([
        util.clone(f, {subsObj:true, fn:true, type:true})
        , sortField(f, fromtargets || { $: targets })
      ])

    // console.log( 'IM DOING SELECTS parseDatelex', subsobj )
    //TEMPFIX!!!!
    for(var i in subsobj['*'][1] ) {
      //wel ff de fields ook doen prob

      subsobj[i] = subsobj['*'][1][i]
    }
    delete subsobj['*']

    } else {
          // console.log( 'targets IM DOING SELECTS parseDatelex', targets )

      subsobj = targets
    }
  } else {
        // console.log('LETS PARSE DATA!4'.cyan.inverse , val, JSON.stringify(fromtargets))

    // console.warn( 'cant\'t find target -- lets do stuff!', val  )
    //TODO:guard voor als het het niet wil -- mischiend door _subs zoeken

    // if(val._path) {
    //   console.log(val._path)
    // }

    //no tragets dont do anything?
  }

  // console.log('RESULT!', JSON.stringify(subsobj))

  return subsobj
}

function setFlag( obj, string, flag, field, val, from, elem ) {



  var nonCloudDataBindings
    , fromKey

    , beTripppin


  if( from ) {
    fromKey = from._name !== void 0 ? from._name : from

    if( from instanceof vObject) {

      //tegenover gestelde bij
      // if(from.__t === 4) {
        // if(from._val && from._val.cloud) {
          //haal juist field weg
        // }
      // } 
      // console.log('FROM!', from._name, from._path )
      fromKey = from._name
    }

    if(from instanceof Array && from[1]) {
      // console.log('be tripping!', from)
      //   fromKey = from[1] && from[1]._name

      // beTripppin = from[0]._name

    }

  }

  var dd = elem && from && ( elem._d || elem.checkParent('data', true) )

  // if(beTripppin) {
  //   console.log(dd, fromKey, beTripppin)
  // }


  if (field === 'collection') {
    var obj2

    if (flag.filter && flag.filter.val!==true && !disableSelections) 
    {
      //dit nog handelen op refs
      obj2 = {}


      //ENABLE FOR SELECTION
      // if (string === true) {

      //   string = '*'
      // } else {

      //   string = string + '.*'
      // }
      var f = flag.filter.raw

        // console.log( 'SET FLAG', arguments )


  // console.log( 'FIELD!:', field , 'FROM:', from,  string.split('.'), string )

      var arr = util.path(obj, string.split('.'), [])

      arr.push( 
        [f, {
          $: sortField(f,obj2)
        }]
      )

      //obj, path, val, overwrite

      //TEMPFIX!!!!
      var temp = util.path( obj, string.split('.'), {}, true )
      for(var i in arr[arr.length-1][1] ) {
        //wel ff de fields ook doen prob

        temp[i] = arr[arr.length-1][1][i]
      }
      arr = temp

          // console.log( 'IM DOING SELECPS COL COL!', arr )


    } else {

      var f = string === true ? '$' : string + '.$'
        , p =  f.split('.')

        , specialFix

      if( dd && dd[ fromKey ] ) 
      {
        nonCloudDataBindings = true
        if( p[0] === fromKey ) 
        {
          p.shift()
          nonCloudDataBindings = false
        }
      }

      if( nonCloudDataBindings ) 
      {
        if(specialFix) {
          obj.specialFix = fromKey
          if(beTripppin) {
            obj.specialFix = [ fromKey, beTripppin ]
          }
          obj2 = util.path(obj, p , {})
          readModel(flag.element._val instanceof element ? flag.element._val : flag.element._val.base, obj2 )
        }
      } 
      else 
      {
        obj2 = util.path(obj, p , {})
        readModel(flag.element._val instanceof element ? flag.element._val : flag.element._val.base, obj2 )
      }

    }

                  // console.log(  'xxxXX1112222XXxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )


  } else {

    if( dd && dd[ fromKey ] ) 
    {
      nonCloudDataBindings = true
    }

    if ( string instanceof Array ) 
    {
      for (var i in string) 
      {
        if( nonCloudDataBindings )
        {
          //TODO: this is a tempfix
          // console.log('NON cloud bindings', string, string[i])
          if( string[i] instanceof Array ) {
            // console.log('!@!@!@')
            string[i] = string[i][0]
          }
          string[i] = string[i].split('.')
          if( string[i][0] === fromKey ) 
          {
            string[i].shift()
            util.path( obj, string[i], true )
          }
        }
        else
        {
          //TODO: this is a tempfix
          // console.log('OBJ:' , obj, 'STRING[i]:', string[i], 'STRING:', string, fromKey)
           if( string[i] instanceof Array ) {
            // console.log('2!@!@!@')
            string[i] = string[i][0]
          }
          util.path(obj, string[i].split('.'), true)
        }
      }
    } 
    else if ( string !== true && typeof string === 'string' ) 
    {
              // console.log(  'xxxXXXXxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )

      if( nonCloudDataBindings )
      {
        // console.log( nonCloudDataBindings , 'NONCLOUD')
          string = string.split('.')
          if( string[0] === fromKey ) 
          {
            string.shift()
              // console.log( 'FIELD!:222222', string )

            if(string.length > 0) util.path( obj, string, true )
          }
          // console.log( nonCloudDataBindings , 'NONCLOUD', string, obj )
      }
      else
      {
        // console.log(  'xxxxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )
        util.path( obj, string.split('.'), true )
      }
    } 
    else 
    {
      // console.log('----> 2'.inverse, string, obj, flag, field)
      // console.error('xxxxxx')
      // obj['__#__'] = true
      // obj = true;
      // console.log('!!!',obj, parent);
      // obj['#'] = true;
    }
    

  }
}

function store( obj, flag, field, val, from, elem ) {

  // console.log('STORE', arguments )

  if (flag instanceof Array) {
    for (var i = 0, l = flag.length; i < l; i++) {
      setFlag(obj, flag[i]._flag.data[2], flag, field, val, from, elem )

    }
  } else {
        // console.log('------>'.red,flag)

    setFlag(obj, flag._flag.data[2], flag, field, val, from, elem )
  }
}

function readModel( elem, obj, val, from , ignorefield) {

  // console.log( 'lets read model'.yellow.inverse, val && val._path || 'no valPath', from && from._path || 'no fromPath' , val, elem, obj, val, from )
    //hier moet het gecombineerd worden met een value waar het aan gebind is!

  if (elem.model && (elem.model.flags||elem.model.subscription||elem.model.field)) {
    
    // if(obj) console.log('XXX121212XXX COLLECTION',  elem.model.field && elem.model.field.val )
    // console.log('SET SORTFIELD! 2.12', JSON.stringify(obj,false,2), elem.model.field && elem.model.field.val)

    var a = obj
      , field
      , doItIgnoreFlags

      //["users", "U_ba3215a1b1038a70", "navigation", "episode"] 
    // console.log( '\n\n\n\n\n-------->', elem.model.field && elem.model.field.val, elem.model.parsing && !elem.model.parsed  )

    if(ignorefield) {
      // console.log('STOP! ignorefield', obj, elem.model.field && elem.model.field.val, from, from && from._path)
      // debugger
    }
    //TODO: compare arrays 
    else if(elem.model.field && elem.model.field.val && !elem.model.parsing && !elem.modelParsed && ( typeof from !== 'string' || elem.model.field.val === from  )  ) {
      field = elem.model.field.val.split('.')
      
      if( elem.model.field.val === from ) {

        // console.log('HERE ITS INTERESTING DO', elem.model.field.val , from )

      } else {
        a = util.path(obj,field,{},true)
        doItIgnoreFlags = true
      }

    } else {
      if(from && elem.model.field && elem.model.field.val !== from) {
        return void 0
      }
    }

    if(elem.model && elem.model.subscription ) {

      var subs = elem.model.subscription.raw
      if(subs === true) {
        if(field) {
          if(field.length>1) {
          a = util.path(obj,field,true,true)
          } else {
            obj[field[0]] = true
            a = true
          }
        }
      } else {
        var sub = elem.model.subscription.raw
        if( typeof sub === 'string' ) {
          var old = sub
          sub = {}
          sub[old] = true
        }
        util.merge(a,sub)
      }
    }

    for (var i in elem.model.flags) {
      store(a, elem.model.flags[i], i, val, from, elem )
    }
    
  }

  if( !elem.model || !elem.model.block || !elem.model.block.val ) {

    for (
      var children = elem.children
      , child
      , child$ = 0
      , children$len = children && children.length
      ; child$ < children$len
      ; child = child$++
    ) {
      child = children[child$]
      if ((!child.model || (!child.model.inherit || child.model.inherit.val!==false))
        && !child._col && !child.data || child._dfrom) { //dit kan beter!
        readModel(child, a || obj, val, from )
      //elem, obj, val, from , ignorefield, field
      }
    }
  }

  if(obj['__#__']) {
    // obj.$ = true
    // util.merge(obj, obj['__#__'])
    delete obj['__#__']
  }

  return elem.model && elem.model.block && elem.model.block.val==='all' ? void 0 : obj
}

util.define(element, 'getModel', function( val, from, ignorefield ) {

  var subscription = readModel( this, {}, val, from, ignorefield )

  // console.error('parsed subscription!', JSON.stringify(subscription, false, 2) )
  //waarom komt ie 3x extra?

  return !util.empty( subscription ) ? subscription : null
})
},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require('../../../object')
  , data = require('../../../data')
  , Value = require('../../../value')
  , util = require('../../../util')
  , vigour = require('../../../')
  , _networkdata = module.exports = exports = vigour.Networkdata = data.new({
      mixed: 4, //mischien niet mixed
      merge: true
    })
  , _sub = 'subscribe'
  , _unsub = 'un' + _sub
  , _listener = 'Listener'
  , _al = 'add' + _listener
  , _rl = 'remove' + _listener
  , _proto = object.prototype
  , _protoAddListener = _proto[_al]
  , _protoRemoveListener = _proto[_rl]
  , _checkSubscription = function( field, val ) {
      var a = this
      while (a && a.__t === 4) {
        if(a.__block) return
        a = a._val
      }
      // console.log(field, a)
      if((a instanceof _networkdata) && a[field]) a[field](val, this)
    }
  , V = require('../../../')

_networkdata.prototype._blacklist.push('_subs','_complete')
//'_' + _sub, '_' + _unsub, we dont use there now
// _subscribe(_sub);
// _subscribe(_unsub);


//TODO: fix mark!!!!!!!!!!! mark:true
util.define(_networkdata,
  'get', function( val, set, notself, stamp ) {
    
    // IM GETTING! ["users", "u_ba3215a1b1038a70", "mtvData", "NL", "nl", "shows"] undefined
    //obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i
    // var bla = (val instanceof Array) ? val : String(val).split('.')
    // console.log('IM GETTING!', bla, val, set, this, this.path)

    //TODO: Always give me the non-from is possible
    // console.warn('Get -- self is now on on defualt should become something different!')
    //obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self,
    //conditional self

    return this.path
      ( (val instanceof Array) ? val : String(val).split('.')
      , set !== void 0 ? set : {}
      , false
      , false
      , false
      , stamp || false //stampy
      , true
      , !notself
      )

  },
  // '_changevobj', function(val,stamp) {
  //   console.error(val,stamp)
  //   return _changevobj.apply(this,arguments)
  // },
  // '_hook', function(val, param) {
  //   for (var i in param) {
  //     this['_' + i] = param[i];
  //   }
  // }, //dont use this now so lets add when used
  _al, function( val ) {
    // console.log('LETS GO!', _sub, val, !!this[_sub])
    if(this[_sub]) this[_sub](val)
    _protoAddListener.apply( this, arguments )
  },
  _rl, function( val, mark ) {
    if (this._listeners && this[_unsub]) {
      // console.log('REMOVE _L'.red.inverse, mark)
      this[_unsub]( mark )
    }
    _protoRemoveListener.apply( this, arguments )
  }
);

//-------DATA---------
util.define(data, 
  _al, function(val) {
    // console.log('0--------->',val)
    if(!this.__block) _checkSubscription.call(this, _sub, val);
    _protoAddListener.apply(this, arguments);
  },
  _rl, function(val, mark) {
     // console.error('2.1 REMOVE _L', mark, val, _unsub)
    if(!this.__block) _checkSubscription.call(this, _unsub, mark);
    _protoRemoveListener.apply(this, arguments);
  }
);

//-------Value---------

// util.define(Value, //test is this impacts performance to much
//   _al, function(val) {
//     // console.log('0--------->',val)
//     if(!this.__block) _checkSubscription.call(this, _sub, val);
//     _protoAddListener.apply(this, arguments);
//   },
//   _rl, function(val, mark) {
//      // console.error('2.1 REMOVE _L', mark, val, _unsub)
//     if(!this.__block) _checkSubscription.call(this, _unsub, mark);
//     _protoRemoveListener.apply(this, arguments);
//   }
// );





},{"../../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js":[function(require,module,exports){
var util = require('../../util')
  , Value = require('../../value')
  , config = require('../../util/config')
  , process = require('../../value/flags/process')
  , raf = require('../../browser/animation/raf')
  , postpone = require('../../browser/events/util').postpone
  , ua = require('../../browser/ua')

Value.prototype._blacklist.push('_last')

module.exports = exports = new Value()
//TODO: .params /w listeners!

config.hashUrl = ua.device === 'tv' && ua.platform === 'lg' ? false :  config.hashUrl

// history.pushState({}, '','' )
// history.go(0)
// history.back()

var pstate = !config.hashUrl //= !window.DEBUG$ && window.history && window.history.pushState
  , cnt = 0
  , timedState
  , state = postpone ( pstate ? function(val) {
      //load current params as well
      //same goes for the other
      //we could add a delay here!
      href = window.location.href

      console.log(val,  val.replace(/ /g, '+').replace(/^#\//, '').toLowerCase())

      window.history.pushState( {}, val, val.replace(/ /g, '+').replace(/^#\//, '').toLowerCase() )
    } : function(val) {
      exports.block = true
      window.location.href = '#/' + val.replace(/ /g, '+').toLowerCase()
      exports.block = false
    } )
  , _set = Value.prototype._set
  , parse = function() {
      if (!pstate) 
      {
        var url = window.location.href.split('#')
        var params = ''
        if( url && url.length === 1 ) {
          params = query( url[0] )
          url[0] = url[0].replace(params, '')
          // window.location = '#/'+params
          // return = 'x'
        }
        // console.log( url, ( url.length > 1 ? url[1].replace(/\+/g, ' ') : ' ' ).slice(1), params )
        // +params
        return ( url.length > 1 ? url[1].replace(/\+/g, ' ') : ' ' ).slice(1)+params
      } else 
      {
        
        var url = window.location.href
        if( url ) {
          params = query( url )
          url = url.replace(params, '')
          // window.location = '#/'+params
          // return = 'x'
        }

        return String(window.location.href)
               .replace(String(window.location.origin) + '/', '')
               .replace(/^#\//, '')
               .replace(/\+/g, ' ')
               || ''
      }
    }
  , query = function( str ) {
      if(!str) str = parse() || ''
      var arr = str.split('?')
        , len = arr.length
      str = len > 1 && arr[ arr.length - 1 ] ? '?'+arr[ arr.length - 1 ] : ''
      return str
    }

exports.parse = parse

//TODO: back btn hijack (event hijack add random param)
//TODO: use raf for updates
exports.val = { 
  string: function() {
    var str = parse()
    return str.replace( query( str ), '' )
  },
  params: {
    val: function() { return query() },
    defer:function( update, args ) {

      this.clearCache() //maybe not?

      var val = this.val
        , params
        , nestedparams
        , c

      if( val && val!==this._last ) {
        this._last = val
        params = val.slice(1).split('&')
        nestedparams = {}
        for( var i in params ) {
          c = params[i].split('=')
          if( c.length>1 ) 
          {
            nestedparams[c[0]] = c[1]
          }
          else
          {
            console.error('url: no [key]=[value] format -- not implemented yet')
          }
        }
        this.val = nestedparams
      }
      raf(function() { update() })
    }
  },
  transform: function( v, cv ) {
    return cv
  },
  defer: function( update, args ) {
    if( args[1] && args[1][0] === 'u' ) 
    {
      this.clearCache()
      raf( function() {
        update()
      })
    } else 
    {
      this.clearCache()
      var a = ( typeof args[0] === 'string'  ? args[0] : args[0] && args[0].val || this.val )
      if(a) 
      {
        exports.blocks = cnt

        state( a + this.params.val )
      }
      return  true
      //TODO: update( true ) blocks all consecutive updates
    }
  }
}

function urlEvent(e) {
  var stamp

  if( !config.hashUrl || exports.blocks!==cnt ) 
  {
    cnt++
    stamp = 'u'+cnt
    exports.clearCache()
    exports.string.clearCache() //maybe not clear on string?
    // exports._update( parse(), 'url' )
    exports.string._update( exports.string.val , stamp )
    exports.params._update( exports.string.val, stamp )
    exports._update( exports.string.val, stamp )
    exports._lstamp = null

  } else {
    cnt++
  }
}

util.define( exports, 'update', function() {
  urlEvent()
})

util.define( exports.string, 'raw', {
  get:function() {
    return this.val.replace( / /g, '+' )
  }
})

if( config.hashUrl )
{
  window.onhashchange = urlEvent
}
else
{
  window.onpopstate = urlEvent
}
//TODO: add popstate


},{"../../browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js":[function(require,module,exports){
/*
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
/*
/*
  useragent sniffing is never used for feature detection, for a multi-screen app you do need information about the device also when running in the browser
  has fields V.ua.platform, device, browser and version. This implementation when compiled, is only 700 bytes
*/
var util = require('../util')
/**
 * test
 * search for regexps in the userAgent
 * fn is a on succes callback
 * check http://www.useragentstring.com/ to test for userAgents
 * @method
 */
, test = exports.test = function( _ua, fn ) {

  for
  ( var tests = util.arg( arguments, 1 )
      , i = tests.length - 1
      , query = tests[i][0]
    ; query !== true && !new RegExp( query ).test( _ua )
    ; query = tests[--i][0]
  )

  ;if( fn.slice || fn.call( this, query, tests[i] ) )
  {
    this[fn] = tests[i][1]
  }

}
, parse = exports.parse = function(_ua, obj) {

  if( !_ua )
  {
    obj = exports
    _ua = typeof navigator !== 'undefined'
        ? navigator.userAgent.toLowerCase()
        : 'no navigator'
  }

  _ua = _ua.toLowerCase()

  if( !obj ) obj = {}

  // _ua = 'webos; linux - large screen'

  var _ff = 'firefox'
    , _android = 'android'
    , _mobile = '.+mobile'
    , _webkit = 'webkit'
    , _ps = 'playstation'
    , _xbox = 'xbox'
    , _linux = 'linux'
    , _castDetect = 'crkey'
    , _chromecast = 'chromecast'
    , _tablet = 'tablet'
    , _windows = 'windows'
    , _phone = 'phone'
    , _iphoneVersion

  test.call
  ( obj
  , _ua
  , function( query, arr ) {

      obj.browser = arr[2] || query

      var _v = _ua.match
      ( new RegExp
        ( '((([\\/ ]version|'
        + arr[0]
        + '(?!.+version))[\/ ])| rv:)([0-9]{1,4}\\.[0-9]{0,2})'
        )
      )

      obj.version = _v ? Number( _v[4] ) : 0
      obj.prefix = arr[1]
      //TODO: add prefix for opera v>12.15;
      //TODO: windows check for ie 11 may be too general;
    }
  , [ true, _webkit ]
  , [ '\\(windows', 'ms', 'ie' ]
  , [ 'safari', _webkit ]
  , [ _ff, 'Moz' ]
  , [ 'opera', 'O' ]
  , [ 'msie', 'ms', 'ie' ]
  , [ 'chrome|crios\/', _webkit, 'chrome' ]
  )

  /**
  * platform detection
  */
  test.call
  ( obj
  , _ua
  , 'platform'
  , [ true, _windows ]
  , [ _linux, _linux ]
  , [ 'lg.{0,3}netcast', 'lg' ] //TODO:propably need to add more!
  , [ _ff + _mobile, _ff ]
  , [ 'mac os x', 'mac' ]
  , [ 'iphone|ipod|ipad', 'ios' ]
  , [ _xbox, _xbox ]
  , [ _ps, _ps ]
  , [ _android, _android ]
  , [ _windows, _windows ]
  , [ _castDetect, _chromecast ]
  , [ 'smart-tv;|;samsung;smarttv', 'samsung' ] //SmartTV2013
  )

  /**
  * device detection
  */
  test.call
  ( obj
  , _ua
  , 'device'
  , [ true, 'desktop' ]
  , [ _windows + '.+touch|ipad|' + _android,  _tablet ]
  , [ 'iphone|(' + _android + _mobile + ')|(' + _ff + _mobile + ')|' + _windows + ' phone|iemobile'
    , _phone
    ]
  , [ _xbox + '|' + _ps, 'console' ]
  , [ 'tv|smarttv|googletv|appletv|hbbtv|pov_tv|netcast.tv|webos.+large', 'tv' ]
  , [ _castDetect, _chromecast ]
  , [ 'amazon-fireos', _tablet ]
  )

  //TODO: amazon firetv and phone
    // alert(window.innerWidth*window.innerHeight +  '  '+ 414 * 736)
  
  //414 × 736
  var iphone6plus = 414 * 736
  if
  ( obj.platform === _android
    && !util.isNode
    && obj.device === _phone
    && window.innerWidth*window.innerHeight > iphone6plus
    // && ~_ua.indexOf('crosswalk')
  )
  {
    obj.device = 'tablet'
  }

  return obj
}

if( !util.isNode ) 
{ 
  parse()
  //TODO: this is very ugly, try to find a better solution
  if( window.__ua__ ) 
  {
    for( var field in window.__ua__ )
    {
      exports[field] = window.__ua__[field]
    }
  }
}

/**
 * prop
 * re-writes js properties to their css counterpart
 * e.g. webkitTransform --> -webkit-transform
 * now its commented since its not nessecary yet
 * @method
 */
// this.prop = function(str) {
//  return str.replace(this.prefix,'-'+this.prefix+'-').toLowerCase();
// }

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var  data = require('./')
  , base = require('../base')
  , util = require('../util')
  , flags = require('../value/flags/data')
  , vObject = require('../object')

exports.extend = util.extend( function(base, extensions, modelblacklist) {

  // var _blacklist = util.add(['flags', 'ref', 'parse', 'parsing'], modelblacklist),
    var _compare = util.compareArrays,
    methods = {
      _dUpdate: function(obj, val, stamp, from, remove, added, oldval, instances, argx1, argx2 ) {
        // if(window.here) console.log('X',stamp)
        if (this.model) {
          //$ndata
          //TODO: very dirty fix get rid of this!
          if( obj === '$ndata' ){
            val = from
            stamp = remove
            from = added
            remove = oldval
            added = instances
            oldval = argx1
            instances = argx2
            // console.log('!@#!@#!@#!@#@!#!@#!@#!@#'.red.inverse)
          }

          // var non = 0
          //   , cnt = 0
          // for( var i in arguments ) 
          // {
          //   cnt++
          //   if(!arguments[i]) {
          //     non++
          //   }
          //   console.log( arguments[i] )
          // }
          // if(non === cnt) {
          //   alert('no args')
          //   return true
          // }

          if (!this._d && this.parent) {
            var p = this.parent;
            while (!this._d && p) {
              if (p._d) {
                // console.error('SET DATA')
                this._dSet(p._d, true);
              } else {
                p = p.parent;
              }
            }
          }
          var t = this,
            model = t.model,
            f = model.flags,

            // f = model ? model.flags : false be carefull with updates in values that have data

            path = t._d && t._d._path || [],
            name = (from || (from = (t._d && t._d._updateOrigin)) && !(from === t._d && (from = false))) && from.updatePath,
            fromPath = from && from._path,
            method = function(i, field) {

              var select, pass, fr, lfield;
              // if( field._flag[2].__t) {
              //multiple flags!
                // console.log('FLAG'.inverse, name, field._flag)
              // }

              if(!field._flag.data) {
                console.error('NO DATA FLAG', name, field._flag, val, obj, remove, added, oldval)
                return
              }
              field = field._flag.data[2];

               // console.log('DATA UPDATE'.magenta.inverse,
               //      'obj:', obj
               //    , 'val:', val
               //    , 'stamp:', stamp
               //    , 'from:', from
               //    , 'remove:', remove
               //    , 'added:', added
               //    , 'field:', field
               //  )
              // var test = (i==='text' && field === 'real.duration')
              // if(test) console.log(field,i)
              // if(test) pass = true

              if (i === 'collection' && t._colFilter) return
              //if not own colfilter --> handle yourself!;
              // if data has changed change colfilter adn send update
              //be carefull /w changes!; too crude

              if (field === true) {
                // console.log('PASS'.inverse,name)
                pass = true;
              } else if (field.pop) {
                // console.log(name,'???')

                // console.log('--->',field, field.pop)

                field = field.concat();

                for (var j = field.length - 1; j >= 0; j--) {
                  if (!lfield !== void 0) {
                    select = util.get(t._d, field[j]);
                    if (select !== void 0) {
                      lfield = true;
                      // break;
                    }
                  }
                  field[j] = field[j].split('.');
                }
              } else {

                // console.log('DO DO!'.inverse,name, t._d && t._d._updateOrigin)

                // console.log(name, path, select, obj, val, stamp, from, remove, added, oldval, instances)

                field = field.split('.')

                select = util.get(t._d, field)

                if(!select && t._d && t._d.from && field ) {
                  // console.log('NO SELECT'.red.inverse, t._d )
                  select = util.get(t._d.from, field)
                  // if(select) {
                  //   // console.log('FOUND SELECT'.green.inverse, select)
                  // }
                } 

                if(select && from && from.__t === 4) lfield = true //test dit of het alles slow maakt

                // if(test&&select) console.log(select._val)
              }

              if (!pass && from) {

                // console.log('testing....?', name, from, select, lfield)
                // if(test) console.log(name, select, lfield, from);

                fr = true;
                var fromFrom

                if ( from === select || ( fromFrom = from.from ) === select ) {
                  pass = true;
                } else {
                  if (t._d._filter && select && select._ancestor(from)) {
                    pass = true;
                    //field ook voor arrays!;
                  } else if (lfield) {

                    // console.log('got lfield!!!!')

                    for (var n = 0; n < field.length; n++) {
                      if (name && _compare(name, field[n]) || field[n][0] === name[0] && util.get(val, field[n].concat().shift())) 
                      {
                        fr = false;
                        break;
                      } 
                      else if ((_compare(path.concat(field[n]), fromPath) || _compare(field[n], fromPath))) 
                      {
                        fr = false;
                        break;
                      } 
                      else {

                        // console.log('HERE?'.cyan.inverse, '\n\n\n', select.from.raw, 'val:'
                        //   , val, 'field:', field, 'fn', field[n], 'n:', n, 'check field:', val && val[field[n]], 'ref:', val.from)
                        // console.log('coming trugh', select && from._val !== null && val, field[n]
                        //   , select && from._val !== null && val && ( val[field[n]] || val.__t === 4 && val.from[field[n]] ) )
                        //TODO: need to add more gaurding for val.$path check if this is cloud and ref

                        if(select && from._val !== null && val && (val[field[n]] || val.$path || val.__t === 4) && (select._ancestor(from) || select.from._ancestor( fromFrom )  ))  //
                        {
                          // console.log(val, field);
                          pass = true;
                          break;
                        }
                      }
                    }
                  } else {

                    // console.log( '---', select, val, field, from, 'fromPath:' , fromPath )

                    if(val===null) {
                      // if(DEBUG$) t._d.DEBUG$log('data/base ---> ERROR val is null  --->'+t._d._removed )
                    } else if(val === void 0) {
                      // TODO: handle this
                      // console.log('\n\n\n undefined what to do now?', arguments,this)
                      // debugger
                      // pass = true
                      // pass = true
                    } else if (name && _compare(name, field) || field[0] === name && name[0] && util.get(val, field.concat().shift())) {
                      fr = false;
                    } else if (path && (_compare(path.concat(field), fromPath) || _compare(field, fromPath))) {
                      fr = false;
                    } else if (select && (val[field[0]]) && select._ancestor && select._ancestor(from)) {
                      // console.log(val, field);
                      pass = true
                    } else if( t.__checkKeys__ ) {
                      // console.log('lets checkj the keys!')
                      // console.log( field, name, val, path, select, val[field[0]], from, this )
                      for( var key$ in t.__checkKeys__ ) {
                        if( field === t.__checkKeys__[key$] || field[0] === t.__checkKeys__[key$] ) {
                          // console.log('maybe??!!@#!@', i, t.__checkKeys__[key$])
                          pass = true
                        }
                      }

                    }
                    // console.log(val, field[0], from);
                  }
                }
              }
              // pass = true;
              // console.log('PASS>>>>>>>>>?'.magenta.inverse, pass ? 'OK!'.green.inverse : 'NO!'.red.inverse  
              //   , 'val:'.blue, val
              //   , 'obj._path:'.blue, obj && obj._path
              //   , 'field:'.blue, field
              //   , 'fromPath:'.blue, fromPath
              //   , 'from:'.blue, from
              //   , 'select'.blue, select
              //   )

              // if(! pass && )

              // pass = true

              //|| remove 

              if (pass || remove || (instances || remove || select !== void 0) && ( !fr || remove === 1)) {

                // console.log('updating!'.cyan.inverse, i, val, instances, remove, select, fr, from)
                // debugger
                //stamp meegeven????
                // console.log( 'FROM!!!!!'.green.inverse, from )
                // console.l
                t[i]._update(val, false, from, remove, added, oldval, !instances, t);
                return true;
              }
            };
          //----------------------------------------------------
            //add advanced models (like on website)
            //not tested and still pretty broken
           var parser = function() {
            if (this._d) {
              var t = this, a
              //if added or first run
              t.model.val //set _caller
              // if (model.field) console.log('????', this.field, model.field)

              if (model.field) a = util.get(t._d, model.field.val)
              if (model._val) a = model._val.call(t, a || t._d) || a
              if (a && t._d !== a) {
                model.parsing = true
                if(model.field) this.modelParsed = model.field.val
                this._dSet(a)
                model.parsing = false
              }
            }
          }
          parser.call(t)
          if (instances) t.eachInstance(parser, 'model')
          //----------------------------------------------------

          //----------------------------------------------------
          if (f && (instances || t._d)) {
            for (var i in f) {
              if (!f[i].__t) {
                for (var j = 0, l = f[i].length; j < l; j++) {
                  if (method(i, f[i][j])) {
                    break;
                  }
                }
              } else {
                method(i, f[i]);
              }
            }
          }
          //----------------------------------------------------

         if(this.model.complete) this.model.complete._val.call(this,data)

        }
      },
      _dSet: function(val, dfrom) {


        // if(val) {
        //   console.log('_Dset'.cyan.inverse, val._path, dfrom)
        // }
        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        if(this.model._flag && this.model._flag.defer  && !this.__processing) {
          this.__pFlag = [ val, dfrom ]
          return
        }

        //dfrom moet niet nog een subscribe doen! -- als het goed is is zn parent al subscribed

        if (this._d && this._d.__t) this._d.removeListener(true, this)
        this._d = val
        if (dfrom) this._dfrom = true
        this._dListen()



        return val;
      },
      _dListen: function() {

          // console.log('HEEEEEE', this.model)

        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        //hier gaan we s fftjes werken met each

        // this._dfrom = true;
        var _this

        if (this.model && this._d && this._d instanceof vObject) 
        { //this model maybe not nessecary?

          // console.log('----->'.cyan.inverse, this._d )

          this._d.addListener([this._dUpdate, this])

          _this = this
          
          //hier filteren op cloudData --- ook werken vanuit remove!!!
            //never do for cloud data
         
          if( !this._d.cloud )
          {
            this._d.each(
              function() { 
                _this.__checkKeys__ = true

                if(this.__t === 4 ) this.addListener([ _this._dUpdate, _this, '$ndata', this ]) 
              }
            )
          }
          //eventueel .val gebruiken voor Values *awesjume!
          //eventueel hier dingen adden aan model

        } 
        else if( this.model && this._d ) 
        {
          for( var key in this._d ) 
          {
            if(!this.__checkKeys__ || this.__checkKeys__ === true) this.__checkKeys__ = []
            if( this._d[key] instanceof vObject )
            {
              if(!this.__checkKeys__.push) {
                console.error('xxxxxx', this, this.__checkKeys__, key, this._d)
                debugger
              }
              this.__checkKeys__.push( key )
              this._d[key].addListener([ this._dUpdate, this, '$ndata', key ])
            }
          }

        }
      },
      updateData: function(instances) {

        if(this.model._flag && this.model._flag.defer && !this.__processing) {
          // console.log('oo2')
          this.__pFlagU = [ instances ]
          this.model._update()
          return
        }
        // console.log('!DOIT updateData'.cyan.inverse)

        this._dUpdate(this._d, void 0, false, false, false, false, false, instances)
      }
    },
    extend = function(i) {
      base.extend({
        name: i,
        type: false,
        value: (extensions && extensions[i]) ? function() {
          methods[i].apply(this, arguments);
          extensions[i].apply(this, arguments);
        } : methods[i]
      });
    };
  for (var i in methods) {
    extend(i)
  }
  base.extend({
    name: 'model',
    cache: false,
    set: function(val) {

      if(this.__pFlag || this.__pFlagU) {
        /*
        TODO: test defer better!!!
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        */
        this.__processing = true
        this.model.parsing = false
        if(this.__pFlag) {
          this._dSet.apply(this,this.__pFlag)
        }
        //subscribe helemaal fucked met field erbij
        if(this.__pFlagU) {
          this.updateData.apply(this,this.__pFlagU)
        }
        this.__pFlagU = null
        this.__pFlag = null
        this.__processing = null
      }

      if(val.field && val.field.val !== this.modelParsed) {
        var a = this.modelParsed && this.modelParsed.split('.')
          , parent
        this.modelParsed = null
        if(this._d) {
          parent = this._d
          if(a) {
            for(var i = a.length-1; i >=0 ; i--) {
              parent = parent._parent
            }
            if(parent) {
              this._dSet(parent)
              this.updateData(true)
            }
          } else {
            this.updateData(true)
          }
        }
        this.modelParsed = null
      }
    },
    remove: function() {
      if( this._d )
      {
        if ( this._d.__t )  
        {
          this._d.removeListener( void 0, this )

          if( !this._d.cloud )
          {
            var _this = this
            this._d.each(
              function() { 
                // _this.__checkKeys__ = true
                if(this.__t === 4 ) this.removeListener( void 0, _this ) 
              }
            )
          }

        }
        else if( this.__checkKeys__) 
        {
          for( var key$ in this.__checkKeys__ ) 
          {
            if( this._d[this.__checkKeys__[key$]] instanceof vObject )
            {
              this._d[this.__checkKeys__[key$]].removeListener( void 0, this )
            }
          }
        }
      }
    }
    // parent: function(parent) {
    //   if( parent.data && (!parent.parent || parent.parent.data!==parent.data) ) {

    //     console.error('WTF?')

    //     this.data = parent.data
    //   }
    // }
  }, {
    name: 'data',
    type: false,
    set: function(val) {
        // console.log('?',val)
      if( this._d === val ) return

      // if(!this.model) this.model = {} //dit met het nooit setten van fmodel scheel op show al 3/9 subscriptions
      //nu nog shared subs maken -- 'shows' (ook meteen process) en dan word thet als het goed is nog een stuk minder
    
      // this.model = {} //pas op met deze
      // console.log('?2')

      if( this.model._flag && this.model._flag.defer ) {
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        // console.log('!@#!@#!@# OOOO'.red)
        return
      }

      // console.error('!!!!!MODEL -- dit moet zoveel mogelijk gereduced', this.model)

      this.model.parsing = false
      this._dSet(val)

      //subscribe helemaal fucked met field erbij
      this.updateData(true)

    },
    get: function() {
      return this._d
    }
  })
})
},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value/flags/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/data.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/conditions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var data = require('./'),
  cnt = 0,
  handleTest = module.exports = function(test, subsObj) {
    // console.error('handleTest!', test)
    if (test instanceof Object) {
      var keys = Object.keys(test);
      if (keys.length === 1) {
        var key = keys[0]
          , valcheck = handleField(key, test[key], subsObj)
          
        return subsObj._check = function(doc){
          // console.log('TESTING', test, doc && doc.raw)
          // console.log('checking for key', key)
          var val = getValue(doc)
          return valcheck(val)
        }
      } else {
        var list = [],
          key;
        for (var k = 0, l = keys.length; k < l; k++) {
          key = keys[k];
          list.push(handleField(key, test[key], subsObj));
        }
        return subsObj._check = makeAND(list);
      }
    } else {
      return subsObj._check = function(doc) {
        return getValue(doc) === test;
      }
    }
  }

function handleField(key, value, subsObj) {
  // console.warn('handleField [', key, '] value', value)
  var check;
  switch (key) {
    case '$not':
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj);
        check = function(doc) {
          return follow(doc) === false;
        };
      } else {
        check = function(doc) {
          return doc !== value;
        };
      }
      break;
    case '$ne':
      check = function(doc) {
        return doc !== value;
      };
      break;
    case '$and':
      var list = makeList(value, subsObj);
      check = makeAND(list);
      break;
    case '$nand':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc) === false) return true;
        }
        return false;
      };
      break;
    case '$or':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return true;
        }
        return false;
      };
      break;
    case '$nor':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return false;
        }
        return true;
      };
      break;
    case '$every':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (!follow(this)) return !(result = false);
          });
          return result;
        } else {
          return false;
        }
      };
      break;
    case '$nevery':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = false;
          doc.each(function() {
            if (!follow(this)) return result = true;
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$':
    case '$some':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj.$);
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (follow(this)) return found = true;
            });
            return found || false;
          }
          return false;
        };
      } else {
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (this === value) return found = true;
            });
            return found || false;
          }
          return false;
        };
        subsObj.$._check = function(doc) {
          return doc === value;
        };
      }
      break;
    case '$nsome':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (follow(this)) return !(result = false);
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$lt':
      check = function(doc) {
        // console.log('burk lt', doc, value)
        return doc < value;
      };
      break;
    case '$lte':
      check = function(doc) {
        return doc <= value;
      };
      break;
    case '$gt':
      check = function(doc) {
        return doc > value;
      };
      break;
    case '$gte':
      check = function(doc) {
        return doc >= value;
      };
      break;
    case '$contains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return regex.test(doc);
      };
      break;
    case '$ncontains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return !regex.test(doc);
      };
      break;
    case '$containsall':
      break;
    case '$ncontainsall':
      break;
    case '$has':
      check = function(doc) {
        return doc && doc[value] !== void 0;
      };
      break;
    case '$nhas':
      check = function(doc) {
        return !doc || doc[value] === void 0;
      };
      break;
    case '$exists':
      check = function(doc) {
        return (doc !== void 0 && doc !== null) === value;
      };
      break;
    case '$in':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return true;
        }
        return false;
      };
      break;
    case '$nin':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return false;
        }
        return true;
      };
      break;
    case '$regex':
      check = function(doc) {
        return value.test(doc);
      }
      break;
    default:
      if (value instanceof Object) {
        var dsubsObj = subsObj[key];

        if (dsubsObj) {
          // console.log('already made that dsubsObj with key', key);
          // dsubsObj._up = subsObj
        } else {
          subsObj.set(key, {});
          dsubsObj = subsObj[key];
        }
        var follow = handleTest(value, dsubsObj);

        check = function(doc) {
          // console.log('TESTING: check OBJECT', doc && doc.raw || doc, 'for field', key)
          doc = getField(doc, key)

          // console.log('wups', doc && doc.raw || doc)
          return follow(doc);
        };
      } else {
        check = function(doc) {
          doc = getField(doc, key)
          
          // doc = getValue(doc)
          // console.log('TESTING: check VALUE', doc && doc.raw || doc, value, doc === value)
          return doc === value;
        };
        subsObj.set(key, {});
        subsObj[key]._check = check
        // subsObj[key] = {
        //   _up: subsObj,
        //   _check: function(doc) {
        //     return doc === value;
        //   }
        // };
      }

  }
  return subsObj ? subsObj._check = check : check;
}

function makeList(arr, subsObj) {
  var list = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    list.push(handleTest(arr[i], subsObj));
  }
  return list;
}

function makeAND(list, subsObj) {
  return function(doc) {
    var val = getValue(doc);
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i](val) === false) return false;
    }
    return true;
  };
}

function getValue(thing){
  var val = thing && thing.from && thing.from.val
  return val !== void 0 ? val : thing
  
}
function getField(thing, field){
  // console.error('getField field', field, 'from', thing && thing.raw || thing)
  thing = getValue(thing)
  return thing ? getValue(thing[field]) : void 0
}
},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('vigour-js'),
  object = require('vigour-js/object'),
  util = require('vigour-js/util');

module.exports = exports = V.Data = object.new();
exports.prototype._blacklist.push('__sub','__block');
util.define(exports, '_hook', function(val, obj) {
  if (obj.subscription) {
    this.__sub = obj.subscription;
    delete obj.subscription;
  }
  if(obj.block) {
    this.__block = true
    delete obj.block
  }
});


},{"vigour-js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var conditions = require('./conditions')
  , utilHash = require('../util/hash')
  , VObject = require('../object')
  , util = require('../util')

/**
 * Selection
 * Class extention for selection / filtering functionality
 * @Class
 */

exports.SubsObj = VObject.new()
exports.SubsObj.prototype._blacklist.push( '_root'
                                         , '_check'
                                         , '_sort'
                                         , '_uid'
                                         )

exports.extend = util.extend(function(base){

  base.prototype._blacklist.push( '_filter'
                                , '_uid'
                                , '_hash'
                                , '_indexCache'
                                , '_subscnt'
                                )

  var _update = base.prototype._update
    , _hook = base.prototype._hook
    , _remove = base.prototype.remove

  util.define( base
    , 'remove', function() {
        var l
        if(this._filter && (l = this.length)){
          for(var i = 0; i < l; i++)
            delete this[i]
        }
        return _remove.apply(this, arguments)
      }
    , 'filter', {
        get: function() {
          return this._filter
        },
        set: function(val) {
          // console.log('new filter \n from --->', this._filter, '\n to ---->'
          //            , val
          //            )
          this._filter = val //moet ook werken als data nog geen selection is
          this._build(undefined, true)
          _update.call( this, void 0, this.stamp(), void 0, false
                      , false, void 0
                      )
        }
      }
    , '_hook', function(val, filter) {
        if (_hook) {
          _hook.call(this, val, filter)
        }
        if (!util.empty(filter) && val) {
          var selection = this
          selection._subscnt = 0
          selection._filter = filter

          selection._hash = utilHash(val._path + JSON.stringify(
            [ filter.condition
            , filter.range
            , filter.sort
            ])
          )
          //!only nessecary serverside!
          if (!selection._uid) selection._uid = selection._hash
        };
      }
    , '_build', function(val, noupdate) {
        var selection = this
        
        if (!val) val = selection._val
        if(!val) return
        if (selection.length) selection._clear() 

        var list = []
          , itemsHandler = this._itemsHandler
          , filter = selection._filter
          , subsObj = filter.subsObj || new exports.SubsObj({}, selection)
          , stamp = this.stamp()
          , sort, item

        if (val.__t === 4 && !val._filter) {
          val = val.from;
        }

        if (filter.sort) {
          if (typeof filter.sort === 'string') {
            filter.sort = {
              field: filter.sort
            }
          }
          sort = filter.sort
          if (!sort.fn) {
            if (!sort.type) sort.type = 'string'
            sort.fn = sortMakers[sort.type](sort)
          }
          subsObj.path(sort.field.split('.'), {}).set('_sort', true)
        }
        // console.log('building?!')
        if (filter.condition) {
          // console.log('found condition', filter.condition)
          var pcnt = 0
            , rcnt = 0
          var check = filter.check 
                 || ( filter.check = conditions( filter.condition
                                               , subsObj
                                               )
                    )
          filter.subsObj = subsObj
          val.each(function(f) {
            item = this
            if (itemsHandler) itemsHandler(item, subsObj, selection)
            if (check(item)) {
              pcnt++
              list.push(item)
            } else if (selection._has(item) !== void 0) {
              // console.log('-------- > removed from selection by condition:'
              //             , item.raw
              //             )
              unstoreIndex(item, selection)
              if(!noupdate){
                _update.call(selection, item, stamp, selection, item, false, null)
              }
              rcnt++
            } else { 
              rcnt++
            }
          })
          // console.log('ran condition: passed:', pcnt, 'rejects:', rcnt)
        } else {
          val.each(function() {
            if (itemsHandler) itemsHandler(this, subsObj, selection)
            list.push(this)
          })
        }

        filter.subsObj = subsObj

        if (sort && list.length > 1) {
          list.sort(filter.sort.fn)
        }

        var i, item

        var range = filter.range
        if (range) {
          if (!(range instanceof Array)) {
            range = filter.range = [0, filter.range]
          }
          if (list.length) {
            var newlist = list.splice(range[0], range[1])
            for (i = list.length; item = list[--i];) {
              if(selection._has(item) !== void 0){
                unstoreIndex(item, selection)
                // if(!noupdate){
                //   _update.call(selection, item, stamp, selection, item, false
                //               , null
                //               )
                // }
                
              }
            }
            list = newlist
          }
        }

        for (var i = list.length, item; item = list[--i];) {
          selection[i] = item
          var isnew = selection._has(item) === void 0
          storeIndex(item, selection, i)
          // if (isnew) {
          //   if(!noupdate){
          //     console.log('doing update wickeds')
          //     _update.call(selection, item, stamp, selection, false, item, null)  
          //   }
          // }
        }
        selection.length = list.length
      }
    , '_update', function(val, stamp, from, remove, added, oldval) {

        if (this._filter) {
           // if(window.here) console.log('hups _update on selection!')

          var selection = this
            , upath = selection.updatePath

          if (upath[0] !== void 0) {
            var shortpath = upath.length === 1
              , itemremove = shortpath && remove
              , item = itemremove ? selection._lfrom : selection.val[upath[0]]
              , relevant

            if (selection._val._filter) {
              if (selection._val._has(item) === void 0) {
                if (selection._has(item) !== void 0) {
                  selection._checkItem(item, false, val, stamp)
                }
                return
              }
            }
            var hint = itemremove ? false : (shortpath && added) ? void 0 : upath

            if (selection._checkItem(item, hint, val, stamp) === true) {
              return _update.apply(selection, arguments) 
            }
          } else {
            // console.log('hit on selection itself?!')
            if (!from) {
              // console.log('\n>>>>>> hit on selection itself (V.Data)')
              if (remove) {
                if (selection.length) selection._clear()              
              }else{
                selection._build()
              }
            }
            return _update.apply(this, arguments)
          }
        } else {
           // if(window.here) console.log('hups _update on selection!',this)
           // console.log('SELECT', this, arguments, this._path)
          return _update.apply(this, arguments)
        }
      }
    , '_has', function(item) {
        var indexCache = item._indexCache
          , uid = this._uid
          , ic

        if (indexCache && uid && (ic = indexCache[uid])) {
          return ic[0]
        }
      }
    , '_clear', function() {
        var self = this
        self.each(function(f) {
          self[f] = void 0
          delete self[f]
        })
        self.length = 0
      }
    , '_checkItem', function(item, hint, val, stamp) {
        if(!item) { return }
        // console.log('_checkItem!', item.raw, hint)
        var selection = this
          , from = item
          , filter = selection._filter
          , sort = filter.sort
          , range = filter.range
          , ranged = range && !(  range[0] === 0 
                               && range[1] >= selection._val.length 
                               || selection.length < range[1] - range[0]
                               )
          , removed = hint === false || item._removed
          , added, index, isin
          , result = isin = (index = selection._has(item)) !== void 0

        var check = filter.check
          , pass = removed 
                   ? false 
                   : (!ranged && hint === 1) 
                     ? isin 
                     : !check || check(item)

        // console.log('================ checkitem in', selection._path)
        // console.log('itemwex', item._val && item._val.raw)
        // console.log('isin', isin, 'pass', pass, 'result', result)
        // console.log('---------- checked item', pass)
        // console.log('removed?', removed)
        // console.log('ranged? (pass == already in)', (!ranged && hint === 1), isin)
        // console.log('ok time for checking', check)
        // console.log('conditions', filter.condition)
        // console.log('check?', check && check(item))
        // console.log('----------')
        
        if (isin !== pass) {
          if (isin) {
            result = 1
            unstoreIndex(item, selection)
            removed = item
            var mark
            while (mark = selection[++index]) {
              selection[index - 1] = mark
              storeIndex(mark, selection, index - 1)
            }

            var end = index - 1
            selection[end] = null
            delete selection[end]

            var replacement
            if (ranged) {
              if (sort) {
                selection._val.each(function() {
                  if (  selection._has(this) === void 0 
                     && (!selection[end] || sort.fn(this, selection[end]) < 0) 
                     && (!check || check(this))
                     ) {
                    replacement = selection[end] = this
                  }
                })
              } else {
                selection._val.each(function() {
                  if ( selection._has(this) === void 0 
                     && (!check || check(this))
                     ) {
                    return replacement = selection[end] = this
                  }
                })
              }
            }
            if (!replacement) {
              selection.length--
            } else {
              storeIndex(replacement, selection, index - 1)
              added = replacement
            }
          } else {
            var newindex
            if (sort) {
              var sortfn = sort.fn
              if (selection.length) {
                selection.each(function(f) {
                  if (sortfn(item, this) < 0) {
                    return newindex = f
                  }
                })
              }
              if (newindex !== void 0) {
                result = 1
                newindex = Number(newindex)
                storeIndex(item, selection, newindex)
                added = item
                if (ranged) {
                  removed = selection[selection.length - 1]
                  unstoreIndex(removed, selection)
                } else {
                  this.length++
                }
                var index = selection.length - 2
                while (index >= newindex) {
                  storeIndex(selection[index], selection, index + 1)
                  selection[index + 1] = selection[index--]
                }
                selection[newindex] = item
              } else if (!ranged) {
                result = 1
                newindex = selection.length++
                selection[newindex] = item
                storeIndex(item, selection, newindex)
                added = item
              }
            } else if (!ranged) {
              result = 1
              newindex = selection.length++
              selection[newindex] = item
              storeIndex(item, selection, newindex)
              added = item
            }
          }
        } else if (isin && sort) {
                      console.log('???', sort, sort.field, hint)

          // console.log('isin + sort! resort?')
          if (hint && hint.length && sort.field) {
            if (~sort.field.indexOf('.')) {
              var sortpath = sort.field.split('.')
              if (!util.compareArrays(hint.slice(1), sortpath)) {
                return result
              }
            } else {
              if (hint[1] !== sort.field) return result
            }
          }

          console.log('?')

          var newindex
          selection.each(function(f) {
            if (f != index) {
              var s = sort.fn(item, this)
              if (s === -1) {
                if (f == index + 1) return true
                newindex = f < index ? f : f - 1
                return true
              } else if (f >= index + 1 && s === 0) {
                return true
              } else if (f > index) {
                newindex = f
              }
            }
          });
          // console.log('newindex', newindex)
          if (newindex !== void 0) {
            result = 1
            var tmp
            if (index > newindex) {
              while (index > newindex) {
                tmp = selection[index] = selection[--index]
                if (tmp) storeIndex(tmp, selection, index + 1)
              }
            } else {
              while (index < newindex) {
                tmp = selection[index] = selection[++index]
                if (tmp) storeIndex(tmp, selection, index - 1)
              }
            }
            selection[newindex] = item
          }

          var end = selection.length - 1

          if (  ranged 
             && (newindex == end || newindex === void 0 
             && index == end)
             ) {
            var replaced
            selection._val.each(function() {
              if (  selection._has(this) === void 0 
                 && sort.fn(this, item) === -1 
                 && (!check || check(this))
                 ) {
                if (!replaced) replaced = item
                selection[end] = item = this
              }
            })
            storeIndex(item, selection, end)
            if (replaced) {
              unstoreIndex(replaced, selection)
              removed = replaced
              added = item
              result = 1
            }
          } else if (newindex !== void 0) {
            storeIndex(item, selection, Number(newindex))
          }

        }
        if (result === 1) {
          // console.log('update from _checkItem!')
          selection.__update(val, stamp, from, removed, added)
        }
        return result
      }
    )

})

var storeIndex = exports.storeIndex = function(item, selection, index) {
  // console.log('storeIndex! item', item._name, '@', index)
  var indexCache = item._indexCache
    , ic
  if (indexCache) {
    ic = indexCache[selection._uid]
    if (ic) {
      ic[1] = ic[0]
      ic[0] = index
    } else {
      indexCache[selection._uid] = [index]
    }
  } else {
    item._indexCache = {}
    item._indexCache[selection._uid] = [index]
  }
}

var unstoreIndex = exports.unstoreIndex = function(item, selection) {
  var indexCache = item._indexCache
  if (indexCache) {
    var ic = indexCache[selection._uid]
    ic[1] = ic[0]
    ic[0] = void 0
  }
}

var sortMakers = {
  number: function(sort) {
    var field = sort.field
    return function(a, b) {
      var va = a[field] && a[field].val
        , vb = b[field] && b[field].val
      if (va === void 0 || vb === void 0) {
        return va === vb 
               ? 0 
               : va === void 0 
                 ? 1 
                 : -1
      }
      return sort.order 
             ? (va - vb) * -1 
             : va - vb
    }
  },
  string: function(sort) {
    var field = sort.field
    if (~field.indexOf('.')) {
      var path = field.split('.')
      return function(a, b) {
        a = getDotFieldVal(a, path)
        b = getDotFieldVal(b, path)
        if (a === void 0 || b === void 0) {
          return a === b 
                 ? 0 
                 : a === void 0 
                   ? 1 
                   : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    } else {
      return function(a, b) {
        a = getFieldVal(a, field)
        b = getFieldVal(b, field)
        var weakA = a === void 0 || a === null
          , weakB = b === void 0 || b === null
        if (weakA || weakB) {
          return a === b ? 0 : weakA ? 1 : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    }
  }
}

function getFieldVal(obj, field) {
  var v = obj.val
  return v && v[field] && v[field].val
}

function getDotFieldVal(obj, field) {
  var v = obj.path(field)
  return v && v.val
}

function putSort(path) {
  var obj = part = {}
  for (var i = 0, l = path.length; i < l; i++) {
    part = part[path[i]] = {
      _up: part
    }
  }
  part._sort = true
  return obj
}

},{"../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","./conditions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/conditions.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js":[function(require,module,exports){
//V only used as a reference now...

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/colors/colors.js":[function(require,module,exports){
/*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var isHeadless = false;

if (typeof module !== 'undefined') {
  isHeadless = true;
}

if (!isHeadless) {
  var exports = {};
  var module = {};
  var colors = exports;
  exports.mode = "browser";
} else {
  exports.mode = "console";
}

//
// Prototypes the string object to have additional method calls that add terminal colors
//
var addProperty = function (color, func) {
  exports[color] = function (str) {
    return func.apply(str);
  };
  String.prototype.__defineGetter__(color, func);
};

function stylize(str, style) {

  var styles;

  if (exports.mode === 'console') {
    styles = {
      //styles
      'bold'      : ['\x1B[1m',  '\x1B[22m'],
      'italic'    : ['\x1B[3m',  '\x1B[23m'],
      'underline' : ['\x1B[4m',  '\x1B[24m'],
      'inverse'   : ['\x1B[7m',  '\x1B[27m'],
      'strikethrough' : ['\x1B[9m',  '\x1B[29m'],
      //text colors
      //grayscale
      'white'     : ['\x1B[37m', '\x1B[39m'],
      'grey'      : ['\x1B[90m', '\x1B[39m'],
      'black'     : ['\x1B[30m', '\x1B[39m'],
      //colors
      'blue'      : ['\x1B[34m', '\x1B[39m'],
      'cyan'      : ['\x1B[36m', '\x1B[39m'],
      'green'     : ['\x1B[32m', '\x1B[39m'],
      'magenta'   : ['\x1B[35m', '\x1B[39m'],
      'red'       : ['\x1B[31m', '\x1B[39m'],
      'yellow'    : ['\x1B[33m', '\x1B[39m'],
      //background colors
      //grayscale
      'whiteBG'     : ['\x1B[47m', '\x1B[49m'],
      'greyBG'      : ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG'     : ['\x1B[40m', '\x1B[49m'],
      //colors
      'blueBG'      : ['\x1B[44m', '\x1B[49m'],
      'cyanBG'      : ['\x1B[46m', '\x1B[49m'],
      'greenBG'     : ['\x1B[42m', '\x1B[49m'],
      'magentaBG'   : ['\x1B[45m', '\x1B[49m'],
      'redBG'       : ['\x1B[41m', '\x1B[49m'],
      'yellowBG'    : ['\x1B[43m', '\x1B[49m']
    };
  } else if (exports.mode === 'browser') {
    styles = {
      //styles
      'bold'      : ['<b>',  '</b>'],
      'italic'    : ['<i>',  '</i>'],
      'underline' : ['<u>',  '</u>'],
      'inverse'   : ['<span style="background-color:black;color:white;">',  '</span>'],
      'strikethrough' : ['<del>',  '</del>'],
      //text colors
      //grayscale
      'white'     : ['<span style="color:white;">',   '</span>'],
      'grey'      : ['<span style="color:gray;">',    '</span>'],
      'black'     : ['<span style="color:black;">',   '</span>'],
      //colors
      'blue'      : ['<span style="color:blue;">',    '</span>'],
      'cyan'      : ['<span style="color:cyan;">',    '</span>'],
      'green'     : ['<span style="color:green;">',   '</span>'],
      'magenta'   : ['<span style="color:magenta;">', '</span>'],
      'red'       : ['<span style="color:red;">',     '</span>'],
      'yellow'    : ['<span style="color:yellow;">',  '</span>'],
      //background colors
      //grayscale
      'whiteBG'     : ['<span style="background-color:white;">',   '</span>'],
      'greyBG'      : ['<span style="background-color:gray;">',    '</span>'],
      'blackBG'     : ['<span style="background-color:black;">',   '</span>'],
      //colors
      'blueBG'      : ['<span style="background-color:blue;">',    '</span>'],
      'cyanBG'      : ['<span style="background-color:cyan;">',    '</span>'],
      'greenBG'     : ['<span style="background-color:green;">',   '</span>'],
      'magentaBG'   : ['<span style="background-color:magenta;">', '</span>'],
      'redBG'       : ['<span style="background-color:red;">',     '</span>'],
      'yellowBG'    : ['<span style="background-color:yellow;">',  '</span>']
    };
  } else if (exports.mode === 'none') {
    return str + '';
  } else {
    console.log('unsupported mode, try "browser", "console" or "none"');
  }
  return styles[style][0] + str + styles[style][1];
}

function applyTheme(theme) {

  //
  // Remark: This is a list of methods that exist
  // on String that you should not overwrite.
  //
  var stringPrototypeBlacklist = [
    '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
    'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
    'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
  ];

  Object.keys(theme).forEach(function (prop) {
    if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
      console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
    }
    else {
      if (typeof(theme[prop]) === 'string') {
        addProperty(prop, function () {
          return exports[theme[prop]](this);
        });
      }
      else {
        addProperty(prop, function () {
          var ret = this;
          for (var t = 0; t < theme[prop].length; t++) {
            ret = exports[theme[prop][t]](ret);
          }
          return ret;
        });
      }
    }
  });
}


//
// Iterate through all default styles and colors
//
var x = ['bold', 'underline', 'strikethrough', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta', 'greyBG', 'blackBG', 'yellowBG', 'redBG', 'greenBG', 'blueBG', 'whiteBG', 'cyanBG', 'magentaBG'];
x.forEach(function (style) {

  // __defineGetter__ at the least works in more browsers
  // http://robertnyman.com/javascript/javascript-getters-setters.html
  // Object.defineProperty only works in Chrome
  addProperty(style, function () {
    return stylize(this, style);
  });
});

function sequencer(map) {
  return function () {
    if (!isHeadless) {
      return this.replace(/( )/, '$1');
    }
    var exploded = this.split(""), i = 0;
    exploded = exploded.map(map);
    return exploded.join("");
  };
}

var rainbowMap = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
    }
  };
})();

exports.themes = {};

exports.addSequencer = function (name, map) {
  addProperty(name, sequencer(map));
};

exports.addSequencer('rainbow', rainbowMap);
exports.addSequencer('zebra', function (letter, i, exploded) {
  return i % 2 === 0 ? letter : letter.inverse;
});

exports.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      exports.themes[theme] = require(theme);
      applyTheme(exports.themes[theme]);
      return exports.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};


addProperty('stripColors', function () {
  return ("" + this).replace(/\x1B\[\d+m/g, '');
});

// please no
function zalgo(text, options) {
  var soul = {
    "up" : [
      '̍', '̎', '̄', '̅',
      '̿', '̑', '̆', '̐',
      '͒', '͗', '͑', '̇',
      '̈', '̊', '͂', '̓',
      '̈', '͊', '͋', '͌',
      '̃', '̂', '̌', '͐',
      '̀', '́', '̋', '̏',
      '̒', '̓', '̔', '̽',
      '̉', 'ͣ', 'ͤ', 'ͥ',
      'ͦ', 'ͧ', 'ͨ', 'ͩ',
      'ͪ', 'ͫ', 'ͬ', 'ͭ',
      'ͮ', 'ͯ', '̾', '͛',
      '͆', '̚'
    ],
    "down" : [
      '̖', '̗', '̘', '̙',
      '̜', '̝', '̞', '̟',
      '̠', '̤', '̥', '̦',
      '̩', '̪', '̫', '̬',
      '̭', '̮', '̯', '̰',
      '̱', '̲', '̳', '̹',
      '̺', '̻', '̼', 'ͅ',
      '͇', '͈', '͉', '͍',
      '͎', '͓', '͔', '͕',
      '͖', '͙', '͚', '̣'
    ],
    "mid" : [
      '̕', '̛', '̀', '́',
      '͘', '̡', '̢', '̧',
      '̨', '̴', '̵', '̶',
      '͜', '͝', '͞',
      '͟', '͠', '͢', '̸',
      '̷', '͡', ' ҉'
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] = options["up"] || true;
    options["mid"] = options["mid"] || true;
    options["down"] = options["down"] || true;
    options["size"] = options["size"] || "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.min = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.min = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  return heComes(text);
}


// don't summon zalgo
addProperty('zalgo', function () {
  return zalgo(this);
});

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/index.js":[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/index.js":[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/socket.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/socket.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? '443' : '80';
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    function close() {
      self.onClose('forced close');
      debug('socket closing - telling transport to close');
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener('upgrade', cleanupAndClose);
      self.removeListener('upgradeError', cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once('upgrade', cleanupAndClose);
      self.once('upgradeError', cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","./transports":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","indexof":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js","parsejson":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parsejson/index.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","parseuri":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseuri/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/index.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling-jsonp":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-jsonp.js","./polling-xhr":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-xhr.js","./websocket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/websocket.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-jsonp.js":[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-xhr.js":[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/websocket.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = require('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","ws":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/ws/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js":[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js":[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js":[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/debug.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/debug.js":[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/node_modules/ms/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/node_modules/ms/index.js":[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./keys":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/keys.js","after":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/after/index.js","arraybuffer.slice":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/arraybuffer.slice/index.js","base64-arraybuffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js","blob":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/blob/index.js","has-binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/index.js","utf8":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/utf8/utf8.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/keys.js":[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/after/index.js":[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/arraybuffer.slice/index.js":[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/blob/index.js":[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob(['hi']);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/index.js":[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/utf8/utf8.js":[function(require,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return 'U+' + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = require('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/node_modules/global/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/node_modules/global/index.js":[function(require,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js":[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parsejson/index.js":[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js":[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseuri/index.js":[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/ws/lib/browser.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./lib/core.js')
require('./lib/done.js')
require('./lib/es6-extensions.js')
require('./lib/node-extensions.js')
},{"./lib/core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","./lib/done.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/done.js","./lib/es6-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/es6-extensions.js","./lib/node-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/node-extensions.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js":[function(require,module,exports){
'use strict';

var asap = require('asap')

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}

},{"asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/done.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}
},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/es6-extensions.js":[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Promise.prototype

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/node-extensions.js":[function(require,module,exports){
'use strict';

//This file contains then/promise specific extensions that are only useful for node.js interop

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      var res = fn.apply(self, args)
      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
        resolve(res)
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    var ctx = this
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback.call(ctx, ex)
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value)
    })
  }, function (err) {
    asap(function () {
      callback.call(ctx, err)
    })
  })
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js":[function(require,module,exports){
(function (process){

// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


}).call(this,require('_process'))

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/index.js":[function(require,module,exports){

module.exports = require('./lib/');

},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/manager.js","./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js","./url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/manager.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var object = require('object-component');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = 'closed';
  this.engine && this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js","./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js","./url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js","backo2":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/backo2/index.js","component-bind":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","engine.io-client":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/index.js","indexof":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/indexof/index.js","object-component":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/object-component/index.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js":[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

},{"./on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js","component-bind":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","has-binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/index.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js","to-array":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/to-array/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js":[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","parseuri":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/parseuri/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/backo2/index.js":[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js":[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js":[function(require,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/index.js":[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/node_modules/isarray/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/indexof/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/object-component/index.js":[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/parseuri/index.js":[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/binary.js":[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./is-buffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js","isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/binary.js","./is-buffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js","json3":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/json3/lib/json3.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js":[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/json3/lib/json3.js":[function(require,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/to-array/index.js":[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/array.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  object = require('./');

util.define(object,
  /**
   * V.Object's equivalent to Array.push()
   * @method push
   * @param  {Arguments}  The item(s) to add to the array
   * @return {Number}     The new length of the array
   */
  'push', function() {
    if (this.__t === 1) {
      if (this.length === void 0) {
        this.length = 0;
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        this._push(arguments[i]);
      }
      return this.length;
    }
  },
  '_push', function(val, vobj, stamp, noupdate, from) {
    //ame, val, vobj, stamp, noupdate, from
    this.length++;
    this.set((this.length - 1), val, vobj, stamp, noupdate, from);
    return this[this.length - 1];
  },
  /**
   * V.Object's equivalent to Array.pop()
   * @method pop
   * @return {*}  The removed array item
   */
  'pop', function() {
    if (this.__t === 1) {
      var l = this.length
      if(l !== 0){
        t = this[l - 1];
        this.length--;
        t.remove();
      }
      // return t; //pretty weird since this object always has value null;
    }
  },
  /**
   * V.Object's equivalent to Array.splice()
   * @method splice
   * @param  {Number}    index   An integer that specifies at what position to add/remove items, Use negative values to specify the position from the end of the array
   * @param  {Number}    howmany The number of items to be removed. If set to 0, no items will be removed
   * @param  {Arguments}         The new item(s) to be added to the array
   * @return {Array}             A new array containing the removed items, if any
   */
  'splice', function(index, howmany) { //can become shorter;
    if (index > -1 && this.__t === 1) { //how many and -i are ignored
      for (var i = 0, l = this.length, shift; i < l; i++) {
        if (shift) {
          if (i === l - 1) {
            // this.length--;
            this[i] = null;
          } else {
            this[i] = this[i + 1];
            this[i]._name = i;
          }
        } else {
          if (i === index) {
            if (i === l - 1) {
              this.pop();
            } else {
              shift = true;
              this.length--;
              this[i].remove();
              this[i] = this[i + 1];
              this[i]._name = i;
            }
          }
        }
      }
    }
  },
  /**
   * Adds value to array if it is not contained in array, executes handler on encountering val in array
   * @method include
   * @param  {*}         val       Value to add
   * @param  {Function}  [handler] Function to execute on encountering val in array
   * @return {Boolean}             True/false
   */
  'include', function(val, handler, arr) {
    return util.include(this, val, handler, arr);
  },
  'concat', function(val) { 

    // if(!val) {
    //   return
    // }
    
    var arr = this
    var ll = arr.length;
    for (var i = 0, l = val.length; i < l; i++) {
      arr._push(val[i], false, false, true);
    }
    arr._update(val);
    return arr;
  },
  'moveItem', function(from, to) { var arr = this
    if(to === void 0) to = arr.length - 1
    if(from === to) return
    var mover = arr[from]
    if(!mover) return
    var step = from < to ? 1 : -1
    do {
      arr[from] = null
      arr.set(from, arr[from + step], true)
      from += step
    } while(from !== to)
    arr[to] = null
    arr.set(to, mover, true)
  }
)

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/compound.js":[function(require,module,exports){


var VObject = require('vigour-js/object').inject(
    require('vigour-js/value/length')
  ),
  util = require('vigour-js/util'),
  uid = require('vigour-js/util/id')

var SAMEPATH = 'could not create compound of two Objects with the same path'

// function Compound(val){
//   var compound = this
//   compound.$sources = new SourceList(compound, val)
//   this.__t = 2
// }

// var Data = require('vigour-js/data')

var Compound = VObject.new(void 0, function(val){
  var compound = this
  compound.$sources = new SourceList(compound, val)
  this.__t = 2
  return false
})
util.define(Compound, '_class', VObject)


module.exports = Compound
// Compound.prototype = new VObject()

Compound.prototype._blacklist.push(
  '$sources'
)

util.define( Compound,
  '_absorb', function _absorb(entry) {
    var compound = this
    var source = entry.source
    var prefix = entry.name
    
    var endpoint = source
    while(endpoint && endpoint.__t === 4 && !endpoint._filter) {
      endpoint = endpoint._val
    }
    entry.endpoint = endpoint
    
    if(endpoint) {
      endpoint.each(function absorbEach(){
        compound.set(prefix + '-' +this._name, this)
      })
    }

    compound.each(function cleanOld(){
      var pointer = this
      var pointed = pointer._val

      // skip cleanup check on construction
      if(!compound.$sources) {
        return
      }

      // TODO: find a better way to check if thing is still in an enpoint
      // get the endpoint the item should be in
      var sourcename = pointer._name.split('-')[0]
      var ep = compound.$sources[sourcename].endpoint
      var ok
      ep.each(function okCheck(){
        if(this === pointed) {
          return ok = true
        }
      })
      if(!ok) {
        pointer.remove()
      }
    })
  },
  '_addCompoundListener', function _addCompoundListener(entry) {
    var compound = this
    entry.source.on(function compoundListener(){
      // console.log('change in source, run absorb on', entry, 
      //   '\nval', arguments[0],
      //   '\nstamp', arguments[1]
      // )
      compound._absorb(entry)
    })
  }
)

function SourceList(compound, val) {
  var sourcelist = this
  sourcelist._parent = compound
  if(val){
    if(!(val instanceof Array)) {
      val = [val]
    }
    this.push.apply(this, val)
  }
}

SourceList.prototype.push = function pushSource(){
  var sourcelist = this
  var compound = sourcelist._parent

  // console.log('push dat sources', arguments.length)
  var al = arguments.length
  for(var i = 0, source; source = arguments[i] ; i++){

    var sourcename = uid()

    // console.log('SOURCENAME IS', sourcename)

    var entry = sourcelist[sourcename] = {
      name: sourcename,
      source: source
    }

    compound._absorb(entry)
    compound._addCompoundListener(entry)

  }
}




},{"vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/util/id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js","vigour-js/value/length":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')

/**
 * Flags are special properties where a function is called
 * different from operators since flags may have nothing to do with value calculation
 * extends default set from V.Object
 * @property
 */
/**
 * Adds new flags to V.Object
 * @method extend
 * @param  {Object}   object V.Object to extend flags to
 * @param  {Function} [set]  [description]
 * @return {[type]}          [description]
 */
exports.extend = util.extend(function(object, set) {
  
  //multiple flags 
  
  // abstract flags array away!
  // 
  // flags object --> field
  // 
  // check /w cases
  // check /w parent
  // flag4 is dynamic has stack as option
  
  var _proto = object.prototype
    , _convert = _proto.convert
    , _set = _proto._set
    , _remove = _proto._remove
    , _check = function(name) {
      var f;
      for (var i in object.flags.dynamic) {
        f = object.flags.dynamic[i](name)
        if(f) break
      }
      return f
    }
    , checkIfFlagOverwrite = function(val) {
      for(var i in val) {
        if(object.flags[i] || _check(i)) return true
      }
    }

  if (!set) set = _proto.set

  _proto._blacklist.push('_flag');
  util.define(object,
    /**
     * [description]
     * @method convert
     * @param  {[type]} val [description]
     * @return {[type]}     [description]
     */
    'convert', function(val) {

      //hier ook weer for
      var obj = _convert.call(this, val);

      // console.log('I SHOULD BE CONVERTING!', val, obj, this._flag)





      if (this._flag && (!val || !util.isObj(val) || val.val || checkIfFlagOverwrite(val) )) {

        // console.log('I SHOULD BE CONVERTING! step 2')

        //ff useVal gebruiken

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (!flag[4] || !flag[4].stack) {

            // console.log('CONVERT NEEDS FIX'.red.bold.inverse)

            if (obj === flag[1]) {
              // console.log('2 CONVERT NEEDS FIX'.red.bold.inverse)
              obj = {};
            }
            if (obj.val === flag[1]) {
              // console.log('3 CONVERT NEEDS FIX'.red.bold.inverse)
              delete obj.val;
            }


            obj[flag[0]] = flag[2]
          }
          else {
            //still have to take care of this situation
            // console.error('trying convert a stack-dynamic flag', flag);
          }
        }

        // console.log('CONVERTED ---->',obj)

      }
      return obj;
    },
    /**
      @property __flags__
    */
    '__flags__', {},
    /**
     * [description]
     * @method remove
     * @param  {[type]} from   [description]
     * @param  {[type]} update [description]
     * @param  {[type]} stamp  [description]
     * @return {[type]}        [description]
     */
    '_remove', function(from, update, stamp) {

      if(this._flag) {
        for(var i in this._flag) {
          // console.log(i, this._flag)
          var flag = this._flag[i]
          //for 
          // console.log('_remove')
          if (flag) {
            //dit moet wel ff lukken
            if (object.flags[flag[0]]) {
              object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag);
            } else {
              flag[4].remove.call(this, flag);
            }
          }
        }
        this._flag = null
      }

      _remove.call(this, from, update, stamp);
    },
    /**
     * [description]
     * @method _set
     * @param  {[type]} val      [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} from     [description]
     * @param  {[type]} remove   [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    '_set', function(val, stamp, from, remove, noupdate) {
      // console.log('make _set',this._name,val);
      _set.call(this, val, stamp, from, remove, noupdate)

      //flag moet dus ook meer een copied value worden

      // console.log('_set', this._flag, val)


      if(this._flag) {

        // console.log('overwrite>?----', this._flag, val)

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (flag) {
            var setFl = object.flags[flag[0]] || flag[4]
            //what to do with reset?
            //change fixen bij cases?
            
            // console.log('2 overwrite>?----', flag, this._val, this._val !== flag[1])
            
            if (this._val !== flag[1] && setFl.useVal) {

              // nu ff hier ook nog!

              if (object.flags[flag[0]]) {

                // console.log('remove flag normal',flag, flag[4], i, this)

                object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag)
                //if this empty
                // delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
                // this._update()
              } else if (!flag[5]) {
                // console.log('remove flag /w flag[4] and not flag[5]',flag, flag[4], i)
                flag[4].remove.call(this, flag);
                // if(this.)
                //delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
              }
            } else if (object.flags[flag[0]] && object.flags[flag[0]].reset && flag[3] !== this) {
              // console.error('RESETTING -- ingnore /w a clear!',flag[0]) 
              object.flags[flag[0]].set.call(this, flag[2], stamp, true, this._name)
            }
          }
        }
      }

    },
    /**
     * [description]
     * @method set
     * @param  {[type]} name     [description]
     * @param  {[type]} val      [description]
     * @param  {[type]} vobj     [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    'set', function(name, val, vobj, stamp, noupdate) {
      var fl = object.flags[name] || _check(name)
        , r
        , same

        // console.log(name, val, vobj)

      if (fl) {

        // console.log('set>?----', name, val, this._flag)
       
      if(val===false) {
          //stack -- alle flags name providen!
          var i = fl.stack||name 
            , flag = this._flag && this._flag[i]
          if(flag && fl.remove) {
            var d = fl.remove.call(this, flag, name)
            // console.log('REMOVE FLAG FROM FALSE'.inverse, fl, name, val, stamp, this)
            if(!d) {
              delete this._flag[i]
              if(util.empty(this._flag)) {
                // console.log('flag is empty, delete')
                delete this._flag
              }
            }
          } 
          r = true
          // if(this._flag)
      } else {
       if(this._flag) {
          //check if need to remove! -- only in case
          for(var i in this._flag) {
            var flag = this._flag[i]
            if (flag && fl.remove) {

              if(!fl.stack && name === flag[0]) {
                // console.log('--->',flag[0])
                if(val!==flag[2]) {
                  // console.log('remove flag! ---> overwrite bymyself --->', flag[0],  setFl, 'by:' ,name, fl, val, flag[2])
                  fl.remove.call(this, flag);
                } else {
                  same = true
                }

              } else if (!fl.stack || fl.stack !== flag[0]) {

                //this._flag

                //if val:true 
                //go check if you need to remove mofos

                var setFl = object.flags[flag[0]] || flag[4]

                if(setFl.useVal && fl.useVal) {

                  // console.log('remove flag! -- clearly has some useVal', flag[0],  setFl, 'by:' ,name, fl)

                  setFl.remove.call(this, flag);
                  delete this._flag[i]
                  if(util.empty(this._flag)) {
                    // console.log('flag is empty, delete')
                    delete this._flag
                  }
                }


                // console.log('remove flag!', flag, flag[0], flag[4],  object.flags[flag[0]]  , fl, name) //check if it needs to be removed
                // var fl 
                
                //fl = object.flags[name] || _check(name)
                //
                //hier iets mee doen weer zoeken naar flag set


                //do the special check if value is tight to flag check (for both! fl.value)

                // fl.remove.call(this, flag);
              }
            }
          }
        }

      if(!same) {
          // console.log('SET FLAG'.inverse, name, val, stamp, this)
          fl.set.call(this, val, stamp, false, name);
          r = true //niet altijd waar ofcourse!
          // console.log('---------')
        } else {
          // console.log('FLAG IS SAME'.red.inverse, name, val, stamp, this)
        }
      }
        this[name] && this[name].remove(false, false, false, false, false, true);
      } else {
        r = set.call(this, name, val, vobj, stamp, noupdate);
      }
      return r;
    });
  object.flags = _proto.__flags__;
  util.define(object.flags, 'dynamic', {});
})
},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/hashpath.js":[function(require,module,exports){
var util = require('../util')
  , hash = require('../util/hash')

exports.extend = util.extend(function(base) {
  base.prototype._blacklist.push('__hp')
  util.define( base
  , '_hashpath', {
      get: function() {
        return this.__hp || (this.__hp = hash(this._path.toString()))
      }
    }
  )
})
},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')
  , vigour = require('../')
  , inject = require('../util/inject')
/**
 * V.Objects are used instead of normal objects in vigour listeners are automatically added and removed
 * type: __t : 1 = array , 2 = object , 3 = has field (can never be an array) , 4 = field ref to other V.Object
 * note you can make an object out of a field or field ref the type will be 3 or 4 though!
 * @constructor
 * @param  {*}      [val]    Value
 * @param  {Object} [parent] Parentobject
 */
var object = module.exports = exports = vigour.Object = function(val, hook, parent) {
  if (parent) this._parent = parent
  if (hook && this._hook) this._hook(val, hook)
  if (val !== void 0) this.val = val
}
object.inject = inject
/**
 * Used to set .val
 * @method _set
 * @param  {*}              val                  [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Object|Boolean} [from]               [description]
 * @param  {Boolean}        [noupdate]           When true, no updates
 * @param  {Boolean}        [add]                When true, this is an add
 */
var _set = function(val, stamp, from, noupdate, add) {

  if(val===null) {
    if (!stamp) stamp = this.stamp()
    this.remove(false, false, false, from, stamp, noupdate)
  }

  if (!this.__t || this.__t < 3 || ( val !== this._val || this._ignoreValue ) ) {

    // console.error(this)
    if(!this.stamp) {
      //moet allemaal event emitters worden (on('error'))
      //this._update('error') en anders V.debug.error._update( 'object' )
      console.error( 'ERROR in vigour-js/object,  OBJECT no .stamp', this )
      return
    }

    if (!stamp) stamp = this.stamp()

    var oldval = this._val
      , nestedval
      , noset
      , isSet
      , isArray
      , valIsSet

    if (this._changevobj 
      && ((this.__t < 4 && val instanceof object) 
      || this.__t === 4 && ((!this._mixed||this._mixed===4) || val instanceof Array 
        || (val instanceof Object 
          && (val instanceof object || val.val))))) { //try to make this shorter
         this._changevobj(val, stamp)
         if(this._mixed===4) this._val = null
    }

    if (vigour.Base && (val instanceof vigour.Base)) {
      this.remove(true, true, false, false, stamp)
      this.__t = 5
      this._val = val
    } else if (val instanceof object) {
      if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
        this.remove(true, true, false, void 0, stamp) //check if 2nd param true is absolutely nessecary (else it will be removed)
      }
      this._val = val
      this.__t = 4
      if (this._setvobj) this._setvobj(val)
    } else {

      if (val instanceof Object && typeof val !== 'function') {
        if (val instanceof Array) {
          this._val = void 0
          this.__t = 1
          this.length = val.length
          noset = this.remove(true, true, val, false, stamp)
          for (var i = 0, l = this.length; i < l; i++) {
            if (!this.set(i, val[i], false, stamp, noupdate, true) && noset !== false) {
              noset = true
            } else {
              noset = false
            }
          }
        } else {

          //normal object

          if (val.clear) {
            noset = this.remove(true, true, false, false, stamp)
            delete val.clear
          } else {

            if (this.__t === 1) {
              if (this._mixed !== 1 && this._mixed!==4) {
                this.remove(true, true, false, false, stamp) //ommiting stamp can be a problem
              } else {
                isArray = true
              }
            } else if (!this._merge && (!this._mixed || this.__t === 2)) {
              noset = this.remove(true, true, val, false, stamp)
            }
          }
          if (val.val && util.isObj(val.val)) {
            valIsSet = true
            this._$setVal( new this._class(val.val, false, this), stamp, from, true)
            this._val._contained = true
          } else if (!this._mixed) {
            this._val = void 0 //this messes up property updates!! (youri)
          }

          if (!isArray) this.__t = 2

          for (var j in val) {
            if (!util.checkArray(this._blacklist, j)) {
              if (j === 'val') {
                if(!valIsSet) isSet = this._$setVal( val.val, stamp, from, true )
                nestedval = true;
              } else {
                //do not always ignore updates at this point
                if (!this.set(j, val[j], false, stamp, noupdate, true) && noset !== false) {
                  noset = true
                } else {
                  noset = false //this is the place where set is passed
                }
              }
            }
          }
        }

      } else {
        if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
          this.remove(true, true, false, false, stamp)
          if (this.__t === 1) delete this.length
        }
        if (val === this._val && !this._ignoreValue ) {
          //maybe use stamp for ignoreValue as well?
          if (noset !== false) {
            this.__t = 3
            return false
          }
        } else {
          this._val = val
          this.__t = 3
        }
      }
    }
    if (nestedval) {

      if (this._set && (isSet !== false || noset === false)) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      }
    } else if (this._set) {
      if (!noset) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      } else {
                    // if(window.smut) console.log('!1',arguments)

        return false;
      }
    }
  } else {
                        // if(window.smut) console.log('!1',arguments)

    return false;
  }

},
/**
 * stamp
 * paint the set origin
 * @method
 */
_stamp = 0,
_params = function(params, list) {
  for (var i = list.length - 1, p; i >= 0; i--) {
    if (params && params[list[i]]!==void 0) {
      p = '_' + list[i]
      util.define(this, p, params[list[i]])
    }
  }
}
/**
* Generates unique stamp
* @method stamp
* @return {Number} Returns stamp
*/
exports.stamp = function() {
//if stamp > x reset ?
return _stamp++
}

exports.set = _set

// objectUtils.extend(exports);  
/**
 * Creates a new constructor based on a V.Object
 * Params can be passed
 * Mixed creates mixed types for the new class i.e having a string and properties
 * @method new
 * @param  {Object} params Parametersobject
 * @return {Object}        Returns V.Object
 */
// window.cnt = 0
// setTimeout(function() {
//   window.smut = true
// },2000)

object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      var conresult
      if (constructor) {
        conresult = constructor.apply(this,arguments)
      }
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)

      if(val !== void 0 && conresult !== false) {
        this.val = val
      }
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  vObj.inject = inject //not handeled well yet
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

util.define(object,

// '_set, set , '

 '_$setVal', _set,

/**
 * Items in the blacklist skipped in each function
 * @method _blacklist
 */
'_blacklist', ['_', '__', '__t', '_val', 'length', '_name', '_parent', '_contained', '_removed','extensions', '__cachedPath', '_ignoreValue', '_indexCache'],
/**
 * Replaces default constructor property ,necessary for classes made with V.Object.new
 * @constructor _class
 */
'_class', object,
/**
 * Stamp is a method of VObject so that it can be extended in subclasses
 * @return {*} a unique identifier for a mutation
 */
'stamp', object.stamp,
/**
 * Used to get .val which returns field values i.e. a string
 * @method _get
 * @return {*} Returns value
 */
'_get', function() {
  var self = this
    , type = self.__t
    , val

  if (type < 3) {
    return self
  } else {
    val = self._val
    return (type !== 4) ? val : val && val._get()
  }
},
/**
 * Used to get .val which returns field values i.e. a string
 * Set creates instances of the _class for nested properties
 * @property
 */
'val', {
  set: function(val) {
    // window.cnt++
    // if(window.smut) {
      // console.error(window.cnt, 'whats happening', this._path, this._prop && this._prop.name, this, this._updateOrigin)
    // }
    return this._$setVal(val)
  },
  get: function() {
    return this._get()
  }
},
/**
 * Add a property to a object
 * @method set
 * @param  {String}  name                [description]
 * @param  {*}       val                 [description]
 * @param  {Boolean} [vobj]              [description]
 * @param  {Number}  [stamp = new stamp] [description]
 * @param  {Boolean} [noupdate]          [description]
 * @return {Boolean}                     [description]
 */
'set', function( name, val, vobj, stamp, noupdate, from ) {

  //function( name, val, vobj, stamp, noupdate, from ) 

  // console.log(name, stamp)

  from = from && this
  if (!vobj && (this[name] instanceof object)) {
    if (this._$setVal.call(this[name], val, stamp, from, noupdate) === false && stamp) {
      return false
    }
  } else {
    if (vobj) {
      if(this[name]) this[name].remove()
      this[name] = val
      this[name]._name = name
      this[name]._parent = this
      if(!noupdate) val._update(val, stamp || this.stamp(), from, void 0, true)
    } else {
      this[name] = new this._class(void 0, false, this)
      this[name]._name = name
      this._$setVal.call(this[name], val, stamp, from, noupdate, true)
    }
    if (this.__t === 1 && this._setArrayItem) {
      this._setArrayItem( this[name], val )
    }
  }
  return true
},
/**
 * Removes a V.Object including all nested fields and values
 * @method remove
 * @param  {Boolean}        [nested]             When true remove nested objects
 * @param  {Boolean}        [bl]                 When true doesn't remove blacklisted items
 * @param  {Boolean}        [not]                [description]
 * @param  {Boolean|Object} [from]               [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Boolean}        [noupdate]           [description]
 * @return {Boolean}                             [description]
 */
 //    this.remove(false, false, false, from, stamp, noupdate)

'remove', function(nested, bl, not, from, stamp, noupdate) { //no update first > (extended in selection.js)
  if (!nested) this._removed = true
  var r, i, oldval
  if (!stamp) stamp = this.stamp()
  // console.log('START',stamp,this._name);
  if (!nested) {
    if (this._parent) {
      this._parent[this._name] = null
      delete this._parent[this._name]
    }
    if (this._val !== void 0) {
      if (this._val instanceof object && this._val._contained) {
        this._val.remove(false, false, false, from || this, stamp, noupdate)
      }
      oldval = this._val
      this._val = null
    }
  }
  for (i in this) {
    if ((!not || !not[i]) && !util.checkArray(this._blacklist, i)) {
      if (this[i] instanceof object) {
        r = false
        // console.log('DELETE',stamp,i,this[i]);
        this[i].remove(false, false, false, from || this, stamp, noupdate)
      }
      this[i] = null
      delete this[i] //delete is pretty nasty for performance
    }
  }
  if (!nested) {
    if (this._remove) {
      //r
      this._remove(from, noupdate ? false : from /*||r*/ , stamp, oldval);
      if (!bl) {
        for (var j in this) {
          if (this[j] !== void 0) {
            if (j !== '_parent' && this[j] instanceof object && this[j]._contained) {
              this[j].remove()
            }
            this[j] = null
            delete this[j]
          }
        }
      }
    }
    this._removed = true
  }
  return r
})


//----this has to be initialized after defining the blacklist property;
exports.listen = require('./listen')
require('./array')
require('./util')
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./array":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/array.js","./listen":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/listen.js","./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/listen.js":[function(require,module,exports){
var util = require('../util')
  , vObject = require('./')
  , V = require('../')
  //TODO: this is a temp fix to emulate on next tick
  , raf = require('vigour-js/browser/animation/raf')
  , Promise = require('promise')

function _addListener( obj, fn, mark, original ) {
  //val, mark, skipcheck, ignoreval, orginal
  if( mark ) 
  {
    // console.log('hey got orginal!', original)
    //n( val, mark, skipcheck, ignoreval, original )
    obj.addListener([ fn, mark ], true, false, false, original  )
  } 
  else 
  {
        // console.log('hey got orginal!', original)

    obj.addListener( fn, false, false, false, original )
  }
}

/*
  _update calls listeners on a given Object (listeners include linking fields in other V.Objects)
  V.Object._update can be modified to change update behavior:
    - standard: update Object and it's parents / ancestors recursively.
    - parentOnly: update Object and only its direct parent.
    - just _update: update only the Object.
*/
var _update = exports._update = function(val, stamp, from, remove, added, oldval, test) {

  // if(window.here) console.log('UPDATE!',this._path)

  var _l = this._listeners
    , i
    , listener

  if (_l) {
    for (i = _l.length; listener = _l[--i];) { //order is irrelevant
      if (listener instanceof vObject) {

        // console.log('update?????', listener._path, this._path, from)

        // if (from) {
        listener._lfrom = from || this
          // }

        listener._update(val, stamp, false, remove, added, oldval)

        if (listener) listener._lfrom = null

      } else if (listener[0]) {
        if(!test || !test(listener)) {
          if (listener.length > 2) {
            for (var l = listener.length - 2
              , l2 = arguments.length
              , a = [], j = -1
              , la = l + l2
              ; j < la
              ; a[++j] = j < l
                ? listener[j + 2]
                : j === l ? this : arguments[j - l - 1]
              );

            listener[0].apply(listener[1], a)
          } else {
            listener[0].call(listener[1], this, val, stamp, from, remove, added, oldval)
          }
        }
      } else {
        listener.call(this, val, stamp, from, remove, added, oldval)
      }
    }
  }
}


// util.define(vObject, 
//   '_nodePath_', function() {
//     if(this._caller) {

//       var arr = []
//       var p = this._caller

//       while(p) {
//         arr.push( p._name || p._node && p._node.className )
//         p = p._node && p.parent
//       }
//       arr.reverse()
//       return arr


//     }
//   }

// )


vObject.prototype._blacklist.push('_listeners', '_listens', '_lfrom', '_listenMap');

util.define(vObject,
  /**
   * _set
   * is called when a value is set
   * @method
   */
  '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
    if (!noupdate) {
      // console.log(this._path, val)
      this._update(val, stamp, from, remove, added, oldval);
    }
  },

  'is', function (val, cb, nextTick ) {

    //on removal of promise remove listener

    if(!cb || ( typeof cb !== 'function')) {
      var _this = this
      nextTick = cb
      // console.error('my mofo', nextTick)
      return new Promise(function( resolve, reject ) {
        // console.log('312123123213', val)
        _this.is( val, function() {
          resolve.apply(this, arguments)
        }, nextTick)
      })
    } else {
      // console.error('lezzgo')
      var cbx = nextTick ? function() {
        var args = util.arg(arguments)
          , _this = this
        raf(function() {
          cb.call(_this)
        })
      } : cb
      //TODO: add original if its not 
          // console.error('--------------', val)

      if(val==='loaded') {
        if(this.$loaded || this.from.$loaded) {
          cbx.call(this)
        } else {
          this.once('loaded', cbx)
        }
      } else {
        var ret
        // var ignore
        // console.error('1!@#@#!!@#', ret, val)

        if(this.val == val ) {
          // console.error('2!@#@#!!@#', ret, val)

          return cbx.call(this)
        } else {
          // console.error('!@#xxxxx12121212122112@#!!@#', ret, val)

          ret = (typeof val === 'function') && val.call(this)
          // ignore = true
          // console.error('2222222222!@#@#!!@#', ret, val)
        }
        if(ret) {
          if( ret instanceof Promise ) {
            // console.error('promise')
            return ret
          } else {
            // console.log('????!!!')
            return cbx.call(this)
          }
        } else {
          // console.error('22222!@!@#!@#', val)
          if(typeof val === 'function') {
            this.once(val, cbx)
         } else {
            this.once({
              $val: val
            }, cbx)
         }
        }
      }
      return this
    }
  },
  /**
   * __update
   * calls listeners attached to the Object
   * types -- function or V.Object
   * @method
   */
  '__update', _update,
  /**
   * _update
   * escalates an update up it's structure and calls __update to call listeners
   * types -- function or V.Object
   * @method
   */
  '_update', function(val, stamp, from, remove, added, oldval, test) { //here you can see if its an update from another object (from)
    // console.log('V.Object OG _update', val, stamp, from, remove, added, oldval)
    var curr = this,
    s = true

    while (curr) {
      // var p = curr._path
      // _update ["clients", "V_2pxcewv3g4k"] 
      // console.log('_update', p, val, from || ((!s && this) ? this : void 0, this) )

      //TODO 10 double check this
      curr.__update(val, stamp, from || (s!==true) ? this : false , remove, added, oldval, test)
      curr = from ? false : curr._parent
      s = false
      if (remove) remove = 1
    }
  },
  /**
   * _remove
   * called on remove
   * @method
   */
  '_remove', function(from, update, stamp, oldval) {
    if (update !== false) {
      this._update(null, stamp, from, true, false, oldval);
    }
    this.removeListener();
    var _l = this._listens,
      i, listener;
    if (_l) {
      //optimize later
      //this,this is weird to always use this...
      for (i = _l.length - 1; i >= 0; _l[i--].removeListener(this, void 0, false, true));
    }
  },
  /**
   * _setvobj
   * if a value is set to a V.Object
   * @method
   */
  '_setvobj', function(val) {
    val.addListener(this);
  },
  /**
   * _changevobj
   * if a value is changed from a V.Object
   * @method
   */
  '_changevobj', function(val) {
    if (this.__t === 4) {
      var _l = this._listens,
        _val = this._val,
        i;
      if (_l) {
        for (i = _l.length; i >= 0; _l[--i] && _l[i].removeListener(this, this));
      }
      if (_val instanceof vObject && _val._contained) {
        _val.remove();
      }
    }
  },
  /**
   * addListener
   * adds a listener to an object can be a function or V.Object
   * @method
   */
  'addListener', function( val, mark, skipcheck, ignoreval, original ) {
    var _l = this._listeners || (this._listeners = []),
      target, g;

    if(original) {
      // console.log('ORGINAL!', original)
      if(!this._listenMap) {
        this._listenMap = []
      }
    }

    //more speed voor checkarray
    if (mark) {
      g = util.checkArray(_l, val[1], 1);
      if (g === false
        || !ignoreval && util.checkArray(_l, val[0], 0) === false
        || (mark !== true && mark.call(this, _l[g], _l, g, val) === true)) {
        
        //TODO: fix this ultra dirty stuff
        if( original && val !== orginal ) {
          this._listenMap.push([ orginal, val ])
        }

        _l.push(val);
      } else  {
         return _l[g];
      }
    } else if (!val.__t || !util.checkArray(_l, val)) {

      if( original && val !== original ) {
        this._listenMap.push([ original, val ])
      }

      _l.push(val);
    }
    if (mark || val instanceof vObject) {
      target = mark ? val[1] : val;
      if (target instanceof vObject) {
        _li = target._listens || (target._listens = []);
        if (skipcheck || !util.checkArray(_li, this)) {

          if( original && val !== original ) {
            this._listenMap.push([ original, val ])
          }

          _li.push(this);
        }
      }
    }
  },
   'once', function( val, method, mark ) {

    //val, mark, skipcheck, ignoreval, orginal

    //TODO:unify /w on
    var mval

    var listen = function() {
      
      this.removeListener( mval, mark )
      // this.removeListener( listen )

      mval.apply( this, arguments )
      //original perhaps????
    }

    if( method ) {
      mval = method
      this.on( val, listen, false, mval ) //deze fn moet wel geremoved worden gebeurd nu niet!
    } else {
      mval = val
      this.on( listen, false, false, mval )
    }

    return this

  },
  'on', function( val, method, mark, original ) {
      /**
        * val can be a condition or a comparison or a method
      **/
      if( V.Base && method instanceof V.Base ) 
      {
        mark = method //make exception for values!
        method = null
      }

      if(!original) {
        original = method
      } else {
        // console.log('set original!', original, method )
      }

      if( !method ) 
      {
        _addListener( this, val, mark, original )
      }
      else 
      {
        if( util.isObj( val ) )
        {
          // console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          //Has to become a condition
          if(val.$val) {
            _addListener( this, function( nval ) {
              if( this.val === val.$val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          } else {
            console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          }
          //Has to become a condition


        }
        else if( typeof val === 'function' )
        {
          _addListener( this, function( nval ) {
            if( val.apply( this, arguments ) ) //more checks
            {
              method.apply( this, arguments )
            }
          }, mark, original )
        }
        else 
        {

          if( util.isObj( method ) )
          {

            mark = val

            console.warn('untested -- add as mark')
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )


          }
          else if( val === 'remove' )
          {
            //val, stamp, false, remove, added, oldval
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          //TODO: in redo this will be done differently (event types are special done)
          else if( val === 'loaded' ) {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              //__frommethod

              if( this.$loaded || this.from.$loaded ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'added' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              if( added ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'self' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;

              //TODO: put on in a different file
              // console.log('SHOULD DO SELF!', arguments, from ) //zo wrong!

              if( this._val === nval 
              || !val && this._updateOrigin===this //pretty slow check , its there to check when someone call .update for example
              ) 
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else
          {
            _addListener( this, function( nval ) {
              if( nval === val || this.val === val || this._val === val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
        }
      }
      return this
    },

  /**
   * removeListener
   * if no val removes all listeners
   * mark checks in array on position 1 for uniqueness
   * remove is used in combination with mark
   * @method
   */
  'removeListener', function(val, mark, remove, nobreak) {
    // console.log('removeListener!', this._path, this._listeners && this._listeners.length
    //   , '\nmark:\n', mark && mark.raw
    //   , '\nval:\n', val && val.name
    //   , '\nval:\n', val
    // )
    var _l = this._listeners,
      i;
    if (_l) {
      for (i = _l.length - 1; i >= 0; i--) {
        //maybe checking mark all the time is too slow?
        var listener = _l[i]
        if (
          (!mark && !val)
          || (val && listener === val) //false voor mark
          || (mark!==false && ((listener instanceof Array) && ((mark && listener[1] === mark && (!val||listener[0]===val)) || val && listener[1] === val))
            && (!remove
              || (remove === true  //dit moet later weg is dan alleen een functie is nu overbodig (check boven)
                ? listener[0] === val
                : remove.call(this, listener, mark))))
        ) {
          // console.log('mark._listens?', !!(mark && mark._listens)
          //     , '\nis vObject?', listener instanceof vObject
          //     , '\nis marked?', listener instanceof Array
          //   )
          var focus = mark
            ? mark
            : listener instanceof vObject
              ? listener
              : listener instanceof Array
                ? listener[1]
                : false
          var listens = focus && focus._listens
          if(listens){
            for(var j = listens.length-1 ; j >= 0 ; j--){
              if(listens[j] === this){
                listens.splice(j, 1)
                if(listens.length === 0)
                  focus._listens = null
                if(focus.__t === 4 && listener._val === this)
                  listener._val = void 0
                break
              }
            }
          }
          _l.splice(i, 1)
          if (_l.length === 0) this._listeners = null;
          if (val && !nobreak) break
        }
      }

      //TODO: this has to be refactored ASAP! do when new design phase for vobject+base is going down
      if( this._listenMap && val ) {
        // console.log('im here!', val)
        var piv
        for(var i = 0, _len = this._listenMap.length; i < _len; i++ ) {
          if( this._listenMap[i][0] === val ) {
             // console.log('hey its the listenmap!', val)
             this.removeListener( this._listenMap[i][1] )
             piv = i
             break;
          }
        }
        if( piv !== void 0 ) {
          this._listenMap.splice(piv, 1)
          if(this._listenMap.length === 0) {
            this._listenMap = false
          }
        }
      }

    }
  });
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","promise":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/index.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  VObject = require('./'),
  V = require('../')
  _c = util.checkArray

/**
 * Gets/sets VObject origin
 * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
 * @method from
 * @param  {Object} obj [description]
 * @return {Object}     [description]
 */
var _coreSet = VObject.set,
  _from = this.from = function(obj) {
    var val = obj,
      last;

    while (val instanceof VObject) {
      // console.log(val)
      if(val._filter) {
        // console.error('IS SELECITON', val)
      }
      last = val;
      val = val._val;
    }
    return last !== obj ? last : false;
  },
  _lastLFrom = function(obj) {
    while (obj && obj.__t === 4) {
      if (obj._lfrom) {
        return obj._lfrom;
      } else {
        obj = obj._val;
      }
    }
  },
  /**
   * Returns path
   * @method _updatePath
   * @param  {Object}    till [description]
   * @return {Object}         Returns path
   */
  _updatePath = function(till, start) {
    var parent = this,
      lfrom,
      path = []; //reduce amount of new arrays
    while (parent && (parent._name !== void 0 || start)) {
      lfrom = parent._lfrom || _lastLFrom(parent)
      if (lfrom) {
        var a = _updatePath.call(lfrom),
          c = parent.from._name;
        util.add(a, path);
        path = a;
        if (c) {
          c = a.indexOf(c);
          a.splice(c, a.length - c);
        }
      }
      if (parent !== till) {
        path.push(parent._name);
        parent = parent._parent;
      } else {
        parent = false;
      }
    }
    // console.log('----->',path)
    return till ? path.reverse() : path;
  }

util.define(VObject,
  /**
   * Removes all linked containers, uses slice on arrays
   * Removes all _listeners
   * @method destroy
   */
   'toString', function( compressed ) {
      return compressed 
             ? JSON.stringify( this.raw ) 
             : JSON.stringify( this.raw, false, 2 )
   },
   'referenceLevel', function(linked) {
      var link = this
      var cnt = 0

      // console.log(link, link.__t)

      while(link && link.__t) {
        if(link===linked) {
          return cnt
        }
        link = link._val
        cnt++
      }
      return false
   },
  'destroy', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    this._removed = true
    this.destroyReferences(nested, bl, not, from, stamp, noupdate)
    this.remove(nested, bl, not, from, stamp, noupdate)
  },
  'destroyReferences', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    var _l = this._listeners
      , parent
      // , item
    if (_l) {
      for (var i = _l.length, ref; ref = _l[--i];) {
        // if(listener instanceof Array){
        //   if(listener)
        // }
        // ref =  instanceof Array ? _l[i][1] : _l[i];
        if (ref instanceof VObject) {
          parent = ref._parent;
          if (parent && parent.__t === 1) {
            parent.splice(ref._name, 1);
          } else {
            ref.remove(nested, bl, not, from, stamp, noupdate);
          }
        }
      }
    }
  },
  /**
   * Performs passed function on each item.
   * Skips items in the blacklist.
   * @method
   * @param  {Function}  fn   function to perform on each
   * @param  {Boolean}   deep If true, repeats eachmethod on nested fields
   * @param  {Arguments} arg  Arguments to pass to the function
   * @return {Boolean}        [description]
   */
  'each', function(fn, deep, arg) {
    //try to make this a lot shorter
    var i, item;
    if (arg !== void 0) {
      arg = util.arg(arguments, 2);
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.apply(item, arg)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each.apply(item, arg)) {
              return true;
            }
          }
        }
      }
    } else {
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.call(item, i)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each(fn, deep, arg)) {
              return true;
            }
          }
        }
      }
    }
  },
  /**
   * Returns the real path
   * @attribute _path
   */
    '_path', {
      get: function() {
        var parent = this
          , path = []

        while (parent && parent._name !== void 0) {
          path.push(parent._name);
          parent = parent._parent;
        }

        return path.reverse();
      }
    },
    '_cachedPath', {
      get: function() {
        return this.__cachedPath || (this.__cachedPath = this._path.join('.'))
      }
    },
  /**
   * Returns the update path
   * @attribute updatePath
   */
  'updatePath', {
    get: function() {
      var a = _updatePath.call(this, this, true),
        name = this._name;
      name !== void 0 && a.unshift(name);
      return a;
    }
  },
  /**
   * Returns the keys of an object
   * @attribute keys
   */
  'keys', {
    get: function() {
      var i, arr = [];
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          arr.push(i);
        }
      }
      return arr;
    }
  },
  /**
   * Returns true if object is Ancestor
   * also return true when object is object to be compared to
   * @attribute keys
   */
  //t._d === from._parent || t._d === from
  '_ancestor', function(obj) {
    // console.log('ANCESTOR'.red.inverse, obj, this)
    var p = this
    while (p) {
      if (obj === p) return true
      p = p._parent
    }
  },
  /**
   * Get a field at first occurence in the parent chain
   * @method checkParent
   * @param  {String}  field [description]
   * @param  {Boolean} get   When true returns found instead of current
   * @return {Object}        [description]
   */
  'checkParent', util.checkParentFactory('_parent'),
  /**
   * Returns a normal object, and keeps links to V.Objects
   * @method
   * @param  {*}      [val] [description]
   * @return {Object}       [description]
   */
  'convert', function(val) {
    var obj = {}, l = 0
    if (!val || val.val) obj.val = this._val
    if (this.__t === 1) {
      obj = []
      for (var i = 0; i < this.length; i++) {
        l++
        obj[i] = this[i].convert()
      }
    } else {
      this.each(function(i) {
        if (!val || val[i]!==void 0) {
          l++
          obj[i] = this.convert()
        }
      })
    }
    if (val) {
      for (var i in val) {
        if (obj[i] === void 0) obj[i] = void 0
        l++
      }
    }
    if (!l && (!val || val.val)) obj = obj.val
    return obj
  },
  /**
   * Returns a normal object
   * @attribute raw
   */
  'raw', {
    get: function() {
      var self = this,
        type = self._filter ? 2 : self.__t,
        obj, i, l;
      if (type === 4) {
        return self._val && self._val.raw;
      } else if (type === 3) {
        return self.val; //when the type is mixed always uses val
      } else {
        if (type === 1) {
          obj = [];
          for (i = -1, l = self.length - 1; i < l; self[++i] && obj.push(self[i].raw));
        } else {
          obj = {};
          for (i in self) {
            if (!_c(self._blacklist, i) && self[i]) {
              obj[i] = self[i].raw;
            }
          }
        }
        return obj;
      }
    }
  },
  /**
   * Gets/sets object origin
   * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
   * @attribute from
   */
  'from', {
    set: function(val) {
      var found = _from(this)
      _coreSet.call(found || this, val)
    },
    get: function() {
      return _from(this) || this
    }
  },
  /**
   * Merge any object into another object
   * Shallow for a shallow merge
   * @method merge
   * @param  {Object}  obj      [description]
   * @param  {Boolean} shallow  [description]
   * @param  {Number}  stamp    [description]
   * @param  {Boolean} noupdate [description]
   * @return {Object}           [description]
   */
  'merge', function merge( obj, shallow, stamp, noupdate, block, sorted, deferUpdates ) {

    // console.log('MERGE---->', obj )

    var mergeArray = this._mergeArray
      , r
      , i
      , stop
      , rt
      , cobj
      , tobj
      , topLevel

    if(!deferUpdates) {
      // console.log('NO deferUpdates'.yellow.inverse)
      topLevel = true
      deferUpdates = []
    }
    //FIXME: make it better long names etc, code formatting

    if ( !stamp ) stamp = this.stamp()

    if ( this.__t === 1 ) {
      if (mergeArray) {
        mergeArray( obj, stamp, noupdate ) //hier moet ook ff deferUpdates
      } else {
        for (var j in obj) {
          cobj = obj[j]
          tobj = this[j]
          if ((j = Number(j)) > -1) {
            r = true
            if (tobj) {
              tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
            } else {
              if (j > this.length - 1) this.length = j + 1
              this.set(j, cobj, false, stamp, true, true)
            }
          }
        }
      }
    } else {
      for (i in obj) {
        stop = true
        cobj = obj[i]
        tobj = this[i]
        if (i !== 'val' && !_c(this._blacklist, i)) {
          if (!shallow && tobj && util.isObj(cobj)) { //cobj instanceof Object && (typeof cobj !== 'function') && cobj.__t !== 3)
            if (cobj.clear) {
              _coreSet.call(tobj, cobj, stamp, false, true)
              r = true
            } else {

              // console.error('---- merge /w update thats mos def wrong!', i, deferUpdates)
              //deferUpdates

              rt = tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
              if (r !== true) r = rt

              if (!rt) 
              {
                // console.log('0000')
                obj[i] = void 0
              }
            }
          } else {

            if (tobj && tobj._val === cobj) { //changed to differentiate between 0 and false, now also differentiates between 1 and '1'
                // console.log('---- 2 update thats mos def wrong!', i)

              if (r !== true) r = false
              // console.log('???????')
              obj[i] = void 0
            } else {
              // console.log('---- 3 update thats mos def wrong!', i)
              if(cobj===null && this[i]) {
                this[i].remove( false, false, false, void 0, stamp )
              } else {
                // console.log('!?'.bold, i, this[i])
                //name, val, vobj, stamp, noupdate, from
                this.set( i, cobj, false, stamp, true )
                // console.log('!xxxx?', i)
                if(this[i] && this[i]._listeners) {
                  // console.log('push push'.green,  JSON.stringify(obj) )
                  deferUpdates.push( [this[i], cobj] )
                }
                //add dit naar list
              }
              if (!r) r = rt;

              // console.warn(r, rt)

              if (!rt) 
              {
                //TODO: TEMP FIX DONT KNOW IF THIS WORKS!
                // console.log('???????22222')
                // obj[i] = void 0
                // console.warn('cant be right!')
                //SUPER CAREFULL WITH THIS R THING!!!!!
                r = true
              }
            }
          }
        }
      }
      if (obj.val) {
        rt = _coreSet.call(this, obj.val, stamp, false, true)
        if (!r) {
          r = rt
        }
        if (!rt) {
          obj.val = void 0
        }
      } else if (!stop) {
        if (!r) {
          r = false;
        }
      }
      r = (r !== false) || r
    }

    if (r) {
      if (!block) {
        // alert(noupdate)
        if (noupdate) {

          // console.log('!!??????????? NOUPDATE'.blue, JSON.stringify(obj))

          if(topLevel) {
            // console.log('UPDATE>?'.magenta.inverse, obj, JSON.stringify( obj ), noupdate, stamp)
            this._update(obj, stamp)
          }
          else {
            this.__update(obj, stamp)
            deferUpdates.push([ this, obj ])
          }
        } else {
          
          // console.log('2UPDATE>?'.cyan.inverse, topLevel, deferUpdates, obj, noupdate, stamp)

          this._update( obj, stamp )
        }
      }
    }
   

    if(topLevel && deferUpdates) {
      // console.log( 'defered updace', topLevel, deferUpdates)
      for(var df in deferUpdates) {
        if( deferUpdates[df][0] && deferUpdates[df][0].__update ) {
          // console.log('DEFERED!!!!'.cyan.inverse, df, deferUpdates[df][1], stamp )
          deferUpdates[df][0].__update( deferUpdates[df][1], stamp )
        }
      }
    }
    return r
  },
  /**
   * Copies an object and returns a new one, can also pass a merge object
   * @method
   * @param  {Object}        obj       Object to copy
   * @param  {Boolean}       [shallow] [description]
   * @param  {Array|Object}  [list]    Takes any object with .length
   * @param  {Object}        [parent]  [description]
   * @return {Object}                  [description]
   */
  'clone', function(obj, shallow, list, parent) { //support shallow!; check obj copy only what is nessecary added makeshort , made parent shorter
    var copy = new this._class(),
      _val = this._val,
      i;
    if (parent) {
      copy._parent = parent;
    }
    copy.__t = this.__t;
    if (this.__t === 1) {
      copy.length = this.length;
    }
    if (list) {
      //list
      for (var j = list.length - 1, item; j >= 0; j--) {
        item = list[j];

        if (item instanceof Array && this[item[0]]) {
          if(item[1] === true) {
            copy[item[0]] = util.clone(this[item[0]], false, true)
          } else {
            copy[item[0]] = item[1];
          }
        } else if (this[item]) {
          // console.log(item)
          copy[item] = this[item];
        }
      }
    }
    if (_val && (_val instanceof VObject && _val._contained)) {
      copy.val = _val.clone(copy, false, list, copy);
      copy._val._contained = true;
    } else {
      VObject.set.call(copy, _val, false, false, true);
    }
    for (i in this) {
      if (!_c(this._blacklist, i)) {
        // console.log(i)
        if (!shallow) {
          if (this[i] instanceof VObject) {
            //function( name, val, vobj, stamp, noupdate, from )

            // console.log('----->1', i, this[i].clone(void 0, false, list, copy))
            //stamp void 0
            copy.set(i, this[i].clone(void 0, false, list, copy), true, false, true)
          } else {

            // console.log('----->2', i, util.clone(this[i]))

            copy[i] = util.clone(this[i]);
          }
        } else {
          //function( name, val, vobj, stamp, noupdate, from )
          copy.set(i, this[i], false, false, true);
        }
      }
    }
    if (obj !== void 0) {
      if (util.isObj(obj)) {
        // console.log('MERGE----->', obj, shallow)
        copy.merge(obj, shallow);
      } else {
        VObject.set.call(copy, obj, false, false, true)
      }
    }
    copy.__t = this.__t;
    return copy;
  },
  /**
   * Returns object on the end of a defined path
   * @method path
   * @param  {Array}     path           Array of fields in path
   * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
   * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
   * @param  {Function}  [writeHandler] Callback on write
   * @return {*}                        Object on the end of a defined path
   */
  'path', function(path, val, overwrite, writeHandler, vobj, stamp, noupdate, self) {
    if(!(path instanceof Array)) path = path.split('.');
    return util.path(this, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self);
  },
  /**
   * Gets object from specified path. When path is a string checks for 'dotnotation'.
   * @method get
   * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
   * @return {*}                 obj[path]|nested object/value
   */
  'get', function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },

  //(val, stamp, from, noupdate, add)
  // '$set', function( val, stamp, from, update ) { //get does not need an array as path

  //   return VObject.set.call( this, val, stamp, from, !update )
    
  //     '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //   if (!noupdate) {
  //     (val, stamp, from, noupdate, add)
  //     // console.log(this._path, val)
  //     this._update(val, stamp, from, remove, added, oldval);
  //   }
    

  // },
  /**
   * Check if obj is empty exclude field names passed to list
   * @method empty
   * @return {Boolean} True/false
   */
  'empty', {
    get: function() {
      return util.empty(this, this._blacklist);
    }
  },
  '$empty', function( excludes, update ) {
      //get does not need an array as path
      var _this = this
      this.each( function( key ) {
        if( 
            !excludes 
              || typeof excludes === 'string'  
                 ? key !== excludes 
                 : !util.checkArray( excludes, key ) 
          )
        {
          if( this.remove ) 
          {
            this.remove( false, false, false, false, false, true )
          } 
          else 
          {
            // console.warn( '$empty non-vObject object.util remove', this, key )
            _this[key] = null
          }
        }
      })
    
      if( this.clearCache ) this.clearCache()

      if( update )
      {
        this._update('empty')
      }
  },
  /**
   * Returns the V.Object from which the current update originated.
   * @method _updateOrigin
   * @return {V.Object} origin of the update
   */
  '_updateOrigin', {
    get: function() {
      var mark = this;
      // console.error('get UPDATE ORIGIN', this._path, this._lfrom)
      while (mark._lfrom) {

        //if V.CloudData
       // console.error( '_update that origin!', mark._path )
        mark = mark._lfrom;
      }
      return mark;
    }
  },
  '_origin', {
    get: function() {
      var mark = this;
      while (mark && mark.__t === 4) {
        mark = mark._val;
      }
      return mark;
    }
  }
)


//add find


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js":[function(require,module,exports){
(function (__dirname){
var util = require('../')
  , ajax
  , PACKAGE = '/package.json'

module.exports = exports = function( callback, params, packageFile, noReplace ) {

  packageFile = packageFile || ( util.isNode ? {} : window.package )

  var obj = {}
    , req = module.exports
    , cb = callback && function( pckg ) {

      obj = pckg.vigour
      req.parse( obj, packageFile, req._checks )

      if(!noReplace) module.exports = obj
      callback(obj)
    }

  //default option add more!
  if(!params) {
    exports.options.val(obj, cb, false, packageFile )
  } else if(exports.options[params]) {
    exports.options[params](obj, cb, false, packageFile )
  } else {
    exports.options.val(obj, cb, params, packageFile )
  }
  return obj
}

if(util.isNode) {
  exports.options = {
    val:function( obj, callback, params, pckg ) {
      callback( pckg )
    }
  }
} else {
  ajax = require( '../../browser/network/ajax' )
  exports.options = {
    val:function(obj, callback, params) {
      if( !window.package ) {
        var domain = !window.cordova && String(window.location)
            .match(/https?:\/\/([^\/]+)/)

        if(domain) domain = domain[0]
         
        ajax({
          url:params && params.url ? params.url : domain+PACKAGE,
          fallback: [
              { url: PACKAGE } //for testing
            , params && params.fallback ? params.fallback : { url: __dirname+PACKAGE }
            , { url: '../'+PACKAGE }
            , { url: '../../'+PACKAGE }
            , { url: '../../../'+PACKAGE }
          ],
          complete:function(data) {
            window.package = data
            if(callback) callback(data)
          }
        })
      } else if(callback) {
        callback(window.package)
      }
    }
  }
}

exports.inject = function() {
  exports._checks = util.arg(arguments)
  return exports
}

exports.loop = function(obj, option, pckgval, merge, fn, params ) {
  if(fn) {
    var val = option(obj,pckgval,merge, params)
    if(val) { util.merge(obj,val) }
  } else {
    for(var h in obj[option]) {
      if((pckgval===h)) {
        util.merge(obj,merge[h])
        break
      }
    }
  }
}

exports.parse = function( obj, pckg, options, params ) {
 if(!(options instanceof Array)) {
    options = [options]
 }

 for(var i in options) {
    for(var check in options[i]) {
      var pckgval = util.get(pckg,check)
        , option = options[i][check]

      exports.loop(obj, option, pckgval, obj[options[i][check]], typeof option === 'function',params)
    }
  }
  return obj
}

}).call(this,"/node_modules/vigour-js/util/config")

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../browser/network/ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/ua.js":[function(require,module,exports){
var ua = require('../../browser/ua')
  , util = require('../')
  , Data = require('../../data').inject(require('../../data/selection'))
/*
selection!

*/
bla = exports

exports.parse = function(obj, pckgval, merge, params) {
  var _ua = ua

  if(params && params.ua) {
    _ua = ua.parse(params.ua.toLowerCase(),{})
  }

  // console.log('HERE!',obj,pckgval,merge)
  var cond
    , uaclone = new Data({bla:util.clone(_ua)})

  if(obj.ua) {
    for(var i in obj.ua) {
      if(_ua.platform===i||_ua.device===i||_ua.browser===i) {
        return obj.ua[i]
      } else if(obj.ua[i].condition) {
        if(!cond) {
          cond = new Data(uaclone, obj.ua[i])
        } else {
          cond.filter = obj.ua[i]
        }
        if(cond.length) {
          delete obj.ua[i].condition
          cond.remove()
          return obj.ua[i]
        }
      }
    }
  }


  //blabla

  // console.log('SUBOBJ???',obj)


  delete obj.subsObj

  if(cond) cond.remove()
}


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js":[function(require,module,exports){
(function (process){
var debug = exports

DEBUG$ = debug

/*
  console.log('util/test \n\nif you want to check memory usage start chrome using: \n\n open -a Google\\ Chrome --args --enable-memory-info \n')
*/
var util = require('../')
  , isNode = util.isNode //has to become part of util
  , V = require('../../')
  , log = debug.log = require('./log')
  , debuglog = log.logger('DEBUG$', 'rainbow')

debug.perf = debug.performance = require('./performance')

//------------------------------------------------------------------------------

if(!isNode) {
  debug.cases = require('../../browser/cases/')
  exports.body = document.body.base
  Object.defineProperty(module.exports, 'domain', {
    get: function() {
      //debugger --- can go away with a transform
      return String(window.location)
        .match(/https?:\/\/([^\/]+)/)[1]
        .replace(/:.+/, '')
    }
  })

} else {
  var DEBUG = process.env.DEBUG
  if(DEBUG){
    var levels = DEBUG.split(',')
    for(var l in levels){
      var two = levels[l].split(':')
      DEBUG$.level[two[0]] = two[1] ? Number(two[1]) : 3
    }
  }
}

//------------------------------------------------------------------------------

exports.int = function(rand, fn) {
  function func() {
    rand = rand||1000
    return ~~(Math.floor(Math.random()*rand))
  }
  return fn ? func() : func
}

exports.text = function (length, fn, str, nolines, strict) {
  if (fn) {
    return function() {
      return exports.text(
        Math.round(Math.random() * length) + 1, false, str, nolines, strict
      )
    }
  }
  else {
    var s = ['.', '.', '.', ';', ',']
      , b = ['ab', 'able', 'zo', 'x', 'lax', 'bur', 'rem', 'lur', 'fur', 'jur', 'lex', 'rex', 'wurd',
        'shur', 'burn', 'heps', 'a', 'i', 'y', 'u', 'e', 'p', 'l', 'splurf']
      , output = ''
      , nospace = 0

    if (str) b = str

    str = function () {
      return b[Math.round(Math.random() * (b.length - 1))]
    }
    if (!length) length = ~~ (Math.random() * 101)
    for (var i = 0, g; i < length; i++) {
      if ( !strict && (!output[output.length - 1]
        || output[output.length - 2] === '.'
        || output[output.length - 2] === '\n')
      ) {
        g = str()
        output += g[0].toUpperCase() + g.slice(1)
      }
      else {
        output += str()
      }
      nospace++
      if (!strict && ~~(Math.random() * (nospace / 2))) {
        var br = false
          , v
        if (!nolines && ~~(Math.random() * 21) > 17) {
          v = s[~~(Math.random() * (s.length - 1))]
          output += v
          if (v === '.' && ~~(Math.random() * 11) > 6) {
            br = true
            output += '\n'
            if (~~(Math.random() * 11) > 7) output += '\n';
          }
        }
        if (!br) output += ' '
        nospace = 0
      }
    }
    return output
  }
}

exports.data = function (populate, level, obj, cnt, prev) {
  if (!obj) obj = {}
  if (!cnt) cnt = 0
  if (!level) level = 0
  for (var i in populate) {
    if ((populate[i] instanceof Object)
      && populate[i].length && populate[i].val
    ) {
      if (populate && populate[i]) {
        obj[i] = []
        for (var j = 0; j < populate[i].length; j++) {
          obj[i][j] = typeof populate[i].val === 'function'
            ? populate[i].val()
            : exports.data(populate[i].val, (level + 1), false, j + 1, obj)
        }
      }
    }
    else if ((populate[i] instanceof Object)
      && (typeof populate[i] !== 'function')
    ) {
      obj[i] = exports.data(populate[i], (level + 1), obj[i], false, cnt, obj)
    }
    else if (populate && populate[i]) {
      obj[i] = (typeof populate[i] === 'function')
      ? populate[i].call(obj, cnt, prev)
      : populate[i];
    }
  }
  return obj;
};

//------------------------------------------------------------------------------
debug.download = function(filename, text) {
  var pom = document.createElement('a');
  pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  pom.setAttribute('download', filename);
  pom.click();
}

//------------------------------------------------------------------------------
debug.remote = function(id) {
  var fileref = document.createElement('script')
  fileref.setAttribute("type", "text/javascript")
  fileref.setAttribute("src", 'http://jsconsole.com/remote.js?'+id)
  document.getElementsByTagName("head")[0].appendChild(fileref)
}

debug.findScript = function(node,name,strict) {

  var children = node.childNodes
    , extension = name.match(/\.([a-zA-Z0-9]{1,30})$/)[1]
    , regExp = !strict && new RegExp(name+'$')
    , field = extension === 'js' ? 'src' : 'href'

  for(var i in children) {

    if(strict ? children[i][field]===name : regExp.test(children[i][field])) {
      return children[i]
    }

  }

  // console.log('notfound', name)
}

function prompty (msg, value, cb) {
    var dialog = document.createElement("div")
        , p = document.createElement("p")
        , input = document.createElement("input")
        , ok = document.createElement("button")
        , cancel = document.createElement("button")
    p.appendChild(document.createTextNode(msg))
    input.type = "text"
    input.value = value
    input.style.display = "block"
    ok.appendChild(document.createTextNode("OK"))
    cancel.appendChild(document.createTextNode("Cancel"))
    ok.addEventListener('click', function () {
        hideDialog()
        cb(input.value)
    })
    cancel.addEventListener('click', function () {
        hideDialog()
        cb(null)
    })
    dialog.appendChild(p)
    dialog.appendChild(input)
    dialog.appendChild(ok)
    dialog.appendChild(cancel)
    dialog.style.position = "absolute"
    dialog.style.top = 25 + "px"
    dialog.style.left = 50 + "px"
    dialog.style.zIndex = 1000
    dialog.style.fontSize =  24 + 'px'
    dialog.style.backgroundColor = "white"
    document.body.appendChild(dialog)
    function hideDialog() {
        dialog.parentNode.removeChild(dialog)
    }
}

debug.native = function(def, parse, cb, file) {
  if(!document.getElementById('dev')) {
    var elem = document.createElement('div')
    elem.id = 'dev'
    elem.style.zIndex = 9999999
    elem.style.position = 'absolute'
    elem.style.left = '2px'
    elem.style.top = '80px'
    elem.style.padding = '15px'
    elem.style.backgroundColor = 'rgba(50,50,50,0.8)'
    elem.style.borderRadius = '50%'
    elem.addEventListener('click',function() {
      prompty('IP', localStorage.getItem('devip') || def || 'http://10.0.1.2:8080', function (ip) {
        if (ip) {
          localStorage.setItem('devip',ip)
           window.location.reload()
        } else {
          // alert('x')
          localStorage.removeItem('devip')
          window.location.reload()
        }
      })
    })
    document.body.appendChild(elem)
  }

  if(!file) {
    file = 'build'
  }

  if( localStorage.getItem('devip') ) {
    DEBUG$.remoteResource(localStorage.getItem('devip')+'/bundle.css',file+'.css',false)
    if(DEBUG$.remoteResource(localStorage.getItem('devip')+'/bundle.js',file+'.js',false)) {
      document.getElementById('dev').style.backgroundColor = 'rgba(0,255,0,0.8)'
      if(cb) cb(localStorage.getItem('devip'))
      return true
    } 
  }
}

//hier remoteresource gebruiken
debug.remoteResource = function(src, replace, strict) {
  console.log('remote resource',src)
  var strict = strict !== void 0 ? strict : true
    , extension = src.match(/\.([a-zA-Z0-9]{1,30})$/)[1]
    , fileref = document.createElement(extension==='js' ? 'script' : 'link')
    , head =  document.getElementsByTagName("head")[0]
    , body = document.body
    , found
    , fileSrc

  if(!replace) {
    strict = false
    replace = src.match(extension==='js'
      ? /(\/)([a-zA-Z0-9-_+$]){0,30}\.js$/
      : /(\/)([a-zA-Z0-9-_+$]){0,30}\.css$/
    )[0].slice(1)


  }

  fileSrc = src+'?'+ ~~(Math.random()*9999999)

  if(extension==='js') {
    fileref.setAttribute("type", "text/javascript")
    fileref.setAttribute("src", fileSrc)
  } else {
    fileref.setAttribute("type", "text/css")
    fileref.setAttribute("rel", "stylesheet")
    fileref.setAttribute("href", fileSrc)
    fileref.setAttribute("id", fileSrc)
  }

  found = debug.findScript(head,replace,strict)

  if(!found) {
      console.log(body, found, '!@!@#!@#JS')

    found = debug.findScript(body,replace,strict)
  }
  if(found) {

    console.log('remote resource found:',found, found.src , fileSrc, src)

    var parent = found.parentNode
    if(String(found.src).indexOf(src)>-1) {
      return
    }

    parent.removeChild(found)
    parent.appendChild(fileref)
    return true
  }
}

}).call(this,require('_process'))

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../browser/cases/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","./log":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/log.js","./performance":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/performance.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/log.js":[function(require,module,exports){
var debug = require('./') 
  , util = require('../') 
  , isNode = util.isNode //has to become part of util
  , V = require('../../')
  , repl
  , colors
  , origConsole = console
  , colors = {
      green:'#56db68',
      red:'#ff0000',
      grey:'#ccc',
      yellow:'#e0e67c',
      cyan:'#00ffff',
      magenta:'#ff00ff',
      blue:'#1111ff',
      white:'#fff'
    }
  , styles = {
      bold:'font-weight:bold;font-size:16px;line-height:15px',
      underline:'border-bottom:1px solid',
      italic:'font-style:italic',
      inverse:function(color) {
        if(color) {
          return color+';background-color:#333;padding:5px;line-height:20px'
        } else {
          return 'color:'+colors.white+';background-color:#333;padding:5px;line-height:20px'
        }
      }
    }

debug.level = 
{ DEBUG$: Infinity
, test:2
}



/*
bold
italic
underline
inverse
yellow
cyan
white
magenta
green
red
grey
blue
rainbow
zebra
random
*/

//------------------------------------------------------------------------------

var logObject
  , parseObject
  , LOG
  , INFO
  , ERROR
  , DETAIL

if (!isNode) { 

  LOG = ':'
  INFO = '::'
  ERROR = 'ERREX!'
  DETAIL = ':::'

  // console = {}
  function loglink(i) {
    return function() {
      // console.log(i, arguments)
      // console.log(new Error().stack)

      origConsole[i].apply(origConsole, arguments)
    }
  }

  // for(var i in origConsole) {
  //   if(i !== 'log') console[i] = loglink(i)
  // }

  var Color = function(val,code,s) {
    this.color =  (s ? code : 'color: '+code)+';'
    this.val = new String('%c'+val)
  }
  
  // console.log = function() {

  //   var next = false

  //   for(var i=0, arg, rargs=[], args = arguments,len = args.length;i<len;i++) {
  //     arg = args[i]
  //     if(arg instanceof Color) {
  //       if(rargs.length){
  //         next = util.arg(args, i)
  //         break
  //       }else{
  //         rargs.push(arg.val.valueOf(), arg.color)
  //       }
  //       // logger(arg.val.valueOf(), arg.color)
  //     } else {
  //       rargs.push(arg)
  //     }
  //   }
  //   // logger('now log', rargs)
  //   if(rargs.length) logger.apply(origConsole,rargs)
  //   // logger('next', next)
  //   if(next.length) console.log.apply(null,next)

  // }

  function color(i, Class, style) {
    util.define(Class || String,i,{
      get:function() {
        if(Class) {
          if(typeof style === 'function') {
            this.color = style(this.color)
          } else {
            this.color+=(style||('color:'+colors[i]))+';'
          }
          return this
        } else {
          var s = colors[i]
          if(style) {
            if(typeof style === 'function') {
              s = style()
            } else {
              s=style
            }
          }
          return new Color(this,s,style)
        }
      }
    })
  }

  // function logger() {


  //   origConsole.log.apply(origConsole,arguments)


  // }

  // for(var i in colors) { color(i) }
  // for(var i in styles) { color(i, false, styles[i]) }  
  // for(var i in colors) { color(i, Color) }
  // for(var i in styles) { color(i, Color, styles[i]) }  

  parseObject = function(obj) {
    if(typeof obj === 'string') return obj
    var str = ''
    for(var i in obj) {
      str += i + ' : ' + (typeof obj[i] === 'string' 
        ?  obj[i] 
        : JSON.stringify(obj[i],false,2)) 
      + '\n'
    }
    return str.inverse.green
  }
  
  logObject = function(obj) {
    console.log(parseObject(obj))
  }
  
} else {
  repl = require('repl')
  colors = require('colors')

  LOG = 'log  '.grey
  INFO = 'info '.green
  ERROR = 'error'.red
  DETAIL = '-----'.grey

  debug.repl = function() {
    repl.start('>')
    return debug
  }
  if(repl.context) repl.context.DEBUG$ = DEBUG$

  console.group = function() {
    console.log('\n____________________________________________________'.grey)
  }      
  console.groupEnd = function() {
    console.log('____________________________________________________\n'.grey)
  }
  var n_util = require('util')
  parseObject = function(obj){
    return n_util.inspect(obj,{colors:true, depth: 50})
  }
  logObject = function(obj){
    console.log(parseObject(obj))
  }
}

//------------------------------------------------------------------------------

util.define(Object,'DEBUG$log', function(msg,s) {
  if(console.group) console.group()
  if(typeof msg === 'string') {
    msg = msg
  } else {
    msg = false
  }
  var h = 'JSON '+(msg||' normal')
  debug.log.header(h)
  if(debug.level.test>1) console.log(JSON.stringify(this,false,2))
  if(s) {
    console.log('\n')
    debug.log.fn.apply(this,util.arg(arguments,1)) 
  }
  // debug.log.end(h)
  if(console.group) console.groupEnd()
  return JSON.stringify(this,false,2)
})

if(!isNode && localStorage) {
  util.define(localStorage,'DEBUG$log', function(msg,s) {
    if(console.group) console.group()
    if(typeof msg === 'string') {
      msg = msg
    } else {
      msg = false
    }
    var h = 'localStorage '+(msg||' normal')
    debug.log.header(h)

    var obj = {}
    for(var i in this) {
      // console.log(i, this)
       try { obj[i] =JSON.parse(this[i]) } catch(e){
        obj[i] = this[i]
       }
    }

    // console.log()

    if(debug.level.test>1) console.log(JSON.stringify(obj,false,2))
    if(s) {
      console.log('\n')
      debug.log.fn.apply(this,util.arg(arguments,1)) 
    }
    // debug.log.end(h)
    if(console.group) console.groupEnd()
    return obj
  })
}

//------------------------------------------------------------------------------

var log = module.exports = exports = {
  stack: false,
  i:function(nr) {
    nr = this.indent
    var str = ''
    for(var i in nr) {
      str+='  '
    }
    return str
  },
  parse: parseObject,
  object: logObject,
  default: function(label, level){
    if(label instanceof Object)
      for(var l in label)
        setDefault(l, label[l])
    else
      setDefault(label, level)
  },
  logger:function(label, color, level){
    log.default(label, level || 1)
    
    function logger(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 2) {
//         console.log.apply(null, [label[color].bold, LOG].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
    }

    logger.info = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 1) {
        console.log.apply(null, [label[color].bold, INFO].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
        
    }
    logger.error = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 0) {
        console.log.apply(null, [label[color].bold, ERROR].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
    }
    logger.detail = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 3) {
        console.log.apply(null, [label[color].bold, DETAIL].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }      
    }
    logger.parse = parseObject
    return logger
  },
  label: function(label, style, log){
      if(isNode) {
        console.log.apply(null, log)
      } else {
        console.log.apply( null
          , ['%c '+label+' ', style].concat(log)
        )
      }
  },
  header:function(msg) {
    this._lh = msg
    console.log(msg.inverse)
  },
  header2:function(msg) {
    this._lh = msg
    console.log(msg.grey.inverse)
  },
  end:function(msg) {
    console.log(('end ['+msg+']').grey.inverse)
  },
  level:function(level,field) {
    if(level >= debug.level.test 
      ||  debug.level[level] 
      || field && debug.level[level]>=field ) 
      console.log.apply(this,util.arg(arguments,1))
  },
  fn:function(arg) {
    debug.log.indent++
    if(typeof arg === 'function') {
      arg.call(this,util.arg(arguments,1))
    } else {
      console.log(arguments)
//       console.log.apply(this,arguments)
    }
    debug.log.indent--
  },
  indent:0
}

//------------------------------------------------------------------------------
function smallStack(lines){
  if(!lines) lines = 1
  var stack = new Error().stack.split('\n')
    , l = 3
    , result = []
    , end

  while(lines--){
    line = stack[l++]
    end = line[line.length-1] === ')' ? line.length-1 : line.length
    result.push(line.slice(line.indexOf('/'), end))
  }

  return result.join('\n').grey
  
}

function setDefault(label, level){
  if(debug.level[label] === void 0) debug.level[label] = level
}

setTimeout(function() {
//   console.log('log levels:\n', log.parse(debug.level))
},0)

//Localstorage

/*
var localStorageSpace = function(){
        var allStrings = '';
        for(var key in window.localStorage){
            if(window.localStorage.hasOwnProperty(key)){
                allStrings += window.localStorage[key];
            }
        }
        return allStrings ? 3 + ((allStrings.length*16)/(8*1024)) + ' KB' : 'Empty (0 KB)';
    };

*/

util.define(debug,'localStorageSize', {
  get:function() {
  var total = 0
  for(var x in localStorage) {
    var kbytes = (((x.length+localStorage[x].length))/(1024))
    total+=kbytes
    // console.log((x+":"+kbytes.toFixed(10)+" KB").grey)
  }
  console.log('LOCAL STORAGE SIZE TOTAL'.inverse.green, (total/1024).toFixed(5)+' MB')
  return total*1024
}
})

util.define(debug,'localStorageKeysSize', {
  get:function() {
  var total = 0
  for(var x in localStorage) {
    var kbytes = (((x.length))/(1024))
    total+=kbytes
    // console.log((x+":"+kbytes.toFixed(10)+" KB").grey)
  }
  console.log('LOCAL STORAGE KEY SIZE TOTAL'.inverse.green, (total/1024).toFixed(5)+' MB')
  return total*1024
}
})



},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js","colors":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/colors/colors.js","repl":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js","util":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/performance.js":[function(require,module,exports){
(function (process){
var util = require('../') 
  , debug = require('./') 
  , isNode = util.isNode //has to become part of util
  , os

if (isNode) { 
  os = require('os')
} else {
  console.log('DEBUG \n\nif you want to check memory usage start chrome using: \n\n open -a Google\\ Chrome --args --enable-memory-info --js-flags="--expose-gc"\n'.grey)
}

function _test(method, name, complete, call, args, nolog) {
  var start = exports.now()
    , memorystart = exports.memory()
    , memoryend
    , mem
    , time
    , end
    , sub 
  if (!name) name = 'TEST PERFORMANCE'
  if (call) {
    sub = method.apply(call, args)
  } 
  else {
    sub = method.apply(this, args)
  }
  end = exports.now()
  memoryend = exports.memory()
  mem = (memoryend - memorystart)
  time = end - start - (sub || 0)
  if (complete) {
    complete(((time) / 1000), (memoryend - memorystart))
  } 
  else if (!nolog) {
    if(debug.level.test>0) {
      console.log( 
        name.inverse , '\nparse time: ' 
        + ((end - start) / 1000) 
        + ' sec' + (mem ? '\nmemory used (approximate): ' 
        + mem + ' bytes' : '')
      )
    }
  }
  return time
}



var oldCheck = []
debug.countNewListeners = function( obj, amount ) {
  
  amount = {val:0}

  var checknow = []

  debug.countListeners( obj, amount, checknow ) 

  var newlistners = []

  for( var i in checknow ) {

    if( util.checkArray( oldCheck, checknow[i] ) === false ) {
      // console.log(checknow[i])
      // if( typeof checknow[i] === 'object' || typeof checknow[i] === 'function' ) {
        // console.log('lets push')
        // if(!util.empty(checknow[i])) {
        newlistners.push( checknow[i] )
        // }
      // }
    }
  }

  oldCheck = checknow

  return {
    amount: amount.val
  , newchecks: newlistners
  }

}


debug.countListeners = function(obj, amount, checked) {
  var amount 
    , checked 

  if(!checked) {
    checked = []
  }

  if(util.checkArray(checked, obj)!==false || !obj) {
    return amount.val
  }
  checked.push(obj)

  if(!amount) amount = {val:0}
  if(obj._listeners) {
    amount.val+=obj._listeners.length
  }

  if(!obj.each) {

    if(obj instanceof Object) {
      for(var i in obj) {
        if(obj[i] && ( obj[i].__t || obj[i]._from || obj._from && i ==='cloud') ) debug.countListeners(obj[i],amount,checked)
      }
    }

  } else {

    obj.each(function(i) {
      debug.countListeners(this,amount,checked)
    })

  }

  return amount.val
}

debug.countSubs = function(obj, amount, key) {
  var amount 
  if(!amount) amount = {val:0}
  if(obj._subs) {
    console.log('!!!!!SUB', obj._path, obj._subs)
    amount.val+=obj._subs.length
  }
    
  if(!obj.each) {
    console.log('no EACH!', key)
  }
  // console.log(obj, obj._subs)
  obj.each(function(i) {
    debug.countSubs(this,amount,i)
  })
  return amount.val
}

function _done(params, time, mem) {
  if (params.complete) {
    params.complete(time, mem, params, exports.average(time)[0], exports.average(time)[1])
  } else {
    if(debug.level.test>0) {
      console.log(
        params.name.inverse 
        , ' n=' + params.loop 
        + '\nparse time:' 
        + (params.extensive 
          ? (' \n\n' + time.join(' sec\n') + ' sec\n\n') 
          : '') 
        + 'average: ' + exports.average(time)[1] 
        + ' sec\ntotal: ' 
        + exports.average(time)[0] + ' sec')
    }
    //+(mem.length>0 ? '\nmemory used (approximate): '+mem+' kb' : '');
  }
}

module.exports = exports = function (params, fn) {
  if (fn && typeof params === 'string') {
    return _test(fn, params)
  } 
  else if (typeof params === 'function') {
    return _test(params)
  } 
  else if (params instanceof Object) {
    if(!params.name) params.name = 'performance test'

    if (params.loop) {
      //testing memory in loop is hard since the gc almost never makes it before next iteration;
      var time = []
        , mem = []
        , callback = function (_time, memory) {
          time.push(_time)
          if (memory) mem.push(memory)
        }

      if(params.interval) {
        var cnt = 0
          , interval = setInterval(function() {
              cnt++
              if(cnt===params.loop-1) {
                 clearInterval(interval)
                 _done(params, time, mem) 
              } else {
                _test(params.method, false, callback)
              }
            },params.interval)
      } else {
        for (var i = params.loop; i > 0; i--) {
          _test(params.method, false, callback)
        }
        _done(params, time, mem) 
      } 
      return exports.average(time)
    } 
    else {
      return _test(params.method
        , params.name
        , params.complete
        , params.call
        , params.args
        , params.nolog)
    }
  }
}

if(debug.log) debug.log.default('test', 4)

exports.now = function () {
  return isNode
    ? process.hrtime()[0] * 1000 + process.hrtime()[1] * 0.000001 
    : (window.performance && window.performance.now 
      ? window.performance.now() 
      : new Date().getTime())
}

exports.memory = function () {
  return isNode 
    ? process.memoryUsage().heapUsed 
    : (window && window.performance && window.performance.memory 
      ? window.performance.memory.usedJSHeapSize * 0.000976562 
      : 0)
}

exports.average = function (array) {
  var number = 0
  for (var i = array.length - 1; i >= 0; i--) {
    number += array[i]
  }
  return [number, number / array.length]
}

}).call(this,require('_process'))

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","os":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/os-browserify/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/global.js":[function(require,module,exports){
(function (process,global){
var g = typeof window !== 'undefined'
        ? window
        : typeof global !== 'undefined'
          ? global
          : false
  , hasLS = typeof localStorage !== 'undefined'
  , hasPR = typeof process !== 'undefined'

var G = module.exports = 
  { session: function(key, val){
      return getSet(g, key, val)
    }
  , env: function(key, val){
      if(hasLS)
        return getSet(localStorage, key, val, 'getItem', 'setItem')
      else if(hasPR)
        return getSet(process.env, key, val)
    }
  }

function getSet(thing, key, val, getter, setter){
  if(!thing)
    return

  if(val === void 0){
    if(getter)
      return thing[getter](key)
    else
      return thing[key]
  }else{
    if(setter){
      thing[setter](key, val)
      return val
    }else{
      return thing[key] = val
    }
  }
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js":[function(require,module,exports){
//check this for more compression http://www.htmlgoodies.com/html5/client/optimizing-websockets-bandwidth.html#fbid=6QZx8napu20

/*
var crcTable
  , create = function () {
      crcTable = []
      for (var c, n = 0, k; n < 256; c = ++n) {
        for (k = 0; k < 8; k++, c = ((c & 1) ? ((0xEDB88320) ^ (c >>> 1)) : (c >>> 1)));
        crcTable[n] = c
      }
      return crcTable
    }

exports = module.exports = function (str) {
  for (var tab = crcTable || create(), crc = -1, i = 0, l = str.length; i < l; i++) {
    crc = (crc >>> 8) ^ tab[(crc ^ str.charCodeAt(i)) & 0xFF]
  }
  return exports.encode(((crc ^ (-1)) >>> 0))
}


*/

exports = module.exports = function(key, seed) {
  var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;
  seed = 1

  remainder = key.length & 3; // key.length % 4
  bytes = key.length - remainder;
  h1 = seed;
  c1 = 0xcc9e2d51;
  c2 = 0x1b873593;
  i = 0;
  
  while (i < bytes) {
      k1 = 
        ((key.charCodeAt(i) & 0xff)) |
        ((key.charCodeAt(++i) & 0xff) << 8) |
        ((key.charCodeAt(++i) & 0xff) << 16) |
        ((key.charCodeAt(++i) & 0xff) << 24);
    ++i;
    
    k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

    h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
    h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
    h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
  }
  
  k1 = 0;
  
  switch (remainder) {
    case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
    case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
    case 1: k1 ^= (key.charCodeAt(i) & 0xff);
    
    k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= k1;
  }
  
  h1 ^= key.length;

  h1 ^= h1 >>> 16;
  h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
  h1 ^= h1 >>> 16;

  return (h1 >>> 0).toString(36)
}

// exports = module.exports = function( str )
// {
//   var FNV1_32A_INIT = 0x811c9dc5;
//   var hval = FNV1_32A_INIT;
//   for ( var i = 0; i < str.length; ++i )
//   {
//     hval ^= str.charCodeAt(i);
//     hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
//   }
//   return hval >>> 0;
// }

/**
 * Encode to base 62 (url save)
*/
exports.encode = function c (a, b) {
  b = b || ""
  return ~~ a 
       ? c(a / 62, String.fromCharCode(((a %= 62) > 9 
          ? a > 35 ? 29 : 87 
          : 48) + a) + b) 
       : b
}

/**
 * decode base 62
*/
exports.decode = function (a, b, c, d) {
  for (b = c = 0; d = a.charCodeAt(c++); b = b * 62 + d - [ , 48, 29, 87][d >> 5]);
  return b
}


// exports.decode64

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js":[function(require,module,exports){
module.exports = function id(pre, level){
  var r = rnd()
  if(level) 
    while(level--){
      r += rnd()
    }
  return pre ? pre + r : r
}

function rnd(){
  return Number(String(Math.random()).slice(2)).toString(36)
}
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
require('./object') //these things add extra methods to util for readability in a seperate module
require('./prop')


exports.isNode = (typeof window === 'undefined') ? true : false

/**
 * Add is similar to .push it returns the array instead of length
 * Can be extended to support more types e.g. add an object to another
 * @method add
 * @param  {Array}  obj Target
 * @param  {Object} add Object to add
 * @deprecated
 */
exports.add = function (obj, add) {
  if (add) obj.push.apply(obj, add);
  return obj
}

/**
 * Finds items in an array
 * @method checkArray
 * @param  {Object|Array}                 list  Defines the list where you want to search through, only uses .length field
 * @param  {Object}                       val   Defines the value you want to search for
 * @param  {Boolean|String|Number}        [index] When index is true return the index instead of true or false, when index and index !== true index is used as a field in objects in the array
 * @param  {String}                       [field] When field return field instead of index or true
 * @return {*}
 */
exports.checkArray = function (list, val, index, field) {
  var arr = index instanceof Array
  if(!list) return false
  for (var i = 0, l = list.length, t; i < l; i++) {
    t = list[i]
    if (index !== void 0) {
      if (index === true) {
        if (t === val) return i
      } else if (arr ? exports.path(t,index)===val : t[index] === val) return field ? t : i
    } else {
      if (t === val) return true
    }
  }
  return false
}

/**
 * Pass arguments (arguments) and return a new array, when index return a new array sliced from index
 * @method arg
 * @param  {Arguments} args        Arguments
 * @param  {Number}    [index = 0] When index return a new array sliced from index
 * @return {Array}
 */
exports.arg = function (args, index) {
  return Array.prototype.slice.call(args, !index ? 0 : index)
}

/**
 * Check if obj is empty exclude field names passed to list
 * @method empty
 * @param  {Object}       obj  Object
 * @param  {Object|Array} list Takes any object with .length
 * @return {Boolean}           True/false
 */
exports.empty = function (obj, list) {
  for (var i in obj) {
    if (!list || !this.checkArray(list, i)) return false
  }
  return true
}

exports.inject = require('./inject')

},{"./inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js","./prop":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/prop.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js":[function(require,module,exports){

var V = require('../')
  , util = require('./')

var $TEST
if(!util.isNode) {
  $TEST = window.$TEST
}



module.exports = exports = function(extend) {

  var args = arguments

  if(args[0]&&args[0].$TEST) {
     $TEST = window.$TEST = true
  }

  if( (typeof this === 'function') || (V.Base && (this instanceof V.Base)) || typeof this === 'object') {
    if((V.Base 
        && (this===V.Base 
        || (this.prototype instanceof V.Base)
        || (this instanceof V.Base))
      )) { 
      args = util.arg(args)
      args.unshift(this)
      extend = this
    } else {
      return inject.apply(this,args)
    }
  }
  for(var i = 1; i < args.length; i++) {
   makeExtend(extend, args[i])
  }
  return extend
}

function makeExtend(extend, module) {
  if($TEST) console.log('9', module, extend)
  if(module.extend) {
    if($TEST) console.log('9.1', extend)
     module.extend(extend)
  } else if(module instanceof Array) {
    var arr = module.concat()
      , mod = arr[0]
    arr[0] = extend
     if($TEST) console.log('9.2')
    mod.extend.apply(mod,arr)
  } 
} 

function inject() {
  if($TEST) console.log('5')
  //do special stuff voor blacklist
  // Custom.prototype = new this() //lighter
  var Custom
    , extendResidue = []
    , Aspects = [this]

  for (var i = 0, Aspect, args = arguments, len = args.length; i < len; i++) {
    
    Aspect = args[i]

    if(typeof Aspect === 'function') {
      if(!Custom) {
        Custom = function() {
          for (var j = 0, len = Aspects.length; j < len;  j++) {
            Aspects[j].apply(this, arguments)
          }
        }
        inherits( Custom, this )
      }
      Aspects.push(Aspect)
      for (var method$ in Aspect.prototype) if ({}.hasOwnProperty.call(Aspect.prototype, method$)) {
        if (method$ === 'constructor') continue
        Custom.prototype[method$] = Aspect.prototype[method$]
      }
    } else {
      if($TEST) console.log('6')
      if(Custom) {
              if($TEST) console.log('7')

       makeExtend(Custom , Aspect)
      } else {
        // if($TEST) console.log('8')
        extendResidue.push(Aspect)
      }
    }
  }

  if(!Custom) Custom = this
  
  for(var j in extendResidue) {
    // console.log('8.'+j, extendResidue[j], Custom)
    makeExtend(Custom,extendResidue[j])
  }

  return Custom
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor
  ctor.prototype = Object.create
    ( superCtor.prototype
    , { constructor: 
        { value: ctor
        , enumerable: false
        , writable: true
        , configurable: true
        }
      }
    )
}

/*
 Dit moet worden geadd voor V.Objects
/*
  object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)
      if (val !== void 0) this.val = val
      // console.log(constructor)
      if(constructor) constructor.apply(this,arguments)  
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

veel dingen werken als extension niet als losse class -- 

*/


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , vigour = require('../') //only here to be able to use util without vigour.Object maybe refactor this away?
  , DOT = '.'

/**
 * lookup
 * polyfill if __lookupSetter__ does not exist;
 */
exports.lookup = Object.__lookupSetter__ || function (i) {
  var t = this
    , a
  while (t) {
    a = Object.getOwnPropertyDescriptor(t, i)
    if (a && a.set) return true
    t = Object.getPrototypeOf(t)
  }
  return false
}

/**
 * Used to set a val to an field on a object, whether it is a vigour.Object or a regular object
 * @method set
 * @param {Object} obj   Defines target Object
 * @param {String} field Target field
 * @param {*}      val   Value to set
 * @todo                 Move this function to a different module (e.g. 'convenience' module)
 */
exports.set = function (obj, field, val, vobj, stamp, noupdate) {
  return (vigour.Object && (obj instanceof vigour.Object))
    ? obj.set(field, val, vobj, stamp, noupdate)
    : (obj[field] = val)
}


/**
 * Returns object on the end of a defined path
 * @method path
 * @example
 * // returns obj.a.b.c
 * var obj = { a: { b: { c: 1 }}}
 * V.util.object.path(obj,['a','b','c'])
 * @param  {Object}    obj            Object to search
 * @param  {Array}     path           Array of fields in path
 * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
 * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
 * @param  {Function}  [writeHandler] Callback on write
 * @param  {Boolean}   [noupdate]     When true, updates will be skipped on write
 * @param  {Number}    [i = 0]        Starting point for searching through path
 * @return {*}                        Object on the end of a defined path
 */

exports.path = function ( obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i ) {
  if (!i) i = 0

  var field = path[i]
    , result
    , c
    , target = (!self && obj && obj.__t === 4) ? obj.from[field] : obj && obj[field]
    , l = i < path.length - 1

  // if(field === void 0) {
  //   throw new Error('path must not contain undefined')
  // }

  if (l && !(target instanceof Object)) target = void 0

  if ((val !== void 0) && (target === void 0 || (!l && overwrite))) {
    c = true
    exports.set(obj, field, l ? {} : val, l ? false : vobj, stamp, noupdate)
    target = obj[field]
  }

  if (l) {
    result = target
      ? this.path(target, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, ++i)
      : target
  } else {
    result = (!self && target && target.__t === 4) ? target.from : target;
    if (c && writeHandler) writeHandler(result)
  }

  return result
}

/**
 * Adds path using 'dot-notation'
 * @method dotField
 * @example
 * // returns blur:{d:{a:{s:{}}}}
 * var blur = {};
 * V.util.object.dotField(blur,'d.a.s');
 * @param  {Object} obj   Object where field will be added
 * @param  {String} field String using 'dot-notation'
 * @return {Object}       Returns field
 */
exports.dotField = function (obj, field) {
  if (~field.indexOf(DOT)) {
    var path = field.split(DOT)
      , first = path.shift()
      , val = {}
    this.path(val, path, obj[field])
    delete obj[field]
    obj[first] = val
    field = first
  }
  return field
}

/**
 * Checks if two lists contain identical content
 * @method compareArrays
 * @param  {Array|Object} a         Takes any object with .length
 * @param  {Array|Object} b         Takes any object
 * @param  {Boolean}      keys      use Object.keys for b
 * @return {Boolean}      True/false
 * @todo                  Maybe change title => compareLists
 */
exports.compareArrays = function(a, b, keys) {
  var bl = keys ? Object.keys(b).length : b.length
  if (a.length !== bl) return false
  for (var i = a.length - 1; i >= 0; i--) {
    if (a[i] != b[i]) return false
  }
  return true
}

/**
 * Gets object from specified path. When path is a string checks for 'dotnotation'.
 * @method get
 * @example
 * // returns 'foo'
 * var a = {b:{c:'foo'}}
 * V.util.object.get(a,'b.c')
 * @param  {Object}       obj  Defines object or V.Value
 * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
 * @return {*}                 obj[path]|nested object/value
 */
exports.get = function (obj, path, self) {
  //TODO: make one interface for get

  if (!obj || !path) return
  if (!self && obj.__t === 4 && !obj._filter) obj = obj.from
  if (!(path instanceof Array)) {
    if (~path.indexOf(DOT)) {
      path = path.split(DOT)
    } else {
      return (!self && obj[path] && obj[path].from) || obj[path]
    }
  }
  //self is too far away in the arguments
  return this.path(obj, path, void 0, false, false, false, false, false, self)
}

/**
 * Returns true if an object is an instance of an object and not a function , V.Object or V.Base
 * @method isObj
 * @param  {Object}  obj Object to inspect
 * @return {Boolean}     True/False
 */
exports.isObj = function (obj) {
  return (obj instanceof Object
    && typeof obj !== 'function'
    && (!vigour.Object || !(obj instanceof vigour.Object))
    && (!vigour.Base || !(obj instanceof vigour.Base)))
}

/**
 * Creates new object with the same value , takes custom objects into account (new obj.constructor())
 * @method clone
 * @param  {Object} obj Object to clone
 * @return {Object}     Returns clone
 */
exports.clone = function (obj, exclude, shallow) {
  if (this.isObj(obj)) {
    var copy = new obj.constructor()
    for (var i in obj) {
      if(!exclude || !exclude[i])
        copy[i] = !shallow
          ? this.clone(obj[i], exclude)
          : obj[i]
    }
    return copy
  }
  return obj
};

/**
 * Merges object b into object a and returns object a
 * @method merge
 * @param  {Object} a Object a
 * @param  {Object} b Object b
 * @return {Object}   Object a
 */
exports.merge = function (a, b, norefs, overwrite) {
  for (var i in b) {
    var aisobj = util.isObj(a[i])
      , bisobj = util.isObj(b[i])

    if (aisobj && bisobj) {
      util.merge(a[i], b[i], norefs, overwrite)
    } else if(!norefs || !bisobj){
      if( overwrite === void 0
       || !(i in a)
       || typeof overwrite === 'function' && overwrite(a[i], b[i])
        ){
        a[i] = b[i]
      }

    }else{
      a[i] = b[i] instanceof Array ? [] : {}
      util.merge(a[i], b[i], norefs, overwrite)
    }
  }
  return a
}

// exports.resolve = function(a, b, bFrom, j) {
//   var same = true;
//   if(b instanceof Object) {
//     for(var i in b) {
//       if(a[i]!==void 0) {
//         if(exports.resolve(a[i],b[i],bFrom ? bFrom[i] : b[i],i)) {
//           if(bFrom) {
//             delete bFrom[i]
//           }
//         } else {
//           same = false
//         }
//       } else {
//         same = false
//       }
//     }
//     if(same) {
//       if(!(bFrom&&j!==void 0)) return true
//       delete bFrom[j]
//     }
//     return same;
//   } else {
//     if(a==b) {
//       if(bFrom&&j!==void 0) {
//         delete bFrom[j]
//       }
//       return true
//     }
//   }
// }

exports.resolve = function(a, b, bFrom, j) {
  // console.log('lolresolve\n',bFrom)
  var same = true;
  if(b instanceof Object) {
    for(var i in b) {
      if(a[i]!==void 0) {
        if(exports.resolve(a[i],b[i],(bFrom!==void 0 && bFrom!==null) ? bFrom[i] : b[i],i)) {
          if(bFrom!==void 0 && bFrom!==null) {
            if(bFrom[i]===null) {
              same = false
            } else {
              delete bFrom[i]
            }
          }
        } else {
          same = false
        }
      } else {
        same = false
      }
    }
    if(same) {
      if(!(bFrom&&j!==void 0)) return true
      delete bFrom[j]
    }
    return same;
  } else {
    if(a==b) {
      if(bFrom&&j!==void 0) {
        delete bFrom[j]
      }
      return true
    }
  }
}

/**
 * Adds value to array if it is not contained in array, executes handler on encountering val in array
 * @method include
 * @param  {Object|Array}   obj       Takes any object with .length
 * @param  {*}              val       Value to add
 * @param  {Function}       [handler] Function to execute on encountering val in array
 * @param  {Boolean}        arr       Include elements of val separately rather than including val itself
 * @return {Boolean}                  True/false
 */
exports.include = function (obj, val, handler, arr) {

  if(arr && val instanceof Array) {
    var ret = false
    for(var i = 0 , len = val.length; i < len; i++) {
      ret = exports.include(obj, val[i], handler)
    }
    return ret
  }

  var i = 0
    , l = obj.length
    , field
    , check

  if (obj.__t === 1) {
    for (;i < l; i++) {
      field = check = obj[i]
      if (check.__t === 4) check = check.from
      if (check === val || check.val === val) {
        if (handler) handler(field)
        return false
      }
    }
    obj.push(val)
    return true
  } else if (obj instanceof Array) {
    for (;i < l; i++) {
      if (obj[i] === val) {
        return false
      }
    }
    obj.push(val)
    return true
  }
}

exports.changeType = function( obj ) {
  var result
  if(obj instanceof Array) {
    result = {}
    for(var i=0,len=obj.length;i<len;i++) {
      result[i]=obj[i]
    }
  } else {
    result = []
    for(var i in obj) {
      result.push(obj[i])
    }
  }
  return result
}

/**
 * Ensures a value is not or contains no V.Objects, only their "raw" versions
 * This needs to be unified with convert, or at least get a better name.
 * @method raw
 * @param  {*}   val   the value to be processed
 * @return {*}         the processed value
 */
exports.raw = function( val, rparams ) {
  if (val instanceof Object) {
    if (val instanceof vigour.Object) {
      return val.raw
    } else {
      var result
      if (val instanceof Array) {
        result = []
        for (var i = 0, l = val.length; i < l; i++) {
          result[i] = this.raw(val[i], rparams)
        }
      } else {
        result = {}
        for (var f in val) {
          result[f] = this.raw(val[f], rparams)
        }
      }
      return result
    }
  } else {
    return val
  }
}

//add level and stops for certain branches
exports.walk = function(obj, fn ) {
  for(var i in obj) {
    if(obj[i] instanceof Object) {
      if(!fn(i, obj[i], obj, true)) {
        if(exports.walk(obj[i], fn)) return true
      } else {
        return true
      }
    } else {
      if(fn(i, obj[i], obj)) {
        return true
      }
    }
  }
}

exports.checkParentFactory = function( parentField ) {
  return function(field, get, links, match) {
    if(get&&get!==true) {
      match = get
      get = false
    }
    var fields = field instanceof vigour.Object ? false : field,
      curr = this,
      found;
    while (curr) {
      found = fields === false ? curr === field : exports.get(curr, fields, !links);
      if (found) {
        if(match) {
          if(match === found || (found instanceof vigour.Object) && found.val === match) {
            return !get && fields ? curr : found;
          }
        } else {
          return !get && fields ? curr : found;
        }
      }
      curr = curr[parentField];
    }
  }
}

exports.disjoin = function disjoin(a, b, check) {
  // console.log('disjoin!')
  var fncheck = typeof check === 'function'
  
  a = getEndpoint(a)
  b = getEndpoint(b)

  a.each(function(){
    var item_a = this
    var item_a_from = item_a.from
    var remove
    b.each(function(){
      var item_b = this
      var item_b_from = item_b.from
      
      
      if(fncheck){
        remove = check(item_a_from, item_b_from)
      } else if(check === true){
        remove = item_a_from === item_b_from
      } else {
        // console.log('compare a', item_a_from.raw, 'to b', item_b_from.raw)
        // console.log('field', check)
        // console.log('a:', item_a_from[check].val)
        // console.log('b:', item_b_from[check].val)
        // console.log('same:', item_a_from[check].val === item_b_from[check].val)

        remove = item_a_from[check] && item_b_from[check] &&
          item_a_from[check].val === item_b_from[check].val
      }
      return remove
    })
    if(remove){
      // console.log('YES CHECK REMOVE')
      // TODO: 
      item_a.remove()
    }
  })

}

function getEndpoint(obj){
  while(obj && obj.__t === 4 && !obj._filter){
    obj = obj._val
  }
  return obj
}

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/process.js":[function(require,module,exports){
//processes
var vObject = require('../object')

// console.log('init process!')

module.exports = {}

},{"../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/prop.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , V = require('../')
/**
 * Setstores are used to avoid updates troughout prototype chains for changes of fields on objects
 * It uses two fields
 *   .__ to indicate own values for pieces of an object inherited trough the prototype chain
 *   ._ is the refence back to the objects as ste in the prototype
 * @constructor setstore
 */
exports.setstore = function() {
  if ( !this.__ ) this.__ = {}
}

//TODO: reconstruct value using pieces of objects in __

exports.getStore = function( name ) {
  return this.__ 
          ? ( this.__[name] !== void 0 
            ? this.__[name] 
            : this._[name]
            ) 
          : this._ && this._[name]
}

function extensions( extend, fn, base, args, extended ) {
    
  if(window.$TEST) {
    console.log(12, extend)
  }

  if( !extend.extensions ) 
  {
    if(base) {
      extend.extensions = []
    } else {
      // console.log(extend)
      if(V.Object && extend instanceof V.Object ) {
        util.define( extend, 'extensions',[])
      } else {
        //gebruik deze extension stylo
        util.define( extend, 'extensions',{val:[], setClass:true} )
      }
    }
  }

  // console.log( 'EXTEND'.red, extend.extensions, base, fn, this, extended )

  if( util.checkArray( extend.extensions, this )===false ) 
  {

    // console.log( 'EXTEND -2'.red, this )

    if( !extended ) extend.extensions = [ this ].concat( extend.extensions ) 

      // console.log( 'EXTEND -3'.red, extend.extensions )
      //somethin weird!

    // console.log( 'EXTEND -3'.red, this, extend, extend.extensions.length )

    var myArgs = util.arg( args )
    if( base && !extended ) {
      myArgs[0] = base
    }
    if(window.$TEST) console.error('??xxx?', myArgs, fn, this)
    var ret = fn.apply( this, myArgs ) //this is the app, extend is the extension 
    if(window.$TEST, ret)
    return ret
  } else {
    if(window.$TEST) console.error('???')
  }

}

exports.extend = function() {


  var extendArray = util.arg( arguments )

  return function(extend) {

    if(window.$TEST) console.log('10 --->', extend)

    var base
      , proto

    if( typeof extend === 'function' ) 
    {
      if( V.Base && ( extend.prototype instanceof V.Base ) ) {
        base = extend.base
        proto = true
      } else {
        proto = extend.prototype
      }
    } else if( V.Base && ( extend instanceof V.Base ) ) 
    {
      proto = extend
    }

    for
    ( 
      var fn
        , ret
        , args = util.arg( arguments )
        , extendArr
        , xArg
        , i = 0
        , len = extendArray.length
        ; i < len
        ; i ++ 
    ) 
    {    
      if(extendArray[i] instanceof Array) 
      {
        extendArr = extendArray[i][0]
        xArg = util.arg(extendArray[i],1)
        xArg.unshift(extend)
      } else 
      {
        xArg = args
        extendArr = extendArray[i]
      }

      if(window.$TEST) {
        console.log('11',  extendArr.extend ?  extendArr : this, base || proto  )
      }

      ret = extensions.call 
      ( extendArr.extend ?  extendArr : this 
      , base || proto || extend
      , extendArr.extend ||  extendArr
      , base
      , xArg
      , extendArr.extend ? true : false 
      ) 
      || extend

    }
    return ret
  }

}

/**
 * Add is used as a shortcut method for Object.defineProperty and extends setstore functionality to normal prototypes
 * @method add
 * @param  {Object}          obj  When obj is a constructor it selects obj.prototype, when obj is a normal object this is used instead
 * @param  {String|Array}    name When name is a string it adds the name for the object, when name is a array do the same setting for each name
 * @param  {Object|Function} val  When val is an object , use this object for Object.defineProperty with default for enummerable:false, when object is empty adds {value:{},ennumerable:false}, when val is a function it automatically wraps a property definition object with {value: val , enummerable:false}, when val is not a function and not an object (boolean, string, number) adds special setstore value
 * @param  {Function}        [set]  Adds custom setters to a setstore object, when set is a string the add functions interprets the arguments as name : property definition pairs
 * @param  {Function}        [get]  Adds custom getters to a setstore object
 * @
 */
exports.define = function (obj, name, val, set, get, id) {
  if (typeof set === 'string') {
    var _args = util.arg(arguments)
    for (var i = 1, l = _args.length; i < l; i += 2) {
      exports.define(obj, _args[i], _args[i + 1])
    }
  } else {
    if (name instanceof Array) {
      for (var i = 0, l = name.length; i < l; i++) {
        exports.define(obj, name[i], val)
      }
    } else {
      if (typeof val === 'function' || val instanceof Array) {
        val = {
          enumerable: false,
          value: val,
          configurable: true
        }
      } else if (!val || ( !(val instanceof Object) || val.setClass  )) {

        if( val && val.setClass ) {
          val = val.val
        }

        var proto = obj.prototype || obj


        //

        //TODO: not a good solution -- has to redefine constantly ( too heavy )
        // if( proto !== obj.prototype && proto._ ) {
        //    //TODO: this can go completely wrong when you expect inheritance not to break when making a new class!
        //    if( proto.constructor.prototype._ === proto._ ) {
        //       var old = proto._
        //       proto._ = {}
        //       for(var key in old) {
        //         proto._[key] = old[key]
        //       }
        //    }
        // }
        
        //maybe make into a method
        if( id) {
          // console.log('DEFINE! DO IT'.red.inverse, name, id, proto)
          if (!proto.__) proto.__ = {}
          proto.__[name] = val
        } else {
          if (!proto._) proto._ = {}
          proto._[name] = val
        }



      

        //if proto is not a prototype (how to check?) then use __ perhaps?

        //moet hier niet altijd ze eiguh worden gemaakt?

       //default dit is eigenlijk het enige dat mis gaat

        var setter = function(val) {
              exports.setstore.call(this)
              //TODO: fix closure for val
              if (val || val === 0 || val === false) this.__[name] = val
            }
          , wset = function(val) {
              val = set.call(this, val);
              setter.call(this, val);
            }
          , getter = function() {
              return exports.getStore.call(this, name);
            }
          , wget = function() {
              var prop = getter.call(this);
              return get.call(this, prop);
            }

        val = {
          enumerable: false,
          configurable: true,
          get: get ? wget : getter,
          set: set ? wset : setter
        }

      } else if (!val.enumerable) {
        if (util.empty(val)) val.value = {}
        val.configurable = true
        val.enumerable = false
      }

      Object.defineProperty(obj.prototype || obj, name, val)

      // Object.defineProperty(obj.prototype || obj, name, val)
      //mayeb do both?
    }
  }
}
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../base')
  , Value = require('./')
  , objectSet = require('../object').set
  , util = require('../util')
  // , raf = require('../browser/animation/raf')

exports.clonelist = [
  [ '_base', false ], '_caller', '_prop', '_name', '_skip'
]

function resolveListener( listener, val, prop, instance ) {
  if (listener) {
    if ( listener._bind === instance && listener.__t === 4 ) {
      // console.log('bind resolve'.red.bold, val )
      listener.val = val
    }
    else if (!listener._bind ) { 

      if( listener.__t === 4 && listener._val === prop )
      {
        // listener.val = 
        listener.val = val
        console.log('----------', listener.__t )
      }
      else
      {
        // console.log('ultimate ugly!')
        val.addListener(listener) //dit fixed  
      }

      //TODO: implement this later
      // if( listener instanceof Array ) {
      //   var mark = listener[1]
      //   if( mark ) {
      //     if( mark === prop._base || mark === instance || instance instanceof mark._class ) {
      //       //TODO: propably need to check for inheritance ( mark instance of prop._base)
      //       // console.log('mark resolve'.green.inverse, listener)
      //       // val.addListener([ listener[0] , instance ], true)
      //     }
      //   }
      // }

      
      // val.addListener(_listeners[i])
    }
  }
}

// function resolveListener( ) {

// }

/**
 * V.value.base.type
 * Defines the base type used in V.Value
 * @type
 */
exports.type = {
  type: Value,
  /**
   * Defines what this type will do on creation.
   * @method create
   * @param  {*} val              Value
   * @param  {[type]}  [prop]     [description] //WORDT NIET GEBRUIKT
   * @param  {Object}  [settings] Settingobject
   * @param  {Boolean} [noupdate] When true, doesn't update the V.Value
   * @return {Object}             Returns the V.Value
   */
  create: function(val, prop, settings, noupdate) {
    var v = new Value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings.set) {
      if (!settings._vset) {
        settings._vset = function(stamp, from, remove, cval) {
          // var t = this
          // t.__s = true
          // if(!t._s) {
            // raf(function() {
              // console.log('IM HERE?')
              // t.__s = null
              settings.set.call(
                   this._caller
                || this._base
                || this, this, stamp, from, remove, cval
              )
            // })
          // }

        }
      }
      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  /**
   * Defines what this type will do on set.
   * @method set
   * @param  {*}      val      Value
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingsobject
   * @return {*}               Returns value
   */
  set: function(val, prop, settings) {

    if(!prop) return
    // console.log('SET FUN!')
    prop._caller = this
    //deze bind zou alleen moeten werken voor als je iets op het exact goede momment changed!

    prop._bind = false
    if (this !== prop._base) {
      var _listeners = prop._listeners
        , _b = prop._base
        , i
        , _this = this

      util.setstore.call(this)
      exports.clonelist[0][1] = this //beetje dirty...

      //clone is always used to get rid of flags
      if (val !== void 0 && !val.clear) {
        val = prop.clone(val, false, exports.clonelist)
      } else {
        // if(prop._flag) {
        //   value.flags[prop._flag[0]].remove && value.flags[prop._flag[0]].remove.call(this,prop._flag)
        // }
        //listener on nested child on parent

         //--->  new width for this one
         // --->  hey a listener on me /w a bind on my instance!
         //  ----> add listener to me (listener on class prop)
         //   -----> hey lets reset this little guys width
         //    ------>  lets add Listener
         //     -------->  double listeners on this one
        var v = new Value()
        v._base = this
        v._prop = settings
        v._caller = this

        // clean FLAGS from node!
        if(val) delete val.clear
        v.val = val
        val = v
      }

      this.__[settings.name] = val

      if( this._class ) this._class.prototype._[settings.name] = val

      // for each field (only 1 level deep for now)
      prop.each
      ( 
        function(key) {
          // console.log('resolve', prop._prop.name, key)
           if( this._listeners ) {
            for (i =  this._listeners.length - 1; i >= 0; i--) {
              resolveListener( this._listeners[i], val[key], prop, _this )
            }
            //TODO: check if this is nessecary
            if(val[key].val !== this.val)
            {
              // console.log(val[key]) 
              // val[key]._update()
            }
          }
        }
      )

      if( _listeners ) {

        for (i = _listeners.length - 1; i >= 0; i--) {
          resolveListener( _listeners[i], val, prop, _this )
        }

      }

      val = null
      // console.log('UPDACE ----'.yellow)
      this[settings.name]._update(val)
    }

    return val
  },
  /**
   Defines what this type will do on get.
   * @method get
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingobject
   * @return {Object}          [description]
  */
  get: function(prop, settings) {
    // console.log('GETTING!', prop, settings.name)
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./'),
  util = require('../../util'),
  object = require('../../object'),
  ownModel = function(base) {
    if (!base.__ || !base.__.model) { //maybe a utility? use it at different spots like settings
      base.model = {};
      if (!base._.model) {
        base._dListen();
      }
    }
    return base.model;
  };
/**
 * data
 * data adds a reference to the data property of the current base class;
 * if there is not _base.model use data.base.extend(baseClass);
 * @flag
 */
flags.data = {
  useVal:true, //(reset???)
  set: function(val, stamp, reset) {

    var current = this.checkParent('_prop.name'),
      name = current._prop.name,
      base = current._base,
      model = ownModel(base);
    if (model.flags && model.flags[name]) {
      if (!(model.flags[name] instanceof Array)) {
        model.flags[name] = [model.flags[name]];
      }
      if (!util.checkArray(model.flags[name], this)) {
        model.flags[name].push(this);
      }
    } else {
      if (!base.model.flags) {
        base.model.flags = {};
      }
      base.model.flags[name] = this;
    }

    // console.log('LEZZ SET IT!', val, stamp, reset, current)

    var getData = function() {
      var data = this._d;
      if (data === void 0) {
        var parent = this;
        while (data === void 0 && parent) {

          // if(parent.model && (!parent.model.inherit || parent.model.inherit.val!==false)) {
          //   return data
          // }

          // console.error('set it /w parent!', this.name, parent.name)

          if (parent._d) {

            if(parent.model && parent.model.field && parent.model.field.val !== parent.modelParsed) {
              parent._d = parent._d[parent.model.field.val] || parent._d.from[parent.model.field.val]
              console.error('het hey its parent model', parent.model.field.val)
              // parent.model = {}
              parent.modelParsed = parent.model.field.val
            }

            // if(par)

            if(this.model&&this.model.field && this.modelParsed !== this.model.field.val) {
              console.error('hey hey hey! i got a model myself!', this.model.field.val, parent._d.keys, parent._d)

              data = this._dSet(parent._d[this.model.field.val] || parent._d.from[this.model.field.val], true);
              // this.model = {}
              this.modelParsed = this.model.field.val
              // this.model.parsed = this.model.field.val
            } else {
              data = this._dSet(parent._d, true);
            }


            // if(parent.model && parent.model.field) {
            //   console.error('it is a field!', parent.model.field.val)
            // }
          } else {
            parent = parent.node.parentNode;
            if (parent) {
              parent = parent.base;
            }
          }
        }
      }
      return data;
    };
    if (val instanceof Object) {
      var v = val.val || val;
      this._val = function() {
        var data = getData.call(this);
        // console.log('---->',v,data)
        return data && v.call(this, data);
      };
      val = val.listen || true;
    } else {
      this._val = function() {
        var data = getData.call(this),
          ret;
        data = val === true ? data : util.get(data, val);
        if (data !== void 0) {
          ret = data.__t && !data._filter && data.val;
          if (!ret && ret !== 0 && ret !== '') { //weird
            ret = data;
          }
        } else {
          ret = '';
        }
        return ret;
      };
    }
    if(!this._flag) this._flag = {}

    // this.__lval = false
    // current._caller.setSetting({
    //   name: name,
    //   parent: function(parent) {
    //     console.log('!@#!@#!@#')
    //     this.updateData()
    //   }
    // });

    this._flag.data = ['data', this._val, val, name];
  },
  remove: function() {
    var current = this.checkParent('_prop.name'),
      model = ownModel(current._base),
      t = this;
    if (model && model.flags) {
      for (var i in model.flags) {
        if (i === current._prop.name) {
          var item = model.flags[i];
          if (item instanceof object || item.length === 1) {
            model.flags[i] = null;
            delete model.flags[i];
          } else {
            model.flags[i].splice(util.checkArray(item, t), 1);
          }
        }
      }
    }
    this._update() //pas hiermee op!
    // var t = this
    setTimeout(function() {
      //deze pas uitvoeren nadat alle klaar is! dit is dirty!
      t._update()
    },0)
  }
};
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var value = require('../'),
    base = require('../base'),
    flags = require('../../object/flags');
    
    base.clonelist.push(['_flag', true]); //true clone!
    flags.extend(value);
    module.exports = value.flags;
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../object/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js","../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/parent.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./')
  , value = require('../')
  , util = require('../../util')
  , vObject = require('../../object')


//todo add element signature in from so it can travel trough updates --- if parent (need less funky things)

/**
 * parent
 * parent makes it possible to add listeners to parent properties
 * using multiple parent properties in one property is still very wrong
 * @flag
 */
value.prototype._blacklist.push('_parentStore')

function baseReset(base,name) {
  if(base && base.node) {
    if(name==='x' || name ==='y') base.cleanCoordinates(name)
    if(base[name]) {
      base[name]._prop._vset.call(base[name])
    }
  }
}


// window.pcheck = 0

// window.pprops = {}

//base,vset,t,type,mparent,fbase, v, val, stamp, from, remove, added, oldval, true, firstSkip
function checker(vset, t, type, mparent, fbase, v, val, stamp, from, remove, added, oldval, first, firstSkip, p) {
  if(p&&(this.parent instanceof mparent) ||  (!p && this.parent===mparent) || firstSkip ) {

    // pcheck++

    var s
      , base = this._from.base.node && this._from.base
      , name = t._prop.name

    // if(!window.pprops[name]) window.pprops[name] = 0

    // window.pprops[name]++


    t._caller = this

    //gaurd voor changes -- if no change -- do nothing
    vset.call(t, stamp, from, remove, val)

    if(base&&base[name]&&base[name+'__p']!==stamp) {
      t._caller = base
      t._caller[name+'__p'] = stamp
      vset.call(t, stamp, from, remove, val)
      t._caller = this
      s=true
    }

    // console.log(this.node)
    for(var i in t._listeners) {
      if(t._listeners[i].pop && t._listeners[i][2]==='parent') {
        if(t._listeners[i][1]._lstamp===stamp) {
          t._listeners[i][1]._lstamp=null
        }
        t._listeners[i][0].call(t._listeners[i][1], type, this, base, v, val, stamp, from, remove, added, oldval, true)
      }
    }

    //reset this._from.base[t._prop.name]===t
    if(s) baseReset(base, name)

  }
}

function updateHandler(type,mparent,fbase,v, val, stamp, from, remove, added, oldval,firstSkip,inherit) {

  var t = this

  this._parentStore[0] = mparent

  this._update(val, from ? this.stamp() : stamp, from, remove, added, oldval, false, false, function() {
    var vset =  this.checkParent('_prop._vset', true)
      , base = this.checkParent('_base', true)
      , complexParent = true
      , p

    if( (mparent===base.parent && from)  ) {
      p = true
    }

    checker.call(base,vset,t,type,mparent,fbase, v, val, stamp, false, remove, added, oldval, true, firstSkip)

    base.eachInstance(function() {
     checker.call(this, vset, t,type, mparent,fbase, v, val, stamp, false, remove, added, oldval, false, p)
    }, t._prop.name)

    vObject.prototype._update.call(this, val, stamp, false, remove, added, oldval, function(l) {
      return l[2]==='parent'
    })

    if(!inherit && v._caller && mparent!==v._caller) {
      updateHandler.call(this,type,v._caller,fbase, v, val, stamp, false, remove, added, oldval,firstSkip,true)
    }

  })
}

function _parent(parent, noupdate, prop, flag, reset) {

  // console.log('_parent call'.cyan.inverse, flag)

  var _lparent = prop._parentStore[0]
    , pname = flag[2]   //flags.parent.val
    , pprop = parent[pname]
    , fbase = this._from.base
    , newP
    , baseSet

  if (!pprop) return

  // console.log('ADD LISTENER TO PARENT')

  pprop.addListener(
    [ updateHandler
    , prop
    , 'parent'
    , parent
    , this //fbase
  ], function(l,listeners,index) {

    if(l[3]!==parent &&  _lparent!==parent && l[4]!==fbase) {
      prop._parentStore[0] = parent
      l[4] = fbase
      newP = true //hoe deze smart afvangen?
    }
  }, false, true)

  // if(reset) {
  //   for(var i in pprop._listeners) {
  //     if(pprop._listeners[i].pop && pprop._listeners[i][1]===fbase[prop._prop.name]) {
  //       if(pprop!==parent._from.base[pname]) {
  //         pprop._listeners.splice(i,1)
  //         break;
  //       }
  //     }
  //   }
  // }

  if (newP || (!_lparent || (_lparent !== parent && _lparent[pname] !== pprop) ) ) {
    prop._parentStore[0] = parent
    if (!noupdate) {
      prop._caller = (baseSet = fbase.node && fbase || prop._base)
      prop._prop._vset.call(prop, prop)
      prop._caller = this
      updateHandler.call(prop,'parent',parent,fbase,pprop,false,vObject.stamp(),false,false,false,false,true,true)
      baseReset(baseSet,prop._prop.name)
    }
  }
}

function _init(val, flag, reset) {
  var parent = this.parent
  // console.log('try parent', flag, parent)
  if (parent) _parent.call(this, parent, true, val, flag, reset)
}

function _val(val) {
  var parent = this.parent || val.checkParent('_parentStore.0', true)
  //flags.parent.val
  if(parent && !val._flag.parent) {
    console.error('NO PARENT FLAG!')
    return
  }
  // console.log('---->',val._flag.parent[2])
  if (parent ) return parent[val._flag.parent[2]].val
}

flags.parent =
{ reset: true
, useVal: true
, set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name'),
      name = current._prop.name
    //flags.parent.val
    if(!this._flag) this._flag = {}

      //overwriting previous parent
      //
    // console.log('SET PARENT---->')
    this._flag.parent = ['parent', _val, val, this]
    if (!current._parentStore) current._parentStore = [false]

    // console.log('GOTS PARENTSTORE!', reset, current._parentStore, this._flag.parent)

    current._parentStore.push(this)
    //setParent settings
    // console.log('---> CREATE SETTING'.yellow.inverse)
    current._caller.setSetting({
      name: name,
      parent: function(parent) {

        // console.log('---> SET SETTING'.yellow.inverse)

        for (var store = this[name]._parentStore, i = store ? store.length - 1 : 0; i > 0; i--) {
          if(store[i]._flag.parent) {
            _parent.call(this, parent, false, this[name], store[i]._flag.parent)
          } else {
            console.error('2 NO PARENT FLAG!')
          }
        }
      }
    });
    //try to minimize val calulations
    this._val = _val
    this._skip = true
    //onInit (if it already has some parents)
    _init.call(current._base, current, this._flag.parent, reset)
    //reAttach listeners for instances
    current._base.eachInstance(_init, name, current, this._flag.parent)
  }
, remove: function(flag) {

    // console.log('REMOVE PARENT'.cyan.inverse)

    var current = this.checkParent('_prop.name'),
      base = current._base,
      listens = current._listens,
      name = current._prop.name,
      val = flag[2],  //flags.parent.val
      parentStore = current._parentStore,
      removelistener = function() {
        var parent = this.parent
        if (parent && parent[val]) {
          if (listens.length > 0) {
            if (util.checkArray(listens, parent[val])) {
              // console.log('REMOVE LISTENER!', parent[val], listens.length, parent[val]._listeners.length, parent[val]._listeners , current)


              //more specific only remove if val matches --- store function
              parent[val].removeListener( false, current )

              //mark = false


              // console.log('REMOVE LISTENER! -- result -- no update?', listens.length)

            }
          } else {
            return true
          }
        }
      }

    this._val = 0

    if (listens && !removelistener.call(base)) {
      base.eachInstance(removelistener, name)
    }

    // console.log('PARENTSTORE', parentStore, current)
    parentStore.splice(util.checkArray(parentStore, this, true), 1)

    if (parentStore.length === 1) {
      // console.log('---> REMOVE SETTING'.yellow.inverse, parentStore)
      base.removeSetting(name, 'parent') //ff corigeren voor andere parent settings!!! op andere fields
      //dit maakt het helemaal kapot!
      // console.warn('REMOVE PARENTSTORE!')
      current._parentStore = null
    }
  }
}
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

//TODO: flags on the basis of path ( similair to cases )

//TODO: make Value flags more injectable
var flags = module.exports = require( './' )
  , processes = require( '../../util/process' )
  , Value = require( '../' )
  , util = require( '../../util' )
  , ajax = require('../../browser/network/ajax')
  , vObject = require('../../object')

//TODO: maybe add promise

exports.create = function( flag, settings, Constructor, extendflags ) {

  if( !extendflags ) extendflags = flags
  if( !Constructor ) Constructor = Value

  var tempStore = '__temp'+flag+'__'
    , inProgress =  '__inprogress'+flag+'__'
    , origUpdate = Constructor.prototype._update
    , once = settings && settings.once
    , deferMethod = settings && settings.deferMethod
    , origSet
    , origRemove
    , deferflag = 
      { reset: true
      , set: function( val, stamp, reset ) {
          if( !this._flag ) this._flag = {}
          this._flag[flag] = [ flag, false, val, this ]
        }
      , remove: function() {
          var defer = this._flag && this._flag[flag]
            , vobj

          if( defer && defer[1] )
          {

            // if( deferMethod ) 
            // {
              // vobj = deferMethod.call( _this, arr, defer[2], _this[tempStore], origUpdate, Constructor )
            // }
            // if() {
              vobj = typeof defer[2] === 'string'
                   ? processes[defer[2]]
                   : typeof defer[2] !== 'function' && defer[2]
            // }

            if( vobj && vobj.removeListener )
            {
              vobj.removeListener( defer[1] )
            }
            else if( vobj && vobj !== true )
            {
              for( var vobj$ in vobj )
              {
                vobj.removeListener( vobj[vobj$] )
              }
            }
          }
        }
      }


  Constructor.prototype._blacklist.push
  ( tempStore
  , inProgress
  , '_history'
  // , '_initialised'
  )

  if( deferMethod ) {
    settings.deferMethod = null
  }

   if( once ) {
    settings.once = null
    Constructor.prototype._blacklist.push( once )
  }

  if( settings ) {
    for( var key in settings )
    {
      if( key === 'set' )
      {
        origSet = deferflag.set
        deferflag.set = function( val, stamp, reset ) {
          settings.set.call( this, origSet, arguments )
        }
      }
      else if( key === 'remove' )
      {
        origRemove = deferflag.remove
        deferflag.remove = function( val, stamp, reset ) {
          settings.remove.call( this, origRemove, arguments )
        }
      }
      else 
      {
        deferflag[key] = settings[key]
      }
    }
  }

  extendflags[flag] = deferflag

  //extend update
  util.define
  ( Constructor
  , '_update'
  , function( val, stamp ) {



      if( ( this._flag && this._flag[flag] ) && ( !once || !this[once] ) ) //&& !this._initialised 
      {

        // this.clearCache()

        // console.error('_updace', val, this._path)

        // console.error( '$EEEEE1', this._path)

        // console.log(this._path, val, stamp)
        var _this = this
          , defer = _this._flag && _this._flag[flag]
          , tempdefer = _this[tempStore]
          , add
          , arr
          , vobj
          , recur
          , fn

        if( !tempdefer )
        {
          _this[tempStore] = tempdefer = []
          add = true
        } else {
          //TODO: fix caching stamp, most efficient but may break things /w instances etc
          // console.log('stamp cahcing', this._path)

          if( stamp && tempdefer[0][1] !== stamp )
          {

            // tempdefer.push(util.arg( arguments ))
            // console.log('stamp cahcing pass' , this._path, tempdefer)
            // tempdefer[0][0] = val
            // tempdefer[0][1] = stamp
            var arg = util.arg(arguments)
            for(var i in arg) {
              tempdefer[0][i] = arg[i]
            }
          }


        // console.error('_updace 3', val, this._path)

         // if(this._name === '$test') console.log('stop its')
          return
        }

        arr = util.arg( arguments )

        // console.error('_updace 2', val, this._path)

        tempdefer.push( arr )

        if( add )
        {
          // if(this._name === '$test') console.error('do it 1')

          if( deferMethod ) 
          {
            vobj = deferMethod.call( _this, arr, defer[2], tempStore, origUpdate, Constructor, inProgress )
          }
          else 
          {
            vobj = typeof defer[2] === 'string'
               ? processes[defer[2]]
               : defer[2]
          }

          if( vobj )
          {

              // console.log('heyho2!!!!!', val,this._path)

          
            //TODO: replace with a standard function, lose the extra closure!
            recur = function() {

              if( once ) 
              {
                _this[once] = true
              }
              //dit ook kunnen meegeven
                // console.error('LETS TRY')

              //TODO: using a closure here may not be nessecary anymore, use another identifier
              for( var i = 0; i < tempdefer.length; i++ ) { //length needs to update
                // _this._caller = tempdefer[i].splice( tempdefer[i].length-1, 1 )
                // tempdefer[i][1] = this.stamp()
                // try{
                  // console.error('LETS TRY go go go',val, i, tempdefer[i])
                  // var stampx = tempdefer[i][1]
                    // , valx = tempdefer[i][0]

                  origUpdate.apply( _this, tempdefer[i] )  

                  // if( (tempdefer[i][1] && tempdefer[i][1]!==stampx) || (tempdefer[i][0] && tempdefer[i][0]!==valx) ) {
                  //   console.warn('defer new update within the loop now it fires! -- be carefull may break')
                  //   var ref = tempdefer[i]
                  //   // setTimeout( function() { 
                  //     _this.clearCache()
                  //     _this[tempStore] = null
                  //     _this[inProgress] = null
                  //     _this.clearReferencesCache()
                  //     // console.log('?????',ref)
                  //     _this._update.apply( _this, ref ) 
                  //   // } ,100) 
                  //   // alert('new update set within loop!')

                  // }
                // }catch(e){console.error('WA', e)}
                
              }

              //listener gets removed but order is different
              if( this.removeListener ) this.removeListener( recur )

              _this[tempStore] = null
            }

            if( typeof vobj === 'function' )
            {

              if( !_this[inProgress] )
              {
               
                fn = function( val ) {
                  
                  if( val!==true && _this[inProgress] ) {
                    _this[inProgress]()
                  }
                  _this[inProgress] = null
                  _this[tempStore] = null
                }

                _this[inProgress] = recur

                if( vobj.call( this, fn , arr, tempdefer ) === true )
                {
                  _this[tempStore] = null
                  _this[inProgress] = null
                }
                // else
                // {
                //   console.log( '?' )
                //   //TODO: check if this is the best way, (updating recur, or mayeb just use the same recur)
                //   _this._deferinprogress = recur
                // }

              }

            }
            else if( vobj === true )
            {

              if( this.val || this.val === 0 )
              {
                origUpdate.apply( _this, arr )
                _this[tempStore] = null
              }  
              else
              {
                console.error( 'no value! from defer type:', flag)
              }
            }
            else if( !vobj.addListener )
            {
              for( var vobj$ in vobj )
              {
                vobj[vobj$].addListener( recur )
              }
            }
            else
            {

              vobj.addListener( recur )
            }

            defer[1] = recur
          }
        }

      }
      else
      {
        // console.log( flag, once, 'should do orig update bitches!', arguments, this )
        origUpdate.apply( this, arguments )
      }

    }
  )

} 

//TODO: injectable
//TODO:_tempdefer hoeft niet altijd maak create -- update type flag
//always update method
// exports.create( 'force', 
// { deferMethod: function( args, vobj, tempStore, update ) {
//     var _this = this
//     //dit zit natuurlijk dieper!
//     _this._skip = true //maybe check if it rly gets reset?
//     _this._ignoreValue = true
//     _this.clearCache()
//     _this[ tempStore ] = null
//     update.apply( _this, args )
//   }  
// })
//deze moet nog wat dieper

// exports.create( 'history', 
// { deferMethod: function( args, vobj, tempStore, update, Constructor ) {
//     //vobj option voor flag
//     if(!this._history) this._history = []

//     this._history.unshift( args )
//     this[tempStore] = null //total control! (old including arguments)

//     //allright that works this.clearCache() //cache dingen adden
//     update.apply( this, args )
//   }
// })

// exports.create( '$type', 
// { deferMethod: function( args, vobj, tempStore, update ) {
//     var _this = this
//       , haveToUpdate

//     //arrays etc
//     _this.clearCache()

//     if( vobj === true )
//     {
//       if( _this.val ) haveToUpdate = true
//     }
//     else if( vobj === 'string' )
//     {
//       if( typeof _this.val === 'string' ) haveToUpdate = true
//     }
//     else if( vobj === 'number' )
//     {
//       if( typeof _this.val === 'number' ) haveToUpdate = true
//     }
//     else if( typeof vobj === 'function' )
//     {
//       if( vobj.apply( _this, args ) ) haveToUpdate = true
//     }

//     if( haveToUpdate ) {
//       _this[tempStore] = null
//       update.apply( _this, args )
//     }
//   }  
// })

exports.create( '$bubble', { 
  deferMethod: function( args, vobj, tempStore, update ) {
    var _this = this
    var doUpdate
    var references
    _this[tempStore] = null

    if( vobj ) {
      if(references = vobj.references) {
        if(references instanceof Object) {
          if(references.$lte 
            && _this.referenceLevel(_this._updateOrigin) <= references.$lte 
          ) {
            doUpdate = true
          }
        } else if(references > -1) {
          //also maximum for example
          // console.error(_this._path, _this.referenceLevel(_this._updateOrigin), 'uOriginPath', _this._updateOrigin._path, '._val',_this._val._path,  'cloud', !!_this._val.cloud)
          if( _this.referenceLevel(_this._updateOrigin) === references ) {
            doUpdate = true
          } 
        } 
        // else if(references === true) {
        //   //only if refference
        //   if(_this.referenceLevel(_this._updateOrigin)!==false) {
        //     doUpdate = true
        //   } 
        
        // }

      } else if( vobj && vobj.self === true ){

          if( args[2] === void 0 || this._val === args[0] || !args[0] && this._updateOrigin===this) {
            doUpdate = true
          }
        }
        
        if(doUpdate) {  
          update.apply(_this, args)
        } else {
          _this.clearReferencesCache()
        }

      } else {
        update.apply(_this, args)
      }

   
  }  
})

exports.create( 'defer' )

//TODO: vObj flag ( accessable trough object[flag] )

Value.operators.responseData = function( val, operator ) {
  return operator===false ? val : operator
}

//vobj parser!

exports.create( 'ajax', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
//     console.log('set ajax defer')
    if( ! this.loading ) {
      //name, val, vobj, stamp, noupdate, from
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor ) {
    var _this = this  

    return vobj && function( update, args ) {

      var origu = update

      update = function( type, kill ) {
        _this.clearCache()
        _this._skip = true
        _this._ignoreValue = true
        if( type ) {
          args[0] = type
          if(! ( _this._val instanceof vObject ) ) {
            _this.val = type
          } 
        }
        if( _this.loading ) _this.loading.val = false
        origu( kill )
        _this._ignoreValue = null
      }

      if( typeof vobj === 'object' )
      {
        var params = vobj
        vobj = {}
        for( var key in params ) {
          if( key === 'defer' ) {
            vobj[key] = params[key]
          } else {
            if(!vobj[key]) {
              if( key !== 'complete' && key !== 'error' && typeof params[key] === 'function' ) {
                vobj[ key ] = params[ key ].call( _this, vobj, args[0], args )
                if( !vobj[key] ) {
                  return true
                }
              } else {
                vobj[key] = params[key]
              }

              if( vobj[key] instanceof vObject ) {
                vobj[key] = vobj[key].val //custom get or raw
              } 
            }
          }
        }
      }

      if( typeof vobj === 'function' ) 
      {
        vobj = vobj.call( _this, vobj, args[0], args )
        if(!vobj) return true
      }

      if( typeof vobj === 'string' ) 
      {
        vobj = { url: vobj }
      }

      if( vobj.url instanceof vObject ) {
        vobj.url = vobj.url.val
      }

      if( !vobj || !( vobj.url || vobj.api ) ) 
      {
        return true
      }

      var complete = vobj.complete
        , error = vobj.error

      vobj.complete = function( data ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, null, data, vobj )
        }
        else
        {
          if(!_this.responseData) {
            _this.set( 'responseData', data )
          }
          else {
            _this.responseData.merge( data )
          }
          ;complete && complete( data )
          update( 'success' )
        }
      }

      vobj.error = function( err ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, err, vobj )
        }
        else
        {
          if( _this.responseData )
          { 
            _this.responseData.each( function( key ) {
              if( !Constructor.operators[key] && !Constructor.flags[key] )
              {
                this.remove()
              }
            })
          }
          _this.set( 'responseData' , void 0 )
          if( error ) error( data )
          update( 'error' )
        }
      }

      if( _this.loading ) {
        //TODO:correct responses managemet -- pretty easy todo
        _this.loading.val = true
      }

      ajax( vobj ) //TODO: let it return a promise
    }  
  }
})

//temp args 

//TODO: dit later vervangen met local flags (api)
//TODO: unify ajax hiermee voor oncsitent error handeling -- of extension op ajax
exports.create( 'apiDefer', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
    if(! this.loading ) {
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor, inProgress ) {
    var _this = this  
   
    return vobj && function( update, args ) {

      if( !args[0] || args[0].apiDefer ) return true

      var wrappedUpdate = function( val, kill ) {

        // console.error('DO DO DO', val, _this, tempStore, _this[tempStore])

        // _this[tempStore] = null
           
        // _this[inProgress] = null


        _this.loading.val = false
        if( val && val!==true ) 
        {
          _this.val = args[0] = val
          try {
            update( val ) //val -- val
          } catch( err ) {
            // console.error( 'DEEPER ERROR IN API DEFER , SOMETHING WRONG /w this API', val )
            //best example is facebook login true and gone but only weh the .loading is there
            //most be a very deep issues i geuss... hard to recreate 
            _this.type = err

            //this is wrong misses _this call and other args
            update( 'error' )
          }

          _this.clearCache()
          _this._val = false
        }
        else 
        {
          //this is wrong misses _this call and other args
          update( val )
        }
      }
      
      _this.loading.val = true
      var api = _this.checkParent( 'api', true )

      if( api && api.val !== true ) 
      {

        api.once(function( val ) {
          if( val === 'error' ) 
          {
            _this.clearCache() //hier ff een functie voor maken!
            _this.val = args[0] = 'error'
            _this.type = this.type || 'api'
            _this.loading.val = false
            wrappedUpdate()
          }
          else if( val === true )
          {
            vobj.call( _this, wrappedUpdate, args )
          }
        })
        api.val = true
      } 
      else
      {
        vobj.call( _this, wrappedUpdate, args )
      }
    }
  }
})

exports.create( 'init', 
{ set: function( set, args ) {
    if( !this.initialised )
    {
      set.apply( this, args ) //niet nodig!
    }
  }
, remove: function( remove, args ) {
    remove.apply( this, args )
    this.initialised = null
  }
, once: 'initialised'
})

module.exports = exports

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../browser/network/ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../util/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/process.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./');

/**
 * self
 * @flag
 */
flags.self = {
  reset: true,
  useVal:true,
  set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name')
    if (current._base && current._base[val]) {
      current._base[val].addListener(this)
      this._val = function() {
        return this[val] && this[val].val
      }
      if(!this._flag)  this._flag = {}
      this._flag.self = ['self', this._val, val, this]
    }
  }
};

},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = module.exports = require('./')
/**
 * listen
 * adds listeners to a V.Value
 * @property
 **/
flags.listen = {
  reset:true,
  set: function(val, stamp, reset) {
    if(!val)
    {
      console.error('no val in flags listen!')
//       debugger
      return
    }
    if(!this._flag) this._flag = {}
    //eventueel mergen!
      
    // console.log('listen'.cyan.inverse, reset, val)
    //if reset make sure its resetted correctly!
    this._flag.listen = ['listen', false, val, this ] 
    if (val instanceof Array) {
      for (var i = val.length - 1; i >= 0; val[i--].addListener(this));
    } else {
      //ok
      var _this = this
      // val.addListener(function() {
      //   console.log('TROUGH LISTEN!!!!'.magenta.inverse, val._path)
      //   // _this._update.apply(_this, arguments)
      // }) 
      val.addListener(this) //dit moet beter (remove listener if possible)
    }
  },
  remove:function() {
    if(this._flag&&this._flag.listen) {
      var val = this._flag.listen[2]
      if (val instanceof Array) {
        for (var i = val.length - 1; i >= 0; val[i--].removeListener(this));
      } else {
        val.removeListener(this) //dit moet beter (remove listener if possible)
      }
    }
  }
}

},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require( '../object' )
  , util = require( '../util' )
  , vigour = require( '../' )

/**
 * vigour.Value
 * v values are optimized for use in combination /w instances of vigourBase, have operators and support method values
 * @Class
 */
module.exports = exports = vigour.Value = object.new(
{ mixed: true
, merge: true
})

//parent problems

var _getOperator = function( val, force, i, t, bind, operators ) {
  var f = t[i]._get(bind, force, val);
  if (f !== void 0 && f !== null) {
    val = operators[i](val || ((typeof f === 'string') ? '' : 0), f);
  }
  return val;
};

exports.prototype._blacklist.push('_lstamp', '_clearCache', '_lval', '__lval','___lval', '_base', '_caller', '_bind', '_prop', '_instances', '_skip', '_overwrite')
//_caller stamp for get for lvals (last values)
util.define(exports,
  'clearCache', function() {
    this.___lval = null
    this.__lval = null
    this._lval = null 
  },
  'clearReferencesCache', function() {
    from = this._val
    while(from) {
      if(from.clearCache) from.clearCache()
      if(from && from._val) {
        from = from._val
      } else {
        from = null
      }
    }
  },
  'ignoreCache', { get:function() {
      var t = this
      while(t) {
        // console.log('hoe zit het??',t )
        if( t._prop && t._prop.cache === false ) return true
        t = t._parent
      } 
    } 
  },
  /**
   * Used to get .val which calculates a constructed value
   * _bind is very important binds listeners to specific instances
   * @method _get
   * @param  {[type]} bind  [description]
   * @param  {[type]} force [description]
   * @return {[type]}       [description]
   */
   '_get', function(bind, force, currentVal) {

    if(this._clearCache) {
      this.clearCache()
    }

    // console.log('_get',this._name, this._val,this);
    if (this._overwrite) {
      return this._overwrite;
    }
    if (!this._lval && this._lval !== 0 || force) {
      var val = this._val,
        nolval,
        operators = this.operators;

      if (val instanceof object) {
        val = val._get(this._bind || bind, force, currentVal);
      } else if (typeof val === 'function') {

        // console.log('RIGHT HERE', currentVal)
        var a = this;
        if (!bind) {
          while (a._parent && !a._caller) {
            a = a._parent;
          }
        }
        val = val.call(bind || a._caller || a._base || this, this, currentVal); //if currentval else something else;
        nolval = true;
        //for functions you need to clear _lval since you never know if there is something in the function updated
      }
      if (operators) {
        if (this.__t === 1 && operators[this._name]) { 
          //operator is an array
          val = 0; //string
          for (var j = 0, l = this.length; j < l; j++) {
            if (this[j]) {
              vj = this[j]._get(bind, false, (currentVal || 0) + val);
              if (!vj) {
                vj = 0; //string
              }
              if (typeof vj === 'string' && val === 0) {
                val = '';
              }
              val += vj; //only add no operator stuff
              if (!this[j]._lval) {
                nolval = true;
              }
            }
          }
        } else {
          //also add before
          var ordered;
          for (var i in this) {
            if (operators[i]) {
              if (!operators[i].order) {
                if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) {
                  force = true;
                }
                val = _getOperator(val, force, i, this, bind, operators);
                if (!nolval && !this[i]._lval) {
                  nolval = true;
                }
              } else {
                if (ordered) {
                  if (!ordered.pop) {
                    ordered = [ordered];
                  }
                  var o = operators[i].order,
                    ol = ordered.length - 1;
                  for (var h = 0; h !== true && h <= ol; h++) {
                    if (h === ol) {
                      if (o < operators[ordered[h]].order) {
                        var a = ordered[h];
                        ordered[ol] = i;
                        ordered.push(a);
                      } else {
                        ordered.push(i);
                      }
                      h = true;
                    } else if (h === ol && o > operators[ordered[h]].order) {
                      ordered.push(i);
                      h = true;
                    }
                  }
                } else {
                  ordered = i;
                }
              }
            }
          }
          //shorter
          if (ordered) {
            // console.log(ordered);
            var x;
            i = ordered.pop ? (x = 1) && ordered[0] : ordered;
            while (i && this[i]) {
              if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) force = true
              val = _getOperator(val, force, i, this, bind, operators);
              if (!nolval && !this[i]._lval) nolval = true
              i = ordered[x++];
            }
          }
        }
      }
      if (!nolval && !force) {
        this._lval = val;
        this.__lval = val;
      } else if (!(this._base && this._base.instances)) {
        this.__lval = val;
      }
      return val;
    } else {
      return this.__lval;
    }
  },
  /**
   * Fires all listeners
   * @method update
   * @param  {[type]} instance    [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @return {[type]}             [description]
   */
  'update',
  function(instance, noinstances, instancesUpdates, stamp, from, remove, added) {
    //is this really nessecary?
    this._update.call( this, void 0, stamp || this.stamp(), from, remove, false, false, noinstances, instance, instancesUpdates  ); //this.val
    return this;
  },
  /**
   * Extends vigourObject._update
   * Adds loads of stuff to optimize updates for calculations
   * @method _update
   * @param  {[type]} val         [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} instance    [description]
   * @return {[type]}             [description]
   */
  '_update',
  function( val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates ) {

    var t = this,
      base = t._base;

    if (val instanceof exports && !t._bind) 
    {
      if (val._caller) {
        t._bind = val._caller;
      }
    }

    if ( (!t._lstamp) || t._lstamp !== stamp  ) {

    // var operators = t.operators
    // var lval 
    // var calcVal
    // var passValueCache 

    // if( !t.ignoreCache ) {
    //   //TODO: this is a temporary fix needs to be faster
    //   //make this a method
    //   function cleanup(t) {
    //   	t._lval = void 0
    //   	t.__lval = void 0 
    //   	if(t._val instanceof object ) {
    //   		//TODO: if stuff doesnt update uncomment this line
    //   		// cleanup(t._val)
    //   	}
  	 //    for(var $field in t) {
  	 //    	if(operators[$field]) {
  	 //    		cleanup(t[$field])
  	 //    	} else if($field > -1) {
  	 //    		cleanup(t[$field])
  	 //    	}
  	 //    }
    // 	}
    //   cleanup(t)

    //   lval = t.___lval
    //   calcVal = t.val
    //   passValueCache = lval === void 0 || lval !== calcVal
    //   t.___lval = calcVal

    // } else {

      // t.clearCache()
      // passValueCache = true
    // }

     // if (  passValueCache || ( base && base.instances ) || t._skip ) { //pass this calculation to vset else its too heavy;

    t._lval = false  
    // t._skip = true
    if(base && base.instances || t._skip || t.__lval === void 0 || t.___lval !== t.val ) {

      // if(window.smut) {
        // console.log('wtf is happening!!!!', t._path, t, t._updateOrigin, arguments)
      // }

        var prop = t._prop,
          parent = t._parent,
          vset = prop && prop._vset;

        var operators = t.operators
  
        //make this better
        if (!(from && remove) && operators && (operators[t._name] || (parent && parent.__t === 1 && operators[parent._name] && (!from || t._name == parent.length - 1)))) {
          //works for arrays since arrays are always replaced on update , updating an individual item using .set will not result in an update at this pont which has to be resolved
          var _op = this._parent;
          while (operators[_op._name]) {
            _op._lval = false; //if no change to lval can go wrong...
            _op = _op._parent;
          }
          if (_op) {
          	//this geatly increases updates may be important for animation but not nessecary for anything else!
            _op._update(val, stamp, this, remove, added, oldval, noinstances, instance, instancesUpdates);
          }
        }

        if (instancesUpdates) {
          instancesUpdates.call(t, val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates);
        } else {
          if (instance) {
            base = instance;
          }
          if (vset) {
            t._caller = base;
            vset.call(t, stamp, from, remove, val);
          }
          if (base && vset && base.instances && !noinstances && prop.updateinstances !== false) {
            base.eachInstance(function() { //look for current caller instance perhaps?
              t._caller = this;
              vset.call(t, stamp, from, remove, val);
            }, prop.name, t);
            t._caller = base;
          }
          //form gone lets see!
          //from self doorgeven in chain ==-- if ! not from from ---> , extra arg
          object.prototype._update.call(t, val, stamp, from || t, remove, added, oldval)
        }

        //pas op met deze!
        t._lstamp = stamp;
    }
    else {
      // if(window.smut) console.log('catch it!', arguments)
    }


    }
  })

//requiring operators does not automaticly require vigourValue, may be handy?
util.define(exports, 'operators', {
  value: exports.operators = require('./operators')
})




},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js":[function(require,module,exports){
var Value = require('vigour-js/value'),
  util = require('vigour-js/util'),
  VObject = require('vigour-js/object')

exports.extend = util.extend(
  function(Target){
    if( Target.prototype instanceof VObject || Target === VObject) {
      // TODO: fix this to affect all VObject blacklists...
      Target.prototype._blacklist.push('_$length')

      util.define( Target,
        '$length', {
          get: function () {
            // TODO: ...so we dont have to do blacklist check:
            util.include(this._blacklist, '_$length')
            return this._$length || (this._$length = makeLength(this))
          }
        }
      )
    } else {
      throw new Error('cannot extend "$length" on non VObject Class')
    }
  }
)

function makeLength(instance) {
  var $length = new Value({
    val: function(){
      return getLength(instance)
    }
  })

  instance.on(function(val){

    // var identifier = instance._path.length 
    //   ? instance._path
    //   : instance._prop && instance._prop.name
    // console.log('UPDATE ON', identifier, 'SHINE DAT LENGTH?!', $length.val
    // )
    // TODO: only update if added or removed
    $length._update.apply($length, arguments)
  })

  return $length
}

function getLength (current) {
  if(!current){
    return 0
  } if (current._filter) {
    return current.length
  } else if (current.__t === 4) {
    return getLength(current._val)
  } else if (current.__t < 3) {
    return current.keys.length
  } else if (typeof current._val === 'string') {
    return current._val.length
  } else {
    return 0
  }
}

},{"vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/on.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    Extension for Base classes to create an inheritable on - value
  */

var Value = require('./')
  , util = require('../util')
  , Base = require('../base')

exports.extend = util.extend
( function(base)
  {
    if( base instanceof Base )
    {

      base.extend
      (
        {
          name:'on',
          set:function(val) {
            
          },
          remove:function(val) {
            //remove
            // console.log('im being removed!')
             if(this.on.$remove) {
              this.on.$remove.update()
            }
          },
          new:function(val) {
            //init
            // console.log('INIT!----', this, val, arguments)
            if(this.on.$new) {
              this.on.$new.update()
            }
          },
          parent:function(val) {
            //init
            if(this.on.$parent) {
              this.on.$parent.update()
            }
          },
          render:function(val) {
            //init
            // console.log('RENDER!----', this, val, arguments)
            if(this.on.$render) {
              this.on.$render.update()
            }
          }
        }
      )

    }
    else
    {
      throw new Error('cannot extend "on" on non Base Class')
    }
  }
)

},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js":[function(require,module,exports){
/**
 * operators
 * operators can be set on V.Value.operators
 * define operators on this module
 * @property
 */
var util = require('../util')
  , V = require('../')
  
exports.add = function( val, operator ) {
  return val + operator
}
exports.sub = function( val, operator ) {
  return val - operator
}
exports.multiply = function( val, operator ) {
  return val * operator
}
exports.divide = function( val, operator ) {
  return val / operator
}
exports.max = function( val, operator ) {
  return val > operator ? operator : val
}
exports.min = function( val, operator ) {
  return val < operator ? operator : val
}
exports.transform = function( val, operator ) {
  return operator === false ? val : operator
}
exports.abs = function( val, operator ) {
  return operator ? Math.abs(val) : val
}
exports.floor = function( val, operator ) {
  return val | 0
}
exports.ceil = function ( val, operator ) {
  return Math.ceil( val )
}
exports.prepend = function( val, operator ) {
  return operator + val
}
exports.or = function ( val, operator ) {
  return val || operator
}
exports.when = function( val, operator ) {
  return operator && val
}
exports.$convertType = function ( val, operator ) {
  //convertType
  if( operator === 'boolean' )
  { 
    return val ? true : false
  } 
  else if( operator === 'number' )
  {
    //do isNan start using loDash for this kind of stuff ( almost nothing )
    //convert falsy or NaN values to 0
    return Number( val )
  }
}

exports.$convertTime = function( time, decimals ) {
  var hrs = ~~ (time / 3600)
  var mins = ~~ ((time % 3600) / 60)
  var secs = !isNaN(parseFloat(decimals)) && isFinite(decimals)
      ? (time % 60).toFixed(decimals) : ~~(time % 60)

  ret = "";
  if (hrs > 0) ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
  ret += "" + mins + ":" + (secs < 10 ? "0" : "");
  ret += "" + secs;
  return ret || 0;
};

exports.default = function( val, operator ) {

// console.log( '????', val )
  
  //pas op met die 0
  if( (!val && val !== 0) || val._val === false || val === 'error' || val === 'success' )
  {
    //TODO: Arrays for default operator
    return operator
  }
  return val
}

exports.default.order = 1000
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/index.js":[function(require,module,exports){
module.exports = exports = require('./lib/')
},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/lib/index.js":[function(require,module,exports){
var pkg = require('../package.json')
  , pluginId = pkg.plugin.id

module.exports = exports = {}

exports.get = function (opts, cb) {
  if (!cb) {
    cb = opts
    opts = {}
  }
  try {
    window.vigourNative.bridge(pluginId, 'get', opts, cb)
  } catch (e) {
    cb(e)
  }
}

exports.set = function (opts, cb) {
  if (!cb) {
    cb = opts
    opts = {}
  }
  try {
    window.vigourNative.bridge(pluginId, 'set', opts, cb)
  } catch (e) {
    cb(e)
  }
}
},{"../package.json":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/package.json"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/package.json":[function(require,module,exports){
module.exports={"name":"vigour-native-statusBar","version":"2015/06/13 15:02:53 UTC (0.0.1)","author":{"name":"Shawn Inder","email":"shawn@vigour.io"},"repository":{"type":"git","url":"git+https://github.com/vigour-io/vigour-native-statusBar.git","branch":"production"},"engines":{"node":">=0.10.0"},"main":"index.js","scripts":{"start":"gaston","test":"test/test.js"},"description":"Allows one to control the native status bar from a web app","keywords":["vigour","native","plugin","statusBar"],"bugs":{"url":"https://github.com/vigour-io/vigour-native-statusBar/issues"},"homepage":"https://github.com/vigour-io/vigour-native-statusBar","dependencies":{"gaston":"git+ssh://git@github.com/vigour-io/gaston.git","vigour-native":"git+ssh://git@github.com/vigour-io/vigour-native.git","vigour-fs":"git+ssh://git@github.com/vigour-io/vigour-fs.git","vigour-dev-tools":"git+ssh://git@github.com/vigour-io/vigour-dev-tools.git"},"optionalDependencies":{},"devDependencies":{"npm":"^2.7.6","npmlog":"^1.2.0"},"plugin":{"id":"statusbar","android":{"className":"io.vigour.plugin.statusbar.StatusBarPlugin","instantiation":"new StatusBarPlugin(this, webView)","libName":"statusbar-debug.aar"}},"gitHead":"588de4723cbde673fb22b4a28b70472045d3c8ff","readme":"# vigour-native-statusBar\nAllows one to control the native status bar from a web app\n\n##Install\n`npm i vigour-native-statusBar`\n\n##Usage\nSee [test/index.js](test/index.js)\n\n##Building a set of native apps from your codebase\n- `npm run build`\n- `npm run build -- ios android`","readmeFilename":"README.md","_id":"vigour-native-statusBar@0.0.1","_shasum":"81cc25910be7f1595417c3b8fdfb8382b1247f47","_from":"git+ssh://git@github.com/vigour-io/vigour-native-statusBar.git","_resolved":"git+ssh://git@github.com/vigour-io/vigour-native-statusBar.git#588de4723cbde673fb22b4a28b70472045d3c8ff","sha":"0.0.1"}
},{}],"/Users/shawn/Work/directv-fl/src/app/index.js":[function(require,module,exports){
var app = module.exports = require( 'vigour-js/app' )
  .inject(
    require( 'vigour-js/app/content' ),
    require( 'vigour-js/app/user' )
  )

require( './user' )
require( './values' )
require( './playback')
require( './init' )

window.a = app

},{"./init":"/Users/shawn/Work/directv-fl/src/app/init.js","./playback":"/Users/shawn/Work/directv-fl/src/app/playback.js","./user":"/Users/shawn/Work/directv-fl/src/app/user.js","./values":"/Users/shawn/Work/directv-fl/src/app/values.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","vigour-js/app/user":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js"}],"/Users/shawn/Work/directv-fl/src/app/init.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var config = require( 'vigour-js/util/config' )
var user = app.user

// preloader
app.css = {
  addClass: 'preload'
}

user.data.is( 'loaded' )
  //do this later when content gets bound
  .then( function() { 
    app.ready.val = true
    //add this later
    // return app.content.is( 'loaded' ) 
  })
  .done( function() {
    app.css = {
      removeClass: 'preload'
    }
  })



app.initialised.once(true, function() {
  // console.log(document.domain.replace(/\:\d\d\d\d/, ':10001'))

  app.cloud = config.cloud === 'domain' ? document.domain+ ':10001'  : config.cloud
// =======
  // if(window.gaston && window.gaston.serverAddress.indexOf('{') === -1) {
  //   app.cloud = 'ws://' +
  //     window.gaston.serverAddress.split('//')[1].split(':')[0] + 
  //     ':10001'
  // } else {
  //   app.cloud = 'ws://' + config.cloud
  // }
  
// >>>>>>> dev
  user.token.val = 'futureland'
})

/*   
'ws://' 
  + window.gaston.serverAddress.split('//')[1].split(':')[0]
  + ':10001'//
*/

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/app/playback.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var Value = require( 'vigour-js/value' )
var cases = app.cases
var user = app.user

app.isPlaying.val = {
  val: false,
  $isReceiver:user.receiver.playing
}

app.volume = {
  val:1,
  $isReceiver: user.receiver.volume
}

cases.$isPlaying = app.isPlaying

if(cases.$isPhone) {
  app.popup.on(function(val) {
    if(val) {
      if(app.isPlaying.val===true) {
        app.isPlaying.from.val = false
        app.popup.is(function() {
          return this.val === false
        }, function() {
          app.isPlaying.from.val = true
        })
      }
    }
  })
}

cases.$isFullscreen = new Value( {
  val: function() {
    return app.state.val === 'player'
  },
  listen: app.state
} )

// cases.$isLoadingVideo = new Value( {
//   val: false,
//   defer: function( update ) {
//     var _this = this
//     if ( this._timer ) {
//       clearTimeout( this._timer )
//       this._timer = null
//     }
//     if ( this._val ) {
//       this._timer = setTimeout( function() {
//         _this.val = false
//         _this._timer = null
//       }, 2000 )
//     }
//     update()
//   }
// } )

// app.isPlaying.on( function( val ) {
//   if ( cases.$isLoggedIn.val ) {
//     if ( val === true ) {
//       // TODO: this crashes now, so i commented it out
//       // var media = app.user.navigation.media.from
//       // if ( media._parent._name !== 'channels' ) {
//       //   var epi = app.user.usage.from.get( media._contentPath ),
//       //     show = epi._parent._parent._parent._parent

//       //   if ( show ) {
//       //     show.set( 'media', media )
//       //   }
//       // }
//     }
//   }
// })

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/app/user.js":[function(require,module,exports){
var app = require('vigour-js/app')
var user = app.user.inject(
  require('vigour-js/app/user/token'),
  require('vigour-js/app/user/usage'),
  require('vigour-js/app/user/navigation'),
  require('vigour-js/app/user/multiscreen')
)

user.set({
  search: false,
  focus_row: 'spotlight',
  // focus_channels:0,
  focus_actor:0,
  focus_channels:0,
  focus_spotlight:0,
  focus_watching:0,
  focus_recommended:0,
  focus_releases:0,
  recentSearches: {},
  popup:0,
  trailerMuted:true
  // url: require( 'vigour-js/browser/network/url' )
})

app.popup.val = user.popup

var Value = require('vigour-js/value')

app.deviceMessage = new Value({
  val: user.receiverClient,
  transform: function( c, cv ){
    var title = cv && cv.from && cv.from.title && cv.from.title.val
    // console.error('deviceMessage! ', title)
    return title ? 'Connected to ' + title : 'Not Connected'
  }
})

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/user/multiscreen":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/multiscreen/index.js","vigour-js/app/user/navigation":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/navigation.js","vigour-js/app/user/token":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/token.js","vigour-js/app/user/usage":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/usage.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/app/values.js":[function(require,module,exports){
var app = require('./')
var ua = require('vigour-js/browser/ua')
var user = app.user
var cases = app.cases
var Value = require('vigour-js/value')
  // TODO: base this on device role
// app.state.val = {
//   default: 'first'
// }

app.state.val = cases.$isPhone ? 'first' : 'second'

app.current = new Value({
  val: user.navigation.last,
  transform: function(v, last) {
    var key = last.key && last.key.val
    return key === 'page' ? user.navigation.page.val : key
  },
  listen: [
    user.navigation.content,
    user.navigation.page
  ]
})

app.previous = new Value({
  val:app.current,
  defer:function(update,args){
    var val = this._val.val
    if(typeof val === 'string' && val !== this.current){
      this.prev = this.current
      this.current = val
    }
    update()
  },
  transform:function(val){
    return val._parent.prev || 0
  }
})

app.secondPopup = new Value(false)

app.hideStatusbar = new Value({
  val: false,
  transform: app.isPlaying
})

cases.$hasReceiver.on(function() {
  app.css = this.val ? {
    addClass: 'hasReceiver'
  } : {
    removeClass: 'hasReceiver'
  }
})

cases.$isIFE = ua.device === 'IFE'

if(!cases.$isPhone){
  cases.$isReceiver.on(function(){
    app.state.val = this.val ? 'second' : 'inactive'
  })
}
},{"./":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/channel/index.js":[function(require,module,exports){
require('./style.less')

var Actors = require('/Users/shawn/Work/directv-fl/src/components/shared/actors')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')
var Progress = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar').Bar
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Poll = require('/Users/shawn/Work/directv-fl/src/components/shared/poll')
var Statistics = require('/Users/shawn/Work/directv-fl/src/components/shared/statistics')
var Trivia = require('/Users/shawn/Work/directv-fl/src/components/shared/trivia')
var Content = require('../content')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/bar')
var Tweets = require('/Users/shawn/Work/directv-fl/src/components/shared/tweets')

module.exports = new Content({
  'holder.page': {
    container:{
      'model.field':'guide.0',
      titlebar:new Bar({
        css: 'ui-bar',
        accent: {},
        left: {
          title:new Title(),
          timefiller: {
            'left.text.data':'start-time',
            'middle.filler': new Progress({
              'seek.w': '75%'
            }),
            'right.text.data':'end-time'  
          }  
        }
      }),
      description:new Description({
        display:{
          data:'description',
          transform:function(v,cv){
            return cv ? 'block' : 'none'
          }
        }
      }),
      actors:new Actors(),
      poll:new Poll(),
      statistics:new Statistics(),
      trivia:new Trivia(),
      tweets:new Tweets(),
    },
    collection:{
      data:'guide',
      element:new Bar({
        left: {
          title:new Title(),
          info: {
            'left.text':{
              data:'start-time',
              add:[
                ' - ',
                {data:'end-time'}
              ]
            }
          }  
        }
      })
    }
  }
}).Class

},{"../content":"/Users/shawn/Work/directv-fl/src/components/active/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/channel/style.less","/Users/shawn/Work/directv-fl/src/components/shared/actors":"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js","/Users/shawn/Work/directv-fl/src/components/shared/bar":"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/poll":"/Users/shawn/Work/directv-fl/src/components/shared/poll/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/statistics":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","/Users/shawn/Work/directv-fl/src/components/shared/trivia":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js","/Users/shawn/Work/directv-fl/src/components/shared/tweets":"/Users/shawn/Work/directv-fl/src/components/shared/tweets/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/channel/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/content/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Player = require('/Users/shawn/Work/directv-fl/src/components/active/player')
var Topbar = require('/Users/shawn/Work/directv-fl/src/components/active/topbar')

module.exports = new Element({
  css: 'content-item',
  x: {
    translate: true
  },
  scrollbar: 'y',
  holder: {
    y: {
      val: 0,
      animation: {
        time: 18,
        easing: 'outCubic',
        complete: function() {
          var _this = this
          if (this.y.val === -this.player.h.val - 1) {
            if (!_this.isSwipedup.val) {
              _this.swipeup.display = 'none'
            }
            if (!_this.timeouty) {
              _this.timeouty = setTimeout(function() {
                if (_this.isSwipedup.val) {
                  _this.swipeup.display = 'block'
                }
                _this.timeouty = false
                _this.y.val = _this.isSwipedup.val ? -_this.player.h.val + 30 : 0
              }, 0)
            }
          }
        }
      }
    },
    player: new Player(),
    swipeup: {
      display: 'none',
      nested: {
        position: 'absolute',
        w: app.w,
        h: app.h,
        msg:{
          icon:new Icon({
            icon:'pullback'
          }),
          text: 'Resume Here'
        },
        'events.click': function() {
          app.user.receiver.media.$userOrigin = false
        }
      },
      y: {
        val: app.h,
        multiply: -1
      },
      h: app.h
    },
    extend: {
      isSwipedup: function(val) {
        if (!this.rendered && val && val.val) {
          this.swipeup.display = 'block'
          this.y = -this.player.h.val + 30
        } else if (this.swipeup.display.val === 'block') {
          this.y = -this.player.h.val - 1
        } else {
          this.y = val.val === true ? -this.player.h.val - 1 : 0
        }
      },
      receiverMedia: function(val) {
        var data = this.parent.data
        if(data){
          var swipeup = this.isSwipedup = val.from === data.from
          if (swipeup) {
            this.player.playing.from = false
          } else {
            var time = data.from.get('time')
            if (time.val < 0) {
              data.from.get('time').val = Math.abs(time.val)
            }
          }
        }
      }
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/active/content/style.less","/Users/shawn/Work/directv-fl/src/components/active/player":"/Users/shawn/Work/directv-fl/src/components/active/player/index.js","/Users/shawn/Work/directv-fl/src/components/active/topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/content/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/discover/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var _focused = require('/Users/shawn/Work/directv-fl//src/components/util').focused
var List = require('/Users/shawn/Work/directv-fl//src/components/shared/list')

var ListHolder = new Element( {
  'header.text':{data:'title'},
  'events.down': function( e ) {
    var _this = this
    var holder = this.parent
    var eY = e.y
    var eX = e.x
    var id = 'passCheck'

    this.addEvent( 'move', function( e ) {
      var dY = e.y - eY
      var dX = e.x - eX
      if ( Math.abs( dX ) > Math.abs( dY ) ) {
        holder.$focus.$userOrigin = _this.name
      }
      _this.removeEvent( false, id )
    }, id )

    this.addEvent( 'up', function( e ) {
      _this.removeEvent( false, id )
    }, id )
  }
} ).Class

module.exports = new Element( {
  css: 'first-discover',
  spotlight: new ListHolder( {
    header:false,
    list: new List.Spotlight({'model.field':'spotlight'}),
    dots: new List.Dots()
  } ),
  channels: new ListHolder({
    model:{field:'channels'},
    list: new List.Channel()
  } ),
  watching: new ListHolder( {
    model:{field:'watching'},
    list: new List.Watching()
  } ),
  releases: new ListHolder( {
    model:{field:'releases'},
    list: new List.Poster()
  } ),
  recommended: new ListHolder( {
    model:{field:'recommended'},
    list: new List.Poster()
  } ),
  extend:{
    $focus: function( val ) {
      var child = typeof val.val === 'string'
        ? this[val.val]
        : this.children[ val.val || 0 ]
      _focused( this, child )
    }
  },
  scrollbar: 'y',
  'events.scroll': function( e ) {
    if(exports.ignoreScroll) return
    var node = this.node
    var fraction = (exports.scrollTop = node.scrollTop) / ( node.scrollHeight - node.offsetHeight )
    var index = Math.round( fraction * ( this.children.length - 1 ) )
    var name = this.children[index].name
    this.$focus.$userOrigin = name
  },
  setSetting: {
    name: 'prepValues',
    parent: function() {
      var children = this.children
      var child
      var field
      var length = children.length
      var i = length - 1
      var obj

      for ( ; i >= 0; i-- ) {
        child = children[i]
        field = 'focus_' + children[i].name
        if ( !app.user[ field ] ){
          obj = {}
          obj[ field ] = 0
          app.user.set( obj )
        }
        child.list.$focus = app.user[ field ]
        if(child.dots) child.dots.container.$focus = app.user[ field ]
      }

      if(exports.scrollTop){
        exports.ignoreScroll = true
        this.node.scrollTop = exports.scrollTop
        window.requestAnimationFrame(function(){
          exports.ignoreScroll = false
        })
      }else{
        var _this = this
        exports.ignoreScroll = true
        window.requestAnimationFrame(function(){
          exports.ignoreScroll = false
          var node = _this.node
          if(node){
            var focus = _this.$focus.val
            var index = getIndex(_this[focus])
            node.scrollTop = index/(length - 1) * ( node.scrollHeight - node.offsetHeight )
          }
        })
      }

    }
  }
} ).Class

function getIndex( _this ){
  if (_this._index === void 0) {
    var siblings = _this.parent.children
    for (var i = siblings.length - 1; i >= 0; i--) {
      siblings[i]._index = i
    }
  }
  return _this._index
}

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/active/discover/style.less","/Users/shawn/Work/directv-fl//src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/discover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/episode/index.js":[function(require,module,exports){
require('./style.less')

var Movie = require('../movie')

module.exports = new Movie({
  'holder.page': {
    'actors.body.collection.data':'show.actors',
    'recommendations.body.collection.data':'show.recommendations'
  }
}).Class


},{"../movie":"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/episode/style.less"}],"/Users/shawn/Work/directv-fl/src/components/active/episode/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var cases = app.cases
var Topbar = require('./topbar')
var Menu = require('./menu')
var Remote = require('./remote')
var Popup
var First

//app alleen maar zo requiren zodat je erbij kan vars moeten altijd megegevb wirden
//app kan je usen voor dingen als app.w, app.h of default cases

if ( cases.$isPhone ) {

  var Switcher = require( './switcher' )

  First = new Element({
    // w:app.w,
    y:{val:0,translate:true},
    // h:app.h,
    css: 'first-state',
    menu: new Menu({
      menu: app.menu
    }),
    on: {
      //replace on with extended vars (nicer) maybe make a type for this (value that also tries to get parent if its no full)
      //value that has a function on it thats just the defer?
      popup:{
        defer:function(update) {
          this.clearCache()
          var caller = this._parent._caller
          if(typeof this.val === 'string' || this.from._contentType === 'actors') {
            if(!caller.popup) {
              Popup = Popup || require('./popup')
              caller.set({
                popup: new Popup({
                  popup:this._val
                })
              })
            }
          }
          update()
        }
      },
      secondPopup:{
        defer:function(update) {
          this.clearCache()
          var caller = this._parent._caller
          if(typeof this.val === 'string' || this.from._contentType === 'actors') {
            if(!caller.volume) {
              Popup = Popup || require('./popup')
              caller.set({
                volume: new Popup({
                  popup:this._val
                })
              })
            }
          }
          update()
        }
      }
    },
    holder: {
      css:{
        val: app.menu, 
        transform: function(val, cv) {
          return cv ? 'open' : ''

        }
      },
      x:{ 
        val: app.menu,
        multiply:325,
        animation:{ time: 12, easing:'outCubic' } 
      },
      topbar: new Topbar(),
      // w: {
      //   parent: 'w'
      // },
      // h:{
      //   parent: 'h'
      // },
      events: {
        down:function(e) {
          if(app.menu.val) {
            e.prevent = true
            app.menu.val = false
          }
        }
      },
      switcher: new Switcher({
        // w:app.w,
        // h:{ val:app.h,sub:Topbar.base.h }
      }),
      miniplayer: new Remote({
        
      }) 
    }
  }).Class

} else {

  First = new Element({
    text: 'oops not phone in firstscreen'
  }).Class

}

module.exports = First
},{"./menu":"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js","./popup":"/Users/shawn/Work/directv-fl/src/components/active/popup/index.js","./remote":"/Users/shawn/Work/directv-fl/src/components/active/remote/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/style.less","./switcher":"/Users/shawn/Work/directv-fl/src/components/active/switcher/index.js","./topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js":[function(require,module,exports){
require('./style.less')
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')

var MenuItem = new Element({
	icon: new Icon({icon:'search'}),
	css:'menu-item',
	title:{}
}).Class

module.exports = exports = new Element({
	w:app.w,
	h:app.h,
	logo: {},
	css:'menu',
	extend: {
		menu:function(){},
		navigation:function(){}
	},
	// scrollbar:'y',
	append: [
		MenuItem,
		{ 'title.text':'search',
			'icon.icon': 'searchMenu',
			'events.click':function() {
				this.parent.navigation.from.page.$userOrigin = 'search'
				this.parent.menu.from.val = false
			}
		},
		{ 'title.text':'discover',
			'icon.icon': 'discover',
		 'events.click':function() {
				this.parent.navigation.from.page.$userOrigin = 'discover'
				this.parent.menu.from.val = false
			}
		},
		{
			'title.text':'on demand',
			'icon.icon': 'shows',
			css:'menu-item inactive'
		},
		{
			'title.text':'live tv',
			'icon.icon': 'tv',
		  css:'menu-item inactive'
		},
		{
			'title.text':'guide',
			'icon.icon': 'epg',
			css:'menu-item inactive'
		}
	],
	footer: {
		profile:{},
		title: {
			text:'Kevin Tague'
		},
		settings: new Icon({
			icon:'settings'
		})
	}
}).set({
	navigation:{
		defer:function(update) {
			if(this.from.page) {
				for(var i in this._caller.children) {
					var child = this._caller.children[i]
					var title = child.title &&  child.title.text.val
					var page = this.from.page.val

					if( title && title===page && this._focused!==child) {
						if(this._focused) {
							this._focused.css ='menu-item'
						}

						this._focused = this._caller.children[i]
						this._focused.css = 'menu-item focused' 
						break;
					}
				}
			}
			update()
		}
	}
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/menu/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/menu/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js":[function(require,module,exports){
require('./style.less')

var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/bar')
var Actors = require('/Users/shawn/Work/directv-fl/src/components/shared/actors')
var Recommendations = require('/Users/shawn/Work/directv-fl/src/components/shared/recommendations')
var Content = require('../content')
var Mpaa = require('/Users/shawn/Work/directv-fl/src/components/shared/mpaa')
var Rating = require('/Users/shawn/Work/directv-fl/src/components/shared/rating')

module.exports = new Content({
  'holder.page': {
    titlebar:new Bar({
      left:{
        title:new Title(),
        subtitle:new Subtitle()
      },
      right:{
        mpaa:new Mpaa(),
        rating:new Rating()
      }
    }),
    description: new Description(),
    actors:new Actors(),
    recommendations:new Recommendations()
  }
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/active/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/movie/style.less","/Users/shawn/Work/directv-fl/src/components/shared/actors":"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js","/Users/shawn/Work/directv-fl/src/components/shared/bar":"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mpaa":"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js","/Users/shawn/Work/directv-fl/src/components/shared/rating":"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js","/Users/shawn/Work/directv-fl/src/components/shared/recommendations":"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/movie/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/player/fullscreen.js":[function(require,module,exports){
// fullscreen.js
var app = require('vigour-js/app')

module.exports = function() {
  var player = this
  var holder = player.parent
  var topbar = holder.checkParent('topbar',true)
  var switcherHolder = holder.checkParent('switcher', true)
  if(player.isFullscreen) {
    player.set(player.revertFullscreen)
    switcherHolder.h = { val: app.h, sub: topbar.h.val }
    holder.set({
      page: {
        display:'block'
      },
      swipeup: {
        display:{transform:null}
      }
    })
    topbar.display = 'table'
    player.isFullscreen = null
  } else {
    player.revertFullscreen = player.revertFullscreen 
      || ({
        w:'100%',
        h:player.h.val,
        rotate:0,
        x:{val:0,translate:true}
      }) 
    player.set({
      rotate:90,
      w:app.h,
      h:app.w,
      x:{ val: app.w, translate: true},
    })
    switcherHolder.h = { val: app.h, sub: 0 }

    holder.set({
      page: {
        display:'none'
      },
      swipeup: {
        display:{transform:'none'}
      }
    })
    topbar.display = 'none'
    player.isFullscreen = true


    // player.node.style.zIndex = 10
  }
}

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/player/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Video = require('vigour-js/browser/element/video')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var app = require('vigour-js/app')
var Seekbar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar')
var fullscreen = require('./fullscreen')
var postpone = require('vigour-js/browser/events/util').postpone
var ASSETS = require('vigour-js/util/config').pointers.assets
var cases = require('vigour-js/browser/cases')
var Loader = require('/Users/shawn/Work/directv-fl/src/components/shared/loader')

module.exports = new Element({
  css:'first-player',
  video: new Video({
    player: require( 'vigour-js/browser/element/video/html5' ),
    src: { data: 'video', prepend: ASSETS },
    duration: { data: 'duration' },
    volume: 1,
    time: { data: 'time' },
    events:{
      stalled:function() {
        if( this.rendered ) this.parent.preload(true)
      },
      play: function() {
        if(this.rendered && this.getBuffer()<0.001) {
          this.parent.preload(true)
        }
      },
      canplay:function() {
        this.parent.preload(false)
      },
      progress: function(p, b) {
        if(this.prev && p > this.prev ) {
          this.parent.preload(false)
        } 
        this.prev = p
        this.data.from.set('time', -Math.abs(p))
      }
    }
  }),
  h:210,
  overlay: {
    middle: {
      left: { play: {
          icon: new Icon({ 
            icon: {
              val: 'play',
              $isPlaying: 'pause'
            } 
          }),
          subtitle: {
            text: {
              val: 'Play',
              $isPlaying: 'Pause'
            }
          },
          events: {
            down: function(e){
              if(this.checkParent('overlay',true).opacity.val > 0.5) {
                var playing = this.checkParent('overlay').playing.from
                playing.val = !playing.val
                e.prevent = true
              }
            }
          }
        }
      },
      middle: { 
        line: {},
        display: {
          val: 'none',
          $hasReceiver: 'table-cell',
          transform: function(){}
        }
      },
      right: { 
        swipeup: {
          icon: new Icon({ icon: 'swipeup' }),
          subtitle: {
            text: 'Play on '
          },
          events: {
            down: function(e){
              var player = this.checkParent('overlay')
              if(player.isFullscreen) {
                fullscreen.call(player)
              }
              if(player.overlay.opacity.val > 0.5) {
                app.user.receiver.playing.$userOrigin = true
                app.user.receiver.media.$userOrigin = this.checkParent('data',true).from
                e.prevent = true
              }
            }
          }
        },
        display: {
          val: 'none',
          $hasReceiver: 'table-cell',
          transform: function(){}
        }
      }
    },
    bottom: {
      left: { 
        table: {
          display: {
            data:function(data) {
              return data._contentType==='channels' ? 'none' : 'table'
            }
          },
          time:{ 
            holder: { 
              text:{ 
                data:'time', 
                multiply: { data:'duration' }, 
                abs:true, 
                $convertTime:true 
              } 
            } 
          },
          holder :{
            seekbar: new Seekbar()
          },
          duration:{ text:{ data:'duration', $convertTime:true } }
        }
      },
      right: { 
        fullscreen: new Icon({
          icon:'fullscreen',
          events: {
            click:function() {
              var player = this.parent.parent.parent.parent
              fullscreen.call(player)
            }
          }
        }) 
      }
    },
    opacity: {
      val:1, animation:{
        time:18,
        easing:'outCubic'
      }
    }
  },
  define: {
    preload: function(val) {
      var overlay = this.overlay
      if(!overlay || this.video.data.from._contentType==='channels') return
      if(val===true && this.rendered) {
       this.preloading = true
       overlay.bottom.left.table.holder.seekbar.css = 'ui-seekbar loading'
       overlay.opacity = 1
      } else {
        overlay.bottom.left.table.holder.seekbar.css = 'ui-seekbar'
        if(this.video.$playing.val===true && this.preloading) {
          overlay.opacity = 0
        }
        this.preloading = false
      }
    },
    fadeOut:postpone(function() {
      var overlay = this.overlay
      if(!overlay) return
      if(this.playing && this.playing.val===true && !this.preloading) {
        overlay.opacity = 0
      }
    },3000)
  },
  events: {
    down: function(e) {
      var overlay = this.overlay
      if(!overlay) return
      if(overlay.opacity.val===0 || e.tempPrevent) {
        overlay.opacity = 1 
        if(this.playing.val===true) {
          this.fadeOut()
        }
      } else if(this.playing.val===true && !e.tempPrevent) {
        overlay.opacity = 0
      }
    },
    move:function() {
      if(this.playing.val===true) {
        this.fadeOut()
      }
    }
  },
  extend:{
    playing: {
      set:function(val) {
        this.video.$playing = val
        if(val.val===true) {
          this.overlay.opacity = 0
        } else {
          this.overlay.opacity = 1
        }
      },
      remove:function() {
        app.isPlaying.from = false
      }
    },
    receiver: function(val, stamp) {
      if(cases.$hasReceiver.val) {
        var receiverClient = val.from
      }
    }
  }
}).Class
},{"./fullscreen":"/Users/shawn/Work/directv-fl/src/components/active/player/fullscreen.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/player/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/loader":"/Users/shawn/Work/directv-fl/src/components/shared/loader/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/player/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/index.js":[function(require,module,exports){
require('./style.less')

var Page = require('../page.js')
var app = require('vigour-js/app')
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var List = require('/Users/shawn/Work/directv-fl/src/components/shared/list')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var Trivia = require('/Users/shawn/Work/directv-fl/src/components/shared/trivia')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')

module.exports = exports = new Page({
  w: app.w,
  h: {
    val: app.h,
    sub: 60
  },
  scrollbar: 'y',
  carousel: {
    container: new List.Carousel({
      collection: {
        data: 'img.cover',
        element: new Element({
          css: 'focus-item',
          img: new Img({
            overlay: {},
            'background.data': true
          })
        })
      },
      $focus: {
        data: 'focus'
      }
    }),
    dots: new List.Dots({
      container: {
        collection: {
          data: 'img.cover',
          element: new Element()
        },
        $focus: {
          data: 'focus',
          default:0
        }
      }
    }),
    'model.subscription': {
      img: {
        cover: {
          $: true
        }
      }
    }
  },
  bio: new Description({
    'header.text': 'bio',
    'body.text.data': 'bio'
  }),
  famous: {
    'header.text': 'Famous For',
    collection: {
      data: 'catalog',
      element: new Poster({
        'events.click': function() {
          app.popup.$userOrigin = false
          app.user.navigation.content.$userOrigin = this.data.from
        }
      })
    }
  },
  model: {
    subscription: {
      title:true 
      //dont know why this works -- but it does
    }
  },
  trivia: new Trivia({
    model: {
      field: 'trivia'
    }
  }),
  footer:{},
  on: {
    $parent: {
      defer: function(update) {
        this._parent._caller.parent.parent.topbar.middle.text = this._parent._caller.data.get('title')
        update()
      }
    }
  }
}).Class

},{"../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/style.less","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl/src/components/shared/trivia":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var cases = require( 'vigour-js/browser/cases' )
var ua = require( 'vigour-js/browser/ua' )

var raf = require( 'vigour-js/browser/animation/raf' )
var app = require( 'vigour-js/app' )
var Icon = require( '../../../shared/icon' )

var Device = new Element({
  css: 'device',
  icon: new Icon({ icon: { 
    data: 'device'
  } }),
  info: {
    title: { text: { data: 'title'} },
    subtitle: { text: { data: 'info' } }
  }
}).Class

module.exports = exports = new Element( {
  css: 'active devices',
  myDevice: new Device({
    model: { inherit: false },
    on: {
      $new: {defer: function(update){
        this._parent._caller.data = app.cloud.client
        update()
      }}
    },
    info: {
      title: { text: 'This Device' },
      subtitle: { text: { data: 'title' } }
    }
  }),
  listTitle: { text: 'Available Devices' },
  middle: {
    display: {
      val: 'block',
      $hasDevices: 'none'
    },
    text: 'No Devices Available'
  },
  list: {
    display: {
      val: 'none',
      $hasDevices: 'block'
    },
    collection: {
      element: new Device( {
        css: 'device',
        model: function( data ) {
          if( data && data.from && data.from.device && 
              /(phone)/.test(
                data.from.device.val 
              )
            ) {
            this.opacity = 0.5
          }
        },
        events: {
          click: function() {
            var user = app.user//this.checkParent( 'on.user', true )._val
            var client = this.data.from
            if( /(tv)|(tablet)|(IFE)/.test( 
                  client.device.val 
                ) 
              ) {
              user.setReceiver( client )
            }
          }
        }
      } ),
      data: true
    }
  },
  on: {
    $render: {
      defer: function(update) {
        // ff binden nog
        var caller = this._parent._caller
        caller.on.devices._val._update()
        update()
      }
    },
    $parent:{
      defer:function(update) {
        this._parent._caller.parent.parent.topbar.middle.text = 'devices'
        update()
      }
    },
    devices: {
      defer: function( update ) {
        var caller = this._parent._caller
        caller.on.receiver._update()
        caller.data = this.from
        update()
      }
    },
    receiver: {
      defer: function( update ) {
        var _this = this
        // TODO: get rid of this raf
        raf( function() {
          if ( _this._parent ) {
            var caller = _this._parent._caller
            var receiver =  _this.from
              
            var elem = caller.list.find( '_d.from', receiver.from )
            if ( elem ) {
              if ( _this.focus && _this.focus._node ) {
                _this.focus.css = {
                  removeClass: 'focused'
                }
              }
              _this.focus = elem
              elem.css = {
                addClass: 'focused'
              }
            } else if ( _this.focus ) {
              if ( _this.focus && _this.focus._node ) {
                _this.focus.css = {
                  removeClass: 'focused'
                }
                _this.focus = null
              }
            }
          }
          update()
        } )
      }
    }
  }
} ).Class

},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')

var Popup = require('../../shared/popup')

var Actor
var Volume
var Devices
var Remote

//basis of popup is shared (also used for remote? or is remote a popup thing?)

module.exports = exports = new Popup({
  popup:{
    // misc:function(update) {
    //  var val = this.val
    //  //dit is gedeeld -- zou ook vanuit app kunnen eventueel
    // },
    defer:function(update,args) {

      this.clearCache()
      
      var val = this.val
      var element
      var switcher = this._caller && this._caller.switcher
      var params = {}
      var topbarParams

      if(!switcher) {
        return true
      }

      if(val === false) {
        // console.error('wtf is happenin????')
        this._caller.y = app.h.val
      } else if(this.from._contentType === 'actors') { //listen to misc different!
        //word if this._contentType === 'actor' // doe dit -- popup.val word op gelistend in app
        element = Actor = Actor || require('./actor')
        params = { 
          // carousel:{
          //   container:{
          //     $focus: this.from.get('focus',2)
          //   },
          //   dots:{
          //     container:{
          //       $focus: this.from.get('focus',2)
          //     }
          //   }
          // },
          data: this.from
        }
      } else if(val === 'volume') { //listen to misc different!
        element = Volume = Volume || require('./volume')
      } else if(val === 'devices') { //listen to misc different!
        // topbar.middle.text.val = app.deviceMessage
        element = Devices = Devices || require('./devices')

        var user = app.user

        params = {
          on: {
            devices: user.devices,
            receiver: user.receiverClient
          }
        }
      } else if(val === 'remote') { //listen to misc different!
        element = Remote = Remote || require('./remote')
        topbarParams = {
          // left:{
          //   icon:'navDown'
          // },
          middle:{
            text:{data:'title'},
            data:app.user.receiver.media
          }
          // right:{
          //   display:'none'
          // }
        }
      } 

      if(element) {
        switcher.transition = {
          element: element,
          $params: params
        }
      }

      if(topbarParams){
        switcher.parent.topbar.set(topbarParams)
      }

      update()
    }
  }
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../shared/popup":"/Users/shawn/Work/directv-fl/src/components/shared/popup/index.js","./actor":"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/index.js","./devices":"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/index.js","./remote":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/style.less","./volume":"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

//maybe add scroll, only when list is too large
module.exports = new Element({
  // css:'popup-page'
// x:{translate:true}
// , scrollbar:'y'
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/carousel.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('../../../shared/icon')
var List = require('../../../shared/list')
var offset = require('vigour-js/browser/events/offset')

var thumb = new List.Item.Info({
	css:'carousel-item',
	scale:{
		parent:'x',
		transform:function(){
			var rect = this.node.getBoundingClientRect()
			var left = rect.left
			var right = rect.right
			var middle = app.w.val/2
			var width = rect.width
			var val = Math.max(1 - Math.abs((left + width/2) - middle)/1000,0.8)
			this.css = left <= middle && right >= middle
				?	'carousel-item front'
				: 'carousel-item'
			return val
		}
	},
  'events.click':function() {
  	app.popup.$userOrigin = false
    app.user.navigation.content.$userOrigin = this.data.from
  }
})

module.exports = exports = new Element({
	w:app.w,
	h:240,
	extend: {
		media: function(val) {
			var _this = this
			var slider = this.slider
			var children = slider.children

			for(var i in children) {
				var child = children[i]
				if(child.data === val.from && this.focused !== child) {
					if(!slider._check && children.length > 1){
						slider.x._p = true
						slider.$focus = i
						slider.x._p = null
						slider._check = true
					}else{
						slider.$focus = i
					}
					if(!this.listenFocus) {
						this.listenFocus = true
						slider.$focus.on(function() {
							var focus = slider.children[this.val].data
							if(val.from!==focus && focus) {
								app.user.receiver.media.$userOrigin = focus

								focus.get('time').is('loaded', function() {
									if(app.user.receiver.media.from===focus) {
										this.val = Math.abs(this.val)
									}
								})
							}
						})
					}
				}
			}
			// }
		}
	},
	slider: new List.Carousel({
		x:{val:280-30+2},
		collection: {
			data:true,
			filter:true,
			element:thumb
		},
		model:{
			complete:function(){
				if(this.children[1] && this.parent.media){ // force an update when children are ready
					this.x._p = true
					this.parent.media.update()
					this.model = false
					this.x._p = null
				}
			}
		}
	})
}).Class


},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../../shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/offset":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/index.js":[function(require,module,exports){
require('./style.less')

var Page = require( '../page.js' )
var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Seekbar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar')

var Carousel = require('./carousel')

var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')

var Guide = new Element({
	'header.text': 'Up Next',
	items: {
		collection: {
			data:'guide',
			element: new Element({
				css:'body',
				title: { text: { data:'title' } },
				subtitle: {
					text: {
						data:'start-time',
						add:[ ' - ', { data:'end-time' } ]
					}
				}
			})
		}
	}
}).Class

module.exports = exports = new Page({
	css:'remote',
	// text:{val:'remoteit!'},
	carousel: new Carousel(),
	info: {

	},
	controls: {
		title: { text:{ data:'guide.0.title', default:{data:'title'} }},
		seekbar: new Seekbar({
			// button: { y:{ val:-8,translate:true } }
		}),
		buttons: {
			left: new Icon({
				icon:'rewind'
			}),
			play: new Icon({
				extend: {
					playing: function(val) {
						this.icon = val.val === true ? 'pause' : 'play'
					}
				},
				icon:'play',
				'events.click':function() {
					this.playing.$userOrigin = !this.playing.val
				}
			}),
			right: new Icon({
				icon:'fastforward'
			}),
			volume: new Icon({
				icon:'volume',
				'events.click': function() {
					app.secondPopup.val = 'volume'
				}
			})
		}
	},
	extend: {
		receiverMedia: function(val) {
			var info = this.info
			var from = val.from
			this.controls.data = val.from
			//bug fix
			var seek = this.controls.seekbar.seek
			seek.w.update(seek)

			if(from._contentType==='channels') {
				if(info.guide&&info.guide.data !== from) {
					info.empty()
				}
				if(!info.guide) {
					info.empty()
					info.set({
						guide: new Guide({data:from})
					})
					this.carousel.data = app.content.get('channels')
				}
				this.carousel.media = from

			} else if( from._contentType !== 'receiver') {
				if(info.description && info.description.data !== from) {
					info.empty()
				}
				if(!info.description) {
					info.empty()
					info.set({
						description: new Description({data:from})
					})
					if(from._contentType==='movies') {
						this.carousel.data = app.content.get('movies')
						//focus gaat weird!
					} else if(from._contentType === 'episodes') {
						//content type word episode ---
						//harder to do
						this.carousel.data = from._parent
					}
				}
				this.carousel.media = from
			}
		}
	},
	on: {
		$parent:{ defer:function(update) {
			this._parent._caller.parent.parent.topbar.middle.text = 'remote'
			//dirty location but fine for now
			app.popup.once(function(){
				if(	this.val===false 
				 && app.user.navigation.content.from !== app.user.receiver.media.from ) {
					app.user.navigation.content.$userOrigin = app.user.receiver.media.from
				}
			})

			update()
		}},
		$new:{defer:function(update) {
			this._parent._caller.receiverMedia = app.user.receiver.media
			this._parent._caller.controls.buttons.play.playing = app.user.receiver.playing
			update()
		}}
	}
}).Class



},{"../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./carousel":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/carousel.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/style.less","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Page = require( '../page.js' )
var Icon = require('../../../shared/icon')
var offset = require('vigour-js/browser/events/offset')

require('./style.less')

module.exports = exports = new Page({
	w:app.w,
	css:'volume',
	top: {
		title: { text: '100%' },
		volume: new Icon({
			icon:'volume', 
			'events.click': function() {
				this.parent.parent.volume.$userOrigin = 1
			}
		})
	},
	extend: {
		volume:function(val) {
			if(!this._volset && val.from!==val) {
				this._volset = true
				this.slider.block.y = val
				this.slider.block.middle.text = val
			}
		}
	},
	on: {
		$new:{ 
			defer:function(update) {
				var caller = this._parent._caller
				if(!caller.volume) {
					caller.volume = app.user.receiver.volume
				}
				update()
			} 
		},
		$parent:{
			defer:function(update) {
				this._parent._caller.parent.parent.topbar.middle.text.val = 'volume'
				update()
			}
		}
	},
	slider: {
		w: app.w,
		h:{val:app.h,sub:350},
		x:{max:0,min:0},
		block: {
			y:{ 
				transform: function(v,cv) {
					cv = cv>-1 ? cv : 1
					return (this.parent && (this.parent.h.val-30)-60)*( 1-cv )+30
				}
			},
			events: {
				drag:function(e) {

					if( !this._offset ) {
						this._offset = offset.y(this.parent)
					}
					//dragstart
					if(!this._draginfos) {
						this._draginfos = e.y-offset.y(this)+this._offset
					}
				
					var calc = 1 - ( e.y - this._draginfos ) / (this.parent.h.val-30)
					if(calc>1) calc = 1
					if(calc<0) calc = 0
					this.parent.parent.volume.$userOrigin = calc
				},
				up:function() {
					this._draginfos = false
				}
			},
			left: new Icon({
				icon: 'menu'
			}),
			middle: {
				text: { 
					transform: function(c, cv) {
						return Math.round(cv*100)+'%'
					}
				}
			},
			right: new Icon({
				icon: 'menuRight'
			}),
			// w:{val:app.w,sub:30},
			h:60
		}
	},
	mute: {
		muted: new Icon({icon:'muted'}),
		'events.click':function() {
			this.parent.volume.$userOrigin = 0
		}
	}
}).Class



},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/offset":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/remote/index.js":[function(require,module,exports){
require('./style.less')

var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('../../shared/icon')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')

module.exports = exports = new Element({
	css:'mini-remote',
	y:{val:0,animation:{ time:10, easing:'outCubic'}},
	extend: {
		playing: function(val) {
			this.right.icon = val.val === true ? 'pause' : 'play'
		},
		media: function(val) {
			var type = val.from._contentType
			if( type === 'movies' || type === 'channels' || type === 'series' || type === 'episodes' ) {
				var _this = this
				// setTimeout(function() {
				// 	_this.parent.switcher.h = { add:-50 }
				// },500)

				this.y = 0
				if(this.data!==val.from) {
					this.data = val.from
				}
			} else {
				// this.parent.switcher.h = { add:0 }
				this.y = 50
			}
		}
	},
	left: {
		background: {
			val:config.pointers.assets,
			add: { data: 'img.thumb' }
		}
	},
	middle: {
		title: {
			text:{data:'title'}
		},
		info:new Subtitle()
	},
	right: new Icon({
		icon:'play',
		'events.click':function(e) {
			e.prevent = true
			this.parent.playing.$userOrigin = !this.parent.playing.val
		}
		//hier ff die listening
	}),
	'events.click': function(e) {
		app.popup.$userOrigin = 'remote'
	}
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/remote/style.less","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/remote/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/search/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var postpone = require('vigour-js/browser/events/util').postpone
var timestamp = require('monotonic-timestamp')
var config = require('vigour-js/util/config')
var Topbar = require('../topbar')
var search = require('/Users/shawn/Work/directv-fl/src/components/shared/search')

//TODO: use data bound to display instead of the big if statement
module.exports = exports = new Element({
  css:'first-search',
  extend: {
    search: function(){}
  },
  define: {
    addRecentSearch: postpone(function(srch) {
      if(!this.node) return
      if(!this.page || !this.page.recent.data) return
      var keys = this.page.recent.holder.data.keys
      var recents = this.page.recent.holder.data.$userOrigin
      if(keys.length>5) {
        recents[keys[0]].remove()
      }
      var found
      if(recents) {
        recents.each(function() {
          if(this.title.val === srch) {
            found = true
            return true
          }
        })
      }
      if(!found) {
        recents.set(timestamp(),{title:srch})
      }
    },1000)
  },
  page:new search.ResultList({
    scrollbar:'y',
    append:{
      val:[
        new Element({
          name:'noResults',
          display:'none',
          icon: new Icon({icon:'wrong'}),
          'title.text':'No results!',
          'body.text':'Please try to refine your query'
        }),
        new search.TopResult({
          name:'topresult'
        }),
        new Element({
          name:'recent',
          model: {
            inherit:false,
            complete:function() {
              if(this.data.keys.length) {
                this.noRecent.display = 'none'
                this.holder.display = 'block'
              } else {
                this.noRecent.display = 'block'
                this.holder.display = 'none'
              }
            }
          },
          noRecent:{
            icon: new Icon({icon:'searchMenu'}),
            title: {
              text:'Start Searching!'
            },
            body: {
              text:'Find your favorite movies, shows and channels.'
            }
          },
          holder: new search.Results({
            title: {
              text:'recent searches'
            },
            collection: {
              data:true,
              element: new search.Result({
                'events.click':function(e) {
                  this.checkParent('search',true).$userOrigin = this.data.title.val
                }
              }),
              filter: {
                sort:{ field:'_name', order:'z-a'}
              }
            }
          })
        })
      ],
      before:'movies'
    }
  }),
  overlay: {
    display:'none'
  },
  search:{
    defer:function(update, args) {

      if(!this.from.cloud) return true

      var caller = this._caller
      var elem$

      var list = [
          caller.page.movies,
          caller.page.series,
          caller.page.channels,
          caller.page.actors
        ]

      // if(!caller.topbar.field.data) {
      //   caller.topbar.field.data = this._val
      // }
      
      this.clearCache()

      if(this.val) {
        var srch = search.parseSearch( this.val )
        if( srch!==false ) {
          caller.addRecentSearch(srch)
          for(var i in list) {
            search.filterCollection( list[i], srch )
          }

          caller.page.recent.display = 'none'

          caller.data.get('movies').is(function() {
            return this.keys && this.keys.length>2 
                && this.from[0] && this.from[0].actors
          }, true).then(function() {
            if(caller._node) {
              for(elem$ in list) {
                list[elem$].display = list[elem$].filter.length > 0 
                  ? 'block' 
                  : 'none'  
              }
              
              var result = search.topResult( list ) 
              caller.page.topresult.data = result || false
              caller.page.topresult.display = result ? 'block' : 'none'
              caller.page.noResults.display = result ? 'none' : 'block'
              //if no result then ----
            }
          })
        } else {
          for(elem$ in list) {
            list[elem$].display = 'none'
          }
          caller.page.topresult.display = 'none'
          caller.page.noResults.display = 'none' 
          caller.page.recent.display = 'block'  
        }
          
      } else {
        for(elem$ in list) {
          list[elem$].display = 'none'
        }
        caller.page.topresult.display = 'none'
        caller.page.noResults.display = 'none' 
        caller.page.recent.display = 'block'
      }
      update()
    }
  }
}).Class

},{"../topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/search/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/search":"/Users/shawn/Work/directv-fl/src/components/shared/search.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/search/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Icon = require('../../shared/icon')
var Menu = require('../menu')
var Discover
var Search
var Channel
var Episode
var Movie
var cases = app.cases

module.exports = exports = new Switcher({
  css: 'first-switcher',
  'extend.navigation': function() {},
  onTransition: 'slide',
  loader: new Element({
    css: 'first-loader',
    x: {
      translate: true
    },
    loadicon: new Icon({
      icon: 'error'
    })
  }),
  navigation: {
    defer: function(update, args) {
      var nav = this.from

      if (!nav || !nav.last || !nav.last.from.key) return true

      var field = nav.last.from.key.val
      var page
      var element
      var switcher = this._caller
      var params
      var options
      nav = nav[field]

      if (field === 'page') {

        var page = nav.val

        if (page === 'discover') {
          element = Discover = Discover || require('../discover')
          params = {
            $focus: app.user.focus_row,
            data: app.content.get('discover')
          }
        } else if (page === 'search') {
          element = Search = Search || require('../search')
          params = {
            data: app.cloud.data,
            search: app.user.search,
            page: {
              recent: {
                data: app.user.recentSearches.from
              }
            }
          }
        }

      } else if (field === 'content') {
        if (!switcher._swElem || switcher._swElem.data !== nav.from) {

          var type = nav._contentType

          if (type === 'movies') {
            element = Movie = Movie || require('../movie')
          } else if (type === 'episodes') {
            element = Episode = Episode || require('../episode')
          } else if (type === 'channels') {
            element = Channel = Channel || require('../channel')
          }

          options = {
            force: true
          }
          params = {
            data: nav.from,
            holder: {
              player: {
                playing: app.isPlaying,
                receiver: app.user.receiver
              },
              receiverMedia: app.user.receiver.media
            }
          }
        }

      }

      if (element) {
        switcher.transition = {
          element: element,
          $params: params,
          direction: app.menu.val ? 0 : field === 'content' ? 1 : -1,
          $options: options
        }

      }

      update()
    }
  }
}).Class

},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../channel":"/Users/shawn/Work/directv-fl/src/components/active/channel/index.js","../discover":"/Users/shawn/Work/directv-fl/src/components/active/discover/index.js","../episode":"/Users/shawn/Work/directv-fl/src/components/active/episode/index.js","../menu":"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js","../movie":"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js","../search":"/Users/shawn/Work/directv-fl/src/components/active/search/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/switcher/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js":[function(require,module,exports){
require('./style.less')
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var user = app.user
var Icon = require('../../shared/icon')
var Title = require('../../shared/title')
var Input = require('./input')

var searchField = new Input({
  events: {
    focusout: function(e) {
      // var overlay = this.parent.parent.overlay
      // overlay.display = 'none'
    },
    focus:function(e) {
      // this.parent.parent.overlay.set({
      //   display:'block'
      // })
    }
  }
}).Class

module.exports = exports = new Element({
	css:'topbar',
	extend:{
		$current:function(val){
			var current = val.val
			if(current === 'search'){
				if(!this.search){
					this.set({
						css:'topbar searching',
						add:[
							new searchField({
								name: 'search',
								data:app.user.search
							}),
							'middle'
						]
					})
				}
			}else if(this.search){
				this.search.remove()
				this.css = 'topbar'
			}

			if( current === 'content' ){
				this.middle.data = user.navigation.content.from
			}else if( current === 'discover' ){
				this.middle.data = { title:current }
			}

		}
	},
	left: new Icon({ 
		icon:{
			val:app.current,
			transform:function(v,current){
				return current === 'content' ? 'back' : 'menu'
			}
		},
		events: {
			down:function(e) {
				e.prevent = true
				if( this.icon.val === 'menu' ){
					app.menu.val = !app.menu.val
				}else{
					user.navigation.page.$userOrigin = app.previous.val || 'discover'
				}
			}
		} 
	}),
	middle:new Title.Show(),
	right: new Icon({
		icon:'cast',
		'events.click':function() {
			app.popup.$userOrigin = 'devices'
		}
	})
})

module.exports = exports.Class


},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","./input":"/Users/shawn/Work/directv-fl/src/components/active/topbar/input.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/topbar/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/input.js":[function(require,module,exports){
require('./reset.less')

var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var events = require('vigour-js/browser/events')
var cases = require('vigour-js/browser/cases')
var app = require('vigour-js/app/')

module.exports = new Element({
  node: 'form',
  name: 'search',
  css: 'search-field',
  model: {
    inherit: false,
    complete: function() {
      this.table.clear.display = this.data.val ? 'table-cell' : 'none'
    }
  },
  table: {
    lefticon: new Icon({
      icon: 'search'
    }),
    inputField: {
      node: 'input',
      attr: {
        type: 'text',
        name: 'search',
        placeholder: 'Search'
      },
      text: {
        data: true
      },
      events: {
        keydown: function(e) {
          if (e.keyCode == 13) e.preventDefault()
        },
        keyup: function(e) {
          if (e.keyCode !== 9) {
            var srch = this.node.value.length ? this.node.value.trim() : ''
            this.data.$userOrigin = srch
          }
        }
      }
    },
    clear: new Icon({
      icon: 'closeSmall',
      display: 'none',
      events: {
        down: function(e) {
          e.prevent = true
          this.parent.fromDown = true
            //TODO: figure out why this.parent does not have data bound to it!
          this.parent.inputField.data.$userOrigin = ''
            // focusout.call(this.parent.parent,e)
        }
      }
    })
  },
  events: {
    focusin: focus
  }
}).Class

function focus(e) {
  console.log('wtf wtf wtf', this.parent)
  if (this.events.focus) {
    this.events.focus._val.call(this, e)
  }
}

function focusout(e) {
  if (this.events.focusout) {
    this.events.focusout._val.call(this, e)
  }
}

},{"./reset.less":"/Users/shawn/Work/directv-fl/src/components/active/topbar/reset.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/reset.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/bio/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

module.exports = new Element({
  css:'second-bio',
  'extend.$focus':function(val){
    var index = val.val
    if(index !== this._index){
      var data = this.data
      if(data){
        this.switcher.transition = {
          element:Img,
          $params:{
            opacity:0,
            background:data.from.get(['img','cover',index || 0],'')
          },
          $options:{
            force:true
          }
        }
        this._index = index
      }
    }
  },
  $focus:{
    data:'focus'
  },
  switcher:new Switcher({
    onTransition:'fade',
    // add:new Img({
    //   'background.data':'img.cover.0'
    // }),
  }),//will switch between images
  overlay:{
    'header.text.data':'title',
    bio:{
      'header.text':'Bio',
      'body.text.data':'bio'
    }
  },
  model:{
    subscription:{
      img:{
        cover:{
          $:true
        }
      }
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/bio/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/bio/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/channel/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var Widget = require('/Users/shawn/Work/directv-fl//src/components/inactive/widget')
var Content = require('../content')
var Trailer = require('../trailer')

module.exports = exports = new Content({
  css: 'second-channel',
  container: {
    left: {
      trailer: new Trailer({
        'video.src.data':'video'
      })
    },
    middle:{
      guide: new Widget.Guide()
    },
    right: new Switcher({
      onTransition: function(current, last) {
        if(last) last.remove()
        this.add(current)
      },
      model:{
        subscription:{
          guide:{
            0:{
              statistics:{
                title:true
              }
            }
          }
        },
        val:function(data){
          var widgetData = data.guide && data.guide[0]
          if(widgetData){
            this.transition = {
              element: widgetData.statistics ? Widget.Stats : Widget.About,
              $params:{ data:data }
            }
          }
        }
      }
    })
  },
  'extend.$complete':function(val){
    var complete = val.val
    if(complete === true){
      this.set({
        css:{removeClass:'preview'},
        container:{
          left:{
            twitter: new Widget.Twitter({
              data:this.data
            })
          }
        }
      })
    }else if(complete === false){
      this.css = {addClass:'preview'}
    }
  }
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","../trailer":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/channel/style.less","/Users/shawn/Work/directv-fl//src/components/inactive/widget":"/Users/shawn/Work/directv-fl/src/components/inactive/widget/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/channel/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js":[function(require,module,exports){
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Cover = require('../cover')
var Channel
var Vod

module.exports = exports = new Element({
  cover: new Cover(),
  'extend.$active': function(val) {
    var active = val.val
    if (active !== void 0) {
      var bg = this.cover.bg
      var info = this.info
      if (active) {
        if (bg._loaded) bg.opacity = false
        bg.$wait = false
      } else {
        bg.$wait = true
        bg.opacity = 0
      }
    }
  },
  $active: true
}).Class

exports.select = function(data, type) {
  if (!type) type = data._contentType

  return type === 'channels' ? {
    element: Channel = Channel || require('../channel'),
    $params: {}
  } : {
    element: Vod = Vod || require('../vod'),
    $params: {
      $popup: app.popup
    }
  }
}

},{"../channel":"/Users/shawn/Work/directv-fl/src/components/inactive/channel/index.js","../cover":"/Users/shawn/Work/directv-fl/src/components/inactive/cover/index.js","../vod":"/Users/shawn/Work/directv-fl/src/components/inactive/vod/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/cover/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

module.exports = new Element({
  css:'second-cover',
  bg:new Img({
    opacity:0,
    $wait:true,
    background:{
      data:'img.cover.0',
      add:{
        data:'show.img.cover.0'
      }
    }
  }),
  overlay:{}
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/cover/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/cover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/discover/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var app = require('vigour-js/app')
var postpone = require('vigour-js/browser/events/util').postpone
var Content = require('../content')

var _preview = postpone(function(switcher,focusIndex) { //move this to app control stuff
  if(focusIndex !== void 0){
    var clouddata = app.cloud.data
    var focusrow = app.user.focus_row.val
    var data = clouddata.get(['discover',focusrow,'items',focusIndex])
    app.preview.val = data
    if(switcher._swElem) switcher._swElem.$active.val = true
  }
},400)

module.exports = new Switcher({
  css: 'second-discover',
  extend:{
    $highlight:function(val){
      var index = val.val
      var last = this.last
      if(index !== false){
        if(!this.fromContent){
          if(this._swElem) this._swElem.$active = false
          _preview(this,index)
          this.last = void 0
        }else{
          this.fromContent = false
        }
      }
    },
    $preview:function(val){
      val = val.val
      if(val){
        var data = val.from
        var transition = Content.select(data)
        transition.$params.data = data
        transition.$params.$complete = false
        this.transition = transition
      }
    },
    $content:function(val){
      val = val.val
      if(val){
        var data = val.from
        var transition = Content.select(data)
        transition.$params.data = data
        transition.$params.$complete = true
        this.transition = transition
        this.fromContent = true
        app.preview.val = data
      }
    }
  },
  onTransition:'fade'
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/discover/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/discover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
  , Element = require('vigour-js/app/ui/element')
  , Discover = require('./discover')
  , Search = require('./search')
  , Statusbar = require('./statusbar')
  , app = require('/Users/shawn/Work/directv-fl//src/app')
  , Navigation = require('./navigation')
  , Player = require('./player')
  , Content = require('./content')

//secondscreen toplevel
module.exports = exports = new Element({
  css:'second-state',
  y:{translate:true,val:0},
  switcher:new Switcher({ // switches between main and search
    onTransition:'fade'
  }),
  navigation:new Navigation(),
  statusbar:new Statusbar(),
  search:new Search(),
  extend:{
    $highlight:function( val ){},
    $preview:function( val ){},
    $page:function( val, stamp ){


      if(this.$media.val || !stamp) return
      var page = val.val

      app.user.trailerMuted.$userOrigin = true
      app.hideStatusbar.val = false
      
      if( page === 'discover' ){
        this.set({
          y:0,
          switcher:{
            transition:{
              element:Discover,
              $params:{
                $preview:this.$preview._val,
                $highlight:this.$highlight._val,
                $content:false
              }
            }
          },
          navigation:{
            container:{
              y:0
            }
          }
        })
      }else if(page === 'search'){
        this.set({
          y: -app.h.val + 80,
          search:{
            $search:app.user.search,
            $muted:app.user.trailerMuted,
            data:app.cloud.data
          }
        })
      }

    },
    $content:function( val,stamp ){

      // if(this.$media.val || !stamp) return
      // var data = val.from
      if(this.$media.val || !stamp) return

      app.hideStatusbar.val = false

      this.set({
        y:0,
        switcher:{
          transition: {
            element:Discover,
            $params:{
              $preview:false,
              $highlight:false,
              $content:val
            }
          }
        },
        navigation:{
          container:{
            y:420
          }
        }
      })
    },
    $media:function( val, stamp ){
      if(val.val){
        this.set({
          y:0,
          switcher:{
            transition:{
              element:Player,
              $params:{
                overlay:{
                  $volume:app.volume,
                  $time:val.val.get('time')
                },
                playing:app.isPlaying,
                data:val.$userOrigin,
                video: {
                  volume: app.volume
                }
              }
            }
          },
          navigation:{
            container:{
              y:460 + 80
            }
          }
        })
      }else{
        app.user.updateNavigation()
      }
    }
  },
  setSetting:{
    name:'updateNav',
    parent:function(){
      app.user.updateNavigation()
    }
  }
}).Class
},{"./content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./discover":"/Users/shawn/Work/directv-fl/src/components/inactive/discover/index.js","./navigation":"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/index.js","./player":"/Users/shawn/Work/directv-fl/src/components/inactive/player/index.js","./search":"/Users/shawn/Work/directv-fl/src/components/inactive/search/index.js","./statusbar":"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/index.js":[function(require,module,exports){
require('./style.less')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Element = require('vigour-js/app/ui/element')
var List = require('/Users/shawn/Work/directv-fl//src/components/shared/list')
var postpone = require('vigour-js/browser/events/util').postpone
var Switcher = require('vigour-js/app/ui/switcher')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')
var Progress = require('/Users/shawn/Work/directv-fl//src/components/inactive/progress')

var yElement = new Element({
  y: {
    translate: true,
    val:420
  }
}).Class

var titleElement = new yElement({
  'text.data': 'title'
}).Class

var map = {
  spotlight: {
    index: 0,
    list: List.Watching
  },
  channels: {
    index: 1,
    list: List.Channel
  },
  watching: {
    index: 2,
    list: List.Watching
  },
  releases: {
    index: 3,
    list: List.Poster
  },
  recommended: {
    index: 4,
    list: List.Poster
  }
}

var switchFocus = function(_this, index, focused, type) {
  var direction = index > _this.index ? -1 : 1
    //switch the title

  _this.container.set({
    bar: {
      title: {
        transition: {
          element: titleElement,
          direction: direction,
          $params: {
            data: focused
          },
          $options: {
            force: true
          }
        }
      },
      arrows: {
        up: {
          opacity:index === 0 ? 0.5 : 1
        },
        down: {
          opacity:index === 4 ? 0.5 : 1
        }
      }
    }
  })

  _this.index = index

  listFocus(_this, index, focused, type, direction)
}

var listFocus = postpone(function(_this, index, focused, type, direction) {
  var lists = _this.container.lists
  var focusItem = app.user['focus_' + type]

  if(lists){
    lists.transition = {
      element: map[type].list,
      direction: direction,
      $params: {
        data: focused,
        $focus: app.highlight.val = focusItem
      },
      $options: {
        force: true
      }
    }
  }
}, 200)

module.exports = new Element({
  css: 'second-navigation',
  container: new yElement({
    progress: new Progress({
      percentage:{
        text:{
          val:{
            parent:'on',
            animation:{
              easing:'outCubic',
              time:18
            }
          },
          transform:function(v,cv){
            return ~~cv + '%'
          }
        }
      },
      model:{
        complete:function(data){
          this.on.update(this)
        },
        inherit:false
      },
      on:{
        data:'time',
        defer:function(update){
          if(~~this.from.val){
            this._caller.opacity = 1
            update()
          }else{
            this._caller.opacity = 0
            return true
          }
        },
        multiply:100
      }
    }),
    bar: {
      title: new Switcher({
        onTransition: function(current, last, direction) {
          _transition(this, 40, current, last, direction)
        }
      }),
      arrows: {
        up:new Icon({
          icon:'upNav',
          opacity:0.1
        }),
        down: new Icon({
          icon:'downNav'
        })
      }
    },
    lists: new Switcher({
      onTransition: function(current, last, direction) {
        _transition(this, 400, current, last, direction)
      }
    })
  }),
  'model.subscription.$.$': true,
  extend:{
    $focus: function(val) { //val === 'spotlight'/'recommended' etc
      var _this = this
      var data = this.data
      if(!data) return
      
      if(!data.$length.val) {
        data.$length.once(function() {
          _this.$focus.update()
        })
        return
      }

      var focused = data[val.val]
      if(focused) {
        switchFocus(_this, map[val.val].index, focused, val.val)
      }
    }
  },
  setSetting: {
    name: 'prepValues',
    parent: function() {
      for(var type in map) {
        var field = 'focus_' + type
        if(!app.user[field]) {
          var obj = {}
          obj[field] = 0
          app.user.set(obj)
        }
      }
    }
  }
}).Class

function _transition(_this, delta, current, last, direction) {
  if(last) {
    last.y = delta * direction // should still remove
    current.y = delta * -direction
  }
  _this.add(current)
  if(_this._timer) {
    clearTimeout(_this._timer)
    _this._timer = null
  }
  _this._timer = setTimeout(function() {
    _this._timer = null
    doit()
  }, 50)

  function doit(){
    if(!current._blocked) current.y = 0
    else window.requestAnimationFrame(doit)
  }
}

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl//src/components/inactive/progress":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl//src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/player/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Video = require('vigour-js/browser/element/video')
var Progress = require('/Users/shawn/Work/directv-fl//src/components/inactive/progress')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var postpone = require('vigour-js/browser/events/util').postpone
var config = require('vigour-js/util/config')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')

var fadeIcon = postpone(function(_this, force) {
  var icon = _this._swElem && _this._swElem.icon
  if (icon) {
    icon.css = 'ui-icon fade-out'
    icon.opacity = 0
    icon.scale = 0.5
  }
}, 750)

var fadeOverlay = postpone(function(_this, force) {
  if (app.isPlaying.val) _this.opacity = 0

}, 1000)

var updatePlay = postpone(function(_this) {
  app.hideStatusbar.val = false
  if (_this.$playing) _this.$playing.update()
}, 1000)

var Overlay = new Element({
  css: 'player-overlay',
  opacity: 0,
  icon: new Icon({
    opacity: 0,
    scale:0.5,
    icon: {
      val: 'pause',
      $isPlaying: 'play'
    }
  }),
  info: {
    poster: {
      img: new Img({
        background:{
          data: 'img.poster',
          add:{data:'show.img.poster'},
          transform:function(v,cv){
            console.log('>>>',cv)
          }
        },
        model:{
          complete:function(){
            this.background.update()
            this.model = false 
          }
        }
      })
    },
    titles: {
      'nowplaying.text': 'Now Playing',
      'title.text':{
        data: 'guide.0.title',
        or:{data:'title'}
      },
      subtitle:new Subtitle()
    }
  },
  recommended: {
    'header.text': 'Recommended',
    on:{
      data:'recommendations.0.img.spotlight',
      add:{
        data:'show.recommendations.0.img.spotlight'
      }
    },
    thumb:{
      on:{parent:'on'},
      img:new Img({
        background:{
          parent:'on'
        }
      })
    },
    display:{
      val:'block',
      when:{self:'on'},
      or:'none'
    },
    model:{
      complete:function(){
        this.on.update()
        this.model = false 
      }
    }
  }
}).Class

var BarOverlay = new Element({
  opacity:0,
  container: {
    txt: {},
    progress: new Progress({
      display:false
    })
  },
  'extend.$value': function(val) {
    this.container.set({ //change this for data
      txt: {
        value: {
          text: val.val
        }
      },
      progress: {
        on: val.val
      }
    })
  }
}).Class

var SeekOverlay = new BarOverlay({
  css: 'seek-overlay',
  'container.txt': {
    text: 'SEEKING ',
    'value.text': {
      data: 'time',
      multiply: {
        data: 'duration'
      },
      $convertTime: true, //{data:'duration'},
    }
  }
}).Class

var VolumeOverlay = new BarOverlay({
  css: 'volume-overlay',
  'container.txt': {
    text: 'VOLUME ',
    'value.text': {
      val: 0,
      transform: function(v, cv) {
        return Math.round(cv * 100 || 0) + '%'
      }
    }
  }
}).Class

var OverlaySwitcher = new Switcher({
  extend: {
    $playing: function(val) {
      this.opacity = 1
      this.transition = {
        element: Overlay,
        $params: {
          data: this.parent.data,
          icon: {
            css: 'ui-icon fade-in',
            opacity: !exports.fromSrc ? 1 : 0,
            scale: 1
          }
        }
      }
      if (app.isPlaying.val) fadeOverlay(this)
      fadeIcon(this)
    },
    $time: function(val) {
      if (exports.fromSrc || arguments[2] === void 0 || val.val < 0) return
      this.opacity = 1

      if(this.data && this.data._contentType!=='channels') {
        this.transition = {
          element: SeekOverlay,
          $params: {
            $value: val.val
          }
        }
      }

      app.hideStatusbar.val = true

      if (app.isPlaying.val) {
        fadeOverlay(this)
      } else {
        updatePlay(this)
      }

    },
    $volume: function(val) {
      if (arguments[2] === void 0) return
      this.opacity = 1
      this.transition = {
        element: VolumeOverlay,
        $params: {
          $value: val.val
        }
      }
      app.hideStatusbar.val = true
      if (app.isPlaying.val) fadeOverlay(this)
      else updatePlay(this)
    }
  },
  onTransition: function(current, last) {
    if (last) last.remove()
    current.$timeout = {
      50: function() {
        this.opacity = 1
      }
    }
    this.add(current)
  }
}).Class

module.exports = new Element({
  css: 'second-player',
  video: new Video({
    player: require('vigour-js/browser/element/video/html5'),
    duration: {
      data: 'duration'
    },
    time: {
      data: 'time'
    },
    src: {
      prepend: config.pointers.assets,
      data: 'video'
    },
    events: {
      progress: function(p) {
        this.data.from.set('time', -Math.abs(p))
      },
      src:function(){
        exports.fromSrc = true
        if(exports.timer){
          clearTimeout(exports.timer)
          exports.timer = null
        }
        exports.timer = setTimeout(function(){
          exports.fromSrc = false
          exports.timer = null
        },500)
        this.parent.overlay.$playing.update()
      }
    }
  }),
  overlay: new OverlaySwitcher(),
  extend: {
    playing: function(val) {
      this.overlay.$playing = val
      this.video.$playing = val
    }
  }
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/player/style.less","/Users/shawn/Work/directv-fl//src/components/inactive/progress":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/player/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
	css:'second-progress',
  on:{
    data:'time',
  	abs:true,
    multiply:100
  },
  display:{
    val:app.preview,
    transform:function(v,cv){
      var popup = app.popup.val
      return (cv && cv._contentType === 'channels') || (popup && typeof popup !== 'string') ? 'none' : 'block'
    },
    listen:app.popup
  },
  w:{
    self:'on',
    transform:function(v,cv){
      return Math.max(~~cv,3) + '%'
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/progress/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/search/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')
var Trailer = require('../trailer')
var search = require('/Users/shawn/Work/directv-fl//src/components/shared/search')
var when = require('promise').all
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')

var NoResults = new Element({
  container:{
    'title.text':'No Results!',
    'subtitle.text':'Please try to refine your query'
  }
}).Class

var StartSearching = new Element({
  container:{
    'title.text':'Start Searching!',
    'subtitle.text':'Find your favorite movies, shows and channels'
  }
}).Class

module.exports = new Element({
  css: 'second-search',
  extend:{
    $search:function( val ){
  	  var _this = this
    	var results = this.results
    	var children = results.list.children
    	var query = search.parseSearch( val.val )
    	var content = app.content

    	this.searchbox.query.text = query

    	if(query !== false){
    		for (var i = children.length - 1; i >= 0; i--) {
    			search.filterCollection( children[i], query )
    		}
    	}

      if(query){
        function loaded(){
          var keys = this.keys
          var from = this.from
          return keys && keys.length > 2
        }

        function done(){
          for (var j = children.length - 1; j >= 0; j--) {
            var child = children[j]
            child.display = child.filter.length ? 'block' : 'none'
          }
          var topResult = search.topResult( children )
          if( topResult ){
            results.display = 'block'
            results.topresult.data = topResult
            if(_this.message){
              _this.message.remove()
            }
          }
          else{
            results.display = 'none'
            _this.set({
              message:new NoResults()
            })
          }
        }

        when([
          content.get('movies').is(loaded),
          content.get('actors').is(loaded),
          content.get('series').is(loaded),
          content.get('channels').is(loaded)
        ]).done(done)
      }else{
        results.display = 'none'
        this.set({
          message:new StartSearching()
        })
      }

    },
    $muted:function(val){
      this.results.topresult.body.container.trailer.$muted = val.val
    }
  },
  searchbox:{
  	searchicon:new Icon({
  		icon:'search'
  	}),
  	'query.text':''
  },
  results:{
  	list:new search.ResultList(),
  	topresult:{
  		model:{inherit:false},
  		header:{
  			text:{
  				// data:'title',
  				prepend:'Top Result'// - '
  			}
  		},
  		body:{
  			container:{
  				trailer:new Trailer(),
  				info:{
  					'title.text.data':'title',
            subtitle:new Subtitle()
  				}
  			},
  			'description.text.data':'description'
  		}
  	}
  }
}).Class

},{"../trailer":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/search/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl//src/components/shared/search":"/Users/shawn/Work/directv-fl/src/components/shared/search.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","promise":"/Users/shawn/Work/directv-fl/node_modules/promise/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/search/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')

module.exports = app.cases.$isIFE 
? new Element({
    css:'second-statusbar branded',
    y:{
      translate:true,
      val:80,
      multiply:app.hideStatusbar
    },
    partner:{
      logo:{}
    },
    weather:{
      add:new Icon({icon:'weather'}),
      text:'Partially Clouded'
    },
    eta:{
      add:new Icon({icon:'airplane'}),
      text:'Time to Los Angeles: 6hr'
    },
    between:{},
    directv:{
      logo:{}
    }
  }).Class
: new Element({
    css:'second-statusbar',
    y:{
    	translate:true,
      val:80,
      multiply:app.hideStatusbar
    },
    directv:{
      logo:{}
    },
    sender:{
      icon:new Icon({icon:'phone'}),
      title:{text:'controlled by iPhone'}
    }
  }).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Video = require('vigour-js/browser/element/video')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var ASSETS = require('vigour-js/util/config').pointers.assets
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Mute = require('/Users/shawn/Work/directv-fl/src/components/shared/mute')

module.exports = new Element({
  css: 'second-trailer',
  'extend.$muted':function(){},
  $muted:true,
  video:new Video({
    player: require('vigour-js/browser/element/video/html5'),
    src:{
      data: 'trailer',
      prepend: ASSETS
    },
    duration: true,
    volume:{
      parent:'$muted',
      multiply:-1,
      add:1
    },
    loop: true,
    autoplay: true
  }),
  logo:new Img({
    'background.data':'img.logo'
  }),
  muted:new Mute({
    icon:{
      parent:'$muted'
    }
  })
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mute":"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/vod/index.js":[function(require,module,exports){
require('./style.less')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Item = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Content = require('../content')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Stickers = require('/Users/shawn/Work/directv-fl/src/components/shared/stickers')
var Bio = require('../bio')

var Overview = new Content({
  css:'overview',
  container:{
    top: {
      'left.poster':new Item.Poster({
        'img.background':{
          add:{
            data:'show.img.poster'
          }
        },
      }),
      right: {
        title:new Title(),
        subtitle:new Subtitle(),
        stickers:new Stickers()
      }
    },
    'description.text.data': 'description',
    starring: {
      display:{
        val:'block',
        when:{data:'actors'},
        or:'none'
      },
      'header.text': 'Starring',
      'actors.collection': {
        data: 'actors',
        element: new Item.Poster({
          css:{addClass:'actor'}
        })
      }
    }
  }
}).Class

var Preview = new Content({
  css:'preview',
  'cover.bg.background':{
    data: 'img.cover.1',
    add:{
      data:'show.img.cover.2'
    }
  },
  'container.info': {
    title:new Title.Show(),
    subtitle:new Subtitle({
      // 'episodes.text':{
      //   data:'episodeNr'
      // }
    }),
    'description.text.data': 'description',
    stickers:new Stickers({
      audience:{
        background:{
          when:{data:'exclusive'},
          val:'assets/img/app/audience.png',
          or:' '
        },
        'model.complete':function(){
          this.background.update()
        }
      }
    }),
  }
}).Class

module.exports = new Switcher({
  css: 'second-vod',
  onTransition:'fade',
  extend:{
    $active:function(val){
      if(this._swElem) this._swElem.$active = val.val
    },
    $complete: function(val) {
      var complete = val.val
      var data = this.data
      var isEpisode = data._contentType === 'episodes'

      var params = {
        data: data.from,
        $active:this.$active
      }

      if (complete === true) {
        this.transition = {
          // element: isEpisode ? EpisodeOverview : Overview,
          element: Overview,
          $params: params
        }
      } else if (complete === false) {
        this.transition = {
          // element: isEpisode ? EpisodePreview : Preview,
          element: Preview,
          $params: params
        }
      }
    },
    $popup:function(val){
      var data = val.val
      if(data && typeof data !== 'string'){
        this.transition = {
          element:Bio,
          $params:{
            data:data.from
          }
        }
      }else{
        if(this.$complete) this.$complete.update()
      }
    },
    data:function(val){
      if(this._swElem && !this._swElem.switcher){
        this._swElem.data = val.val
      }
    }
  },
  $active:true
}).Class

},{"../bio":"/Users/shawn/Work/directv-fl/src/components/inactive/bio/index.js","../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/vod/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl/src/components/shared/stickers":"/Users/shawn/Work/directv-fl/src/components/shared/stickers/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/vod/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/widget/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')
var Video = require('vigour-js/browser/element/video')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Mpaa = require('/Users/shawn/Work/directv-fl/src/components/shared/mpaa')
var Score = require('/Users/shawn/Work/directv-fl/src/components/shared/statistics').Score
var Stickers = require('/Users/shawn/Work/directv-fl/src/components/shared/stickers')

exports.Twitter = new Element({
  css: 'twitter-widget',
  'header.text': 'Tweets',
  'tweets.collection': {
    data: 'guide.0.tweets',
    element: new Element({
      css: 'tweet',
      bird: new Icon({icon:'twitter'}),
      'author.text':{
        data: 'author',
        prepend: '@'
      },
      'body.text.data': 'body'
    })
  }
}).Class

exports.Guide = new Element({
  css: 'guide-widget',
  'header.text': 'Guide',
  'programs.collection': {
    data: 'guide',
    element: new Element({
      css: 'program',
      left:{
        'title.text.data': 'title',
        progress: {
          'start.text.data': 'start-time',
          'dash.text': ' - ',
          'bar.seek': {},
          'end.text.data': 'end-time'
        }
      },
      mpaa:new Mpaa()
    })
  }
}).Class

var Poller = new Element({
  css: 'poller',
  'left.logo': new Img(),
  right: {
    'title.text.data': 'title',
    bar: {
      'extend.$borderTopColor': function(val) {
        if(val.val) this.node.style.borderTopColor = val.val
      },
      '$borderTopColor.data': 'color',
      w: {
        data: 'votes',
        divide: 10000,
        multiply: 100,
        add: '%'
      }
    },
    'votes.text': {
      data: 'votes',
      add: ' VOTES'
    }
  },
  setSetting: {
    name: 'bindvotes',
    parent: function(parent) {
      this.right.bar.w = {
        divide: parent.on
      }
    }
  }
}).Class

var Poll = new Element({
  on: { // store the totalvotes
    data: 'poll.0.votes',
    'add.data': 'poll.1.votes'
  },
  append: [
    Poller, {
      'model.field': 'poll.0'
    }, {
      'model.field': 'poll.1'
    }
  ]
}).Class

exports.Stats = new Element({
  css: 'stats-widget',
  'header.text': 'Statistics',
  container: {
    model:{field:'guide.0'},
    score: new Score(),
    info: {
      'title.text': 'Who will win?',
      'subtitle.text': 'Use phone to vote'
    },
    poll: new Poll()
  }
}).Class

exports.About = new Element({
  css: 'about-widget',
  'header.text': 'About the Show',
  container: {
    img:new Img({
      'background.data':'img.thumb'
    }),
    info:{
      'model.field':'guide.0',
      titles:{
        'title.text.data': 'title',
        'subtitle.text.data': 'subtitle'
      },
      stickers:new Stickers()
    },
    'description.text.data':'guide.0.description'
  }
}).Class
},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mpaa":"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js","/Users/shawn/Work/directv-fl/src/components/shared/statistics":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js","/Users/shawn/Work/directv-fl/src/components/shared/stickers":"/Users/shawn/Work/directv-fl/src/components/shared/stickers/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var app = require('vigour-js/app')

module.exports = new Element({
  css:'ui-actors',
  display:{
    val:'block',
    when:{
      data:'actors',
      or:{
        data:'show.actors'
      }
    },
    or:'none'
  },
  header: { text: 'Starring' },
  body: {
    scrollbar: 'x',
    collection: {
      data: 'actors',
      element: new Poster({
        'events.click':function() {
          app.popup.$userOrigin = this.data.from
        }
      })
    }
  }
}).Class


},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/actors/style.less","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/actors/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

module.exports = exports = new Element({
  css:'ui-bar'
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/bar/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/bar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

var Description = new Element({
	css:'ui-description',
  header: { text: 'Description' },
  body: {
    text: { data: 'description' }
  }
}).Class

module.exports = Description

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/description/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/description/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
  , cases = require('vigour-js/browser/cases')
  , icon = new Element({ css:'ui-icon' })
  , map =
    { discover:'\ue600'
    , shows:'\ue601'
    , tv:'\ue602'
    , settings:'\ue603'
    , cast:'\ue604'
    , desktop:'\ue602'
    , play:'\ue605'
    , pause:'\ue606'
    , fullscreen:'\ue607'
    , exitfullscreenAlt:'\ue608'
    , pullback:'\ue609'
    , swipeup:'\ue60a'
    , allChannels:'\ue60b'
    , disconnected:'\ue60c'
    , menu:'\ue60d'
    , IFE:'\ue60e'
    , back:'\ue60f'
    , closeSmall:'\ue610'
    , close:'\ue611'
    , wrong:'\ue612'
    , correct:'\ue613'
    , facebook:'\ue614'
    , twitter:'\ue615'
    , phone:'\ue616'
    , tablet:'\ue617'
    , volume:'\ue618'
    , muted:'\ue619'
    , pauseAlt:'\ue61a'
    , playAlt:'\ue61b'
    , rewind:'\ue61c'
    , fastforward:'\ue61d'
    , profile:'\ue61e'
    , dropdown:'\ue61f'
    , rightNav:'\ue620'
    , leftNav:'\ue621'
    , right:'\ue622'
    , search:'\ue623'
    , noResult:'\ue624'
    , searchMenu:'\ue625'
    , epg:'\ue626'
    , upNav:'\ue627'
    , downNav:'\ue628'
    , menuRight:'\ue629'
    , airplane:'\ue62a'
    , mutedAlt:'\ue62b'
    , locked:'\ue62c'
    , weather:'\ue62d'
    , empty:' '
    }

icon.extend({
  icon: function(val) {
    var name = map[val.val]
    if(name) {
      var v = '<span>' + name + '</span>',
        value = this.node.innerHTML,
        divindex = value.indexOf('<div')
      if(~divindex) v += value.slice(divindex)
      this.html = v;
    } else {
      console.error('icon error: ', val.val, ' is not defined')
    }
  }
})

module.exports = exports = icon.Class
exports.map = map

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/icon/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/icon/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')
var ASSETS = require('vigour-js/util/config').pointers.assets

module.exports = new Element({
  opacity: 0,
  background: {
    data:'img',
    prepend:ASSETS,
    load: function(t) {
      if(this.$wait && this.$wait.val){
        this.$wait.once(false,function(){
          this.opacity = false
        })
      }else{
        this.opacity = false
      }
      this._loaded = true
      t._loaded = true
    }
  },
  'extend.$wait':function(){}
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/channel.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')

module.exports = new List({
  collection: {
    data: 'items',
    element:Item.Channel
  }
}).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/dots.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var _focused = require('/Users/shawn/Work/directv-fl//src/components/util').focused

module.exports = new Element({
  css:'list-dots',
  container:{
    collection:{
      data:'spotlight.items',
      element:new Element()
    },
    'extend.$focus': function( val ) {
      // alert(typeof val.val === 'string')
      var child = typeof val.val === 'string'
        ? this[val.val]
        : this.children[ val.val || 0 ]
      _focused( this, child )
    },
    model:{ complete:function(){
      if( this.children[0] ){
        if(this.$focus) this.$focus.update()
        this.model = { complete:null }
      }
    }}
  }
}).Class
},{"/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js":[function(require,module,exports){
require( './style.less' )

var cases = require( 'vigour-js/browser/cases' )
var Element = require( 'vigour-js/app/ui/element' )
var util = require('/Users/shawn/Work/directv-fl//src/components/util')
var _focused = util.focused
var _preventAnimation = util.preventAnimation

var Base = new Element( {
  css: 'base-list',
  model: function() {

    if ( this.children[ 0 ] ) {
      if( !this.$focus ) {
        console.error('this list needs a $focus value!')
        // this.$focus = 0
      }
      _updateX(this)
      this.$focus.update()
      this.model = false
    }
  },
  setSetting: {
    name: 'updateX',
    parent: function() {
      _updateX(this)
    }
  },
  'events.click':function(){
    var parent = this.parent
    if(parent.parent.$focus) parent.parent.$focus.from = parent._name
    // console.error('this!',this.parent.parent)
  }
} ).Class

var List = new Base( {
  'extend.$focus': function( val ) {
    var _this = this
    var n = val.val || 0
    var parent = this.parent
    
    _focused( this, this.children[ n ] )
    _bounce( this )

    if( !cases.$isPhone && parent ){
      
      var node = this.node
      var parentTop = parent.node.getBoundingClientRect().top
      if(_this.rafId) window.cancelAnimationFrame(_this.rafId)
      function check(){
        var top = node.getBoundingClientRect().top
        if(!top || top === parentTop) {
          _this.x = {
            multiply: -n
          }
          _this.rafId = null
        }else{
          _this.rafId = window.requestAnimationFrame(check)
        }
      }
      check()

    }else{
      this.x = {
        multiply: -n
      }
    }
  },
  x: {
    translate: true,
    val:0,
    multiply: 0,
    defer: _defer
  },
  y:{
    translate:true,
    val:0
  },
  $isPhone: {
    x: {
      animation: {
        time: 24,
        easing: 'outCubic'
      }
    },
    'events.grab': {
      x: true,
      pass: _pass,
      move: _highlight,
      up: _position
    }
  }
} ).Class

module.exports = exports = cases.$isPhone ? new Base( {
  // model:function(){
  //   if ( this.children[ 0 ] ) {
  //     var name = this.parent._name
  //     var scrollLeft = exports[name] && exports[name].scrollLeft
  //     if(scrollLeft){
  //       exports[name].ignoreScroll = true
  //       this.node.scrollLeft = scrollLeft
  //       exports[name].ignoreScroll = false
  //     }else{
  //       if( !this.$focus ) {
  //         console.error('this list needs a $focus value!')
  //         // this.$focus = 0

  //       }
  //       _updateX(this)
  //       this.$focus.update()
  //     }
  //     this.model = false
  //   }
  // },
  'extend.$focus': function( val ) {
    var children = this.children
    _focused( this, children[ val.val || 0 ] )
    if ( !this.node.scrollLeft && val.val ) {
      this.node.scrollLeft = val.val * _step( this, children )
    }
  },
  scrollbar: 'x',
  'events.scroll': function( e ) {
    // var name = this.parent._name
    // if(!exports[name]) exports[name] = {}
    // else if(exports[name].ignoreScroll) return

    if(!this._checked){ //block the first
      this._checked = true
      return
    }

    var _this = this
    var node = this.node
    var scrollLeft = node.scrollLeft
    var fraction = scrollLeft / ( node.scrollWidth - node.offsetWidth )
    var index = Math.round( fraction * ( _length( this ) - 1 ) )
    // exports[name].scrollLeft = scrollLeft
    _this.$focus.from = index
  }
} ).Class : List

exports.Carousel = List
exports.Spotlight = require( './spotlight' )
exports.Channel = require( './channel' )
exports.Poster = require( './poster' )
exports.Watching = require( './watching' )
exports.Dots = require( './dots' )
exports.Item = require( './item' )

var treshold = 60
var flick = 10

function _bounce( list ) {
  if ( list.x._e ){
    list.x = {
      _esub: list.x._e._val
    }
    list.x.update()
  }
}

function _highlight( e, d){
  var length = _length( this )
  var step = _step( this )
  var oldpos = this._start
  var newpos = oldpos
  if ( d.x < -treshold ) {
    newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
  } else if ( d.x > treshold ) {
    newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
  }
  if(-newpos !== this.$focus.val) _set( this, newpos )
}

function _pass( e, d ) {
  if(Math.abs( d.x ) > Math.abs( d.y )){
    this._start = -this.$focus.val || 0
    return true
  }
}

function _position( e, d, ld ) { // unify with switcher
  var children = this.children
  var length = _length( this )
  var oldpos = this._start || 0
  var newpos
  var step = _step( this, children )

  if ( Math.abs( ld.x ) > flick ) {
    if ( ld.x < 0 && d.x < treshold ) {
      newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
    } else if ( ld.x > 0 && d.x > -treshold ) {
      newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
    }
  } else {
    if ( d.x < -treshold ) {
      newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
    } else if ( d.x > treshold ) {
      newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
    }
  }

  if ( newpos !== void 0 && -newpos !== this.$focus.val ) _set( this, newpos )
  
  _bounce( this )
}

function _step( list, children, corrected ) { // this can be cleaner
  var node

  if ( !children ) children = list.children
  if ( children[ 0 ] ) {
    if ( !list._step ) {
      node = list.node
      list._step = node.scrollWidth / _length( list ) // 
    }
    if ( corrected ) {
      node = list.node
      return ( node.scrollWidth - node.offsetWidth ) / ( _length( list ) - 1 )
    }
    return list._step
  }
}

function _length( _this ){
  return _this.children.length //_this._length || ( _this._length = _this.children.length )
}

function _defer( update, args ) {
  var list = this._caller
  var step = _step( list, null, true )
  if ( step ) {
    if(!this._val) this.val = step
    this._flag = null
  }
  update()
}

function _updateX( _this ){
  if( _this.x ){
    _preventAnimation(_this,function(){
      _this.x._p = true
      _this.x.update()
      _this.x._p = null
    })
  }
}

function _set( _this, newpos ){
  var field = _this.$focus._flag && _this.$focus._flag.data[2]
  var data = _this.data
  if( field && data ){
    data.from.set(field,-newpos)
  }else _this.$focus.from = -newpos
}
},{"./channel":"/Users/shawn/Work/directv-fl/src/components/shared/list/channel.js","./dots":"/Users/shawn/Work/directv-fl/src/components/shared/list/dots.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","./poster":"/Users/shawn/Work/directv-fl/src/components/shared/list/poster.js","./spotlight":"/Users/shawn/Work/directv-fl/src/components/shared/list/spotlight.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/list/style.less","./watching":"/Users/shawn/Work/directv-fl/src/components/shared/list/watching.js","/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js":[function(require,module,exports){
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var blocked = 'blocked'

module.exports = exports = new Element({
  img: new Img(),
  'events.click': function() {
    var focus = this.parent.$focus
    if (focus) focus.from = this.$index
    app.user.navigation.content.$userOrigin = this.data.from
  },
  extend: [{
      name: '$index',
      type: false,
      get: function() {
        if (this._index === void 0) {
          var siblings = this.parent.children
          for (var i = siblings.length - 1; i >= 0; i--) {
            siblings[i]._index = i
          }
        }
        return this._index
      }
    }, {
      $blocked: _blocked
    }],
  '$blocked.data':blocked
}).Class

exports.Info = new exports({
  css: 'info-item',
  'img.background.data': 'img.thumb',
  info: {
    title: new Title.Show(),
    subtitle: new Subtitle()
  }
}).Class

exports.Poster = new exports({
  css: 'poster-item',
  'img.background.data': 'img.poster',
}).Class

exports.Channel = new exports.Info({
  'logo': new Img({
    'background.data': 'img.logo'
  }),
  'info.title.text.data': 'guide.0.title'
}).Class

exports.Carousel = new Img({
  css: 'spotlight-item',
  'extend.$blocked': _blocked,
  'events.click': function() {
    app.user.navigation.content.$userOrigin = this.data.from
  },
  background: {
    data: 'img.spotlight'
  },
  '$blocked.data':blocked
}).Class

function _blocked(val){
  if(val.val){
    this.addEvent('click',function(){
      // new Audio('http://www.noiseaddicts.com/samples_1w72b820/3739.mp3').play()
      alert('This item is not available')
    },blocked)
    this.css = { addClass:blocked }
    this.set({
      lock:new Icon({icon:'locked'})
    })
  }else{
    if(this.lock){
      this.removeEvent(false, blocked)
      this.css = { removeClass:blocked }
      this.lock.remove()
    }
  }
}

},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/poster.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Img = require('/Users/shawn/Work/directv-fl//src/components/shared/img')
var app = require('vigour-js/app')
var Item = require('./item')

List.Poster = module.exports = exports = new List({
  collection: {
    data: 'items',
    element:new Item.Poster()
  }
}).Class

// exports.element = element
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl//src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/spotlight.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')
var Img = require('/Users/shawn/Work/directv-fl//src/components/shared/img')
var app = require('vigour-js/app')

module.exports = new List.Carousel( {
  collection: {
    data: 'items',
    element:Item.Carousel
  }
} ).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl//src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/list/watching.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')
var app = require('vigour-js/app')

module.exports = new List({
  collection: {
    data: 'items',
    element:new Item.Info({
      bar:{
        w:{
          data:'time',
          multiply:100,
          abs:true,
          add:'%'
        }
      }
    })
  }
}).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/loader/index.js":[function(require,module,exports){
require('./style.less')

var Sprite = require('vigour-js/app/ui/sprite')
  , Element = require('vigour-js/app/ui/element')
  , cases = require('vigour-js/browser/cases')

module.exports = new Sprite(
{ css:'ui-loader'
, w:30
, h:30
, params:{ cols:1, rows:26 } // once:true }
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/loader/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/sprite":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/sprite/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/loader/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  background:{
    data:'mpaa',
    add:{data:'show.mpaa'},
    transform:function(v, mpaa){
      if( mpaa ) return 'assets/img/app/mpaa_' + mpaa.toLowerCase() + '.png'
    }
  }
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js":[function(require,module,exports){
require('./style.less')

var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
module.exports = new Icon({
  css:'ui-icon shared-mute',
  icon:{
    transform:function(v,cv){
      return cv ? 'mutedAlt' : 'volume'
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/mute/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/mute/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/poll/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var config = require('vigour-js/util/config')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar').Bar

var VoteRow = new Element({
  css: 'ui-voterow',
  left: {
    logo: { 
      background: { 
        data: 'img',
        prepend: config.pointers.assets
      },
      'events.click': function(){
        this.data.votes.val += 1
      }
    }
  },
  right: {
    count: {
      model:function(data){
        if(data._parent){
          this.model = false
          this.votefiller.data = data._parent
        }
      },
      team: { text: { data: 'title' } },
      votes: { text: { data: 'votes' ,add: ' VOTES' } },
      votefiller: new Bar({
        seek: {
          w:{
            data:true,
            transform: function( c, cv ){
              var count = this.parent.parent
              var myvotes = count.data && count.data.votes && count.data.votes.val
              if(myvotes) {
                var v1 = cv[0].votes.val
                var v2 = cv[1].votes.val
                var total = v1 + v2
                return ( myvotes / total ) * 100 + '%'
              }
            }
          },
          'extend.$backgroundColor': function( val ){
            var count = this.parent.parent
            var mycolor = count.data && count.data.color && count.data.color.val
            if(mycolor) {
            this.node.style.backgroundColor = mycolor
            }
          },
          '$backgroundColor.data': true
        }
      })
    }
  }
}).Class

var Poll = new Element({
  css: 'ui-poll',
  display:{
    val:'block',
    when:{data:'poll.0.title'},
    or:'none'
  },
  header: { text: { data: 'poll.title' } },
  first: new VoteRow({
    model: { field: 'poll.0' }
  }),
  second: new VoteRow({
    model: { field: 'poll.1' }
  })
}).Class

module.exports = Poll

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/poll/style.less","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/poll/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/popup/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')
var Switcher = require( 'vigour-js/app/ui/switcher' )
    .inject( require( 'vigour-js/app/ui/switcher/transitions' ) )

module.exports = exports = new Element({
  css:'popup',
  topbar:{
    left:new Icon({icon:'left'}),
    middle: { text:'popup' },
    right:new Icon({
      icon:'close',
      events: {
        click:function() {
          this.parent.parent.popup.$userOrigin = false
        }
      }
    })
  },
  w:app.w,
  h:app.h,
  y:
  { val:0, 
    animation:
    { time:app.h.val / 30
    , start:app.h
    , easing:'outCubic'
    , done:function(cv) {
        var t = this
        if(cv>=100) t.remove()
      }
    }
  },
  switcher:new Switcher({
    onTransition: {
      val:'fade',
      $hasTouch: 'slide'
    },
    backFallback: function() {
      console.error('wtf moet hier...backfallback')
    }
  }),
  extend:{
    popup:function(){}
  }
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/app/ui/switcher/transitions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  text:{data:'rating',add:{data:'show.rating'}}
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var app = require('vigour-js/app')

var Recommendations = new Element({
  css: 'ui-recommendations',
  display:{
    val:'block',
    when:{
      data:'recommendations',
      or:{
        data:'show.recommendations'
      }
    },
    or:'none'
  },
  header: { text: 'You\'ll love these' },
  body: {
    scrollbar: 'x',
    collection: {
      data: 'recommendations',
      element: Poster
    }
  }
}).Class

module.exports = Recommendations

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/style.less","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/search.js":[function(require,module,exports){
var app = require('vigour-js/app/')
var Element = require('vigour-js/app/ui/element')
var display = require('vigour-js/browser/element/properties/collection/display')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Mute = require('/Users/shawn/Work/directv-fl/src/components/shared/mute')
var config = require('vigour-js/util/config')

var Result = exports.Result = app.cases.$isPhone 
? new Element({
    css:'search-result',
    body: {
      title: {
        text:{data:'title'},
      },
      arrowRight: new Icon({ icon:'right' })
    },
    'events.click':function(e) {
      app.user.navigation.content.$userOrigin = this.data
     }
  }).Class
: new Element({
    css:'search-result',
    'poster.container':new Img({
      'background.data':'img.poster'
    }),
    body:{
      'title.text.data':'title',
      subtitle:new Subtitle()
    }
  }).Class

var Results = exports.Results = new Element({
  css:'search-results',
  title: {
    text:'recent searches'
  },
  collection: {
    option:display,
    element:Result
  }
}).Class

var TopResult = exports.TopResult = new Element({
  title: {text:'top result'},
  css:'search-top-result',
  body: {
    poster:{
      img: {
        background: {
          val: config.pointers.assets,
          add: { data:'img.poster' }
        },
        backdrop:{},
        mute:new Mute({
          display:{
            val:'none',
            $hasReceiver:'block'
          },
          icon:{
            val:app.user.trailerMuted
          },
          'events.click':function(e) {
            app.user.trailerMuted.$userOrigin = !app.user.trailerMuted.val
          }
        })
      }
    },
    textHolder:{
      title: { text:{ data:'title' } },
      info: { text:'112 minutes' },
      rating: {
        text: { data:'rating'}
      },
      description: { text: { data: 'description'} },
      'events.click':function(e) {
        var data =  this.title.data
        
        //_name
        if(data._contentType==='series') {
          data = data.get('seasons.0.episodes.0')
        }

        app.user.navigation.content.$userOrigin = data
      }
    }
  },
  model: { inherit: false }
  // 'model.field':'movies.0' //deze moet dynamicly changen :(
}).Class

exports.ResultList = new Element({
  movies: new Results({
    title: {
      text:'movies'
    },
    collection: {
      element: new Result({
        model: {
          subscription: {
            title:true,
            actors:{
              $:{
                title:true
              }
            }
          }
        }
      }),
      data:'movies'
    }
  }),
  series: new Results({
    title: {
      text:'series'
    },
    collection: {
      data:'series',
      element: new Result({
        'events.click':function(e) {
           app.user.navigation.content.$userOrigin = this.data.get('seasons.0.episodes.0')
        }
      })
    }
  }),
  channels: new Results({
    title: {
      text:'channels'
    },
    collection: {
      data:'channels'
    }
  }),
  actors: new Results({
    title: {
      text:'actors'
    },
    collection: {
      data:'actors',
      element: new Result({
        model: {
          subscription: {
            title:true,
            catalog:{
              $:{
                title:true
              }
            }
          }
        },
        'events.click':function(e) {
          //misc
          // alert('?')
          app.popup.$userOrigin = this.data.from
        }
      })
    }
  })
}).Class

exports.filterCollection = function( element, srch, filter) {
  filter = filter || {
    condition: {
      $or: [
      { title:{ $contains:srch } },
      { catalog:{ $: { title: { $contains:srch } } } },
      { actors:{ $: { title: { $contains:srch } } } }
      ]
    }
  }
  if( element.filter ) {
    element.filter.filter = filter
  } else {
    element.collection = { filter: filter }
  }    
}

exports.topResult = function( list ) {
  for(var i in list) {
    if( list[i].filter && list[i].filter[0] ) {
      return list[i].filter[0]
    }
  }
}

exports.parseSearch = function(val) {
  if(val && val.__t === 2) {
    return ''
  }
  val = val && val.trim() || ''
  var str = '';
  return val
}
},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mute":"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/properties/collection/display":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/display.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var app = require('vigour-js/app/') //  replace app stuff with parent
var ua = require('vigour-js/browser/ua')
var cases = require('vigour-js/browser/cases')
var videoUtil = require('vigour-js/browser/element/video/util')
var Icon = require('../icon')
var _limitUpdates = ua.platform === 'ios' || ua.platform === 'android'

var Bar = new Element({
  css:'ui-seekbar',
  bg:{},
  seek:{}
}).Class

var seekbar = new Bar({
  css:{
    data:'title',
    transform:function(){
      var type = this.data && this.data._contentType
      return 'ui-seekbar' + ( type === 'channels' ? ' channel' : '')
    }
  },
  'seek.w':{ 
    data:'time',
    transform:function(v,cv){
      return Math.abs(cv) * 100 + '%'
    }
  },
  bg: {
    loaderbar: {}
  },
  button:{ y:{ val:-9,translate:true } },
  events:{
    down: function(e) { 
      e.tempPrevent = true
      setTime.call(this, e)
    },
    drag: setTime,
    up:cases.touch
      ? function(e){
          var overlayOpacity = this.parent.parent.parent.opacity
          if(!this._skipUp) setTime.call(this, e)
          else this._skipUp = null
        }
      : setTime
  }
})

module.exports = exports = seekbar.Class

exports.Bar = Bar

function setTime(e) {

  if(this.seek.data._contentType === 'channels') return
  // console.error('xxxx')
  var rect = this.node.getBoundingClientRect()
    , x
    , nr

  if(this._left){
    x = rect.top
    nr = (e.y-x)/rect.height
  }else if(this._right){
    x = rect.top
    nr = (rect.height-(e.y-x))/rect.height
  }else{
    x = rect.left
    nr = (e.x-x)/(rect.right-x)
  }

  var val = nr > 1 ? 1 : nr < 0 ? 0 : nr
  if( val !== this._prevVal )
  {
    this.seek.data.from.set('time',val)
    this._prevVal = val
  }
}
},{"../icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/style.less","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element/video/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/util.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var config = require('vigour-js/util/config')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

var Score = new Element({
  css:'ui-score',
  top: {
    info: {
      'title.text.data': 'statistics.title',
      'subtitle.text.data': 'statistics.date'
    },
    teams: {
      left: new Img({
        'background.data': 'statistics.left.img'
      }),
      right:new Img({
        'background.data': 'statistics.right.img'
      })
    }
  },
  body: {
    'left.text.data': 'statistics.left.points',
    middleleft: {
      'title.text.data': 'statistics.left.acronym',
      'subtitle.text.data': 'statistics.left.innings'
    },
    middleright: {
      'title.text.data': 'statistics.right.acronym',
      'subtitle.text.data': 'statistics.right.innings'
    },
    'right.text.data': 'statistics.right.points',
  }
}).Class

module.exports = exports = new Element({
  css: 'ui-statistics',
  display:{
    data:'statistics.title',
    transform:function(v,cv){
      return cv ? 'block' : 'none'
    }
  },
  'header.text': 'Statistics',
  body:new Score()
}).Class

exports.Score = Score
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/statistics/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/stickers/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Mpaa = require('../mpaa')
var Rating = require('../rating')

module.exports = new Element({
  css:'ui-stickers',
  mpaa:new Mpaa(),
  rating: new Rating()
}).Class
},{"../mpaa":"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js","../rating":"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/stickers/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/stickers/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  text: {
    data: 'subtitle',
    add: [
      '.', {
        data: 'year',
        add: [' - ', {
          data: 'duration',
          divide: 60,
          floor: true,
          add: ' Minutes'
        }]
      },
      '.', {
        data: 'guide.0.start-time',
        add: [' - ', {
          data: 'guide.0.end-time'
        }]
      }
    ],
    transform: function(v, cv) {
      var arr = cv.split('.')
      var l = arr.length - 1
      var str = arr[l]
      while (str[1] === '-' || (str[5] === '-' && str[7] === ' ')) { //dirty!
        str = arr[--l]
      }
      if (str) return str

      var from = this.data && this.data.from
      if (from) {
        var episode = (from._name | 0) + 1
        var season = (from._parent._parent._name | 0) + 1
        return 'Season ' + season + ' - ' + 'Episode ' + episode
      }
    }
  }
}).Class

},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )

module.exports = exports = new Element({
  'text.default.data':'title'
}).Class

exports.Show = new exports({
  'text.data':'show.title'
}).Class

// exports.Program = new exports({
//   'text.data':'guide.0.title'
// }).Class
// exports.Topbar = new exports.Show({

// })
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var ASSETS = require('vigour-js/util/config').pointers.assets

module.exports = new Element({
  css: 'ui-trivia',
  'header.text': 'Trivia',
  display:{
    data:'trivia.title',
    transform:function(v,cv){
      return cv ? 'block' : 'none'
    }
  },
  body: {
    background: { 
      data: 'img',
      prepend: ASSETS
    },
    'title.text.data': 'trivia.title',
    'subtitle.text.data': 'trivia.subtitle',
    'description.text.data': 'trivia.description'
  }
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/trivia/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/tweets/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')

var app = require('vigour-js/app')

var tweet = new Element({
  css: 'tweet',
  icon: new Icon({icon:'twitter'}),
  from: { text: { val: '@', add: { data: 'author' } } },
  msg: { text: { data: 'body' } },
  retweet: { text: 'RETWEET' }
})

var Tweets = new Element({
    css: 'ui-tweets',
    display:{
      data:'tweets',
      transform:function(v,cv){
        return cv ? 'block' : 'none'
      }
    },
    header: { text: 'Tweets' },
    holdert: { //weird name.... holder is a class
      scrollbar: 'x',
      body: {
        collection: {
          data: 'tweets',
          element: tweet
        }
      }
    }
}).Class

module.exports = Tweets

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/tweets/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/tweets/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

module.exports = new Element({
  css:'ui-wallpaper'
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var Switcher = require( 'vigour-js/app/ui/switcher' )
    .inject( require( 'vigour-js/app/ui/switcher/transitions' ) )
var app = require( 'vigour-js/app' )
var cases = app.cases
var Wallpaper = require('/Users/shawn/Work/directv-fl/src/components/shared/wallpaper')

module.exports = exports = new Switcher( {
  css:'app-switcher',
  on: {
    state: { //state lekker extended
      defer: function( update ) {
        var on = this._parent
        var switcher = on._caller
        var state = this.from.val
        
        if( state==='second' ) {

          switcher.transition = {
            element:require('/Users/shawn/Work/directv-fl//src/components/inactive'),
            $params:{ 
              $highlight:on.highlight._val,
              $preview:on.preview._val,
              $media:app.user.receiver.media,
              $page:on.navigation._val.page,
              $content:on.navigation._val.content,
              navigation:{
                data:app.content.get('discover'),
                $focus:on.focus._val,
                container:{
                  progress:{
                    data:on.preview._val
                  }
                }
                // $progress:app.progress
              }
            }
          }

        } else if( state==='first' ) {

          switcher.transition = {
            element:require('/Users/shawn/Work/directv-fl//src/components/active'),
            $params:{
              menu: {
                navigation: app.user.navigation
              },
              on:{
                focus:on.focus._val,
                popup:on.popup._val,
                secondPopup:on.secondPopup._val
              },
              holder:{
                topbar:{
                  $current: app.current,
                },
                switcher:{
                  navigation: app.user.navigation
                },
                miniplayer:{
                  media:app.user.receiver.media,
                  playing:app.user.receiver.playing
                }
              }
            }
          }

        } else if( state === 'inactive'){
        
          switcher.transition = {
            element:Wallpaper,
            $params:{}
          }

        }

        update()
      }
    }
  },
  onTransition:'fade'
} ).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/switcher/style.less","/Users/shawn/Work/directv-fl//src/components/active":"/Users/shawn/Work/directv-fl/src/components/active/index.js","/Users/shawn/Work/directv-fl//src/components/inactive":"/Users/shawn/Work/directv-fl/src/components/inactive/index.js","/Users/shawn/Work/directv-fl/src/components/shared/wallpaper":"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/app/ui/switcher/transitions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js"}],"/Users/shawn/Work/directv-fl/src/components/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/util/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
exports.focused = function( holder, focused, method ) {
  if ( focused ) {
    
    var previous = holder._focused

    if ( previous !== focused ) {

      if ( previous ) {
        previous.css = {
          removeClass: 'focused'
        }
        previous.$focused = false
      }

      focused.css = {
        addClass: 'focused'
      }

      focused.$focused = true

      if ( method ) method( focused, previous )

      holder._focused = focused
    }

  }
}

exports.preventAnimation = function( _this, method, done ){
  _this._blocked = true
  _this.css = {addClass:'dontAnimate'}
  window.requestAnimationFrame(function(){
    method()
    window.requestAnimationFrame(function(){
      _this.css = {removeClass:'dontAnimate'}
      _this._blocked = null
      if( done ) done()
    })
  })
}
},{}],"/Users/shawn/Work/directv-fl/src/main/clienthack.js":[function(require,module,exports){
var app = require('/Users/shawn/Work/directv-fl/src/app')
var url = require('vigour-js/browser/network/url')
var ua = require('vigour-js/browser/ua')
var device = url.params.device && url.params.device.val || ua.device

var clientinfo = {
  phone: {
    title: 'Kevin\'s iPhone',
    info: 'iPhone 6'
  },
  tablet: {
    title: 'Kevin\'s iPad',
    info: 'iPad 2',
    device: 'tablet'
  },
  tv: {
    title: 'Sharp',
    info: '52" LED TV',
    device: 'tv'
  },
  IFE: {
    title: 'United Airlines',
    info: 'In Flight Entertainment',
    device: 'IFE'
  },
  def: {
    title: ua.platform+' '+device,
    info: ua.platform+' '+device,
    device:device
  }
}

app.cloud.client.val = clientinfo[device] || clientinfo.def
},{"/Users/shawn/Work/directv-fl/src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/browser/network/url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/main/index.js":[function(require,module,exports){
require('./uahack')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Switcher = require('/Users/shawn/Work/directv-fl//src/components/switcher')
var user = app.user

if(app.cases.$isNative){
  var statusBar = require('vigour-native-statusBar')
  statusBar.set({
    style:'light',
    visibility:'overlay'
  }, function (err) {
    if (err) alert("error setting statusBar: " +err)
  })
}

// switcher between first/second/player

// app.ready.once(true,function(){

require('./clienthack')

// app.ready.once(true,function(){
// alert('x')
app.set({
  switcher: new Switcher( {
    on: {
      navigation: user.navigation,
      play: app.playing,
      receiver: user.receiver,
      usage: user.usage,
      content: app.content,
      search: user.search,
      focus: user.focus_row,
      preview: app.preview,
      highlight: app.highlight,
      popup:app.popup,
      secondPopup:app.secondPopup,
      //nav word different
      // watched: user.watched.from,
      state: app.state,
      overlay: app.overlay,
      loading: app.loading,
      activeClient: user.activeClient,
      volume: app.volume
    }
  })
})

// TODO: rename app.initialized?

// app.popup.val = 'actor'
// app.menu.val = true
// })

app.initialised.val = true


// app.ready.is(true,function(){
//   app.secondPopup.val = 'volume'
// },true)
},{"./clienthack":"/Users/shawn/Work/directv-fl/src/main/clienthack.js","./uahack":"/Users/shawn/Work/directv-fl/src/main/uahack.js","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl//src/components/switcher":"/Users/shawn/Work/directv-fl/src/components/switcher/index.js","vigour-native-statusBar":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/index.js"}],"/Users/shawn/Work/directv-fl/src/main/uahack.js":[function(require,module,exports){
var ua = require('vigour-js/browser/ua')
var cases = require('vigour-js/browser/cases')

console.log('---------------- ua hacking that!', ua)


if(ua.device === 'desktop') {
  ua.device = 'tv'
  ua.platform = 'fancy'
  cases.$isDesktop = false
  cases.$isTv = true
  window.INACTIVE = true
} else if(ua.device === 'ipad') {
  window.INACTIVE = true

}

},{"vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"package.json":[function(require,module,exports){
module.exports={"name":"directv-fl","version":"2015/06/13 15:02:52 UTC (1.0.5)","description":"","main":"index.js","scripts":{"startGaston":"./node_modules/.bin/gaston dev","start":"npm run startGaston","test":"echo \"Error: no test specified\" && exit 1","symlink":"mkdir -p node_modules; ln -sf $(pwd) $(pwd)/node_modules","startHub":"./node_modules/vigour-hub/bin/hub -d -c directv","prestart":"npm run startHub &","build":"vNative build","release":"packer -r -c package.json,.package.json"},"repository":{"type":"git","url":"https://github.com/vigour-io/directv-fl.git","branch":"production"},"author":"Vigour","bugs":{"url":"https://github.com/vigour-io/directv-fl/issues"},"homepage":"https://github.com/vigour-io/directv-fl","dependencies":{"through2":"*","lodash":"3.2.0","monotonic-timestamp":"0.0.9","promise":"^7.0.1","vigour-js":"git+ssh://git@github.com:vigour-io/vigour-js.git#directv"},"devDependencies":{"vigour-native":"git+ssh://git@github.com:vigour-io/vigour-native.git","vigour-native-statusBar":"git+ssh://git@github.com:vigour-io/vigour-native-statusBar.git","vigour-packer-server":"git+ssh://git@github.com:vigour-io/vigour-packer-server.git","vigour-hub":"git+ssh://git@github.com:vigour-io/vigour-hub.git#directv","gaston":"git+ssh://git@github.com:vigour-io/gaston.git"},"vigour":{"cloud":"http://52.8.23.45:80","development":{"button":false},"pointers":{"assets":"http://devassets.vigour.io/"},"packer":{"web":"index.html","assets":{"bundle.js":true,"bundle.css":true,"index.html":true,"assets":"*","fonts.css":true},"git":{"owner":"vigour-io","repo":"directv-fl"},"mail":{"fromAddress":"shawn@vigour.io","to":"shawn@vigour.io"},"slack":{},"server":{}},"native":{"platforms":{"ios":{"productName":"DTV - In Flight","organizationName":"Vigour","organizationIdentifier":"io.vigour.directv-fl","buildNumber":"1","appIndexPath":"index.html","appUrlIdentifier":"com.directv-fl.org","appUrlScheme":"directv-fl"}}},"branches":{"master":{"pointers":{"img":"http://jim.local/assets/","assets":"http://jim.local/assets/"}},"youzi-dev":{"pointers":{"img":"http://jim.local/assets/","assets":"http://jim.local/assets/"}},"marcus-dev":{"cloud":"http://localhost:10001","uscloud":"http://54.173.192.57:10001"},"shawn-dev":{"cloud":"http://192.168.2.18:10001"},"production":{"cloud":"http://52.8.23.45:80","native":{"platforms":{"ios":{"productName":"DTV - In Flight"}}}},"airplane":{"cloud":"http://52.8.40.195:80","native":{"platforms":{"ios":{"productName":"DTV DEMO - In Flight"}}}},"livingroom":{"cloud":"http://directv-fl-demo.local:10001","pointers":{"assets":"http://directv-fl-demo.local/"},"native":{"platforms":{"ios":{"productName":"DTV DEMO - Home"}}}}}},"gaston":{"browserify-transforms":[{"path":"vigour-js/util/inform-transform","options":{"global":"false"}}],"require-paths":{"dtv":"src","shared":"src/components/shared","dtv-components":"src/components","dtv-active":"src/components/active","dtv-item":"src/components/active/content-item","dtv-channel":"src/components/active/content-item/channel","dtv-episode":"src/components/active/content-item/episode","dtv-movie":"src/components/active/content-item/movie"}},"sha":"1.0.5"}
},{}]},{},["/Users/shawn/Work/directv-fl/index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImNvbmZpZy5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZG9tYWluLWJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2FzdG9uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL29zLWJyb3dzZXJpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ2FzdG9uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbW9ub3RvbmljLXRpbWVzdGFtcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2NvcmUuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9lczYtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL25vZGUtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItYXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItcmF3LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2Uvbm9kZV9tb2R1bGVzL2FzYXAvcmF3LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvY2xvdWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC9jb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91aS9lbGVtZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdWkvc3ByaXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlci90cmFuc2l0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvaWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdXNlci9tb2NrZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvbXVsdGlzY3JlZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL25hdmlnYXRpb24uanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL29yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvc2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdXNlci90b2tlbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvdXNhZ2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC92YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jhc2Uvc2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL2Vhc2luZy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vZnJhbWUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9yYWYuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jYXNlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jYXNlcy9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvY3NzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2NvbGxlY3Rpb24vZGlzcGxheS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvY29sbGVjdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvY29sbGVjdGlvbi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvcHJvY2Vzcy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvc2Nyb2xsYmFyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvc2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8vaHRtbDUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL2FkdmFuY2VkLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy9iYXNpYy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9ldmVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL29mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2FqYXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9hdXRoZW50aWNhdGUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvZGF0YWNsb3VkLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2Nsb3VkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvc29ja2V0LmlvLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2RhdGEvZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2RhdGEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay91cmwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvdWEuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2RhdGEvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvZGF0YS9jb25kaXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9kYXRhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9kYXRhL3NlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9jb2xvcnMvY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWluaGVyaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeS9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL3V0ZjgvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2hhcy1jb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvaGFzLWNvcnMvbm9kZV9tb2R1bGVzL2dsb2JhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZWpzb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3Byb21pc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZG9uZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2VzNi1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvbm9kZS1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9ub2RlX21vZHVsZXMvYXNhcC9hc2FwLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9vYmplY3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2pzb24zL2xpYi9qc29uMy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3RvLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9vYmplY3QvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL29iamVjdC9jb21wb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9vYmplY3QvaGFzaHBhdGguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL29iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L2xpc3Rlbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvY29uZmlnL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL2NvbmZpZy91YS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9kZWJ1Zy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9kZWJ1Zy9sb2cuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvZGVidWcvcGVyZm9ybWFuY2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL2hhc2guanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaW5qZWN0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9wcm9jZXNzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL3Byb3AuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL2RhdGEuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9mbGFncy9wYXJlbnQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3NlbGYuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9sZW5ndGguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL29uLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9vcGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyL3BhY2thZ2UuanNvbiIsInNyYy9hcHAvaW5kZXguanMiLCJzcmMvYXBwL2luaXQuanMiLCJzcmMvYXBwL3BsYXliYWNrLmpzIiwic3JjL2FwcC91c2VyLmpzIiwic3JjL2FwcC92YWx1ZXMuanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvY2hhbm5lbC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9jb250ZW50L2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2Rpc2NvdmVyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2VwaXNvZGUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvbWVudS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9tb3ZpZS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wbGF5ZXIvZnVsbHNjcmVlbi5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wbGF5ZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvYWN0b3IvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvZGV2aWNlcy9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9wYWdlLmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3BvcHVwL3JlbW90ZS9jYXJvdXNlbC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9yZW1vdGUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvdm9sdW1lL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3JlbW90ZS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9zZWFyY2gvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvc3dpdGNoZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvdG9wYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3RvcGJhci9pbnB1dC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2Jpby9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2NoYW5uZWwvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9pbmFjdGl2ZS9jb250ZW50L2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvY292ZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9pbmFjdGl2ZS9kaXNjb3Zlci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvbmF2aWdhdGlvbi9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3BsYXllci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3Byb2dyZXNzL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvc2VhcmNoL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvc3RhdHVzYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvdHJhaWxlci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3ZvZC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3dpZGdldC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9hY3RvcnMvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2Rlc2NyaXB0aW9uL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24vaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QvY2hhbm5lbC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2RvdHMuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2l0ZW0uanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9wb3N0ZXIuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9zcG90bGlnaHQuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC93YXRjaGluZy5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9sb2FkZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbXBhYS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9tdXRlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3BvbGwvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvcG9wdXAvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvcmF0aW5nL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3JlY29tbWVuZGF0aW9ucy9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9zZWFyY2guanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2Jhci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9zdGF0aXN0aWNzL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3N0aWNrZXJzL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3N1YnRpdGxlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3RpdGxlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3RyaXZpYS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC90d2VldHMvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvd2FsbHBhcGVyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc3dpdGNoZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy91dGlsL2luZGV4LmpzIiwic3JjL21haW4vY2xpZW50aGFjay5qcyIsInNyYy9tYWluL2luZGV4LmpzIiwic3JjL21haW4vdWFoYWNrLmpzIiwicGFja2FnZS5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvVUE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGpCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzcxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIndpbmRvdy5uYW1lID0gJ2RpcmVjdHYtZmwnXG5cbi8vIHdpbmRvdy5wYWNrYWdlID0gcmVxdWlyZSgncGFja2FnZS5qc29uJylcbi8vIGNvbnNvbGUubG9nKCd3dGYuLi4nLCB3aW5kb3cucGFja2FnZSlcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcmVxdWlyZSggJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycgKVxuICAgICAgICAgICAgICAuaW5qZWN0XG4gICAgICAgICAgICAgICggeyAncmVwb3NpdG9yeS5icmFuY2gnOiAnYnJhbmNoZXMnIH1cbiAgICAgICAgICAgICAgLCByZXF1aXJlKCAndmlnb3VyLWpzL3V0aWwvY29uZmlnL3VhJyApXG4gICAgICAgICAgICAgIClcblxuZXhwb3J0cyggZnVuY3Rpb24oIHJlc3VsdCApIHtcbiAgZm9yKHZhciBrZXkgaW4gcmVzdWx0KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1xcbicsIGksIHJlc3VsdFtpXSlcbiAgICBleHBvcnRzW2tleV0gPSByZXN1bHRba2V5XSBcbiAgfVxuICBleHBvcnRzLnBhcnNlZCA9IHRydWVcblxufSwgZmFsc2UsIHdpbmRvdy5wYWNrYWdlLCB0cnVlICkiLCJcblxuLy8gd2luZG93Ll9fdWFfXyA9IHtcbi8vICAgZGV2aWNlOid0YWJsZXQnXG4vLyB9XG5cbndpbmRvdy5wYWNrYWdlID0gcmVxdWlyZSgncGFja2FnZS5qc29uJyk7XG52YXIgY29uZmlnID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vY29uZmlnJylcbiAgLCByZW1vdGVcblxuXG5pZiggY29uZmlnLmRldmVsb3BtZW50ICYmIGNvbmZpZy5kZXZlbG9wbWVudC5idXR0b24gKVxue1xuICByZW1vdGUgPSByZXF1aXJlKCAndmlnb3VyLWpzL3V0aWwvZGVidWcnIClcbiAgICAgICAgICAgIC5uYXRpdmUoIGZhbHNlLCBmYWxzZSwgZnVuY3Rpb24odXJsKSB7fSAsICdidW5kbGUnIClcbn1cblxuaWYoICFyZW1vdGUgKSBcbntcbiAgdmFyIGNhc2VzID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJyApXG4gICAgLCB1YSA9IHJlcXVpcmUoICd2aWdvdXItanMvYnJvd3Nlci91YScgKVxuXG4gIC8vIGlmKHVhLmRldmljZSA9PT0gJ3RhYmxldCcpe1xuICAvLyAgIHZhciB2aWV3cG9ydCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJtZXRhW25hbWU9dmlld3BvcnRdXCIpXG4gIC8vICAgdmlld3BvcnQuc2V0QXR0cmlidXRlKCdjb250ZW50JywgJ3dpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0wLjYsIG1heGltdW0tc2NhbGU9MS4wLCB1c2VyLXNjYWxhYmxlPTAnKTtcbiAgLy8gfVxuXG4gIHJlcXVpcmUoICcuL3NyYy9tYWluJyApXG4gIFxufSIsbnVsbCwiLypnbG9iYWwgZGVmaW5lOmZhbHNlIHJlcXVpcmU6ZmFsc2UgKi9cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCl7XG5cdC8vIEltcG9ydCBFdmVudHNcblx0dmFyIGV2ZW50cyA9IHJlcXVpcmUoJ2V2ZW50cycpXG5cblx0Ly8gRXhwb3J0IERvbWFpblxuXHR2YXIgZG9tYWluID0ge31cblx0ZG9tYWluLmNyZWF0ZURvbWFpbiA9IGRvbWFpbi5jcmVhdGUgPSBmdW5jdGlvbigpe1xuXHRcdHZhciBkID0gbmV3IGV2ZW50cy5FdmVudEVtaXR0ZXIoKVxuXG5cdFx0ZnVuY3Rpb24gZW1pdEVycm9yKGUpIHtcblx0XHRcdGQuZW1pdCgnZXJyb3InLCBlKVxuXHRcdH1cblxuXHRcdGQuYWRkID0gZnVuY3Rpb24oZW1pdHRlcil7XG5cdFx0XHRlbWl0dGVyLm9uKCdlcnJvcicsIGVtaXRFcnJvcilcblx0XHR9XG5cdFx0ZC5yZW1vdmUgPSBmdW5jdGlvbihlbWl0dGVyKXtcblx0XHRcdGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZW1pdEVycm9yKVxuXHRcdH1cblx0XHRkLmJpbmQgPSBmdW5jdGlvbihmbil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKXtcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm4uYXBwbHkobnVsbCwgYXJncylcblx0XHRcdFx0fVxuXHRcdFx0XHRjYXRjaCAoZXJyKXtcblx0XHRcdFx0XHRlbWl0RXJyb3IoZXJyKVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGQuaW50ZXJjZXB0ID0gZnVuY3Rpb24oZm4pe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVycil7XG5cdFx0XHRcdGlmICggZXJyICkge1xuXHRcdFx0XHRcdGVtaXRFcnJvcihlcnIpXG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGZuLmFwcGx5KG51bGwsIGFyZ3MpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNhdGNoIChlcnIpe1xuXHRcdFx0XHRcdFx0ZW1pdEVycm9yKGVycilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZC5ydW4gPSBmdW5jdGlvbihmbil7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmbigpXG5cdFx0XHR9XG5cdFx0XHRjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdGVtaXRFcnJvcihlcnIpXG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH07XG5cdFx0ZC5kaXNwb3NlID0gZnVuY3Rpb24oKXtcblx0XHRcdHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKClcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fTtcblx0XHRkLmVudGVyID0gZC5leGl0ID0gZnVuY3Rpb24oKXtcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXHRcdHJldHVybiBkXG5cdH07XG5cdHJldHVybiBkb21haW5cbn0pLmNhbGwodGhpcykiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfVxuICAgICAgdGhyb3cgVHlwZUVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LicpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSAwO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKGVtaXR0ZXIuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gMTtcbiAgZWxzZVxuICAgIHJldCA9IGVtaXR0ZXIuX2V2ZW50c1t0eXBlXS5sZW5ndGg7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cbiIsImV4cG9ydHMuZW5kaWFubmVzcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdMRScgfTtcblxuZXhwb3J0cy5ob3N0bmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbG9jYXRpb24uaG9zdG5hbWVcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLmxvYWRhdmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnVwdGltZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcblxuZXhwb3J0cy5mcmVlbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy50b3RhbG1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMuY3B1cyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdCcm93c2VyJyB9O1xuXG5leHBvcnRzLnJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbjtcbiAgICB9XG4gICAgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5uZXR3b3JrSW50ZXJmYWNlc1xuPSBleHBvcnRzLmdldE5ldHdvcmtJbnRlcmZhY2VzXG49IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHt9IH07XG5cbmV4cG9ydHMuYXJjaCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdqYXZhc2NyaXB0JyB9O1xuXG5leHBvcnRzLnBsYXRmb3JtID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2Jyb3dzZXInIH07XG5cbmV4cG9ydHMudG1wZGlyID0gZXhwb3J0cy50bXBEaXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICcvdG1wJztcbn07XG5cbmV4cG9ydHMuRU9MID0gJ1xcbic7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cbiIsIi8vIElmIGBEYXRlLm5vdygpYCBpcyBpbnZva2VkIHR3aWNlIHF1aWNrbHksIGl0J3MgcG9zc2libGUgdG8gZ2V0IHR3b1xuLy8gaWRlbnRpY2FsIHRpbWUgc3RhbXBzLiBUbyBhdm9pZCBnZW5lcmF0aW9uIGR1cGxpY2F0aW9ucywgc3Vic2VxdWVudFxuLy8gY2FsbHMgYXJlIG1hbnVhbGx5IG9yZGVyZWQgdG8gZm9yY2UgdW5pcXVlbmVzcy5cblxudmFyIF9sYXN0ID0gMFxudmFyIF9jb3VudCA9IDFcbnZhciBhZGp1c3RlZCA9IDBcbnZhciBfYWRqdXN0ZWQgPSAwXG5cbm1vZHVsZS5leHBvcnRzID1cbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgLyoqXG4gIFJldHVybnMgTk9UIGFuIGFjY3VyYXRlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHRpbWUuXG4gIFNpbmNlIGpzIG9ubHkgbWVhc3VyZXMgdGltZSBhcyBtcywgaWYgeW91IGNhbGwgYERhdGUubm93KClgXG4gIHR3aWNlIHF1aWNrbHksIGl0J3MgcG9zc2libGUgdG8gZ2V0IHR3byBpZGVudGljYWwgdGltZSBzdGFtcHMuXG4gIFRoaXMgZnVuY3Rpb24gZ3VhcmFudGVlcyB1bmlxdWUgYnV0IG1heWJlIGluYWNjdXJhdGUgcmVzdWx0c1xuICBvbiBlYWNoIGNhbGwuXG4gICoqL1xuICAvL3VuY29tbWVudCB0aGlzIHdlblxuICB2YXIgdGltZSA9IERhdGUubm93KClcbiAgLy90aW1lID0gfn4gKHRpbWUgLyAxMDAwKSBcbiAgLy9eXl51bmNvbW1lbnQgd2hlbiB0ZXN0aW5nLi4uXG5cbiAgLyoqXG4gIElmIHRpbWUgcmV0dXJuZWQgaXMgc2FtZSBhcyBpbiBsYXN0IGNhbGwsIGFkanVzdCBpdCBieVxuICBhZGRpbmcgYSBudW1iZXIgYmFzZWQgb24gdGhlIGNvdW50ZXIuIFxuICBDb3VudGVyIGlzIGluY3JlbWVudGVkIHNvIHRoYXQgbmV4dCBjYWxsIGdldCdzIGFkanVzdGVkIHByb3Blcmx5LlxuICBCZWNhdXNlIGZsb2F0cyBoYXZlIHJlc3RyaWN0ZWQgcHJlY2lzaW9uLCBcbiAgbWF5IG5lZWQgdG8gc3RlcCBwYXN0IHNvbWUgdmFsdWVzLi4uXG4gICoqL1xuICBpZiAoX2xhc3QgPT09IHRpbWUpICB7XG4gICAgZG8ge1xuICAgICAgYWRqdXN0ZWQgPSB0aW1lICsgKChfY291bnQrKykgLyAoX2NvdW50ICsgOTk5KSlcbiAgICB9IHdoaWxlIChhZGp1c3RlZCA9PT0gX2FkanVzdGVkKVxuICAgIF9hZGp1c3RlZCA9IGFkanVzdGVkXG4gIH1cbiAgLy8gSWYgbGFzdCB0aW1lIHdhcyBkaWZmZXJlbnQgcmVzZXQgdGltZXIgYmFjayB0byBgMWAuXG4gIGVsc2Uge1xuICAgIF9jb3VudCA9IDFcbiAgICBhZGp1c3RlZCA9IHRpbWVcbiAgfVxuICBfYWRqdXN0ZWQgPSBhZGp1c3RlZFxuICBfbGFzdCA9IHRpbWVcbiAgcmV0dXJuIGFkanVzdGVkXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWInKVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAvcmF3Jyk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG4vLyBTdGF0ZXM6XG4vL1xuLy8gMCAtIHBlbmRpbmdcbi8vIDEgLSBmdWxmaWxsZWQgd2l0aCBfdmFsdWVcbi8vIDIgLSByZWplY3RlZCB3aXRoIF92YWx1ZVxuLy8gMyAtIGFkb3B0ZWQgdGhlIHN0YXRlIG9mIGFub3RoZXIgcHJvbWlzZSwgX3ZhbHVlXG4vL1xuLy8gb25jZSB0aGUgc3RhdGUgaXMgbm8gbG9uZ2VyIHBlbmRpbmcgKDApIGl0IGlzIGltbXV0YWJsZVxuXG4vLyBBbGwgYF9gIHByZWZpeGVkIHByb3BlcnRpZXMgd2lsbCBiZSByZWR1Y2VkIHRvIGBfe3JhbmRvbSBudW1iZXJ9YFxuLy8gYXQgYnVpbGQgdGltZSB0byBvYmZ1c2NhdGUgdGhlbSBhbmQgZGlzY291cmFnZSB0aGVpciB1c2UuXG4vLyBXZSBkb24ndCB1c2Ugc3ltYm9scyBvciBPYmplY3QuZGVmaW5lUHJvcGVydHkgdG8gZnVsbHkgaGlkZSB0aGVtXG4vLyBiZWNhdXNlIHRoZSBwZXJmb3JtYW5jZSBpc24ndCBnb29kIGVub3VnaC5cblxuXG4vLyB0byBhdm9pZCB1c2luZyB0cnkvY2F0Y2ggaW5zaWRlIGNyaXRpY2FsIGZ1bmN0aW9ucywgd2Vcbi8vIGV4dHJhY3QgdGhlbSB0byBoZXJlLlxudmFyIExBU1RfRVJST1IgPSBudWxsO1xudmFyIElTX0VSUk9SID0ge307XG5mdW5jdGlvbiBnZXRUaGVuKG9iaikge1xuICB0cnkge1xuICAgIHJldHVybiBvYmoudGhlbjtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUNhbGxPbmUoZm4sIGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oYSk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuZnVuY3Rpb24gdHJ5Q2FsbFR3byhmbiwgYSwgYikge1xuICB0cnkge1xuICAgIGZuKGEsIGIpO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG5mdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKTtcbiAgfVxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKTtcbiAgfVxuICB0aGlzLl8zMiA9IDA7XG4gIHRoaXMuXzggPSBudWxsO1xuICB0aGlzLl84OSA9IFtdO1xuICBpZiAoZm4gPT09IG5vb3ApIHJldHVybjtcbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblByb21pc2UuXzgzID0gbm9vcDtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSBQcm9taXNlKSB7XG4gICAgcmV0dXJuIHNhZmVUaGVuKHRoaXMsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKTtcbiAgfVxuICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gIGhhbmRsZSh0aGlzLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzKSk7XG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiBzYWZlVGhlbihzZWxmLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICByZXR1cm4gbmV3IHNlbGYuY29uc3RydWN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXMgPSBuZXcgUHJvbWlzZShub29wKTtcbiAgICByZXMudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIGhhbmRsZShzZWxmLCBuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzKSk7XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGhhbmRsZShzZWxmLCBkZWZlcnJlZCkge1xuICB3aGlsZSAoc2VsZi5fMzIgPT09IDMpIHtcbiAgICBzZWxmID0gc2VsZi5fODtcbiAgfVxuICBpZiAoc2VsZi5fMzIgPT09IDApIHtcbiAgICBzZWxmLl84OS5wdXNoKGRlZmVycmVkKTtcbiAgICByZXR1cm47XG4gIH1cbiAgYXNhcChmdW5jdGlvbigpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl8zMiA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgIGlmIChzZWxmLl8zMiA9PT0gMSkge1xuICAgICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHNlbGYuXzgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIHNlbGYuXzgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmV0ID0gdHJ5Q2FsbE9uZShjYiwgc2VsZi5fOCk7XG4gICAgaWYgKHJldCA9PT0gSVNfRVJST1IpIHtcbiAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBMQVNUX0VSUk9SKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNvbHZlKHNlbGYsIG5ld1ZhbHVlKSB7XG4gIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gIGlmIChuZXdWYWx1ZSA9PT0gc2VsZikge1xuICAgIHJldHVybiByZWplY3QoXG4gICAgICBzZWxmLFxuICAgICAgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKVxuICAgICk7XG4gIH1cbiAgaWYgKFxuICAgIG5ld1ZhbHVlICYmXG4gICAgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKVxuICApIHtcbiAgICB2YXIgdGhlbiA9IGdldFRoZW4obmV3VmFsdWUpO1xuICAgIGlmICh0aGVuID09PSBJU19FUlJPUikge1xuICAgICAgcmV0dXJuIHJlamVjdChzZWxmLCBMQVNUX0VSUk9SKTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgdGhlbiA9PT0gc2VsZi50aGVuICYmXG4gICAgICBuZXdWYWx1ZSBpbnN0YW5jZW9mIFByb21pc2VcbiAgICApIHtcbiAgICAgIHNlbGYuXzMyID0gMztcbiAgICAgIHNlbGYuXzggPSBuZXdWYWx1ZTtcbiAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBkb1Jlc29sdmUodGhlbi5iaW5kKG5ld1ZhbHVlKSwgc2VsZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbGYuXzMyID0gMTtcbiAgc2VsZi5fOCA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5cbmZ1bmN0aW9uIHJlamVjdChzZWxmLCBuZXdWYWx1ZSkge1xuICBzZWxmLl8zMiA9IDI7XG4gIHNlbGYuXzggPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuZnVuY3Rpb24gZmluYWxlKHNlbGYpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl84OS5sZW5ndGg7IGkrKykge1xuICAgIGhhbmRsZShzZWxmLCBzZWxmLl84OVtpXSk7XG4gIH1cbiAgc2VsZi5fODkgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCBwcm9taXNlKXtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHByb21pc2UpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdmFyIHJlcyA9IHRyeUNhbGxUd28oZm4sIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVzb2x2ZShwcm9taXNlLCB2YWx1ZSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlamVjdChwcm9taXNlLCByZWFzb24pO1xuICB9KVxuICBpZiAoIWRvbmUgJiYgcmVzID09PSBJU19FUlJPUikge1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlamVjdChwcm9taXNlLCBMQVNUX0VSUk9SKTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHZhciBzZWxmID0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudGhlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpcztcbiAgc2VsZi50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9LCAwKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgZmlsZSBjb250YWlucyB0aGUgRVM2IGV4dGVuc2lvbnMgdG8gdGhlIGNvcmUgUHJvbWlzZXMvQSsgQVBJXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAvcmF3Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG52YXIgVFJVRSA9IHZhbHVlUHJvbWlzZSh0cnVlKTtcbnZhciBGQUxTRSA9IHZhbHVlUHJvbWlzZShmYWxzZSk7XG52YXIgTlVMTCA9IHZhbHVlUHJvbWlzZShudWxsKTtcbnZhciBVTkRFRklORUQgPSB2YWx1ZVByb21pc2UodW5kZWZpbmVkKTtcbnZhciBaRVJPID0gdmFsdWVQcm9taXNlKDApO1xudmFyIEVNUFRZU1RSSU5HID0gdmFsdWVQcm9taXNlKCcnKTtcblxuZnVuY3Rpb24gdmFsdWVQcm9taXNlKHZhbHVlKSB7XG4gIHZhciBwID0gbmV3IFByb21pc2UoUHJvbWlzZS5fODMpO1xuICBwLl8zMiA9IDE7XG4gIHAuXzggPSB2YWx1ZTtcbiAgcmV0dXJuIHA7XG59XG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHZhbHVlO1xuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIE5VTEw7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gVU5ERUZJTkVEO1xuICBpZiAodmFsdWUgPT09IHRydWUpIHJldHVybiBUUlVFO1xuICBpZiAodmFsdWUgPT09IGZhbHNlKSByZXR1cm4gRkFMU0U7XG4gIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIFpFUk87XG4gIGlmICh2YWx1ZSA9PT0gJycpIHJldHVybiBFTVBUWVNUUklORztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoZW4gPSB2YWx1ZS50aGVuO1xuICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVQcm9taXNlKHZhbHVlKTtcbn07XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycik7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKTtcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFByb21pc2UgJiYgdmFsLnRoZW4gPT09IFByb21pc2UucHJvdG90eXBlLnRoZW4pIHtcbiAgICAgICAgICB3aGlsZSAodmFsLl8zMiA9PT0gMykge1xuICAgICAgICAgICAgdmFsID0gdmFsLl84O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsLl8zMiA9PT0gMSkgcmV0dXJuIHJlcyhpLCB2YWwuXzgpO1xuICAgICAgICAgIGlmICh2YWwuXzMyID09PSAyKSByZWplY3QodmFsLl84KTtcbiAgICAgICAgICB2YWwudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuO1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIHAgPSBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsKSk7XG4gICAgICAgICAgICBwLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHJlamVjdCh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qIFByb3RvdHlwZSBNZXRob2RzICovXG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10gPSBmdW5jdGlvbiAoZikge1xuICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZigpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZigpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xucmVxdWlyZSgnLi9kb25lLmpzJyk7XG5yZXF1aXJlKCcuL2ZpbmFsbHkuanMnKTtcbnJlcXVpcmUoJy4vZXM2LWV4dGVuc2lvbnMuanMnKTtcbnJlcXVpcmUoJy4vbm9kZS1leHRlbnNpb25zLmpzJyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBjb250YWlucyB0aGVuL3Byb21pc2Ugc3BlY2lmaWMgZXh0ZW5zaW9ucyB0aGF0IGFyZSBvbmx5IHVzZWZ1bFxuLy8gZm9yIG5vZGUuanMgaW50ZXJvcFxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG5Qcm9taXNlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChmbiwgYXJndW1lbnRDb3VudCkge1xuICBhcmd1bWVudENvdW50ID0gYXJndW1lbnRDb3VudCB8fCBJbmZpbml0eTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB3aGlsZSAoYXJncy5sZW5ndGggJiYgYXJncy5sZW5ndGggPiBhcmd1bWVudENvdW50KSB7XG4gICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICB9XG4gICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICBlbHNlIHJlc29sdmUocmVzKTtcbiAgICAgIH0pXG4gICAgICB2YXIgcmVzID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICBpZiAocmVzICYmXG4gICAgICAgIChcbiAgICAgICAgICB0eXBlb2YgcmVzID09PSAnb2JqZWN0JyB8fFxuICAgICAgICAgIHR5cGVvZiByZXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgKSAmJlxuICAgICAgICB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbidcbiAgICAgICkge1xuICAgICAgICByZXNvbHZlKHJlcyk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuUHJvbWlzZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIHZhciBjYWxsYmFjayA9XG4gICAgICB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nID8gYXJncy5wb3AoKSA6IG51bGw7XG4gICAgdmFyIGN0eCA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLm5vZGVpZnkoY2FsbGJhY2ssIGN0eCk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBleCk7XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBudWxsLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlcnIpO1xuICAgIH0pO1xuICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyByYXdBc2FwIHByb3ZpZGVzIGV2ZXJ5dGhpbmcgd2UgbmVlZCBleGNlcHQgZXhjZXB0aW9uIG1hbmFnZW1lbnQuXG52YXIgcmF3QXNhcCA9IHJlcXVpcmUoXCIuL3Jhd1wiKTtcbi8vIFJhd1Rhc2tzIGFyZSByZWN5Y2xlZCB0byByZWR1Y2UgR0MgY2h1cm4uXG52YXIgZnJlZVRhc2tzID0gW107XG4vLyBXZSBxdWV1ZSBlcnJvcnMgdG8gZW5zdXJlIHRoZXkgYXJlIHRocm93biBpbiByaWdodCBvcmRlciAoRklGTykuXG4vLyBBcnJheS1hcy1xdWV1ZSBpcyBnb29kIGVub3VnaCBoZXJlLCBzaW5jZSB3ZSBhcmUganVzdCBkZWFsaW5nIHdpdGggZXhjZXB0aW9ucy5cbnZhciBwZW5kaW5nRXJyb3JzID0gW107XG52YXIgcmVxdWVzdEVycm9yVGhyb3cgPSByYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcih0aHJvd0ZpcnN0RXJyb3IpO1xuXG5mdW5jdGlvbiB0aHJvd0ZpcnN0RXJyb3IoKSB7XG4gICAgaWYgKHBlbmRpbmdFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IHBlbmRpbmdFcnJvcnMuc2hpZnQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbHMgYSB0YXNrIGFzIHNvb24gYXMgcG9zc2libGUgYWZ0ZXIgcmV0dXJuaW5nLCBpbiBpdHMgb3duIGV2ZW50LCB3aXRoIHByaW9yaXR5XG4gKiBvdmVyIG90aGVyIGV2ZW50cyBsaWtlIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVwYWludC4gQW4gZXJyb3IgdGhyb3duIGZyb20gYW5cbiAqIGV2ZW50IHdpbGwgbm90IGludGVycnVwdCwgbm9yIGV2ZW4gc3Vic3RhbnRpYWxseSBzbG93IGRvd24gdGhlIHByb2Nlc3Npbmcgb2ZcbiAqIG90aGVyIGV2ZW50cywgYnV0IHdpbGwgYmUgcmF0aGVyIHBvc3Rwb25lZCB0byBhIGxvd2VyIHByaW9yaXR5IGV2ZW50LlxuICogQHBhcmFtIHt7Y2FsbH19IHRhc2sgQSBjYWxsYWJsZSBvYmplY3QsIHR5cGljYWxseSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm9cbiAqIGFyZ3VtZW50cy5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBhc2FwO1xuZnVuY3Rpb24gYXNhcCh0YXNrKSB7XG4gICAgdmFyIHJhd1Rhc2s7XG4gICAgaWYgKGZyZWVUYXNrcy5sZW5ndGgpIHtcbiAgICAgICAgcmF3VGFzayA9IGZyZWVUYXNrcy5wb3AoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByYXdUYXNrID0gbmV3IFJhd1Rhc2soKTtcbiAgICB9XG4gICAgcmF3VGFzay50YXNrID0gdGFzaztcbiAgICByYXdBc2FwKHJhd1Rhc2spO1xufVxuXG4vLyBXZSB3cmFwIHRhc2tzIHdpdGggcmVjeWNsYWJsZSB0YXNrIG9iamVjdHMuICBBIHRhc2sgb2JqZWN0IGltcGxlbWVudHNcbi8vIGBjYWxsYCwganVzdCBsaWtlIGEgZnVuY3Rpb24uXG5mdW5jdGlvbiBSYXdUYXNrKCkge1xuICAgIHRoaXMudGFzayA9IG51bGw7XG59XG5cbi8vIFRoZSBzb2xlIHB1cnBvc2Ugb2Ygd3JhcHBpbmcgdGhlIHRhc2sgaXMgdG8gY2F0Y2ggdGhlIGV4Y2VwdGlvbiBhbmQgcmVjeWNsZVxuLy8gdGhlIHRhc2sgb2JqZWN0IGFmdGVyIGl0cyBzaW5nbGUgdXNlLlxuUmF3VGFzay5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICB0aGlzLnRhc2suY2FsbCgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChhc2FwLm9uZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaG9vayBleGlzdHMgcHVyZWx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLlxuICAgICAgICAgICAgLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0XG4gICAgICAgICAgICAvLyBkZXBlbmRzIG9uIGl0cyBleGlzdGVuY2UuXG4gICAgICAgICAgICBhc2FwLm9uZXJyb3IoZXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gYSB3ZWIgYnJvd3NlciwgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLiBIb3dldmVyLCB0byBhdm9pZFxuICAgICAgICAgICAgLy8gc2xvd2luZyBkb3duIHRoZSBxdWV1ZSBvZiBwZW5kaW5nIHRhc2tzLCB3ZSByZXRocm93IHRoZSBlcnJvciBpbiBhXG4gICAgICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB0dXJuLlxuICAgICAgICAgICAgcGVuZGluZ0Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHJlcXVlc3RFcnJvclRocm93KCk7XG4gICAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgICAgICBmcmVlVGFza3NbZnJlZVRhc2tzLmxlbmd0aF0gPSB0aGlzO1xuICAgIH1cbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IG1lYW5zIHBvc3NpYmxlIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGl0cyBvd24gdHVybiwgd2l0aFxuLy8gcHJpb3JpdHkgb3ZlciBvdGhlciBldmVudHMgaW5jbHVkaW5nIElPLCBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlZHJhd1xuLy8gZXZlbnRzIGluIGJyb3dzZXJzLlxuLy9cbi8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYSB0YXNrIHdpbGwgcGVybWFuZW50bHkgaW50ZXJydXB0IHRoZSBwcm9jZXNzaW5nIG9mXG4vLyBzdWJzZXF1ZW50IHRhc2tzLiBUaGUgaGlnaGVyIGxldmVsIGBhc2FwYCBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24gYnkgYSB0YXNrLCB0aGF0IHRoZSB0YXNrIHF1ZXVlIHdpbGwgY29udGludWUgZmx1c2hpbmcgYXNcbi8vIHNvb24gYXMgcG9zc2libGUsIGJ1dCBpZiB5b3UgdXNlIGByYXdBc2FwYCBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSB0b1xuLy8gZWl0aGVyIGVuc3VyZSB0aGF0IG5vIGV4Y2VwdGlvbnMgYXJlIHRocm93biBmcm9tIHlvdXIgdGFzaywgb3IgdG8gbWFudWFsbHlcbi8vIGNhbGwgYHJhd0FzYXAucmVxdWVzdEZsdXNoYCBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxubW9kdWxlLmV4cG9ydHMgPSByYXdBc2FwO1xuZnVuY3Rpb24gcmF3QXNhcCh0YXNrKSB7XG4gICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gRXF1aXZhbGVudCB0byBwdXNoLCBidXQgYXZvaWRzIGEgZnVuY3Rpb24gY2FsbC5cbiAgICBxdWV1ZVtxdWV1ZS5sZW5ndGhdID0gdGFzaztcbn1cblxudmFyIHF1ZXVlID0gW107XG4vLyBPbmNlIGEgZmx1c2ggaGFzIGJlZW4gcmVxdWVzdGVkLCBubyBmdXJ0aGVyIGNhbGxzIHRvIGByZXF1ZXN0Rmx1c2hgIGFyZVxuLy8gbmVjZXNzYXJ5IHVudGlsIHRoZSBuZXh0IGBmbHVzaGAgY29tcGxldGVzLlxudmFyIGZsdXNoaW5nID0gZmFsc2U7XG4vLyBgcmVxdWVzdEZsdXNoYCBpcyBhbiBpbXBsZW1lbnRhdGlvbi1zcGVjaWZpYyBtZXRob2QgdGhhdCBhdHRlbXB0cyB0byBraWNrXG4vLyBvZmYgYSBgZmx1c2hgIGV2ZW50IGFzIHF1aWNrbHkgYXMgcG9zc2libGUuIGBmbHVzaGAgd2lsbCBhdHRlbXB0IHRvIGV4aGF1c3Rcbi8vIHRoZSBldmVudCBxdWV1ZSBiZWZvcmUgeWllbGRpbmcgdG8gdGhlIGJyb3dzZXIncyBvd24gZXZlbnQgbG9vcC5cbnZhciByZXF1ZXN0Rmx1c2g7XG4vLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5leHQgdGFzayB0byBleGVjdXRlIGluIHRoZSB0YXNrIHF1ZXVlLiBUaGlzIGlzXG4vLyBwcmVzZXJ2ZWQgYmV0d2VlbiBjYWxscyB0byBgZmx1c2hgIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWQgaWZcbi8vIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLlxudmFyIGluZGV4ID0gMDtcbi8vIElmIGEgdGFzayBzY2hlZHVsZXMgYWRkaXRpb25hbCB0YXNrcyByZWN1cnNpdmVseSwgdGhlIHRhc2sgcXVldWUgY2FuIGdyb3dcbi8vIHVuYm91bmRlZC4gVG8gcHJldmVudCBtZW1vcnkgZXhoYXVzdGlvbiwgdGhlIHRhc2sgcXVldWUgd2lsbCBwZXJpb2RpY2FsbHlcbi8vIHRydW5jYXRlIGFscmVhZHktY29tcGxldGVkIHRhc2tzLlxudmFyIGNhcGFjaXR5ID0gMTAyNDtcblxuLy8gVGhlIGZsdXNoIGZ1bmN0aW9uIHByb2Nlc3NlcyBhbGwgdGFza3MgdGhhdCBoYXZlIGJlZW4gc2NoZWR1bGVkIHdpdGhcbi8vIGByYXdBc2FwYCB1bmxlc3MgYW5kIHVudGlsIG9uZSBvZiB0aG9zZSB0YXNrcyB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuLy8gSWYgYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24sIGBmbHVzaGAgZW5zdXJlcyB0aGF0IGl0cyBzdGF0ZSB3aWxsIHJlbWFpblxuLy8gY29uc2lzdGVudCBhbmQgd2lsbCByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYgd2hlbiBjYWxsZWQgYWdhaW4uXG4vLyBIb3dldmVyLCBgZmx1c2hgIGRvZXMgbm90IG1ha2UgYW55IGFycmFuZ2VtZW50cyB0byBiZSBjYWxsZWQgYWdhaW4gaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB3aGlsZSAoaW5kZXggPCBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAvLyBBZHZhbmNlIHRoZSBpbmRleCBiZWZvcmUgY2FsbGluZyB0aGUgdGFzay4gVGhpcyBlbnN1cmVzIHRoYXQgd2Ugd2lsbFxuICAgICAgICAvLyBiZWdpbiBmbHVzaGluZyBvbiB0aGUgbmV4dCB0YXNrIHRoZSB0YXNrIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHF1ZXVlW2N1cnJlbnRJbmRleF0uY2FsbCgpO1xuICAgICAgICAvLyBQcmV2ZW50IGxlYWtpbmcgbWVtb3J5IGZvciBsb25nIGNoYWlucyBvZiByZWN1cnNpdmUgY2FsbHMgdG8gYGFzYXBgLlxuICAgICAgICAvLyBJZiB3ZSBjYWxsIGBhc2FwYCB3aXRoaW4gdGFza3Mgc2NoZWR1bGVkIGJ5IGBhc2FwYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgLy8gZ3JvdywgYnV0IHRvIGF2b2lkIGFuIE8obikgd2FsayBmb3IgZXZlcnkgdGFzayB3ZSBleGVjdXRlLCB3ZSBkb24ndFxuICAgICAgICAvLyBzaGlmdCB0YXNrcyBvZmYgdGhlIHF1ZXVlIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICBpZiAoaW5kZXggPiBjYXBhY2l0eSkge1xuICAgICAgICAgICAgLy8gTWFudWFsbHkgc2hpZnQgYWxsIHZhbHVlcyBzdGFydGluZyBhdCB0aGUgaW5kZXggYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGUgcXVldWUuXG4gICAgICAgICAgICBmb3IgKHZhciBzY2FuID0gMCwgbmV3TGVuZ3RoID0gcXVldWUubGVuZ3RoIC0gaW5kZXg7IHNjYW4gPCBuZXdMZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIHF1ZXVlW3NjYW5dID0gcXVldWVbc2NhbiArIGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCAtPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGluZGV4ID0gMDtcbiAgICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCBpcyBpbXBsZW1lbnRlZCB1c2luZyBhIHN0cmF0ZWd5IGJhc2VkIG9uIGRhdGEgY29sbGVjdGVkIGZyb21cbi8vIGV2ZXJ5IGF2YWlsYWJsZSBTYXVjZUxhYnMgU2VsZW5pdW0gd2ViIGRyaXZlciB3b3JrZXIgYXQgdGltZSBvZiB3cml0aW5nLlxuLy8gaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vc3ByZWFkc2hlZXRzL2QvMW1HLTVVWUd1cDVxeEdkRU1Xa2hQNkJXQ3owNTNOVWIyRTFRb1VUVTE2dUEvZWRpdCNnaWQ9NzgzNzI0NTkzXG5cbi8vIFNhZmFyaSA2IGFuZCA2LjEgZm9yIGRlc2t0b3AsIGlQYWQsIGFuZCBpUGhvbmUgYXJlIHRoZSBvbmx5IGJyb3dzZXJzIHRoYXRcbi8vIGhhdmUgV2ViS2l0TXV0YXRpb25PYnNlcnZlciBidXQgbm90IHVuLXByZWZpeGVkIE11dGF0aW9uT2JzZXJ2ZXIuXG4vLyBNdXN0IHVzZSBgZ2xvYmFsYCBpbnN0ZWFkIG9mIGB3aW5kb3dgIHRvIHdvcmsgaW4gYm90aCBmcmFtZXMgYW5kIHdlYlxuLy8gd29ya2Vycy4gYGdsb2JhbGAgaXMgYSBwcm92aXNpb24gb2YgQnJvd3NlcmlmeSwgTXIsIE1ycywgb3IgTW9wLlxudmFyIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG5cbi8vIE11dGF0aW9uT2JzZXJ2ZXJzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGhhdmUgaGlnaCBwcmlvcml0eSBhbmQgd29ya1xuLy8gcmVsaWFibHkgZXZlcnl3aGVyZSB0aGV5IGFyZSBpbXBsZW1lbnRlZC5cbi8vIFRoZXkgYXJlIGltcGxlbWVudGVkIGluIGFsbCBtb2Rlcm4gYnJvd3NlcnMuXG4vL1xuLy8gLSBBbmRyb2lkIDQtNC4zXG4vLyAtIENocm9tZSAyNi0zNFxuLy8gLSBGaXJlZm94IDE0LTI5XG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDExXG4vLyAtIGlQYWQgU2FmYXJpIDYtNy4xXG4vLyAtIGlQaG9uZSBTYWZhcmkgNy03LjFcbi8vIC0gU2FmYXJpIDYtN1xuaWYgKHR5cGVvZiBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpO1xuXG4vLyBNZXNzYWdlQ2hhbm5lbHMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgZ2l2ZSBkaXJlY3QgYWNjZXNzIHRvIHRoZSBIVE1MXG4vLyB0YXNrIHF1ZXVlLCBhcmUgaW1wbGVtZW50ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAsIFNhZmFyaSA1LjAtMSwgYW5kIE9wZXJhXG4vLyAxMS0xMiwgYW5kIGluIHdlYiB3b3JrZXJzIGluIG1hbnkgZW5naW5lcy5cbi8vIEFsdGhvdWdoIG1lc3NhZ2UgY2hhbm5lbHMgeWllbGQgdG8gYW55IHF1ZXVlZCByZW5kZXJpbmcgYW5kIElPIHRhc2tzLCB0aGV5XG4vLyB3b3VsZCBiZSBiZXR0ZXIgdGhhbiBpbXBvc2luZyB0aGUgNG1zIGRlbGF5IG9mIHRpbWVycy5cbi8vIEhvd2V2ZXIsIHRoZXkgZG8gbm90IHdvcmsgcmVsaWFibHkgaW4gSW50ZXJuZXQgRXhwbG9yZXIgb3IgU2FmYXJpLlxuXG4vLyBJbnRlcm5ldCBFeHBsb3JlciAxMCBpcyB0aGUgb25seSBicm93c2VyIHRoYXQgaGFzIHNldEltbWVkaWF0ZSBidXQgZG9lc1xuLy8gbm90IGhhdmUgTXV0YXRpb25PYnNlcnZlcnMuXG4vLyBBbHRob3VnaCBzZXRJbW1lZGlhdGUgeWllbGRzIHRvIHRoZSBicm93c2VyJ3MgcmVuZGVyZXIsIGl0IHdvdWxkIGJlXG4vLyBwcmVmZXJyYWJsZSB0byBmYWxsaW5nIGJhY2sgdG8gc2V0VGltZW91dCBzaW5jZSBpdCBkb2VzIG5vdCBoYXZlXG4vLyB0aGUgbWluaW11bSA0bXMgcGVuYWx0eS5cbi8vIFVuZm9ydHVuYXRlbHkgdGhlcmUgYXBwZWFycyB0byBiZSBhIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCBNb2JpbGUgKGFuZFxuLy8gRGVza3RvcCB0byBhIGxlc3NlciBleHRlbnQpIHRoYXQgcmVuZGVycyBib3RoIHNldEltbWVkaWF0ZSBhbmRcbi8vIE1lc3NhZ2VDaGFubmVsIHVzZWxlc3MgZm9yIHRoZSBwdXJwb3NlcyBvZiBBU0FQLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2tyaXNrb3dhbC9xL2lzc3Vlcy8zOTZcblxuLy8gVGltZXJzIGFyZSBpbXBsZW1lbnRlZCB1bml2ZXJzYWxseS5cbi8vIFdlIGZhbGwgYmFjayB0byB0aW1lcnMgaW4gd29ya2VycyBpbiBtb3N0IGVuZ2luZXMsIGFuZCBpbiBmb3JlZ3JvdW5kXG4vLyBjb250ZXh0cyBpbiB0aGUgZm9sbG93aW5nIGJyb3dzZXJzLlxuLy8gSG93ZXZlciwgbm90ZSB0aGF0IGV2ZW4gdGhpcyBzaW1wbGUgY2FzZSByZXF1aXJlcyBudWFuY2VzIHRvIG9wZXJhdGUgaW4gYVxuLy8gYnJvYWQgc3BlY3RydW0gb2YgYnJvd3NlcnMuXG4vL1xuLy8gLSBGaXJlZm94IDMtMTNcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi05XG4vLyAtIGlQYWQgU2FmYXJpIDQuM1xuLy8gLSBMeW54IDIuOC43XG59IGVsc2Uge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihmbHVzaCk7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIHJlcXVlc3RzIHRoYXQgdGhlIGhpZ2ggcHJpb3JpdHkgZXZlbnQgcXVldWUgYmUgZmx1c2hlZCBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZS5cbi8vIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYW4gZXJyb3IgdGhyb3duIGluIGEgdGFzayBmcm9tIHN0YWxsaW5nIHRoZSBldmVudFxuLy8gcXVldWUgaWYgdGhlIGV4Y2VwdGlvbiBoYW5kbGVkIGJ5IE5vZGUuanPigJlzXG4vLyBgcHJvY2Vzcy5vbihcInVuY2F1Z2h0RXhjZXB0aW9uXCIpYCBvciBieSBhIGRvbWFpbi5cbnJhd0FzYXAucmVxdWVzdEZsdXNoID0gcmVxdWVzdEZsdXNoO1xuXG4vLyBUbyByZXF1ZXN0IGEgaGlnaCBwcmlvcml0eSBldmVudCwgd2UgaW5kdWNlIGEgbXV0YXRpb24gb2JzZXJ2ZXIgYnkgdG9nZ2xpbmdcbi8vIHRoZSB0ZXh0IG9mIGEgdGV4dCBub2RlIGJldHdlZW4gXCIxXCIgYW5kIFwiLTFcIi5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRvZ2dsZSA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyKGNhbGxiYWNrKTtcbiAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO1xuICAgIG9ic2VydmVyLm9ic2VydmUobm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIHRvZ2dsZSA9IC10b2dnbGU7XG4gICAgICAgIG5vZGUuZGF0YSA9IHRvZ2dsZTtcbiAgICB9O1xufVxuXG4vLyBUaGUgbWVzc2FnZSBjaGFubmVsIHRlY2huaXF1ZSB3YXMgZGlzY292ZXJlZCBieSBNYWx0ZSBVYmwgYW5kIHdhcyB0aGVcbi8vIG9yaWdpbmFsIGZvdW5kYXRpb24gZm9yIHRoaXMgbGlicmFyeS5cbi8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG5cbi8vIFNhZmFyaSA2LjAuNSAoYXQgbGVhc3QpIGludGVybWl0dGVudGx5IGZhaWxzIHRvIGNyZWF0ZSBtZXNzYWdlIHBvcnRzIG9uIGFcbi8vIHBhZ2UncyBmaXJzdCBsb2FkLiBUaGFua2Z1bGx5LCB0aGlzIHZlcnNpb24gb2YgU2FmYXJpIHN1cHBvcnRzXG4vLyBNdXRhdGlvbk9ic2VydmVycywgc28gd2UgZG9uJ3QgbmVlZCB0byBmYWxsIGJhY2sgaW4gdGhhdCBjYXNlLlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTWVzc2FnZUNoYW5uZWwoY2FsbGJhY2spIHtcbi8vICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuLy8gICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gY2FsbGJhY2s7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIEZvciByZWFzb25zIGV4cGxhaW5lZCBhYm92ZSwgd2UgYXJlIGFsc28gdW5hYmxlIHRvIHVzZSBgc2V0SW1tZWRpYXRlYFxuLy8gdW5kZXIgYW55IGNpcmN1bXN0YW5jZXMuXG4vLyBFdmVuIGlmIHdlIHdlcmUsIHRoZXJlIGlzIGFub3RoZXIgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuLy8gSXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gYXNzaWduIGBzZXRJbW1lZGlhdGVgIHRvIGByZXF1ZXN0Rmx1c2hgIGJlY2F1c2Vcbi8vIGBzZXRJbW1lZGlhdGVgIG11c3QgYmUgY2FsbGVkICpieSBuYW1lKiBhbmQgdGhlcmVmb3JlIG11c3QgYmUgd3JhcHBlZCBpbiBhXG4vLyBjbG9zdXJlLlxuLy8gTmV2ZXIgZm9yZ2V0LlxuXG4vLyBmdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tU2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuLy8gICAgICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuLy8gICAgIH07XG4vLyB9XG5cbi8vIFNhZmFyaSA2LjAgaGFzIGEgcHJvYmxlbSB3aGVyZSB0aW1lcnMgd2lsbCBnZXQgbG9zdCB3aGlsZSB0aGUgdXNlciBpc1xuLy8gc2Nyb2xsaW5nLiBUaGlzIHByb2JsZW0gZG9lcyBub3QgaW1wYWN0IEFTQVAgYmVjYXVzZSBTYWZhcmkgNi4wIHN1cHBvcnRzXG4vLyBtdXRhdGlvbiBvYnNlcnZlcnMsIHNvIHRoYXQgaW1wbGVtZW50YXRpb24gaXMgdXNlZCBpbnN0ZWFkLlxuLy8gSG93ZXZlciwgaWYgd2UgZXZlciBlbGVjdCB0byB1c2UgdGltZXJzIGluIFNhZmFyaSwgdGhlIHByZXZhbGVudCB3b3JrLWFyb3VuZFxuLy8gaXMgdG8gYWRkIGEgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIHRoYXQgY2FsbHMgZm9yIGEgZmx1c2guXG5cbi8vIGBzZXRUaW1lb3V0YCBkb2VzIG5vdCBjYWxsIHRoZSBwYXNzZWQgY2FsbGJhY2sgaWYgdGhlIGRlbGF5IGlzIGxlc3MgdGhhblxuLy8gYXBwcm94aW1hdGVseSA3IGluIHdlYiB3b3JrZXJzIGluIEZpcmVmb3ggOCB0aHJvdWdoIDE4LCBhbmQgc29tZXRpbWVzIG5vdFxuLy8gZXZlbiB0aGVuLlxuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4gICAgICAgIC8vIFdlIGRpc3BhdGNoIGEgdGltZW91dCB3aXRoIGEgc3BlY2lmaWVkIGRlbGF5IG9mIDAgZm9yIGVuZ2luZXMgdGhhdFxuICAgICAgICAvLyBjYW4gcmVsaWFibHkgYWNjb21tb2RhdGUgdGhhdCByZXF1ZXN0LiBUaGlzIHdpbGwgdXN1YWxseSBiZSBzbmFwcGVkXG4gICAgICAgIC8vIHRvIGEgNCBtaWxpc2Vjb25kIGRlbGF5LCBidXQgb25jZSB3ZSdyZSBmbHVzaGluZywgdGhlcmUncyBubyBkZWxheVxuICAgICAgICAvLyBiZXR3ZWVuIGV2ZW50cy5cbiAgICAgICAgdmFyIHRpbWVvdXRIYW5kbGUgPSBzZXRUaW1lb3V0KGhhbmRsZVRpbWVyLCAwKTtcbiAgICAgICAgLy8gSG93ZXZlciwgc2luY2UgdGhpcyB0aW1lciBnZXRzIGZyZXF1ZW50bHkgZHJvcHBlZCBpbiBGaXJlZm94XG4gICAgICAgIC8vIHdvcmtlcnMsIHdlIGVubGlzdCBhbiBpbnRlcnZhbCBoYW5kbGUgdGhhdCB3aWxsIHRyeSB0byBmaXJlXG4gICAgICAgIC8vIGFuIGV2ZW50IDIwIHRpbWVzIHBlciBzZWNvbmQgdW50aWwgaXQgc3VjY2VlZHMuXG4gICAgICAgIHZhciBpbnRlcnZhbEhhbmRsZSA9IHNldEludGVydmFsKGhhbmRsZVRpbWVyLCA1MCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlVGltZXIoKSB7XG4gICAgICAgICAgICAvLyBXaGljaGV2ZXIgdGltZXIgc3VjY2VlZHMgd2lsbCBjYW5jZWwgYm90aCB0aW1lcnMgYW5kXG4gICAgICAgICAgICAvLyBleGVjdXRlIHRoZSBjYWxsYmFjay5cbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbi8vIFRoaXMgaXMgZm9yIGBhc2FwLmpzYCBvbmx5LlxuLy8gSXRzIG5hbWUgd2lsbCBiZSBwZXJpb2RpY2FsbHkgcmFuZG9taXplZCB0byBicmVhayBhbnkgY29kZSB0aGF0IGRlcGVuZHMgb25cbi8vIGl0cyBleGlzdGVuY2UuXG5yYXdBc2FwLm1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lciA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcjtcblxuLy8gQVNBUCB3YXMgb3JpZ2luYWxseSBhIG5leHRUaWNrIHNoaW0gaW5jbHVkZWQgaW4gUS4gVGhpcyB3YXMgZmFjdG9yZWQgb3V0XG4vLyBpbnRvIHRoaXMgQVNBUCBwYWNrYWdlLiBJdCB3YXMgbGF0ZXIgYWRhcHRlZCB0byBSU1ZQIHdoaWNoIG1hZGUgZnVydGhlclxuLy8gYW1lbmRtZW50cy4gVGhlc2UgZGVjaXNpb25zLCBwYXJ0aWN1bGFybHkgdG8gbWFyZ2luYWxpemUgTWVzc2FnZUNoYW5uZWwgYW5kXG4vLyB0byBjYXB0dXJlIHRoZSBNdXRhdGlvbk9ic2VydmVyIGltcGxlbWVudGF0aW9uIGluIGEgY2xvc3VyZSwgd2VyZSBpbnRlZ3JhdGVkXG4vLyBiYWNrIGludG8gQVNBUCBwcm9wZXIuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGlsZGVpby9yc3ZwLmpzL2Jsb2IvY2RkZjcyMzI1NDZhOWNmODU4NTI0Yjc1Y2RlNmY5ZWRmNzI2MjBhNy9saWIvcnN2cC9hc2FwLmpzXG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIGRvbWFpbjsgLy8gVGhlIGRvbWFpbiBtb2R1bGUgaXMgZXhlY3V0ZWQgb24gZGVtYW5kXG52YXIgaGFzU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiO1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4vLyBwcmlvcml0eSBvdmVyIG90aGVyIGV2ZW50cyBpbmNsdWRpbmcgbmV0d29yayBJTyBldmVudHMgaW4gTm9kZS5qcy5cbi8vXG4vLyBBbiBleGNlcHRpb24gdGhyb3duIGJ5IGEgdGFzayB3aWxsIHBlcm1hbmVudGx5IGludGVycnVwdCB0aGUgcHJvY2Vzc2luZyBvZlxuLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duIGJ5IGEgdGFzaywgdGhhdCB0aGUgdGFzayBxdWV1ZSB3aWxsIGNvbnRpbnVlIGZsdXNoaW5nIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLCBidXQgaWYgeW91IHVzZSBgcmF3QXNhcGAgZGlyZWN0bHksIHlvdSBhcmUgcmVzcG9uc2libGUgdG9cbi8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4vLyBjYWxsIGByYXdBc2FwLnJlcXVlc3RGbHVzaGAgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbm1vZHVsZS5leHBvcnRzID0gcmF3QXNhcDtcbmZ1bmN0aW9uIHJhd0FzYXAodGFzaykge1xuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCgpO1xuICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIC8vIEF2b2lkcyBhIGZ1bmN0aW9uIGNhbGxcbiAgICBxdWV1ZVtxdWV1ZS5sZW5ndGhdID0gdGFzaztcbn1cblxudmFyIHF1ZXVlID0gW107XG4vLyBPbmNlIGEgZmx1c2ggaGFzIGJlZW4gcmVxdWVzdGVkLCBubyBmdXJ0aGVyIGNhbGxzIHRvIGByZXF1ZXN0Rmx1c2hgIGFyZVxuLy8gbmVjZXNzYXJ5IHVudGlsIHRoZSBuZXh0IGBmbHVzaGAgY29tcGxldGVzLlxudmFyIGZsdXNoaW5nID0gZmFsc2U7XG4vLyBUaGUgcG9zaXRpb24gb2YgdGhlIG5leHQgdGFzayB0byBleGVjdXRlIGluIHRoZSB0YXNrIHF1ZXVlLiBUaGlzIGlzXG4vLyBwcmVzZXJ2ZWQgYmV0d2VlbiBjYWxscyB0byBgZmx1c2hgIHNvIHRoYXQgaXQgY2FuIGJlIHJlc3VtZWQgaWZcbi8vIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLlxudmFyIGluZGV4ID0gMDtcbi8vIElmIGEgdGFzayBzY2hlZHVsZXMgYWRkaXRpb25hbCB0YXNrcyByZWN1cnNpdmVseSwgdGhlIHRhc2sgcXVldWUgY2FuIGdyb3dcbi8vIHVuYm91bmRlZC4gVG8gcHJldmVudCBtZW1vcnkgZXhjYXVzdGlvbiwgdGhlIHRhc2sgcXVldWUgd2lsbCBwZXJpb2RpY2FsbHlcbi8vIHRydW5jYXRlIGFscmVhZHktY29tcGxldGVkIHRhc2tzLlxudmFyIGNhcGFjaXR5ID0gMTAyNDtcblxuLy8gVGhlIGZsdXNoIGZ1bmN0aW9uIHByb2Nlc3NlcyBhbGwgdGFza3MgdGhhdCBoYXZlIGJlZW4gc2NoZWR1bGVkIHdpdGhcbi8vIGByYXdBc2FwYCB1bmxlc3MgYW5kIHVudGlsIG9uZSBvZiB0aG9zZSB0YXNrcyB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuLy8gSWYgYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24sIGBmbHVzaGAgZW5zdXJlcyB0aGF0IGl0cyBzdGF0ZSB3aWxsIHJlbWFpblxuLy8gY29uc2lzdGVudCBhbmQgd2lsbCByZXN1bWUgd2hlcmUgaXQgbGVmdCBvZmYgd2hlbiBjYWxsZWQgYWdhaW4uXG4vLyBIb3dldmVyLCBgZmx1c2hgIGRvZXMgbm90IG1ha2UgYW55IGFycmFuZ2VtZW50cyB0byBiZSBjYWxsZWQgYWdhaW4gaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICB3aGlsZSAoaW5kZXggPCBxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRJbmRleCA9IGluZGV4O1xuICAgICAgICAvLyBBZHZhbmNlIHRoZSBpbmRleCBiZWZvcmUgY2FsbGluZyB0aGUgdGFzay4gVGhpcyBlbnN1cmVzIHRoYXQgd2Ugd2lsbFxuICAgICAgICAvLyBiZWdpbiBmbHVzaGluZyBvbiB0aGUgbmV4dCB0YXNrIHRoZSB0YXNrIHRocm93cyBhbiBlcnJvci5cbiAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgIHF1ZXVlW2N1cnJlbnRJbmRleF0uY2FsbCgpO1xuICAgICAgICAvLyBQcmV2ZW50IGxlYWtpbmcgbWVtb3J5IGZvciBsb25nIGNoYWlucyBvZiByZWN1cnNpdmUgY2FsbHMgdG8gYGFzYXBgLlxuICAgICAgICAvLyBJZiB3ZSBjYWxsIGBhc2FwYCB3aXRoaW4gdGFza3Mgc2NoZWR1bGVkIGJ5IGBhc2FwYCwgdGhlIHF1ZXVlIHdpbGxcbiAgICAgICAgLy8gZ3JvdywgYnV0IHRvIGF2b2lkIGFuIE8obikgd2FsayBmb3IgZXZlcnkgdGFzayB3ZSBleGVjdXRlLCB3ZSBkb24ndFxuICAgICAgICAvLyBzaGlmdCB0YXNrcyBvZmYgdGhlIHF1ZXVlIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSBwZXJpb2RpY2FsbHkgc2hpZnQgMTAyNCB0YXNrcyBvZmYgdGhlIHF1ZXVlLlxuICAgICAgICBpZiAoaW5kZXggPiBjYXBhY2l0eSkge1xuICAgICAgICAgICAgLy8gTWFudWFsbHkgc2hpZnQgYWxsIHZhbHVlcyBzdGFydGluZyBhdCB0aGUgaW5kZXggYmFjayB0byB0aGVcbiAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvZiB0aGUgcXVldWUuXG4gICAgICAgICAgICBmb3IgKHZhciBzY2FuID0gMCwgbmV3TGVuZ3RoID0gcXVldWUubGVuZ3RoIC0gaW5kZXg7IHNjYW4gPCBuZXdMZW5ndGg7IHNjYW4rKykge1xuICAgICAgICAgICAgICAgIHF1ZXVlW3NjYW5dID0gcXVldWVbc2NhbiArIGluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHF1ZXVlLmxlbmd0aCAtPSBpbmRleDtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5sZW5ndGggPSAwO1xuICAgIGluZGV4ID0gMDtcbiAgICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG5yYXdBc2FwLnJlcXVlc3RGbHVzaCA9IHJlcXVlc3RGbHVzaDtcbmZ1bmN0aW9uIHJlcXVlc3RGbHVzaCgpIHtcbiAgICAvLyBFbnN1cmUgZmx1c2hpbmcgaXMgbm90IGJvdW5kIHRvIGFueSBkb21haW4uXG4gICAgLy8gSXQgaXMgbm90IHN1ZmZpY2llbnQgdG8gZXhpdCB0aGUgZG9tYWluLCBiZWNhdXNlIGRvbWFpbnMgZXhpc3Qgb24gYSBzdGFjay5cbiAgICAvLyBUbyBleGVjdXRlIGNvZGUgb3V0c2lkZSBvZiBhbnkgZG9tYWluLCB0aGUgZm9sbG93aW5nIGRhbmNlIGlzIG5lY2Vzc2FyeS5cbiAgICB2YXIgcGFyZW50RG9tYWluID0gcHJvY2Vzcy5kb21haW47XG4gICAgaWYgKHBhcmVudERvbWFpbikge1xuICAgICAgICBpZiAoIWRvbWFpbikge1xuICAgICAgICAgICAgLy8gTGF6eSBleGVjdXRlIHRoZSBkb21haW4gbW9kdWxlLlxuICAgICAgICAgICAgLy8gT25seSBlbXBsb3llZCBpZiB0aGUgdXNlciBlbGVjdHMgdG8gdXNlIGRvbWFpbnMuXG4gICAgICAgICAgICBkb21haW4gPSByZXF1aXJlKFwiZG9tYWluXCIpO1xuICAgICAgICB9XG4gICAgICAgIGRvbWFpbi5hY3RpdmUgPSBwcm9jZXNzLmRvbWFpbiA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gYHNldEltbWVkaWF0ZWAgaXMgc2xvd2VyIHRoYXQgYHByb2Nlc3MubmV4dFRpY2tgLCBidXQgYHByb2Nlc3MubmV4dFRpY2tgXG4gICAgLy8gY2Fubm90IGhhbmRsZSByZWN1cnNpb24uXG4gICAgLy8gYHJlcXVlc3RGbHVzaGAgd2lsbCBvbmx5IGJlIGNhbGxlZCByZWN1cnNpdmVseSBmcm9tIGBhc2FwLmpzYCwgdG8gcmVzdW1lXG4gICAgLy8gZmx1c2hpbmcgYWZ0ZXIgYW4gZXJyb3IgaXMgdGhyb3duIGludG8gYSBkb21haW4uXG4gICAgLy8gQ29udmVuaWVudGx5LCBgc2V0SW1tZWRpYXRlYCB3YXMgaW50cm9kdWNlZCBpbiB0aGUgc2FtZSB2ZXJzaW9uXG4gICAgLy8gYHByb2Nlc3MubmV4dFRpY2tgIHN0YXJ0ZWQgdGhyb3dpbmcgcmVjdXJzaW9uIGVycm9ycy5cbiAgICBpZiAoZmx1c2hpbmcgJiYgaGFzU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudERvbWFpbikge1xuICAgICAgICBkb21haW4uYWN0aXZlID0gcHJvY2Vzcy5kb21haW4gPSBwYXJlbnREb21haW47XG4gICAgfVxufVxuIiwidmFyIENsb3VkID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZCcpXG4gICAgLmluamVjdChcbiAgICAgIHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvZGF0YWNsb3VkJyksXG4gICAgICByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2Nsb3VkL2F1dGhlbnRpY2F0ZScpXG4gICAgKSxcbiAgVmFsdWUgPSByZXF1aXJlKCd2aWdvdXItanMvdmFsdWUnKSxcbiAgRGF0YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9kYXRhJyksXG4gIHV0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbCcpLFxuICBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJyksXG4gIHVhID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvdWEnKSxcbiAgcmFmID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicpXG5cbi8vIHZhciBzZW12ZXIgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9zZW12ZXInKVxuXG5yZXF1aXJlKCd2aWdvdXItanMvdmFsdWUvZmxhZ3MvcHJvY2VzcycpIC8vIG11c3RiZWNvbWUgaW5qZWN0YWJsZSBvbiBvYmplY3QgKCBhbGwgdGhlc2UgZXh0ZW5zaW9uIHNob3VsZCBiZSBsb2NhdGVkIHNlcGVyYXRlbHkgKVxuXG5mdW5jdGlvbiBzZXRDbGllbnRJbmZvIChjbG91ZCwgYmFzZSkge1xuICAvLyB0b2RvOiBtb3ZlIGNsaWVudCB0byBjbG91ZFxuICBcbiAgdmFyIG9sZGNsaWVudCA9IGNsb3VkLmNsaWVudC5mcm9tLnJhd1xuICB2YXIgb2JqID0gb2xkY2xpZW50IFxuICAgID8geyBcbiAgICAgICAgdGl0bGU6IG9sZGNsaWVudC50aXRsZSxcbiAgICAgICAgZGV2aWNlOiBvbGRjbGllbnQuZGV2aWNlLFxuICAgICAgICBpbmZvOiBvbGRjbGllbnQuaW5mb1xuICAgICAgfVxuICAgIDoge31cbiAgZmlsdGVyRW1wdHkob2JqKVxuXG4gIHZhciBjbGllbnQgPSBjbG91ZC5kYXRhLmdldChbJ2NsaWVudHMnLCBjbG91ZC5jbGllbnRpZF0pLFxuICAgIHRpdGxlLCBkZXZpY2UsIGNhc3RJZFxuXG4gIHZhciBpbmZvID0gY2FzZXMudG91Y2ggXG4gICAgPyB1YS5kZXZpY2UgKyAnICcgKyBcbiAgICAgICggdWEucGxhdGZvcm0gPT09ICdpb3MnID8gJ2lPUycgOiB1YS5wbGF0Zm9ybSApICtcbiAgICAgICggdWEudmVyc2lvbiA/ICcgJyArIHVhLnZlcnNpb24gOiAnJyApXG4gICAgOiB1YS5wbGF0Zm9ybSArICcgJyArIHVhLmJyb3dzZXIgKyAnICcgKyB1YS52ZXJzaW9uXG5cbiAgaWYgKGNhc2VzLiRpc0lvcykge1xuICAgIHRpdGxlID0gdWEuZGV2aWNlID09PSAncGhvbmUnID8gJ2lwaG9uZScgOiAnaXBhZCdcbiAgICBkZXZpY2UgPSB1YS5kZXZpY2VcbiAgfSBlbHNlIHtcbiAgICBpZiAodWEucGxhdGZvcm0gPT09ICdhcHBsZXR2Jykge1xuICAgICAgdGl0bGUgPSAnQXBwbGUgVFYnXG4gICAgICBkZXZpY2UgPSAnY2FzdCdcbiAgICB9IGVsc2UgaWYgKGNhc2VzLiRpc0Nocm9tZWNhc3QpIHtcbiAgICAgIHRpdGxlID0gJ0Nocm9tZWNhc3QnXG4gICAgICBkZXZpY2UgPSAnY2FzdCdcbiAgICAgIGNhc3RJZCA9IHdpbmRvdy5zZXNzaW9uSWRcbiAgICB9IGVsc2Uge1xuICAgICAgZGV2aWNlID0gdWEuZGV2aWNlXG4gICAgICB0aXRsZSA9IGNhc2VzLiRpc0Rlc2t0b3AgPyB1YS5wbGF0Zm9ybSA6IHVhLnBsYXRmb3JtICsgJyAnICsgZGV2aWNlXG4gICAgfVxuICB9XG5cbiAgdXRpbC5tZXJnZSggb2JqLCB7XG4gICAgdGl0bGU6IHRpdGxlLFxuICAgIGRldmljZTogZGV2aWNlLFxuICAgIGluZm86IGluZm9cbiAgfSwgZmFsc2UsIGZhbHNlIClcblxuICBpZiAoY2FzdElkKSB7XG4gICAgb2JqLmNhc3RJZCA9IGNhc3RJZCB8fCBmYWxzZVxuICB9XG5cbiAgLy8gY2xpZW50Lm1lcmdlKG9iaiwgZmFsc2UsIGZhbHNlKVxuICBjbGllbnQudmFsID0gb2JqXG4gIGNsb3VkLmNsaWVudC52YWwgPSBjbGllbnRcblxuICAvLyBERUJVRyBMT0dTOiBcbiAgLy8gY2xvdWQuY2xpZW50Lm9uKGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20pe1xuICAvLyAgIC8vIGNvbnNvbGUubG9nKCdcXG5cXG5cXG5cXG51cGRhdGUga2Vua2VyJywgdmFsLCBmcm9tKVxuICAvLyAgIHZhciBvcmlnaW4gPSBmcm9tIHx8IHRoaXMuX3VwZGF0ZU9yaWdpblxuICAvLyAgIGlmKHZhbCAmJiB2YWwudG9rZW4gfHwgKG9yaWdpbiAmJiBvcmlnaW4uX25hbWUgPT09ICd0b2tlbicpKSB7XG4gIC8vICAgICBjb25zb2xlLmVycm9yKCdUT0tFTlNFVFRPS0VOU0VUVE9LRU5TRVQnLCB2YWwgJiYgKHZhbC50b2tlbiB8fCB2YWwpIClcbiAgLy8gICB9XG4gIC8vIH0pXG5cbiAgLy8gdXNlci5jbGllbnRVc2VyVG9rZW4gPSB1c2VyLmNsaWVudC5mcm9tLmdldCgndXNlclRva2VuJykgZGV6ZSBpcyBkdWlkZWxpamsgZnVja2VkIHVwIGFuZCBoYXMgdG8gYmUgZml4ZWRcbn1cblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZCggcmVxdWlyZSgnLi92YWx1ZXMnKSwgZnVuY3Rpb24gKGJhc2UpIHtcbiAgdmFyIF9jbG91ZCA9IG5ldyBDbG91ZChuZXcgVmFsdWUoKSlcbiAgICAsIF9maXJzdCAvLz0gdHJ1ZVxuICBcbiAgY2FzZXMuJGlzQ29ubmVjdGVkID0gbmV3IFZhbHVlKCBfY2xvdWQuY29ubmVjdGVkIClcblxuICAvLyB0b2RvOiBtb3ZlIHRvIGNsb3VkXG4gIF9jbG91ZC5jbGllbnQgPSBuZXcgVmFsdWUoKVxuXG4gIF9jbG91ZC5vbmNlKCd3ZWxjb21lJywgZnVuY3Rpb24gKGlkKSB7XG4gICAgc2V0Q2xpZW50SW5mbyhfY2xvdWQsIGJhc2UpXG4gIH0pXG5cbiAgLy8gX2Nsb3VkLm9uKCdyZWNvbm5lY3QnLClcbiAgLy8gY29uc29sZS5lcnJvcignPj4+IGFkZGluZyByZWNvbm5lY3QgbGlzdGVuZXInKVxuICBfY2xvdWQub24oJ3JlY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCc+Pj4+IHJlY29ubmVjdCBzZXQgdXAgcmVzZXQgY2xpZW50IGluZm8hJywgX2Nsb3VkLmNsaWVudC5mcm9tLnJhdylcbiAgICB2YXIgc2V0T2JqID0ge31cbiAgICBfY2xvdWQuY2xpZW50LmZyb20uZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBpZihpICE9PSAna2V5JyAmJiBpICE9PSAndHlwZScgJiYgaSAhPT0gJ2lwJyl7XG4gICAgICAgIHNldE9ialtpXSA9IHRoaXMuX3ZhbFxuICAgICAgfVxuICAgIH0pXG4gICAgX2Nsb3VkLmNsaWVudC5mcm9tLm9uKCdyZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGlmKE9iamVjdC5rZXlzKHNldE9iaikubGVuZ3RoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZXNldCBkYXQgY2xpZW50IGluZm8nLCBzZXRPYmopXG4gICAgICAgIF9jbG91ZC5kYXRhLmNsaWVudHMuc2V0KF9jbG91ZC5jbGllbnRpZCwgc2V0T2JqKVxuICAgICAgfVxuICAgIH0pXG4gIH0pXG5cbiAgYmFzZS5kZWZpbmUoe1xuICAgIGNsb3VkOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9jbG91ZFxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBpZiAodXRpbC5pc09iaih2YWwpKSB7XG4gICAgICAgICAgaWYgKHZhbC5mYXN0TG9naW4pIHtcbiAgICAgICAgICAgIF9jbG91ZC5mYXN0TG9naW4udmFsID0gdHJ1ZVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwuYXBpKSB7XG4gICAgICAgICAgICBfY2xvdWQuYXBpLnZhbCA9IHZhbC5hcGlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsLnVybCkge1xuICAgICAgICAgICAgX2Nsb3VkLnVybC52YWwgPSB2YWwudXJsXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9jbG91ZC51cmwudmFsID0gdmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgdmFyIF92ZXJzaW9uID0gbmV3IERhdGEoIF9jbG91ZC5kYXRhLmdldCgnYXBwJyksIHsgc3Vic2NyaXB0aW9uOiB7ICQ6dHJ1ZSB9IH0gKVxuXG4gIC8vc2VtdmFyIC0tIEFQUCBWRVJTSU9OIERPRVMgTk9UIFdPUkshXG4gIGJhc2UudmVyc2lvbkRhdGEgPSBuZXcgVmFsdWUoe1xuICAgIHZhbDogX3ZlcnNpb24sXG4gICAgZGVmZXI6IGZ1bmN0aW9uKHVwZGF0ZSwgYXJncykge1xuICAgICAgdmFyIGRvVXBkYXRlXG4gICAgICB2YXIgdFxuICAgICAgaWYodGhpcy5mcm9tLnZlcnNpb24pIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hleSBoZXkgaGV5JylcbiAgICAgICAgaWYoICF3aW5kb3cucGFja2FnZSApIFxuICAgICAgICB7XG4gICAgICAgICAgY29uc29sZS5lcnJvciggJ25vIHdpbmRvdyBwYWNrYWdlJywgd2luZG93LnBhY2thZ2UgKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3dmVyc2lvbiA9IHRoaXMuZnJvbS52ZXJzaW9uLnZhbFxuICAgICAgICAgICAgLCBvbGR2ZXJzaW9uID0gd2luZG93LnBhY2thZ2UudmVyc2lvblxuXG4gICAgICAgICAgaWYobmV3dmVyc2lvbiAmJiBvbGR2ZXJzaW9uKSB7XG4gICAgICAgICAgICBuZXd2ZXJzaW9uID0gbmV3dmVyc2lvbi5zcGxpdCgnLicpXG4gICAgICAgICAgICBvbGR2ZXJzaW9uID0gb2xkdmVyc2lvbi5zcGxpdCgnLicpXG4gICAgICAgICAgICBuZXd2ZXJzaW9uID0gTnVtYmVyKG5ld3ZlcnNpb25bMV0pXG4gICAgICAgICAgICBvbGR2ZXJzaW9uID0gTnVtYmVyKChvbGR2ZXJzaW9uWzFdfHwwKSlcbiAgICAgICAgICAgIGlmKCBuZXd2ZXJzaW9uID4gb2xkdmVyc2lvbiApIHtcbiAgICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICAgIHdpbmRvdy5wYWNrYWdlLnZlcnNpb24gPSB0aGlzLmZyb20udmVyc2lvbi52YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICB1cGRhdGUoIGRvVXBkYXRlID8gdm9pZCAwIDogdHJ1ZSApXG4gICAgfVxuICB9KVxuXG59KVxuXG5cbmZ1bmN0aW9uIGZpbHRlckVtcHR5KG9iaikge1xuICBmb3IodmFyIGYgaW4gb2JqKSB7XG4gICAgaWYob2JqW2ZdID09PSB2b2lkIDApIHtcbiAgICAgIGRlbGV0ZSBvYmpbZl1cbiAgICB9XG4gIH1cbn1cbiIsInZhciBWYWx1ZSA9IHJlcXVpcmUoJy4uL3ZhbHVlJylcbiAgLCBDbG91ZERhdGEgPSByZXF1aXJlKCAnLi4vYnJvd3Nlci9uZXR3b3JrL2Nsb3VkL2RhdGEnIClcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgdk9iaiA9IHJlcXVpcmUoJy4uL29iamVjdCcpXG5cblxudXRpbC5kZWZpbmVcbiggQ2xvdWREYXRhXG4sICdfY29udGVudFBhdGgnXG4sIHsgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwID0gdGhpcy5fcGF0aFxuICAgICAgZm9yKHZhciBpIGluIHAgKSB7XG4gICAgICAgIGlmKCBwW2ldID09PSAnc2hvd3MnIHx8IHBbaV0gPT09ICdjaGFubmVscycgKSB7XG4gICAgICAgICAgcmV0dXJuIHAuc2xpY2UoIGkgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUuZXJyb3IoJ19jb250ZW50UGF0aCB1c2VkIG9uIG5vbi1jb250ZW50IGRhdGEnLCB0aGlzLCBwKVxuICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdfY29udGVudFBhdGggdXNlZCBvbiBub24tY29udGVudCBkYXRhJylcbiAgICAgIC8vIHJldHVybiB0aGlzLl9wYXRoLnNsaWNlKCBiYXNlLmluc3RhbmNlc1swXS5kYXRhLmZyb20uX3BhdGgubGVuZ3RoIClcbiAgICB9XG4gIH1cbilcblxudXRpbC5kZWZpbmUoXG4gIHZPYmpcbiwgJ19jb250ZW50VHlwZSdcbiwgeyBnZXQ6ZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZnJvbSA9IHRoaXMuZnJvbVxuICAgICAgaWYoIGZyb20uY2xvdWQgJiYgZnJvbS5fcGFyZW50ICkgcmV0dXJuIGZyb20uX3BhcmVudC5fbmFtZVxuICAgIH1cbiAgfVxuKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKCBcbiAgcmVxdWlyZSgnLi92YWx1ZXMnKVxuLCByZXF1aXJlKCcuL2Nsb3VkJylcbiwgZnVuY3Rpb24oIGFwcCApIHtcbiAgICB2YXIgY29udGVudCA9IGFwcC5jb250ZW50ID0gbmV3IFZhbHVlKHt9KVxuICAgIC8vIHZhciBnZXQgPSBWYWx1ZS5wcm90b3R5cGUuZ2V0XG4gICAgdXRpbC5kZWZpbmUoY29udGVudCwgJ2dldCcsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmKCB0aGlzLl92YWwgJiYgdGhpcy5fdmFsLmNsb3VkICkgeyBcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsLmdldC5hcHBseSh0aGlzLl92YWwsIGFyZ3VtZW50cykgXG4gICAgICAgIH0gZWxzZSB7IFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ2FwcC5jb250ZW50ICwgZG9udCBoYXZlIGNsb3VkIGRhdGEhJykgXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICBhcHAucmVnaW9uLm9uKG9uQ2hhbmdlKVxuICAgIGFwcC5sYW5ndWFnZS5vbihvbkNoYW5nZSlcblxuICAgIG9uQ2hhbmdlKClcblxuICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCl7XG4gICAgICB2YXIgcmVnaW9uID0gYXBwLnJlZ2lvbi52YWxcbiAgICAgICAgLCBsYW5ndWFnZSA9IGFwcC5sYW5ndWFnZS52YWxcblxuICAgICAgLy9UT0RPOm1ha2UgdGhpcyBjb25maWd1cmFibGUgaW4gdGhlIGFwcFxuICAgICAgaWYobGFuZ3VhZ2U9PT0naXQnKSB7XG4gICAgICAgIGxhbmd1YWdlID0gJ2VuJ1xuICAgICAgfVxuXG4gICAgICBpZihyZWdpb24gJiYgbGFuZ3VhZ2Upe1xuICAgICAgICAvL1RPRE86IG1ha2UgbXR2RGF0YSBjb25maWd1cmFibGVcbiAgICAgICAgLy8gY29udGVudC52YWwgPSBhcHAuY2xvdWQuZGF0YS5nZXQoWydtdHZEYXRhJywgcmVnaW9uLCBsYW5ndWFnZV0pXG5cbiAgICAgICAgLy8gY29udGVudC52YWwgPSBhcHAuY2xvdWQuZGF0YVxuXG4gICAgICB9XG4gICAgICBjb250ZW50LnZhbCA9IGFwcC5jbG91ZC5kYXRhXG4gICAgfVxuICAgIFxuICB9XG4pXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBcbiAqIGNvdWxkIHRoaW5rIG9mIHNvbWV0aGluZyBzbyBzdHlsZSByZXF1aXJlcyBhcmUgcGFyc2VkIG9wdGlvbmFseVxuICogbWF5YmUgaW4gdmlnb3VyLWpzIHVzZSBkeW5hbWljIHNjcmlwdCB0YWdzIGFuZCBwYXJzZSB0aG9zZSAvdyBnYXN0b24gaWYgeW91IGFyZSB1c2luZyBnYXN0b25cbiAqIHRoaXMgd2lsbCBtYWtlIGl0IG1vcmUgdXNhYmxlIGZvciBvdGhlcnMgaW4gdGhlIGZ1dHVyZSBhbmQgbWFrZXMgaXQgY29tcGF0aWJsZSB3aXRoIHB1cmUgYnJvd3NlcmlmeVxuICovXG5cbnJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5yZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vZWFzaW5nJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuL3VpL2VsZW1lbnQnKVxuICAsIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKVxuICAsIGFuaW1hdGlvbiA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbicpXG4gICwgZXZlbnRzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL2FkdmFuY2VkJylcbiAgLCB1YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL3VhJylcbiAgLCByYWYgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vcmFmJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKVxuICAsIGFwcFxuICAsIF9pb3MgPSB1YS5wbGF0Zm9ybT09PSdpb3MnXG4gICwgX3dpbmRvd3MgPSB1YS5wbGF0Zm9ybSA9PT0gJ3dpbmRvd3MnXG4gICwgYXJyID0gWydwaG9uZScsJ3RhYmxldCcsJ3R2JywnZGVza3RvcCcsJ2lvcycsJ2FuZHJvaWQnLCd3aW5kb3dzJywnbWFjJywnJGhhc1RvdWNoJywnc2xvdycsJ2Nocm9tZWNhc3QnXSAvL21heWJlIG1ha2UgdGhpcyBjb25maWdyYWJsZVxuICAvL3VpL2Nhc2VzIC0tXG4gICwgaSA9IGFyci5sZW5ndGggLSAxXG5cbi8vaGllciBwcm9jZXNzIGluIHJlcXVpcmVuIGVuIGFkZGVkICdhcHBTdGFydCcgb2Z6b2lldHMgZGVyZ2VsaWprc1xuLy9hZGQgb29rIHByb2Nlc3MgYWFuIGJhc2UgZGluZ2VuIGRhbiB3b3JkIGlldHMgcGFzIGdlYWRkIG5hIGVlbiBiZXBhYWxkZSBwcm9jZXNzIHVwZGF0ZVxuLy91bHRyYSBtb2ZvIHBvd2VyZnVsbFxuXG5jYXNlcy4kaXNJb3NCcm93c2VyID0gX2lvcyAmJiAoICdzdGFuZGFsb25lJyBpbiBuYXZpZ2F0b3IgJiYgIW5hdmlnYXRvci5zdGFuZGFsb25lIClcbmNhc2VzLiRpc0lvc0Z1bGwgPSAoIWNhc2VzLiRpc0lvc0Jyb3dzZXImJl9pb3MpIHx8ICgoX2lvcyB8fCBfd2luZG93cykgJiYgISF3aW5kb3cuY29yZG92YSkgfHwgZmFsc2VcbmNhc2VzLiRpc1JldGluYSA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMVxuY2FzZXMuJGlzU2xvdyA9IChfd2luZG93cyAmJiB1YS5kZXZpY2UgPT09ICdwaG9uZScpIHx8ICh1YS5ub1JhZiYmdWEuaGFzVHJhbnNpdGlvbikgfHwgX2lvcyAmJiAod2luZG93LnNjcmVlbi5oZWlnaHQgPT09ICg5NjAgLyAyKSkgfHwgdWEuZGV2aWNlID09PSAndHYnXG5jYXNlcy4kaXNOYXRpdmUgPSB3aW5kb3cuY29yZG92YSA/IHRydWUgOiBmYWxzZVxuY2FzZXMuJGlzV2luZG93c01vYmlsZSA9IHVhLnBsYXRmb3JtID09PSAnd2luZG93cycgJiYgdWEuZGV2aWNlID09PSAncGhvbmUnICYmICEhd2luZG93LmNvcmRvdmFcbmNhc2VzLiRpc1Bob25lQnJvd3NlciA9IHVhLmRldmljZSA9PT0gJ3Bob25lJyAmJiAhKCBjYXNlcy4kaXNOYXRpdmUgfHwgY2FzZXMuJGlzSW9zRnVsbCApXG4vL3BhY2tlciBjYXNlIHZvb3Igd2ViIC8vIG5hdGl2ZVxuXG5hcHAgPSBtb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgJ3gseSc6e3ZhbDowLGNsZWFuOnRydWUsdHJhbnNsYXRlOnRydWV9XG4sIG5vZGU6IGRvY3VtZW50LmJvZHlcbiwgdzogd2luZG93LmlubmVyV2lkdGhcbiwgaDogd2luZG93LmlubmVySGVpZ2h0XG4sIGNzczogJ2FwcCdcbn0pXG5cbi8vaWYoY2FzZXMuJGlzaW9zRnVsbCkge1xuICAvLyBhcHAueSA9IHthZGQ6MjB9XG4gIC8vIGFwcC5oID0ge3N1YjoyMH1cbi8vfVxuXG52YXIgbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbi8vICAgY29uc29sZS5sb2coJ3Jlc2l6ZSEhJywndzonLHdpbmRvdy5pbm5lcldpZHRoLCdoOicsd2luZG93LmlubmVySGVpZ2h0LCdibG9jaz86JyxhcHAuYmxvY2tSZXNpemUpXG4gIGlmKCFhcHAuYmxvY2tSZXNpemUpIHtcbiAgICAvLyBhbmltYXRpb24ucHJldmVudCA9IHRydWVcbiAgICBhcHAudy52YWwgPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGFwcC5oLnZhbCA9IHdpbmRvdy5pbm5lckhlaWdodFxuICAgIC8vIGFuaW1hdGlvbi5wcmV2ZW50ID0gZmFsc2VcbiAgfSBlbHNlIHtcbiAgICBhcHAuYmxvY2tSZXNpemUgPSBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDYXNlKHN0cikge1xuICBpZihzdHIgIT09ICckaGFzVG91Y2gnKXtcbiAgICB2YXIgY3NzU3RyID0gICdzJyArIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICB2YXIgY2FzZVN0ciA9ICckaScgKyBjc3NTdHJcbiAgICBpZihjYXNlc1tjYXNlU3RyXT09PXZvaWQgMCkge1xuICAgICAgY2FzZXNbY2FzZVN0cl0gPSAodWEuZGV2aWNlID09PSBzdHIgfHwgdWEucGxhdGZvcm0gPT09IHN0cikgPyB0cnVlIDogZmFsc2VcbiAgICB9XG4gICAgYXBwLmNzcyA9IHthZGRDbGFzczpjYXNlc1tjYXNlU3RyXSA/ICdpJyArIGNzc1N0ciA6ICdub3RJJysgY3NzU3RyfVxuICB9ZWxzZXtcbiAgICBhcHAuY3NzID0ge2FkZENsYXNzOmNhc2VzLiRoYXNUb3VjaCA/ICdoYXNUb3VjaCcgOiAnbm90SGFzVG91Y2gnfVxuICB9XG59XG5cbi8vIGxpc3RlbmVyID0gZXZlbnRVdGlscy50aHJvdHRsZShsaXN0ZW5lciw2MClcbi8vIGxpc3RlbmVyID1cbi8vIGNhc2VzLiRpc25vQ2FsYyA9ICF1dGlsLmhhc0NhbGMoKVxuLy9jYXNlIHRvbyBzZWUgaWYgYXBwIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyIG9uIGlvcyAobGltaXRzIHZpZGVvIGNhcGFiaWxpdGllcylcblxuaWYoY2FzZXMuJGlzdG91Y2gpIGV2ZW50cy5kb2N1bWVudC5hZGRFdmVudCgnbW92ZScsZnVuY3Rpb24oZSkge1xuICBpZighZXZlbnRzLl9tYXliZXNjcm9sbCAmJiAhZXZlbnRzLl9zZXRzY3JvbGwpIGUucHJldmVudERlZmF1bHQoKVxufSwnYXBwJylcblxuaWYoJ29yaWVudGF0aW9uJyBpbiB3aW5kb3cpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdvcmllbnRhdGlvbmNoYW5nZScsbGlzdGVuZXIpXG5pZighX2lvcykgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsbGlzdGVuZXIpXG5cbi8vYWRkaW5nICM8Y2FzZT4gaW4gdXJsIGZvcmNlcyBjYXNlLCBtdWx0aXBsZSBoYXNoZXMgPT0+IG11bHRpcGxlIGNhc2VzXG4vL3RoaXMgaXMgZm9yIHRlc3RpbmcgcHVycG9zZXMgLCBhZGQgZGV2ZWxvcG1lbnQgaW5kZW50aWZpZXIgZm9yIGNvbXBpbGVyXG5cbi8vdGhpcyBoYXMgdG8gZ29cbmlmKHdpbmRvdy5sb2NhdGlvbi5oYXNoKSB7XG4gIHZhciBoYXNoQ2FzZXMgPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnIycpWzFdXG4gICAgLCB4ID0gaGFzaENhc2VzLnNwbGl0KCcsJylcblxuICBmb3IodmFyIGogaW4geCkge1xuICAgIHZhciB5ID0geFtqXS5zcGxpdCgnPScpXG4gICAgdWFbeVswXV0gPSB5WzFdXG4gIH1cbiAgXG59XG5cbmlmKHVhLmRldmljZSA9PT0gJ3R2Jykge1xuICBjYXNlcy4kaXNTbG93ID0gdHJ1ZVxufVxuXG5mb3IoO2kgPj0gMDspIGRlZmF1bHRDYXNlKGFycltpLS1dKVxuXG5cblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Jyb3dzZXIvZWxlbWVudCcpXG5cbnJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlL2ZsYWdzL3BhcmVudCcpXG5yZXF1aXJlKCcuLi8uLi8uLi92YWx1ZS9mbGFncy9zZWxmJylcbnJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxucmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUvZmxhZ3MvdXRpbCcpXG5yZXF1aXJlKCcuLi8uLi8uLi9icm93c2VyL2V2ZW50cycpXG5cbm1vZHVsZS5leHBvcnRzID1cbiAgRWxlbWVudFxuICAuaW5qZWN0XG4gICggcmVxdWlyZSgnLi4vLi4vLi4vYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvY29sbGVjdGlvbicpXG4gICwgcmVxdWlyZSgnLi4vLi4vLi4vYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMnKVxuICAsIHJlcXVpcmUoJy4uLy4uLy4uL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL3Njcm9sbGJhcicpXG4gICwgcmVxdWlyZSgnLi4vLi4vLi4vYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvcHJvY2VzcycpXG4gICwgcmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUvb24nKVxuICApXG5cbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vZWxlbWVudCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKSBcbiAgLCBzcHJpdGUgPSBuZXcgRWxlbWVudCh7IFxuICAgICd3LGgnOjUwLFxuICAgIHg6e3RyYW5zbGF0ZTp0cnVlLHZhbDowfVxuICB9KVxuXG5zcHJpdGUuZXh0ZW5kKHsgbmFtZTogJ3BhcmFtcycgLy90aGlzIGhhcyB0byBjb21lIGZyb20gdWkgKGVsZW1lbnQpXG4gICwgdHlwZTogZmFsc2VcbiAgLCBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMuX3BhcmFtcyA9IHZhbFxuICAgIHRoaXMuQ2xhc3MucHJvdG90eXBlLl9wYXJhbXMgPSB2YWwgLy90ZW1wP1xuICB9XG59KVxuXG5zcHJpdGUuc2V0U2V0dGluZyh7XG4gIG5hbWU6J3NwaW5uZXInLFxuICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSB0aGlzXG4gICAgICAsIHBhcmFtcyA9IHRoaXMuX3BhcmFtcyB8fCB7fVxuICAgICAgLCBzdGFydCA9IHBhcmFtcy5zdGFydCB8fCAwXG4gICAgICAsIHNwZWVkID0gcGFyYW1zLmZyYW1lcyB8fCAzXG4gICAgICAsIHJvd3MgPSBwYXJhbXMucm93cyB8fCAxXG4gICAgICAsIGNvbHMgPSBwYXJhbXMuY29scyB8fCAwIC8vaWdub3JlXG4gICAgICAsIG9uY2UgPSBwYXJhbXMub25jZVxuICAgICAgLCBjbnQgPSBzdGFydFxuICAgICAgLCBzdGVwcyA9IChwYXJhbXMuc3RlcHMgfHwgKHJvd3MqY29scy1zdGFydCkgfHwgMTkpXG4gICAgICAsIGN1clJvdyA9IDBcbiAgICAgICwgY3VyQ29sID0gMFxuXG4gICAgaWYoIXQuZGlzcGxheSB8fCAhdC5kaXNwbGF5Ll9iYXNlPT09dCkge1xuICAgICAgdC5kaXNwbGF5ID0gdC5kaXNwbGF5ICYmIHQuZGlzcGxheS52YWwgfHwgJ2Jsb2NrJ1xuICAgIH1cbiAgICB0LmRpc3BsYXkuYWRkTGlzdGVuZXIoW2Rpc3BsYXlMaXN0ZW5lcix0XSx0cnVlKVxuXG4gICAgdC5ub2RlLnN0eWxlLmJhY2tncm91bmRTaXplID0gdGhpcy53LnZhbCpjb2xzKydweCBhdXRvJ1xuICAgIC8vcmVtZWJlciB3aGVyZSBpdCB3YXMgcGVyaGFwcyBpZiByZS1yZW5kZXJlZFxuICAgIGlmKHQuZGlzcGxheS52YWw9PT0nbm9uZScpIHJldHVyblxuXG4gICAgdC5fc3Bpbm5lciA9IHV0aWwuaW50ZXJ2YWwoZnVuY3Rpb24oKSB7IC8vdGVzdCBpbnRlcnZhbCBmb3IgbGVha3NcbiAgICAgIHQubm9kZS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSBcbiAgICAgICAgKC10LncudmFsKmN1ckNvbCkrJ3B4ICcrKHJvd3MgPyAoLXQuaC52YWwqY3VyUm93KSA6IDApKydweCdcbiAgICAgIGNudCsrXG4gICAgICBpZihjbnQgPT09IHN0ZXBzKSB7XG4gICAgICAgIGNudCA9IHN0YXJ0XG4gICAgICAgIGlmKG9uY2UpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdYWFhYWCcpXG4gICAgICAgICAgcmVtb3ZlUmFmLmNhbGwodClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyUm93ID0gcm93cyA/IH5+KGNudC9jb2xzKSA6IDBcbiAgICAgIGN1ckNvbCA9IGNudC0oY3VyUm93KSpjb2xzXG4gICAgfSxzcGVlZClcbiAgfSxcbiAgcmVtb3ZlOnJlbW92ZVJhZlxufSlcblxuZnVuY3Rpb24gcmVtb3ZlUmFmKCkge1xuICAgICAvLyBhbGVydCgnbGV0cyByZW1vdmUgdGhpcyBiYWRib3knKVxuXG4gIGlmKHRoaXMuX3NwaW5uZXIpIHtcbiAgICB0aGlzLl9zcGlubmVyKClcbiAgICB0aGlzLl9zcGlubmVyID0gbnVsbFxuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BsYXlMaXN0ZW5lciAodmFsKSB7XG4gIGlmKHZhbC52YWw9PT0nbm9uZScpIHtcbiAgICByZW1vdmVSYWYuY2FsbCh0aGlzKVxuICB9IGVsc2Uge1xuICAgIGlmKCF0aGlzLl9zcGlubmVyKSB0aGlzLnNldHRpbmcoJ3JlbmRlcicpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzcHJpdGUuQ2xhc3NcblxuXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG5cbnZhciBCYXNlID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jhc2UnKVxuICAsIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9lbGVtZW50JylcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZScpXG4gICwgVk9iamVjdCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QnKVxuICAsIHN3aXRjaGVyID0gbmV3IEVsZW1lbnQoKVxuICAsIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKVxuXG5mdW5jdGlvbiBleHRlbmRGYWN0b3J5KCBmaWVsZCApe1xuICByZXR1cm4geyBuYW1lOmZpZWxkXG4gICwgdHlwZTpmYWxzZVxuICAsIHNldDpmdW5jdGlvbiggZm4gKXtcbiAgICAgIGlmKGZuIGluc3RhbmNlb2YgRnVuY3Rpb24pXG4gICAgICB7XG4gICAgICAgIHZhciBzZXQgPSB7fVxuICAgICAgICBzZXRbJ18nK2ZpZWxkXSA9IGZuXG4gICAgICAgIHRoaXMuZGVmaW5lKHNldClcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigncHJvcGVydHkgJyArIGZpZWxkICsgJyBuZWVkcyB0byBiZSBhIGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuVmFsdWUuZmxhZ3MuJHBhcmFtcyA9IHtcbiAgc2V0OmZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgdGhpcy5wYXJhbXMgPSB2YWxcbiAgfVxufVxuXG5WYWx1ZS5mbGFncy4kb3B0aW9ucyA9IHtcbiAgc2V0OmZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgdGhpcy5vcHRpb25zID0gdmFsXG4gIH1cbn1cblxuc3dpdGNoZXIuZXh0ZW5kXG4oIHsgbG9hZGVyOnt9XG4gICwgYW5pbWF0aW9uOnt9XG4gICwgZGVsYXk6e31cbiAgLCBkb25lOnt9XG4gICwgZm9yY2U6e31cbiAgLCBiYWNrRmFsbGJhY2s6XG4gICAgeyBjYWNoZTpmYWxzZVxuICAgIC8vICwgc2V0OmZ1bmN0aW9uKCl7fVxuICAgIH1cbiAgLCBvblRyYW5zaXRpb246XG4gICAgeyBjYWNoZTpmYWxzZVxuICAgIC8vICwgc2V0OmZ1bmN0aW9uKCl7fVxuICAgIH1cbiAgLCB0cmFuc2l0aW9uOlxuICAgIHsgY2FjaGU6ZmFsc2VcbiAgICAsIHNldDpmdW5jdGlvbiggdmFsICl7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdmFsLmVsZW1lbnQgJiYgdmFsLmVsZW1lbnQuX3ZhbFxuICAgICAgICAgICwgcGFyYW1zID0gdmFsLnBhcmFtc1xuICAgICAgICAgICwgb3B0aW9ucyA9IHZhbC5vcHRpb25zIHx8IHt9XG4gICAgICAgICAgLCBmb3JjZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5mb3JjZVxuICAgICAgICAgICwgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXG4gICAgICAgICAgLCBsYXN0ID0gdGhpcy5fc3dFbGVtIHx8IGNoaWxkcmVuWzBdXG4gICAgICAgICAgLCBiYXNlID0gZWxlbWVudCAmJiBlbGVtZW50LmJhc2VcbiAgICAgICAgICAsIGNoaWxkcmVuTGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAgICAgLCBjdXJyZW50XG4gICAgICAgICAgLCBjaGlsZFxuICAgICAgICAgICwgZGlyZWN0aW9uXG4gICAgICAgICAgLCBfdGhpcyA9IHRoaXNcblxuICAgICAgICAvL2lmIHRoZXJlIGFyZSBvbGQgbG9hZGluZyBsaXN0ZW5lcnMgcmVtb3ZlIHRoZXNlXG4gICAgICAgIGlmKCB0aGlzLl9sb2FkaW5nIClcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuX2xvYWRpbmdbMV0ucmVtb3ZlTGlzdGVuZXIoIHRoaXMuX2xvYWRpbmdbMF0gKVxuICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSB2b2lkIDBcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmKCBfdGhpcy5fdGltZXIgKXtcbiAgICAgICAgLy8gICBjbGVhclRpbWVvdXQoIF90aGlzLl90aW1lciApXG4gICAgICAgIC8vICAgX3RoaXMuX3RpbWVyID0gbnVsbFxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29wdGlvbnM/IScuZ3JlZW4uaW52ZXJzZSxvcHRpb25zKVxuICAgICAgICAvL2lzIGl0IHRoZSBzYW1lICwgaXMgaXQgbm90IHRoZSBzYW1lIHdoYXR1cCFcbiAgICAgICAgaWYoIGJhc2UgJiYgYmFzZSBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgZWxlbWVudCA9PT0gRWxlbWVudCApXG4gICAgICAgIHsgXG4gICAgICAgICAgaWYoICFmb3JjZSAmJiB0aGlzLl9zd0VsZW0gJiYgdGhpcy5fc3dFbGVtIGluc3RhbmNlb2YgZWxlbWVudCApXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fc3dFbGVtLnNldCggcGFyYW1zIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgIHtcblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIHN0aWxsIG9sZCBwYWdlcywgcmVtb3ZlIHRoZXNlXG4gICAgICAgICAgICBpZiggY2hpbGRyZW5MZW5ndGggPiAxIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZm9yICggaSA9IGNoaWxkcmVuTGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV1cbiAgICAgICAgICAgICAgICBpZiggY2hpbGQgIT09IGxhc3QgKSBjaGlsZC5yZW1vdmUoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IHRoaXMuX2RpcmVjdGlvbiA9IHZhbC5kaXJlY3Rpb24gJiYgdmFsLmRpcmVjdGlvbi5fdmFsXG4gICAgICAgICAgICBpZiggb3B0aW9ucyAmJiBvcHRpb25zLmxvYWRlciAmJiAhb3B0aW9ucy5sb2FkZXIuJGxvYWRlZCApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmKCAhdGhpcy5sb2FkZXIgKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ25vIGxvYWRlciBkZWZpbmVkIScgKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdmFyIGxvYWRlciA9IG5ldyB0aGlzLmxvYWRlci5fdmFsLkNsYXNzKClcblxuICAgICAgICAgICAgICBpZiggb3B0aW9ucy5sb2FkZXIgaW5zdGFuY2VvZiBWT2JqZWN0ICkgLy9UT0RPOiB0aGlzIGhhcyBnb3R0ZW4gVkVSWSBkaXJ0eSA+IGNsZWFuIHRoaXMgdXAhXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgaWYoICFjdXJyZW50ICkgY3VycmVudCA9IG5ldyBlbGVtZW50KCBwYXJhbXMgKVxuICAgICAgICAgICAgICAgICAgaWYoIGxvYWRlci5fcmVtb3ZlIClcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kb25lID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVsYXkgPSBjYXNlcy50YWJsZXQgPyA0MDAgOiAyMDAgLy9kaXQgaXMgbmF0dXVybGlqayBhYnN1cmRcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKCBfdGhpcy5fc3dFbGVtIGluc3RhbmNlb2YgZWxlbWVudCApXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3dFbGVtLnNldCggcGFyYW1zIClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblRyYW5zaXRpb24uX3ZhbC5jYWxsKCBfdGhpcywgY3VycmVudCwgX3RoaXMuX3N3RWxlbSAsIDAsIG9wdGlvbnMgKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVsYXkgPSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IG9wdGlvbnMubG9hZGVyLl9wYXRoXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGluZyA9IFsgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZiggX3RoaXMuX3RpbWVyICl7XG4gICAgICAgICAgICAgICAgICAvLyAgIGNsZWFyVGltZW91dCggX3RoaXMuX3RpbWVyIClcbiAgICAgICAgICAgICAgICAgIC8vICAgX3RoaXMuX3RpbWVyID0gbnVsbFxuICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgbG9hZGVyLl9yZW1vdmUgPSB0cnVlXG4gICAgICAgICAgICAgICAgICBpZiggY3VycmVudCAmJiBvcHRpb25zLmRvbmUgKSBvcHRpb25zLmRvbmUoKVxuXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucy5sb2FkZXIgXVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2FkZCB0aGUgbGlzdGVuZXIgZm9yJyxwYXRoKVxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRpbmdbMV0uaXMoJ2xvYWRlZCcsIHRoaXMuX2xvYWRpbmdbMF0gKVxuICAgICAgICAgICAgICAgIC8vIF90aGlzLl90aW1lciA9IHNldFRpbWVvdXQoIHRoaXMuX2xvYWRpbmdbMF0sIDUwMDAgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICBpZiggIWN1cnJlbnQgKSBjdXJyZW50ID0gbmV3IGVsZW1lbnQoIHBhcmFtcyApXG5cbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZG9uZSA9IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWxheSA9IDIwMFxuXG4gICAgICAgICAgICAgICAgICBpZiggX3RoaXMuX3N3RWxlbSBpbnN0YW5jZW9mIGVsZW1lbnQgKVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fc3dFbGVtLnNldCggcGFyYW1zIClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25UcmFuc2l0aW9uLl92YWwuY2FsbCggX3RoaXMsIGN1cnJlbnQsIF90aGlzLl9zd0VsZW0gLCAwLCBvcHRpb25zIClcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWxheSA9IHZvaWQgMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9wdGlvbnMubG9hZGVyID0gdm9pZCAwXG5cbiAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb24uX3ZhbC5jYWxsKCB0aGlzLCBsb2FkZXIsIGxhc3QsIGRpcmVjdGlvbiwgb3B0aW9ucylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY3VycmVudCA9IG5ldyBlbGVtZW50KHBhcmFtcylcbiAgICAgICAgICAgICAgb3B0aW9ucy5kb25lID0gdm9pZCAwXG4gICAgICAgICAgICAgIG9wdGlvbnMuZGVsYXkgPSB2b2lkIDBcbiAgICAgICAgICAgICAgb3B0aW9ucy5sb2FkZXIgPSB2b2lkIDBcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uLl92YWwuY2FsbCggdGhpcywgY3VycmVudCwgbGFzdCAsIGRpcmVjdGlvbiwgb3B0aW9ucyApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCBvcHRpb25zLmFuaW1hdGlvbiAhPT0gdm9pZCAwICkgb3B0aW9ucy5hbmltYXRpb24gPSB2b2lkIDBcbiAgICAgICAgICAgIGlmKCBvcHRpb25zLmRlbGF5ICkgb3B0aW9ucy5kZWxheSA9IHZvaWQgMFxuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYocGFyYW1zKVxuICAgICAgICB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignb25seSBwYXJhbXMgZGVmaW5lZCEnLCBwYXJhbXMpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihwYXJhbXMpXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdubyBwYXJhbXMgYW5kIG5vIGVsZW1lbnQgZGVmaW5lZCEnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4pXG5cbnN3aXRjaGVyLmRlZmluZVxuKHsgYmFjazpmdW5jdGlvbigpeyAvL3JlbW92ZSBiYWNrIGxvZ2ljIGZyb20gc3dpdGNoZXIgKHlvdSBjYW4ndCBpc29sYXRlIGl0ISBpZSB3aGVuIHlvdSBsYW5kIG9uIHBhZ2UsIHdoYXQgaXMgYmFjaz8pXG4gICAgICB0aGlzLmJhY2tGYWxsYmFjay5fdmFsLmNhbGwoIHRoaXMgKVxuXHRcdH1cbiAgLCBhZGQ6ZnVuY3Rpb24oIGVsZW1lbnQsIHByZXZpb3VzICl7XG4gICAgICBjb25zb2xlLmxvZygnYWRkLS0tPicsZWxlbWVudClcbiAgICAgIHRoaXMuX3N3RWxlbSA9IGVsZW1lbnRcblxuICAgICAgLy8gdHJ5XG4gICAgICAvLyB7XG4gICAgICAgIEVsZW1lbnQucHJvdG90eXBlLmFkZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgIC8vIH1cbiAgICAgIC8vIGNhdGNoKGVycilcbiAgICAgIC8vIHtcbiAgICAgIC8vICAgY29uc29sZS5lcnJvcignZXJyb3IgYWRkaW5nIHRoZSBuZXcgZWxlbWVudCcsZXJyLGFyZ3VtZW50cylcbiAgICAgIC8vIH1cbiAgICB9XG5cdH1cbilcblxuc3dpdGNoZXIuZXh0ZW5kXG4oIHsgbmFtZTonb24nXG4gICwgc2V0OmZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAvLyBzZXQgaGlzdG9yeSB2YXJpYWJsZSBmb3IgYWxsXG4gICAgICAvLyB2YWwuZWFjaChmdW5jdGlvbigpe1xuICAgICAgLy8gICB2YXIgZnJvbSA9IHRoaXMuJHVzZXJPcmlnaW4udmFsXG4gICAgICAvLyAgIGlmKCFmcm9tKSByZXR1cm5cbiAgICAgIC8vICAgaWYoIWZyb20uX2hpc3RvcnkpIGZyb20uc2V0KCdoaXN0b3J5Jyx0cnVlKVxuICAgICAgLy8gICBpZighdGhpcy5fX2NoZWNrZWQpXG4gICAgICAvLyAgIHtcbiAgICAgIC8vICAgICB0aGlzLm9uKGZ1bmN0aW9uKCl7XG4gICAgICAvLyAgICAgICB2YXIgY2FsbGVyID0gdGhpcy5fcGFyZW50Ll9jYWxsZXJcbiAgICAgICAgICAgIFxuICAgICAgLy8gICAgICAgaWYoIWNhbGxlci5fYmFja1N0b3JlKVxuICAgICAgLy8gICAgICAgeyBcbiAgICAgIC8vICAgICAgICAgY2FsbGVyLl9iYWNrU3RvcmUgPSBbIHRoaXMgXVxuICAgICAgLy8gICAgICAgfVxuICAgICAgLy8gICAgICAgZWxzZSBpZihjYWxsZXIuX2RpcmVjdGlvbiA9PT0gLTEpXG4gICAgICAvLyAgICAgICB7XG4gICAgICAvLyAgICAgICAgIGlmKGNhbGxlci5fYmFja1N0b3JlWzFdICE9PSB2b2lkIDApIGNhbGxlci5fYmFja1N0b3JlLnNoaWZ0KClcbiAgICAgIC8vICAgICAgICAgZWxzZSBjYWxsZXIuX2JhY2tTdG9yZSA9IFsgdGhpcyBdXG4gICAgICAvLyAgICAgICB9XG4gICAgICAvLyAgICAgICBlbHNlIGlmKGNhbGxlci5fZGlyZWN0aW9uID09PSAxKVxuICAgICAgLy8gICAgICAge1xuICAgICAgLy8gICAgICAgICBjYWxsZXIuX2JhY2tTdG9yZS51bnNoaWZ0KCB0aGlzIClcbiAgICAgIC8vICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgLy8gICAgIH0pXG4gICAgICAvLyAgICAgdGhpcy5fX2NoZWNrZWQgPSB0cnVlXG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH0pXG4gICAgfVxuICAsIHJlbW92ZTpmdW5jdGlvbigpeyAvLyBjcmVhdGUgcmVmcyB0byBvcmlnaW5hbFxuICAgICAgaWYoIHRoaXMuX2xvYWRpbmcgKVxuICAgICAge1xuICAgICAgICB0aGlzLl9sb2FkaW5nWzFdLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2xvYWRpbmdbMF0pXG4gICAgICAgIHRoaXMuX2xvYWRpbmcgPSBudWxsXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCB0aGlzLl9zd1RpbWVyICkgY2xlYXJUaW1lb3V0KCB0aGlzLl9zd1RpbWVyIClcbiAgICAgIGlmKCB0aGlzLl90aW1lciApIGNsZWFyVGltZW91dCggdGhpcy5fdGltZXIgKVxuXG4gICAgICBpZiggdGhpcy5vbi4kcmVtb3ZlICkgdGhpcy5vbi4kcmVtb3ZlLnVwZGF0ZSgpXG4gICAgfVxuICAsIG5ldzpmdW5jdGlvbigpe1xuICAgICAgaWYoIHRoaXMub24uJG5ldyApIHRoaXMub24uJG5ldy51cGRhdGUoKVxuICAgIH1cbiAgfVxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBzd2l0Y2hlci5DbGFzcygpLkNsYXNzIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNSwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKSxcbiAgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpLFxuICB1dGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGZ1bmN0aW9uKGJhc2UpIHtcbiAgYmFzZS5zZXQoe1xuICAgIG9uVHJhbnNpdGlvbjoge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKHVwZGF0ZSkgeyAvL29ic2N1cmUgdHJhbnNmb3JtXG4gICAgICAgIGlmIChleHBvcnRzW3RoaXMuX3ZhbF0pIHRoaXMuX3ZhbCA9IGV4cG9ydHNbdGhpcy5fdmFsXVxuICAgICAgICB1cGRhdGUoKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn0pXG5cbi8vc2xpZGUgdHJhbnNpdGlvblxuZXhwb3J0cy5zbGlkZSA9IGZ1bmN0aW9uKGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICBpZiAoZGlyZWN0aW9uICYmIGxhc3QpIGFuaW1hdGUodGhpcywgY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uLCBvcHRpb25zKVxuICBlbHNlIGJhc2ljKHRoaXMsIGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbiwgb3B0aW9ucylcbn1cblxuLy9mYWRlIHRyYW5zaXRpb25cbmV4cG9ydHMuZmFkZSA9IGZ1bmN0aW9uKGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICBiYXNpYyh0aGlzLCBjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24sIG9wdGlvbnMpXG59XG5cbi8vYmFzaWMgdHJhbnNpdGlvblxuZnVuY3Rpb24gYmFzaWMoX3RoaXMsIGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICB2YXIgZG9uZSA9IG9wdGlvbnMuZG9uZSxcbiAgICBub0FuaW1hdGlvbiA9IG9wdGlvbnMuYW5pbWF0aW9uID09PSBmYWxzZSxcbiAgICBkZWxheSA9IG9wdGlvbnMuZGVsYXlcblxuICBpZiAobGFzdCkge1xuICAgIGFkZChfdGhpcywgY3VycmVudCwgbGFzdClcblxuICAgIGlmIChub0FuaW1hdGlvbikge1xuICAgICAgcmVtb3ZlKF90aGlzLCBsYXN0KVxuICAgICAgYWRkKF90aGlzLCBjdXJyZW50KVxuXG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICB0aW1lcihfdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5kb25lKSBvcHRpb25zLmRvbmUoKVxuICAgICAgICAgIH0sIGRlbGF5KVxuICAgICAgICB9IGVsc2UgZG9uZSgpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkZWxheSkge1xuICAgICAgdGltZXIoX3RoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmYWRlKF90aGlzLCBsYXN0LCBvcHRpb25zKVxuICAgICAgfSwgZGVsYXkpXG4gICAgfSBlbHNlIGZhZGUoX3RoaXMsIGxhc3QsIG9wdGlvbnMpXG4gIH0gZWxzZSBhZGQoX3RoaXMsIGN1cnJlbnQsIGZhbHNlLCBkb25lKVxufVxuXG4vL2FuaW1hdGVkIHRyYW5zaXRpb25cbmZ1bmN0aW9uIGFuaW1hdGUoX3RoaXMsIGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbiwgb3B0aW9ucykge1xuICB2YXIgYW5pbWF0aW9uVGltZSA9IDIwIC8vIG1ha2UgdGhpcyBjb25maWd1cmFibGVcbiAgICAsXG4gICAgYXBwV2lkdGggPSBhcHAudy52YWwsXG4gICAgY3VycmVudFN0YXJ0LCBmb3J3YXJkID0gZGlyZWN0aW9uID09PSAxLFxuICAgIGxhc3RFbmRcblxuICBpZiAoZm9yd2FyZCkge1xuICAgIGN1cnJlbnRTdGFydCA9IGFwcFdpZHRoXG4gICAgbGFzdEVuZCA9IGFwcFdpZHRoIC8gLTNcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50U3RhcnQgPSBhcHBXaWR0aCAvIC0zXG4gICAgbGFzdEVuZCA9IGFwcFdpZHRoXG4gIH1cblxuICBpZiAoY2FzZXMuJGlzV2luZG93cykge1xuICAgIGN1cnJlbnQueCA9IHtcbiAgICAgIHRyYW5zbGF0ZTogdHJ1ZSxcbiAgICAgIHZhbDogY3VycmVudFN0YXJ0XG4gICAgfVxuXG4gICAgbGFzdC54ID0ge1xuICAgICAgdHJhbnNsYXRlOiB0cnVlLFxuICAgICAgdmFsOiAwXG4gICAgfVxuXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgIGN1cnJlbnQueCA9IDBcbiAgICAgIGxhc3QueCA9IGxhc3RFbmRcblxuICAgICAgdGltZXIoX3RoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZW1vdmUoX3RoaXMsIGxhc3QsIG9wdGlvbnMuZG9uZSlcbiAgICAgIH0sIDIxMClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGN1cnJlbnQueCA9IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICBzdGFydDogY3VycmVudFN0YXJ0LFxuICAgICAgICB0aW1lOiBhbmltYXRpb25UaW1lLFxuICAgICAgICBkZWxheTogMSxcbiAgICAgICAgZWFzaW5nOiAnb3V0Q3ViaWMnLFxuICAgICAgICBkb25lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZW1vdmUoX3RoaXMsIGxhc3QsIG9wdGlvbnMuZG9uZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhbDogMFxuICAgIH1cblxuICAgIGxhc3QueCA9IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICB0aW1lOiBhbmltYXRpb25UaW1lLFxuICAgICAgICBkZWxheTogMixcbiAgICAgICAgZWFzaW5nOiAnb3V0Q3ViaWMnXG4gICAgICB9LFxuICAgICAgdmFsOiBsYXN0RW5kXG4gICAgfVxuICB9XG5cbiAgaWYgKCFmb3J3YXJkKSBhZGQoX3RoaXMsIGN1cnJlbnQsIGxhc3QpXG4gIGVsc2UgYWRkKF90aGlzLCBjdXJyZW50KVxuXG59XG5cbmZ1bmN0aW9uIGFkZChfdGhpcywgdG9BZGQsIGJlZm9yZSwgZG9uZSkge1xuICBpZiAodG9BZGQpIF90aGlzLmFkZCh0b0FkZCwgYmVmb3JlKVxuICBpZiAoZG9uZSkgZG9uZSgpXG59XG5cbmZ1bmN0aW9uIGZhZGUoX3RoaXMsIGxhc3QsIG9wdGlvbnMpIHtcbiAgbGFzdC5vcGFjaXR5ID0gMFxuICBsYXN0Lm5vZGUucG9pbnRlckV2ZW50cyA9ICdub25lJ1xuICB0aW1lcihfdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlKF90aGlzLCBsYXN0LCBvcHRpb25zLmRvbmUpXG4gIH0sIDIwMClcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKF90aGlzLCB0b1JlbW92ZSwgZG9uZSkge1xuICBpZiAodG9SZW1vdmUpIHRvUmVtb3ZlLnJlbW92ZSgpXG4gIGlmIChkb25lKSBkb25lKClcbn1cblxuZnVuY3Rpb24gdGltZXIoX3RoaXMsIGZuLCB0aW1lKSB7XG4gIGlmIChfdGhpcy5fc3dUaW1lcikge1xuICAgIGNsZWFyVGltZW91dChfdGhpcy5fc3dUaW1lcilcbiAgICBfdGhpcy5fc3dUaW1lciA9IG51bGxcbiAgfVxuICBfdGhpcy5fc3dUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZm4uY2FsbChfdGhpcylcbiAgICBfdGhpcy5fc3dUaW1lciA9IG51bGxcbiAgfSwgdGltZSlcbn1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG5cbnJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kXG4oIGZ1bmN0aW9uKCBiYXNlICkge1xuICAgIC8vIGJhc2VcbiAgICBiYXNlLmV4dGVuZFxuICAgICggXG4gICAgICB7IGlkOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICB2YXIgaWQgPSB2YWwudmFsXG5cbiAgICAgICAgICBpZiggaWQgJiYgdGhpcy5jbG91ZCApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuY2xvdWQuZGF0YS5nZXQoWyAndXNlcnMnLCBpZCBdKVxuICAgICAgICAgIH0gXG4gICAgICAgICAgZWxzZSBpZiggIWlkICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gdGhpcy5kYXRhID0gdm9pZCAwXG4gICAgICAgICAgICAvL1RPRE86IHRoaXMgd29ya3MgYnVnZ3kgaW4gdmFsdWVzIC0tLSB2b2lkIDAgZG9lcyBub3QgdXBkYXRlIGRhdGEsIG1heWJlIGp1c3QgdXNlIGZhbHNlIGZvciBub3dcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdiYXNlLm1vY2tkYXRhJylcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGJhc2UubW9ja2RhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICwgZGF0YToge1xuICAgICAgICAgIC8vbW9ja2RhdGEgb24gc3RhcnQgY2FuIGJyZWFrIGV2ZXJ5dGhpbmcgZG93blxuICAgICAgICAgIHZhbDogYmFzZS5tb2NrZGF0YSAsXG4gICAgICAgICAgc2V0OmZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgICAgICB2YXIgdXNlciA9IHRoaXNcblxuICAgICAgICAgICAgLy8gaWYoIXRoaXMuZmlyc3QpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcy5maXJzdCA9IHRydWVcbiAgICAgICAgICAgIC8vIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmKHVzZXIuaW5zdGFuY2VzICYmIHVzZXIuaW5zdGFuY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yICgnLS0gdG1wIGZpeCBkYXRhIG9uIGJhc2Ugc3dpdGNoIHRvIGluc3RhbmNlWzBdJyApXG4gICAgICAgICAgICAgIC8vVE9ETzogdGhpcyBpcyBhIGhhY2t5IHNvbHV0aW9uISBmaXggbGF0ZXJcbiAgICAgICAgICAgICAgdXNlciA9IHVzZXIuaW5zdGFuY2VzWzBdXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCB2YWwuZnJvbS5jbG91ZCAgKSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYoIHVzZXIuX19fYyAhPT0gdmFsLmZyb20gKSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVzZXIuaW5pdGlhbGlzZWQgPSBudWxsXG4gICAgICAgICAgICAgICAgdXNlci5fX19jID0gdmFsLmZyb21cbiAgICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiB1c2VyLm9uLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgIHVzZXIub24udXNlcltrZXldLmNhbGwoIHVzZXIsIGtleSApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVzZXIuaW5pdGlhbGlzZWQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmKCB1c2VyLl9fX2MgPT09IGZhbHNlICkgcmV0dXJuXG4gICAgICAgICAgICAgIHVzZXIuX19fYyA9IGZhbHNlXG4gICAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHVzZXIub24udXNlcikge1xuICAgICAgICAgICAgICAgIHVzZXIub24ubW9ja1trZXldLmNhbGwoIHVzZXIsIGtleSApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXNlci5pbml0aWFsaXNlZCA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuXG59KVxuIiwicmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3Mvc2VsZicpXG5yZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy9wcm9jZXNzJylcbnJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzL3V0aWwnKVxuICAvL1RPRE86IGNsZWFuIHRoZXNlIHRvIHdvcmsgL3cgaW5qZWN0XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlJyksXG4gIEJhc2UgPSByZXF1aXJlKCcuLi8uLi9iYXNlJyksXG4gIERhdGEgPSByZXF1aXJlKCcuLi8uLi9kYXRhJyksXG4gIHZPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKS5pbmplY3QoXG4gICAgcmVxdWlyZSgnLi9vcmlnaW4nKVxuICApLFxuICB0aW1lc3RhbXAgPSByZXF1aXJlKCdtb25vdG9uaWMtdGltZXN0YW1wJyksXG4gIF9zdWJzY3JpcHRpb25zID0ge30sXG4gIE1vY2tEYXRhID0gcmVxdWlyZSgnLi9tb2NrZGF0YScpLFxuICBtb2NrZGF0YSA9IG5ldyBNb2NrRGF0YSh7fSlcbiAgLy8gbWFrZSBtb2NrZGF0YSB2YWlsYWJsZVxuXG52YXIgX2V4dGVuZCA9IEJhc2UucHJvdG90eXBlLmV4dGVuZFxuXG52YXIgdXNlciA9IG5ldyBCYXNlKHtcbiAgZGVmYXVsdFR5cGU6IHJlcXVpcmUoJy4vdHlwZScpXG59KVxuXG51c2VyLmRlZmluZSh7XG4gIHN1YnNjcmlwdGlvbnM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfc3Vic2NyaXB0aW9uc1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAodmFsKSB1dGlsLm1lcmdlKF9zdWJzY3JpcHRpb25zLCB2YWwpXG4gICAgfVxuICB9LFxuICBtb2NrZGF0YToge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG1vY2tkYXRhXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICh2YWwpIG1vY2tkYXRhLm1lcmdlKHZhbClcbiAgICB9XG4gIH0sXG4gIG9uOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIG1vY2s6IHt9LFxuICAgICAgdXNlcjoge31cbiAgICB9XG4gIH1cbiwgZXh0ZW5kOiBmdW5jdGlvbiggc2V0dGluZ3MgKSB7XG5cbiAgICBpZihzZXR0aW5ncy5tb2NrKSB7XG4gICAgICB0aGlzLm1vY2tkYXRhID0gc2V0dGluZ3MubW9ja1xuICAgIH1cblxuICAgIHZhciByZXQgPSBfZXh0ZW5kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblxuICAgIGlmKHNldHRpbmdzLnZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzW3NldHRpbmdzLm5hbWVdID0gc2V0dGluZ3MudmFsXG4gICAgfVxuXG4gICAgaWYoIHNldHRpbmdzLm9uICkge1xuXG4gICAgICBpZiggdHlwZW9mIHNldHRpbmdzLm9uID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICBzZXR0aW5ncy5vbi5jYWxsKCB0aGlzLCBzZXR0aW5ncy5uYW1lICkgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiggdGhpcy5kYXRhICYmIHRoaXMuZGF0YS5jbG91ZCApIHtcbiAgICAgICAgICBzZXR0aW5ncy5vbi51c2VyICYmIHNldHRpbmdzLm9uLnVzZXIuY2FsbCggdGhpcywgc2V0dGluZ3MubmFtZSApIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNldHRpbmdzLm9uLm1vY2sgJiYgc2V0dGluZ3Mub24ubW9jay5jYWxsKCB0aGlzLCBzZXR0aW5ncy5uYW1lICkgXG4gICAgICAgIH1cbiAgICAgIH0gICAgXG4gICAgfVxuXG4gICAgcmV0dXJuIHJldFxuICB9XG59KVxuXG4vLyB1c2VyXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoXG4gIHJlcXVpcmUoJy4uL2Nsb3VkJyksXG4gIGZ1bmN0aW9uIChiYXNlKSB7XG4gICAgdmFyIGFwcHVzZXIgPSBiYXNlLnVzZXIgPSBuZXcgdXNlci5DbGFzcygpLmluamVjdChcbiAgICAgIHJlcXVpcmUoJy4vc2V0JyksXG4gICAgICByZXF1aXJlKCcuL2lkJylcbiAgICAgIC8vaW5qZWN0IHBhcyBvcCBleHRlbmQ/Pz9cbiAgICApXG4gICAgYXBwdXNlci5wYXJlbnQgPSBiYXNlXG4gICAgYXBwdXNlci5jYXNlcyA9IGJhc2UuY2FzZXNcbiAgICBhcHB1c2VyLmNsb3VkID0gYmFzZS5jbG91ZFxuICB9XG4pIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBEYXRhID0gcmVxdWlyZSgnLi4vLi4vZGF0YScpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IERhdGEubmV3KCkgIFxuXG51dGlsLmRlZmluZSggZXhwb3J0cyxcbidnZXQnLCBmdW5jdGlvbiggdmFsLCBzZXQsIG5vdHNlbGYgKSB7XG4gIHJldHVybiB0aGlzLnBhdGhcbiAgKCAodmFsIGluc3RhbmNlb2YgQXJyYXkpID8gdmFsIDogU3RyaW5nKHZhbCkuc3BsaXQoJy4nKVxuICAsIHNldCAhPT0gdm9pZCAwID8gc2V0IDoge31cbiAgLCBmYWxzZVxuICAsIGZhbHNlXG4gICwgZmFsc2VcbiAgLCBmYWxzZVxuICAsIHRydWVcbiAgLCAhbm90c2VsZlxuICApXG59KVxuXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsJyksXG4gIFZhbHVlID0gcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlJyksXG4gIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKSxcbiAgRGF0YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9kYXRhJykuaW5qZWN0KFxuICAgIHJlcXVpcmUoJ3ZpZ291ci1qcy9kYXRhL3NlbGVjdGlvbicpICAgIFxuICApLFxuICBDb21wb3VuZCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QvY29tcG91bmQnKSxcbiAgZXZlbnRzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzJyksXG4gIHVhID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvdWEnKSxcbiAgcmFmID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicpXG5cbnZhciBWT2JqZWN0ID0gcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdCcpXG5WT2JqZWN0LmluamVjdChcbiAgcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlL2xlbmd0aCcpXG4pXG5cbnZhciBJTkFDVElWRSA9IHR5cGVvZiB3aW5kb3cgIT09IHZvaWQgMCAmJiB3aW5kb3cuSU5BQ1RJVkVcblxudmFyIGRldmljZUlzQ2FuZGlkYXRlID0gLyhkZXNrdG9wKXwodHYpfChjYXN0KXwodGFibGV0KXwoYWlycGxheSkvaVxuY2FzZXMuJGlzQ2FuZGlkYXRlID0gZGV2aWNlSXNDYW5kaWRhdGUudGVzdCh1YS5kZXZpY2UpXG5cbnZhciBkZXZpY2VJc1R2TGlrZSA9IC8odHYpfChjYXN0KXwoYWlycGxheSkvaVxuXG5yZXF1aXJlKCd2aWdvdXItanMvdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZnVuY3Rpb24gKHVzZXIpIHtcblxuICB2YXIgY29udGVudCA9IHVzZXIucGFyZW50LmluamVjdChyZXF1aXJlKCcuLi8uLi9jb250ZW50JykpLmNvbnRlbnRcblxuICBjb250ZW50Lm9uKCdzZWxmJywgZnVuY3Rpb24oKSB7XG4gICAgaWYoIHVzZXIudG9rZW4udmFsICkge1xuICAgICAgaWYodXNlci5yZWNlaXZlci5tZWRpYS52YWwgJiYgdXNlci5yZWNlaXZlci5tZWRpYS5mcm9tICE9PSB1c2VyLnJlY2VpdmVyLm1lZGlhICkge1xuICAgICAgICBpZih1c2VyLnJlY2VpdmVyLm1lZGlhLmZyb20hPT0gY29udGVudC5nZXQoIHVzZXIucmVjZWl2ZXIubWVkaWEuZnJvbS5fY29udGVudFBhdGggKSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2xldHMgZ28gY2hhbmdlIGl0IScsIHVzZXIucmVjZWl2ZXIubWVkaWEpXG4gICAgICAgICAgdXNlci5yZWNlaXZlci5tZWRpYS4kdXNlck9yaWdpbiA9IGNvbnRlbnQuZ2V0KCB1c2VyLnJlY2VpdmVyLm1lZGlhLmZyb20uX2NvbnRlbnRQYXRoIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gXG4gIH0pXG5cbiAgLy8gZXh0ZW5kIGJhc2ljIHByb3BlcnRpZXNcbiAgdXNlci5leHRlbmQoe1xuICAgIHJlY2VpdmVyOiB7XG4gICAgICBtb2NrOiB7XG4gICAgICAgIHJlY2VpdmVyOiB7XG4gICAgICAgICAgdm9sdW1lOiAxLFxuICAgICAgICAgIG1lZGlhOiBmYWxzZSxcbiAgICAgICAgICBwbGF5aW5nOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmFsOiB7XG4gICAgICAgIG1lZGlhOiB7XG4gICAgICAgICAgJGJ1YmJsZToge1xuICAgICAgICAgICAgcmVmZXJlbmNlczp7XG4gICAgICAgICAgICAgICRsdGU6MVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVmZXI6ZnVuY3Rpb24odXBkYXRlKXtcbiAgICAgICAgICAgIHZhciBwbGF5aW5nID0gdGhpcy5fcGFyZW50LnBsYXlpbmdcbiAgICAgICAgICAgIGlmKHBsYXlpbmcgJiYgIXRoaXMuZnJvbS52YWwpIHBsYXlpbmcuZnJvbS52YWwgPSBmYWxzZVxuICAgICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgcmVjZWl2ZXI6IHtcbiAgICAgICAgICB2b2x1bWU6IHRydWUsXG4gICAgICAgICAgcGxheWluZzp0cnVlLFxuICAgICAgICAgIG1lZGlhOiB7XG4gICAgICAgICAgICAkOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgbW9jazogc2V0TW9ja19yZWNlaXZlcixcbiAgICAgICAgdXNlcjogc2V0VXNlcl9yZWNlaXZlclxuICAgICAgfVxuICAgIH0sXG4gICAgY2xpZW50czoge1xuICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgIGNsaWVudHM6IHtcbiAgICAgICAgICAkOiB7XG4gICAgICAgICAgICAkOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgbW9jazogc2V0Q2xpZW50cyxcbiAgICAgICAgdXNlcjogc2V0Q2xpZW50c1xuICAgICAgfVxuICAgIH0sXG4gICAgY2FuZGlkYXRlczogeyB2YWw6IHt9IH0sXG4gICAgc2libGluZ3M6IHsgdmFsOiB7fSB9LFxuICAgIHJlY2VpdmVyQ2xpZW50OiB7XG4gICAgICB2YWw6IHt9LFxuICAgICAgb246IHtcbiAgICAgICAgbW9jazogc2V0TW9ja19yZWNlaXZlckNsaWVudCxcbiAgICAgICAgdXNlcjogc2V0VXNlcl9yZWNlaXZlckNsaWVudFxuICAgICAgfSxcbiAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICByZWNlaXZlckNsaWVudDp7XG4gICAgICAgICAgJDogdHJ1ZSAgXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFjdGl2ZUNsaWVudDoge1xuICAgICAgdmFsOiB7fSxcbiAgICAgIG1vY2s6IHtcbiAgICAgICAgYWN0aXZlQ2xpZW50OiB0cnVlXG4gICAgICB9LFxuICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgIGFjdGl2ZUNsaWVudDp7XG4gICAgICAgICAgJDogdHJ1ZSAgXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBtb2NrOiBzZXRNb2NrX2FjdGl2ZUNsaWVudCxcbiAgICAgICAgdXNlcjogc2V0VXNlcl9hY3RpdmVDbGllbnRcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIFxuICAvLyBleHRlbmQgZGV2aWNlcyAobmVlZHMgc2libGluZ3MpXG4gIHVzZXIuZXh0ZW5kKHtcbiAgICBkZXZpY2VzOiB7XG4gICAgICB2YWw6IG5ldyBDb21wb3VuZCh1c2VyLnNpYmxpbmdzKVxuICAgIH1cbiAgfSlcbiAgXG4gIC8vIGV4dGVuZCBjYXNlIHZhbHVlc1xuICB1c2VyLmV4dGVuZCh7XG4gICAgaGFzUmVjZWl2ZXI6IHtcbiAgICAgIHZhbDoge1xuICAgICAgICB2YWw6IHVzZXIucmVjZWl2ZXJDbGllbnQsXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odmFsLCBjdikge1xuICAgICAgICAgIHZhciBlbmRwb2ludCA9IHVzZXIucmVjZWl2ZXJDbGllbnQuZnJvbVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlbmRwb2ludCAmJiAhZW5kcG9pbnQuX3JlbW92ZWQgJiZcbiAgICAgICAgICAgIGVuZHBvaW50LmNsb3VkICYmIGVuZHBvaW50Ll9wYXRoWzBdID09PSAnY2xpZW50cydcbiAgICAgICAgICApIHx8IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaXNSZWNlaXZlcjogeyAgICAgIFxuICAgICAgdmFsOiB7XG4gICAgICAgIGRlZmVyOiBmdW5jdGlvbih1cGRhdGUsIGFyZ3Mpe1xuICAgICAgICAgIHZhciBvcmlnaW4gPSBhcmdzWzJdIHx8IHRoaXMuX3VwZGF0ZU9yaWdpblxuICAgICAgICAgIGlmKCFvcmlnaW4gfHwgXG4gICAgICAgICAgICAgIShvcmlnaW4uX3Byb3AgfHwgb3JpZ2luLl9uYW1lID09PSAncmVjZWl2ZXJDbGllbnQnKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYmxvY2sgdXBkYXRlJywgb3JpZ2luKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ25vIGJsb2NrJylcbiAgICAgICAgICB2YXIgc3RhbXAgPSBhcmdzWzFdXG4gICAgICAgICAgaWYoc3RhbXAgIT09ICdjbGVhbnVwJykge1xuICAgICAgICAgICAgaWYodXNlci5faGFuZGxlT2xkSXNSZWNlaXZlcikge1xuICAgICAgICAgICAgICBpZiggdXNlci5fd2FzUmVjZWl2ZXIgJiYgXG4gICAgICAgICAgICAgICAgICAhdXNlci5oYXNSZWNlaXZlci52YWwgJiZcbiAgICAgICAgICAgICAgICAgICF1c2VyLmlzQWN0aXZlLnZhbFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2kgd2FzIHJlY2VpdmVyIGZvciB0aGlzIGd1eScsIHVzZXIuZGF0YS5fdmFsLnJhdylcbiAgICAgICAgICAgICAgICB1c2VyLnNldFJlY2VpdmVyKHVzZXIuY2xvdWQuY2xpZW50LmZyb20pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXNlci5faGFuZGxlT2xkSXNSZWNlaXZlciA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICB1c2VyLl93YXNSZWNlaXZlciA9IHRoaXMudmFsXG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIHZhbDogdXNlci5yZWNlaXZlckNsaWVudCxcbiAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih2YWwsIGN2KSB7XG4gICAgICAgICAgdmFyIGVuZHBvaW50ID0gdXNlci5yZWNlaXZlckNsaWVudC5mcm9tXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVuZHBvaW50ICYmICFlbmRwb2ludC5fcmVtb3ZlZCAmJlxuICAgICAgICAgICAgZW5kcG9pbnQuY2xvdWQgJiYgZW5kcG9pbnQgPT09IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cbiAgICAgICAgICApIHx8IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaGFzQ2FuZGlkYXRlczogeyBcbiAgICAgIHZhbDogeyBcbiAgICAgICAgdmFsOiB1c2VyLmNhbmRpZGF0ZXMuJGxlbmd0aCxcbiAgICAgICAgJGNvbnZlcnRUeXBlOiAnYm9vbGVhbidcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc0RldmljZXM6IHtcbiAgICAgIHZhbDogeyBcbiAgICAgICAgdmFsOiB1c2VyLmRldmljZXMuJGxlbmd0aCxcbiAgICAgICAgJGNvbnZlcnRUeXBlOiAnYm9vbGVhbidcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzQWN0aXZlOiB7XG4gICAgICB2YWw6IHtcbiAgICAgICAgZGVmZXI6IGZ1bmN0aW9uKHVwZGF0ZSwgYXJncyl7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tIGlzQWN0aXZlIGNoZWNrIGRhdCEnKVxuICAgICAgICAgIHZhciBvcmlnaW4gPSBhcmdzWzJdIHx8IHRoaXMuX3VwZGF0ZU9yaWdpblxuICAgICAgICAgIGlmKCFvcmlnaW4gfHwgXG4gICAgICAgICAgICAgIShvcmlnaW4uX3Byb3AgfHwgb3JpZ2luLl9uYW1lID09PSAnYWN0aXZlQ2xpZW50JylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ25vIGJsb2NraXQnLCBcbiAgICAgICAgICAgIC8vICAgb3JpZ2luLl9wYXRoLFxuICAgICAgICAgICAgLy8gICBvcmlnaW4sXG4gICAgICAgICAgICAvLyAgICdcXG52YWw6JywgYXJnc1swXVxuICAgICAgICAgICAgLy8gKVxuICAgICAgICAgICAgdXBkYXRlKHRydWUpXG4gICAgICAgICAgICAvLyByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc3RhbXAgPSBhcmdzWzFdXG5cbiAgICAgICAgICBpZihzdGFtcCkge1xuICAgICAgICAgICAgaWYoc3RhbXAgIT09ICdjbGVhbnVwJykge1xuICAgICAgICAgICAgICBpZih1c2VyLl9oYW5kbGVPbGRJc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgIGlmKCB1c2VyLl93YXNBY3RpdmUgJiYgXG4gICAgICAgICAgICAgICAgICAgICEoIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luICYmIFxuICAgICAgICAgICAgICAgICAgICAgICB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbi5fdmFsXG4gICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2kgd2FzIGFjdGl2ZUNsaWVudCBmb3IgdGhpcyBndXkgUkVTRVQnKVxuICAgICAgICAgICAgICAgICAgdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gPSB1c2VyLmNsb3VkLmNsaWVudC5fdmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVzZXIuX2hhbmRsZU9sZElzQWN0aXZlID0gbnVsbFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICAgIHVzZXIuX3dhc0FjdGl2ZSA9IHRoaXMudmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2dvIHVwZGF0ZSEnKVxuICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH0sXG4gICAgICAgIHZhbDogdXNlci5hY3RpdmVDbGllbnQsXG4gICAgICAgIC8vICRidWJibGU6IHtcbiAgICAgICAgLy8gICByZWZlcmVuY2VzOiAyXG4gICAgICAgIC8vIH0sXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gKGMsIGN2KSB7XG4gICAgICAgICAgdmFyIGVuZHBvaW50ID0gdXNlci5hY3RpdmVDbGllbnQuZnJvbVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAoZW5kcG9pbnQgJiYgZW5kcG9pbnQudmFsID09PSB0cnVlKSB8fFxuICAgICAgICAgICAgZW5kcG9pbnQgPT09IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cbiAgICAgICAgICApIHx8IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2V0UmVjZWl2ZXI6IHtcbiAgICAgIHR5cGU6IGZhbHNlLFxuICAgICAgdmFsOiBmdW5jdGlvbihjbGllbnQpIHtcbiAgICAgICAgdmFyIHVzZXIgPSB0aGlzXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3NldFJlY2VpdmVyIGNhbGxlZCBsb2wnKVxuICAgICAgICBjbGllbnQgPSBjbGllbnQuZnJvbVxuICAgICAgICBpZighY2xpZW50KSByZXR1cm5cblxuICAgICAgICB2YXIgY2FzdHR5cGUgPSBjbGllbnQuY2FzdCAmJiBjbGllbnQuY2FzdC52YWxcblxuICAgICAgICBpZihjYXN0dHlwZSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRSZWNlaXZlciEgdXNlci5jYXN0W2Nhc3R0eXBlXScsIHVzZXIuY2FzdFtjYXN0dHlwZV0pXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3NldFJlY2VpdmVyISB1c2VyLmNhc3RbY2FzdHR5cGVdLnNldFJlY2VpdmVyJywgdXNlci5jYXN0W2Nhc3R0eXBlXS5zZXRSZWNlaXZlcilcbiAgICAgICAgICB1c2VyLmNhc3RbY2FzdHR5cGVdLnNldFJlY2VpdmVyKGNsaWVudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGllbnQuc2V0KCd0b2tlbicsIHVzZXIudG9rZW4udmFsKVxuICAgICAgICAgIHVzZXIucmVjZWl2ZXJDbGllbnQuJHVzZXJPcmlnaW4gPSBjbGllbnRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgXG4gIC8vIERFQlVHOlxuICAvLyB1c2VyLmFjdGl2ZUNsaWVudC5vbihmdW5jdGlvbigpe1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoJ2FjdGl2ZUNsaWVudCBoYXBwZW5pbiEnLCB0aGlzLmZyb20gJiYgdGhpcy5mcm9tLnRvU3RyaW5nKCkpXG4gIC8vIH0pXG4gIFxuICAvLyB1c2VyLmhhc1JlY2VpdmVyLm9uKGZ1bmN0aW9uKCl7XG4gIC8vICAgY29uc29sZS5lcnJvcignbG9sIGhhc1JlY2VpdmVyIGxpc3RlbmVyIGZpcmVzISB2YWw6JywgdGhpcy52YWwpXG4gIC8vIH0pXG4gIC8vIHVzZXIuaXNSZWNlaXZlci5vbihmdW5jdGlvbigpe1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoJ2xvbCBpc1JlY2VpdmVyIGxpc3RlbmVyIGZpcmVzISB2YWw6JywgdGhpcy52YWwpXG4gIC8vIH0pXG4gIC8vIHVzZXIuYWN0aXZlQ2xpZW50Lm9uKGZ1bmN0aW9uKCl7XG4gIC8vICAgY29uc29sZS5lcnJvcignbG9sIGFjdGl2ZUNsaWVudCBsaXN0ZW5lciBmaXJlcyEgdmFsOlxcbicsIHRoaXMuZnJvbS50b1N0cmluZygpKVxuICAvLyB9KVxuXG4gIC8vIGxpc3RlbmVyczpcblxuICAvLyBvbiBhY3Rpdml0eTogbWFrZSBtZSBhY3RpdmVDbGllbnRcbiAgaWYoIWNhc2VzLiRpc0Nocm9tZWNhc3QgJiYgIUlOQUNUSVZFKSB7XG4gICAgdmFyIGFjdGl2ZUV2ZW50ID0gY2FzZXMuJGlzVHYgPyAna2V5ZG93bicgOiAnZG93bidcbiAgICBldmVudHMuZG9jdW1lbnQuYWRkRXZlbnQoYWN0aXZlRXZlbnQsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmKCB1c2VyLmNsb3VkLmNsaWVudC5fdmFsICYmXG4gICAgICAgICAgIShjYXNlcy4kaXNGdWxsc2NyZWVuICYmIGNhc2VzLiRpc0Z1bGxzY3JlZW4udmFsKVxuICAgICAgICApIHtcbiAgICAgICAgdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gPSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG4gICAgICB9XG4gICAgfSkgIFxuICB9XG4gIFxuXG4gIC8vIHJlLWVzdGFibGlzaCBvbGQgc2V0dXAgYWZ0ZXIgcmVjb25uZWN0XG4gIHVzZXIuY2xvdWQub24oJ3dlbGNvbWUnLCBmdW5jdGlvbigpe1xuICAgIGlmKHVzZXIuY2xvdWQuX3N0YXR1cyA+IDIpe1xuICAgICAgdXNlci5faGFuZGxlT2xkSXNBY3RpdmUgPSB0cnVlXG4gICAgICB1c2VyLl9oYW5kbGVPbGRJc1JlY2VpdmVyID0gdHJ1ZVxuICAgICAgdXNlci5jbG91ZC5kYXRhLm9uY2UoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29rIGdvIHJlc2V0IGRhdCBvbGQgc2l0dWF0aW9uJylcbiAgICAgICAgdXNlci5pc0FjdGl2ZS51cGRhdGUoKVxuICAgICAgICB1c2VyLmlzUmVjZWl2ZXIudXBkYXRlKClcbiAgICAgIH0pXG4gICAgfVxuICB9KVxuXG4gIC8qXG4gICogd2hlbiBJIGJlY29tZSBhY3RpdmUsIHVuc2V0IG15c2VsZiBhcyByZWNlaXZlclxuICAqIGFuZCBpZiBub3QgaXBsb2dpbiA+IHNlbGVjdCBuZXcgcmVjZWl2ZXJcbiAgKi9cbiAgdXNlci5pc0FjdGl2ZS5vbih0cnVlLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXNSZWNlaXZlciA9IHVzZXIuaXNSZWNlaXZlci52YWxcbiAgICAvLyBjb25zb2xlLmxvZygnaXNSZWNlaXZlcj8hJywgaXNSZWNlaXZlcilcblxuICAgIGlmKHVzZXIuaGFzQ2FuZGlkYXRlcy52YWwpIHsgLy8gICYmICF1c2VyLmlwbG9naW4udmFsXG4gICAgICAvLyBjb25zb2xlLmxvZygndXNlci5oYXNDYW5kaWRhdGVzLnZhbCcsIHVzZXIuaGFzQ2FuZGlkYXRlcy52YWwpXG4gICAgICAvLyBjb25zb2xlLmxvZygnaXNSZWNlaXZlcicsIFxuICAgICAgLy8gICBpc1JlY2VpdmVyLCBcbiAgICAgIC8vICAgJ1xcbnVzZXIuaGFzUmVjZWl2ZXIudmFsJywgdXNlci5oYXNSZWNlaXZlci52YWxcbiAgICAgIC8vICAgKVxuICAgICAgaWYoaXNSZWNlaXZlciB8fCAhdXNlci5oYXNSZWNlaXZlci52YWwpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29rIHNlbGVjdCByZWNlaXZlciBiZWNhdXNlIGkgYmVjYW1lIGFjdGl2ZSEnKVxuICAgICAgICB2YXIgbmV3cmVjZWl2ZXIgPSBzZWxlY3RSZWNlaXZlcih1c2VyLCB1c2VyLmNhbmRpZGF0ZXMpXG4gICAgICAgIGlmKG5ld3JlY2VpdmVyKSB7XG4gICAgICAgICAgLy8gd2FpdCBmb3IgbXkgb3duIGlzYWN0aXZlIHNldFxuICAgICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgICAgdXNlci5zZXRSZWNlaXZlcihuZXdyZWNlaXZlcilcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2UgaWYoaXNSZWNlaXZlcikge1xuICAgICAgICAgIHVzZXIucmVjZWl2ZXJDbGllbnQuJHVzZXJPcmlnaW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoaXNSZWNlaXZlcil7XG4gICAgICB1c2VyLnJlY2VpdmVyQ2xpZW50LiR1c2VyT3JpZ2luID0gbnVsbFxuICAgIH1cbiAgfSkgIFxuICBcblxuICAvLyB3aGVuIHJlY2VpdmVyIGxlYXZlcywgSSBtaWdodCBoYXZlIHRvIGJlY29tZSB0aGUgbmV3IHJlY2VpdmVyXG4gIGlmKGNhc2VzLiRpc0NhbmRpZGF0ZSkge1xuICAgIHVzZXIuaGFzUmVjZWl2ZXIub24oMCwgZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSl7XG4gICAgICBpZihzdGFtcCA9PT0gdXNlci5jbG91ZC5zdGFtcCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygneWVzIHVwZGF0ZSBpcyBvaycpXG4gICAgICAgIGlmKCF1c2VyLmlzQWN0aXZlLnZhbCl7XG4gICAgICAgICAgLy8gd2FpdCBmb3IgYWxsIHJlbW92ZXMgdG8gZmluaXNoXG4gICAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAvLyBzZWxlY3QgcmVjZWl2ZXJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdvayBzZWxlY3QgcmVjZWl2ZXIgYmVjYXVzZSByZWNlaXZlciBsZWZ0IScpXG4gICAgICAgICAgICB2YXIgbmV3cmVjZWl2ZXIgPSBzZWxlY3RSZWNlaXZlcih1c2VyLCB1c2VyLmNsaWVudHMpXG4gICAgICAgICAgICAvLyBpZiBpdHMgbWUgPiB1cGRhdGUgdXNlclxuICAgICAgICAgICAgaWYobmV3cmVjZWl2ZXIgPT09IHVzZXIuY2xvdWQuY2xpZW50LmZyb20pIHtcbiAgICAgICAgICAgICAgdXNlci5zZXRSZWNlaXZlcihuZXdyZWNlaXZlcilcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpIGFtIG5vdCBuZXcgcmVjZWl2ZXIhIG5ld3JlY2VpdmVyIGlzJywgbmV3cmVjZWl2ZXIgJiYgbmV3cmVjZWl2ZXIucmF3KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGUgbm90IGZyb20gdGhlIGNsb3VkJylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gd2hlbiBhIHR2IGpvaW5zLCBJIG1pZ2h0IHdhbnQgdG8gZ3JhYiBpdFxuICBpZighdXNlci5pcGxvZ2luLnZhbCl7XG4gICAgdXNlci5jYW5kaWRhdGVzLm9uKGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQpe1xuICAgICAgLy8gY29uc29sZS5lcnJvcignLS0tLS0tLS0gY2hlY2sgZm9yIHR2IGpvaW5lclxcbicsXG4gICAgICAvLyAgICd1c2VyLmhhc0NhbmRpZGF0ZXMudmFsJywgdXNlci5oYXNDYW5kaWRhdGVzLnZhbCwgJ1xcbicsXG4gICAgICAvLyAgICd1c2VyLmlzQWN0aXZlLnZhbCcsIHVzZXIuaXNBY3RpdmUudmFsLCAnXFxuJyxcbiAgICAgIC8vICAgJ3VzZXIuaW5pdGlhbGlzZWQnLCB1c2VyLmluaXRpYWxpc2VkXG4gICAgICAvLyApXG4gICAgICAvLyBjb25zb2xlLmxvZyh1c2VyLmNhbmRpZGF0ZXMudG9TdHJpbmcoKSlcbiAgICAgIGlmKHVzZXIuaGFzQ2FuZGlkYXRlcy52YWwgJiYgdXNlci5pc0FjdGl2ZS52YWwgJiZcbiAgICAgICAgICB1c2VyLmluaXRpYWxpc2VkXG4gICAgICAgICkge1xuICAgICAgICBncmFiVFYodXNlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ25vIGNhbmRpZGF0ZXMnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICBcbiAgLy8gbWFrZSBjYXNlc1xuICBjYXNlcy4kaXNBY3RpdmUgPSB1c2VyLmlzQWN0aXZlXG4gIC8vIGNhc2VzLiRoYXNDYW5kaWRhdGVzID0gdXNlci5oYXNDYW5kaWRhdGVzXG4gIGNhc2VzLiRoYXNEZXZpY2VzID0gdXNlci5oYXNEZXZpY2VzXG4gIGNhc2VzLiRoYXNSZWNlaXZlciA9IHVzZXIuaGFzUmVjZWl2ZXJcbiAgY2FzZXMuJGlzUmVjZWl2ZXIgPSB1c2VyLmlzUmVjZWl2ZXJcblxuXG59KVxuXG4vLyBjbGllbnRzXG5mdW5jdGlvbiB1cGRhdGVDbGllbnRzKCkge1xuICB0aGlzLmNsaWVudHMudXBkYXRlKClcbn1cblxuZnVuY3Rpb24gc2V0Q2xpZW50cyAoKSB7XG4gIHZhciB1c2VyID0gdGhpc1xuICB2YXIgbGlua2VkID0gdXNlci5kYXRhLl92YWxcblxuICAvLyBjbGllbnRzXG4gIHZhciBsaW5rZWRjbGllbnRzID0gbGlua2VkLmdldCgnY2xpZW50cycpXG4gIC8vIGNhY2hlIG9sZCwgc2V0IG5ldywgYW5kIHJlbW92ZSBsaXN0ZW5lciBpZiBjYWNoZWQgb2xkXG4gIHZhciBvbGRjbGllbnRzID0gdXNlci5jbGllbnRzLl92YWxcbiAgdXNlci5jbGllbnRzID0gbGlua2VkY2xpZW50c1xuICBsaW5rZWRjbGllbnRzLmFkZExpc3RlbmVyKFt1cGRhdGVDbGllbnRzLCB1c2VyXSwgdHJ1ZSlcbiAgaWYoIG9sZGNsaWVudHMgKSB7XG4gICAgb2xkY2xpZW50cy5yZW1vdmVMaXN0ZW5lcih1cGRhdGVDbGllbnRzLCB1c2VyKVxuICB9XG5cbiAgLy8gY2FuZGlkYXRlc1xuICAvLyBjYWNoZSBwcmV2aW91c2UgdmFsdWVcbiAgdmFyIG9sZGNhbmRpZGF0ZXMgPSB1c2VyLmNhbmRpZGF0ZXMgJiYgdXNlci5jYW5kaWRhdGVzLl92YWxcbiAgLy8gbWFrZSBjYW5kaWRhdGVzXG4gIHZhciBjYW5kaWRhdGVzID0gdXNlci5jYW5kaWRhdGVzID0gbmV3IERhdGEoIGxpbmtlZGNsaWVudHMsIHtcbiAgICBjb25kaXRpb246IHsgXG4gICAgICBkZXZpY2U6IHtcbiAgICAgICAgJGNvbnRhaW5zOiAnKGRlc2t0b3ApfCh0dil8KGNhc3QpfCh0YWJsZXQpfChhaXJwbGF5KSdcbiAgICAgIH0sXG4gICAgICBrZXk6IHtcbiAgICAgICAgJGV4aXN0czogdHJ1ZSxcbiAgICAgICAgJG5lOiB0aGlzLmNsb3VkLmNsaWVudGlkXG4gICAgICB9XG4gICAgfVxuICB9KVxuICAvLyBhZGQgbGlzdGVuZXIgYmVjYXVzZSBvZiByZWFzb25zXG4gIGNhbmRpZGF0ZXMub24oZnVuY3Rpb24oKXtcbiAgICB1c2VyLmNhbmRpZGF0ZXMudXBkYXRlKClcbiAgfSlcbiAgLy8gY2xlYW4gdXAgZGF0IG9sZCBzZWxlY3Rpb25cbiAgaWYob2xkY2FuZGlkYXRlcykge1xuICAgIG9sZGNhbmRpZGF0ZXMucmVtb3ZlKClcbiAgfVxuICBcbiAgLy8gc2libGluZ3NcbiAgLy8gY2FjaGUgcHJldmlvdXNlIHZhbHVlXG4gIHZhciBvbGRzaWJsaW5ncyA9IHVzZXIuc2libGluZ3MgJiYgdXNlci5zaWJsaW5ncy5fdmFsXG4gIC8vIG1ha2Ugc2libGluZ3NcbiAgdmFyIHNpYmxpbmdzID0gdXNlci5zaWJsaW5ncyA9IG5ldyBEYXRhKCBsaW5rZWRjbGllbnRzLCB7XG4gICAgY29uZGl0aW9uOiB7XG4gICAgICBrZXk6IHtcbiAgICAgICAgJGV4aXN0czogdHJ1ZSxcbiAgICAgICAgJG5lOiB0aGlzLmNsb3VkLmNsaWVudGlkXG4gICAgICB9XG4gICAgfVxuICB9KVxuICAvLyBhZGQgbGlzdGVuZXIgYmVjYXVzZSBvZiByZWFzb25zXG4gIHNpYmxpbmdzLm9uKGZ1bmN0aW9uKCl7XG4gICAgLy8gY29uc29sZS5sb2coJ3VwZGF0ZSBvbiBjYW5kaWRhdGVzID4gdXBkYXRlIHVzZXIuY2FuZGlkYXRlcycpXG4gICAgdXNlci5zaWJsaW5ncy51cGRhdGUoKVxuICB9KVxuICAvLyBjbGVhbiB1cCBkYXQgb2xkIHNlbGVjdGlvblxuICBpZihvbGRzaWJsaW5ncykge1xuICAgIG9sZHNpYmxpbmdzLnJlbW92ZSgpXG4gIH1cbn1cblxuLy8gYWN0aXZlQ2xpZW50XG5cbnZhciBhY1JlbW92ZVRhcmdldFxudmFyIGFjQWRkZWRUYXJnZXRcblxuZnVuY3Rpb24gc2V0TW9ja19hY3RpdmVDbGllbnQgKCkge1xuICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tLSBzZXRNb2NrX2FjdGl2ZUNsaWVudCEnKVxuXG4gIHZhciB1c2VyID0gdGhpc1xuXG4gIGlmKGFjUmVtb3ZlVGFyZ2V0KSB7XG4gICAgYWNSZW1vdmVUYXJnZXQucmVtb3ZlTGlzdGVuZXIoYWNSZW1vdmVDaGVjaywgdXNlcilcbiAgICBhY1JlbW92ZVRhcmdldCA9IG51bGxcbiAgfVxuICBpZihhY0FkZGVkVGFyZ2V0KSB7XG4gICAgYWNBZGRlZFRhcmdldC5yZW1vdmVMaXN0ZW5lcihhY0FkZGVkQ2hlY2ssIHVzZXIpXG4gICAgYWNBZGRlZFRhcmdldCA9IG51bGxcbiAgfVxuXG4gIHZhciBsaW5rZWQgPSB1c2VyLmRhdGEuX3ZhbFxuXG4gIHVzZXIuYWN0aXZlQ2xpZW50ID0gbGlua2VkLmdldCgnYWN0aXZlQ2xpZW50Jywge30pXG4gIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luID0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuXG59XG5cblxuXG5mdW5jdGlvbiBzZXRVc2VyX2FjdGl2ZUNsaWVudCAoKSB7XG4gIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tIHNldFVzZXJfYWN0aXZlQ2xpZW50IScpXG5cbiAgdmFyIHVzZXIgPSB0aGlzXG5cbiAgLy8gY29uc29sZS5sb2coJ2RhdCBhY3RpdmVDbGllbnQ6JywgXG4gIC8vICAgdXNlci5kYXRhLl92YWwuYWN0aXZlQ2xpZW50XG4gIC8vICAgPyAneWVzIGFjdGl2ZWNsaWVudFxcbicgKyB1c2VyLmRhdGEuX3ZhbC5hY3RpdmVDbGllbnQudG9TdHJpbmcoKVxuICAvLyAgIDogJ25vIGFjdGl2ZUNsaWVudCBpbiBtYSBuZXcgdXNlciEhXFxuJyArIHVzZXIuZGF0YS5fdmFsLnRvU3RyaW5nKClcbiAgLy8gKVxuXG4gIGlmKGFjQWRkZWRUYXJnZXQpIHtcbiAgICBhY0FkZGVkVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGFjQWRkZWRDaGVjaywgdXNlcilcbiAgICBhY0FkZGVkVGFyZ2V0ID0gbnVsbFxuICB9XG4gIFxuICB2YXIgbGlua2VkID0gdXNlci5kYXRhLl92YWxcbiAgdmFyIGxpbmtlZFJlZiA9IGxpbmtlZC5nZXQoJ2FjdGl2ZUNsaWVudCcsIHt9KVxuXG4gIGlmKGFjUmVtb3ZlVGFyZ2V0KSB7XG4gICAgYWNSZW1vdmVUYXJnZXQucmVtb3ZlTGlzdGVuZXIoYWNSZW1vdmVDaGVjaywgdXNlcilcbiAgfVxuICBhY1JlbW92ZVRhcmdldCA9IGxpbmtlZFJlZlxuICBhY1JlbW92ZVRhcmdldC5hZGRMaXN0ZW5lcihbYWNSZW1vdmVDaGVjaywgdXNlcl0sIHRydWUpXG5cbiAgdXNlci5hY3RpdmVDbGllbnQgPSBsaW5rZWRSZWZcbiAgXG4gIC8vIGNvbnNvbGUuZXJyb3IoJ1VTRVJTV0lUQ0ggQUNUSVZFQ0xJRU5UJylcbiAgaWYoIUlOQUNUSVZFKXtcbiAgICBpZihjYXNlcy4kaXNUdikge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignSU0gVFYgVVNFUlNXSVRDSCBXQVQgVE8gRE8nKVxuICAgICAgLy8gdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gPSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG4gICAgICAvLyBUT0RPOiBmaXggdGhpczpcbiAgICAgIHZhciBhY3RpdmVDbGllbnQgPSBsaW5rZWRSZWYuZnJvbVxuICAgICAgLy8gY29uc29sZS5lcnJvcignYWN0aXZlQ2xpZW50IGlzJywgYWN0aXZlQ2xpZW50KVxuICAgICAgLy8gY29uc29sZS5sb2coJ2kgYW0nLCB1c2VyLmNsb3VkLmNsaWVudC5mcm9tLnJhdylcbiAgICAgIGlmKCEoYWN0aXZlQ2xpZW50ICYmIGFjdGl2ZUNsaWVudC5fbmFtZSAhPT0gJ2FjdGl2ZUNsaWVudCcpKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3NldCBtYXNlbGYgYWN0aXZlJylcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignU0VUIE1FIFRPIERBVCBhY3RpdmVDbGllbnQgKFRWKScpXG4gICAgICAgIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luID0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuICAgICAgfWVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndWRwYXRlIGFjdGl2ZUNsaWVudCBiZWNhdXNlIGRvIGl0JylcbiAgICAgICAgdXNlci5hY3RpdmVDbGllbnQudXBkYXRlKClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoIWNhc2VzLiRpc0Nocm9tZWNhc3QpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1NFVCBNRSBUTyBEQVQgYWN0aXZlQ2xpZW50JylcbiAgICAgIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luID0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuICAgIH1cbiAgfVxuICBcblxuICBpZih1c2VyLmhhc0NhbmRpZGF0ZXMudmFsKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2NoZWNrIGZvciB0diB0byBncmFiIG9uIHNldFVzZXJfYWN0aXZlQ2xpZW50JylcbiAgICBncmFiVFYodXNlcilcbiAgfVxuXG4gIHVzZXIuYWN0aXZlQ2xpZW50LnVwZGF0ZSgpXG5cbn1cbmZ1bmN0aW9uIGFjUmVtb3ZlQ2hlY2sgKGZpcmVyLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUpIHtcbiAgdmFyIHVzZXIgPSB0aGlzXG4gIGlmKGZpcmVyLl9yZW1vdmVkKSB7XG4gICAgaWYoYWNBZGRlZFRhcmdldCkge1xuICAgICAgYWNBZGRlZFRhcmdldC5yZW1vdmVMaXN0ZW5lcihhY0FkZGVkQ2hlY2ssIHVzZXIpXG4gICAgfVxuICAgIGFjQWRkZWRUYXJnZXQgPSBmaXJlci5fcGFyZW50XG4gICAgYWNBZGRlZFRhcmdldC5hZGRMaXN0ZW5lcihbYWNBZGRlZENoZWNrLCB1c2VyXSwgdHJ1ZSlcbiAgfVxufVxuZnVuY3Rpb24gYWNBZGRlZENoZWNrIChmaXJlciwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCkge1xuICB2YXIgdXNlciA9IHRoaXMsXG4gICAgbGlua2VkdXNlciA9IGZpcmVyXG5cbiAgaWYobGlua2VkdXNlci5hY3RpdmVDbGllbnQpe1xuICAgIGFjQWRkZWRUYXJnZXQucmVtb3ZlTGlzdGVuZXIoYWNBZGRlZENoZWNrLCB1c2VyKVxuICAgIGFjQWRkZWRUYXJnZXQgPSBudWxsXG4gICAgXG4gICAgYWNSZW1vdmVUYXJnZXQgPSBsaW5rZWR1c2VyLmFjdGl2ZUNsaWVudFxuICAgIGFjUmVtb3ZlVGFyZ2V0LmFkZExpc3RlbmVyKFthY1JlbW92ZUNoZWNrLCB1c2VyXSwgdHJ1ZSlcblxuICAgIHVzZXIuYWN0aXZlQ2xpZW50ID0gbGlua2VkdXNlci5hY3RpdmVDbGllbnRcbiAgfVxufVxuXG4vLyByZWNlaXZlckNsaWVudFxudmFyIHJjQWRkZWRUYXJnZXRcbnZhciByY1JlbW92ZVRhcmdldFxuXG5mdW5jdGlvbiBzZXRNb2NrX3JlY2VpdmVyQ2xpZW50ICgpIHtcbiAgdmFyIHVzZXIgPSB0aGlzXG5cbiAgaWYocmNBZGRlZFRhcmdldCkge1xuICAgIHJjQWRkZWRUYXJnZXQucmVtb3ZlTGlzdGVuZXIocmNBZGRlZENoZWNrLCB1c2VyKVxuICB9XG4gIGlmKHJjUmVtb3ZlVGFyZ2V0KSB7XG4gICByY1JlbW92ZVRhcmdldC5yZW1vdmVMaXN0ZW5lcihyY1JlbW92ZUNoZWNrLCB1c2VyKSBcbiAgfVxuXG4gIHZhciBsaW5rZWQgPSB1c2VyLmRhdGEuX3ZhbFxuICB1c2VyLnJlY2VpdmVyQ2xpZW50ID0gbGlua2VkLmdldCgncmVjZWl2ZXJDbGllbnQnLCBmYWxzZSlcbn1cbmZ1bmN0aW9uIHNldFVzZXJfcmVjZWl2ZXJDbGllbnQgKCkge1xuICB2YXIgdXNlciA9IHRoaXNcblxuICBpZihyY0FkZGVkVGFyZ2V0KSB7XG4gICAgcmNBZGRlZFRhcmdldC5yZW1vdmVMaXN0ZW5lcihyY0FkZGVkQ2hlY2ssIHVzZXIpXG4gICAgcmNBZGRlZFRhcmdldCA9IG51bGxcbiAgfVxuXG4gIHZhciBsaW5rZWQgPSB1c2VyLmRhdGEuX3ZhbFxuICB2YXIgbGlua2VkUmVmID0gbGlua2VkLmdldCgncmVjZWl2ZXJDbGllbnQnLCB7fSlcblxuICBpZihyY1JlbW92ZVRhcmdldCkge1xuICAgIHJjUmVtb3ZlVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHJjUmVtb3ZlQ2hlY2ssIHVzZXIpXG4gIH1cbiAgcmNSZW1vdmVUYXJnZXQgPSBsaW5rZWRSZWZcbiAgcmNSZW1vdmVUYXJnZXQuYWRkTGlzdGVuZXIoW3JjUmVtb3ZlQ2hlY2ssIHVzZXJdLCB0cnVlKVxuXG4gIHVzZXIucmVjZWl2ZXJDbGllbnQgPSBsaW5rZWRSZWZcblxuICBpZihjYXNlcy4kaXNUdikge1xuICAgIC8vIHNldCB0diB0byByZWNlaXZlciBpZiBhY3RpdmVjbGllbnQgYW5kIG5vIHJlY2VpdmVyXG4gICAgdmFyIGFjdGl2ZUNsaWVudCA9IHVzZXIuYWN0aXZlQ2xpZW50LmZyb21cbiAgICBpZiggYWN0aXZlQ2xpZW50ICYmIGFjdGl2ZUNsaWVudC5fX3QgPT09IDIgJiZcbiAgICAgICAgYWN0aXZlQ2xpZW50ICE9PSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tICYmXG4gICAgICAgICF1c2VyLmhhc1JlY2VpdmVyLnZhbFxuICAgICAgKSB7XG4gICAgICB1c2VyLnNldFJlY2VpdmVyKHVzZXIuY2xvdWQuY2xpZW50LmZyb20pXG4gICAgfVxuICB9IGVsc2UgaWYgKGNhc2VzLiRpc0Nocm9tZWNhc3QpIHtcbiAgICAvLyBhbHdheXMgc2V0IGNocm9tZWNhc3QgdG8gcmVjZWl2ZXJcbiAgICB1c2VyLnNldFJlY2VpdmVyKHVzZXIuY2xvdWQuY2xpZW50LmZyb20pXG4gIH1cblxufVxuZnVuY3Rpb24gcmNSZW1vdmVDaGVjayAoZmlyZXIsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSkge1xuICB2YXIgdXNlciA9IHRoaXNcbiAgaWYoZmlyZXIuX3JlbW92ZWQpIHtcbiAgICBpZihyY0FkZGVkVGFyZ2V0KSB7XG4gICAgICByY0FkZGVkVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHJjQWRkZWRDaGVjaywgdXNlcilcbiAgICB9XG4gICAgcmNBZGRlZFRhcmdldCA9IGZpcmVyLl9wYXJlbnRcbiAgICByY0FkZGVkVGFyZ2V0LmFkZExpc3RlbmVyKFtyY0FkZGVkQ2hlY2ssIHVzZXJdLCB0cnVlKVxuICB9XG59XG5mdW5jdGlvbiByY0FkZGVkQ2hlY2sgKGZpcmVyLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkKSB7XG4gIHZhciB1c2VyID0gdGhpcyxcbiAgICBsaW5rZWR1c2VyID0gZmlyZXJcblxuICBpZihsaW5rZWR1c2VyLnJlY2VpdmVyQ2xpZW50KXtcbiAgICByY0FkZGVkVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHJjQWRkZWRDaGVjaywgdXNlcilcbiAgICByY0FkZGVkVGFyZ2V0ID0gbnVsbFxuXG4gICAgcmNSZW1vdmVUYXJnZXQgPSBsaW5rZWR1c2VyLnJlY2VpdmVyQ2xpZW50XG4gICAgcmNSZW1vdmVUYXJnZXQuYWRkTGlzdGVuZXIoW3JjUmVtb3ZlQ2hlY2ssIHVzZXJdLCB0cnVlKVxuXG4gICAgdXNlci5yZWNlaXZlckNsaWVudCA9IGxpbmtlZHVzZXIucmVjZWl2ZXJDbGllbnRcbiAgfVxufVxuLy8gcmVjZWl2ZXJcbmZ1bmN0aW9uIHNldE1vY2tfcmVjZWl2ZXIgKCkge1xuICB2YXIgdXNlciA9IHRoaXNcbiAgbGlua1JlY2VpdmVyKHVzZXIpXG59XG5mdW5jdGlvbiBzZXRVc2VyX3JlY2VpdmVyICgpIHtcbiAgdmFyIHVzZXIgPSB0aGlzXG4gIGxpbmtSZWNlaXZlcih1c2VyKVxufVxuZnVuY3Rpb24gbGlua1JlY2VpdmVyICh1c2VyKSB7XG4gIHZhciBsaW5rZWQgPSB1c2VyLmRhdGEuX3ZhbFxuICAgICwgbGlua2VkcmVjZWl2ZXIgPSBsaW5rZWQuZ2V0KCdyZWNlaXZlcicsIHt9KVxuXG4gIHVzZXIucmVjZWl2ZXIgPSB7XG4gICAgdm9sdW1lOiBsaW5rZWRyZWNlaXZlci5nZXQoJ3ZvbHVtZScsIDEpLFxuICAgIG1lZGlhOiBsaW5rZWRyZWNlaXZlci5nZXQoJ21lZGlhJywgZmFsc2UpLFxuICAgIHBsYXlpbmc6IGxpbmtlZHJlY2VpdmVyLmdldCgncGxheWluZycsIGZhbHNlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHNlbGVjdFJlY2VpdmVyKHVzZXIsIGxpc3QpIHtcbiAgLy8gY29uc29sZS5lcnJvcignXFxuXFxuPT09PT09PT09PT09PT09PT09PT09PT09PXNlbGVjdFJlY2VpdmVyISEhXFxuXFxuJylcbiAgd2hpbGUobGlzdCAmJiBsaXN0Ll9fdCA9PT0gNCAmJiAhbGlzdC5fZmlsdGVyKXtcbiAgICBsaXN0ID0gbGlzdC5fdmFsXG4gIH1cbiAgaWYoIWxpc3QpIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcignY291bGQgbm90IGRldGVybWluZSBsaXN0IHRvIHNlbGVjdCBmcm9tJylcbiAgfVxuICB2YXIgd2lubmVyXG4gIGxpc3QuZWFjaChmdW5jdGlvbigpe1xuICAgIHZhciBjbGllbnQgPSB0aGlzLl92YWxcbiAgICAvLyBzYW5pdHkgY2hlY2tcbiAgICBpZighY2xpZW50IHx8IGNsaWVudC5fcmVtb3ZlZCB8fCAhY2xpZW50LmRldmljZSkge1xuICAgICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ2JhZCBjbGllbnQnLCBcbiAgICAgICAgJ3BhdGg6JywgY2xpZW50ICYmIGNsaWVudC5fcGF0aCxcbiAgICAgICAgJ2NsaWVudDonLCBjbGllbnQgJiYgY2xpZW50LnJhdyB8fCBjbGllbnRcbiAgICAgIClcbiAgICB9XG4gICAgLy8gc2tpcCBpZiBjbGllbnQgaXMgdGhlIGFjdGl2ZUNsaWVudFxuICAgIGlmKGNsaWVudCA9PT0gdXNlci5hY3RpdmVDbGllbnQuZnJvbSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBkZXZpY2UgPSBjbGllbnQuZGV2aWNlLnZhbFxuICAgIC8vIHNraXAgaWYgY2xpZW50IGlzIG5vdCBhIGNhbmRpZGF0ZVxuICAgIGlmKCFkZXZpY2VJc0NhbmRpZGF0ZS50ZXN0KGRldmljZSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHNraXAgaWYgY2xpZW50IGlzIGluIHVzZSBieSBvdGhlciB1c2VyXG4gICAgaWYoY2xpZW50LnRva2VuICYmIGNsaWVudC50b2tlbi52YWwgIT09IHVzZXIudG9rZW4udmFsKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gY2xpZW50IGlzIGEgcG9zc2libGUgd2lubmVyXG4gICAgd2lubmVyID0gY2xpZW50XG4gICAgLy8gc3RpY2sgaWYgY2xpZW50IGlzIHR2LWxpa2VcbiAgICBpZihkZXZpY2VJc1R2TGlrZS50ZXN0KGRldmljZSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9KVxuICAvLyBjb25zb2xlLmVycm9yKCdcXG5cXG49PT09PT09PT09PT09PT09PT09PT09PT09IHdpbm5lcjonLHdpbm5lcix1c2VyLmNsb3VkLmNsaWVudGlkLCdcXG5cXG4nKVxuXG4gIHJldHVybiB3aW5uZXJcbn1cblxuZnVuY3Rpb24gZ3JhYlRWKHVzZXIpe1xuICAvLyBjb25zb2xlLmVycm9yKCc9PT09PT09PT09PT09IGdyYWJUViEnKVxuICB1c2VyLmNhbmRpZGF0ZXMuX3ZhbC5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGNhbmRpZGF0ZSA9IHRoaXMuZnJvbVxuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2NhbmRpZGF0ZScsIFxuICAgIC8vICAgJ2RldmljZUlzVHZMaWtlJywgZGV2aWNlSXNUdkxpa2UudGVzdChjYW5kaWRhdGUuZGV2aWNlLnZhbCksXG4gICAgLy8gICAnIWNhbmRpZGF0ZS50b2tlbicsICEoY2FuZGlkYXRlLnRva2VuICYmIGNhbmRpZGF0ZS50b2tlbi52YWwpLFxuICAgIC8vICAgJ2NhbmRpZGF0ZS50b2tlbicsIChjYW5kaWRhdGUudG9rZW4gJiYgY2FuZGlkYXRlLnRva2VuLnZhbClcbiAgICAvLyApXG4gICAgaWYoY2FuZGlkYXRlLmRldmljZS52YWwgPT09ICd0dicgJiZcbiAgICAgICAgIShjYW5kaWRhdGUudG9rZW4gJiYgY2FuZGlkYXRlLnRva2VuLnZhbClcbiAgICAgICkge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignZ3JhYiBkYXQhJylcbiAgICAgIGNhbmRpZGF0ZS5zZXQoJ3Rva2VuJywgdXNlci50b2tlbi52YWwpXG4gICAgICBpZighdXNlci5oYXNSZWNlaXZlci52YWwpIHtcbiAgICAgICAgdXNlci5zZXRSZWNlaXZlcihjYW5kaWRhdGUpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG4vLyBmdW5jdGlvbiBsb2coKXtcbi8vICAgY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuXFxuXFxuJylcbi8vICAgY29uc29sZS5sb2cod2luZG93LkZMQUcsJzonKVxuLy8gICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpXG4vLyAgIGNvbnNvbGUubG9nKCdcXG5cXG5cXG5cXG4tLS0tLS0tLS0tLS0tLS0tLS0tLScpXG4vLyB9XG4vLyBsb2cuc3RhcnQgPSBmdW5jdGlvbihmbGFnKXtcbi8vICAgY29uc29sZS5sb2coJ1xcblxcblxcbj09PT09PT09PT09PT09PT09PT09PT0gU1RBUlQnLFxuLy8gICAgIHdpbmRvdy5GTEFHID8gd2luZG93LkZMQUcgOiAnJywgZmxhZywgJ1xcblxcbidcbi8vICAgKVxuLy8gfVxuLy8gbG9nLmVuZCA9IGZ1bmN0aW9uKGZsYWcpe1xuLy8gICBjb25zb2xlLmxvZygnXFxuXFxuPT09PT09PT09PT09PT09PT09PT09PSBFTkQnLFxuLy8gICAgIHdpbmRvdy5GTEFHID8gd2luZG93LkZMQUcgOiAnJywgZmxhZywgJ1xcblxcbidcbi8vICAgKVxuLy8gfVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbCcpXG52YXIgdk9iamVjdCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QnKVxudmFyIE1vY2tEYXRhID0gcmVxdWlyZSgnLi9tb2NrZGF0YScpXG5cbnJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZS9mbGFncy9wcm9jZXNzJylcblxuLy9uYXYgaXMgdGFraW5nIGNhcmUgb2Y6IFxuLy8gZG91YmxlIHVwZGF0ZXMgb24gdGhlIHNhbWUgdGhpbmcgd2l0aCB0aGUgc2FtZSB2YWx1ZSAoc3luY2luZyBpbiBpdCB0cm91Z2ggdGhlIGNsb3VkKVxuLy8gdXBkYXRpbmcgbmF2aWdhdGlvblxuLy8gbW9jayBhbmQgdXNlciBkYXRhLCBzdWJzY3JpcHRpb25zXG5cbi8vVE9ETzogYWRkIHZpZXdcblxuLy8gY29udGVudCBlbiBzd2l0Y2ggb3AgY29udGVudCBwYWtrZW5cbi8vICAgcGFnZVxuLy8gICBjb250ZW50XG4vLyBvb2sgYnViYmxlOiAxIG9wIGFsbGUgZGluZ2VuXG4vLyBmdW5jdGlvbiB1cGRhdGVOYXZpZ2F0aW9uXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmRcbiggZnVuY3Rpb24oIHVzZXIgKSB7XG5cbiAgdmFyIGNvbnRlbnQgPSB1c2VyLnBhcmVudC5pbmplY3QocmVxdWlyZSgnLi4vY29udGVudCcpKS5jb250ZW50XG5cbiAgY29udGVudC5vbignc2VsZicsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBuYXYgPSB1c2VyLm5hdmlnYXRpb25cbiAgICB2YXIgY29udGVudCA9IHRoaXNcbiAgICB2YXIgY29udGVudE5hdiA9IG5hdi5jb250ZW50LmZyb21cbiAgICB2YXIgbWlzYyA9IG5hdi5taXNjLmZyb21cblxuICAgIGlmKGNvbnRlbnROYXYuX2NvbnRlbnRQYXRoKSB7XG4gICAgICBuYXYuY29udGVudC4kdXNlck9yaWdpbi52YWwgPSBjb250ZW50LmZyb20uZ2V0KGNvbnRlbnROYXYuX2NvbnRlbnRQYXRoKSAvL0RJVCBJTiBOQVZJR0FUSU9OXG4gICAgfVxuXG4gICAgaWYobWlzYy5fY29udGVudFBhdGgpIHtcbiAgICAgIG5hdi5jb250ZW50LiR1c2VyT3JpZ2luLnZhbCA9IGNvbnRlbnQuZnJvbS5nZXQobWlzYy5fY29udGVudFBhdGgpIC8vRElUIElOIE5BVklHQVRJT05cbiAgICB9XG4gIH0pXG5cbiAgdXNlci5kZWZpbmUoe1xuICAgIHVwZGF0ZU5hdmlnYXRpb246IGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICBpZih0aGlzLm5hdmlnYXRpb24ubGFzdCAmJiB0aGlzLm5hdmlnYXRpb24ubGFzdC4kdXNlck9yaWdpbikge1xuICAgICAgICBrZXkgPSBrZXkgfHwgdGhpcy5uYXZpZ2F0aW9uLmxhc3QuJHVzZXJPcmlnaW4uZ2V0KCdrZXknKS52YWxcbiAgICAgICAgaWYoIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbltrZXldLl91cGRhdGUoIHRoaXMubmF2aWdhdGlvbltrZXldLl92YWwuX3ZhbCAsICdsJytNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqOTk5OSkgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm5hdmlnYXRpb24ucGFnZS4kdXNlck9yaWdpbiA9ICdkaXNjb3ZlcidcbiAgICB9XG4gIH0pXG5cbiAgdXNlci5leHRlbmQoe1xuICAgIG5hdmlnYXRpb246IHtcbiAgICAgIG1vY2s6IHtcbiAgICAgICAgbmF2aWdhdGlvbjogXG4gICAgICAgIHsgY29udGVudDogZmFsc2VcbiAgICAgICAgLCBwYWdlOiBmYWxzZSBcbiAgICAgICAgLCBtaXNjOiBmYWxzZVxuICAgICAgICAsIGxhc3Q6IHsga2V5OiAncGFnZScsIHRpbWU6IDAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgIG5hdmlnYXRpb246IFxuICAgICAgICB7IGNvbnRlbnQ6dHJ1ZVxuICAgICAgICAsIHBhZ2U6dHJ1ZVxuICAgICAgICAsIG1pc2M6IHRydWVcbiAgICAgICAgLCBsYXN0OiBcbiAgICAgICAgICB7IGtleTp0cnVlXG4gICAgICAgICAgLCB0aW1lOnRydWVcbiAgICAgICAgICB9XG4gICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhbDogXG4gICAgICB7IHBhZ2U6IHsgZGVmZXI6IGRlZmVyTmF2aWdhdGlvbiB9XG4gICAgICAsIGNvbnRlbnQ6IHsgZGVmZXI6IGRlZmVyTmF2aWdhdGlvbiB9XG4gICAgICAsIG1pc2M6IHsgZGVmZXI6IGRlZmVyTmF2aWdhdGlvbiB9XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgdXNlcjogZnVuY3Rpb24gbmF2aWdhdGlvblRvVXNlckRhdGEoIGtleSApIHtcblxuICAgICAgICAgIHJlc29sdmVMYXN0TGlzdGVuZXIodGhpcylcbiAgICAgICAgICBcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSB7XG4gICAgICAgICAgICBsYXN0OiB0aGlzLmRhdGEuX3ZhbC5nZXQoIFsga2V5LCAnbGFzdCcgXSApXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX19maXJzdCA9IHRydWVcblxuICAgICAgICAgIHZhciBuYXYgPSB0aGlzLm5hdmlnYXRpb25cbiAgICAgICAgICAgICwgdXNlckRhdGEgPSB0aGlzLmRhdGEuJHVzZXJPcmlnaW5cblxuICAgICAgICAgIHRoaXMuX2xhc3R1cGRhdGUgPSBmdW5jdGlvbiBsYXN0VXBkYXRlVXNlciggdmFsLCBzdGFtcCwgZnJvbSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2hleSB0aGlzIHNob3VsZCBkbyB0aGUgdXBkYXRlJylcblxuICAgICAgICAgICAgaWYoIHRoaXMua2V5ICYmIG5hdlt0aGlzLmtleS52YWxdICkgIFxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdoZXkgdGhpcyBzaG91bGQgZG8gdGhlIHVwZGF0ZSExJylcblxuICAgICAgICAgICAgICBuYXZbdGhpcy5rZXkudmFsXS4kdXNlck9yaWdpbi5fdXBkYXRlKCB2b2lkIDAsICdsJytzdGFtcCAgKVxuICAgICAgICAgICAgICBuYXYudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYXYubGFzdC5mcm9tLm9uKHRoaXMuX2xhc3R1cGRhdGUpXG5cbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdLRVknLGtleSlcbiAgICAgICAgICAvLyBkZWJ1Z2dlclxuXG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gXG4gICAgICAgICAgeyBwYWdlOiB1c2VyRGF0YS5nZXQoIFsga2V5LCAncGFnZScgXSwgJ2Rpc2NvdmVyJyApIFxuICAgICAgICAgICwgY29udGVudDogdXNlckRhdGEuZ2V0KCBbIGtleSwgJ2NvbnRlbnQnIF0gKVxuICAgICAgICAgICwgbWlzYzogdXNlckRhdGEuZ2V0KCBbIGtleSwgJ21pc2MnIF0gKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKG5hdi5sYXN0LmZyb20ua2V5KSB7XG4gICAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAgICAgbmF2Lmxhc3QuZnJvbS5fdXBkYXRlKCB2b2lkIDAsIHZPYmplY3Quc3RhbXAoKSApXG4gICAgICAgICAgfSBlbHNlIGlmKCFuYXYubGFzdC5mcm9tLmtleSkge1xuICAgICAgICAgICAgLy9ubyBwYWdlIHN3aXRjaCB0byBkZWZhdWx0ICggbWFrZSBhIGRlZmF1bHQgcG9zc2lsYmUgKVxuICAgICAgICAgICAgbmF2LnBhZ2UuJHVzZXJPcmlnaW4gPSAnZGlzY292ZXInXG4gICAgICAgICAgfVxuXG4gICAgICAgIH0sXG4gICAgICAgIG1vY2s6IGZ1bmN0aW9uIG5hdmlnYXRpb25Ub01vY2tEYXRhKCkge1xuXG4gICAgICAgICAgcmVzb2x2ZUxhc3RMaXN0ZW5lcih0aGlzKVxuICAgIFxuICAgICAgICAgIHZhciBuYXYgPSB0aGlzLm5hdmlnYXRpb25cblxuICAgICAgICAgICB2YXIgbW9jayA9IHRoaXMubW9ja2RhdGEubmF2aWdhdGlvblxuICAgICAgICAgICAgLCBzZXQgPSBcbiAgICAgICAgICAgICAgeyBwYWdlOiBtb2NrLnBhZ2VcbiAgICAgICAgICAgICAgLCBjb250ZW50OiBtb2NrLmNvbnRlbnRcbiAgICAgICAgICAgICAgLCBtaXNjOiBtb2NrLm1pc2NcbiAgICAgICAgICAgICAgLy8gLCBsYXN0OiBtb2NrLmxhc3QgXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IHsgbGFzdDogbW9jay5sYXN0IH1cblxuICAgICAgICAgIC8vVE9ETzogdGhpcyBpcyBhIHRlbXAgZml4IHNob3VsZCBnbyBiYWNrIHRvIHBhZ2UgeW91IGxvZ291dCBmcm9tIVxuICAgICAgICAgIGlmKHRoaXMuX19maXJzdCkge1xuICAgICAgICAgICAgbW9jay5wYWdlLnZhbCA9ICdkaXNjb3ZlcidcbiAgICAgICAgICB9IFxuICAgIFxuICAgICAgICAgIHRoaXMuX2xhc3R1cGRhdGUgPSBmdW5jdGlvbiBsYXN0VXBkYXRlTW9jayggdmFsLCBzdGFtcCwgZnJvbSApIHtcbiAgICAgICAgICAgIGlmKCBuYXZbdGhpcy5rZXkudmFsXSApIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYXZbdGhpcy5rZXkudmFsXS4kdXNlck9yaWdpbi5fdXBkYXRlKCB2b2lkIDAsICdsJytzdGFtcCAgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5hdi5sYXN0LmZyb20ub24oIHRoaXMuX2xhc3R1cGRhdGUgKVxuICAgICAgICAgIC8vIHZhciBuYXYgPSBob2Uga29tIGlrIGhpZXIgYWFuIG1uIHVzZXI/Pz9cbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCc/Pz8/PycsdGhpcy50b2tlbi5fbHZhbCwgdGhpcy50b2tlbi52YWwpXG4gICAgICAgICAgLy8gbmVlZCB0byB1c2Ugc2V0dGVyIChub3QgbmF2IHJlZilcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBzZXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBmdW5jdGlvbiByZXNvbHZlTGFzdExpc3RlbmVyKCB1c2VyICkge1xuICAgIGlmKCB1c2VyLl9sYXN0dXBkYXRlIFxuICAgICAgICAmJiB1c2VyLm5hdmlnYXRpb24ubGFzdCBcbiAgICAgICAgJiYgdXNlci5uYXZpZ2F0aW9uLmxhc3QuZnJvbSAhPT0gdXNlci5uYXZpZ2F0aW9uLmxhc3RcbiAgICAgKXtcbiAgICAgIHVzZXIubmF2aWdhdGlvbi5sYXN0LmZyb20ucmVtb3ZlTGlzdGVuZXIodXNlci5fbGFzdHVwZGF0ZSlcbiAgICAgIHVzZXIuX2xhc3R1cGRhdGUgPSBudWxsXG4gICAgIH1cbiAgfSAgICAgIFxuXG4gIGZ1bmN0aW9uIGRlZmVyTmF2aWdhdGlvbiggdXBkYXRlLCBhcmdzICkge1xuICAgIGlmKCBhcmdzWzFdICYmIGFyZ3NbMV1bMF0gPT09ICdsJyAmJiBcbiAgICAgIHRoaXMuX25hbWUgPT09IHRoaXMuX3BhcmVudC5sYXN0LmZyb20ua2V5LnZhbFxuICAgICkge1xuXG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgLy9UT0RPOiBtb3JlIHNwZWNpZmljIG1heSBiZSB0b28gbWFueSB1cGRhdGVzPz8/XG4gICAgICAvLyBjb25zb2xlLmxvZygnbGV6eiB1cGRhdGUgaXQnLCB0aGlzLl9wYXJlbnQuX3BhdGgsIHRoaXMuX3BhdGgpXG5cbiAgICAgIHVwZGF0ZSgpXG5cbiAgICAgIC8vIHRoaXMuX3BhcmVudC5fdXBkYXRlLmFwcGx5KCB0aGlzLl9wYXJlbnQsIGFyZ3MgKVxuXG5cbiAgICB9IFxuICAgIGVsc2UgXG4gICAge1xuICAgICAgdXBkYXRlKCB0cnVlIClcbiAgICB9XG4gIH0gXG5cbn0pXG4iLCIvL3VzZXJPcmlnaW5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgTW9ja0RhdGEgPSByZXF1aXJlKCcuL21vY2tkYXRhJylcbiAgLCB0aW1lc3RhbXAgPSByZXF1aXJlKCdtb25vdG9uaWMtdGltZXN0YW1wJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZCggZnVuY3Rpb24oIHZPYmplY3QgKSB7XG5cbiAgdmFyIF9jb3JlU2V0ID0gdk9iamVjdC5zZXRcbiAgICAsIF9mcm9tVXNlciA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gICAgICAgIHZhciB2YWwgPSBvYmpcbiAgICAgICAgICAsIG5hdlxuICAgICAgICAgICwgbGFzdFxuXG4gICAgICAgIHdoaWxlICh2YWwgJiYgIXZhbC5fcmVtb3ZlZCAmJiB2YWwgaW5zdGFuY2VvZiB2T2JqZWN0KSB7XG5cbiAgICAgICAgICBpZiggdmFsLl9wYXJlbnQgJiYgdmFsLl9wYXJlbnQuX3Byb3AgJiYgdmFsLl9wYXJlbnQuX3Byb3AubmFtZSA9PT0gJ25hdmlnYXRpb24nICkge1xuICAgICAgICAgICAgbmF2ID0gdmFsXG4gICAgICAgICAgfSBcblxuICAgICAgICAgIGlmKCAoIHZhbC5jbG91ZCAmJiB2YWwuX3BhdGhbMF0gPT09ICd1c2VycycgKSBcbiAgICAgICAgICAgICAgfHwgdmFsIGluc3RhbmNlb2YgTW9ja0RhdGEgXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBbIHZhbCwgbmF2IF1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGFzdCA9IHZhbDtcbiAgICAgICAgICB2YWwgPSB2YWwuX3ZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXN1bHQgPSBsYXN0ICYmICFsYXN0Ll9yZW1vdmVkICYmIGxhc3QgIT09IG9ialxuICAgICAgICAgID8gbGFzdCBcbiAgICAgICAgICA6IGZhbHNlXG5cbiAgICAgICAgcmV0dXJuIFsgcmVzdWx0LCBuYXYgXVxuXG4gICAgICB9XG5cbiAgdXRpbC5kZWZpbmUoIHZPYmplY3QsIFxuICAgICckdXNlck9yaWdpbicsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKCB2YWwgKSB7XG5cbiAgICAgIHZhciBzZWFyY2ggPSBfZnJvbVVzZXIodGhpcylcbiAgICAgICAgLCBmb3VuZCA9IHNlYXJjaFswXSAvL3x8IHRoaXNcbiAgICAgICAgLCBuYXYgPSBzZWFyY2hbMV1cbiAgICAgICAgLCBzYW1lXG5cbiAgICAgIGlmKCFmb3VuZCkge1xuICAgICAgICB2YXIgcHJvcG5hbWUgPSB0aGlzLl9wcm9wICYmIHRoaXMuX3Byb3AubmFtZVxuXG4gICAgICAgIGlmKHByb3BuYW1lKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignPj4+Pj4+Pj4gbWFraW5nIGFuZCBsaW5raW5nJywgcHJvcG5hbWUpXG5cbiAgICAgICAgICB2YXIgdXNlciA9IHRoaXMuX2NhbGxlcixcbiAgICAgICAgICAgIGxpbmtlZHVzZXIgPSB1c2VyLmRhdGEuX3ZhbFxuXG4gICAgICAgICAgaWYoIWxpbmtlZHVzZXIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJz8/Pz8nLCB2YWwpXG4gICAgICAgICAgICBkZWJ1Z2dlclxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvdW5kID0gbGlua2VkdXNlci5nZXQocHJvcG5hbWUsIHt9KVxuICAgICAgICAgIHRoaXMudmFsID0gZm91bmRcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignRk9VTkQnLCB0aGlzLl9wcm9wICYmIHRoaXMuX3Byb3AubmFtZSwgZm91bmQuX3BhdGgsIGZvdW5kLnJhdywgZm91bmQpXG4gICAgICB9XG5cbiAgICAgIGlmKCFmb3VuZCkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ25vIHVzZXIgYnV0IGRvIGZyb20nKVxuICAgICAgICAvLyByZXR1cm4gX2NvcmVTZXQoIHRoaXMuZnJvbSwgdmFsIClcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBmaW5kIGNvcnJlY3QgJHVzZXJPcmlnaW4gZm9yICcrICggdGhpcy5fbmFtZSB8fCB0aGlzLl9wcm9wICYmICdwcm9wZXR5ICcrdGhpcy5fcHJvcC5uYW1lICkgKVxuICAgICAgfVxuXG4gICAgICBfY29yZVNldC5jYWxsKCBmb3VuZCAsIHZhbClcblxuICAgICAgaWYobmF2ICYmIG5hdi5fbmFtZSApIHtcbiAgICAgICAgbmF2Ll9wYXJlbnQubGFzdC5mcm9tLnZhbCA9IFxuICAgICAgICB7IHRpbWU6IHRpbWVzdGFtcCgpXG4gICAgICAgICwga2V5OiBuYXYuX25hbWVcbiAgICAgICAgfVxuICAgICAgfSBcblxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfZnJvbVVzZXIoIHRoaXMgKVswXSAvL3x8IHRoaXNcbiAgICB9XG4gIH0pXG59KSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCB1c2VyID0gcmVxdWlyZSgnLi8nKVxuICAsIHZPYmogPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKCBcbmZ1bmN0aW9uKCBiYXNlICkge1xuXG4gIGZ1bmN0aW9uIHNldFVzZXIoaSkge1xuICAgIC8vbWFrZSB0aGVzZSAyIG1vcmUgZGVmdWFsdFxuICAgIC8vIGNvbnNvbGUubG9nKGkpXG4gICAgLy8gY29uc29sZS5sb2coICdzd3RpY2ggdG8gdXNlcicsIGksIHRoaXMuZGF0YS5fdmFsIClcbiAgICB0aGlzW2ldID0gdGhpcy5kYXRhLiR1c2VyT3JpZ2luLmdldCggaSwgdGhpc1tpXS5fcHJvcC4kZGVmYXVsdCApXG4gIH1cblxuICBmdW5jdGlvbiBzZXRNb2NrKGkpIHtcbiAgICAvLyBjb25zb2xlLmxvZyggJ3N3dGljaCB0byBtb2NrJywgaSwgdGhpcy5tb2NrZGF0YVtpXSApXG4gICAgdGhpc1tpXSA9IHRoaXMubW9ja2RhdGFbaV1cbiAgfVxuXG4gIGJhc2UuZGVmaW5lKHtcbiAgICBfc2V0OiBmdW5jdGlvbih2YWwsIGkgKSBcbiAgICB7XG4gICAgICBpZiAoIHRoaXNbaV0gaW5zdGFuY2VvZiB2T2JqICkgXG4gICAgICB7XG4gICAgICAgIC8vVE9ETzogdG9yb3VnaCB0ZXN0aW5nXG4gICAgICAgIHRoaXNbaV0udmFsID0gdmFsW2ldXG4gICAgICB9IFxuICAgICAgaWYgKHR5cGVvZiB0aGlzW2ldID09PSAnZnVuY3Rpb24nKSBcbiAgICAgIHtcbiAgICAgICAgaWYgKHZhbFtpXSBpbnN0YW5jZW9mIEFycmF5KSBcbiAgICAgICAge1xuICAgICAgICAgIHRoaXNbaV0uYXBwbHkodGhpcyx2YWxbaV0pXG4gICAgICAgIH0gZWxzZSBcbiAgICAgICAge1xuICAgICAgICAgIHRoaXNbaV0odmFsW2ldKVxuICAgICAgICB9XG4gICAgICB9IFxuICAgICAgZWxzZSBcbiAgICAgIHtcbiAgICAgICAgaWYgKCB0aGlzLmlzUHJvcGVydHkoIGksIHZhbCApICkge1xuICAgICAgICAgIC8vIGNvbnNvbGUud2FybigndGhpcyBpcyBhIHByb3BlcnR5IScsIGkgLCB2YWwgKVxuICAgICAgICAgIHRoaXNbaV0gPSB2YWxbaV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiggdGhpc1tpXSApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIG1lcmdlPyBjaGVjayBvb2sgdm9vciBjbG91ZCBiaWp2b29yYmVlbGRcbiAgICAgICAgICAgIHRoaXNbaV0gPSB2YWxbaV1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdOT1cgTEVUUyBNQUtFIEEgQkFTSUMgVFlQRScsIGksIHRoaXMpXG5cbiAgICAgICAgICAgIHZhciBtb2NrID0ge31cblxuICAgICAgICAgICAgbW9ja1tpXSA9IHZhbFtpXVxuXG4gICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uID0ge31cbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbltpXSA9IHRydWVcblxuICAgICAgICAgICAgLy8gdGhpcy5tb2NrZGF0YSA9IG1vY2tcblxuICAgICAgICAgICAgdGhpcy5leHRlbmQoe1xuICAgICAgICAgICAgICBuYW1lOmlcbiAgICAgICAgICAgICwgbW9jazogbW9ja1xuICAgICAgICAgICAgLCAkZGVmYXVsdDogdmFsW2ldXG4gICAgICAgICAgICAsIHN1YnNjcmlwdGlvbjogc3Vic2NyaXB0aW9uIC8vbWF5YmUgZG8gdGhpcyBpZiBub3Qgc3BlY2lmaWVkXG4gICAgICAgICAgICAsIG9uOiB7XG4gICAgICAgICAgICAgICAgbW9jazogc2V0TW9ja1xuICAgICAgICAgICAgICAsIHVzZXI6IHNldFVzZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgLy9kaXQgYmV0ZXItLS0tIG1vZXQgbmFtZWxpamsgbmlldCB2YWxbaV0gd29yZGVuIG1hYXIgbW9ja2RhdGEgKG9mIG1ldGVlbiBzd2l0Y2hlbiBuYWFyIHVzZXJEYXRhKVxuICAgICAgICAgICAgXG4gICAgICAgICAgIFxuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2hleScsIGksIHRoaXNbaV0gKVxuICAgICAgICBcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0pIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlJylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvY2FzZXMnKVxuXG5yZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy9wcm9jZXNzJylcblxuLy9UT0RPOiB1cmwgZXJyb3Igb24gc3RhcnQgdXAgKHNldCBmcm9tIGNsb3VkKVxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZFxuKCBmdW5jdGlvbiggYmFzZSApIHtcblxuICBiYXNlLmRlZmluZSh7XG4gICAgdXBkYXRlSWQ6IGZ1bmN0aW9uKCByZXMgKSB7XG4gICAgICB0aGlzLmlkID0gcmVzIGluc3RhbmNlb2YgQXJyYXkgPyByZXNbIHJlcy5sZW5ndGggLTEgXSA6IHJlc1xuICAgICAgXG4gICAgICAvL2hpZXIgZmYgdm9vciBuYXZpZ2F0aW9uXG4gICAgICAvL2dldCBsYXN0P1xuICAgIH1cbiAgLCBhdXRoZW50aWNhdGU6IGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZSggX3RoaXMsIHJlcXVlc3QsIHZhbCwgdXBkYXRlICkge1xuICAgICAgdmFyIHVzZXIgPSB0aGlzXG4gICAgICAgICwgY2xvdWQgPSB1c2VyLmNsb3VkXG5cbiAgICAgIGlmKGNsb3VkLnBhcmFtcy5mYXN0TG9naW4gJiYgdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgIHZhciB1c2VySWQgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndXNlcklkJylcbiAgICAgICAgaWYodXNlcklkKXtcbiAgICAgICAgICByZXF1ZXN0LmlkID0gdXNlcklkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdnbyBjbG91ZC5hdXRoZW50aWNhdGUhIScpXG4gICAgICBjbG91ZC5hdXRoZW50aWNhdGUoIHJlcXVlc3QsIGZ1bmN0aW9uKCByZXMgKSB7XG4gICAgICAgIFxuICAgICAgICBpZihyZXMuZXJyb3IgJiYgdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXJJZCcpXG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY2xlYXJDYWNoZSgpXG5cbiAgICAgICAgaWYodmFsICE9PSBfdGhpcy52YWwpe1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1xcblxcblxcbmRpZCBhIGZhc3QgcmUtbG9naW4hIC0tIGRvdWJsZSBjaGVjaycpXG4gICAgICAgIH1cblxuICAgICAgICBpZiggcmVzLmVycm9yIHx8ICFfdGhpcy52YWwgKXtcbiAgICAgICAgICBfdGhpcy52YWwgPSBmYWxzZVxuICAgICAgICAgIHVzZXIuaWQgPSBmYWxzZVxuICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgICAgaWYoIHJlcy5lcnJvciApe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignYXV0aGVudGljYXRlIGVycm9yOicsIHJlcy5lcnJvcilcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGlmKCEgKHVzZXIuaXBsb2dpbiAmJiB1c2VyLmlwbG9naW4udmFsKSApe1xuICAgICAgICAgICAgICB1c2VyLmNsb3VkLmVtaXQoJ2xvZ291dCcsIHJlcyApXG5cbiAgICAgICAgICAgICAgaWYodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIiApe1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VySWQnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcigndG9rZW4gaXMgc2V0IHRvIGZhbHNlIHdoaWxlIGF1dGhlbnRpY2F0aW5nIChsb2dvdXQhIC0tIG5lZWQgdG8gZ2V0IGEgbWV0aG9kIHRvIGJyZWFrIGl0IHdoaWxlIGluIHByb2dyZXNzKScpXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQVVUSCBTVUM2JywgdXNlciwgcmVzIClcbiAgICAgICAgICAvL2RpdCBpcyBvb2sgd3JvbmcgY29tcGxldGVseSEgLS0gZGl0IGFsbGVlbiBkb2VuIG1ldCBlZW4gdXNlcnRva2VuISEhIVxuICAgICAgICAgIC8vIGFuZGVycyB3YWNodGVuIHRvdCBlZW4gb3ZlcnRha2UgYWN0aWVcbiAgICAgICAgICBpZiggX3RoaXMudmFsICE9PSB0cnVlICkge1xuICAgICAgICAgICAgdXNlci51cGRhdGVJZCggcmVzIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihjbG91ZC5wYXJhbXMuZmFzdExvZ2luICYmIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgdmFyIHVzZXJJZFxuICAgICAgICAgICAgaWYocmVzIGluc3RhbmNlb2YgQXJyYXkpXG4gICAgICAgICAgICAgIHVzZXJJZCA9IHJlc1tyZXMubGVuZ3RoLTFdXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHVzZXJJZCA9IHJlc1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3VzZXJJZCcsIHVzZXJJZCkgIFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKHVzZXIuaXBsb2dpbiAmJiB1c2VyLmlwbG9naW4udmFsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVFYgTE9HSU4gU1VDQ0VTUyEgbWF5YmUgZ28gbWFrZSBtYXNlbGYgZGF0IHVzZXInKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJz4+PiB0b2tlbicsIHVzZXIudG9rZW4udmFsKVxuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxuICBcbiAgLy8gY29uc29sZS5sb2coJz8/Pz8/Pz8/Pz8/Pz8gc2V0IGlwbG9naW4nLCBjYXNlcy4kaXNUdiB8fCBjYXNlcy4kaXNDaHJvbWVjYXN0KVxuICAvLyBiYXNlLmlwbG9naW4gPSBjYXNlcy4kaXNUdiB8fCBjYXNlcy4kaXNDaHJvbWVjYXN0XG4gIFxuICBiYXNlLmV4dGVuZChcbiAgeyAvL3ByaW1hcnlcbiAgICBpcGxvZ2luOiB7IHZhbDogY2FzZXMuJGlzVHYgfHwgY2FzZXMuJGlzQ2hyb21lY2FzdCB9LFxuICAgIHRva2VuOntcbiAgICAgIC8vIFRPRE86IHdoZW4gSVAgYmFzZWQgY29ubmVjdGl2aXR5IGlzIGZpeGVkIHRoaXMgaXMgbm90IG5lZWRlZFxuICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgIHRva2VuOiB0cnVlXG4gICAgICB9LFxuICAgICAgdmFsOntcbiAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiggdmFsLCBjdiApIHtcbiAgICAgICAgICByZXR1cm4gKCBjdiBpbnN0YW5jZW9mIE9iamVjdCApID8gZmFsc2UgOiBjdlxuICAgICAgICB9LFxuICAgICAgICBkZWZlcjpmdW5jdGlvbiggdXBkYXRlLCBhcmdzLCB0ZW1wZGVmZXIgKSB7XG5cbiAgICAgICAgICBpZihhcmdzWzBdICYmIGFyZ3NbMF0uZGVmZXIpIHJldHVybiB0cnVlXG5cbiAgICAgICAgICB2YXIgdG9rZW4gPSB0aGlzXG4gICAgICAgICAgdmFyIHVzZXIgPSB0b2tlbi5fY2FsbGVyXG5cbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdUT0tFTiBTRVQheHh4JywgdG9rZW4pXG5cbiAgICAgICAgICB1c2VyLmNsb3VkLmNvbm5lY3RlZC5pcyh0cnVlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvbGR2YWwgPSBhcmdzXG4gICAgICAgICAgICAgICwgdmFsID0gdG9rZW4udmFsXG4gICAgICAgICAgICAgICwgdXNlcklkID0gdXNlci5pZCAmJiB1c2VyLmlkLnZhbFxuICAgICAgICAgICAgICAsIGlwbG9naW4gPSB1c2VyLmlwbG9naW4gJiYgdXNlci5pcGxvZ2luLnZhbFxuXG4gICAgICAgICAgICAvLyBpZiggdXNlci5pcGxvZ2luICYmIHVzZXIuaXBsb2dpbi52YWwgKXtcbiAgICAgICAgICAgIC8vICAgaXBsb2dpbiA9IHRydWVcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vRE9VQkxFIENIRUNLIC0tLSB0aGlzIHdhcyBpbiB0aGVyZSB0byBhbGx3YXlzIG1ha2Ugc3VyZSB0aGlzIHN0dWZmIGRpZCBub3QgaGFwcGVuLi4uXG4gICAgICAgICAgICAvLyBpZiggdXNlci5hY3RpdmVDbGllbnQgJiYgdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gJiYgdXNlci5hY3RpdmVDbGllbnQuZnJvbSA9PT0gdXNlci5jbGllbnQuZnJvbSAgKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtYyBkaXJ0eSBsZXRzIGZpeCB0aGlzIGhlcmUhIG9uIGxvZ291dCBzZXQgZmFsc2UgdG8gYmUgY2VydGFpbicsIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luIClcbiAgICAgICAgICAgICAgLy8gdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gPSBmYWxzZVxuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICB0b2tlbi5jbGVhckNhY2hlKClcblxuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcigndG9rZW4gaXMgc2V0IScsIHZhbClcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0b2tlbiBpcyBzZXQhJywgaXBsb2dpbilcblxuICAgICAgICAgICAgaWYoIHVzZXJJZCAmJiAhaXBsb2dpbiApe1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTE9HT1VUIC0tLT4gRU1JVCcucmVkLmludmVyc2UsIHVzZXJJZCApXG4gICAgICAgICAgICAgIHZhciBfbGFzdCA9IHVzZXIuY2xvdWQubG9nb3V0KCB1c2VySWQgKVxuICAgICAgICAgICAgICBpZih0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcklkJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdmFsICl7XG5cbiAgICAgICAgICAgICAgdmFyIHVybCA9IHVzZXIuY2xvdWQuYXBpLmdldCgnYXV0aCcpXG5cbiAgICAgICAgICAgICAgdmFyIHJlcXVlc3QgPSBcbiAgICAgICAgICAgICAgeyB1cmw6IHVybFxuICAgICAgICAgICAgICAsIHN1YnM6IHVzZXIuc3Vic2NyaXB0aW9uc1xuICAgICAgICAgICAgICAsIHRva2VuOiB2YWxcbiAgICAgICAgICAgICAgLy9UT0RPOiBhbHNvIGFkZCB0dlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICwgYXV0aCA9IHVzZXIuX19hdXRoZW50aWNhdGVkX19cblxuICAgICAgICAgICAgICBpZiggaXBsb2dpbiApe1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgYWxsIHR2IHZpYmVzXG4gICAgICAgICAgICAgICAgaWYoIHZhbCA9PT0gdHJ1ZSApIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0LnRva2VuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlcXVlc3QudHYgPSB0cnVlXG5cbiAgICAgICAgICAgICAgICBpZiggIWF1dGggKXtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdJUExPR0lOIEZJUlNUIFRJTUUgUE9QIERBVCBBVVRIRU5USUNBVEUnKVxuICAgICAgICAgICAgICAgICAgdXNlci5fYXV0aHJlcXVlc3QgPSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICB1c2VyLmF1dGhlbnRpY2F0ZSggdG9rZW4sIHJlcXVlc3QsIHZhbCwgdXBkYXRlIClcbiAgICAgICAgICAgICAgICAgIHVzZXIuX19hdXRoZW50aWNhdGVkX18gPSB0cnVlXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICB2YXIgdXNlcnMgPSB1c2VyLmNsb3VkLmRhdGEuZ2V0KCd1c2VycycpXG4gICAgICAgICAgICAgICAgICAgICwgc2V0XG5cbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0lQTE9HSU4gVVNFUlNXSVRDSCcpXG4gICAgICAgICAgICAgICAgICAvLyBmaW5kIHRoZSB1c2VyIEkgc2hvdWxkIHN3aXRjaCB0b1xuICAgICAgICAgICAgICAgICAgdXNlcnMuZWFjaChmdW5jdGlvbigga2V5ICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc+PiBIQVZFIFVTRVInLCB0aGlzKVxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xvdWR1c2VyID0gdGhpc1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKGNsb3VkdXNlci50b2tlbiAmJiBjbG91ZHVzZXIudG9rZW4udmFsID09PSB0b2tlbi52YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpbSBzd2l0Y2hpbmcgdG8gdGhpcyB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgc2V0ID0gY2xvdWR1c2VyLl9uYW1lXG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3N3aXRjaCB0byB0aGlzIHVzZXJ0IScpXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYoXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG91ZHVzZXIucmVjZWl2ZXJDbGllbnQgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG91ZHVzZXIucmVjZWl2ZXJDbGllbnQuZnJvbSA9PT0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3RoaXMgb3RoZXIgdXNlciBoYXMgbWUgYXMgcmVjZWl2ZXJDbGllbnQsIGJldHRlciByZW1vdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvdWR1c2VyLnJlY2VpdmVyQ2xpZW50LiR1c2VyT3JpZ2luID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZihjbG91ZHVzZXIuYWN0aXZlQ2xpZW50ICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvdWR1c2VyLmFjdGl2ZUNsaWVudC5mcm9tID09PSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcigndGhpcyBvdGhlciB1c2VyIGhhcyBtZSBhcyByZWNlaXZlckNsaWVudCwgYmV0dGVyIHJlbW92ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG91ZHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luID0gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIGlmKCFzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5pZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgdXNlci5pZCA9IHNldFxuXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB1cGRhdGUoKSBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdXNlci5fYXV0aHJlcXVlc3QgPSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgdXNlci5hdXRoZW50aWNhdGUoIHRva2VuLCByZXF1ZXN0LCB2YWwsIHVwZGF0ZSApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICB1c2VyLmlkID0gZmFsc2VcbiAgICAgICAgICAgICAgdXBkYXRlKCkgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgbG9jYWxTdG9yYWdlVG9rZW46IHtcbiAgICAgIHZhbDoge1xuICAgICAgICBkZWZlcjpmdW5jdGlvbih1cGRhdGUsIGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdXNlciA9IHRoaXMuX2NhbGxlclxuICAgICAgICAgIGlmKCF1c2VyLl9yZWFkTG9jYWxTdG9yYWdlICYmIHR5cGVvZiB0aGlzLnZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHVzZXIuX3JlYWRMb2NhbFN0b3JhZ2UgPSB0aGlzLnZhbFxuICAgICAgICAgICAgdmFyIHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0odXNlci5fcmVhZExvY2FsU3RvcmFnZSlcbiAgICAgICAgICAgIGlmKHRva2VuICYmIHRva2VuICE9PSAndHJ1ZScpIHtcbiAgICAgICAgICAgICAgdXNlci50b2tlbiA9IHRva2VuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1c2VyLnRva2VuLm9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgdG9rZW52YWwgPSB0aGlzLnZhbFxuICAgICAgICAgICAgICBpZih0eXBlb2YgdG9rZW52YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0odXNlci5fcmVhZExvY2FsU3RvcmFnZSwgdG9rZW52YWwpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odXNlci5fcmVhZExvY2FsU3RvcmFnZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZSh0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICAvLyBiYXNlLnRva2VuID0gZmFsc2VcblxuICBiYXNlLmNhc2VzLiRpc0xvZ2dlZEluID0gbmV3IFZhbHVlKFxuICB7IHZhbDogYmFzZS50b2tlblxuICAsIHRyYW5zZm9ybTpmdW5jdGlvbih2YWwsIGN2KSB7XG4gICAgICBpZihjdiA9PT0gdHJ1ZSkgcmV0dXJuIDBcbiAgICB9XG4gIH0pXG5cbiAgdmFyIG15Y2xpZW50ID0gYmFzZS5jbG91ZC5jbGllbnRcblxuICBteWNsaWVudC5vbihmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tKXtcbiAgICAvLyBjb25zb2xlLmxvZygnc29tZXRoaW5nIGhhcHBlbmVkIG9uIG15IGNsb3VkIGNsaWVudCEnKVxuICAgIG9yaWdpbiA9IGZyb20gfHwgdGhpcy5fdXBkYXRlT3JpZ2luXG4gICAgaWYoc3RhbXAgPT09IGJhc2UuY2xvdWQuc3RhbXApIHtcbiAgICAgIHZhciBjbG91ZGNsaWVudCA9IG15Y2xpZW50LmZyb21cbiAgICAgIGlmKGNsb3VkY2xpZW50LnRva2VuKXtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tIHRva2VuIG9uIHVzZXIgaXMgbm93JywgYmFzZS50b2tlbi52YWwsICdzZXQgd2l0aCcsIGNsb3VkY2xpZW50LnRva2VuLnZhbClcbiAgICAgICAgYmFzZS50b2tlbi52YWwgPSBiYXNlLl9hdXRocmVxdWVzdC50b2tlbiA9IGNsb3VkY2xpZW50LnRva2VuLnZhbFxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLSBkaWQgc2V0IHRva2VuIG9uIHVzZXInKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBiYXNlLnRva2VuLl9uYW1lID0gJ3Rva2VuJ1xuXG59KVxuXG5cblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGJhc2UgPSByZXF1aXJlKCcuLi8uLi9iYXNlJylcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlJykvLy5uZXcoKVxuICAsIG9iamVjdFNldCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpLnNldFxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcblxuLy8gVmFsdWUuaW5qZWN0KHJlcXVpcmUoJy4vbGlzdGVuX2ZpeCcpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgdHlwZTogVmFsdWUsXG4gIGNyZWF0ZTogZnVuY3Rpb24odmFsLCBwcm9wLCBzZXR0aW5ncywgbm91cGRhdGUpIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdjcmVhdGUgaXQnLCB2YWwsIHNldHRpbmdzIClcbiAgICB2YXIgdiA9IG5ldyBWYWx1ZSgpXG4gICAgdi5fYmFzZSA9IHRoaXNcbiAgICB2Ll9jYWxsZXIgPSB2Ll9iYXNlXG4gICAgdi5fcHJvcCA9IHNldHRpbmdzXG4gICAgLy8gY29uc29sZS5sb2coJ3NldCcpXG4gICAgb2JqZWN0U2V0LmNhbGwodiwgdmFsLCBmYWxzZSwgZmFsc2UsIHRydWUpXG4gICAgLy8gY29uc29sZS5sb2coJ2RvbmUgc2V0dGluZycpXG4gICAgaWYgKHRoaXMuX2NsYXNzKSB0aGlzLl9jbGFzcy5wcm90b3R5cGUuX1tzZXR0aW5ncy5uYW1lXSA9IHZcbiAgICBpZiAoc2V0dGluZ3MpIHtcblxuICAgICAgaWYgKCFzZXR0aW5ncy5fdnNldCkge1xuXG4gICAgICAgIC8vY2FuIGFsc28gYWRkIGEgdGhpbmcgdG8gc2V0IG9uIGdldCBieSBkZWZhdWx0P1xuXG4gICAgICAgIGlmKHNldHRpbmdzLm1vY2spIHtcbiAgICAgICAgICAvL2lmIG5vdCBzZXQgYWRkIHNvbWUgZWZmaWNpZW5jeSBwbHpcbiAgICAgICAgICB0aGlzLm1vY2tkYXRhID0gc2V0dGluZ3MubW9ja1xuICAgICAgICB9XG5cbiAgICAgICAgaWYoc2V0dGluZ3Muc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gc2V0dGluZ3Muc3Vic2NyaXB0aW9uXG4gICAgICAgIH1cblxuICAgICAgICBpZihzZXR0aW5ncy5vbikge1xuICAgICAgICAgIGlmKCB0eXBlb2Ygc2V0dGluZ3Mub24gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICB0aGlzLm9uLm1vY2tbc2V0dGluZ3MubmFtZV0gPSBzZXR0aW5ncy5vblxuICAgICAgICAgICAgdGhpcy5vbi51c2VyW3NldHRpbmdzLm5hbWVdID0gc2V0dGluZ3Mub25cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoc2V0dGluZ3Mub24ubW9jayAmJiAhdGhpcy5vbi5tb2NrW3NldHRpbmdzLm5hbWVdKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJhc2UsIGJhc2Uub24pXG4gICAgICAgICAgICAgIHRoaXMub24ubW9ja1tzZXR0aW5ncy5uYW1lXSA9IHNldHRpbmdzLm9uLm1vY2tcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHNldHRpbmdzLm9uLnVzZXIgJiYgIXRoaXMub24udXNlcltzZXR0aW5ncy5uYW1lXSkge1xuICAgICAgICAgICAgICB0aGlzLm9uLnVzZXJbc2V0dGluZ3MubmFtZV0gPSBzZXR0aW5ncy5vbi51c2VyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MuX3ZzZXQgPSBmdW5jdGlvbihzdGFtcCwgZnJvbSwgcmVtb3ZlLCBjdmFsKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIGJhc2UgPSB0aGlzLl9jYWxsZXJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9iYXNlXG4gICAgICAgICAgICAgICAgfHwgdGhpc1xuXG5cbiAgICAgICAgICAvL2lmICFiYXNlIC0tXG4gICAgICAgICAgLy8gaWYoIWJhc2UuKVxuXG4gICAgICAgICAgaWYoc2V0dGluZ3Muc2V0KSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5zZXQuY2FsbChcbiAgICAgICAgICAgICAgYmFzZSwgdGhpcywgc3RhbXAsIGZyb20sIHJlbW92ZSwgY3ZhbFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIW5vdXBkYXRlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdVUERBVEUgY3JlYXRpb24nKVxuICAgICAgICB2Ll91cGRhdGUodmFsKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdlxuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKHZhbCwgcHJvcCwgc2V0dGluZ3MpIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdzZXQgaXQnLCB2YWwgKVxuICAgIHRoaXMuX2NhbGxlciA9IHRoaXNcbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIGdldDogZnVuY3Rpb24ocHJvcCwgc2V0dGluZ3MpIHtcbiAgICBpZiAocHJvcCkgcHJvcC5fY2FsbGVyID0gdGhpc1xuICAgIGlmIChzZXR0aW5ncy5nZXQpIHJldHVybiBzZXR0aW5ncy5nZXQuY2FsbCh0aGlzLCBwcm9wKVxuICAgIHJldHVybiBwcm9wXG4gIH1cbn0iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsJylcblxudmFyIHZPYmplY3QgPSByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0JylcblxudmFyIE1vY2tEYXRhID0gcmVxdWlyZSgnLi9tb2NrZGF0YScpXG5cbnZhciBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcblxudmFyIERhdGEgPSByZXF1aXJlKCd2aWdvdXItanMvZGF0YScpXG4gICAgICAuaW5qZWN0KCByZXF1aXJlKCd2aWdvdXItanMvZGF0YS9zZWxlY3Rpb24nKSApXG5cblxucmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kXG4oIGZ1bmN0aW9uKCB1c2VyICkge1xuXG4gIHZhciBjb250ZW50ID0gdXNlci5wYXJlbnQuaW5qZWN0KHJlcXVpcmUoJy4uL2NvbnRlbnQnKSkuY29udGVudFxuXG4gIHVzZXIuZXh0ZW5kKHtcbiAgICB1c2FnZToge1xuICAgICAgbW9jazoge1xuICAgICAgICB1c2FnZTp7fVxuICAgICAgfSxcbiAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICB1c2FnZToge1xuICAgICAgICAgIHNob3dzOiB7XG4gICAgICAgICAgICAkOiB7XG4gICAgICAgICAgICAgIG1lZGlhOntcbiAgICAgICAgICAgICAgICAvL2RpdCBtb2V0IHNvd2llc28gbmlldCB0aXRsZSB3b3JkZW4hIGxpZXZlciBnZXdvb24gdHJ1ZSBvZiBpZCBvZnpvXG4gICAgICAgICAgICAgICAgJDp0cnVlXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZhdm91cml0ZTp0cnVlLFxuICAgICAgICAgICAgICB0aW1lc3RhbXA6dHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIG1vY2s6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy51c2FnZSA9IHRoaXMubW9ja2RhdGEudXNhZ2VcbiAgICAgICAgfSxcbiAgICAgICAgdXNlcjpmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnVzYWdlID0gdGhpcy5kYXRhLmZyb20uZ2V0KCd1c2FnZScse30pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgd2F0Y2hlZDp7XG4gICAgICBvbjoge1xuICAgICAgICAvL21pc2NoaWVuIGVpZ2VuICwgbmlldXdlIHNlbGVjdGlvbiBtYWtlbiBhbHZhc3RcbiAgICAgICAgbW9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYodGhpcy5fX3dhdGNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX193YXRjaGVkLnJlbW92ZSgpXG4gICAgICAgICAgICB0aGlzLl9fd2F0Y2hlZCA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodGhpcy53YXRjaGVkKSB0aGlzLndhdGNoZWQuJGVtcHR5KClcbiAgICAgICAgICB0aGlzLndhdGNoZWQgPSB7fVxuICAgICAgICB9LFxuICAgICAgICB1c2VyOmZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB1c2VyID0gdGhpc1xuICAgICAgICAgIGlmKHRoaXMuX193YXRjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9fd2F0Y2hlZC5yZW1vdmUoKVxuICAgICAgICAgICAgdGhpcy5fX3dhdGNoZWQgPSBudWxsXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXMuX193YXRjaGVkID0gbmV3IERhdGEoIHVzZXIudXNhZ2UuZnJvbS5nZXQoJ3Nob3dzJykgLCB7XG4gICAgICAgICAgICBjb25kaXRpb246IHsgXG4gICAgICAgICAgICAgIG1lZGlhOiB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgICAgICRleGlzdHM6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdXNlci53YXRjaGVkID0ge31cblxuICAgICAgICAgIHNlbGVjdGlvbi5vbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZXRzID0ge31cblxuICAgICAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICB2YXIgYmxhID0gIGNvbnRlbnQuZ2V0KHRoaXMuX3BhdGguc2xpY2UoLTIpKVxuICAgICAgICAgICAgICB2YXIgb2JqID0ge31cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHV0aWwucGF0aChvYmosIGJsYS5fcGF0aCwge1xuICAgICAgICAgICAgICAgIGltZzp0cnVlLFxuICAgICAgICAgICAgICAgIHRpdGxlOnRydWVcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgIHZhciBfY2xvdWQgPSAgdXNlci5wYXJlbnQuY2xvdWRcbiAgICAgICAgICAgICBfY2xvdWQuc3Vic2NyaWJlKG9iailcblxuICAgICAgICAgICAgICB1c2VyLndhdGNoZWQuc2V0KHRoaXMuX25hbWUsIFxuICAgICAgICAgICAgICB7IHNob3c6IGJsYVxuICAgICAgICAgICAgICAsIG1lZGlhOiB0aGlzLm1lZGlhLmZyb21cbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICB1c2VyLndhdGNoZWRbdGhpcy5fbmFtZV0ub25jZSgncmVtb3ZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgX2Nsb3VkLnVuc3Vic2NyaWJlKG9iailcbiAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICBzZXRzW3RoaXMuX25hbWVdID0gdHJ1ZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdXNlci53YXRjaGVkLmVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBpZighc2V0c1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGlmKHVzZXIud2F0Y2hlZClcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHNldHMgPSBmYWxzZVxuXG4gICAgICAgICAgICB1c2VyLndhdGNoZWQudXBkYXRlKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIHNlbGVjdGlvbi5fdXBkYXRlKClcblxuICAgICAgICB9XG4gICAgICB9IFxuICAgIH0sXG5cbiAgICBmYXZvdXJpdGVzOntcbiAgICAgIG9uOiB7XG4gICAgICAgIC8vbWlzY2hpZW4gZWlnZW4gLCBuaWV1d2Ugc2VsZWN0aW9uIG1ha2VuIGFsdmFzdFxuICAgICAgICBtb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZih0aGlzLl9fZmF2b3VyaXRlcykge1xuICAgICAgICAgICAgdGhpcy5fX2Zhdm91cml0ZXMucmVtb3ZlKClcbiAgICAgICAgICAgIHRoaXMuX19mYXZvdXJpdGVzID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLmZhdm91cml0ZXMpIHRoaXMuZmF2b3VyaXRlcy4kZW1wdHkoKVxuICAgICAgICAgIHRoaXMuZmF2b3VyaXRlcyA9IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHVzZXI6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHVzZXIgPSB0aGlzXG4gICAgICAgICAgaWYodXNlci5fX2Zhdm91cml0ZXMpIHtcbiAgICAgICAgICAgIHVzZXIuX19mYXZvdXJpdGVzLnJlbW92ZSgpXG4gICAgICAgICAgICB1c2VyLl9fZmF2b3VyaXRlcyA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mYXZvdXJpdGVzLiRlbXB0eSgpXG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHVzZXIuX19mYXZvdXJpdGVzID0gbmV3IERhdGEoIHVzZXIudXNhZ2UuZnJvbS5nZXQoJ3Nob3dzJykgLCB7XG4gICAgICAgICAgICBjb25kaXRpb246IHsgXG4gICAgICAgICAgICAgIGZhdm91cml0ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICB1c2VyLmZhdm91cml0ZXMgPSB7fVxuXG4gICAgICAgICAgc2VsZWN0aW9uLm9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNldHMgPSB7fVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgIHZhciBibGEgPSAgY29udGVudC5nZXQodGhpcy5fcGF0aC5zbGljZSgtMikpXG5cbiAgICAgICAgICAgICAgdXNlci5mYXZvdXJpdGVzLnNldCh0aGlzLl9uYW1lLGJsYSlcbiAgICAgICAgICAgICAgc2V0c1t0aGlzLl9uYW1lXSA9IHRydWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHVzZXIuZmF2b3VyaXRlcy5lYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgaWYoIXNldHNbbmFtZV0gICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgc2V0cyA9IGZhbHNlXG5cbiAgICAgICAgICAgIHVzZXIuZmF2b3VyaXRlcy51cGRhdGUoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgc2VsZWN0aW9uLl91cGRhdGUoKVxuXG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfVxuICB9KVxuXG4gIHVzZXIuZXh0ZW5kKHtcbiAgICBoYXNXYXRjaGVkOiB7XG4gICAgICB2YWw6IHtcbiAgICAgICAgdmFsOiB1c2VyLndhdGNoZWQsXG4gICAgICAgIHRyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfSxcbiAgICBoYXNGYXZvdXJpdGVzOiB7XG4gICAgICB2YWw6IHtcbiAgICAgICAgdmFsOiB1c2VyLmZhdm91cml0ZXMsXG4gICAgICAgIHRyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHZhciBvbGRDb250ZW50ID0gY29udGVudC5fdmFsXG5cbiAgY29udGVudC5vbignc2VsZicsIGZ1bmN0aW9uKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjb250ZW50IGlzIGNoYW5naW5nIGZyb20nLCBvbGRDb250ZW50ICYmIG9sZENvbnRlbnQuX3BhdGgsICd0bycsIHRoaXMuX3ZhbC5fcGF0aClcbiAgICBpZiggdXNlci50b2tlbi52YWwgKSB7XG4gICAgICByZXNvbHZlV2F0Y2hlZE1lZGlhKCB1c2VyIClcbiAgICAgIHVzZXIuZmF2b3VyaXRlcy5fcHJvcC5vbi51c2VyLmNhbGwodXNlcilcbiAgICAgIHVzZXIud2F0Y2hlZC5fcHJvcC5vbi51c2VyLmNhbGwodXNlcilcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZVdhdGNoZWRNZWRpYSggdXNlciApXG4gICAgICB1c2VyLmZhdm91cml0ZXMuX3Byb3Aub24ubW9jay5jYWxsKHVzZXIpXG4gICAgICB1c2VyLndhdGNoZWQuX3Byb3Aub24udXNlci5jYWxsKHVzZXIpXG4gICAgfVxuICB9KVxuXG4gIGNhc2VzLiRoYXNGYXZvdXJpdGVzID0gdXNlci5oYXNGYXZvdXJpdGVzXG4gIGNhc2VzLiRoYXNXYXRjaGVkID0gdXNlci5oYXNXYXRjaGVkXG5cbn0pXG5cbmZ1bmN0aW9uIHJlc29sdmVXYXRjaGVkTWVkaWEoIHVzZXIgKSB7XG4gIHVzZXIud2F0Y2hlZC5mcm9tLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1lZGlhID0gdGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLmZyb21cbiAgICBpZihtZWRpYSkge1xuXG4gICAgICB2YXIgbmV3UGF0aCA9IHVzZXIucGFyZW50LmNvbnRlbnQuZnJvbS5fcGF0aC5jb25jYXQoIG1lZGlhLl9jb250ZW50UGF0aCApICAgICAgIFxuICAgICAgdmFyIG9sZFBhdGggPSBtZWRpYS5fcGF0aFxuXG4gICAgICBpZiggIXV0aWwuY29tcGFyZUFycmF5cyggb2xkUGF0aCwgbmV3UGF0aCApICkge1xuICAgICAgICBjb25zb2xlLmxvZygncmVzb2x2ZScsIG9sZFBhdGgsIG5ld1BhdGgpXG4gICAgICAgIHRoaXMubWVkaWEudmFsID0gdXNlci5wYXJlbnQuY29udGVudC5nZXQoIG5ld1BhdGggKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gaGFzVHJhbnNmb3JtKCBjLCBjdikge1xuICB2YXIgc2VsZWN0aW9uID0gYy5fcGFyZW50Ll92YWxcbiAgaWYoc2VsZWN0aW9uKSB7XG4gICAgaWYoc2VsZWN0aW9uLiRsZW5ndGgudmFsPjApIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiAwXG59XG4gICIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgVmFsdWUgPSByZXF1aXJlKCcuLi92YWx1ZScpXG4gICwgdXJsID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9uZXR3b3JrL3VybCcpXG4gICwgdWEgPSByZXF1aXJlKCcuLi9icm93c2VyL3VhJylcblxucmVxdWlyZSgnLi4vdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZCggZnVuY3Rpb24oIGFwcCApIHtcblxuICAvL3VzZSBjYXNlcyByZWZlcmVuY2Ugb24gYXBwXG4gIHZhciBjYXNlcyA9IGFwcC5jYXNlcyB8fCAoIGFwcC5jYXNlcyA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvY2FzZXMnKSApXG5cbiAgYXBwLmluaXRpYWxpc2VkID0gbmV3IFZhbHVlKCBmYWxzZSApXG5cbiAgYXBwLm92ZXJsYXkgPSBuZXcgVmFsdWUoIGZhbHNlIClcblxuICBhcHAuZm9jdXNTdGF0ZSA9IG5ldyBWYWx1ZSgnbWVudScpXG5cbiAgYXBwLnJlZ2lvbiA9IG5ldyBWYWx1ZSh7IGluaXQ6IGFwcC5pbml0aWFsaXNlZCB9KVxuICAvL2Jyb3dzZXJcbiAgLy91YS5icm93c2VyXG5cbiAgYXBwLnVybCA9IHVhLmRldmljZSA9PT0gJ3R2JyAmJiB1YS5wbGF0Zm9ybSA9PT0gJ2xnJyBcbiAgICAgICAgPyAgbmV3IFZhbHVlKHtkZWZlcjpmdW5jdGlvbigpe30sIHBhcmFtczp7fSwgc3RyaW5nOicnfSkgXG4gICAgICAgIDogIHVybCBcbiAgLy9vb2sgcGFzIG9wIGFwcCBpbml0aWxpc2VkIVxuXG4gIGFwcC5yZWFkeSA9IG5ldyBWYWx1ZSgpXG5cbiAgYXBwLm1lbnUgPSBuZXcgVmFsdWUoeyBpbml0OiBhcHAucmVhZHkgfSlcblxuICAvL1RPRE86bmV0d29ya1xuICAvL21vdmUgbmV0d29yayBhcGkgZmlsZSB0byBoZXJlIHBlcmhhcHNcbiAgYXBwLm5ldHdvcmsgPSBuZXcgVmFsdWUoKVxuXG4gIC8vVE9ETzogZG91YmxlIGNoZWNrIHRoaXMgaXMgZWZmaWNpZW50XG4gIGFwcC5sb2FkaW5nID0gbmV3IFZhbHVlKHsgXG4gICAgaW5pdDogYXBwLnJlYWR5XG4gICwgZGVmZXI6IGZ1bmN0aW9uKCB1cGRhdGUsIGFyZ3MgKSB7XG4gICAgICAvL1RPRE86IGNhY2hlZCB1cGRhdGVQYXRoID9cbiAgICAgIHZhciBpZCA9IHRoaXMudXBkYXRlUGF0aC5qb2luKCcuJylcbiAgICAgIGlmKCBhcmdzWzBdPT09ZmFsc2UgJiYgKCAoaWQgJiYgaWQgPT09IHRoaXMuaWQpIHx8ICF0aGlzLmlkICkgKSB7XG4gICAgICAgIHRoaXMudmFsID0gYXJnc1swXVxuICAgICAgICB0aGlzLmlkID0gZmFsc2VcbiAgICAgIH0gZWxzZSBpZiggYXJnc1swXSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkXG4gICAgICAgIHRoaXMudmFsID0gdHJ1ZVxuICAgICAgfVxuICAgICAgdXBkYXRlKClcbiAgICB9XG4gICAgLy9hZGQgZGVmZXJlZCBsYXRlciAobWF5YmUgZG9udCBzaG93IGEgbG9hZGVyIGZvciBsZXNzIHRoZW4geHh4IHNlYykgXG4gIH0pXG5cbiAgLy8gJ19zZXQnLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIG5vdXBkYXRlLCBhZGRlZCwgb2xkdmFsKSB7XG4gIC8vYWRkIGxvY2Fsc3RvcmFnZVxuXG4gIHZhciBndWVzc0xhbmd1YWdlID0gYXBwLmd1ZXNzTGFuZ3VhZ2UgPSBmdW5jdGlvbiBndWVzc0xhbmd1YWdlKCl7XG4gICAgLy9UT0RPOiBjb3Jkb3ZhIGxhbmd1YWdlXG4gICAgdmFyIGd1ZXNzID0gd2luZG93Lm5hdmlnYXRvci51c2VyTGFuZ3VhZ2VcbiAgICAgICAgICAgICB8fCB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlXG4gICAgICAgICAgICAgfHwgYXBwLnJlZ2lvbi52YWwgXG4gICAgaWYoZ3Vlc3MpXG4gICAgICByZXR1cm4gZ3Vlc3Muc2xpY2UoMCwyKS50b0xvd2VyQ2FzZSgpXG4gIH1cblxuIGFwcC5sYW5ndWFnZSA9IG5ldyBWYWx1ZSggIFxuICB7IHRyYW5zZm9ybTogZnVuY3Rpb24oIHZhbCwgY3YgKSB7XG4gICAgICBpZighY3YgfHwgdHlwZW9mIGN2ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBjdiA9IGd1ZXNzTGFuZ3VhZ2UoKVxuICAgICAgfSBcbiAgICAgIHJldHVybiBjdiA/IGN2LnNsaWNlKDAsMikudG9Mb3dlckNhc2UoKSA6IGZhbHNlXG4gICAgfVxuICAsIGluaXQ6IGFwcC5pbml0aWFsaXNlZCBcbiAgfSlcblxuICBhcHAuZnVsbHNjcmVlbiA9IG5ldyBWYWx1ZSh7IGZvcmNlOiB0cnVlIH0pXG5cbiAgYXBwLmxvYWRlciA9IG5ldyBWYWx1ZSgpXG5cbiAgYXBwLnZvbHVtZSA9IG5ldyBWYWx1ZShcbiAgeyB2YWw6MVxuICAsIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd2b2x1bWU/Jyxjdixpc05hTihjdikgPyAxIDogY3YpXG4gICAgICAvL1RPRE86IHVzZSBsb0Rhc2ggZm9yIGlzTmFuXG4gICAgICByZXR1cm4gaXNOYU4oY3YpID8gMSA6IGN2XG4gICAgfVxuICB9KVxuXG4gIGFwcC5wb3B1cCA9IG5ldyBWYWx1ZSh7IGluaXQ6IGFwcC5yZWFkeSB9KVxuXG4gIGFwcC5wcmV2aWV3ID0gbmV3IFZhbHVlKHsgaW5pdDogYXBwLnJlYWR5IH0pXG5cbiAgYXBwLmhpZ2hsaWdodCA9IG5ldyBWYWx1ZSh7IGluaXQ6IGFwcC5yZWFkeSB9KVxuXG4gIGFwcC5zdGF0ZSA9IG5ldyBWYWx1ZSh7IGluaXQ6IGFwcC5yZWFkeSB9KVxuICBcbiAgYXBwLm5vdGlmaWNhdGlvbiA9IG5ldyBWYWx1ZSggXG4gIHsgaW5pdDogYXBwLnJlYWR5ICBcbiAgLCBmb3JjZTogdHJ1ZSAvL1RPRE86IG1ha2UgdGhpcyBiZXR0ZXJcbiAgfSlcblxuICBhcHAuaXNQbGF5aW5nID0gbmV3IFZhbHVlKFxuICB7IGluaXQ6IGFwcC5yZWFkeVxuICAsIHZhbDpmYWxzZVxuICB9KVxuXG4gIGFwcC5yZXN0cmljdFBsYXliYWNrID0gbmV3IFZhbHVlKClcblxuICAvL21ha2UgaW5qZWN0YWJsZVxuICBhcHAud2lmaU9ubHkgPSBuZXcgVmFsdWUoXG4gICAgbG9jYWxTdG9yYWdlIFxuICAgID8geyB2YWw6IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd3aWZpT25seScpIHx8IGZhbHNlXG4gICAgICAsIGRlZmVyOmZ1bmN0aW9uKCB1cGRhdGUgKXtcbiAgICAgICAgICBpZih0aGlzLl92YWwpIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd3aWZpT25seScsdHJ1ZSlcbiAgICAgICAgICBlbHNlIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd3aWZpT25seScpXG4gICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIDogZmFsc2VcbiAgKVxuXG4gIGFwcC5yZXN0cmljdFBsYXliYWNrLnZhbCA9IFxuICB7IHZhbDogYXBwLndpZmlPbmx5XG4gICwgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgcmV0dXJuICggY3YgJiYgY2FzZXMuJGlzTmF0aXZlICYmIGFwaS5uZXR3b3JrLnZhbCAhPT0gJ3dpZmknIClcbiAgICAgICAgPyB0cnVlXG4gICAgICAgIDogZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBtb3ZlIHRoaXMgKHNldHRpbmcgY2FzZSB2YWx1ZSkgb3V0IG9mIGFwcCB2YWx1ZXNcbiAgY2FzZXMuJHN0b3JlQXZhaWxhYmxlID0gbmV3IFZhbHVlKCBcbiAgICBjYXNlcy4kaXNOYXRpdmUgJiYgKCBjYXNlcy4kaXNJb3MgfHwgY2FzZXMuJGlzQW5kcm9pZCB8fCBjYXNlcy4kaXNXaW5kb3dzTW9iaWxlICkgLy8mJiB3aW5kb3cuU3RvcmVcbiAgKVxuXG59KSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBWID0gcmVxdWlyZSgnLi4vJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgaW5qZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmplY3QnKVxuLy8gLCByYWYgPSByZXF1aXJlKCcuLi9icm93c2VyL2FuaW1hdGlvbi9yYWYnKVxuXG5cbi8qXG4gIHV0aWwuZGVmaW5lKCBleHRlbmQsICdleHRlbnNpb25zJyx7dmFsOltdLCBzZXRDbGFzczp0cnVlfSApXG4qL1xuXG4vKipcbiAqIEJhc2UgaXMgdXNlZCBhcyBhIGNsYXNzIGNvbnN0cnVjdG9yLlxuICogQGNvbnN0cnVjdG9yIFYuQmFzZVxuICogQHBhcmFtICB7Kn0gW3ZhbF0gU3RhcnR2YWx1ZSBmb3IgbmV3IFYuQmFzZVxuICovXG52YXIgYmFzZSA9IFYuQmFzZSA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCkge1xuICB0aGlzLl9mcm9tID0gdGhpcy5jb25zdHJ1Y3RvclxuICBpZiAodmFsKSB0aGlzLnNldCh2YWwpXG59XG5cbmV4cG9ydHMuc2V0dGluZ3MgPSByZXF1aXJlKCcuL3NldHRpbmdzJylcblxuLyoqXG4gKiBTZXRzIHByb3BlcnRpZXMgZGVmaW5lZCBpbiBhbiBvYmplY3QuXG4gKiBEZWZpbmUgYSBfc2V0IG1ldGhvZCBvbiBhIGJhc2UgaW5zdGFuY2UgdG8gZ2V0IGN1c3RvbSBtZXRob2QgcGVyIHNldC5cbiAqIEBmdW5jdGlvbiBfc2V0XG4gKiBAcGFyYW0gIHsqfSB2YWwgICAgICAgICBBbnkgdmFsdWVcbiAqIEBwYXJhbSAgeyp9IFtwYXJhbXNdICAgIEFkZGVkIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gbm9zZXQgIFdoZW4gdHJ1ZSByZXR1cm5zIGEgcGFyc2VkIHZhbCBvYmplY3QgYnV0IHNldCBub3RoaW5nXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICByZXR1cm4gc2VsZiBmb3IgY2hhaW5pbmdcbiAqL1xudmFyIF9zZXQgPSBleHBvcnRzLnNldCA9IGZ1bmN0aW9uKHZhbCwgcGFyYW1zLCBub3NldCkge1xuICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgIGlmICh+aS5pbmRleE9mKCcsJykpIHtcbiAgICAgIGZvciAodmFyIGFyciA9IGkuc3BsaXQoJywnKSwgbXVsdGlvYmogPSB7fSwgbSA9IDAsIG1sID0gYXJyLmxlbmd0aDsgbSA8IG1sOyBtKyspIHtcbiAgICAgICAgbXVsdGlvYmpbYXJyW21dXSA9IHV0aWwuY2xvbmUodmFsW2ldKVxuICAgICAgfVxuICAgICAgaWYgKCFub3NldCkge1xuICAgICAgICBfc2V0LmNhbGwodGhpcywgbXVsdGlvYmosIHBhcmFtcywgbm9zZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdmFsW2ldXG4gICAgICAgIGZvciAodmFyIG4gaW4gbXVsdGlvYmopIHtcbiAgICAgICAgICB2YWxbbl0gPSBtdWx0aW9ialtuXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSB1dGlsLmRvdEZpZWxkKHZhbCwgaSlcblxuICAgICAgLy8gY29uc29sZS5lcnJvciggJ1NFVCcsIHRoaXMsIHRoaXMuX3NldClcblxuICAgICAgaWYgKHRoaXMuX3NldCAmJiAhbm9zZXQpIHtcbiAgICAgICAgdGhpcy5fc2V0LmNhbGwodGhpcywgdmFsLCBpLCBwYXJhbXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL1RPRE86IGNoZWNrIGZvciBwcm9wZXJ0eSBtb3ZlIGZyb20gZWxlbWVudCBzZXQgdG8gaGVyZVxuICAgICAgICAvLyBpZiggVi5PYmplY3QgJiYgdGhpcy5pc1Byb3BlcnR5KCBpLCB2YWwgKSAmJiB0aGlzW2ldIGluc3RhbmNlb2YgVi5PYmplY3QgKVxuICAgICAgICAvLyB7XG4gICAgICAgIC8vICAgY29uc29sZS5sb2coJz8/JywgaSwgdmFsLCB0aGlzLmlzUHJvcGVydHkoIGksIHZhbCApIClcbiAgICAgICAgLy8gICB0aGlzW2ldLnZhbCA9IHZhbFtpXVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGVsc2VcbiAgICAgICAgLy8ge1xuICAgICAgICAgIHRoaXNbaV0gPSB2YWxbaV1cbiAgICAgICAgLy8gfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9zZXQgPyB2YWwgOiB0aGlzXG59O1xuXG51dGlsLmRlZmluZShiYXNlLFxuICAvKipcbiAgICogV2hlbiBhIEJhc2UgaXMgZXh0ZW5kZWQgd2l0aG91dCBkZWZpbmluZyB0aGUgdHlwZSB0aGlzIGlzIHRoZSBkZWZhdWx0IHR5cGUuXG4gICAqIEBwcm9wZXJ0eSBkZWZhdWx0VHlwZVxuICAgKi9cbiAgJ2lzUHJvcGVydHknLCBmdW5jdGlvbiggaSwgdmFsKSB7XG4gICAgdmFyIHQgPSB0aGlzXG4gICAgICAsIHJlc3VsdCA9IFxuXG4gICAgICBcbiAgICAvLyB2YWxbaV0gaW5zdGFuY2VvZiBPYmplY3QgIC8vVEhJUyBNQVkgR08gQVdBWSBMQVRFUlxuICAgICAgICAgICAvL1RPRE86IGNoZWNrIGlmIHRoaXMgaXMgcmVhbGx5IG5lc3NlcmFjeSAoIHZvaWQgMCApXG4gICAgICAgICAgIC8vICYmIFxuXG4gICAgICAvL1NVUEVSIERBTkdFUkdPVVMgVEhJTkdcblxuICAgICAgICAgICEoIHQuX1tpXSA9PT0gdm9pZCAwIC8vLS0tIGRhbmdlciByZXNvbHZlIHdoZW4gZGVmaW5lIF8gaXMgZml4ZWRcbiAgICAgICAgICAgJiYgIXV0aWwubG9va3VwLmNhbGwodCwgaSkgXG4gICAgICAgICAgICYmIHR5cGVvZiB0W2ldIT09J2Z1bmN0aW9uJyBcbiAgICAgICAgICApXG5cbiAgICAvLyBjb25zb2xlLmxvZyggdmFsW2ldIGluc3RhbmNlb2YgT2JqZWN0LCB0Ll9baV0gPT09IHZvaWQgMCwgJ3ZhbDonLHQuX1tpXSwgIXV0aWwubG9va3VwLmNhbGwodCwgaSksIHR5cGVvZiB0W2ldIT09J2Z1bmN0aW9uJyAgKVxuXG4gICAgLy8gY29uc29sZS5sb2coICdJUyBQUk9QRVJUWScsIGksIHJlc3VsdCApXG5cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG4gICdkZWZhdWx0VHlwZScsIGZhbHNlLFxuICAnZXh0ZW5zaW9ucycsIGZhbHNlLFxuICAnZGVmaW5lJywgZnVuY3Rpb24odmFsKSB7XG4gICAgZm9yKHZhciBpIGluIHZhbCkge1xuICAgICAgdXRpbC5kZWZpbmUoIHRoaXMsIGksIHZhbFtpXSApXG4gICAgICB1dGlsLmRlZmluZSggdGhpcy5DbGFzcywgaSwgdmFsW2ldIClcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBFeHRlbmQgaXMgdXNlZCB0byBhZGQgcHJvcGVydGllcyB0byBiYXNlLlxuICAgKiBTZXR0aW5ncyBhcmUgc2ltaWxhciB0byBzdGFuZGFyZCBkZWZpbmVQcm9wZXJ0eS5cbiAgICogQG1ldGhvZCBleHRlbmRcbiAgICogQHBhcmFtICAge09iamVjdH0gICBzZXR0aW5ncyAgICAgICAgRGVmaW5lIHRoZSBmb2xsb3dpbmcgZmllbGRzOiBuYW1lLCB0eXBlLCBzZXQsIG5ldywgcmVtb3ZlLlxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgIHNldHRpbmdzLm5hbWUgICBEZWZpbmUgdGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgW3NldHRpbmdzLnR5cGVdIERlZmluZSB0aGUgdHlwZSBvZiBvYmplY3QgZS5nLiBWLlZhbHVlLCBzZXQgdHlwZSB0byBmYWxzZSBpZiB5b3Ugd2FudCB0byB1c2Ugc3RhbmRhcmQgZGVmaW5lUHJvcGVydHlcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBzZXR0aW5ncy5zZXQgICAgRGVmaW5lIGEgZnVuY3Rpb24gb24gc2V0XG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gc2V0dGluZ3MubmV3ICAgIERlZmluZSBhIGZ1bmN0aW9uIG9uIGNvbnN0cnVjdFxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259IHNldHRpbmdzLnJlbW92ZSBEZWZpbmUgYSBmdW5jdGlvbiBvbiByZW1vdmVcbiAgICogQHJldHVybiAge1t0eXBlXX0gICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2V4dGVuZCcsIGZ1bmN0aW9uKHNldHRpbmdzKSB7XG5cbiAgICAvL1RPRE86IGFkZCB0byBpbnN0YW5jZSBhcyB3ZWxsICwgaGF2ZSBhIGRpY3Rpb25hcnkgb2YgZXh0ZW5zdGlvbnMgLS0gZ2V0IHRvIG9yZ2luYWwgZWFzeWx5XG4gICAgdmFyIGFyZ3MgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gICAgICAsIGwgPSBhcmdzLmxlbmd0aFxuICAgICAgLCBpXG5cbiAgICBpZiAobCA+IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyB0aGlzLmV4dGVuZCggYXJnc1tpKytdICkpO1xuICAgIH0gZWxzZSBpZiAoIXNldHRpbmdzLm5hbWUpIHtcbiAgICAgIGZvciAoaSBpbiBzZXR0aW5ncykge1xuXG4gICAgICAgIGlmKCB0eXBlb2Ygc2V0dGluZ3NbaV0gPT09ICdmdW5jdGlvbicgKSBcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuZXh0ZW5kKCB7IG5hbWU6IGksIHNldDogc2V0dGluZ3NbaV0gfSApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgc2V0dGluZ3NbaV0ubmFtZSA9IGlcbiAgICAgICAgICB0aGlzLmV4dGVuZCggc2V0dGluZ3NbaV0gKVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiggc2V0dGluZ3MgPT09IHRydWUgKXtcbiAgICAgICAgYWxlcnQoKVxuICAgICAgfVxuXG5cbiAgICAgIGlmICghc2V0dGluZ3MuZGVmICYmIHNldHRpbmdzLmRlZiAhPT0gMCkgc2V0dGluZ3MuZGVmID0gZmFsc2U7XG4gIFxuICAgICAgaWYgKHRoaXMuQ2xhc3MucHJvdG90eXBlLl9zZXR0aW5ncykge1xuICAgICAgICBleHBvcnRzLnNldHRpbmdzLnBhcnNlLmNhbGwodGhpcywgc2V0dGluZ3MpXG4gICAgICAgIGlmIChzZXR0aW5ncy5fc2V0dGluZ3MpIGV4cG9ydHMuc2V0dGluZ3MuY3JlYXRlLmNhbGwodGhpcywgc2V0dGluZ3MpXG4gICAgICB9XG4gICAgICAvLzEuIG5vcm1hbCBleHRlbnNpb25zXG4gICAgICBpZiAoc2V0dGluZ3MudHlwZSA9PT0gZmFsc2UgfHwgKCAhc2V0dGluZ3MudHlwZSAmJiAhdGhpcy5kZWZhdWx0VHlwZSApICkge1xuXG4gICAgICAgIC8vVE9ETzogdGVzdCBpZiBkb3VibGUgZGVmaW5lIGlzIGFjdHVhbGx5IG9rIVxuICAgICAgICAvLyB1dGlsLmRlZmluZSh0aGlzLCBzZXR0aW5ncy5uYW1lLCBzZXR0aW5ncylcblxuICAgICAgICB1dGlsLmRlZmluZSh0aGlzLkNsYXNzLCBzZXR0aW5ncy5uYW1lLCBzZXR0aW5ncylcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8yLiBWLlZhbHVlc1xuICAgICAgICBpZiAoIXNldHRpbmdzLnR5cGUpIHNldHRpbmdzLnR5cGUgPSB0aGlzLmRlZmF1bHRUeXBlXG4gICAgICAgICAgLy9hIHR5cGUgaGFzIGZpZWxkcyB0eXBlLCBzZXQgLGdldCwgY3JlYXRlXG4gICAgICAgIHZhciBnZXQgPSAgZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICAgICAgLy9jdXN0b20gZ2V0XG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MudHlwZS5nZXQgXG4gICAgICAgICAgICAgID8gc2V0dGluZ3MudHlwZS5nZXQuY2FsbCh0aGlzLCBwcm9wLCBzZXR0aW5ncylcbiAgICAgICAgICAgICAgOiBwcm9wXG4gICAgICAgICAgfVxuICAgICAgICAgICwgc2V0ID0gIGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAgICAgICB2YXIgcHJvcCA9IHRoaXNbc2V0dGluZ3MubmFtZV1cbiAgICAgICAgICAgIGlmKHByb3A9PT1udWxsKSByZXR1cm5cbiAgICAgICAgICAgIGlmIChwcm9wPT09c2V0dGluZ3MuZGVmKSB7IC8vKHByb3AgaW5zdGFuY2VvZiBWLk9iamVjdClcbiAgICAgICAgICAgICAgLy9yZXR1cm4gaXMgaGllciBtaXNjaGllbiBuaWV0IG5vZGlnO1xuICAgICAgICAgICAgICByZXR1cm4gc2V0dGluZ3MudHlwZS5jcmVhdGUuY2FsbCh0aGlzLCB2YWwsIHByb3AsIHNldHRpbmdzKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsID0gc2V0dGluZ3MudHlwZS5zZXQuY2FsbCh0aGlzLCB2YWwsIHByb3AsIHNldHRpbmdzKVxuICAgICAgICAgICAgICBpZiAodmFsIT09IG51bGwpIHByb3AudmFsID0gdmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vVE9ETzogdGVzdCBpZiBkb3VibGUgZGVmaW5lIGlzIGFjdHVhbGx5IG9rIVxuICAgICAgICB1dGlsLmRlZmluZShcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIHNldHRpbmdzLm5hbWUsXG4gICAgICAgICAgc2V0dGluZ3MuZGVmLFxuICAgICAgICAgIHNldCxcbiAgICAgICAgICBnZXQsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICAgIC8vZGl0IGJyZWFrZWQgd2F0IHNoaXRcblxuICAgICAgICAvL29yIG9uIHZhbHVlID8gdmFsdWUucHJvcFxuXG4gICAgICAgIC8vbWFrZSBleHRlbmRlZCBwcm90b3R5cGUgb2JqZWN0IHBlcmhhcHNcbiAgICAgICAgLy8gdGhpcy5DbGFzcy5wcm90b3R5cGVbJ19fJytzZXR0aW5ncy5uYW1lKydfXyddID0gc2V0dGluZ3NcblxuICAgICAgICB1dGlsLmRlZmluZShcbiAgICAgICAgICB0aGlzLkNsYXNzLFxuICAgICAgICAgIHNldHRpbmdzLm5hbWUsXG4gICAgICAgICAgc2V0dGluZ3MuZGVmLFxuICAgICAgICAgIHNldCxcbiAgICAgICAgICBnZXRcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhpcyBCYXNlLiBBbHNvIHJlbW92ZXMgYWxsIGxpc3RlbmVycyBhZGRlZCB0byBleHRlbnNpb25zLlxuICAgKiBJbnN0YW5jZXMgdHJ1ZSB3aWxsIHJlbW92ZSBhbGwgaW5zdGFuY2VzIGFzIHdlbGwuXG4gICAqIEBtZXRob2QgcmVtb3ZlXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gaW5zdGFuY2VzICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZnJvbXJlbW92ZSBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gcGFyYW1zICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAncmVtb3ZlJywgZnVuY3Rpb24oaW5zdGFuY2VzLCBmcm9tcmVtb3ZlLCBwYXJhbXMpIHtcblxuICAgIC8vIHRoaXMuX3JlbW92aW5nID0gdHJ1ZVxuXG4gICAgaWYoIXRoaXMuX2Zyb20pIHJldHVyblxuXG4gICAgdGhpcy5zZXR0aW5nKCdyZW1vdmUnLCBbcGFyYW1zXSk7XG5cbiAgICBpZiAoIWZyb21yZW1vdmUpIHtcbiAgICAgIHZhciBpbnMgPSB0aGlzLl9mcm9tLmJhc2UuaW5zdGFuY2VzXG4gICAgICBpZihpbnMpIHtcbiAgICAgICAgZm9yICh2YXIgbiA9IDAsIGwgPSBpbnMubGVuZ3RoOyBpbnNbbl0gIT09IHRoaXMgfHwgIWlucy5zcGxpY2UobiwgMSk7IG4rKyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiB0aGlzLl9fKSB7XG4gICAgICBpZiAodGhpcy5fX1tpXSBpbnN0YW5jZW9mIFYuT2JqZWN0KSB7XG4gICAgICAgIC8vbmVzdGVkLCBibGFja2xpc3QsIG5vdCAoZmllbGRzIGluIG9iamVjdCksIGZyb20sIHN0YW1wLCBub3VwZGF0ZVxuLy8gICAgICAgICBjb25zb2xlLmxvZygnLS0tLS0tLS0tJywgaSwgdGhpcy5fX1tpXSwgdGhpcy5fX1tpXS5fcGF0aCApXG4gICAgICAgIHRoaXMuX19baV0ucmVtb3ZlKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX19baV0gPSBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9fW2ldID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9fID0gbnVsbFxuXG4gICAgaWYgKGluc3RhbmNlcyAmJiB0aGlzLmluc3RhbmNlcykge1xuICAgICAgZm9yIChqID0gdGhpcy5pbnN0YW5jZXMubGVuZ3RoIC0gMTsgaiA+PSAwOyB0aGlzLmluc3RhbmNlc1tqLS1dLnJlbW92ZSh0cnVlLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiBpbiB0aGlzKSB7XG4gICAgICAvLyBpZih0aGlzW2pdIGluc3RhbmNlb2YgVi5CYXNlKSB7XG4gICAgICAvLyAgIHRoaXNbal0ucmVtb3ZlKClcbiAgICAgIC8vIH0gXG4gICAgICB0aGlzW2pdID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXR0aW5ncyA9IG51bGxcbiAgICB0aGlzLl8gPSBudWxsXG4gICAgZGVsZXRlIHRoaXMuX3NldHRpbmdzXG4gICAgZGVsZXRlIHRoaXMuX1xuICAgIGRlbGV0ZSB0aGlzLl9fXG4gICAgLy8gZGVsZXRlIHRoaXMuX2NsYXNzOyBtYXkgbm90IGJlIG5lc3NlY2FyeVxuICB9LFxuICAvKnNldCBvbiBwcm90b3R5cGUqL1xuICAnc2V0JywgX3NldCxcbiAgJ2dldCcsIGZ1bmN0aW9uKCBwYXRoLCBzZWxmICkge1xuICAgIHJldHVybiB1dGlsLmdldCggdGhpcywgcGF0aCwgc2VsZiApXG4gIH0sXG5cbiAgJ2luamVjdCcsIGluamVjdCxcbiAgLyoqXG4gICAqIFBhc3NlcyBmaWVsZCBwYXJhbWV0ZXIgb25seSBmb3IgaW5zdGFuY2VzIG1hdGNoaW5nIGEgZmllbGRcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gZm4gICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgZmllbGQgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHsqfSAgICAgICAgdmFsICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHsqfSAgICAgICAgcCAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2VhY2hJbnN0YW5jZScsIGZ1bmN0aW9uKGZuLCBmaWVsZCwgdmFsLCBwKSB7XG4gICAgdmFyIGluc3RhbmNlcyA9IHRoaXMuaW5zdGFuY2VzO1xuICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5zdGFuY2VzLmxlbmd0aCwgaW5zdGFuY2U7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaV07XG5cblxuLy9wcm9ibGVtISBoYXMgdG8gY29ycmVjdCBmb3IgbWlzc2luZyBpbnN0YW5jZXMhISFcbi8vICAgY29uc29sZS5sb2coaW5zdGFuY2UsIGluc3RhbmNlcylcblxuICAgICAgICAgIFxuXG4gICAgICAgIGlmIChpbnN0YW5jZSAmJiAoIWZpZWxkIHx8ICFpbnN0YW5jZS5fXyB8fCAhaW5zdGFuY2UuX19bZmllbGRdKSkge1xuICAgICAgICAgIGlmIChmbi5jYWxsKGluc3RhbmNlLCB2YWwsIHApKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluc3RhbmNlLmVhY2hJbnN0YW5jZShmbiwgZmllbGQsIHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKCFpbnN0YW5jZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1xcblxcblxcblxcbmluc3RhbmNlIGluIGJhc2UgZ29uZT8nLCBpICwgaW5zdGFuY2VzKVxuICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY2xhc3MgZnJvbSB0aGUgY3VycmVudCBCYXNlIGluc3RhbmNlXG4gICAqIEBjb25zdHJ1Y3RvciBDbGFzc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqL1xuICAnQ2xhc3MnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fY2xhc3MpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZXMgPSBbXTtcbiAgICAgICAgdGhpcy5fY2xhc3MgPSBmdW5jdGlvbih2YWwsIHByb3RvLCBzZXR0aW5nKSB7XG4gICAgICAgICAgaWYgKCFwcm90bykge1xuICAgICAgICAgICAgdmFyIGZyb20gPSB0aGlzLl9mcm9tLmJhc2U7XG4gICAgICAgICAgICBmcm9tLmluc3RhbmNlcy5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZykge1xuICAgICAgICAgICAgICB0aGlzLnNldHRpbmcoJ25ldycsIFtmcm9tLCBzZXR0aW5nXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0KHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jbGFzcy5iYXNlID0gdGhpcztcbiAgICAgICAgdGhpcy5fY2xhc3MucHJvdG90eXBlID0gbmV3IHRoaXMuX2Zyb20oZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLl9jbGFzcy5wcm90b3R5cGUuX18gPSBudWxsO1xuICAgICAgICB1dGlsLnNldHN0b3JlLmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBpLCBfcHJvdG8gPSB0aGlzLl9jbGFzcy5wcm90b3R5cGUuXyA9IHt9O1xuICAgICAgICBmb3IgKGkgaW4gdGhpcy5fXykge1xuICAgICAgICAgIF9wcm90b1tpXSA9IHRoaXMuX19baV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpIGluIHRoaXMuXykge1xuICAgICAgICAgIGlmIChfcHJvdG9baV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgX3Byb3RvW2ldID0gdGhpcy5fW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbGFzcy5wcm90b3R5cGUuX2Zyb20gPSB0aGlzLl9jbGFzcztcbiAgICAgICAgdGhpcy5fY2xhc3MuaW5qZWN0ID0gaW5qZWN0XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY2xhc3M7XG4gICAgfVxuICB9KTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4vJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8qKlxuICogU2V0dGluZ3MgYXJlIHVzZWQgZm9yIHNwZWNpYWwgY2FzZXMgZS5nLiBvblJlbW92ZSBvciBvbk5ldyBpbnN0YW5jZVxuICogQHByb3BlcnR5XG4gKi9cbnV0aWwuZGVmaW5lKGJhc2UsICdfc2V0dGluZ3MnKTtcblxuYmFzZS5wcm90b3R5cGUuXy5fc2V0dGluZ3MgPSB7fTtcblxuLyoqXG4gKiBTZXQgc2V0dGluZ3Mgb24gQmFzZVxuICogQGZ1bmN0aW9uIF9zZXRcbiAqIEBwYXJhbSAge09iamVjdH0gIHNldCAgICAgIE9iamVjdCB0byBzZXRcbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtyZW1vdmVdXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbZm9yY2VdICBUcnVlL2ZhbHNlXG4gKi9cbnZhciBfc2V0ID0gZnVuY3Rpb24oc2V0LCByZW1vdmUsIGZvcmNlKSB7XG4gIHZhciBfcyA9IHNldC5fc2V0dGluZ3MgLy9lLmcuIG5vZGUgLCByZW1vdmUgYW5kIHBhcmVudFxuICAgICwgdCA9IHRoaXNcbiAgICAsIF9fdCA9IHQuXy5fc2V0dGluZ3NcbiAgICAsIHNldHRpbmdcbiAgICAsIGlcbiAgICAsIF90XG5cbiAgdXRpbC5zZXRzdG9yZS5jYWxsKHQpXG5cbiAgaWYgKCF0Ll9fLl9zZXR0aW5ncykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjcmVhdGUgbXkgb3duIHNldHRpbmdzJylcbiAgICB0Ll9fLl9zZXR0aW5ncyA9IHt9XG4gICAgZm9yICh2YXIgaiBpbiBfX3QpIHtcbiAgICAgIHQuX3NldHRpbmdzW2pdID0gX190W2pdXG4gICAgfVxuICB9XG5cbiAgX3QgPSB0Ll9fLl9zZXR0aW5nc1xuXG4gIC8vIGNvbnNvbGUubG9nKCdTRVRUSU5HUz8nLmludmVyc2UsIHNldCwgX190KVxuXG4gIGZvciAoaSBpbiBfcykge1xuICAgIHNldHRpbmcgPSBfc1tpXVxuICAgIC8vZWZmaWNpZW50IG1lbW9yeSBtYW5hZ2VtZW50IG9ubHkgbWFrZSBvd24gaWYgYWJzb2x1dGVseSBuZXNzZWNhcnlcbiAgICBpZiAoKHJlbW92ZSAmJiBfdFtzZXR0aW5nXVtzZXQubmFtZV0pIHx8ICghcmVtb3ZlICYmICFfdFtzZXR0aW5nXVtzZXQubmFtZV0pIHx8IGZvcmNlKSB7XG4gICAgICBcbiAgICAgIGlmIChfdFtzZXR0aW5nXSA9PT0gX190W3NldHRpbmddKSB7XG4gICAgICAgIF90W3NldHRpbmddID0ge31cbiAgICAgICAgZm9yICh2YXIgbiBpbiBfX3Rbc2V0dGluZ10pIHtcbiAgICAgICAgICBfdFtzZXR0aW5nXVtuXSA9IF9fdFtzZXR0aW5nXVtuXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgdGhpcy5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHRoaXNbc2V0Lm5hbWVdICE9PSB0W3NldC5uYW1lXSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmcgIT09IF90ICYmIHRoaXMuX3NldHRpbmdzW3NldHRpbmddID09PSBfdFtzZXR0aW5nXSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZm91bmQgdGhhdCB0aGUgc2V0dGluZ3MgYXJlIHRoZSBzYW1lIGFuZCBub3QgdGhlIHNhbWUgcHJvcGVydHkgbWFrZSBteSBvd24nKTtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLSBTRVRUSU5HJylcbiAgICAgICAgICAgICAgX3NldC5jYWxsKHRoaXMsIF90W3NldHRpbmddW3NldC5uYW1lXSwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZyAhPT0gX3QgJiYgdGhpcy5fc2V0dGluZ3Nbc2V0dGluZ10gIT09IF90W3NldHRpbmddKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0gUkVNT1ZFIFNFVFRJTkcnKVxuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubmFtZSxzZXQubmFtZSwnZm91bmQgdGhhdCB0aGUgcHJvcGVydHkgaXMgdGhlIHNhbWUgYnV0IHNldHRpbmdzIGFyZSBub3QhJyk7XG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2V0dGluZyhzZXQubmFtZSwgc2V0dGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgX3Rbc2V0dGluZ11bc2V0Lm5hbWVdID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIF90W3NldHRpbmddW3NldC5uYW1lXTsgLy9kZWxldGUgaXMga3V0ITtcbiAgICAgICAgaWYgKHV0aWwuZW1wdHkoX3Rbc2V0dGluZ10pKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2xldHMgcHV0IHRoaXMgdG8gdHJ1ZSEnKVxuICAgICAgICAgIF90W3NldHRpbmddID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLSBETyBTRVRUSU5HJywgc2V0LCBfdCwgc2V0dGluZywgc2V0Lm5hbWUpXG4gICAgICAgIGlmKF90W3NldHRpbmddPT09dHJ1ZSkge1xuICAgICAgICAgIF90W3NldHRpbmddPXt9XG4gICAgICAgIH1cbiAgICAgICAgX3Rbc2V0dGluZ11bc2V0Lm5hbWVdID0gc2V0O1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVTVUxUPycsIHNldHRpbmcsIF90W3NldHRpbmddKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCdTRVRUSU5HUz8gLS0gcmVzdWx0Jy5pbnZlcnNlLCBfdCwgdGhpcy5fc2V0dGluZ3M9PT1fdCwgdGhpcy5CTFVYRU4pXG5cbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldHRpbmdcbiAqIEBtZXRob2QgY3JlYXRlXG4gKiBAcGFyYW0gIHtbdHlwZV19IHNldCBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oc2V0KSB7XG4gIHNldC5fc2V0ID0gc2V0LnNldDtcbiAgc2V0LnNldCA9IGZ1bmN0aW9uKHZhbCwgcHJvcCkge1xuICAgIF9zZXQuY2FsbCh0aGlzLCBzZXQpXG4gICAgc2V0Ll9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdHMgc2V0dGluZ3MgZnJvbSBzZXR0aW5nc29iamVjdCBhbmQgc3RvcmVzIHRoZW0gaW4gYW4gYXJyYXkuXG4gKiBAbWV0aG9kIHBhcnNlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzIFNldHRpbmdvYmplY3RcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqZWN0ICAgU2V0dGluZ3NvYmplY3RcbiAqL1xuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKHNldHRpbmdzLCBvYmplY3QpIHtcbiAgaWYgKCFvYmplY3QpIHtcbiAgICBvYmplY3QgPSB0aGlzLl9zZXR0aW5nc1xuICB9XG4gIGZvciAodmFyIGkgaW4gb2JqZWN0KSB7XG4gICAgaWYgKHNldHRpbmdzW2ldKSB7XG4gICAgICBpZiAoIXNldHRpbmdzLl9zZXR0aW5ncykge1xuICAgICAgICBzZXR0aW5ncy5fc2V0dGluZ3MgPSBbXTtcbiAgICAgIH1cbiAgICAgIHNldHRpbmdzLl9zZXR0aW5ncy5wdXNoKGkpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGRzIHNldHRpbmcocykgdG8gQmFzZSBwcm90b3R5cGVcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0gIHtTdHJpbmdbXX0gICAgbmFtZSAgQXJyYXkgb2Ygc2V0dGluZ25hbWVzXG4gKiBAcGFyYW0gIHtQcm90b3R5cGV9ICAgcHJvdG8gUHJvdG90eXBlIGVnLiBteUJhc2UgY2xhc3NcbiAqL1xuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbihuYW1lLCBwcm90bykgeyAvL3N0YXJ0IHVzaW5nIHRoaXMgc29tZXRpbWVzITtcbiAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAodmFyIGkgaW4gbmFtZSkge1xuICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgIHRoaXMuYWRkKG5hbWVbaV0sIHByb3RvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkU2V0dGluZyhuYW1lW2ldLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghcHJvdG8pIHtcbiAgICAgIHV0aWwuc2V0c3RvcmUuY2FsbCh0aGlzKTtcbiAgICAgIGlmICghdGhpcy5fXy5fc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fXy5fc2V0dGluZ3MgPSB7fTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGogaW4gdGhpcy5fLl9zZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9zZXR0aW5nc1tqXSA9IHRoaXMuXy5fc2V0dGluZ3Nbal07XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXR0aW5nc1tuYW1lXSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3RvLnByb3RvdHlwZS5fc2V0dGluZ3NbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgc2V0dGluZ3MgdG8gaW5zdGFuY2VzIG9mIEJhc2VcbiAqIHNldHRpbmdzIG9ubHkgd29yayBmb3IgaW5zdGFuY2VzIG9mIHRoZSBhZGRlZCBCYXNlc2V0dGluZ3NcbiAqIEBtZXRob2RcbiAqL1xudXRpbC5kZWZpbmUoYmFzZSxcbiAgJ2FkZFNldHRpbmcnLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgZXhwb3J0cy5hZGQuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICBpZiAodGhpcy5fY2xhc3MpIHtcbiAgICAgIHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fLl9zZXR0aW5ncyA9IHRoaXMuX3NldHRpbmdzO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiBzZXR0aW5nLmNyZWF0ZVxuICAgKiBAbWV0aG9kIHNldFNldHRpbmdcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzZXQgU2V0dGluZ29iamVjdFxuICAgKi9cbiAgJ3NldFNldHRpbmcnLCBmdW5jdGlvbihzZXQpIHtcbiAgICAvL2VlcnN0IGNoZWNrZW4gb2YgaWUgYWwgYmVzdGFhdCBhbmRlcnMga2FuIGhldCB2b29ya29tZW4gZGF0IGhldCB0ZXZlZWwgaXNcbiAgICBleHBvcnRzLnBhcnNlLmNhbGwodGhpcywgc2V0KTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgU0VUVElORycueWVsbG93LmludmVyc2UsIHNldCwgdGhpcy5fc2V0dGluZ3MgKVxuXG4gICAgLy9nZXQgZ2VicnVpa2VuIC0tLSBvYmplY3QgaXMgZWVuIGNoZWNrIG9wIG1lZXJkZXJlIGZpZWxkcyByZXR1cm5zIHRydWUgb2YgZmFsc2UgLy8gYmlqIGdldCBvb2sgbW9nZWxpamsgb20gZmllbGQgbWVlIHRlIGdldmVuXG4gICAgX3NldC5jYWxsKHRoaXMsIHNldCk7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnU0VUIFNFVFRJTkcgLS0gcmVzdWx0Jy55ZWxsb3cuaW52ZXJzZSwgdGhpcy5fc2V0dGluZ3MgKVxuXG4gIH0sXG4gIC8qKlxuICAgKiBbZGVzY3JpcHRpb25dXG4gICAqIEBtZXRob2QgcmVtb3ZlU2V0dGluZ1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgIG5hbWUgICAgIE5hbWUgb2YgdGhlIHNldHRpbmcgdG8gcmVtb3ZlXG4gICAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gc2V0dGluZ3MgU2V0dGluZ29iamVjdFxuICAgKi9cbiAgJ3JlbW92ZVNldHRpbmcnLCBmdW5jdGlvbihuYW1lLCBzZXR0aW5ncykge1xuXG4gICAgLy8gaWYoIXNldHRpbmdzKSB7XG4gICAgLy8gICAvL3RoaXMgbWF5IGFsbCBiZSBub3QgbmVzc2VjYXJ5IVxuICAgIC8vICAgZm9yKHZhciBpIGluIHRoaXMuX3NldHRpbmdzKSB7XG4gICAgLy8gICAgIGZvcih2YXIgaiBpbiB0aGlzLl9zZXR0aW5nc1tpXSkge1xuICAgIC8vICAgICAgIGlmKHRoaXMuX3NldHRpbmdzW2ldW2pdLm5hbWU9PT1uYW1lKSB7XG4gICAgLy8gICAgICAgICBzZXR0aW5ncz10aGlzLl9zZXR0aW5nc1tpXVtqXVxuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgICAgfVxuICAgIC8vICAgICB9XG4gICAgLy8gICB9XG4gICAgLy8gfVxuXG4gICAgaWYgKCEoc2V0dGluZ3MgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIC8vdGhpcyBtYXkgYWxsIGJlIG5vdCBuZXNzZWNhcnkhXG4gICAgICAvLyBpZihzZXR0aW5ncyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgLy8gICBzZXR0aW5ncyA9IHNldHRpbmdzLl9zZXR0aW5nc1xuICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgc2V0dGluZ3MgPSBbc2V0dGluZ3NdO1xuICAgICAgLy8gfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSBzZXR0aW5ncy5sZW5ndGggLSAxLCBmb3VuZCwgX3NldHRpbmdzID0gdGhpcy5fc2V0dGluZ3M7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoX3NldHRpbmdzICYmIF9zZXR0aW5nc1tzZXR0aW5nc1tpXV0gJiYgX3NldHRpbmdzW3NldHRpbmdzW2ldXVtuYW1lXSkge1xuICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm91bmQpIHtcbiAgICAgIF9zZXQuY2FsbCh0aGlzLCB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIF9zZXR0aW5nczogc2V0dGluZ3NcbiAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIG9iamVjdCBoYXMgc2V0dGluZ3MgYW5kIGV4ZWN1dGVzIHRoZW0uIEFyZ3VtZW50cyBhcmUgcGFzc2VkIHRvIHNldHRpbmdzLlxuICAgKiBAbWV0aG9kIHNldHRpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICBuYW1lIE5hbWUgb2YgdGhlIHNldHRpbmdcbiAgICogQHBhcmFtICB7QXJndW1lbnRzfSBhcmcgIEFyZ3VtZW50cyB0byBwYXNzIHRvIHNldHRpbmdzXG4gICAqL1xuICAnc2V0dGluZycsIGZ1bmN0aW9uKG5hbWUsIGFyZykgeyAvL21pc3NjaGllbiBhcmdcbiAgICB2YXIgX3MgPSB0aGlzLl9zZXR0aW5ncztcbiAgICBpZiAoX3MgJiYgX3NbbmFtZV0gJiYgX3NbbmFtZV0gIT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gX3NbbmFtZV0pIHtcbiAgICAgICAgX3NbbmFtZV1baV1bbmFtZV0uYXBwbHkodGhpcywgYXJnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4vKipcbiAqIEJhc2UgaGFzIHR3byBkZWZhdWx0IHNldHRpbmdzXG4gKiBuZXcgaXMgaW52b2tlZCBvbiBjb25zdHJ1Y3Rpb24gLCByZW1vdmUgb24gcmVtb3ZhbDtcbiAqIEBzZXR0aW5nc1xuICovXG5leHBvcnRzLmFkZChbJ25ldycsICdyZW1vdmUnXSwgYmFzZSlcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cbnZhciBhbmltYXRpb24gPSByZXF1aXJlKCcuLycpO1xuYW5pbWF0aW9uLmVhc2luZyA9IGV4cG9ydHM7XG4vLyB0OiBjdXJyZW50IHRpbWUsIGI6IGJlZ2lubmluZyB2YWx1ZSwgYzogY2hhbmdlIEluIHZhbHVlLCBkOiBkdXJhdGlvblxuLy8gY291cnRlc3kgb2YgUm9iZXJ0IFBlbm5lclxuZXhwb3J0cy5pbkN1YmljID0gZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICByZXR1cm4gYyAqICh0IC89IGQpICogdCAqIHQgKyBiO1xufTtcblxuZXhwb3J0cy5vdXRDdWJpYyA9IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqIHQgKyAxKSArIGI7XG59O1xuXG5leHBvcnRzLm91dEJhY2sgPSBmdW5jdGlvbih0LCBiLCBjLCBkLCBzKSB7XG4gIHZhciBzID0gMS43MDE1ODtcbiAgcmV0dXJuIGMgKiAoKHQgPSB0IC8gZCAtIDEpICogdCAqICgocyArIDEpICogdCArIHMpICsgMSkgKyBiO1xufTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgVmFsdWUgPSByZXF1aXJlKCcuLi8uLi92YWx1ZScpXG4gICwgZnJhbWUgPSBuZXcgVmFsdWUoMSlcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgX29uID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gY29uc29sZS5ncm91cCgpXG4gICAgLy8gY29uc29sZS5sb2coJ1xcblxcbi0tLS1SQUYtLS0tJy5tYWdlbnRhLmJvbGQpXG4gICAgZXhwb3J0cy5yYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX29uKVxuICAgIGZyYW1lLnZhbCsrXG4gICAgLy8gY29uc29sZS5ncm91cEVuZCgpXG4gIH1cblxuZnJhbWUuZG9uZSA9IG5ldyBWYWx1ZSh0cnVlKVxuXG51dGlsLmRlZmluZShmcmFtZSxcbiAgJ2FkZExpc3RlbmVyJywgZnVuY3Rpb24odmFsLCBtYXJrLCByZW1vdmUpIHtcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycyl7XG4gICAgICB0aGlzLmRvbmUudmFsID0gZmFsc2VcbiAgICAgIF9vbigpXG4gICAgfVxuICAgIFZhbHVlLnByb3RvdHlwZS5hZGRMaXN0ZW5lci5jYWxsKHRoaXMsIHZhbCwgbWFyaywgcmVtb3ZlKVxuICB9XG4sICdyZW1vdmVMaXN0ZW5lcicsIGZ1bmN0aW9uKHZhbCwgbWFyaywgcmVtb3ZlKSB7XG4gICAgdmFyIHQgPSB0aGlzXG4gICAgVmFsdWUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodCwgdmFsLCBtYXJrLCByZW1vdmUpXG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShleHBvcnRzLnJhZklkKVxuICAgICAgdGhpcy52YWwgPSAxXG4gICAgICB0aGlzLmRvbmUudmFsID0gdHJ1ZVxuICAgIH1cbiAgfVxuKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZyYW1lIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQnKS5pbmplY3QocmVxdWlyZSgnLi4vZWxlbWVudC9wcm9wZXJ0aWVzJykpIC8vZWxlbWVudCBhZGRlZCAoZXh0ZW5kKSAvL2NhbGwgZXh0ZW5kIG9uIGZsYWdzIChtYWtlIGJ1ZmZlciBpZiBhbHJlYWR5IGV4dGVuZGVkKVxuICAsIG9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIGZsYWdzID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3MvdXRpbCcpXG4gICwgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUvb3BlcmF0b3JzJylcbiAgLCBmcmFtZSA9IHJlcXVpcmUoJy4vZnJhbWUnKVxuICAsIF9saW5lYXIgPSBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGMgKiB0IC8gZCArIGJcbiAgfVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5vcGVyYXRvcnMuX2EgPSBmdW5jdGlvbiAodmFsLCBvcGVyYXRvcikge1xuICByZXR1cm4gb3BlcmF0b3Jcbn1cblxuZnVuY3Rpb24gcHJldmVudFNldCh2YWwpIHtcbiAgdGhpcy5fcCA9IHRydWVcbiAgdGhpcy52YWwgPSB2YWxcbiAgdGhpcy5fcCA9IGZhbHNlXG59XG5cbm9wZXJhdG9ycy5fYS5vcmRlciA9IDJcblxuZmxhZ3MuYW5pbWF0aW9uID0ge1xuICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBcbiAgICB2YXIgdGhpc09iamVjdCA9IHRoaXNcbiAgICAgICwgX3AgPSB0aGlzT2JqZWN0LmNoZWNrUGFyZW50KCdfcHJvcCcpXG5cbiAgICBpZiAodmFsKSB7XG5cbiAgICAgIGlmICghdGhpc09iamVjdC5fdmFsKSB0aGlzT2JqZWN0LnZhbCA9IDBcblxuICAgICAgdmFyIG5hbWUgPSBfcC5fcHJvcC5uYW1lXG4gICAgICAgICwgZWxlbWVudCA9IF9wLl9jYWxsZXJcbiAgICAgICAgLCBub0xpc3RlbmVyID0gdmFsLm5vTGlzdGVuZXJcbiAgICAgICAgLCBwYXRoID0gdGhpc09iamVjdC5fcGF0aFxuICAgICAgICAsIGlkID0gbmFtZS5jb25jYXQocGF0aC5qb2luKCcnKSlcbiAgICAgICAgLCBza2lwID0gdmFsLnNraXBcbiAgICAgICAgLCBlYXNpbmcgPSB2YWwuZWFzaW5nIFxuICAgICAgICAgICYmIGV4cG9ydHMuZWFzaW5nW3ZhbC5lYXNpbmddIFxuICAgICAgICAgIHx8IHZhbC5lYXNpbmcgXG4gICAgICAgICAgfHwgX2xpbmVhclxuICAgICAgICAsIHRpbWUsIHN0YXJ0LCByZWFkeVxuXG4gICAgICBpZighX3AuX2FuaW1MaXN0ZW4pIF9wLl9hbmltTGlzdGVuID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICB2YXIgdG4gPSB0aGlzW25hbWVdXG4gICAgICAgIGlmKHRuKSB0bi51cGRhdGUodGhpcywgdHJ1ZSlcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFyIEZPUlRFU1RJTkcgPSBmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoXG4gICAgICAgICAgY29uc29sZS5sb2coJ19hbmltTGlzdGVuIHNldHRpbmcnLGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpXG4gICAgICAgICAgZnJhbWUucmVtb3ZlTGlzdGVuZXIodm9pZCAwLCB0aGlzKVxuICAgICAgICAgIGNvbnNvbGUubG9nKCc+PiBfYW5pbUxpc3RlbiBzZXR0aW5nJyxmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgICAgIGlmKEZPUlRFU1RJTkcgJiYgRk9SVEVTVElORyA9PT0gKGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RoaXMgPj4nLHRoaXMpXG4gICAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbGVtZW50LnNldFNldHRpbmcoe1xuICAgICAgICBuYW1lOidhbmltYXRpb24nLFxuICAgICAgICByZW1vdmU6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIEZPUlRFU1RJTkcgPSBmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSBzZXR0aW5nJyxmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgICAgIFxuXG4gICAgICAgICAgZnJhbWUucmVtb3ZlTGlzdGVuZXIoIHZvaWQgMCwgdGhpcylcblxuXG4gICAgICAgICAgaWYoZnJhbWUuX2xpc3RlbmVycyAmJiBGT1JURVNUSU5HICYmIEZPUlRFU1RJTkcgPT09IChmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBmb3IodmFyIGkgaW4gZnJhbWUuX2xpc3RlbmVycyApIHtcbiAgICAgICAgICAgICAgaWYoIGZyYW1lLl9saXN0ZW5lcnNbaV0gaW5zdGFuY2VvZiBBcnJheSApIHtcbi8vICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ09NUEFSRScsZnJhbWUuX2xpc3RlbmVyc1tpXVsxXT09PXRoaXMsIGZyYW1lLl9saXN0ZW5lcnNbaV1bMV0sICd2cycsIHRoaXMgKVxuICAgICAgICAgICAgICAgIGlmKCBmcmFtZS5fbGlzdGVuZXJzW2ldWzFdPT09dGhpcywgZnJhbWUuX2xpc3RlbmVyc1tpXVsxXSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZnJhbWUuX2xpc3RlbmVycy5zcGxpY2UoaSwxKVxuLy8gICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0aGlzID4+Jyx0aGlzLm5vZGUpXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgX3AucHJldmVudFNldCA9IHByZXZlbnRTZXRcblxuICAgICAgX3Auc2V0KCd0cmFuc2xhdGUnLCB0cnVlKVxuXG4gICAgICB0aGlzT2JqZWN0LnNldCgnX2EnLCB7XG4gICAgICAgIHRpbWU6IHZhbC50aW1lIHx8IDYwLFxuICAgICAgICB2YWw6IGZ1bmN0aW9uKHYsIGN2LCBiKSB7XG4gICAgICAgICAgXG4gICAgICAgICAgdmFyIHQgPSB0aGlzXG4gICAgICAgICAgICAsIGFcbiAgICAgICAgICAgICwgcHJvcCA9IF9wIC8vdFtuYW1lXSB8fFxuICAgICAgICAgICAgLCBwciA9IHRbbmFtZV1cblxuICAgICAgICAgIGlmICghdC5fYSkgdC5fYSA9IHt9XG4gICAgICAgIFxuICAgICAgICAgIGlmICghdC5fYVtpZF0pIHtcblxuICAgICAgICAgICAgc3RhcnQgPSB2YWwuc3RhcnQgPT09IHZvaWQgMCBcbiAgICAgICAgICAgICAgPyB0LnJlbmRlcmVkICYmICh0aGlzT2JqZWN0Ll9fbHZhbCAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgID8gdGhpc09iamVjdC5fX2x2YWxcbiAgICAgICAgICAgICAgICA6IGN2XG4gICAgICAgICAgICAgIDogdmFsLnN0YXJ0IGluc3RhbmNlb2Ygb2JqZWN0IFxuICAgICAgICAgICAgICAgID8gdmFsLnN0YXJ0LnZhbFxuICAgICAgICAgICAgICAgIDogdmFsLnN0YXJ0XG5cbiAgICAgICAgICAgIHQuX2FbaWRdID0ge1xuICAgICAgICAgICAgICBfc3RhcnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBfZW5kOiBzdGFydCxcbiAgICAgICAgICAgICAgX2N1cnJlbnQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBfY291bnQ6IDBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0LnJlbmRlcmVkKSByZXR1cm4gc3RhcnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodC5yZW5kZXJlZCkge1xuICAgICAgICAgICAgaWYoc2tpcCkge1xuICAgICAgICAgICAgICB0Ll9hW2lkXS5fY3VycmVudCA9IGN2XG4gICAgICAgICAgICAgIHNraXAgPSBmYWxzZVxuICAgICAgICAgICAgICByZXR1cm4gY3ZcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYSA9IHQuX2FbaWRdXG4gICAgICAgICAgICBpZiAocHIuX3AgfHwgZXhwb3J0cy5wcmV2ZW50KSB7XG4gICAgICAgICAgICAgIGEuX2ZyYW1lID0gMFxuLy8gICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVtb3ZlIHByZXZlbnQnLGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpXG4gICAgICAgICAgICAgIGZyYW1lLnJlbW92ZUxpc3RlbmVyKHByb3AuX2FuaW1MaXN0ZW4sIHRoaXMsIHRydWUpXG4vLyAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+PiByZW1vdmUgcHJldmVudCcsZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgaWYgKHByLl9wICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgYS5fY3VycmVudCA9IGEuX2VuZCA9IGN2XG4gICAgICAgICAgICAgICAgaWYgKHZhbC5jb21wbGV0ZSkgbm9MaXN0ZW5lciA9IHZhbC5jb21wbGV0ZS5jYWxsKHQsIGN2KVxuICAgICAgICAgICAgICAgIGlmICh2YWwuZG9uZSkgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7IHZhbC5kb25lLmNhbGwodCxjdikgfSwgMClcbiAgICAgICAgICAgICAgICBpZiAodmFsLm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICAgICAgaWYodmFsLm9uY2UpIHZhbC5vbmNlLmNhbGwodCxjdikgXG4gICAgICAgICAgICAgICAgICAgIHZhbC5vbmNlID0gbnVsbFxuICAgICAgICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYS5fZnJhbWUgIT09IGZyYW1lLnZhbCkge1xuICAgICAgICAgICAgICBpZiAoYS5fZnJhbWUgfHwgKGN2ICE9PSB2b2lkIDAgJiYgYS5fY3VycmVudCAhPT0gY3YpKSB7IC8vY2hlY2tpbmcgYS5mcmFtZSBmYXN0ZXIgdGhhbiBjb21wYXJpbmcgYS5jdXJyZW50IHRvIGN2XG4gICAgICAgICAgICAgICAgaWYgKGEuX2VuZCAhPT0gY3YpIHtcblxuICAgICAgICAgICAgICAgICAgaWYgKHZhbC5pbml0KSB2YWwuaW5pdC5jYWxsKHQsIGEuX2N1cnJlbnQpXG4gICAgICAgICAgICAgICAgICBpZighbm9MaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5hZGRMaXN0ZW5lcihbcHJvcC5fYW5pbUxpc3RlbiwgdGhpcywgbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAsIGZ1bmN0aW9uIChsaXN0ZW5BcnJheSwgbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxpc3RlbmVyc1tpXS5wb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsaXN0ZW5lcnNbaV0ucG9wICYmIGxpc3RlbmVyc1tpXVsxXT09PXQgJiYgbGlzdGVuZXJzW2ldWzJdPT09bmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlIFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYS5fc3RhcnQgPSBhLl9jdXJyZW50XG4gICAgICAgICAgICAgICAgICBhLl9lbmQgPSBjdlxuICAgICAgICAgICAgICAgICAgYS5fY291bnQgPSAwXG4gICAgICAgICAgICAgICAgICB0aW1lID0gfn52LnRpbWUudmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGEuX2ZyYW1lID0gZnJhbWUudmFsXG5cbiAgICAgICAgICAgICAgICBpZih2YWwuZGVsYXkpe1xuICAgICAgICAgICAgICAgICAgdmFsLmRlbGF5LS1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBhLl9zdGFydFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBjbnQgPSArK2EuX2NvdW50XG4gICAgICAgICAgICAgICAgYS5fY3VycmVudCA9IGVhc2luZy5jYWxsKHQsIGNudCwgYS5fc3RhcnQsIGEuX2VuZCAtIGEuX3N0YXJ0LCB0aW1lIHx8ICh0aW1lID0gfn52LnRpbWUudmFsKSlcbiAgICAgICAgICAgICAgICBpZih2YWxbY250XSkgdmFsW2NudF0uY2FsbCh0aGlzLGEuX2N1cnJlbnQsY3YpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGEuX2NvdW50ID09PSB0aW1lKSB7ICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBhLl9jdXJyZW50ID0gY3ZcbiAgICAgICAgICAgICAgICBhLl9mcmFtZSA9IDBcbiAgICAgICAgICAgICAgICBhLl9jb3VudCA9IDBcblxuICAgICAgICAgICAgICAgIGlmICh2YWwuY29tcGxldGUpIG5vTGlzdGVuZXIgPSB2YWwuY29tcGxldGUuY2FsbCh0LCBjdilcbiAgICAgICAgICAgICAgICBpZiAodmFsLmRvbmUpIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyB2YWwuZG9uZS5jYWxsKHQsY3YpIH0sIDApXG4gICAgICAgICAgICAgICAgaWYgKHZhbC5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbC5vbmNlKSB2YWwub25jZS5jYWxsKHQsY3YpIFxuICAgICAgICAgICAgICAgICAgICB2YWwub25jZSA9IG51bGxcbiAgICAgICAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIW5vTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAge1xuLy8gICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlbW92ZSBub2xpc3RlbmVyJyxmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgZnJhbWUucmVtb3ZlTGlzdGVuZXIocHJvcC5fYW5pbUxpc3RlbiwgdGhpcywgdHJ1ZSlcbi8vICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc+PiByZW1vdmUgbm9saXN0ZW5lcicsZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhLl9jdXJyZW50XG4gICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgICAgICAgIFxuICAgICAgX3AuX3NraXAgPSB0cnVlXG4gICAgICB0aGlzT2JqZWN0Ll9za2lwID0gdHJ1ZVxuICAgICAgXG4gICAgICBpZiAodmFsLnN0YXJ0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIGNhbGxlciA9IHRoaXMuX2NhbGxlclxuICAgICAgICBpZighY2FsbGVyKSBjYWxsZXIgPSB0aGlzLmNoZWNrUGFyZW50KCdfcHJvcCcpLl9jYWxsZXJcbiAgICAgICAgY2FsbGVyLnNldFJlbmRlcihuYW1lLCBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZShuYW1lKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gXG4gICAgZWxzZSB7XG4gICAgICB0aGlzT2JqZWN0LnJlbW92ZSgnX2EnKVxuICAgICAgdGhpc09iamVjdC5fc2tpcCA9IHZvaWQgMFxuICAgICAgX3AuX3NraXAgPSB2b2lkIDBcbiAgICAgIF9yZW1vdmUoX3ApXG4gICAgfVxuXG4gIH1cbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG52YXIgdWEgPSByZXF1aXJlKCcuLi91YScpLFxuICBSQUYgPSAnZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLFxuICBDQVAgPSAnUicgKyBSQUYsXG4gIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgbGFzdEZyYW1lID0gMDtcblxudXRpbC5kZWZpbmUodWEsICdoYXNUcmFuc2l0aW9uJywge1xuICBnZXQ6ZnVuY3Rpb24oKSB7XG4gICAgaWYoIXVhLl9oYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgdmFyIGIgPSBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudFxuICAgICAgICAsIHMgPSBiLnN0eWxlXG4gICAgICAgICwgcCA9ICdyYW5zaXRpb24nO1xuICAgICAgdWEuX2hhc1RyYW5zaXRpb24gPSB0eXBlb2Ygc1sndCcrcF0gPT09ICdzdHJpbmcnIFxuICAgICAgICB8fCB0eXBlb2Ygc1t1YS5wcmVmaXggKyAnVCcrcF0gPT09ICdzdHJpbmcnXG4gICAgfVxuICAgIHJldHVybiB1YS5faGFzVHJhbnNpdGlvblxuICB9XG59KVxuICBcblJBRiA9ICdyJyArIFJBRjtcbmlmICghd2luZG93W1JBRl0pIHsgXG5cbiAgdWEubm9SYWYgPSB0cnVlXG5cbiAgLy93aW5kb3dbdWEucHJlZml4ICsgQ0FQXSB8fCBcblxuICB3aW5kb3dbUkFGXSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoY2FsbGJhY2ssIDIwKTtcbiAgfTtcbiAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oaWQpIHtcbiAgICBjbGVhclRpbWVvdXQoaWQpO1xuICB9O1xufVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gd2luZG93W1JBRl1cblxuZXhwb3J0cy50aW1lciA9IGZ1bmN0aW9uKCBmbiwgZnJhbWVzLCByZXBlYXQgKXtcbiAgaWYoIC0tZnJhbWVzICl7XG4gICAgZXhwb3J0cyhmdW5jdGlvbigpe1xuICAgICAgaWYoIHJlcGVhdCApIGZuKClcbiAgICAgIGV4cG9ydHMudGltZXIoIGZuLCBmcmFtZXMsIHJlcGVhdCApXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzKCBmbiApXG4gIH1cbn1cblxuZXhwb3J0cy5yZXBlYXQgPSBmdW5jdGlvbiggZm4sIGZyYW1lcyApe1xuICBleHBvcnRzLnRpbWVyKCBmbiwgZnJhbWVzLCB0cnVlIClcbn1cblxuLy9jaGVjayBpb3MgNiBwYXVsIGlyaXNoIHNheXMgc3R1ZmYgZ29lcyB3cm9uZyB0aGVyZS4uLiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxudmFyIGNhc2VzID0gcmVxdWlyZSgnLi8nKSxcbiAgZWxlbWVudCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQnKSxcbiAgc2V0RmxhZ3MgPSByZXF1aXJlKCcuLi9lbGVtZW50L3NldCcpLFxuICBiYXNlID0gcmVxdWlyZSgnLi4vLi4vYmFzZScpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLUNBU0VTIEZPUiBTRVQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgX2NzcyA9IGZ1bmN0aW9uKHQsIG5hbWUsIGludmVydCwgcmVtb3ZlKSB7XG4gICAgaWYgKCFpbnZlcnQpIHtcbiAgICAgIGlmKCF0LmNzcykgeyB0LmNzcyA9ICcnIH1cbiAgICAgIHQuY3NzLnNldCggcmVtb3ZlID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcycsIG5hbWUgKSBcbiAgICAgIHQuY3NzLnVwZGF0ZSh0KVxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignXFxuXFxuXFxuc2V0IGNzcyEhISEheHh4JywgbmFtZSwgdC5ub2RlKVxuXG4gICAgICB0LmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1xcblxcblxcbmluc3RhbmNlISBzZXQgY3NzISEhISEnLCBuYW1lLCB0Lm5vZGUpXG5cbiAgICAgICAgLy8gaWYodGhpcy5jc3MgIT09IHQuY3NzKSB7XG4gICAgICAgICAgdGhpcy5jc3Muc2V0KCByZW1vdmUgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJywgbmFtZSApIFxuICAgICAgICAgIHRoaXMuY3NzLnVwZGF0ZSh0aGlzKVxuICAgICAgICAvLyB9XG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kcyA9IGNhc2VzLm1ldGhvZHM7XG5cbnNldEZsYWdzLnJlbW92ZSA9IGZ1bmN0aW9uKGksIHZhbCwgY29weSwgdG9wKSB7XG4gIC8vdGhpcyBjb3VsZCBiZWNvbWUgYSBzZXBlcmF0ZSBtb2R1bGUgc2luY2UgcmVtb3ZlIG1heSBiZSB1c2VmdWxsIGZvciBkaWZmZXJlbnQgcHVycG9zZXNcbiAgaWYgKHZhbCAmJiB2YWwuX19yZW1vdmVfXykge1xuICAgIGlmICh0aGlzW2ldIGluc3RhbmNlb2YgYmFzZSkge1xuICAgICAgdG9wW2ldID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICh1dGlsLmxvb2t1cC5jYWxsKHRoaXMsIGkpKSB7XG4gICAgICBkZWxldGUgdmFsLl9fcmVtb3ZlX187XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWxbaV07XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbnNldEZsYWdzLmNhc2VzID0gbWV0aG9kcy5yZWFkZXIoZnVuY3Rpb24gY2FzZVJlYWRlckJhc2UobmFtZSwgdmFsLCBkeW5hbWljLCBpbnZlcnQpIHtcbiAgdmFyIHQgPSB0aGlzLFxuICAgIGYgPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIG9iaiA9IGJhc2Uuc2V0KG9iaiwgZmFsc2UsIHRydWUpO1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYgKHV0aWwuaXNPYmoob2JqW2ldKSkge1xuICAgICAgICAgIG9ialtpXSA9IGYob2JqW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIG1ldGhvZCxcbiAgICBwYXJzZWQsXG4gICAgc2V0LFxuICAgIHNWYWwsXG4gICAgb3JpZ2luYWw7XG4gIHZhbCA9IGYodmFsKTtcblxuICBpZiAoZHluYW1pYykge1xuICAgIGlmICghdC5fY2FzZXMpIHtcbiAgICAgIHQuX2Nhc2VzID0ge307XG4gICAgfVxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIGlmICh0Ll9jYXNlc1tuYW1lXS5tZXRob2QpIHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcihuYW1lLCAnY2FzZSA9PT0gbnVsbCAsIHJlbW92ZSBpdCcpO1xuICAgICAgICBjYXNlc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcih0Ll9jYXNlc1tuYW1lXS5tZXRob2QpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc2VzW25hbWVdLnZhbCkge1xuICAgICAgICB0LmNzcyA9IHtcbiAgICAgICAgICByZW1vdmVDbGFzczogbmFtZVxuICAgICAgICB9O1xuICAgICAgICAgdC5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmNzcyA9IHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6IG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZGVsZXRlIHQuX2Nhc2VzW25hbWVdOyAvL3JlbW92ZXMgY2FzZSBvcmdpbmFsXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1NFVCBDQVNFJyxuYW1lLHQuX2Nhc2VzW25hbWVdJiZ0Ll9jYXNlc1tuYW1lXS5tZXRob2QpO1xuICAgICAgcGFyc2VkID0gbWV0aG9kcy5vcmlnaW5hbCh0LCB0cnVlLCB2YWwsIHQuX2Nhc2VzLCB0cnVlLCBuYW1lKTtcbiAgICAgIHQuX2Nhc2VzW25hbWVdID0ge1xuICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgb3JpZzogcGFyc2VkWzBdLFxuICAgICAgICBuZXN0ZWQ6IHBhcnNlZFsxXVxuICAgICAgfTtcblxuICAgICAgaWYgKCF0Ll9jYXNlc1tuYW1lXS5tZXRob2QpIHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcigndGhpcyBpcyB3aGF0IGkgaGF2ZSBzZXQgZm9yIG9yaWdpbmFsJywgdC5fY2FzZXMpO1xuICAgICAgICBtZXRob2QgPSB0Ll9jYXNlc1tuYW1lXS5tZXRob2QgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdMRVRTIFRSWSBUTyBSVU4gTUVUSE9EJyxuYW1lLHZhbCk7XG5cbiAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICBzZXQgPSBtZXRob2RzLm1lcmdlKHRydWUsIG5hbWUsIHZhbCwgdC5fY2FzZXMpOyAvL2FyZyBubyB2YWw7XG4gICAgICAgICAgICBzVmFsID0gc2V0IFswXTtcbiAgICAgICAgICAgIG9yaWdpbmFsID0gc2V0WzFdO1xuICAgICAgICAgICAgZGVsZXRlIHNWYWwudmFsO1xuICAgICAgICAgICAgZGVsZXRlIG9yaWdpbmFsLnZhbDtcbiAgICAgICAgICAgIGlmIChjYXNlc1tuYW1lXS52YWwpIHtcbiAgICAgICAgICAgICAgX2Nzcyh0LCBuYW1lLCBpbnZlcnQpO1xuICAgICAgICAgICAgICB0LnNldChzVmFsLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF9jc3ModCwgbmFtZSwgaW52ZXJ0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdC5zZXQob3JpZ2luYWwsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignQUREIExJU1RFTkVSIFRPJyxuYW1lLCAgdC5fY2FzZXNbbmFtZV0pO1xuICAgICAgICBjYXNlc1tuYW1lXS5hZGRMaXN0ZW5lcihtZXRob2QpO1xuICAgICAgICAvL3JlbW92ZSBzZXR0aW5nIG9uIHJlbW92ZSAoc2F2ZXMgbWVtb3J5KVxuICAgICAgICB0LnNldFNldHRpbmcoe1xuICAgICAgICAgIG5hbWU6ICdfYycgKyBuYW1lLFxuICAgICAgICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZih0aGlzID09PSB0ICkge1xuICAgICAgICAgICAgICBjYXNlc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcihtZXRob2QpOyAvL2lmKCF0aGlzLmNzcyA9PT0gdGhpcy5fZnJvbS5iYXNlLmNzcykgXG4gICAgICAgICAgICAgIHRoaXMuX2Nhc2VzW25hbWVdLm1ldGhvZCA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lLCAnYWxyZWFkeSBnb3QgbGlzdGVuZXJzIGZvciBjYXNlJyxuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXNlc1tuYW1lXS52YWwpIHtcbiAgICAgICAgX2Nzcyh0LCBuYW1lLCBpbnZlcnQpO1xuICAgICAgICB0LnNldCh2YWwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfY3NzKHQsIG5hbWUsIGludmVydCk7XG4gICAgdC5zZXQodmFsKTsgLy9tYXliZSBjb3B5IGFyZ3M/XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59KTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSxcbiAgZWxlbWVudCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQnKSwgLy9lbGVtZW50IC93IGV4dGVuZFxuICB2YWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlJyksXG4gIGZsYWdzID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3MnKTtcblxuLyoqXG4gKiBjYXNlc1xuICogY2FzZXMgYXJlIHVzZWQgdG8gc2V0IG9uZSBvciBtb3JlIHZhbHVlcyB3aGVuIGEgc3BlY2lmaWMgY2FzZSBpcyB0cnVlXG4gKiB0aGVyZSBhcmUgMiB0eXBlcyBvZiBjYXNlcyAsIHN0YXRpYyBhbmQgZHluYW1pYyAsXG4gKiBzdGF0aWMgY2FzZXMgYXJlIHNldCBhdCBpbml0aWFsaXphdGlvbiBvZiB0aGUgYXBwbGljYXRpb24gLCB1c2VmdWxsIGZvciB0aGluZ3Mgc3VjaCBhcyBkZXZpY2UgdHlwZSAocGhvbmUsIGRlc2t0b3AsIHR2KVxuICogZHluYW1pYyBjYXNlcyBjYW4gYmUgY2hhbmdlZCBkeW5hbWljbHkgYW5kIE9iamVjdHMgb3IgQmFzZXMgdGhhdCB1c2UgdGhlIGNhc2Ugd2lsbCBiZSBjaGFuZ2VkIGR5bmFtaWNseSBhcyB3ZWxsXG4gKi9cblxudXRpbC5kZWZpbmUoZXhwb3J0cywgJ21ldGhvZHMnLCB7fSk7XG4vL211bHRpcGxlLCByZWN1cnNpdmUgYW5kIG9yaWdpbmFsIGhhdmUgdG8gYmVjb21lIGV4dGVuc2lvbnMgb24gVi5PYmplY3QuY29udmVydCBzbyBpdCdzIHBvc3NpYmxlIHRvIHVzZSB0aGUgc2FtZSBmb3IgZGF0YSBhbmQgZXZlbnRzXG5cbnZhciBfaXNPYmogPSB1dGlsLmlzT2JqLFxuICAvKlxuICAgIF9yZWN1clxuICAgIHNwZWNpYWwgbWVyZ2UgdGhhdCBhZGRzIF9fcmVtb3ZlX18gaWYgYSBmaWVsZCBoYXMgdG8gYmUgcmVtb3ZlZFxuICAqL1xuICBfcmVjdXIgPSBmdW5jdGlvbihvcmlnaW5hbCwgbWVyZ2UsIGZpZWxkRXhpc3RzKSB7XG5cbiAgICAvLyBjb25zb2xlLmxvZyhvcmlnaW5hbCwgbWVyZ2UsIGZpZWxkRXhpc3RzKVxuXG4gICAgdmFyIGtleXMsIGksIGtleSwgb3JpZ2luYWxDaGlsZCwgbWVyZ2VDaGlsZDtcbiAgICBpZiAoZmllbGRFeGlzdHMpIHtcbiAgICAgIGtleXMgPSB7fTtcbiAgICAgIGZvciAoa2V5IGluIG9yaWdpbmFsKSB7XG4gICAgICAgIGtleXNba2V5XSA9IHRydWU7IC8va2V5cyBjYW4gYmUgdW5kZWZpbmVkIC0tIGNvZGUgY2FuIGJlY29tZSBzaG9ydGVyXG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoaSBpbiBtZXJnZSkge1xuICAgICAgaWYgKCFmaWVsZEV4aXN0cyB8fCBrZXlzW2ldKSB7XG4gICAgICAgIG9yaWdpbmFsQ2hpbGQgPSBvcmlnaW5hbFtpXTtcbiAgICAgICAgbWVyZ2VDaGlsZCA9IG1lcmdlW2ldO1xuICAgICAgICBpZiAob3JpZ2luYWxDaGlsZCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIGlmIChvcmlnaW5hbENoaWxkLl9fcmVtb3ZlX18gJiYgKG1lcmdlQ2hpbGQgJiYgIW1lcmdlQ2hpbGQuX19yZW1vdmVfXykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcmlnaW5hbENoaWxkLl9fcmVtb3ZlX187XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKG1lcmdlQ2hpbGQgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgICAgICBtZXJnZVtpXSA9IHtcbiAgICAgICAgICAgICAgdmFsOiBtZXJnZUNoaWxkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVjdXIob3JpZ2luYWxDaGlsZCwgbWVyZ2VDaGlsZCwgZmllbGRFeGlzdHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9yaWdpbmFsW2ldID0gbWVyZ2VDaGlsZDtcbiAgICAgICAgICBvcmlnaW5hbENoaWxkID0gJ2J1cm4nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKlxuICAgICAgICAgIF9tdWx0aXBsZVxuICAgICAgICAgIG1lcmdlIG11bHRpcGxlIG9yZ2luYWxzIGludG8gYSBuZXcgb3JnaW5hbCBvYmplY3QgYWxzbyByZXNvbHZlIG5lc3RlZCBjYXNlc1xuICAgICAgKi9cbiAgX211bHRpcGxlID0gZnVuY3Rpb24odCwgbmVzdGVkLCBjYXNlcywgY3VycmVudE9iaiwgY3VycmVudFZhbCwgYmFzZSwgbmFtZSwgcGF0aCwgb3JpZykge1xuXG4gICAgaWYgKCFwYXRoKSB7XG4gICAgICBvcmlnID0gdDtcbiAgICAgIHBhdGggPSBbXTtcbiAgICB9XG4gICAgdmFyIGosIF9jYXNlLCBjdkNoaWxkO1xuXG4gICAgaWYoKGN1cnJlbnRWYWwgaW5zdGFuY2VvZiBvYmplY3QpICYmICFiYXNlKSB7XG5cbiAgICAgIC8vIGN1cnJlbnRPYmoudmFsID0gdC5fdmFsXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdWT0JKJywgY3VycmVudE9iailcblxuXG4gICAgfSBlbHNlIGlmIChjdXJyZW50VmFsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBmb3IgKGogaW4gY3VycmVudFZhbCkge1xuICAgICAgICBjdkNoaWxkID0gY3VycmVudFZhbFtqXTtcbiAgICAgICAgaWYgKGV4cG9ydHNbal0pIHtcbiAgICAgICAgICBfY2FzZSA9IGV4cG9ydHNbal07XG4gICAgICAgICAgaWYgKF9jYXNlIGluc3RhbmNlb2Ygb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIWJhc2UgfHwgIWVsZW1lbnQuc2V0Lmxvb2t1cC5jYWxsKG9yaWcsIHBhdGhbcGF0aC5sZW5ndGggLSAxXSkpIHsgLy9lbGVtZW50IGlzIHJlcXVpcmVkIGluIGNhc2VzLmJhc2UsIG1ha2UgdGhpcyBwYXJ0IGV4dGVuZGFibGVcbiAgICAgICAgICAgICAgbmVzdGVkW2pdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNPYmooY3ZDaGlsZCkpIHtcbiAgICAgICAgICAgIGN1cnJlbnRPYmoudmFsID0gdCAmJiAodC5fdmFsICE9PSB2b2lkIDAgPyB0Ll92YWwgOiB2b2lkIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoLnB1c2goaik7XG4gICAgICAgICAgICAvL3Nob3VsZCBiZSBwb3NzaWJsZSB0byB1c2UgbmVzdGVkIGZvciBjdXJyZW50IG5lc3RlZCBjYXNlO1xuICAgICAgICAgICAgX211bHRpcGxlKHQsIG5lc3RlZCwgY2FzZXMsIGN1cnJlbnRPYmosIGN2Q2hpbGQsIGJhc2UsIG5hbWUsIHBhdGgsIG9yaWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjdXJyZW50T2JqW2pdID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoX2lzT2JqKGN2Q2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRPYmpbal0pIHtcbiAgICAgICAgICAgICAgY3VycmVudE9ialtqXSA9ICh0ICYmIHRbal0gJiYgdFtqXS5jb252ZXJ0ICYmIHRbal0uY29udmVydChjdkNoaWxkKSkgfHwgKGN2Q2hpbGQgaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aC5wdXNoKGopO1xuICAgICAgICAgICAgX211bHRpcGxlKHQgJiYgdFtqXSwgbmVzdGVkLCBjYXNlcywgY3VycmVudE9ialtqXSwgY3ZDaGlsZCwgYmFzZSwgbmFtZSwgcGF0aCwgb3JpZyk7XG4gICAgICAgICAgICBpZiAoYmFzZSAmJiAoIXQgfHwgIXRbal0pKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRPYmpbal0uX19yZW1vdmVfXyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0ICYmIGN1cnJlbnRPYmogJiYgIWN1cnJlbnRPYmpbal0pIHtcbiAgICAgICAgICAgICAgaWYgKGZsYWdzW2pdKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGN1cnJlbnRPYmpbal07XG4gICAgICAgICAgICAgICAgY3VycmVudE9iai52YWwgPSB0Ll92YWwgIT09IHZvaWQgMCA/IHQuX3ZhbCA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50T2JqW2pdID0gaiA9PT0gJ3ZhbCcgXG4gICAgICAgICAgICAgICAgICA/ICh0Ll92YWwgIT09IHZvaWQgMCA/IHQuX3ZhbCA6IHZvaWQgMCkgXG4gICAgICAgICAgICAgICAgICA6ICh0W2pdIT09dm9pZCAwICYmIHRbal0uY29udmVydCAmJiB0W2pdLmNvbnZlcnQoKSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLypcbiAgICAgIG9yaWdpbmFsXG4gICAgICBjcmVhdGUgYSBvcmdpbmFsIHN0b3JlIGZvciBhIG5ldyBjYXNlXG4gICAgKi9cbmV4cG9ydHMubWV0aG9kcy5vcmlnaW5hbCA9IGZ1bmN0aW9uKHQsIGlzT2JqLCB2YWwsIGNhc2VzLCBiYXNlLCBuYW1lKSB7XG5cblxuXG4gIHZhciBvYmogPSBpc09iaiA/IHQuY29udmVydCh2YWwpIDogdC5fdmFsLFxuICAgIGksIGNmbGFnLCBuZXN0ZWQgPSB7fTtcblxuICBfbXVsdGlwbGUodCwgbmVzdGVkLCBjYXNlcywgb2JqLCB2YWwsIGJhc2UsIG5hbWUpO1xuXG4gIC8vIGZvcih2YXIgaSBpbiBuZXN0ZWQpIHtcbiAgLy8gICBjb25zb2xlLmVycm9yKCdORVNURUQ6OjonLGkpO1xuICAvLyB9XG4gIC8vIGNvbnNvbGUubG9nKGJhc2UgPyAnQkFTRTonOiAnUFJPUEVSVFk6JyAsIG5hbWUsJ09SSUdJTkFMIEdFTkVSQVRJT04nLCdcXG52YWw6Jyx2YWwsJ1xcbm9iajonLG9iaiwnXFxubmVzdGVkOicsbmVzdGVkLCdcXG5jYXNlczonLGNhc2VzKTtcblxuICBmb3IgKGkgaW4gY2FzZXMpIHtcbiAgICBpZiAoIW5lc3RlZFtpXSkge1xuICAgICAgY2ZsYWcgPSBjYXNlc1tpXS5vcmlnO1xuICAgICAgaWYgKCFpc09iaikge1xuICAgICAgICBpZiAoX2lzT2JqKGNmbGFnKSkge1xuICAgICAgICAgIGlmIChjZmxhZy52YWwpIHtcbiAgICAgICAgICAgIG9iaiA9IGNmbGFnLnZhbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqID0gY2ZsYWc7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfaXNPYmooY2ZsYWcpKSB7XG4gICAgICAgICAgaWYgKCFjYXNlc1tpXS5uZXN0ZWRbbmFtZV0pIHtcbiAgICAgICAgICAgIF9yZWN1cihvYmosIGNmbGFnLCBuYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnZhbCkge1xuICAgICAgICAgIG9iai52YWwgPSBjZmxhZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cblxuICByZXR1cm4gW29iaiwgbmVzdGVkXTtcbn07XG4vKlxuICBtZXJnZVxuICBtZXJnZSBkeW5hbWljIGNhc2VzIChvdmVyd3JpdGUgL3cgY2FzZXMgdGhhdCBhcmUgdHJ1ZSBhbmQgZnVydGhlciBpbiB0aGUgb3JkZXIgb2YgY2FzZXMpXG4qL1xuZXhwb3J0cy5tZXRob2RzLm1lcmdlID0gZnVuY3Rpb24oaXNPYmosIG5hbWUsIHZhbCwgY2FzZXMpIHtcbiAgdmFyIG9yaWdpbmFsID0gdXRpbC5jbG9uZShjYXNlc1tuYW1lXS5vcmlnKSxcbiAgICBzVmFsID0gdmFsLFxuICAgIG92ZXJ3cml0ZSxcbiAgICBpLFxuICAgIG1lcmdlLFxuICAgIG9yaWdpbmFsQ2hpbGQ7XG4gIGZvciAoaSBpbiBjYXNlcykge1xuICAgIGlmIChpICE9PSBuYW1lICYmICFjYXNlc1tuYW1lXS5uZXN0ZWRbaV0pIHtcbiAgICAgIGlmIChleHBvcnRzW2ldLnZhbCkge1xuICAgICAgICBtZXJnZSA9IGNhc2VzW2ldLnZhbDtcbiAgICAgICAgaWYgKF9pc09iaihvcmlnaW5hbCkgfHwgX2lzT2JqKG1lcmdlKSkge1xuICAgICAgICAgIGlmICghX2lzT2JqKG9yaWdpbmFsKSkge1xuICAgICAgICAgICAgb3JpZ2luYWwgPSB7XG4gICAgICAgICAgICAgIHZhbDogb3JpZ2luYWxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2lzT2JqKG1lcmdlKSkge1xuICAgICAgICAgICAgbWVyZ2UgPSB7XG4gICAgICAgICAgICAgIHZhbDogbWVyZ2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZWN1cihvcmlnaW5hbCwgbWVyZ2UsIHRydWUpO1xuICAgICAgICAgIGZvciAoaSBpbiBleHBvcnRzKSB7XG4gICAgICAgICAgICBvcmlnaW5hbENoaWxkID0gb3JpZ2luYWxbaV07XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxDaGlsZCAhPT0gbnVsbCAmJiBvcmlnaW5hbENoaWxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgZGVsZXRlIG9yaWdpbmFsW2ldOyAvL2RlbGV0ZSBpcyBwcmV0dHkgc2xvd1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3ZlcndyaXRlKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgICAgICAgaWYgKHNWYWwgPT09IHZhbCkge1xuICAgICAgICAgICAgICAgIHNWYWwgPSB1dGlsLmNsb25lKHNWYWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG1lcmdlID0gdXRpbC5jbG9uZShtZXJnZSk7XG4gICAgICAgICAgICAgIGZvciAoaSBpbiBleHBvcnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lcmdlW2ldICE9PSBudWxsICYmIG1lcmdlW2ldICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1JFTU9WRSBGSVgnLCBpKTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXJnZVtpXTsgLy9kZWxldGUgaXMgcHJldHR5IHNsb3dcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3JlY3VyKHNWYWwsIG1lcmdlLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChtZXJnZS52YWwpIHtcbiAgICAgICAgICAgICAgICBzVmFsID0gbWVyZ2UudmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9yaWdpbmFsID0gbWVyZ2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3ZlcndyaXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtzVmFsLCBvcmlnaW5hbF07XG59O1xuLypcbiAgcmVhZGVyXG4gIGFic3RyYWN0aW9uIGZvciB1c2UgaW4gY2FzZXMub2JqZWN0IGFuZCBjYXNlcy5iYXNlXG4qL1xuZXhwb3J0cy5tZXRob2RzLnJlYWRlciA9IGZ1bmN0aW9uKGZuLCBkeW5hbWljLCBfc3RhdGljKSB7XG4gIHJldHVybiBmdW5jdGlvbiByZWFkZXIobmFtZSwgdmFsKSB7XG4gICAgdmFyIGludmVydCA9IChuYW1lWzBdID09PSAnIScpLFxuICAgICAgdkNhc2UgPSBpbnZlcnQgPyBleHBvcnRzWyhuYW1lLnNsaWNlKDEpKV0gOiBleHBvcnRzW25hbWVdLFxuICAgICAgcmV0O1xuICAgIGlmICh2Q2FzZSkge1xuICAgICAgaWYgKHZDYXNlIGluc3RhbmNlb2Ygb2JqZWN0KSB7XG4gICAgICAgIGlmIChpbnZlcnQgJiYgIWV4cG9ydHNbbmFtZV0pIHtcbiAgICAgICAgICBleHBvcnRzW25hbWVdID0gbmV3IHZhbHVlKHtcbiAgICAgICAgICAgIHZhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhdkNhc2UudmFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxpc3RlbjogdkNhc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXQgPSBmbiA/IGZuLmNhbGwodGhpcywgbmFtZSwgdmFsLCB0cnVlLCBpbnZlcnQpIDogZHluYW1pYztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGludmVydCA/ICEhZm4gOiBmbiA/IGZuLmNhbGwodGhpcywgbmFtZSwgdmFsKSA6IF9zdGF0aWNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGludmVydCkge1xuICAgICAgcmV0ID0gZm4gPyBmbi5jYWxsKHRoaXMsIG5hbWUsIHZhbCwgZmFsc2UsIGludmVydCkgOiBfc3RhdGljO1xuICAgIH1cbiAgICBpZiAodkNhc2UgPT09IGZhbHNlICYmIGZuKSB7XG4gICAgICByZXQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xufTtcblxucmVxdWlyZSgnLi9vYmplY3QnKTtcbnJlcXVpcmUoJy4vYmFzZScpOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxudmFyIGZsYWdzID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3MnKSxcbiAgQ2FzZXMgPSByZXF1aXJlKCcuLycpLFxuICBvYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSxcbiAgbWV0aG9kcyA9IENhc2VzLm1ldGhvZHMsXG4gIGR5bmFtaWMgPSB7XG4gICAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCwgbmFtZSkge1xuXG4gICAgICBpZighdGhpcy5fZmxhZykgdGhpcy5fZmxhZyA9IHt9XG5cbiAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICAvL3NlbGVjdGlvbiBmb3IgdC5fZmxhZyBlYXN5IG1ha2VuXG4gICAgICAgICAgXG4gICAgICAgICAgXG4gICAgICAgIGZsYWdzID0gdC5fZmxhZy5jYXNlIHx8ICh0Ll9mbGFnLmNhc2UgPSBbXG4gICAgICAgICAgJ2Nhc2UnLFxuICAgICAgICAgIHQuX3ZhbCxcbiAgICAgICAgICBmYWxzZSwge30sXG4gICAgICAgICAgZHluYW1pY1xuICAgICAgICBdKSxcbiAgICAgICAgY2FzZXMgPSBmbGFnc1szXSxcbiAgICAgICAgaXNPYmogPSB1dGlsLmlzT2JqKHZhbCksXG4gICAgICAgIHNldFZhbCA9IChpc09iaiAmJiAhdmFsLnZhbCkgPyBmYWxzZSA6IHRydWU7XG4gICAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICAgIGlmIChjYXNlc1tuYW1lXSkge1xuICAgICAgICAgIENhc2VzW25hbWVdLnJlbW92ZUxpc3RlbmVyKGNhc2VzW25hbWVdLm1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIGNhc2VzW25hbWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmxhZ3NbNV0gPSB0cnVlO1xuICAgICAgICBpZiAoIWNhc2VzW25hbWVdKSB7XG4gICAgICAgICAgdmFyIHggPSBtZXRob2RzLm9yaWdpbmFsKHQsIGlzT2JqLCB2YWwsIGNhc2VzLCBmYWxzZSwgbmFtZSk7XG4gICAgICAgICAgY2FzZXNbbmFtZV0gPSB7XG4gICAgICAgICAgICB2YWw6IHZhbCxcbiAgICAgICAgICAgIG9yaWc6IHhbMF0sXG4gICAgICAgICAgICBuZXN0ZWQ6IHhbMV0sXG4gICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgc2V0ID0gbWV0aG9kcy5tZXJnZShpc09iaiwgbmFtZSwgdmFsLCBjYXNlcyksXG4gICAgICAgICAgICAgIHNWYWwgPSBzZXRbMF0sXG4gICAgICAgICAgICAgIG9yaWdpbmFsID0gc2V0WzFdO1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lKVxuICAgICAgICAgICAgICAvLyBpZihuYW1lID09PSAnJGlzQWN0aXZlJyApY29uc29sZS5lcnJvcignYm9lbG9lIGJvZWxvZSBib2Vsb2UhISEnLHNWYWwsb3JpZ2luYWwpXG5cbiAgICAgICAgICAgICAgZmxhZ3NbNV0gPSB0cnVlOyAvL3RoZSBjbG9zdXJlcyBoZXJlIGFyZSBub3QgcmVhbGx5IG5lc3NlY2FyeSBiZXR0ZXIgdG8gYXZvaWRcbiAgICAgICAgICAgICAgaWYgKENhc2VzW25hbWVdLnZhbCkge1xuXG4gICAgICAgICAgICAgICAgaWYoIXNWYWwpIGNvbnNvbGUud2FybihuYW1lLCd3cm9uZyBpbiBjYXNlcyEnLCBzVmFsLCBDYXNlcywgZmxhZ3MpXG4gICAgICAgICAgICAgICAgaWYgKHNldFZhbCAmJiBzVmFsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBpZihuYW1lID09PSAnJGlzQWN0aXZlJyApY29uc29sZS5sb2coJ3llZSBpdHMgdHJ1ZScpXG4gICAgICAgICAgICAgICAgICBmbGFnc1sxXSA9IHNWYWwudmFsIHx8IHNWYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHQudmFsID0gc1ZhbDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZihuYW1lID09PSAnJGlzQWN0aXZlJyApY29uc29sZS5sb2coJ25vIHdheSBnb3plZScpXG5cbiAgICAgICAgICAgICAgICBpZiAoc2V0VmFsKSBmbGFnc1sxXSA9IG9yaWdpbmFsICYmIG9yaWdpbmFsLnZhbCB8fCBvcmlnaW5hbFxuXG4gICAgICAgICAgICAgICAgaWYobmFtZSA9PT0gJyRpc0FjdGl2ZScgKWNvbnNvbGUubG9nKCdubyB3YXkgZ296ZWUgMicsb3JpZ2luYWwsIHQpXG5cbiAgICAgICAgICAgICAgICB0LnZhbCA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZsYWdzWzVdID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIENhc2VzW25hbWVdLmFkZExpc3RlbmVyKGZsYWdzWzNdW25hbWVdLm1ldGhvZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENhc2VzW25hbWVdLnZhbCkge1xuICAgICAgICAgIGlmIChzZXRWYWwpIHtcbiAgICAgICAgICAgIGZsYWdzWzFdID0gdmFsLnZhbCB8fCB2YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9iamVjdC5zZXQuY2FsbCh0LCB2YWwsIHN0YW1wLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgLy9ub3QgYWx3YXlzXG4gICAgICAgICAgdC5faWdub3JlZm9ybm93ID0gdHJ1ZVxuXG4gICAgICAgIH1cbiAgICAgICAgZmxhZ3NbNV0gPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gcmVzZXQ6ZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdyZXNldCcpXG4gICAgLy8gfSxcbiAgICAvL2FkZCByZXNldCBsYXRlclxuICAgIHJlbW92ZTogZnVuY3Rpb24oZmxhZ3MsIG5hbWUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGZsYWdzLCBuYW1lKVxuICAgICAgdmFyIGNudCA9IDBcbiAgICAgIGZvciAodmFyIGkgaW4gZmxhZ3NbM10pIHtcbiAgICAgICAgLy8gaWYoZmxhZ3NbM10pXG4gICAgICAgIGNudCsrXG4gICAgICAgIGlmKCF0aGlzLl9pZ25vcmVmb3Jub3cgJiYgIW5hbWUgfHwgaT09PW5hbWUpIHtcbiAgICAgICAgICBjbnQgLS1cbiAgICAgICAgICBDYXNlc1tpXS5yZW1vdmVMaXN0ZW5lcihmbGFnc1szXVtpXS5tZXRob2QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9pZ25vcmVmb3Jub3dcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoY250KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDQVNFIE9CSkVDVCBSRU1PVkFMIC0tLSBJVCBJUyBOT1QgRU1QWScpXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICBzdGFjazogJ2Nhc2UnXG4gIH0sXG4gIF9zdGF0aWMgPSB7XG4gICAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCwgbmFtZSkge1xuICAgICAgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgICBvYmplY3Quc2V0LmNhbGwodGhpcywgdmFsLCBzdGFtcCwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuZmxhZ3MuZHluYW1pYy5jYXNlcyA9IG1ldGhvZHMucmVhZGVyKGZhbHNlLCBkeW5hbWljLCBfc3RhdGljKTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbi8qXG4gIGdldHMgYW5kIGNhY2hlcyB2YWx1ZXMgZm9yIGNzcyBjbGFzc2VzLCBhbHNvIHBvc3NpYmxlIHRvIGNoYW5nZSBzdHlsZXMgb2YgY2xhc3Nlc1xuICByZXR1cm4gYW4gYXJyYXkgb2YgbXVsdGlwbGUgY3NzIG9iamVjdHMgY29ycmVzcG9uZGluZyB0byB0aGUgY2xhc3MgbmFtZVxuICB3aGVuIHlvdSBwYXNzIGZpZWxkIGl0IHNlYXJjaGVzIHRoZSBmaWVsZCB0cm91Z2ggYWxsIHRoZSBjbGFzc2VzIHNlbGVjdGVkLCBhbHdheXMgdGFrZXMgZmlyc3QgYXJndW1lbnRcbiAgbWF5YmUgaGF2ZSB0byBtYWtlIHRoaXMgZm9yIHRoaW5ncyBzdWNoIGFzIGRpdiBzZWxlY3RvcnMgLyBuZXN0ZWQgc3R1ZmYgLS0tIHdpbGwgYmUgY3B1IGludGVuc2l2ZSE7XG4qL1xudmFyIHNlbGVjdG9yID0gJ2Nzc1J1bGVzJyxcbiAgcGFyc2VjbGFzcyA9IGZ1bmN0aW9uKHNsY3RyKSB7XG4gICAgc2xjdHIgPSAnLicgKyBzbGN0ci5yZXBsYWNlKC9cXC4vZywgJyAuJykudG9Mb3dlckNhc2UoKTtcbiAgICBmb3IgKHZhciByb2JqLCBzZWxlY3QgPSBkb2N1bWVudC5zdHlsZVNoZWV0cywgbGVuZ3RoID0gc2VsZWN0Lmxlbmd0aCwgaSA9IDAsIHNlbGVjdEl0ZW07IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc2VsZWN0SXRlbSA9IHNlbGVjdFtpXVtzZWxlY3Rvcl0gfHwgc2VsZWN0W2ldWyhzZWxlY3RvciA9ICdydWxlcycpXTsgLy9sb2NhdGlvbiBvZiB0aGlzIHBvbHlmaWxsIGNhbiBiZSBpbXByb3ZlZFxuICAgICAgaWYoc2VsZWN0SXRlbSkge1xuICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHNlbGVjdEl0ZW0ubGVuZ3RoLCBpdGVtOyBzZWxlY3RJdGVtLCBqIDwgbDsgaXRlbSA9IHNlbGVjdEl0ZW1baisrXSwgaXRlbS5zZWxlY3RvclRleHQgPT09IHNsY3RyICYmIChyb2JqID0gaXRlbS5zdHlsZSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcm9iajtcbiAgfSxcbiAgYyA9IGZ1bmN0aW9uKGNzc0NsYXNzLCBjYWNoZSkge1xuICAgIHZhciB0ID0gZXhwb3J0cztcbiAgICBjYWNoZS5wdXNoKHRbY3NzQ2xhc3NdIHx8ICh0W2Nzc0NsYXNzXSA9IHBhcnNlY2xhc3MoY3NzQ2xhc3MpKSB8fCB7fSk7XG4gICAgcmV0dXJuIGNzc0NsYXNzO1xuICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHNsY3RyLCBmaWVsZCkge1xuICBpZiAoc2xjdHIpIHtcbiAgICB2YXIgY2FjaGUgPSB0aGlzW3NsY3RyXTtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICBjYWNoZSA9IFtdO1xuICAgICAgZm9yICh2YXIgc2VsZWN0YXJyYXkgPSBzbGN0ci5zcGxpdCgnICcpLCBpID0gMCwgbCA9IHNlbGVjdGFycmF5Lmxlbmd0aCwgY3NzQ2xhc3M7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKChjc3NDbGFzcyA9IGMoc2VsZWN0YXJyYXlbaV0sIGNhY2hlKS5zcGxpdCgnLicpKSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgYyhjc3NDbGFzc1tjc3NDbGFzcy5sZW5ndGggLSAxXSwgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzW3NsY3RyXSA9IGNhY2hlO1xuICAgIH1cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIGlmKCEoY2FjaGUgaW5zdGFuY2VvZiBBcnJheSkpXG4gICAgICAgIHJldHVyblxuICAgICAgZm9yICh2YXIgcmV0LCBpID0gY2FjaGUubGVuZ3RoIC0gMTsgIXJldCAmJiBpID49IDA7IHJldCA9IGNhY2hlW2ktLV1bZmllbGRdKTtcbiAgICAgIGNhY2hlID0gcmV0OyAgXG4gICAgfVxuICAgIHJldHVybiBjYWNoZTtcbiAgfVxufTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UnKVxuICAsIHZhbHVlQmFzZSA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL2Jhc2UnKVxuICAsIHZpZ291ciA9IHJlcXVpcmUoJy4uLy4uLycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIGVsZW1lbnRCYXNlID0gbmV3IGJhc2UoKVxuXG5lbGVtZW50QmFzZS5kZWZhdWx0VHlwZSA9IHZhbHVlQmFzZS50eXBlXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHZpZ291ci5FbGVtZW50ID0gZWxlbWVudEJhc2UuQ2xhc3NcbmV4cG9ydHMuYmFzZSA9IGVsZW1lbnRCYXNlXG5cbnZhciBfZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogJ25vIGRvY3VtZW50JywgLy9yZWZlcmVuY2UgdG8gZG9jdW1lbnQgaXMgZmFzdGVyIHRoYW4gdXNpbmcgd2luZG93LmRvY3VtZW50O1xuICAvKipcbiAgICogUmVtb3ZlcyBjaGlsZHJlbiBmcm9tIHBhcmVudCBub2RlXG4gICAqIEBtZXRob2QgX3JlbW92ZUNoaWxkcmVuXG4gICAqL1xuICBfcmVtb3ZlQ2hpbGRyZW4gPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBjID0gdGhpcy5fbm9kZS5jaGlsZE5vZGVzLCBpID0gMCwgbCA9IGMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoY1tpXS5iYXNlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nXG4gICAgICAgIGNbaV0uYmFzZS5yZW1vdmUoZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogbm9kZVxuICogYWRkcyBhbmQgY2xvbmVzIGh0bWwgbm9kZXM7XG4gKiBAYXR0cmlidXRlXG4gKi9cbmV4cG9ydHMuYmFzZS5leHRlbmQoe1xuICAgIG5hbWU6ICdub2RlJyxcbiAgICB0eXBlOiBmYWxzZSAsXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiBub2RlIGlzIHNldFxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtICB7Kn0gdmFsIERlZmluZXMgdGhlIHZhbHVlIG9mIHRoaXMuX25vZGVcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy9jaGFuZ2luZyBub2RlIGJ1Z3MgL3cgY29udmVyc2lvbnNcbiAgICAgIC8vaWZyYW1lIHNlbGVjdG9ycyBkb250IGV2YWx1YXRlIHRvIGEgc3RyaW5nXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0IHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX25vZGUgPSB2YWw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ub2RlID0gX2RvYy5jcmVhdGVFbGVtZW50KHZhbCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9ub2RlLmJhc2UgPSB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgZ2V0IG5vZGVcbiAgICAgKiBAbWV0aG9kIGdldFxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX25vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlID0gX2RvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgY3JlYXRlIGEgbmV3IG5vZGVcbiAgICAgKiBAbWV0aG9kIG5ld1xuICAgICAqIEBwYXJhbSAge09iamVjdH0gZnJvbSAgICBUYXJnZXRcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5ld25vZGUgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgIFwibmV3XCI6IGZ1bmN0aW9uKGZyb20sIG5ld25vZGUpIHtcbiAgICAgIGlmICghbmV3bm9kZSkge1xuICAgICAgICB2YXIgbm9kZSA9IGZyb20uX25vZGU7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGUuY2xvbmVOb2RlKHRydWUpOyAvL2VzcGVjaWFseSBnb29kIHRvIGRvIGZvciBtZW1vcnkgKGFsc28gc2F2ZXMgMjAlIG9uIGNwdSlcbiAgICAgICAgICB0aGlzLl9ub2RlLmJhc2UgPSB0aGlzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ub2RlID0gbmV3bm9kZTtcbiAgICAgIH1cbiAgICAgIGlmIChmcm9tLl9ub2RlICYmIGZyb20uX25vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIHZhciBpLCBjID0gdGhpcy5fbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICAgIGNmID0gZnJvbS5fbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICAgIGwgPSBjLmxlbmd0aCxcbiAgICAgICAgICBjaSwgY2ZiO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgY2ZiID0gY2ZbaV0uYmFzZTtcbiAgICAgICAgICBpZiAoY2ZiKSB7XG4gICAgICAgICAgICBjW2ldLmJhc2UgPSBuZXcgY2ZiLkNsYXNzKGZhbHNlLCBmYWxzZSwgY1tpXSk7XG4gICAgICAgICAgICAvL21heWJlIGNhbGwgY2hpbGRyZW4gbmV3IHN0dWZmIHdpdGggYSBjdXN0b20gc2V0dGluZyBhcyB3ZWxsP1xuICAgICAgICAgICAgaWYgKGNmYi5fbmFtZSkge1xuICAgICAgICAgICAgICBjW2ldLmJhc2UuX25hbWUgPSBjZmIuX25hbWU7XG4gICAgICAgICAgICAgIHRoaXNbY2ZiLl9uYW1lXSA9IGNbaV0uYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNbaV0uYmFzZS5zZXR0aW5nKCdwYXJlbnQnLCBbdGhpc10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVmaW5lcyB3aGF0IGhhcHBlbnMgd2hlbiB5b3UgcmVtb3ZlIGEgbm9kZVxuICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICogQHBhcmFtICB7Kn0gIFtwYXJhbV0gSWYgcGFyYW0gZG9lc24ndCByZW1vdmUgbm9kZSBmcm9tIHBhcmVudFxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24ocGFyYW0pIHtcbiAgICAgIF9yZW1vdmVDaGlsZHJlbi5jYWxsKHRoaXMpO1xuICAgICAgaWYodGhpcy5fbm9kZSkgdGhpcy5fbm9kZS5iYXNlID0gbnVsbCAvL2xpdHRsZSBzbG93IG9wdGltaXplIGxhdGVyXG4gICAgICBpZiAoIXBhcmFtKSB7XG4gICAgICAgIHZhciBfcCA9IHRoaXMuX25vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgaWYgKF9wKSB7XG4gICAgICAgICAgX3AucmVtb3ZlQ2hpbGQodGhpcy5fbm9kZSk7XG4gICAgICAgICAgaWYgKHRoaXMuX25hbWUgJiYgX3AuYmFzZSkge1xuICAgICAgICAgICAgX3AuYmFzZVt0aGlzLl9uYW1lXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2V0IGNzcyBjbGFzcyBvZiBhIGRpdlxuICAgKiBVc2UgYWRkQ2xhc3Mgb3IgcmVtb3ZlQ2xhc3MgdG8gYWRkL3JlbW92ZSBhIGNsYXNzXG4gICAqIEBhdHRyaWJ1dGUgY3NzXG4gICAqIEBwYXJhbSAge09iamVjdH0gdmFsIFtkZXNjcmlwdGlvbl1cbiAgICogd2FybmluZzogdGhlIGFkZCBvcGVyYXRvciBpbiBjc3MgaXMgY3VycmVudGx5IHVzZWQgYnkgLm5hbWUsXG4gICAqIGFuZCB3aWxsIGJlIHJlcGxhY2VkIHdoZW4geW91IHRyeSB0byBidWlsZCBhIHN0cmluZ1xuICAgKiB1c2luZyB7dmFsOiAuLi4uIGFkZDogLi4uLn1cbiAgICovXG4gIHtcbiAgICAvLyBfXyRjc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy8gdGhpcy5jc3NcbiAgICAvLyB9XG4gICAgY3NzOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBfdmFsID0gdmFsLnZhbCB8fCAnJztcbiAgICAgIHZhbC5fc2tpcCA9IHRydWU7IC8vX3NraXAgaXMgYW4gdWdseSBuYW1lXG4gICAgICBpZih2YWwuYWRkQ2xhc3Mpe1xuICAgICAgICBpZiAoIX5fdmFsLmluZGV4T2YodmFsLmFkZENsYXNzLnZhbCkpIHtcbiAgICAgICAgICB2YWwuX3ZhbCA9ICgoX3ZhbC5sZW5ndGggPiAwID8gX3ZhbCArICcgJyA6ICcnKSArIHZhbC5hZGRDbGFzcy52YWwpO1xuICAgICAgICAgIGlmKHZhbC5hZGQpIHZhbC5fdmFsID0gdmFsLl92YWwucmVwbGFjZSh2YWwuYWRkLnZhbCwnJylcbiAgICAgICAgICB2YWwuX2x2YWwgPSBmYWxzZTtcbiAgICAgICAgICB2YWwuX19sdmFsID0gZmFsc2U7XG4gICAgICAgICAgdmFsLl9fX2x2YWwgPSBmYWxzZTtcbiAgICAgICAgICBfdmFsID0gdmFsLnZhbDtcbiAgICAgICAgfVxuICAgICAgICB2YWwuYWRkQ2xhc3MucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKHZhbC5yZW1vdmVDbGFzcyl7XG4gICAgICAgIGlmIChfdmFsICYmIHZhbC5fdmFsKSB7XG4gICAgICAgICAgdmFsLl92YWwgPSB2YWwuX3ZhbC5yZXBsYWNlKG5ldyBSZWdFeHAoJyA/JyArIHZhbC5yZW1vdmVDbGFzcy52YWwpLCAnJyk7XG4gICAgICAgICAgdmFsLl9sdmFsID0gZmFsc2U7XG4gICAgICAgICAgdmFsLl9fbHZhbCA9IGZhbHNlO1xuICAgICAgICAgIHZhbC5fX19sdmFsID0gZmFsc2U7XG4gICAgICAgICAgX3ZhbCA9IHZhbC52YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFsLnJlbW92ZUNsYXNzLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiggX3ZhbCApIHtcbiAgICAgICAgdGhpcy5ub2RlLmNsYXNzTmFtZSA9IF92YWwucmVwbGFjZSgnJCcsJycpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NOYW1lID0gJydcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBNYWtlcyBpdCBwb3NzaWJsZSB0byByZWZlcmVuY2UgYSBjaGlsZCBieSBuYW1lXG4gICAqIFNldHRpbmcgb24gYSBjbGFzcyBkb2VzIG5vdCB1cGRhdGUgbmFtZXMgb2YgaW5zdGFuY2VzXG4gICAqIEVsZW1lbnRbTkFNRV1cbiAgICogQGF0dHJpYnV0ZSBuYW1lXG4gICAqL1xuICB7XG4gICAgbmFtZTogJ25hbWUnLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgX3AgPSB0aGlzLnBhcmVudDtcbiAgICAgIGlmICh0aGlzLl9uYW1lKSB7XG4gICAgICAgIGlmIChfcCkge1xuICAgICAgICAgIF9wW3RoaXMuX25hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fbmFtZSA9IHZhbDtcbiAgICAgIGlmICghdGhpcy5fbm9kZSB8fCB2YWwgIT09IHRoaXMubm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIC8vbmFtZSBkb2VzIG5vdCBpbmhlcml0LCBiZXdhcmUhXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdXSEFUUyBUSElTPycsdmFsKTtcbiAgICAgICAgLy8gdGhpcy5jc3MgPSB7YWRkQ2xhc3M6dmFsfTtcbiAgICAgICAgLy8gdGhpcy5jbGFzc05hbWUgPSB0aGlzLl9uYW1lO1xuICAgICAgICBpZighdGhpcy5jc3MgfHwgdGhpcy5jc3MuX3ZhbCE9PXZhbCl0aGlzLmNzcyA9IHsgYWRkOiAnICcgKyB2YWwgfVxuICAgICAgICAvL3NwZWNpYWwgbmFtZSBmaWVsZD9cbiAgICAgIH1cbiAgICAgIGlmIChfcCkge1xuICAgICAgICBfcFt2YWxdID0gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhcmVudCBiYXNlIGVsZW1lbnRcbiAgICogQGF0dHJpYnV0ZSBwYXJlbnRcbiAgICovXG4gIHtcbiAgICBuYW1lOiAncGFyZW50JyxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMuX25vZGUpIHtcbiAgICAgICAgdmFyIF9wID0gdGhpcy5fbm9kZS5wYXJlbnROb2RlIHx8IHRoaXMuX3A7XG4gICAgICAgIHJldHVybiBfcCA/IF9wLmJhc2UgfHwgX3AuX3AgOiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIGNoaWxkTm9kZXMgL3cgYmFzZSBjbGFzc2VzIGFycmF5IHNsb3csIGNhY2hlIGlmIHBvc3NpYmxlXG4gICAqIEBhdHRyaWJ1dGUgY2hpbGRyZW5cbiAgICovXG4gIHtcbiAgICBuYW1lOiAnY2hpbGRyZW4nLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZighdGhpcy5fbm9kZSkgcmV0dXJuIFtdXG4gICAgICB2YXIgYyA9IHRoaXMuX25vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgbCA9IGMubGVuZ3RoLFxuICAgICAgICBfYyA9IG5ldyBBcnJheShsKSxcbiAgICAgICAgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgX2NbaV0gPSBjW2ldLmJhc2UgfHwgY1tpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYztcbiAgICB9XG4gIH0pO1xuXG52YXIgcmVjdXJSZW5kZXIgPSBmdW5jdGlvbihwYXJlbnQpIHtcblxuICBpZiAoIXRoaXMubGFzdGluZGV4KSB0aGlzLnNldHRpbmcoJ3JlbmRlcicsIFtwYXJlbnRdKSAvL2V4ZWN1dGUgcmVuZGVyIHNldHRpbmdzXG5cbiAgaWYgKHRoaXMucmVuZGVycykge1xuXG4gICAgLy8gY29uc29sZS5lcnJvcignUkVOREVSIC0tLScsIHRoaXMubmFtZSwgdGhpcy5yZW5kZXJzKVxuXG4gICAgZm9yICh2YXIgcFxuICAgICAgLCBjID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcbiAgICAgICwgY2xcbiAgICAgICwgYXJyID0gdGhpcy5yZW5kZXJzXG4gICAgICAsIG9ialxuICAgICAgLCBpID0gdGhpcy5sYXN0aW5kZXggfHwgMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIG9iaiA9IGFycltpXVxuXG4gICAgIGlmKG9iaikge1xuICAgICAgICBwID0gdXRpbC5jaGVja0FycmF5KGMsIG9iaiwgJ2Jhc2UnKVxuICAgICAgICBpZiAocCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICByZWN1clJlbmRlci5jYWxsKG9iaiwgdGhpcylcbiAgICAgICAgfSBlbHNlIGlmKG9iai5fZnJvbSkge1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NMQVNTIScsb2JqLCBvYmoubmFtZSAmJiB0aGlzW29iai5uYW1lXSAmJiB0aGlzW29iai5uYW1lXSA9PT0gY2wpXG5cbiAgICAgICAgICBjbCA9IG9iai5DbGFzc1xuXG4gICAgICAgICAgaWYob2JqLm5hbWUgJiYgdGhpc1tvYmoubmFtZV0gJiYgdGhpc1tvYmoubmFtZV0gPT09IGNsKSB7XG4gICAgICAgICAgICByZWN1clJlbmRlci5jYWxsKHRoaXNbb2JqLm5hbWVdLCB0aGlzKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIGZvciAodmFyIGogaW4gYykge1xuICAgICAgICAgICAgIGlmIChjW2pdLmJhc2UgJiYgY1tqXS5iYXNlIGluc3RhbmNlb2YgY2wpIHtcbiAgICAgICAgICAgICAgIHJlY3VyUmVuZGVyLmNhbGwoY1tqXS5iYXNlLCB0aGlzKVxuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gYXJyLnNwbGljZShpLDEpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5sYXN0aW5kZXggPSBsXG59LFxuXG5zZXRSZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHAsIHBwO1xuICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICBwID0gdGhpcy5wYXJlbnQ7XG4gICAgaWYgKHAucmVuZGVycykge1xuICAgICAgcC5yZW5kZXJzLnB1c2godGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAucmVuZGVycyA9IFt0aGlzXTtcbiAgICAgIHBwID0gcC5wYXJlbnQ7XG4gICAgICBpZiAocHAgJiYgIShwcC5fc2V0dGluZ3MgJiYgcHAuX3NldHRpbmdzLnJlbmRlciAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgc2V0UmVuZGVyLmNhbGwocCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59LFxuXG52YWxSZW5kZXIgPSBmdW5jdGlvbih2YWwpIHtcbiAgdmFyIF9zZXR0aW5ncyA9ICh2YWwuX18gJiYgdmFsLl9fLl9zZXR0aW5ncyB8fCB2YWwuXy5fc2V0dGluZ3MpXG4gIGlmICh2YWwuXy5yZW5kZXJzIHx8IHZhbC5fXyAmJiB2YWwuX18ucmVuZGVycyB8fCBfc2V0dGluZ3MucmVuZGVyICE9PSB0cnVlKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcnMpIHRoaXMucmVuZGVycyA9IFtdXG4gICAgaWYgKCEodGhpcy5fXyAmJiB0aGlzLl9fLnJlbmRlcnMpKSB0aGlzLnJlbmRlcnMgPSB1dGlsLmNsb25lKHRoaXMucmVuZGVycylcbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnJlbmRlcnM9PT10aGlzLl9fLnJlbmRlcnMsIHRoaXMuX18ucmVuZGVycywgdGhpcy5fLnJlbmRlcnMpXG5cbiAgICAvLyBjb25zb2xlLmxvZyh1dGlsLmNoZWNrQXJyYXkodGhpcy5yZW5kZXJzLHZhbC5fZnJvbSkpXG4gICAgLy8gY29uc29sZS5sb2coJ1hYWFhYWCcsdmFsKVxuICAgIC8vIGlmKHV0aWwuY2hlY2tBcnJheSh0aGlzLnJlbmRlcnMsdmFsLl9mcm9tLl9mcm9tLCdfZnJvbS5fZnJvbScpPT09ZmFsc2UmJnV0aWwuY2hlY2tBcnJheSh0aGlzLnJlbmRlcnMsdmFsLl9mcm9tLCdfZnJvbScpPT09ZmFsc2UpIHtcbiAgICAgIHRoaXMucmVuZGVycy5wdXNoKHZhbClcbiAgICAvLyB9XG4gICAgLy8gY29uc29sZS5sb2coJ3JlbmRlcnMgcHVzaCAtLS0gY3JlYXRlcyBsZWFrcyEnKVxuICB9XG59XG5cbi8vZGVmaW5lIHZhbnVpdCBiYXNlIChrb3J0ZXIhKVxudXRpbC5kZWZpbmUoZXhwb3J0cyxcbiAgICdhcHBlbmQnLCBmdW5jdGlvbihhcnIpIHtcblxuICAgIC8vIGFsZXJ0KCdBUFBFTkQnKVxuICAgIC8vIGNvbnNvbGUubG9nKCdBUFBFTkQnLmludmVyc2UsYXJyKVxuXG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50c1xuXG4gICAgICBpZihhcmd1bWVudHMubGVuZ3RoPjEpIHtcbiAgICAgICAgYXJyID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgICAgfSAvL2Vsc2UgaWYoYXJyIClcblxuICAgICAgdmFyIGluc2VydGJlZm9yZVxuICAgICAgaWYoIWFyci5sZW5ndGggJiYgIShhcnIgaW5zdGFuY2VvZiBleHBvcnRzKSAmJiBhcnIudmFsKSB7XG4gICAgICAgIGluc2VydGJlZm9yZSA9IGFyci5iZWZvcmVcbiAgICAgICAgYXJyID0gYXJyLnZhbFxuICAgICAgfVxuICAgICAgdmFyIENsYXNzID0gYXJyWzBdXG4gICAgICAsIGkgPSAwXG4gICAgICAsIGwgPSBhcnIubGVuZ3RoXG4gICAgICBpZighYXJyLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmFkZChhcnIsIGluc2VydGJlZm9yZSlcbiAgICAgIH0gZWxzZSBpZih0eXBlb2YgQ2xhc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm9yKHZhciBpPTEsIGwgPSBhcnIubGVuZ3RoO2k8bDtpKyspIHtcbiAgICAgICAgICB0aGlzLmFkZChuZXcgQ2xhc3MoYXJyW2ldKSwgaW5zZXJ0YmVmb3JlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoO2k8bDtpKyspIHtcbiAgICAgICAgICB0aGlzLmFkZChhcnJbaV0sIGluc2VydGJlZm9yZSlcbiAgICAgICAgfVxuICAgICAgfVxuICB9LFxuICAnY2hlY2tSZW5kZXInLCBmdW5jdGlvbih2YWwsIG5vdFJlbmRlcmVkKSB7XG4gICAgaWYgKHZhbCkgdmFsUmVuZGVyLmNhbGwodGhpcywgdmFsKVxuICAgIGlmICghbm90UmVuZGVyZWQpIHtcbiAgICAgIHZhciBfcmVuZGVycyA9ICh0aGlzLl9fICYmIHRoaXMuX18ucmVuZGVycyB8fCB0aGlzLl8ucmVuZGVycylcbiAgICAgIGlmICggKCAoX3JlbmRlcnMgIHx8ICgodGhpcy5fXyAmJiB0aGlzLl9fLl9zZXR0aW5ncykgIHx8IHRoaXMuXy5fc2V0dGluZ3MpLnJlbmRlciAhPT0gdHJ1ZSlcbiAgICAgICAgICAmJiAoIXRoaXMubGFzdGluZGV4IHx8IChfcmVuZGVycyAmJiB0aGlzLmxhc3RpbmRleCA8IF9yZW5kZXJzLmxlbmd0aCkpXG4gICAgICAgICkgJiYgdGhpcy5yZW5kZXJlZCkge1xuICAgICAgICByZWN1clJlbmRlci5jYWxsKHRoaXMsIHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZih0aGlzLnBhcmVudCkgdmFsUmVuZGVyLmNhbGwodGhpcy5wYXJlbnQsIHRoaXMpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAnY2hlY2tQYXJlbnQnLCB1dGlsLmNoZWNrUGFyZW50RmFjdG9yeSgncGFyZW50JyksXG4gICdnZXQnLGZ1bmN0aW9uKHBhdGgsIHNlbGYpIHsgLy9nZXQgZG9lcyBub3QgbmVlZCBhbiBhcnJheSBhcyBwYXRoXG4gICAgcmV0dXJuIHV0aWwuZ2V0KHRoaXMsIHBhdGgsIHNlbGYpO1xuICB9LFxuICAnZmluZCcsIGZ1bmN0aW9uKGdldCwgbWF0Y2gsIGxldmVsKSB7XG4gICAgaWYobGV2ZWwgPT09IHZvaWQgMCkgbGV2ZWwgPSB0cnVlXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcbiAgICAgICwgaSA9IDBcbiAgICAgICwgZm91bmRcbiAgICAgICwgY2hpbGRcbiAgICAgICwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICAsIHBhc3NPbiA9IGxldmVsPT09dHJ1ZSA/IHRydWUgOiBsZXZlbC0xXG4gICAgZm9yKDtpPGxlbjtpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV0uYmFzZVxuICAgICAgaWYoY2hpbGQpIHtcbiAgICAgICAgaWYoY2hpbGQuZ2V0KGdldCwgdHJ1ZSk9PW1hdGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICAgIH0gZWxzZSBpZihsZXZlbCkge1xuICAgICAgICAgIGZvdW5kID0gY2hpbGQuZmluZChnZXQsIG1hdGNoLCBwYXNzT24pXG4gICAgICAgICAgaWYoZm91bmQpIHJldHVybiBmb3VuZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAnc2V0UmVuZGVyJywgZnVuY3Rpb24obmFtZSwgdmFsKSB7XG4gICAgdGhpcy5zZXRTZXR0aW5nKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICByZW5kZXI6IHZhbFxuICAgIH0pO1xuICAgIHNldFJlbmRlci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkgeyAvL2xvb2sgZm9yIGN1cnJlbnQgY2FsbGVyIGluc3RhbmNlIHBlcmhhcHM/XG4gICAgICBzZXRSZW5kZXIuY2FsbCh0aGlzKVxuICAgIH0sIG5hbWUpO1xuICB9LFxuICAncmVuZGVycycsIGZhbHNlLFxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgYXMgY2hpbGRcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICB2YWwgIE9iamVjdCB0byBiZSBhZGRlZFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFJldHVybnMgdGhlIFYuZWxlbWVudFxuICAgKi9cbiAgJ2FkZCcsIGZ1bmN0aW9uKHZhbCwgaW5zZXJ0YmVmb3JlKSB7XG4gICAgXG4gICAgaWYoaW5zZXJ0YmVmb3JlKSB7XG4gICAgICBpZih0eXBlb2YgaW5zZXJ0YmVmb3JlID09PSAnc3RyaW5nJykgaW5zZXJ0YmVmb3JlID0gdGhpc1tpbnNlcnRiZWZvcmVdXG4gICAgICBpZihpbnNlcnRiZWZvcmUpIHtcbiAgICAgICAgdGhpcy5ub2RlLmluc2VydEJlZm9yZSh2YWwubm9kZSwgaW5zZXJ0YmVmb3JlLm5vZGUgfHwgaW5zZXJ0YmVmb3JlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignY2Fubm90IGZpbmQgaW5zZXJ0YmVmb3JlJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKHZhbClcblxuICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHZhbC5ub2RlKVxuICAgIH1cblxuICAgIHZhbC5zZXR0aW5nKCdwYXJlbnQnLCBbdGhpc10pIC8vZXhlY3V0ZSBwYXJlbnQgc2V0dGluZ3NcbiAgICBpZiAodmFsLm5hbWUpIHRoaXNbdmFsLm5hbWVdID0gdmFsXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vbmVlZHMgY2xlYW5pbmcgY29zdHMgMyUgbm93Li4uXG4gICAgdGhpcy5jaGVja1JlbmRlcih2YWwpXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlblxuICAgKiBAbWV0aG9kIGVtcHR5XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGluc3RhbmNlcyBUcnVlIHdpbGwgcmVtb3ZlIGFsbCBpbnN0YW5jZXMgb2YgY2hpbGRyZW4gcmVtb3ZlZFxuICAgKi9cbiAgJ2VtcHR5JyxcbiAgZnVuY3Rpb24oaW5zdGFuY2VzKSB7XG4gICAgdmFyIGMgPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1xuICAgICAgLCBpXG4gICAgdGhpcy5ub2RlLmlubmVySHRtbCA9ICcnXG4gICAgZm9yIChpID0gYy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGNbaV0uYmFzZSkgY1tpXS5iYXNlLnJlbW92ZShpbnN0YW5jZXMpXG4gICAgfVxuICB9KTtcblxuZXhwb3J0cy5iYXNlLmFkZFNldHRpbmcoJ3BhcmVudCcpXG5leHBvcnRzLmJhc2UuYWRkU2V0dGluZygncmVuZGVyJylcbnJlcXVpcmUoJy4vc2V0JykiLCJ2YXIgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vdXRpbCcpXG5cbmV4cG9ydHMucHJlcGFyZSA9IGZ1bmN0aW9uKGVsKSB7XG4gIGlmKCFlbC5kaXNwbGF5KSBlbC5kaXNwbGF5ID0gJ2Jsb2NrJ1xufVxuXG5leHBvcnRzLm5ld0VsZW1lbnQgPSBmdW5jdGlvbihkYXRhLCBlbGVtZW50LCB0KSB7XG4gIHZhciBjID0gY29sbGVjdGlvbi5jaGlsZHJlbih0KVxuICBmb3IodmFyIGkgaW4gYykge1xuICAgIGlmKGNbaV0uX2QgJiYgY1tpXS5fZD09PWRhdGEpIHtcbiAgICAgIGNbaV0uZGlzcGxheSA9IGVsZW1lbnQuZGlzcGxheS52YWxcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG4gXG5leHBvcnRzLnJlbSA9IGZ1bmN0aW9uIChlbCwgdCwgaGFzRmlsdGVyLCBub1Jlc29sdmUpIHtcbiBlbC5kaXNwbGF5ID0gJ25vbmUnXG4gcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5mcmFnbWVudCA9IGZ1bmN0aW9uKGEsYixleGNsdWRlLGkpIHtcbiAgLy9zaW5jZSBpdCBuZXZlciByZW1vdmVzIGV4Y2x1ZGVzIHNob3VsZCBuZXZlciBiZSBhcHBsaWVkXG4gIC8vZXhjbHVkZSBpcyBub3JtYWxseSB1c2VkIHRvIG5vdCBhZGQgdGhpbmdzIGFnYWluIGlmIHRoZXkgYWxyZWFkeSBleGlzdFxuICBpZihleGNsdWRlKSBleGNsdWRlW2ldPW51bGxcbn1cbiIsIlxudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL3V0aWwnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi91dGlsJylcblxuLyoqXG4gKiBjb2xsZWN0aW9uXG4gKiBsaW5rcyBhcnJheXMgb3Igb2JqZWN0IHRvIGVsZW1lbnRzXG4gKiB1c2UgZmlsdGVyIGlmIHlvdSB3YW50IHRvIGNvbnZlcnRcbiAqIEBhdHRyaWJ1dGVcbiAqL1xuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKFxuICByZXF1aXJlKCcuLi9kYXRhJyksXG4gIGZ1bmN0aW9uKGJhc2Upe1xuXG4gICAgYmFzZS5leHRlbmQoe1xuICAgICAgbmFtZTonY29sbGVjdGlvbicsXG4gICAgICAvLyByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIHRoaXMudXBkYXRlKCdjb2xsZWN0aW9uJykgXG4gICAgICAvLyB9LFxuICAgICAgcmVtb3ZlOmZ1bmN0aW9uKCkge1xuICAgICAgICBpZih0aGlzLl9jb2xFbGVtKSB0aGlzLl9jb2xFbGVtLnJlbW92ZSgpXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGNoYW5nZSwgYWRkZWQpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd4eHh4IUAjISFAIyEjJywgdGhpcy5kYXRhICYmIHRoaXMuZGF0YS50b1N0cmluZygpKVxuXG4gICAgICAgIHZhbC5fc2tpcCA9IHRydWVcblxuICAgICAgICB2YXIgaGFzRmlsdGVyID0gY29sbGVjdGlvbi5maWx0ZXIodmFsLCB0aGlzKVxuICAgICAgICAgICwgZGF0YSA9IHRoaXMuZmlsdGVyIHx8IHZhbC52YWxcbiAgICAgICAgICAsIG9wdGlvbnMgPSB0aGlzLl9jb2xPcHRpb25zIHx8IHZhbC5vcHRpb25zIFxuICAgICAgICAgICAgICAmJiAodGhpcy5fY29sT3B0aW9ucyA9IHZhbC5vcHRpb25zLmNvbnZlcnQoKSlcbiAgICAgICAgICAsIG9yaWcgPSAgdmFsLmVsZW1lbnRcbiAgICAgICAgICAsIGVsID0gdGhpcy5fY29sRWxlbSBcbiAgICAgICAgICAgICAgfHwgKG9yaWcgJiYgb3JpZy5fdmFsKSAmJiAodGhpcy5fY29sRWxlbSA9IG5ldyAob3JpZy5fdmFsLkNsYXNzIHx8IG9yaWcuX3ZhbCkoKSlcbiAgICAgICAgICAsIGZpcnN0UnVuID0gIXRoaXMuX2NvbEluaXRcbiAgICAgICAgICAsIHNsU3RhbXBcbiAgICAgICAgICAsIGVsVmFsXG4gICAgICAgICAgLCBjb2xFbGVtID0gdGhpcy5fY29sRWxlbVxuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJyEhIU9QVElPTlMhJywgb3B0aW9ucylcblxuICAgICAgICAvL2RpcnR5IGJsb2NrISBjbGVhbiBpdCBGQVNUXG5cbiAgICAgICAgLy8gfHwgIXRoaXMucmVuZGVyZWQgXG5cbiAgICAgICAgaWYoIShkYXRhICYmIGVsKSkgcmV0dXJuIC8vfHwhdGhpcy5yZW5kZXJlZFxuICAgICAgICBcbiAgICAgICAgc2xTdGFtcCA9IG9yaWcuX3NsU3RhbXBcbiAgICAgICAgZWxWYWwgPSBvcmlnLl92YWxcblxuICAgICAgICBpZihzbFN0YW1wKSB7XG4gICAgICAgICAgb3JpZy5fc2xTdGFtcCA9IHN0YW1wXG4gICAgICAgIH0gZWxzZSBpZihjb2xFbGVtICYmIG9yaWcuX3NsU3RhbXAgIT09IHN0YW1wKSB7XG4gICAgICAgICAgaWYoIShlbFZhbC5DbGFzcyAmJiAoY29sRWxlbSBpbnN0YW5jZW9mIGVsVmFsLkNsYXNzKSkgXG4gICAgICAgICAgICAmJiAhKCFlbFZhbC5DbGFzcyAmJiAoY29sRWxlbSBpbnN0YW5jZW9mIGVsVmFsKSkpIHtcbiAgICAgICAgICAgIGVsID0gdGhpcy5fY29sRWxlbSA9IG5ldyAoZWxWYWwuQ2xhc3MgfHwgZWxWYWwpKClcbiAgICAgICAgICAgIG9yaWcuX3NsU3RhbXAgPSBzdGFtcFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnb29rIGxldWsgZmYgdXBkYXRlJywgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBjaGFuZ2UsIGFkZGVkKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXNzIScpXG4gICAgICAgICAgXG4gICAgICAgIGlmKGZpcnN0UnVuKSB7XG5cbiAgICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMucHJlcGFyZSAmJiBvcHRpb25zLnByZXBhcmUoZWwpXG5cbiAgICAgICAgICB0aGlzLl9jb2xJbml0ID0gdHJ1ZVxuICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChjb2xsZWN0aW9uLmZyYWdtZW50KCBkYXRhLCBlbCwgdGhpcywgZmFsc2UsIG9wdGlvbnNcbiAgICAgICAgICAgICwgaGFzRmlsdGVyICkpXG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmKGZyb20gJiYgZnJvbS5fcGFyZW50ID09PSBkYXRhLmZyb20pIHtcbiAgICAgICAgICAgIGlmKHJlbW92ZSkge1xuICAgICAgICAgICAgICB2YXIgciA9IHV0aWwuY2hlY2tBcnJheShjb2xsZWN0aW9uLmNoaWxkcmVuKHRoaXMpLGZyb20sJ19kJyx0cnVlKVxuICAgICAgICAgICAgICBpZihyKSB7XG4gICAgICAgICAgICAgICAgaWYoIShvcHRpb25zICYmIG9wdGlvbnMucmVtICYmIG9wdGlvbnMucmVtKHIsIHRoaXMsIGhhc0ZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgICByLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYodXRpbC5jaGVja0FycmF5KGNvbGxlY3Rpb24uY2hpbGRyZW4odGhpcyksZnJvbSwnX2QnKT09PWZhbHNlKSB7XG5cbiAgICAgICAgICAgICAgY29sbGVjdGlvbi5lbGVtZW50KCBmcm9tLCBlbCwgdGhpcywgdHJ1ZSwgdGhpcy5ub2RlLCBvcHRpb25zLCBoYXNGaWx0ZXIsIHRydWUgKVxuICAgICAgICAgICAgfSBlbHNlIGlmKGhhc0ZpbHRlciAmJiBvcHRpb25zICYmIG9wdGlvbnMuaW5kZXhDaGFuZ2UpIHtcblxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5kZXhDaGFuZ2UoXG4gICAgICAgICAgICAgICAgICB1dGlsLmNoZWNrQXJyYXkoY29sbGVjdGlvbi5jaGlsZHJlbih0aGlzKSxmcm9tLCdfZCcsdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICwgdGhpcywgaGFzRmlsdGVyIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcxMjJYWFhYWCcsIGZyb20sIGhhc0ZpbHRlciwgY29sbGVjdGlvbi5maWx0ZXIodmFsLCB0aGlzKSkgLy90cnkgdG8gZml4IG9yZGVyIGJ5IG5hbWUgYmV0dGVyXG5cbiAgICAgICAgICAgIGlmKCFmcm9tKSB7XG5cbiAgICAgICAgICAgICAgaWYocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbi5jbGVhcih0aGlzLCBvcHRpb25zKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgdmFyIGMgPSBjb2xsZWN0aW9uLmNoaWxkcmVuKHRoaXMpXG4gICAgICAgICAgICAgICAgICAsIGV4Y2x1ZGUgPSB7fVxuICAgICAgICAgICAgICAgICAgLCBuYW1lXG4gICAgICAgICAgICAgICAgICAsIGZGaWVsZFxuICAgICAgICAgICAgICAgICAgLCBrZXlzXG4gICAgICAgICAgICAgICAgICAsIGNoaWxkXG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWFhYWFgnLGhhc0ZpbHRlcikgLy90cnkgdG8gZml4IG9yZGVyIGJ5IG5hbWUgYmV0dGVyXG4gICAgICAgICAgICAgICAgaWYoaGFzRmlsdGVyPT09dHJ1ZSkge1xuICAgICAgICAgICAgICAgICAga2V5cyA9IGRhdGEua2V5c1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvcih2YXIgaiBpbiBjKSB7XG4gICAgICAgICAgICAgICAgICBjaGlsZCA9IGNbal1cbiAgICAgICAgICAgICAgICAgIG5hbWUgPSBjW2pdLl9kLl9uYW1lXG5cbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGNbal0sIGhhc0ZpbHRlciwga2V5cywgdXRpbC5jaGVja0FycmF5KGRhdGEsY2hpbGQuX2QpID09PSBmYWxzZSlcblxuICAgICAgICAgICAgICAgICAgaWYoaGFzRmlsdGVyICYmICFrZXlzID8gdXRpbC5jaGVja0FycmF5KGRhdGEsY2hpbGQuX2QpID09PSBmYWxzZSA6ICFkYXRhW25hbWVdIHx8IGRhdGFbbmFtZV0hPT1jaGlsZC5fZCApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ0hFQ0shLS0tJyxqKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKCEob3B0aW9ucyAmJiBvcHRpb25zLnJlbSAmJiBvcHRpb25zLnJlbShjaGlsZCwgdGhpcywgaGFzRmlsdGVyLCBoYXNGaWx0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vdGhpcyBpcyBtb3JlIGVmZmljaWVudFxuICAgICAgICAgICAgICAgICAgICAvLyBpZihkYXRhW25hbWVdIT09Y1tqXS5fZCkgY1tqXS5kYXRhID0gZGF0YVtuYW1lXSBcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZVtuYW1lXT10cnVlXG4gICAgICAgICAgICAgICAgICAgIGlmKGhhc0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgIGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmRleENoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2hpbGQuX2QuX2luZGV4Q2FjaGVbaGFzRmlsdGVyXVswXSE9PWNoaWxkLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleENoYW5nZShjaGlsZCwgdGhpcywgaGFzRmlsdGVyLCB0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZihoYXNGaWx0ZXI9PT10cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqIT11dGlsLmNoZWNrQXJyYXkoa2V5cyxuYW1lLHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBleGNsdWRlW25hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCEob3B0aW9ucyAmJiBvcHRpb25zLnJlbSAmJiBvcHRpb25zLnJlbShjW2pdLCB0aGlzLCBoYXNGaWx0ZXIsIGhhc0ZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmZyYWdtZW50KGRhdGEsIGVsLCB0aGlzLCBleGNsdWRlLCBvcHRpb25zLCBoYXNGaWx0ZXIpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxufSkiLCJ2YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4uLycpXG4gICwgRGF0YSA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL2RhdGEnKS5pbmplY3QocmVxdWlyZSgnLi4vLi4vLi4vLi4vZGF0YS9zZWxlY3Rpb24nKSlcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdXRpbCcpXG5cbnZhciByID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBTdHJpbmcofn4oTWF0aC5yYW5kb20oKSo5KSkrJydcbn1cblxuZXhwb3J0cy5lbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGVsZW1lbnQsIHQsIHVwZGF0ZSwgbm9kZSwgb3B0aW9ucywgaGFzRmlsdGVyLCByZXNvbHZlKSB7XG4gIHZhciBlbGVtXG4gIGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5uZXdFbGVtZW50KSB7XG4gICAgZWxlbSA9IG9wdGlvbnMubmV3RWxlbWVudC5hcHBseSh0aGlzLGFyZ3VtZW50cylcbiAgICBpZihlbGVtPT09dHJ1ZSkgcmV0dXJuXG4gIH1cbiAgZWxlbSA9IGVsZW0gfHwgbmV3IGVsZW1lbnQuQ2xhc3MoKVxuICBcbiAgZWxlbS5fY29sID0gdHJ1ZVxuXG4vLyAgIGNvbnNvbGUubG9nKCAnLS0tLT4nLCBkYXRhIClcblxuICBpZiAoZGF0YSAhPT0gdm9pZCAwKSBlbGVtLl9kU2V0KGRhdGEpXG4gIGlmIChub2RlKSBub2RlLmFwcGVuZENoaWxkKGVsZW0ubm9kZSlcbiAgZWxlbS5zZXR0aW5nKCdwYXJlbnQnLCBbdF0pXG4gIDtvcHRpb25zJiZvcHRpb25zLmVsZW1lbnQmJm9wdGlvbnMuZWxlbWVudChlbGVtLCB0LCBoYXNGaWx0ZXIsIHJlc29sdmUpXG4gIGlmICh1cGRhdGUgJiYgZGF0YSAhPT0gdm9pZCAwKSBlbGVtLnVwZGF0ZURhdGEoKVxuICB0LmNoZWNrUmVuZGVyKGVsZW0sIHRydWUpXG4gIHJldHVybiBlbGVtXG59XG5cbmV4cG9ydHMuZnJhZ21lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCwgdCwgZXhjbHVkZSwgb3B0aW9ucywgaGFzRmlsdGVyKSB7XG4gIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgLCBpdGVtID0gZnVuY3Rpb24oaSkge1xuICAgICAgICAvL2lmIHlvdSB1c2UgdGhlIHBhc3NlZCBpIGl0IGlzIGEgZGlmZmVyZW50IHZhbHVlIGZvciBzZWxlY3Rpb25zXG4gICAgICAgIGlmKHRoaXMuX25hbWUpIGkgPSB0aGlzLl9uYW1lXG4gICAgICAgIGlmKCEob3B0aW9ucyYmb3B0aW9ucy5mcmFnbWVudCYmb3B0aW9ucy5mcmFnbWVudCh0LHRoaXMsZXhjbHVkZSxpKSlcbiAgICAgICAgICAmJiAoIWV4Y2x1ZGUgfHwgIWV4Y2x1ZGVbaV0pICkge1xuICAgICAgICAgIHZhciBlbGVtID0gZXhwb3J0cy5lbGVtZW50KCB0aGlzIHx8IG51bGwsIGVsZW1lbnQsIHQsIGZhbHNlLCBmcmFnLCBvcHRpb25zXG4gICAgICAgICAgICAgICwgaGFzRmlsdGVyKVxuICAgICAgICAgIGlmKGVsZW0pIGZyYWcuYXBwZW5kQ2hpbGQoIGVsZW0ubm9kZSApXG4gICAgICAgICAgZWxlbS51cGRhdGVEYXRhKClcbiAgICAgICAgfVxuICAgICAgfVxuICBmcmFnLl9wID0gdFxuXG4gIGlmKGRhdGEuZWFjaCkge1xuICAgIGRhdGEuZWFjaChpdGVtKVxuICB9IGVsc2Uge1xuICAgIC8vbm9ybWFsIGRhdGFcbiAgICBmb3IodmFyIGkgaW4gZGF0YSkge1xuICAgICAgaXRlbS5jYWxsKCBkYXRhW2ldICxpIClcbiAgICB9XG4gIH1cblxuICAvLyBlbGVtZW50LnVwZGF0ZURhdGEodHJ1ZSlcbiAgcmV0dXJuIGZyYWdcbn1cblxuZXhwb3J0cy5jaGlsZHJlbiA9IGZ1bmN0aW9uICh0LCBvcHRpb25zKSB7XG4gIGlmKCF0KSByZXR1cm5cbiAgdmFyIGNoID0gW11cbiAgZm9yKHZhciBpIGluIHQubm9kZS5jaGlsZE5vZGVzKSB7XG4gICAgdmFyIGNoaWxkID0gdC5ub2RlLmNoaWxkTm9kZXNbaV0uYmFzZVxuICAgIGlmKGNoaWxkICYmIGNoaWxkLl9jb2wpIHtcbiAgICAgIGNoLnB1c2goY2hpbGQpXG4gICAgfVxuICB9XG4gIDtvcHRpb25zJiZvcHRpb25zLmNoaWxkcmVuJiZvcHRpb25zLmNoaWxkcmVuKGNoKVxuICByZXR1cm4gY2hcbn1cblxuZXhwb3J0cy5jbGVhciA9IGZ1bmN0aW9uICh0LCBvcHRpb25zKSB7XG4gIHQuY29sSW5pdCA9IG51bGxcbiAgdmFyIGMgPSBleHBvcnRzLmNoaWxkcmVuKHQpXG4gIGZvcih2YXIgaSBpbiBjKSB7IGNbaV0ucmVtb3ZlKCkgfVxuICA7b3B0aW9ucyYmb3B0aW9ucy5jbGVhciYmb3B0aW9ucy5jbGVhcih0KVxufVxuXG5leHBvcnRzLmZpbHRlciA9IGZ1bmN0aW9uICh2YWwsdCkge1xuXG5cbiAgdmFyIGRhdGEgPSB2YWwudmFsXG5cblxuICAvLyBjb25zb2xlLmxvZygnRE8gSSBIQVZFIEZVTFRFUiE+PycsZGF0YSwgIHZhbCwgdClcblxuXG4gIGlmKHZhbC5maWx0ZXIgJiYgdmFsLmZpbHRlci52YWw9PT10cnVlKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3NvcnQgYnkgbmFtZScpIG1vZXQgYmV0ZXJcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2dvdCBpdCFEQVRBeCEnKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgICAvL2RpZmZlcmVudCB2aWJlc1xuICB9XG5cbiAgaWYgKGRhdGEgJiYgdmFsLmZpbHRlciAmJiAhdC5maWx0ZXIpIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdNQUtFIE5FVyBTVFlVRkZGJylcblxuICAgIHZhciBhID0gdmFsLmZpbHRlci5yYXdcbiAgICAvL2RpdCBpcyBrYXBvdFxuICAgIGRhdGEgPSB0LmZpbHRlciA9IG5ldyBEYXRhKGRhdGEsIGEpXG5cbiAgICAvLyBjb25zb2xlLmxvZygnRklMVEVSU1NTUyEnLCBhLCB0KVxuICAgIC8vIGRlYnVnZ2VyXG5cbiAgICBhLl9jb2wgPSB0cnVlXG4gICAgXG4gICAgZGF0YS5hZGRMaXN0ZW5lcihmdW5jdGlvbiAodmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlKSB7XG4gICAgICB0LmNvbGxlY3Rpb24uX3VwZGF0ZSh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUpXG4gICAgfSlcbiAgICBcbiAgICB0LnNldFNldHRpbmcoe1xuICAgICAgLy8gbmFtZTogJ2NvbGxlY2l0b25maWx0ZXInLFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHQuZmlsdGVyLnJlbW92ZSgpXG4gICAgICAgIHQuZmlsdGVyID0gbnVsbFxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBjb25zb2xlLmxvZygnREFUQXghJylcbiAgICByZXR1cm4gZGF0YS5fdWlkXG4gICAgLy8gcmV0dXJuIHQuZmlsdGVyLl91aWQvL2RhdGEgaXMgZmlsdGVyXG4gIH0gZWxzZSBpZihkYXRhICYmIGRhdGEuX2ZpbHRlcikge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnRHh4eEFUQXghJylcblxuICAgIHJldHVybiBkYXRhLl91aWRcbiAgfSBcbiAgZWxzZSBpZih0LmZpbHRlcikge1xuXG4gICAgcmV0dXJuIHQuZmlsdGVyLl91aWRcbiAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ05PIERBVEFYISBGSUxURVInLCB0KVxuXG59XG5cbi8vIGV4cG9ydHMuaW5kZXhDaGFuZ2UgPSBmdW5jdGlvbihlbCwgdCwgaGFzRmlsdGVyLCBub1Jlc29sdmUpIHtcbi8vIHZhciBvbGRJbmRleCA9IGVsLl9kLl9pbmRleENhY2hlW2hhc0ZpbHRlcl1bMV1cbi8vICAgICAsIG5ld0luZGV4ID0gZWwuX2QuX2luZGV4Q2FjaGVbaGFzRmlsdGVyXVswXVxuLy8gICAgICwgY2ggPSAhbm9SZXNvbHZlICYmIGNvbGxlY3Rpb24uY2hpbGRyZW4odCxleHBvcnRzKVxuLy8gICAgICwgbFxuXG5cbi8vICAgZXhwb3J0cy54eShlbClcblxuLy8gICBpZihub1Jlc29sdmUpIHJldHVyblxuXG4vLyAgIGwgPSBjaC5sZW5ndGhcbiAgXG4gIFxuLy8gICB2YXIgY2xvbmUgPSBlbC5ub2RlLmNsb25lTm9kZSh0cnVlKVxuLy8gICB0Lm5vZGUucmVtb3ZlQ2hpbGQoZWwpXG4vLyAgIGVsLl9ub2RlID0gY2xvbmVcblxuXG4gICBcbi8vICAgLy8gdC5oID0gdC5ub2RlLnNjcm9sbEhlaWdodFxuLy8gfSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBkYXRhID0gcmVxdWlyZSgnLi4vLi4vLi4vZGF0YS9iYXNlJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG4gICwgZmxhZ3MgPSByZXF1aXJlKCcuLi8uLi8uLi92YWx1ZS9mbGFncycpXG5cbi8qKlxuICAqIGV4dGVuZHMgdXBkYXRlRGF0YSB0byB0YWtlIGNoaWxkTm9kZXMgaW50byBhY2NvdW50XG4gICogbWF5IG5lZWQgdG8gYWRkIGV4dHJhIGFyZ3VtZW50IGZvciBnbyBkZWVwXG4gICogQG1ldGhvZFxuKi9cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoWyBkYXRhLCB7XG4gIHVwZGF0ZURhdGE6IGZ1bmN0aW9uICggaW5zdGFuY2VzLCBkYXRhLCBmbW9kZWwgKSB7XG5cbiAgICAvLyBpZiggaW5zdGFuY2VzICkgY29uc29sZS5lcnJvcignPz8/Py0tLS0tLS0tLS0tPj4+Pj4nKVxuXG4gICAgaWYgKHRoaXMuX2QpIHtcbiAgICAgIHRoaXMuX3N1YnNjcmliZWQgPSBmYWxzZVxuICAgICAgZGF0YSA9IHRoaXMuX2RcbiAgICB9XG5cbiAgICB2YXIgZmZtb2RlbCA9IGZhbHNlXG4gICAgdmFyIHBhcnNlZCA9IGZhbHNlXG4gICAgaWYgKCFmbW9kZWwgJiYgIXRoaXMubW9kZWwgJiYgIXRoaXMuX2Ztb2RlbCkgZmZtb2RlbCA9IHRydWVcbiAgICAvL2Ztb2RlbCBpcyBmaXJzdCBtb2RlbFxuICAgIGZvciAodmFyIGNoaWxkcmVuID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcbiAgICAgICwgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDFcbiAgICAgICwgYmFzZTsgaSA+PSAwOyBpLS0pIHtcblxuICAgICAgYmFzZSA9IGNoaWxkcmVuW2ldLmJhc2VcbiAgICAgIFxuICAgICAgLy8gaWYoYmFzZSAmJiBiYXNlLm1vZGVsICYmIGJhc2UubW9kZWwuZmllbGQgJiYgYmFzZS5tb2RlbFBhcnNlZCAhPT0gYmFzZS5tb2RlbC5maWVsZC52YWwgJiYgYmFzZS5pbnN0YW5jZXMgJiYgaW5zdGFuY2VzKSB7XG4gICAgICAvLyAgIC8vIGNvbnNvbGUuZXJyb3IoJzEnLCBiYXNlICYmIGJhc2UubmFtZSwgYmFzZS5pbnN0YW5jZXMpXG4gICAgICAvLyAgICAgICBpZighZGF0YSAmJiBpbnN0YW5jZXMpIHtcbiAgICAgIC8vICAgICAgICAgaWYoIWRhdGEpIHtcbiAgICAgIC8vICAgICAgICAgICBkYXRhID0gYmFzZS5jaGVja1BhcmVudCgnX2QnLHRydWUpIHx8IHRoaXMuY2hlY2tQYXJlbnQoJ19kJyx0cnVlKVxuICAgICAgLy8gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdoZXkgaGV5IGhleScsIGRhdGEsIHRoaXMuX2QsIGJhc2UuX2QsIGJhc2UpXG4gICAgICAvLyAgICAgICAgIH1cbiAgICAgIC8vICAgICAgICAgY29uc29sZS5lcnJvcignbGV6emdvIGluc3RhbmNlcycsIGRhdGEpXG4gICAgICAvLyAgICAgICAgIC8vIGJhc2UuX2QgPSBkYXRhID0gZGF0YS5nZXQodGhpcy5tb2RlbC5maWVsZC52YWwpIC8vdXRpbC5wYXRoKGRhdGEsdGhpcy5tb2RlbC5maWVsZC52YWwuc3BsaXQoJy4nKSlcbiAgICAgIC8vICAgICAgICAgZm9yKHZhciBpIGluIGJhc2UuaW5zdGFuY2VzKSB7XG4gICAgICAvLyAgICAgICAgICAgaWYoIWJhc2UuaW5zdGFuY2VzW2ldLm1vZGVsLnBhcnNlZCkge1xuICAgICAgLy8gICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignPycsYmFzZS5pbnN0YW5jZXNbaV0ubW9kZWwucGFyc2VkKVxuICAgICAgLy8gICAgICAgICAgICAgYmFzZS5pbnN0YW5jZXNbaV0udXBkYXRlRGF0YShmYWxzZSwgZGF0YSlcbiAgICAgIC8vICAgICAgICAgICB9XG4gICAgICAvLyAgICAgICAgIH1cbiAgICAgIC8vICAgICAgICAgLy8gYmFzZS5tb2RlbFBhcnNlZCA9IFxuICAgICAgLy8gICAgICAgICAvLyBiYXNlLm1vZGVsID0ge31cbiAgICAgIC8vICAgICAgICAgLy8gYmFzZS5tb2RlbC5wYXJzZWQgPSBiYXNlLm1vZGVsLmZpZWxkLnZhbCBcbiAgICAgIC8vICAgICAgICAgLy8gcmV0dXJuXG4gICAgICAvLyAgICAgICB9XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGlmKGJhc2UgJiYgYmFzZS5tb2RlbCAmJiBiYXNlLm1vZGVsLmZpZWxkICYmICFiYXNlLl9kKSB7XG4gICAgICAgIC8vIGJhc2UuX2RTZXQoZGF0YSwgdHJ1ZSlcbiAgICAgIC8vIH1cblxuICAgICAgaWYgKGJhc2VcbiAgICAgICYmICghKGJhc2UubW9kZWwgJiYgYmFzZS5tb2RlbC5pbmhlcml0ICYmIGJhc2UubW9kZWwuaW5oZXJpdC52YWw9PT1mYWxzZSkpXG4gICAgICAmJiAoYmFzZS5fZCA9PT0gdm9pZCAwIHx8IGJhc2UuX2Rmcm9tIHx8IChiYXNlLm1vZGVsICYmIGJhc2UubW9kZWwuZmllbGQpICkpIHtcbiAgICAgICAgdmFyIHRkYXRhID0gZGF0YVxuXG4gICAgICAgIGlmIChiYXNlLm1vZGVsICYmIChkYXRhIHx8IGJhc2UubW9kZWwgJiYgYmFzZS5tb2RlbC5maWVsZCkpIHtcbiAgICAgICAgICBpZiAoZmZtb2RlbCkgYmFzZS5fZm1vZGVsID0gdHJ1ZVxuXG4gICAgICAgICAgLy9oaWVyIG9vayBmZiBtb2RlbCBwYXJzZW4hXG4gICAgICAgICAgaWYoYmFzZS5tb2RlbCAmJiBiYXNlLm1vZGVsLmZpZWxkKSB7XG4gICAgICAgICAgICB0ZGF0YSA9IGRhdGEuZ2V0KGJhc2UubW9kZWwuZmllbGQudmFsKVxuICAgICAgICAgICAgYmFzZS5tb2RlbFBhcnNlZCA9IGJhc2UubW9kZWwuZmllbGQudmFsXG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKHRkYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IodGRhdGEuX2NhY2hlZFBhdGgpXG5cbiAgICAgICAgICBiYXNlLl9kU2V0KHRkYXRhLCB0cnVlKVxuICAgICAgICB9XG5cbiAgICAgICAgYmFzZS51cGRhdGVEYXRhKGZhbHNlLCB0ZGF0YSwgYmFzZS5fZm1vZGVsIHx8IGZtb2RlbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1dKSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxuICAvKlxuICAgIGhlcmUgc29tZSBiYXNpYyBodG1sIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIFYuRWxlbWVudC5OZXNzZWNhcnlcbiAgICBmb3IgdmFsdWVzIHRoYXQgeW91IHdhbnQgdG8gYmUgYWJsZSB0byBiaW5kIHRvIFYuT2JqZWN0c1xuICAgIFVzZXMgYmFzZS5leHRlbmQgLS0gc2VlIGNvcmUuYmFzZSBmb3IgbW9yZSBpbmZvcm1hdGlvblxuICAqL1xuXG52YXIgdWEgPSByZXF1aXJlKCcuLi8uLi91YScpXG52YXIgY3NzID0gcmVxdWlyZSgnLi4vLi4vY3NzJylcbnZhciBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlJylcbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG52YXIgaGFzaCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvaGFzaCcpXG52YXIgcmFmID0gcmVxdWlyZSgnLi4vLi4vYW5pbWF0aW9uL3JhZicpXG52YXIgX2xvYWQgPSByZXF1aXJlKCcuLi8nKS5pbWFnZXMgPSB7fVxudmFyIF90cmFuc2Zvcm0gPSB1YS5wcmVmaXggKyAnVHJhbnNmb3JtJ1xudmFyIF9jc3NUcmFuc2Zvcm0gPSB1YS5wcmVmaXggKyAnLXRyYW5zZm9ybSdcbnZhciBwb3N0cG9uZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy91dGlsJykucG9zdHBvbmVcbnZhciBib2R5ID0gZG9jdW1lbnQuYm9keS5zdHlsZVxuICAgIC8vdGhpbmsgYWJvdXQgZG9jIHJlYWR5IGV2ZW50IG9yIGZhbGxiYWNrIGlmIG5vIGJvZHlcbnZhciBfdHJhbnNsYXRlID0gYm9keS5wZXJzcGVjdGl2ZVByb3BlcnR5ICE9IHZvaWQgMFxuICAgICAgICAgICAgICAgICB8fCBib2R5LldlYmtpdFBlcnNwZWN0aXZlICE9IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICA/IFsndHJhbnNsYXRlM2QoJywgJywwcHgpJ11cbiAgICAgICAgICAgICAgICAgICAgOiBbJ3RyYW5zbGF0ZSgnLCAnKSddXG52YXIgX2Nvb3JkaW5hdGUgPSBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdmFyIG1hcmdpbiA9ICdtYXJnaW4nICsgKHN0eWxlWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHlsZS5zbGljZSgxKSk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmKHZhbC5jbGVhbikge1xuICAgICAgICAgIF9jbGVhbkNvb3JkaW5hdGUuY2FsbCh0aGlzLHN0eWxlLG1hcmdpbilcbiAgICAgICAgICB2YWwuY2xlYW4gPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbC50cmFuc2xhdGUpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zbGF0ZSh2YWwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5ub2RlLnN0eWxlW3RoaXMucmVsYXRpdmUgPyBtYXJnaW4gOiBzdHlsZV0gPSB2YWwudmFsICsgJ3B4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxudmFyIF9jbGVhclRyYW5zZm9ybSA9IG5ldyBSZWdFeHAoX2Nzc1RyYW5zZm9ybSsnKC4qPyk7JylcbnZhciBfY2xlYXIgPVxuICAgIHsgeDogLyhtYXJnaW4tbGVmdCguKj8pOyl8KGxlZnQoLio/KTspL2dcbiAgICAsIHk6IC8obWFyZ2luLXRvcCguKj8pOyl8KHRvcCguKj8pOykvZ1xuICAgIH1cbnZhciBfY2xlYW5Db29yZGluYXRlID0gZnVuY3Rpb24oIGNoZWNrICkge1xuICAgICAgdmFyIHQgPSB0aGlzLl90XG4gICAgICAsIGtlZXAgPSBmYWxzZVxuICAgICAgLCB2YWwgPSB0aGlzW2NoZWNrXVxuICAgICAgLCBjc3NUZXh0ID0gdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQucmVwbGFjZSggX2NsZWFyW2NoZWNrXSwgJycgKVxuXG4gICAgaWYoIHZhbCAmJiB2YWwudHJhbnNsYXRlICYmIHZhbC50cmFuc2xhdGUudmFsPT09ZmFsc2UpIHZhbC50cmFuc2xhdGUgPSBudWxsXG5cbiAgICBpZih0aGlzLm5vZGUuc3R5bGVbX3RyYW5zZm9ybV0gJiYgIXZhbC50cmFuc2xhdGUpIHtcbiAgICAgIGlmKHQpIHtcbiAgICAgICAgaWYoIXRoaXNbY2hlY2tdLnRyYW5zbGF0ZSkge1xuICAgICAgICAgIGZvcih2YXIgaSA9IDIgOyBpIDwgNiA7IGkrKykge1xuICAgICAgICAgICAgaWYodFtpXSlrZWVwPXRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAga2VlcD10cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKCFrZWVwKSBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKF9jbGVhclRyYW5zZm9ybSwnJylcbiAgICB9XG4gICAgdGhpcy5ub2RlLnN0eWxlLmNzc1RleHQgPSBjc3NUZXh0XG4gIH1cblxudmFyIHNldFRpbWVycywgcmVtb3ZlVGltZXJzLCBfc2V0VGltZW91dFxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGZ1bmN0aW9uKGJhc2UpIHtcbiAgdXRpbC5kZWZpbmUoYmFzZS5DbGFzcyxcbiAgICAnY2xlYW5Db29yZGluYXRlcycsIGZ1bmN0aW9uKGNvb3JkKSB7XG4gICAgICAgaWYodGhpcy5fbm9kZSkge1xuICAgICAgICBpZighY29vcmQpIHtcbiAgICAgICAgICBfY2xlYW5Db29yZGluYXRlLmNhbGwodGhpcywneCcpXG4gICAgICAgICAgX2NsZWFuQ29vcmRpbmF0ZS5jYWxsKHRoaXMsJ3knKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9jbGVhbkNvb3JkaW5hdGUuY2FsbCh0aGlzLGNvb3JkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAndHJhbnNsYXRlJywgZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIF94XG4gICAgICAsIF95XG4gICAgICAsIF92YWwgPSAgdmFsLnZhbFxuICAgICAgLCBfc2NhbGVcbiAgICAgICwgX3JvdGF0ZVxuICAgICAgLCBfcm90YXRlWVxuICAgICAgLCBfcm90YXRlWFxuICAgICAgLCBfc3RyID0gJydcbiAgICAgICwgX25hbWUgPSB2YWwgJiYgdmFsLl9wcm9wLm5hbWVcbiAgICAgICwgX3QgPSB0aGlzLl90ID0gdGhpcy5fdCB8fCBbXVxuICAgICAgLCBub3BlID0gZmFsc2VcblxuICAgIC8vY2lydGljYWwgcGVyZm9ybWFuY2UgcG9pbnQgaGVuY2UgdXNlIG9mIHwgMFxuICAgIGlmIChfbmFtZSA9PT0gJ3gnKSB7XG4gICAgICBfeCA9IF92YWwgfCAwXG4gICAgICBpZiAoX3ggPT09IF90WzBdKSBub3BlID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoX25hbWUgPT09ICd5Jykge1xuICAgICAgX3kgPSBfdmFsIHwgMFxuICAgICAgaWYgKF95ID09PSBfdFsxXSkgbm9wZSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKF9uYW1lID09PSAncm90YXRlJykge1xuICAgICAgX3JvdGF0ZSA9IF92YWxcbiAgICAgIGlmIChfcm90YXRlID09PSBfdFsyXSkgbm9wZSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKF9uYW1lID09PSAnc2NhbGUnKSB7XG4gICAgICBfc2NhbGUgPSBfdmFsXG4gICAgICBpZiAoX3NjYWxlID09PSBfdFszXSkgbm9wZSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKF9uYW1lID09PSAncm90YXRlWScpIHtcbiAgICAgIF9yb3RhdGVZID0gX3ZhbFxuICAgICAgaWYgKF9yb3RhdGVZID09PSBfdFs0XSkgbm9wZSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKF9uYW1lID09PSAncm90YXRlWCcpIHtcbiAgICAgIF9yb3RhdGVYID0gX3ZhbFxuICAgICAgaWYgKF9yb3RhdGVYID09PSBfdFs0XSkgbm9wZSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoIW5vcGUpIHtcbiAgICAgIF90WzBdID0gIF94IHx8ICh0aGlzLngudHJhbnNsYXRlICYmIHRoaXMueC52YWwgfCAwKSB8fCAwXG4gICAgICBfdFsxXSA9ICBfeSB8fCAodGhpcy55LnRyYW5zbGF0ZSAmJiB0aGlzLnkudmFsIHwgMCkgfHwgMFxuICAgICAgX3RbMl0gPSBfcm90YXRlIHx8IHRoaXMucm90YXRlLnZhbFxuICAgICAgX3RbM10gPSBfc2NhbGUgfHwgdGhpcy5zY2FsZS52YWxcbiAgICAgIF90WzRdID0gX3JvdGF0ZVkgfHwgdGhpcy5yb3RhdGVZLnZhbFxuICAgICAgX3RbNV0gPSBfcm90YXRlWCB8fCB0aGlzLnJvdGF0ZVgudmFsXG4gICAgICBpZiAoX3RbMF0gfHwgX3RbMV0pIHtcbiAgICAgICAgX3N0ciA9IF9zdHJcbiAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgX3RyYW5zbGF0ZVswXVxuICAgICAgICAgICsgX3RbMF0gKyAncHgsJ1xuICAgICAgICAgICsgX3RbMV0gKyAncHgnXG4gICAgICAgICAgKyBfdHJhbnNsYXRlWzFdXG4gICAgICAgICAgKVxuICAgICAgfVxuICAgICAgaWYgKF90WzJdKSB7IF9zdHIgPSBfc3RyLmNvbmNhdCgnIHJvdGF0ZSgnICsgX3RbMl0gKyAnZGVnKScpIH1cbiAgICAgIGlmIChfdFszXSkgeyBfc3RyID0gX3N0ci5jb25jYXQoJyBzY2FsZSgnICsgX3RbM10gKyAnKScpIH1cbiAgICAgIGlmIChfdFs0XSkgeyBfc3RyID0gX3N0ci5jb25jYXQoJyByb3RhdGVZKCcgKyBfdFs0XSArICdkZWcpJykgfVxuICAgICAgaWYgKF90WzVdKSB7IF9zdHIgPSBfc3RyLmNvbmNhdCgnIHJvdGF0ZVgoJyArIF90WzVdICsgJ2RlZyknKSB9XG4gICAgICB0aGlzLm5vZGUuc3R5bGVbX3RyYW5zZm9ybV0gPSBfc3RyXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH0sICd1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgX2FyZ3MgPSB1dGlsLmFyZyhhcmd1bWVudHMpLCBsID0gX2FyZ3MubGVuZ3RoLCBwOyBpIDwgbDsgaSsrICkge1xuICAgICAgaWYgKF9hcmdzW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdGhpcy51cGRhdGUuYXBwbHkodGhpcywgX2FyZ3NbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcCA9IHV0aWwuZ2V0KHRoaXMsIF9hcmdzW2ldKTtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICBwLnVwZGF0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGRvbmUgPSBwb3N0cG9uZShmdW5jdGlvbih2YWwsc2VsZixzZGlyKXtcbiAgICBpZihzZWxmKXtcbiAgICAgIGlmKHZhbC5fbGlzdGVuZXJzICE9PSB2b2lkIDApIHZhbC52YWwgPSBzZWxmLm5vZGVbc2Rpcl1cbiAgICAgIGVsc2Ugc2VsZltzZGlyXS5fX2x2YWwgPSB2b2lkIDBcbiAgICB9XG4gIH0sMjApXG5cbiAgZnVuY3Rpb24gY3JlYXRlU2Nyb2xsKGRpcil7XG4gICAgdmFyIHMgPSAnc2Nyb2xsJ1xuICAgICAgLCBzZGlyID0gcyArIGRpciAvL3Njcm9sbExlZnQgb3Igc2Nyb2xsVG9wXG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTpzZGlyLFxuICAgICAgc2V0OmZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgdiA9IHZhbC52YWxcbiAgICAgICAgICAsIHNlbGYgPSB0aGlzXG4gICAgICAgIGlmKHYgIT09IHZvaWQgMCkgc2VsZi5ub2RlW3NkaXJdID0gdlxuICAgICAgICBpZighc2VsZi5fX3NUKXtcbiAgICAgICAgICBzZWxmLl9fc1QgPSB0cnVlXG4gICAgICAgICAgc2VsZi5hZGRFdmVudChzLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBkb25lKHZhbCxzZWxmLHNkaXIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICB9LFxuICAgICAgZ2V0OmZ1bmN0aW9uKHZhbCl7XG4gICAgICAgIGlmKHZhbC5fX2x2YWwgPT09IHZvaWQgMCkgdmFsLnZhbCA9IHRoaXMubm9kZVtzZGlyXVxuICAgICAgICByZXR1cm4gdmFsXG4gICAgICB9LFxuICAgICAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgICAgICAsIHZhbCA9IHNlbGZbc2Rpcl0uX19sdmFsXG4gICAgICAgIGlmKHZhbCl7XG4gICAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm5vZGVbc2Rpcl0gPSB2YWxcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBiYXNlLmV4dGVuZCh7XG4gICAgbmFtZTogJ3JlbGF0aXZlJyxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHMgPSB0aGlzLnBvc2l0aW9uICE9PSBmYWxzZSA/IHRoaXMucG9zaXRpb24udmFsIDogKHRoaXMucG9zaXRpb24gPSB7XG4gICAgICAgIGNzczogdHJ1ZSxcbiAgICAgICAgdmFsOiBjc3ModGhpcy5jc3MudmFsLCAncG9zaXRpb24nKVxuICAgICAgfSlcbiAgICAgIHJldHVybiBzICE9PSAnYWJzb2x1dGUnXG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogZmFsc2UsXG4gICAgbmFtZTogJ3JlbmRlcmVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJldCA9IHRoaXMuX3JlbmRlcmVkIHx8ICh0aGlzLm5vZGUgPT09IGRvY3VtZW50LmJvZHkpLFxuICAgICAgICBwYXJlbnQ7XG4gICAgICBpZiAoIXJldCkge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLm5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKCFyZXQgJiYgcGFyZW50KSB7XG4gICAgICAgICAgaWYgKHBhcmVudC5iYXNlICYmIHBhcmVudC5fcmVuZGVyZWQpIHtcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwYXJlbnQgPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHRoaXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG4gIGNyZWF0ZVNjcm9sbCgnTGVmdCcpLFxuICBjcmVhdGVTY3JvbGwoJ1RvcCcpLFxuICB7XG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJz8/Pz8/Jyx2YWwuY3NzLnZhbClcbiAgICAgIC8vIGlmICghdmFsLmNzcykgeyAvL2NoZWNrIHdoZW4gaWdub3JpbmcgdGhpcyBiZWNvbWVzIGEgcHJvYmxlbVxuICAgICAgICB0aGlzLm5vZGUuc3R5bGUucG9zaXRpb24gPSB2YWwudmFsO1xuICAgICAgLy8gfVxuICAgIH0sXG4gICAgLy8gc2Nyb2xsVG9wOmZ1bmN0aW9uKHZhbCkge1xuICAgIC8vICAgY29uc29sZS5lcnJvcih2YWwudmFsKVxuICAgIC8vICAgdGhpcy5ub2RlLnNjcm9sbFRvcCA9IHZhbC52YWxcbiAgICAvLyB9LFxuICAgIHJvdGF0ZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSh2YWwpO1xuICAgIH0sXG4gICAgcm90YXRlWTogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSh2YWwpO1xuICAgIH0sXG4gICAgcm90YXRlWDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSh2YWwpO1xuICAgIH0sXG4gICAgc2NhbGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUodmFsKTtcbiAgICB9LFxuICAgIHNyYzogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgdiA9IHZhbC52YWw7XG4gICAgICBpZiAodiAmJiB2W3YubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgICAgICB0aGlzLm5vZGUuc3JjID0gdjtcbiAgICAgIH1cbiAgICB9LFxuICAgIGF0dHI6ZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgdCA9IHRoaXNcbiAgICAgIHZhbC5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgdC5ub2RlLnNldEF0dHJpYnV0ZShpLHRoaXMudmFsKVxuICAgICAgfSlcbiAgICB9LFxuICAgIGJhY2tncm91bmRQb3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IHZhbC52YWxcbiAgICB9LFxuICAgIGJhY2tncm91bmRCYXRjaDogZnVuY3Rpb24odmFsKSB7XG5cblxuICAgIH0sXG4gICAgYmFja2dyb3VuZDogZnVuY3Rpb24odmFsKSB7IC8vb3B0aW9uYWwgbWF5YmUgaW4gYSBzZXBlcmF0ZSBtb2R1bGVcbiAgICAgIHZhciB2ID0gdmFsLnZhbFxuICAgICAgICAsIHQgPSB0aGlzXG4gICAgICAgICwgc3R5bGUgPSB0aGlzLm5vZGUuc3R5bGVcbiAgICAgICAgLCB1cmxcbiAgICAgICAgLCBoYXNoZWRcbiAgICAgICAgLCBwYXJlbnRCYXRjaFxuICAgICAgICAsIGJhdGNoXG5cbiAgICAgIGlmKHZhbC5nb25lICYmIHZhbC5nb25lLnZhbCkge1xuICAgICAgICB2YWwuX3NraXAgPSB0cnVlXG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRJbWFnZSA9ICcnXG4gICAgICB9IGVsc2UgaWYgKHYgJiYgdlt2Lmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgdXJsID0gJ3VybCgnICsgdiArICcpJ1xuICAgICAgICBpZihzdHlsZS5iYWNrZ3JvdW5kSW1hZ2U9PT11cmwpIHJldHVyblxuXG4gICAgICAgIC8vVmFsdWVcbiAgICAgICAgaWYgKHZhbC5zaXplKSBzdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IHZhbC5zaXplLnZhbFxuXG4gICAgICAgIGlmICh2YWwubG9hZCkge1xuXG4gICAgICAgICAgaGFzaGVkID0gaGFzaCh2KVxuICAgICAgICAgIHBhcmVudEJhdGNoID0gdGhpcy5jaGVja1BhcmVudCgnYmFja2dyb3VuZEJhdGNoJylcbiAgICAgICAgICBpZihwYXJlbnRCYXRjaCkgYmF0Y2ggPSBwYXJlbnRCYXRjaC5iYWNrZ3JvdW5kQmF0Y2hcblxuICAgICAgICAgIGlmKCFfbG9hZFtoYXNoZWRdKSB7XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWQgPSBudWxsXG4gICAgICAgICAgICAvL2Fsc28gcmVtb3ZlIHNldHRpbmdcblxuICAgICAgICAgICAgaWYoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGJhdGNoLl9yYWYpXG4gICAgICAgICAgICAgIGlmKCFiYXRjaC5iYXRjaCkgYmF0Y2guYmF0Y2ggPSBbXVxuICAgICAgICAgICAgICBiYXRjaC5iYXRjaC5wdXNoKGhhc2gpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9sb2FkW2hhc2hlZF09bmV3IFZhbHVlKGZhbHNlKVxuICAgICAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpXG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICBpZihiYXRjaCkge1xuICAgICAgICAgICAgICAgYmF0Y2guYmF0Y2guc3BsaWNlKHV0aWwuY2hlY2tBcnJheShiYXRjaC5iYXRjaCxoYXNoZWQpLDEpXG4gICAgICAgICAgICAgICBpZihiYXRjaC5iYXRjaC5sZW5ndGg9PT0wKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2guYmF0Y2ggPSBudWxsXG4gICAgICAgICAgICAgICAgYmF0Y2guX3JhZiA9IHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmKHBhcmVudEJhdGNoLl9ub2RlKSBiYXRjaC5fdmFsLmNhbGwocGFyZW50QmF0Y2gpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2xvYWRbaGFzaGVkXS52YWwgPSB0cnVlXG4gICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBudWxsXG4gICAgICAgICAgICAgIGltZyA9IG51bGxcbiAgICAgICAgICAgICAgX2xvYWRbaGFzaGVkXS5yZW1vdmUoZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSlcbiAgICAgICAgICAgICAgX2xvYWRbaGFzaGVkXSA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGltZy5zcmMgPSB2XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoX2xvYWRbaGFzaGVkXSE9PXRydWUpIHtcbiAgICAgICAgICAgICB0aGlzLl9sb2FkZWQgPSBudWxsXG5cbiAgICAgICAgICAgIF9sb2FkW2hhc2hlZF0uYWRkTGlzdGVuZXIoW2Z1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZih2YWwubG9hZCAmJiB2YWwubG9hZC52YWwhPT10cnVlKSB2YWwubG9hZC5fdmFsLmNhbGwodGhpcywgdCk7XG4gICAgICAgICAgICB9LHZhbC5fYmFzZV0sIHRydWUpXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZVxuXG4gICAgICAgICAgICBpZihiYXRjaCkge1xuICAgICAgICAgICAgICBpZigoIWJhdGNoLmJhdGNoKSB8fCBiYXRjaC5iYXRjaC5sZW5ndGg9PT0wKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2guYmF0Y2ggPSBudWxsXG4gICAgICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGJhdGNoLl9yYWYpXG4gICAgICAgICAgICAgICAgYmF0Y2guX3JhZiA9IHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICBpZihwYXJlbnRCYXRjaC5fbm9kZSkgYmF0Y2guX3ZhbC5jYWxsKHBhcmVudEJhdGNoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYodmFsLmxvYWQudmFsIT09dHJ1ZSkgdmFsLmxvYWQuX3ZhbC5jYWxsKHRoaXMsIHQpO1xuXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gdXJsXG5cbiAgICAgIH1cbiAgICB9LFxuICAgIHBhZGRpbmc6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLnBhZGRpbmcgPSB2YWwudmFsICsgJ3B4JztcbiAgICB9LFxuICAgIHk6IF9jb29yZGluYXRlKCd0b3AnKSxcbiAgICB4OiBfY29vcmRpbmF0ZSgnbGVmdCcpLFxuICAgIGRpc3BsYXk6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy5ub2RlLnN0eWxlLmRpc3BsYXkgPSB2YWwudmFsO1xuICAgIH0sXG4gICAgdzogZnVuY3Rpb24odmFsKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygndycpO1xuICAgICAgdmFyIHYgPSB2YWwudmFsXG4gICAgICB0aGlzLm5vZGUuc3R5bGUud2lkdGggPSAodiA+IC0xID8gKHYgfCAwKSAgKyAncHgnIDogdiApIHx8ICcxMDAlJyBcbiAgICB9LFxuICAgIGg6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy8gdmFyIHYgPSB2YWwudmFsIHwgMCB0eXBvIG9yIGJ1Zz9cbiAgICAgIHZhciB2ID0gdmFsLnZhbFxuICAgICAgdGhpcy5ub2RlLnN0eWxlLmhlaWdodCA9ICh2ID4gLTEgPyAodiB8IDApICArICdweCcgOiB2ICkgfHwgJzEwMCUnXG4gICAgfSxcbiAgICBvcGFjaXR5OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciB2ID0gdmFsLnZhbDtcbiAgICAgIGlmKHY9PT1mYWxzZSkgdGhpcy5ub2RlLnN0eWxlLm9wYWNpdHkgPSBudWxsXG4gICAgICBlbHNlIHRoaXMubm9kZS5zdHlsZS5vcGFjaXR5ID0gdiA+IC0xID8gdiA6IDE7XG4gICAgfSxcbiAgICBodG1sOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciB2ID0gdmFsLnZhbCB8fCAnJ1xuICAgICAgaWYoIHYucmVwbGFjZSApXG4gICAgICB7XG4gICAgICAgIC8vYWRkIHNvbWUgaW5qZWN0aW9uIHByZXZlbnRpb24gYXMgb3B0aW9uPyAobm8gc2NyaXB0IGV0YylcbiAgICAgICAgdiA9IHYucmVwbGFjZSgvXFx0L2csICcgICAgJylcbiAgICAgICAgICAgICAucmVwbGFjZSgvXFxyXFxufFxcbnxcXHIvZywgJzxici8+JylcbiAgICAgICAgICAgICAucmVwbGFjZSgvICAvZywgJyZuYnNwOyAnKVxuICAgICAgICAgICAgIC5yZXBsYWNlKC8gIC9nLCAnICZuYnNwOycpIC8vIHNlY29uZCBwYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlcyBvZGQgbnVtYmVyIG9mIHNwYWNlcywgd2hlcmUgd2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbmQgdXAgd2l0aCBcIiZuYnNwO1wiICsgXCIgXCIgKyBcIiBcIlxuICAgICAgICB0aGlzLm5vZGUuaW5uZXJIVE1MID0gdlxuICAgICAgfVxuXG4gICAgfSxcbiAgICBocmVmOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMubm9kZS5ocmVmID0gdmFsLnZhbDtcbiAgICB9LFxuICAgIHRleHQ6IGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnU0VUVElORyBURVhUJy5ncmVlbi5pbnZlcnNlLiB2YWwudmFsLCB2YWwpXG5cbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlXG4gICAgICAgICwgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXNcbiAgICAgICAgLCB2ID0gdmFsLnZhbCB8fCB2YWwudmFsID09PSAwID8gdmFsLnZhbCA6ICcnXG5cbiAgICAgIGlmKHYgaW5zdGFuY2VvZiBPYmplY3QpIHYgPSAnJ1xuXG4gICAgICBpZiAoL3RleHQvLnRlc3Qobm9kZS50eXBlKSkge1xuICAgICAgICBub2RlLnZhbHVlID0gdjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAobm9kZXNbaV0ubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdCTEFCTEEnLmludmVyc2UsdilcbiAgICAgICAgICAgIG5vZGVzW2ldLm5vZGVWYWx1ZSA9IHY7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHYpKTtcbiAgICB9LFxuICAgICR0aW1lb3V0OiBmdW5jdGlvbiggdmFsICkge1xuICAgICAgaWYoc2V0VGltZXJzID09PSB2b2lkIDApe1xuICAgICAgICBzZXRUaW1lcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAgICAgdmFyIHRpbWVvdXQgPSB0aGlzLiR0aW1lb3V0XG4gICAgICAgICAgaWYoIHRpbWVvdXQgKSB7XG4gICAgICAgICAgICBpZihfc2V0VGltZW91dCA9PT0gdm9pZCAwKXtcbiAgICAgICAgICAgICAgX3NldFRpbWVvdXQgPSBmdW5jdGlvbiggX3RoaXMsIHRpbWVvdXQsIGtleXMsIGkgKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBrZXlzWyBpIF0gLSAoIGtleXNbIGkgLSAxIF0gfHwgMCApXG4gICAgICAgICAgICAgICAgdmFyIGZuID0gdGltZW91dFsga2V5c1sgaSBdIF0uX3ZhbFxuICAgICAgICAgICAgICAgIGZuLmlkID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBmbi5pZCA9IG51bGxcbiAgICAgICAgICAgICAgICAgIGlmKCAhZm4uZG9uZSB8fCAhX3RoaXMuZG9uZSApIHtcbiAgICAgICAgICAgICAgICAgICAgZm4uY2FsbCggX3RoaXMgKVxuICAgICAgICAgICAgICAgICAgICBmbi5kb25lID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kb25lID0gbnVsbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYoIGtleXNbICsraSBdICkgX3NldFRpbWVvdXQoIF90aGlzLCB0aW1lb3V0LCBrZXlzLCBpIClcbiAgICAgICAgICAgICAgICB9LCB0aW1lIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9zZXRUaW1lb3V0KCBfdGhpcywgdGltZW91dCwgdGltZW91dC5rZXlzLCAwIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKCB0aGlzLnJlbmRlcmVkICkge1xuICAgICAgICBzZXRUaW1lcnMuY2FsbCggdGhpcyApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldFNldHRpbmcoIHtcbiAgICAgICAgICBuYW1lOiAnc2V0VGltZXJzJyxcbiAgICAgICAgICByZW5kZXI6IHNldFRpbWVyc1xuICAgICAgICB9IClcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTZXR0aW5nKCB7XG4gICAgICAgIG5hbWU6ICdyZW1vdmVUaW1lcnMnLFxuICAgICAgICByZW1vdmU6IHJlbW92ZVRpbWVycyB8fCAocmVtb3ZlVGltZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignLS0tLS0tLS1SRU1PVkUnLHRoaXMuX25vZGUpXG4gICAgICAgICAgdmFyIHRpbWVycyA9IHRoaXMuJHRpbWVvdXRcbiAgICAgICAgICBpZiggdGltZXJzICkge1xuICAgICAgICAgICAgdGltZXJzLmVhY2goIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgZm4gPSB0aGlzLl92YWxcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignLS0tLS0tLS0tcmVtb3ZpbmcnLGZuLGZuLmRvbmUpXG4gICAgICAgICAgICAgIGlmKCB0aGlzLmRvbmUgKSB0aGlzLmRvbmUgPSBudWxsXG4gICAgICAgICAgICAgIGlmKCBmbi5pZCApIGNsZWFyVGltZW91dCggZm4uaWQgKVxuICAgICAgICAgICAgICBpZiggZm4uZG9uZSApIGZuLmRvbmUgPSBudWxsXG4gICAgICAgICAgICB9IClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IClcbiAgICB9XG4gIH0pO1xufSk7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbihiYXNlKSB7XG4gIHZhciBwcm90byA9IGJhc2UuQ2xhc3MucHJvdG90eXBlXG4gICAgLCBhZGQgPSBwcm90by5hZGRcblxuICB1dGlsLmRlZmluZVxuICAoIHByb3RvXG4gICwgJ2FkZCdcbiAgLCAgZnVuY3Rpb24odmFsKSB7XG4gICAgICAgaWYoICF2YWwucHJvY2VzcyApXG4gICAgICAge1xuICAgICAgICAgIGFkZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICB9IGVsc2VcbiAgICAgICB7XG4gICAgICAgICAgdmFsLl9fdGVtcEFkZCA9IHV0aWwuYXJnKCBhcmd1bWVudHMgKVxuICAgICAgICAgIHZhbC5fX3RlbXBBZGQudW5zaGlmdCh0aGlzKVxuICAgICAgIH1cbiAgICAgfVxuICApXG5cbiAgYmFzZS5leHRlbmQoe1xuICAgIHByb2Nlc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgY29uc29sZS5sb2coJ3h4eHhfX194eHh4JylcbiAgICAgIGlmKHRoaXMuX190ZW1wQWRkICYmICF0aGlzLnBhcmVudCkge1xuICAgICAgICBhZGQuYXBwbHkodGhpcy5fX3RlbXBBZGRbMF0sIHRoaXMuX190ZW1wQWRkLnNsaWNlKDEpKVxuICAgICAgICB0aGlzLl9fdGVtcEFkZCA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbn0pXG5cbi8vcHJvY2VzcyB3b3JkdCBtaXNjaGllbiBtZWVyIGVlbiBvcGVyYXRvcj9cbi8vc29vcnQgZmllbGQgZWlnZW5saWprIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cycpXG4gICwgY2FzZXMgPSByZXF1aXJlKCcuLi8uLi9jYXNlcycpXG4gICwgdWEgPSByZXF1aXJlKCcuLi8uLi91YScpXG4gICwgZ2xvYmFsID0gZmFsc2VcbiAgLCBOT05FID0gJ25vbmUnXG4gICwgX2lvcyA9IHVhLnBsYXRmb3JtPT09J2lvcydcbiAgLCBfYW5kcm9pZCA9IHVhLnBsYXRmb3JtPT09J2FuZHJvaWQnXG4gICwgVklTSUJMRSA9ICd2aXNpYmxlJ1xuICAsIGV4dGVuZCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKS5leHRlbmRcbiAgLCBkb2MgPSBldmVudHMuZG9jdW1lbnRcbiAgLCB0aW1lclxuICAsIGZuXG5cbmlmKGNhc2VzLiRoYXNUb3VjaCl7XG5cbiAgZnVuY3Rpb24gYmx1ciAoZSl7XG4gICAgaWYoIWRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpe1xuICAgICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLCdibHVyJylcbiAgICB9ZWxzZSBpZihlLnRhcmdldC50YWdOYW1lIT09J0lOUFVUJyAmJiBlLnRhcmdldC50YWdOYW1lIT09J0ZPUk0nKXtcbiAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuYmx1cigpXG4gICAgICBkb2MucmVtb3ZlRXZlbnQoZmFsc2UsJ2JsdXInKVxuICAgIH1cbiAgfVxuXG4gIGV2ZW50cy5wcmV2ZW50RG93biA9IFxuICB7IHZhbDpcbiAgICB7IGRvd246ZnVuY3Rpb24oZSxtZXRob2QpIHtcbiAgICAgICAgaWYoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgZG9jLmFkZEV2ZW50KCd1cCcsYmx1ciwnYmx1cicpXG4gICAgICAgIGVsc2UgaWYoZS50YXJnZXQudGFnTmFtZSE9PSdJTlBVVCcgJiYgZS50YXJnZXQudGFnTmFtZSE9PSdGT1JNJyAmJiAhZXZlbnRzLl9tYXliZXNjcm9sbCkgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXZlbnRzLnNjcm9sbGJhciA9IFxuICB7IHZhbDogXG4gICAgeyBkb3duOmZ1bmN0aW9uKGUsbWV0aG9kLHZhbCkge1xuXG4gICAgICAgIHZhciBzY3JvbGxTdGFydFxuICAgICAgICAgICwgdCA9IHRoaXNcbiAgICAgICAgICAsIHNjcm9sbFN0clxuICAgICAgICAgICwgeEF4aXMgPSAodmFsLl92YWwgPT09ICd4JylcbiAgICAgICAgICAsIGF4aXNcbiAgICAgICAgICAsIG90aGVyYXhpc1xuICAgICAgICAgICwgbW92ZVxuICAgICAgICAgICwgZFxuICAgICAgICAgICwgYm90dG9tUHJldmVudFxuICAgICAgICAgIFxuICAgICAgICBpZih4QXhpcykge1xuICAgICAgICAgIGF4aXMgPSAneCdcbiAgICAgICAgICBvdGhlcmF4aXMgPSAneSdcbiAgICAgICAgICBzY3JvbGxTdHIgPSAnc2Nyb2xsTGVmdCdcbiAgICAgICAgICBkID0gdC5ub2RlLnNjcm9sbFdpZHRoIC0gdC5ub2RlLm9mZnNldFdpZHRoXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGF4aXMgPSAneSdcbiAgICAgICAgICBvdGhlcmF4aXMgPSAneCdcbiAgICAgICAgICBzY3JvbGxTdHIgPSAnc2Nyb2xsVG9wJ1xuICAgICAgICAgIGQgPSB0Lm5vZGUuc2Nyb2xsSGVpZ2h0IC0gdC5ub2RlLm9mZnNldEhlaWdodFxuICAgICAgICB9XG5cbiAgICAgICAgc2Nyb2xsU3RhcnQgPSB0Lm5vZGVbc2Nyb2xsU3RyXSAvLzw9PT09PT09PSBsZXNzIGVmZmljaWVudCBidXQgbW9yZSBwcmVkaWN0YWJsZSBmb3IgY29tcGVuc2F0aW9uXG5cbiAgICAgICAgaWYoZCA+IDApe1xuICAgICAgICAgIGV2ZW50c1theGlzXSA9IHRydWVcbiAgICAgICAgICBldmVudHMuX21heWJlc2Nyb2xsID0gdHJ1ZVxuICAgICAgICAgIGlmKCF4QXhpcyl7XG4gICAgICAgICAgICBpZiAoIXNjcm9sbFN0YXJ0KXtcbiAgICAgICAgICAgICAgc2Nyb2xsU3RhcnQgPSB0Lm5vZGVbc2Nyb2xsU3RyXSA9ICAxXG4gICAgICAgICAgICB9ZWxzZSBpZihzY3JvbGxTdGFydD09PWQpIHtcbiAgICAgICAgICAgICAgc2Nyb2xsU3RhcnQgPSB0Lm5vZGVbc2Nyb2xsU3RyXSA9IGQgLSAxXG4gICAgICAgICAgICB9ZWxzZSBpZihzY3JvbGxTdGFydCA+IGQpe1xuICAgICAgICAgICAgICBib3R0b21QcmV2ZW50ID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciB5ID0gZS55XG4gICAgICAgICAgICAsIHggPSBlLnhcbiAgICAgICAgICAgICwgbW92ZWlkID0gc2Nyb2xsU3RyICsgYXhpc1xuICAgICAgICAgIFxuICAgICAgICAgIGRvYy5hZGRFdmVudCgnbW92ZScsZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4LWUueClcbiAgICAgICAgICAgICAgLCBkWSA9IHktZS55XG4gICAgICAgICAgICAgICwgZHkgPSBNYXRoLmFicyhkWSlcblxuICAgICAgICAgICAgaWYoeEF4aXMpe1xuICAgICAgICAgICAgICBpZihkeSA+IGR4KXtcbiAgICAgICAgICAgICAgICBldmVudHNbYXhpc10gPSBmYWxzZVxuICAgICAgICAgICAgICAgIGlmKCFldmVudHNbb3RoZXJheGlzXSkgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBpZihkeCA+IGR5KXtcbiAgICAgICAgICAgICAgICBldmVudHNbYXhpc10gPSBmYWxzZVxuICAgICAgICAgICAgICAgIGlmKCFldmVudHNbb3RoZXJheGlzXSkgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYoYm90dG9tUHJldmVudCAmJiBkWSA+IDApe1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1vdmUgPSB0cnVlXG4gICAgICAgICAgICBibHVyKGUpXG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnQoZmFsc2UsbW92ZWlkKVxuICAgICAgICAgIH0sbW92ZWlkKVxuXG4gICAgICAgICAgZG9jLmFkZEV2ZW50KCd1cCcsZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIG1zID0gZXZlbnRzLl9tYXliZXNjcm9sbCwgbXNsLCBhcnJcblxuICAgICAgICAgICAgaWYoIW1vdmUpe1xuICAgICAgICAgICAgICB2YXIgc2NybGwgPSB0Lm5vZGVbc2Nyb2xsU3RyXVxuICAgICAgICAgICAgICBtb3ZlID0gIShzY3JsbCA9PT0gc2Nyb2xsU3RhcnQpIHx8IHNjcmxsIDwgMCB8fCAoIHNjcmxsID4gZCAmJiAhYm90dG9tUHJldmVudCApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFtb3ZlICYmICFldmVudHNbb3RoZXJheGlzXSAmJiAhZXZlbnRzLmNsaWNrLmJsb2NrICYmIG1zICYmIG1zLmxlbmd0aCl7XG4gICAgICAgICAgICAgIG1zbCA9IG1zLmxlbmd0aFxuICAgICAgICAgICAgICB3aGlsZShtc2wtLSkgaWYoIWUucHJldmVudCl7XG4gICAgICAgICAgICAgICAgYXJyID0gbXNbbXNsXVxuICAgICAgICAgICAgICAgIGFyclswXS5jYWxsKGFyclsxXSxlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCFldmVudHNbb3RoZXJheGlzXSB8fCBtb3ZlKSBldmVudHMuX21heWJlc2Nyb2xsID0gZmFsc2VcblxuICAgICAgICAgICAgZXZlbnRzW2F4aXNdID0gZmFsc2VcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSxzY3JvbGxTdHIpXG5cbiAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgPSAwXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0sc2Nyb2xsU3RyKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm4gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBcbiAgICB2YXIgc3R5bGUgPSB0aGlzLm5vZGUuc3R5bGVcblxuICAgIHN0eWxlLm92ZXJmbG93ID0gJ3Njcm9sbCdcbiAgICBzdHlsZS53ZWJraXRPdmVyZmxvd1Njcm9sbGluZyA9ICd0b3VjaCdcbiAgICBzdHlsZS5tc1RvdWNoQWN0aW9uID0gJ2F1dG8nXG4gICAgc3R5bGUudG91Y2hBY3Rpb24gPSAnYXV0bydcblxuICAgIGlmICh2YWwudmFsID09PSAneCcpIHtcbiAgICAgIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSAncGFuLXgnXG4gICAgICBzdHlsZS50b3VjaEFjdGlvbiA9ICdwYW4teCdcbiAgICAgIHN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nXG4gICAgICBzdHlsZS5vdmVyZmxvd1ggPSAnc2Nyb2xsJ1xuICAgIH1lbHNlIGlmICh2YWwudmFsID09PSAneScpIHtcbiAgICAgIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSAncGFuLXknXG4gICAgICBzdHlsZS50b3VjaEFjdGlvbiA9ICdwYW4teSdcbiAgICAgIHN0eWxlLm92ZXJmbG93WCA9ICdoaWRkZW4nXG4gICAgICBzdHlsZS5vdmVyZmxvd1kgPSAnc2Nyb2xsJ1xuICAgIH1cblxuICAgIHRoaXMuZXZlbnRzID0geyBzY3JvbGxiYXI6dmFsLnZhbCB9XG4gICAgaWYoIWdsb2JhbCkge1xuICAgICAgZ2xvYmFsID0gdHJ1ZVxuICAgICAgZG9jLmV2ZW50cyA9IHsgcHJldmVudERvd246dHJ1ZSB9XG4gICAgfVxuICB9XG5cbn1lbHNle1xuXG4gIGZuID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ251bnUgaGV5IScpXG5cbiAgICB2YXIgc3R5bGUgPSB0aGlzLm5vZGUuc3R5bGU7XG4gICAgc3R5bGUub3ZlcmZsb3cgPSAnYXV0byc7XG4gICAgc3R5bGUub3ZlcmZsb3dZID0gdmFsLnZhbCAhPT0gJ3gnID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcbiAgICBzdHlsZS5vdmVyZmxvd1ggPSB2YWwudmFsICE9PSAneScgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xuICB9XG5cbn1cblxuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQoZnVuY3Rpb24oYmFzZSkge1xuICBiYXNlLmV4dGVuZCh7IHNjcm9sbGJhcjpmbiB9KVxufSkgICIsInZhciB1YSA9IHJlcXVpcmUoJy4uLy4uL3VhJylcbiAgLCBfcHJlZml4ID0gJy0nK3VhLnByZWZpeC50b0xvd2VyQ2FzZSgpXG4gICwgX3RyYW5zZm9ybSA9IF9wcmVmaXggKyAnLXRyYW5zZm9ybSdcblxuZXhwb3J0cy5nZXRNYXRyaXggPSBmdW5jdGlvbihub2RlKSB7XG4gIGlmKG5vZGUuc3R5bGVbX3RyYW5zZm9ybV0pIHtcbiAgICB2YXIgYXJyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSwgbnVsbClcbiAgICAgIC5nZXRQcm9wZXJ0eVZhbHVlKF90cmFuc2Zvcm0pLnJlcGxhY2UoJ21hdHJpeCgnLCAnJykuc3BsaXQoJywnKVxuICAgIHJldHVybiBhcnJcbiAgfVxufVxuXG4vLyBleHBvcnRzLmhhc0NhbGMgPSBmdW5jdGlvbigpIHtcbi8vICAgdmFyIGR1bW15ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jylcbi8vICAgICAsIHByb3BzID0gWyBfcHJlZml4KyctY2FsYycsICdjYWxjJyBdXG4vLyAgICAgLCBpID0gcHJvcHMubGVuZ3RoXG4vLyAgIHdoaWxlKGktMSkge1xuLy8gICAgIGR1bW15LnN0eWxlLmNzc1RleHQgPSAnd2lkdGg6JyArIHByb3BzW2ktMV0gKyAnKDFweCk7J1xuLy8gICAgIGlmIChkdW1teS5zdHlsZS5sZW5ndGgpIHJldHVybiBwcm9wc1tpLTFdXG4vLyAgICAgaS0tXG4vLyAgIH1cbi8vIH0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgZWxlbWVudCA9IHJlcXVpcmUoJy4vJylcbiAgLCBvYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKVxuXG4vKipcbiAqIGZsYWdzXG4gKiBhZGQga2V5d29yZHMgdG8gc2V0IG9iamVjdHMgd2hpY2ggYXJlIGNoZWNrZWQgdXNpbmcgYSBmdW5jdGlvbiBpbiBmbGFnc1xuICogc2ltcGx5IGFkZCBmaWVsZHMgdG8gdGhlIHNldCBtb2R1bGVcbiAqL1xudmFyIGZsYWdzID0gZXhwb3J0c1xuICAvKipcbiAgICogX2ZsYWdcbiAgICogZnVuY3Rpb24gdGhhdCBjYWxscyBmbGFnIGZ1bmN0aW9ucyBvbiBlbGVtZW50LnNldC5mbGFnc1xuICAgKi9cbiAgLCBfZmxhZyA9IGZ1bmN0aW9uKG5hbWUsIHZhbCwgY29weSwgdG9wKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGZvciAodmFyIGkgaW4gZmxhZ3MpIHtcbiAgICAgICAgZiA9IGZsYWdzW2ldLmNhbGwodGhpcywgbmFtZSwgdmFsLCBjb3B5LCB0b3ApO1xuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG51dGlsLmRlZmluZShlbGVtZW50LFxuICAvKipcbiAgICogc2V0XG4gICAqIGFkZHMgY2hpbGRyZW4gZm9yIG5vbiBleGlzdGluZyBhdHRyaWJ1dGVzXG4gICAqIF9vcmlnaW5hbCBhcmUgb3JpZ2luYWwgdmFsdWVzIGNoYW5nZWQgYnkgY2FzZXMgYW5kIGV2ZW50c1xuICAgKiBpbnN0YW5jZXMgLSBhZGQgb3IgcmVtb3ZlIGNoaWxkcmVuIGZyb20gaW5zdGFuY2VzO1xuICAgKi9cbiAgJ19zZXQnLCBmdW5jdGlvbih2YWwsIGksIGluc3RhbmNlcykge1xuICAgIC8vdGhpc1xuICAgIGlmICghX2ZsYWcuY2FsbCh0aGlzLCBpLCB2YWxbaV0sIGluc3RhbmNlcywgdmFsKSkge1xuXG4gICAgICBpZiAoICF0aGlzLmlzUHJvcGVydHkoIGksIHZhbCApICkge1xuXG4gICAgICAgIGlmICh2YWxbaV0gaW5zdGFuY2VvZiBlbGVtZW50KSB7XG4gICAgICAgICAgdmFyIGJlZm9yZVxuICAgICAgICAgIGlmICh0aGlzW2ldKSB7XG4gICAgICAgICAgICBmb3IodmFyIGM9dGhpcy5ub2RlLmNoaWxkTm9kZXMsbm9kZSQ9MCxsZW49Yy5sZW5ndGg7bm9kZSQ8bGVuO25vZGUkKyspIHtcbiAgICAgICAgICAgICAgaWYoY1tub2RlJF09PT10aGlzW2ldLm5vZGUpIHtcbiAgICAgICAgICAgICAgICBiZWZvcmUgPSBjWyhub2RlJCsxKV1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tpXS5yZW1vdmUgJiYgdGhpc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9yZXBsYWNlIGVsZW1lbnQgaWYgaXRzIGFscmVhZHkgdGhlcmVcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKGFkZCwgaW5zdGFuY2VzLCB2YWxbaV0pXG4gICAgICAgICAgdmFyIGFkZCA9IGluc3RhbmNlcyA/IG5ldyB2YWxbaV0uQ2xhc3MgOiB2YWxbaV07XG4gICAgICAgICAgYWRkLm5hbWUgPSBpO1xuICAgICAgICAgIHRoaXMuYWRkKGFkZCwgYmVmb3JlKTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB0aGlzLmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgYWRkLkNsYXNzKCk7XG4gICAgICAgICAgICAgIGEuX25hbWUgPSBpO1xuICAgICAgICAgICAgICB0aGlzLmFkZChhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggdGhpc1tpXSBpbnN0YW5jZW9mIG9iamVjdCApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vVE9ETzogdG9yb3VnaCB0ZXN0aW5nXG4gICAgICAgICAgICB0aGlzW2ldLnZhbCA9IHZhbFtpXVxuICAgICAgICAgIH0gXG4gICAgICAgICAgZWxzZSBpZiggdmFsW2ldIGluc3RhbmNlb2Ygb2JqZWN0ICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdhcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gc2V0IHVzaW5nIGEgdk9iamVjdD8gbWF5YmUgcmVxdWlyZSBzb21lIHN0dWZmIChlLmcuIGRhdGEpJylcbiAgICAgICAgICAgIHRoaXNbaV0gPSB2YWxbaV1cbiAgICAgICAgICB9IFxuICAgICAgICAgIGVsc2UgaWYoIHRoaXNbaV0gaW5zdGFuY2VvZiBlbGVtZW50ICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYoIHZhbFtpXSApIHtcbiAgICAgICAgICAgICAgdGhpc1tpXS5zZXQodmFsW2ldLCBpbnN0YW5jZXMpXG4gICAgICAgICAgICB9IGVsc2UgaWYoIHZhbFtpXSA9PT0gZmFsc2UgKXtcbiAgICAgICAgICAgICAgaWYgKCBpbnN0YW5jZXMgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGhpc1tpXSkgdGhpc1tpXS5yZW1vdmUoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpc1tpXS5yZW1vdmUoKVxuICAgICAgICAgICAgICB0aGlzW2ldID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gXG4gICAgICAgICAgZWxzZSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZih2YWxbaV0gaW5zdGFuY2VvZiBPYmplY3QgKSB7XG4gICAgICAgICAgICAgIHZhciBhZGQgPSBuZXcgZWxlbWVudCgpLnNldCh2YWxbaV0sIGluc3RhbmNlcylcbiAgICAgICAgICAgICAgYWRkLm5hbWUgPSBpO1xuICAgICAgICAgICAgICB0aGlzLmFkZChhZGQpXG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZXMpXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2hJbnN0YW5jZSggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBhZGQuQ2xhc3MoKVxuICAgICAgICAgICAgICAgICAgYS5fbmFtZSA9IGlcbiAgICAgICAgICAgICAgICAgIHRoaXMuYWRkKGEpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIicgKyBpICsgJ1wiIGlzIG5vdCBhbiBleGlzdGluZyBwcm9wZXJ0eS4gXCInICsgdmFsW2ldICsgJ1wiIGlzIGEgcHJpbWl0aXZlLiBBZGRpbmcgYXMgcHJpbWl0aXZlLicgKVxuICAgICAgICAgICAgICB0aGlzW2ldID0gdmFsW2ldXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKHR5cGVvZiB0aGlzW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgaWYodmFsW2ldIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXNbaV0uYXBwbHkodGhpcyx2YWxbaV0pXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbaV0odmFsW2ldKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzW2ldID0gdmFsW2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vZHluYW1pYyBjaGFuZ2VzIHRvIHRoZSBfb3JpZ2luYWwgc2V0IG9iamVjdCBwb29sXG4gICAgICAvL2lmICghY29weSAmJiB0aGlzLl9vcmlnaW5hbCkge1xuICAgICAgLy90aGlzLl9vcmlnaW5hbFtpXSA9IHZhbFtpXTsgLy9jaGVjayBpZiBzdHVmZiAvdyBjbGFzc2VzIGlzIG5lc3NlY2FyeTtcbiAgICAgIC8vfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIGNvbnZlcnRcbiAgICogZm9yIGVhY2ggZmllbGRzIGluIHZhbCBjb252ZXJ0IGJhY2sgdG8gYSBzZXRPYmplY3Q7XG4gICAqL1xuICAnY29udmVydCcsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBzZXRPYmogPSB7fSxcbiAgICAgIGlzT2JqO1xuICAgIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgICBpc09iaiA9IHV0aWwuaXNPYmoodmFsW2ldKVxuICAgICAgaWYgKHRoaXNbaV0gaW5zdGFuY2VvZiBlbGVtZW50KSB7XG4gICAgICAgIHNldE9ialtpXSA9IGlzT2JqID8gdGhpc1tpXS5jb252ZXJ0KHZhbFtpXSkgOiB0aGlzW2ldXG4gICAgICB9IGVsc2UgaWYgKHRoaXNbaV0gaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgICAgc2V0T2JqW2ldID0gdGhpc1tpXS5jb252ZXJ0KGlzT2JqICYmIHZhbFtpXSlcbiAgICAgIH0gZWxzZSBpZiAodGhpc1tpXSA9PT0gdm9pZCAwIHx8ICh1dGlsLmxvb2t1cC5jYWxsKHRoaXMsIGkpICYmIHRoaXNbaV0gPT09IGZhbHNlKSkge1xuICAgICAgICBzZXRPYmpbaV0gPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0T2JqW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2V0T2JqXG4gIH0pIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuLy9kdXJhdGlvbiBpbiBhIFYuVmFsdWUgLS0+IHVwZGF0ZSBpZiBuZXNzZWNhcnk/XG52YXIgdWEgPSByZXF1aXJlKCcuLi8uLi91YScpXG4gICwgdmlkZW8gPSByZXF1aXJlKCcuLycpXG4gICwgcG9zdHBvbmUgPSByZXF1aXJlKCcuLi8uLi8uLi9icm93c2VyL2V2ZW50cy91dGlsJykucG9zdHBvbmVcbiAgLCBfd2luUGhvbmUgPSB1YS5wbGF0Zm9ybSA9PT0gJ3dpbmRvd3MnICYmIHVhLmRldmljZSA9PT0gJ3Bob25lJ1xuICAsIF9pb3MgPSB1YS5wbGF0Zm9ybSA9PT0gJ2lvcydcbiAgLCBfYW5kcm9pZCA9IHVhLnBsYXRmb3JtID09PSAnYW5kcm9pZCdcbiAgLCBfaW9zNyA9IF9pb3MgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5zcGxpdCgnT1MnKVsxXVsxXSA9PT0gJzcnIC8vIFRFTVAgRklYIFVOVElMIFdFIERPIFVBXG4gICwgX2NhbnBsYXkgPSAnY2FucGxheScvL19pb3M3ID8gJ2NhbnBsYXl0aHJvdWdoJyA6ICdjYW5wbGF5JyBcblxuZnVuY3Rpb24gY3JlYXRlTGlzdGVuZXIgKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50c1xuICAgICwgbCA9IGFyZ3MubGVuZ3RoXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgX3RoaXMgPSB0aGlzOyBpIDwgbDsgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoYXJnc1tpKytdXG4gICAgICAsIGZ1bmN0aW9uKGUpIHsgdHlwZS5fdmFsLmNhbGwoX3RoaXMsZSkgfSkpO1xuICB9XG5cbn1cblxuZnVuY3Rpb24gX2NhbnBsYXlMaXN0ZW5lciAoKSB7XG4gIGlmICggIXRoaXMuX2NhbnBsYXkgJiYgIV93aW5QaG9uZSApIHsgLy9sYXRlciB2ZXJzaW9ucyAoaWYgZml4ZWRpbiA5KVxuICAgIFxuICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICwgbm9kZSA9IHRoaXMubm9kZVxuICAgIFxuICAgIHRoaXMuX2NhbnBsYXkgPSB0cnVlXG4gICAgXG4gICAgLy8gaWYoX2lvcykgbm9kZS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcblxuICAgIGZ1bmN0aW9uIGNhblBsYXkoKSB7XG4gICAgICBpZiAoIF90aGlzLnRpbWUgKSB7XG4gICAgICAgIFxuICAgICAgICBpZiAoIV90aGlzLnRpbWUudmFsKSB0aGlzLl9maXJzdFQgPSB0cnVlXG4gICAgICAgICAgLy9maXhlcyBmb3IgcGhvbmVnYXAhIHdpbmRvd3Ntb2JpbGVcbiAgICAgICAgaWYgKF9hbmRyb2lkICYmIHVhLmJyb3dzZXIgIT09ICdjaHJvbWUnKSB7IFxuICAgICAgICAgIC8vYW5kIHNwZWNpYWwgYnJvd3NlciE7IGNoZWNrIGZpcmVmb3g7IC8vaWRlbnRpZnkgbW9yZSBicm93c2VycyB0aGF0IGRvIG5vdCBuZWVkIHRoaXMgY3JhcFxuICAgICAgICAgIHZhciB0cmllcyA9IDBcbiAgICAgICAgICBjbGVhckludGVydmFsKCBfdGhpcy5fdGltZUZpeEludGVydmFsIClcbiAgICAgICAgICBfdGhpcy5fdGltZUZpeEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy51cGRhdGVUaW1lKClcbiAgICAgICAgICAgIGlmICh0cmllcyA9PT0gMykge1xuICAgICAgICAgICAgICBfdGhpcy5fY2FucGxheSA9IG51bGxcbiAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfdGhpcy5fdGltZUZpeEludGVydmFsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLm5vZGUuZHVyYXRpb24gIT09IDEpIHsgLy9hbmRyb2lkIHNldHMgZHVyYXRpb24gdG8gMSBhcyBkZWZhdWx0IGluc3RlYWQgb2YgMFxuICAgICAgICAgICAgICB0cmllcysrXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5wbGF5aW5nKSBfdGhpcy5ub2RlLnBsYXkoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIDIwMClcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIGlmIChfdGhpcy50aW1lLnZhbCkge1xuICAgICAgICAgICAgaWYgKF9pb3M3KSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IF90aGlzLnVwZGF0ZVRpbWUoKSB9LCAwKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVGltZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLl9mb3JjZVRpbWUgPSB0cnVlIFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCBfaW9zICYmIHRoaXMucGxheWluZyApe1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBfdGhpcy50aW1lLnZhbCAqIF90aGlzLmR1cmF0aW9uLnZhbFxuICAgICAgICAgICAgZnVuY3Rpb24gdGltZXVwZGF0ZSgpe1xuICAgICAgICAgICAgICBpZih+fm5vZGUuY3VycmVudFRpbWUgPj0gfn50aW1lKXtcbiAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlKVxuICAgICAgICAgICAgICAgIGlmKF9pb3M3KXtcbiAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNhbnBsYXl0aHJvdWdoKCl7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGxheSgpXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJ1xuICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJyxjYW5wbGF5dGhyb3VnaClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLGNhbnBsYXl0aHJvdWdoKVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgbm9kZS5wbGF5KClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZSlcbiAgICAgICAgICAgIG5vZGUucGF1c2UoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLl9jYW5wbGF5ID0gbnVsbFxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKF9jYW5wbGF5LCBjYW5QbGF5KVxuICAgIH1cblxuICAgIHRoaXMuX2NhblBsYXkgPSBjYW5QbGF5XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKF9jYW5wbGF5LCBjYW5QbGF5KVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldFRpbWUgKHZhbCkge1xuICBpZiAodGhpcy5ub2RlLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLm5vZGUuY3VycmVudFRpbWUgPSB2YWxcbiAgICBpZiAoX2lvcykgdGhpcy5fY29ycmVjdFRpbWUgPSB2YWxcbiAgfSBlbHNlIHtcbiAgICBfY2FucGxheUxpc3RlbmVyLmNhbGwodGhpcylcbiAgfVxufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gIFxueyBwcm9ncmVzczoge1xuICAgIHNldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZW5kJywgKF90aGlzLl9wckVuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5jbGVhclByb2dyZXNzKClcbiAgICAgIH0pKVxuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5Jyx0aGlzLl9jYW5QbGF5KVxuICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZCcsIHRoaXMuX3ByRW5kKSAvL21heWJlIG5vIHBsYXkgYW5kIHBhdXNlITtcbiAgICB9XG4gIH1cbiwgYnVmZmVyOiBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgYnVmZmVyZWQgPSB0aGlzLm5vZGUgJiYgdGhpcy5ub2RlLmJ1ZmZlcmVkXG4gICAgaWYgKGJ1ZmZlcmVkKSB7XG4gICAgICB2YXIgbCA9IGJ1ZmZlcmVkLmxlbmd0aFxuICAgICAgICAsIHBpdiA9IC0xXG4gICAgICAgICwgdCA9IHRoaXMubm9kZS5jdXJyZW50VGltZSB8fCAwXG4gICAgICAgICwgbHNcbiAgICAgICAgLCB0dFxuICAgICAgICAsIGkgPSAwXG4gICAgICBcbiAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGxzID0gYnVmZmVyZWQuc3RhcnQoaSlcbiAgICAgICAgaWYgKGxzID4gcGl2ICYmIGxzIDwgdCkge1xuICAgICAgICAgIHBpdiA9IGlcbiAgICAgICAgICB0dCA9IGxzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBpdiA+IC0xKSB7XG4gICAgICAgIHBpdiA9IGJ1ZmZlcmVkLmVuZChwaXYpXG4gICAgICAgIHJldHVybiBwaXYgPCB0ID8gMCA6IHBpdiAvIHRoaXMuZHVyYXRpb24udmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9XG4sIHBsYXk6IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmKHRoaXMubm9kZSAmJiB0aGlzLm5vZGUucGF1c2UpIHtcbiAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgdGhpcy5ub2RlLnBsYXkoKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMubm9kZS5wYXVzZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG4sIHRpbWU6IFxuICAvL3Rlc3RzIGZvciBhbmRyb2lkICwgd2lucGhvbmUsIGZpcmVmb3hwaG9uZSAoc2Vla2luZyBvbiB3aW5waG9uZSBpcyBub3QgcG9zc2libGUgYW55d2F5cylcbiAgeyBzZXQgICAvL19pb3MgIHx8IF9hbmRyb2lkIC8vdWEuZGV2aWNlID09PSAncGhvbmUnIHx8IHVhLmRldmljZSA9PT0gJ3RhYmxldCdcbiAgICAgIC8vIHBvc3Rwb25lKHNldFRpbWUpXG4gICAgOiBzZXRUaW1lXG4gICwgZ2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciB0aW1lID0gdGhpcy5ub2RlICYmIHRoaXMubm9kZS5jdXJyZW50VGltZVxuICAgICAgaWYgKHRoaXMuX2NvcnJlY3RUaW1lKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb3JyZWN0VGltZSA+IHRpbWUgLSAyICYmIHRoaXMuX2NvcnJlY3RUaW1lIDwgdGltZSArIDIpIHsgLy98fCB0aGlzLmNudFxuICAgICAgICAgIHRpbWUgPSB0aGlzLl9jb3JyZWN0VGltZVxuICAgICAgICAgIGlmICghdGhpcy5jbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY250ID0gM1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY250IDwgMikge1xuICAgICAgICAgICAgdGhpcy5fY29ycmVjdFRpbWUgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy5fY250ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29ycmVjdFRpbWUrPTAuNSAvL3Nob3VsZCBiZSBpbnRlcnZhbCBvZiBwcm9ncmVzcyB1cGRhdGVzXG4gICAgICAgICAgICB0aGlzLl9jbnQtLVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aW1lID0gdGhpcy5fY29ycmVjdFRpbWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRpbWUgLyB0aGlzLmR1cmF0aW9uLnZhbCB8fCB2YWwudmFsXG4gICAgfVxuICB9XG4sIGR1cmF0aW9uOiBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVxuICAgIHJldHVybiBub2RlICYmIG5vZGUucmVhZHlTdGF0ZSA/IG5vZGUuZHVyYXRpb24gOiB2YWwgJiYgdmFsLnZhbFxuICB9XG4sIGF1dG9wbGF5OiBmdW5jdGlvbih2YWwpIHtcbiAgICBpZih0aGlzLm5vZGUpIHRoaXMubm9kZS5hdXRvcGxheSA9IHZhbC52YWxcbiAgfVxuLCBsb29wOiBmdW5jdGlvbih2YWwpIHtcbiAgICBpZih0aGlzLm5vZGUpIHRoaXMubm9kZS5sb29wID0gdmFsLnZhbFxuICB9XG4sIHZvbHVtZTogZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIHZvbHVtZSA9IHZhbC52YWxcbiAgICBpZih0aGlzLm5vZGUgJiYgIWlzTmFOKHZvbHVtZSkpIHRoaXMubm9kZS52b2x1bWUgPSB2b2x1bWVcbiAgfVxuXG4sIFwibmV3XCI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWRkRXZlbnQoJ2Rvd24nLGZ1bmN0aW9uKGUpeyBlLnByZXZlbnREZWZhdWx0KCkgfSlcbiAgICBfY2FucGxheUxpc3RlbmVyLmNhbGwodGhpcylcbiAgICBpZiAodGhpcy52b2x1bWUpIHRoaXMudm9sdW1lLnVwZGF0ZSh0aGlzKVxuICB9XG4sIGV2ZW50czoge1xuICAgIHBhdXNlOmZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgaWYoX2lvcyAmJiBfdGhpcy5ub2RlKSB7IFxuICAgICAgIF90aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICBpZighX3RoaXMuaWdub3JlZXZlbnRzKSBfdGhpcy5wYXVzZSgpICAgICBcbiAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgLCBwcm9ncmVzczogdmlkZW8ucHJvZ3Jlc3NcbiAgLCByZWFkeTogY3JlYXRlTGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJylcbiAgLCBjYW5wbGF5OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgIGlmKF90aGlzLm5vZGUpIF90aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihfY2FucGxheSwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZihfdGhpcy5ub2RlICYmIF90aGlzLm5vZGUucmVhZHlTdGF0ZT09PTQpIHtcbiAgICAgICAgICBfdGhpcy5fc3RhbGxlZCA9IGZhbHNlXG4gICAgICAgICAgdmFsLl92YWwuY2FsbChfdGhpcyxlKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgLCBzdGFsbGVkOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgLCBub2RlID0gdGhpcy5ub2RlXG4gICAgICAgICwgbGlzdGVuID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHZhciB0aW1lID0gX3RoaXMuZ2V0VGltZSgpXG4gICAgICAgICAgaWYoIShfdGhpcy5nZXRCdWZmZXIodGltZSktdGltZSA+IDAuMDUpKSB7XG4gICAgICAgICAgICBfdGhpcy5fc3RhbGxlZCA9IHRydWVcbiAgICAgICAgICAgIHZhbC5fdmFsLmNhbGwoX3RoaXMsZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIGlmKG5vZGUpe1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3N0YWxsZWQnLCBsaXN0ZW4gKVxuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3dhaXRpbmcnLCBsaXN0ZW4gKVxuICAgICAgfVxuICAgIH1cbiAgLCBwbGF5OiBcbiAgICB7IHBsYXk6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5ldmVudHMucGxheSkgdGhpcy5ldmVudHMucGxheS5fdmFsLmNhbGwodGhpcylcbiAgICAgIH1cbiAgICAsIHNldDogZmFsc2VcbiAgICB9XG4gICwgZW5kOiBjcmVhdGVMaXN0ZW5lcignZW5kZWQnKVxuICB9XG4sIHNyYzogZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIHNyYyA9IHRoaXMubm9kZS5zcmNcbiAgICBpZiAoc3JjICE9PSB2YWwgfHwgdmFsIHx8ICF2YWwgJiYgc3JjKSB0aGlzLm5vZGUuc3JjID0gdmFsLnZhbFxuICB9XG59XG5cbmlmICghdmlkZW8ucGxheWVyKSB2aWRlby5wbGF5ZXIgPSBtb2R1bGUuZXhwb3J0cyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuLi8nKVxuICAuaW5qZWN0XG4gICggcmVxdWlyZSgnLi4vcHJvcGVydGllcycpXG4gIClcblxuICAsIGV2ZW50cyA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKVxuICAsIHBvc3Rwb25lID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxuICAsIGJhc2UgPSBuZXcgZWxlbWVudCh7XG4gICAgICBub2RlOiAndmlkZW8nXG4gIH0pXG4gIFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gYmFzZS5DbGFzc1xudmFyIHZpZGVvID0gZXhwb3J0c1xuZXhwb3J0cy5iYXNlID0gYmFzZVxuXG5iYXNlLnNldFNldHRpbmcoXG57IG5hbWU6ICdfdmlkZW9TZXR0aW5ncydcbiwgbmV3OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIubmV3KSB0aGlzLnBsYXllci5uZXcuY2FsbCh0aGlzKVxuICB9XG4sIHJlbW92ZTpmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wbGF5ZXIucmVtb3ZlKSB0aGlzLnBsYXllci5yZW1vdmUuY2FsbCh0aGlzKVxuICB9XG4sIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICAgaWYgKHRoaXMucGxheWVyLnJlbmRlcikgdGhpcy5wbGF5ZXIucmVuZGVyLmNhbGwodGhpcylcbiAgfVxufSlcbi8vcHJveHkgYWRkZW4gLS0+IHNob3VsZCBiZSBhbiBleHRlbnNpb24gb24gc3JjXG5iYXNlLm5vZGUuc2V0QXR0cmlidXRlKCd3ZWJraXQtcGxheXNpbmxpbmUnLCAnJylcblxuLy9jbG91ZCBzaG9ydGVuIHRoZXNlIDMgZnVuY3Rpb25zXG5mdW5jdGlvbiBfdmlkRXZlbnRzICh2YWwpIHtcblxuICB0aGlzLl9yZWFkeUZvckV2ZW50cyA9IHRydWVcblxuLy8gICBjb25zb2xlLmxvZygnXFxuXFxuXFxuXFxuXFxublxcblxcblxcblNFVCBWSURFVkVOVFMnKVxuXG4gIHZhciB0ID0gdGhpc1xuICAgICwgZSA9ICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLmV2ZW50c1xuICB2YWwuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgaWYgKGVbaV0gJiYgZVtpXS5zZXQgIT09IGZhbHNlKSAoZVtpXS5zZXQgfHwgZVtpXSkuY2FsbCh0LCB0aGlzLCBpKVxuICB9KVxuICByZXR1cm4gZVxufVxuXG5mdW5jdGlvbiBfcmVtb3ZlVmlkRXZlbnRzICh2YWwpIHtcbiAgdmFyIHQgPSB0aGlzXG4gICAgLCBlID0gKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikuZXZlbnRzXG5cbiAgdmFsLmVhY2goZnVuY3Rpb24oaSkge1xuICAgIGlmIChlW2ldICYmIGVbaV0ucmVtb3ZlKSBlW2ldLnJlbW92ZS5jYWxsKHQsIHRoaXMsIGkpXG4gIH0pXG59XG5cbmZ1bmN0aW9uIF9wbGF5SG9vayAocGFyYW0pIHtcbiAgdmFyIHZhbCA9IHRoaXMuZXZlbnRzXG4gIGlmICh2YWwpIHtcbiAgICB2YXIgdCA9IHRoaXNcbiAgICAgICwgZSA9ICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLmV2ZW50c1xuICAgIHZhbC5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIGlmIChlW2ldICYmIGVbaV0ucGxheSkgZVtpXS5wbGF5LmNhbGwodCwgdGhpcywgaSwgcGFyYW0pXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBfcHJvZ3Jlc3ModmFsKSB7XG5cbiAgLy8gY29uc29sZS5lcnJvcignU0VUIHByb2dyZXNzJyx0aGlzLl9wcm9ncmVzcylcblxuICBpZiAoIXRoaXMuX3Byb2dyZXNzKSB7XG5cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1NFVCBwcm9ncmVzcyBmb3IgUkVBTCcsdGhpcy5fcHJvZ3Jlc3MpXG5cbiAgICAvL21heWJlIGRvIHRoaXMgd2l0aCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgLS0gZGFuZ2VyIGxpZXMgaW4gaW5jb3Npc3RlbmN5IHdpdGggdGltaW5nXG4gICAgdmFyIHBhcmFtcyA9IHZhbFxuICAgICAgLCBpbnRlcnZhbCA9IHBhcmFtcy5pbnRlcnZhbCAmJiBwYXJhbXMuaW50ZXJ2YWwudmFsIHx8IDUwMCBcbiAgICAgICwgZm4gPSBwYXJhbXMuX3ZhbFxuICAgICAgLCB0ID0gdGhpc1xuICAgICAgLCBwciA9ICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLnByb2dyZXNzXG5cbiAgICBpZiAocHIgJiYgcHIuc2V0KSBwci5zZXQuY2FsbCh0KVxuXG4gICAgdC5fcHJvZ3Jlc3MgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ2JlZm9yZSBwcm9ncmVzcyBjYWxsIScsdC5zcmMudmFsKVxuICAgICAgLy8gaWYodC5wbGF5aW5nJiYhdC5fX3BhdXNlZCkge1xuICAgICAgLy8gICAvLyB0LnBsYXkoKVxuICAgICAgLy8gICAvLyBubyBzcmMhXG4gICAgICAvLyB9XG5cbiAgICAgIHZhciBwID0gTnVtYmVyKHQuZ2V0VGltZSgpKVxuICAgICAgICAsIGIgPSB0LmdldEJ1ZmZlcihwKVxuICAgICAgICAsIGQgPSBOdW1iZXIodC5kdXJhdGlvbi52YWwpXG5cbiAgICAgIGlmKGQ9PT0xKSBkPTAgLy9hbmRyb2lkIGZpeCAtLSBtYXliZSByZW1vdmVcblxuICAgICAgaWYgKHAgPj0gMSAmJiBkKSB7XG4gICAgICAgIHQucGF1c2UoKVxuICAgICAgICB0LnBsYXlpbmcgPSBmYWxzZSAvL3Nob3VsZCB0aGlzIGJlIHJlbW92ZWQgYW4gZ28gdG8gZW5kPyBcbiAgICAgICAgLy9jYWxsIHBhdXNlIGFuZCBzZXQgdGltZSBpbiBoZXJlP1xuICAgICAgICB0LmNsZWFyUHJvZ3Jlc3MoKVxuICAgICAgfSBlbHNlIHtcblxuICAgICAgICBpZih0Ll9zdGFsbGVkICYmIGQpIHsgLy9qdXN0IHRvIG1ha2Ugc3VyZSBidWZmZXJpbmcgYWx3YXlzIGRpc3NhcGFlcnMgICAgXG4gICAgICAgICAgaWYoYj4wLjg1IHx8ICh0Ll9fbHAgJiYgdC5ldmVudHMuY2FucGxheSAmJiAocCA+IHQuX19scCsoMS9kKSkpKSB7IC8vaW4gc2Vjb25kc1xuICAgICAgICAgICAgdC5fc3RhbGxlZCA9IGZhbHNlXG4gICAgICAgICAgICB0LmV2ZW50cy5jYW5wbGF5Ll92YWwuY2FsbCh0KVxuICAgICAgICAgICAgdC5fX2xwID0gbnVsbFxuICAgICAgICAgIH0gZWxzZSBpZiggKCF0Ll9fbHApICYmIHA+LTEpIHtcbiAgICAgICAgICAgIHQuX19scCA9IHBcbiAgICAgICAgICB9IFxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIXQuaWdub3JlZXZlbnRzKSBmbi5jYWxsKHQsIHAsIGIpXG4gICAgICB9XG4gICAgfSwgaW50ZXJ2YWwpXG4gIH1cbn1cblxudGhpcy5fcHJvZ3Jlc3MgPSBfcHJvZ3Jlc3NcblxuZXhwb3J0cy5wcm9ncmVzcyA9IFxueyBwbGF5OiBmdW5jdGlvbihpLCBwLCBwYSkge1xuICAgIGlmIChwYSkge1xuICAgICAgX3Byb2dyZXNzLmNhbGwodGhpcywgdGhpcy5ldmVudHMucHJvZ3Jlc3MpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJQcm9ncmVzcygpXG4gICAgfVxuICB9XG4sIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKHRoaXMucGxheWluZykgX3Byb2dyZXNzLmNhbGwodGhpcywgdmFsKVxuICB9XG4sIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbGVhclByb2dyZXNzKClcbiAgfVxufVxuXG51dGlsLmRlZmluZShleHBvcnRzXG4sICdyZXN1bWVQbGF5JywgcG9zdHBvbmUoZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5ub2RlKSB7XG4gICAgICBpZih0aGlzLiRwbGF5aW5nLnZhbD09PXRydWUpIHtcbiAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNTZWVraW5nID0gbnVsbFxuICAgICAgLy8gY29uc29sZS5lcnJvcignUkVTVU1FIScpXG4gICAgfVxuICB9LDEwMDEpXG4sICdzZXRFdmVudHMnLCBmdW5jdGlvbigpIHtcbiAgICBfdmlkRXZlbnRzLmNhbGwodGhpcywgdGhpcy5ldmVudHMpXG4gIH1cbiwgJ3BsYXknLCBmdW5jdGlvbihjbGVhciwgaWdub3JlKSB7XG5cbiAgICBpZiAoY2xlYXIpIGRlbGV0ZSB0aGlzLmlnbm9yZWV2ZW50c1xuICAgIGlmICghaWdub3JlICYmICF0aGlzLmlnbm9yZWV2ZW50cyAmJiB0aGlzLnBsYXlpbmcgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZVxuICAgICAgICBfcGxheUhvb2suY2FsbCh0aGlzLCB0cnVlKVxuICAgIH0gZWxzZSBpZih0aGlzLl9fcGF1c2VkICYmIHRoaXMuZXZlbnRzLnByb2dyZXNzKSB7XG4gICAgICB0aGlzLnBsYXlpbmcgPSB0cnVlXG4gICAgICBfcHJvZ3Jlc3MuY2FsbCh0aGlzLHRoaXMuZXZlbnRzLnByb2dyZXNzKVxuICAgIH1cbiAgICB0aGlzLl9fcGF1c2VkID0gbnVsbFxuICAgIDsodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5wbGF5LmNhbGwodGhpcywgdHJ1ZSlcbiAgfVxuLCAncGF1c2UnLCBmdW5jdGlvbihpZ25vcmUpIHtcblxuICAgIGlmKGlnbm9yZSkgdGhpcy5pZ25vcmVldmVudHMgPSB0cnVlXG5cbiAgICBpZiAoIXRoaXMuaWdub3JlZXZlbnRzICYmIHRoaXMucGxheWluZyAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucGxheWluZyA9IGZhbHNlXG4gICAgICBfcGxheUhvb2suY2FsbCh0aGlzLCBmYWxzZSlcbiAgICAgIGlmKHRoaXMuZXZlbnRzLnBhdXNlKSB7XG4gICAgICAgIHRoaXMuZXZlbnRzLnBhdXNlLl92YWwuY2FsbCh0aGlzKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyUHJvZ3Jlc3MoKVxuICAgIH1cblxuICAgIHRoaXMuX19wYXVzZWQgPSB0cnVlXG4gICAgOyh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLnBsYXkuY2FsbCh0aGlzLCBmYWxzZSlcbiAgfVxuLCAndG9nZ2xlJywgZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKHRoaXMucGxheWluZykge1xuICAgICAgdGhpcy5wYXVzZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGxheSgpXG4gICAgfVxuICB9XG4sICd1cGRhdGVUaW1lJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZmlyc3RUID0gZmFsc2VcbiAgICBleHBvcnRzLnNldFRpbWUuY2FsbCh0aGlzLCB0aGlzLnRpbWUpXG4gIH1cbiwgJ2dldFRpbWUnLCBmdW5jdGlvbigpIHtcblxuICAgIC8vIGNvbnNvbGUuZXJyb3IodGhpcy5pc1NlZWtpbmcpXG5cbiAgICByZXR1cm4gdGhpcy5pc1NlZWtpbmcgXG4gICAgICB8fCAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLnBsYXllciBcbiAgICAgIHx8IHZpZGVvLnBsYXllcikudGltZS5nZXQuY2FsbCh0aGlzLCB0aGlzLnRpbWUpIFxuICAgICAgfHwgMFxuICB9XG4sICdnZXRCdWZmZXInLCBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gKHRoaXMucmVuZGVyZWQgJiYgdGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5idWZmZXIuY2FsbCh0aGlzLCB2YWwgfHwgMClcbiAgfVxuLCAnY2xlYXJQcm9ncmVzcycsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wcm9ncmVzcykge1xuICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSB0aGF0IHByb2dyZXNzJylcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcHJvZ3Jlc3MpXG4gICAgICB0aGlzLl9wcm9ncmVzcyA9IG51bGxcbiAgICAgIHZhciBwciA9ICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLnByb2dyZXNzXG4gICAgICBpZiAocHIgJiYgcHIucmVtb3ZlKSBwci5yZW1vdmUuY2FsbCh0aGlzKVxuICAgIH1cbiAgfVxuKVxuXG5iYXNlLmV4dGVuZChcbnsgbmFtZTogJ3BsYXllcidcbiwgdHlwZTogZmFsc2Vcbiwgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICB1dGlsLnNldHN0b3JlLmNhbGwodGhpcylcbiAgICB0aGlzLl9fLnBsYXllciA9IHZhbFxuICAgIGlmICh2YWwuZWxlbWVudCkgdGhpcy5ub2RlID0gdmFsLmVsZW1lbnRcbiAgICBpZiAodGhpcy5fY2xhc3MpIHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fLnBsYXllciA9IHZhbFxuICB9XG4sIGdldDogZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuIHV0aWwuZ2V0U3RvcmUuY2FsbCh0aGlzLCAncGxheWVyJykgfHwgdmlkZW8ucGxheWVyIHx8IHt9XG4gIH1cbn1cbiwgXG57IG5hbWU6ICdkdXJhdGlvbidcbiwgc2V0OiBmdW5jdGlvbih2YWwpIHt9XG4sIGdldDogZnVuY3Rpb24odmFsKSB7XG4gICAgdmFsLl9vdmVyd3JpdGUgPSAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5kdXJhdGlvbi5jYWxsKHRoaXMsIHZhbClcbiAgICByZXR1cm4gdmFsXG4gIH1cbn1cbixcbntcbiAgbmFtZTonJHBsYXlpbmcnXG4sIHNldDpmdW5jdGlvbiggdmFsICkge1xuICAgIC8vc3RhbXAgaW5mb1xuICAgIC8vIGlmKCB0aGlzLnJlbmRlcmVkICkgLy9UT0RPIGF2b2lkIGhlYXZ5IGNoZWNrXG4gICAgLy8ge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignISEhISEhISEhISFzZXQgJHBsYXlpbmcnLCB2YWwudmFsKVxuICAgICAgaWYoIHZhbC52YWwgKVxuICAgICAge1xuICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgIH1cbiAgICAvLyB9XG4gIH1cbn1cbiwgXG57IG5hbWU6ICd0aW1lJ1xuLCBzZXQ6IFxuICAoZXhwb3J0cy5zZXRUaW1lID0gZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKCF0aGlzLl9pZ25vcmUpIHtcblxuXG4gICAgICB2YWwuX292ZXJ3cml0ZSA9IG51bGxcbiAgICBcbiAgICAgIHZhciB2ID0gdmFsLnZhbFxuICAgICAgICAsIGkgPSBmYWxzZVxuXG4gICAgICBpZiAodiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGlmICghdGhpcy5fZmlyc3RUIHx8IHRoaXMuX2ZvcmNlVGltZSA9PT0gdHJ1ZSkgeyBcbiAgICAgICAgICB2ID0gTWF0aC5hYnModilcbiAgICAgICAgICBpID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLl9maXJzdFQgPSB0cnVlXG4gICAgICAgICAgdGhpcy5fZm9yY2VUaW1lID0gbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHYgPj0gMCkge1xuXG5cblxuICAgICAgICAgIGlmKHRoaXMuZHVyYXRpb24pe1xuICAgICAgICAgICAgdGhpcy5pc1NlZWtpbmcgPSB2XG5cbiAgICAgICAgICAgIC8vIGlmKHBsYXlpbmcpIHRoaXMucGF1c2UoKVxuXG4gICAgICAgICAgICBpZih0aGlzLl9fbHApIHRoaXMuX19scCA9IG51bGxcbiAgICAgICAgICAgIDsodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS50aW1lLnNldC5jYWxsKHRoaXMsIHYgKiB0aGlzLmR1cmF0aW9uLnZhbClcbiAgICAgICAgICAgIGlmKHRoaXMuZXZlbnRzLnNlZWtpbmcgJiYgIWkpICB0aGlzLmV2ZW50cy5zZWVraW5nLl92YWwuY2FsbCh0aGlzLHYpXG5cbiAgICAgICAgICAgIHRoaXMucmVzdW1lUGxheSgpXG5cbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2NhblxcJ3Qgc2V0IHRpbWUsIG5vIGR1cmF0aW9uIGRlZmluZWQhJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gIH0pXG59XG4sIFxueyBhdXRvcGxheTogZnVuY3Rpb24odmFsKSB7XG4gICAgKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikuYXV0b3BsYXkuY2FsbCh0aGlzLCB2YWwpXG4gIH1cbiwgbG9vcDogZnVuY3Rpb24odmFsKSB7XG4gICAgKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikubG9vcC5jYWxsKHRoaXMsIHZhbClcbiAgfVxuLCB2b2x1bWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLnZvbHVtZS5jYWxsKHRoaXMsIHZhbClcbiAgfVxuLCBzcmM6IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmKHZhbC52YWwhPT10aGlzLl9fX1NyYykge1xuICAgICAgdGhpcy5fX19TcmMgPSB2YWwudmFsXG4gICAgICBpZih0aGlzLmV2ZW50cy5zcmMpICB0aGlzLmV2ZW50cy5zcmMuX3ZhbC5jYWxsKHRoaXMsdmFsKVxuICAgICAgOyh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLnNyYy5jYWxsKHRoaXMsIHZhbClcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJyEhISEhISEhISEhc2V0IHNyYycpXG5cbiAgICAgIGlmKHRoaXMuJHBsYXlpbmcudmFsID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucGxheSgpXG4gICAgICB9XG5cbiAgICB9XG4gIH1cbn1cbiwgXG57IG5hbWU6ICdldmVudHMnXG4sIFwibmV3XCI6IGZ1bmN0aW9uKCkge1xuICAgIC8vZGV6ZSBmdW5jdGllIGt1bm5lbiBpbnN0ZWxsZW5cbiAgICBpZiggICh0aGlzLnBsYXllciAmJiB0aGlzLnBsYXllci5zZXRFdmVudHMgIT09IGZhbHNlKSkge1xuICAgICAgX3ZpZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuZXZlbnRzKVxuICAgIH1cbiAgfVxuLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMucmFmSWQpXG4gICAgeyBcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZklkKVxuICAgICAgdGhpcy5yYWZJZCA9IG51bGxcbiAgICB9XG4gICAgX3JlbW92ZVZpZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuZXZlbnRzKVxuICB9XG4sIHNldDogZnVuY3Rpb24odmFsKSB7XG4vLyAgIGNvbnNvbGUubG9nKCdFVkVOVFMhJylcbiAgICBcbiAgICB2YXIgYSA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICBcbiAgICAgIGFbNV0gPSB0aGlzLl9yZWFkeUZvckV2ZW50cyBcbiAgICAgICAgICAgPyBfdmlkRXZlbnRzLmNhbGwodGhpcywgdmFsKSBcbiAgICAgICAgICAgOiAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5ldmVudHMgXG5cbiAgICAgIGlmKCFhWzVdLnNlZWtpbmcpIGFbNV0uc2Vla2luZyA9IHtzZXQ6ZmFsc2V9XG4gICAgICBpZighYVs1XS5zcmMpIGFbNV0uc3JjID0ge3NldDpmYWxzZX1cbiAgICBcbiAgICBldmVudHMuX3NldC5hcHBseSh0aGlzLCBhKVxuICB9XG59KVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xuZXhwb3J0cy50aW1lID0gZnVuY3Rpb24odGltZSwgZGVjaW1hbHMpIHtcbiAgdmFyIGhycyA9IH5+ICh0aW1lIC8gMzYwMCksXG4gICAgbWlucyA9IH5+ICgodGltZSAlIDM2MDApIC8gNjApLFxuICAgIHNlY3MgPSBkZWNpbWFscyA/ICh0aW1lICUgNjApLnRvRml4ZWQoZGVjaW1hbHMpIDogfn4odGltZSAlIDYwKTtcbiAgcmV0ID0gXCJcIjtcbiAgaWYgKGhycyA+IDApIHJldCArPSBcIlwiICsgaHJzICsgXCI6XCIgKyAobWlucyA8IDEwID8gXCIwXCIgOiBcIlwiKTtcbiAgcmV0ICs9IFwiXCIgKyBtaW5zICsgXCI6XCIgKyAoc2VjcyA8IDEwID8gXCIwXCIgOiBcIlwiKTtcbiAgcmV0ICs9IFwiXCIgKyBzZWNzO1xuICByZXR1cm4gcmV0IHx8IDA7XG59OyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cbnZhciBldmVudHMgPSByZXF1aXJlKCcuLycpXG4gICwgb3BlcmF0b3JzID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUvb3BlcmF0b3JzJylcbiAgLCBkb2MgPSBldmVudHMuZG9jdW1lbnRcblxubW9kdWxlLmV4cG9ydHMgPSBldmVudHNcblxub3BlcmF0b3JzLl9lID0gZnVuY3Rpb24odmFsLCBvcGVyYXRvcikge1xuICByZXR1cm4gdmFsICsgb3BlcmF0b3Jcbn1cblxub3BlcmF0b3JzLl9lc3ViID0gZnVuY3Rpb24odmFsLCBvcGVyYXRvcikge1xuICByZXR1cm4gdmFsIC0gb3BlcmF0b3Jcbn1cblxub3BlcmF0b3JzLl9lLm9yZGVyID0gM1xuICBcbmZ1bmN0aW9uIGNob29zZU1vdmUgKHZhbCwgbWV0aG9kKSB7XG4gIHJldHVybiB2YWwubW92ZSAmJiB2YWwubW92ZS5fdmFsIFxuICAgIHx8ICFtZXRob2QuX190ICYmIG1ldGhvZCAhPT0gdHJ1ZSAmJiBtZXRob2QgXG4gICAgfHwgbWV0aG9kLl92YWw7XG59XG5cbmZ1bmN0aW9uIGRyYWcgKGUsIG1ldGhvZCwgdmFsKSB7XG4gIHZhciB0ID0gdmFsLmJpbmQgPyB2YWwuYmluZC5fdmFsIDogdGhpc1xuICAgICwgbW92ZSA9IGNob29zZU1vdmUodmFsLCBtZXRob2QpXG4gICAgLCBpZCA9ICdkcmFnJ1xuICBlLnByZXZlbnREZWZhdWx0KClcbiAgaWYgKG1vdmUpIGRvYy5hZGRFdmVudCgnbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICBtb3ZlLmNhbGwodCwgZSwgdmFsKVxuICB9LCBpZClcblxuICBpZiAodmFsLmRvd24pIHZhbC5kb3duLl92YWwuY2FsbCh0LCBlLCB2YWwpXG4gIFxuICBkb2MuYWRkRXZlbnQoJ3VwJywgZnVuY3Rpb24oZSkge1xuICAgIGlmICh2YWwudXApIHZhbC51cC5fdmFsLmNhbGwodCwgZSwgdmFsKVxuICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSwgaWQpXG4gIH0sIGlkKVxufVxuXG5mdW5jdGlvbiBhY3RpdmUgKGUsIG1ldGhvZCwgdmFsKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgaWQgPSAnYWN0aXZlJ1xuICAgICwgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYuY3NzID0ge2FkZENsYXNzOnZhbC5fdmFsfVxuICAgICAgICB0aW1lciA9IG51bGxcbiAgICAgIH0sNTApXG5cbiAgaWYoZXhwb3J0cy5fZGVhY3RpdmF0ZSkgZXhwb3J0cy5fZGVhY3RpdmF0ZSgpXG5cbiAgZXhwb3J0cy5fZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGltZXIpIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICBkb2MucmVtb3ZlRXZlbnQoZmFsc2UsaWQpXG4gICAgZXhwb3J0cy5fZGVhY3RpdmF0ZSA9IG51bGxcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICBpZighc2VsZikgcmV0dXJuXG4gICAgICBpZighc2VsZi5fc3RheUFjdGl2ZSkgc2VsZi5jc3MgPSB7cmVtb3ZlQ2xhc3M6dmFsLl92YWx9XG4gICAgICBlbHNlIHNlbGYuY3NzID0ge2FkZENsYXNzOnZhbC5fdmFsfVxuICAgIH0pXG4gIH1cblxuICBkb2MuYWRkRXZlbnQoJ21vdmUnLGV4cG9ydHMuX2RlYWN0aXZhdGUsaWQpXG4gIGRvYy5hZGRFdmVudCgndXAnLGV4cG9ydHMuX2RlYWN0aXZhdGUsaWQpXG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dSYXcgKHZvYmopIHtcbiAgdmFyIG9iaiA9IHt9XG4gICAgLCBrZXlzID0gdm9iai5rZXlzXG4gICAgLCBrZXlcbiAgICAsIGkgPSBrZXlzLmxlbmd0aCAtIDFcbiAgZm9yICg7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2V5c1tpXVxuICAgIG9ialtrZXldID0gdm9ialtrZXldXG4gIH1cbiAgcmV0dXJuIG9ialxufVxuXG5mdW5jdGlvbiBpbml0R3JhYiAodCwgZSwgdmFsLCBuYW1lKSB7XG4gIGlmICghdFtuYW1lXSB8fCAhdFtuYW1lXS5fZSkgdFtuYW1lXSA9IHsgX2U6IDAgfVxuICBpZiAodmFsW25hbWVdLl92YWwgIT09IHRydWUpIHRbbmFtZV0uc2V0KCdfZScsIHNoYWxsb3dSYXcodmFsW25hbWVdKSlcbiAgcmV0dXJuIGVbbmFtZV0gLSAodFtuYW1lXS5fZS52YWwpXG59XG5cbmZ1bmN0aW9uIGdyYWIgKGUsIG1ldGhvZCwgdmFsLCBuZXN0ZWQpIHtcbiAgdmFyIHQgPSB2YWwuYmluZCAmJiAhbmVzdGVkID8gdmFsLmJpbmQudmFsIDogdGhpc1xuICAgICwgaWQgPSAoIHZhbC55IFxuICAgICAgPyAneScgXG4gICAgICA6IHZhbC54IFxuICAgICAgICA/ICd4JyBcbiAgICAgICAgOiAneHknKSBcbiAgICAgICAgKyAnR3JhYicgXG4gICAgICAgICsgKG5lc3RlZCB8fCAnJylcbiAgaWYgKHQpIHtcbiAgICBpZiAodC5fbm9kZSkge1xuICAgICAgdmFyIG1vdmUgPSBjaG9vc2VNb3ZlKHZhbCwgbWV0aG9kKVxuICAgICAgICAsIHN0YXJ0WCA9IGUueFxuICAgICAgICAsIHN0YXJ0WSA9IGUueVxuICAgICAgICAsIHJlYWR5XG4gICAgICAgICwgY1hcbiAgICAgICAgLCBjWVxuICAgICAgICAsIG9sZFhcbiAgICAgICAgLCBvbGRZXG4gICAgICAgICwgbmV3WCA9IHN0YXJ0WFxuICAgICAgICAsIG5ld1kgPSBzdGFydFlcbiAgICAgICAgLCBwYXNzXG4gICAgICAgICwgdXBGbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHQueC5fcCA9IGZhbHNlXG4gICAgICAgICAgICB0LnkuX3AgPSBmYWxzZVxuICAgICAgICAgICAgaWYgKHZhbC51cCAmJiBwYXNzKSB7XG4gICAgICAgICAgICAgIHZhbC51cC5fdmFsLmNhbGwodCwgZSwge1xuICAgICAgICAgICAgICAgIHg6IG5ld1ggLSBzdGFydFgsXG4gICAgICAgICAgICAgICAgeTogbmV3WSAtIHN0YXJ0WVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7IHg6IG5ld1ggLSBvbGRYXG4gICAgICAgICAgICAgICwgeTogbmV3WSAtIG9sZFlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50cy5jbGljay5ibG9jayA9IGZhbHNlXG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnQoZmFsc2UsIGlkKVxuICAgICAgICAgIH1cbiAgICAgIGlmICghdmFsLnggJiYgIXZhbC55KXsgLy90aGlzIG5lZWRzIHJldmlzaW9uXG4gICAgICAgIHZhbC54ID0ge192YWw6IHRydWV9XG4gICAgICAgIHZhbC55ID0ge192YWw6IHRydWV9XG4gICAgICB9XG4gICAgICBpZiAodmFsLmRvd24pIHZhbC5kb3duLl92YWwuY2FsbCh0LCBlLCB2YWwpO1xuICAgICAgZG9jLmFkZEV2ZW50KCdtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBvbGRYID0gbmV3WFxuICAgICAgICBvbGRZID0gbmV3WVxuICAgICAgICBuZXdYID0gZS54XG4gICAgICAgIG5ld1kgPSBlLnlcblxuICAgICAgICBldmVudHMuY2xpY2suYmxvY2sgPSB0cnVlXG5cbiAgICAgICAgaWYgKCFyZWFkeSkge1xuICAgICAgICAgIHBhc3MgPSB2YWwucGFzcyA/IHZhbC5wYXNzLl92YWwuY2FsbCh0LCBlLCB7XG4gICAgICAgICAgICB4OiBuZXdYIC0gc3RhcnRYLFxuICAgICAgICAgICAgeTogbmV3WSAtIHN0YXJ0WVxuICAgICAgICAgIH0pIDogdHJ1ZVxuICAgICAgICAgIGlmKCFwYXNzKSB7XG4gICAgICAgICAgICB1cEZuKGUpXG4gICAgICAgICAgICBtb3ZlID0gZmFsc2VcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSwgaWQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgaWYgKHZhbC54KSB7XG4gICAgICAgICAgICAgIGNYID0gaW5pdEdyYWIodCwgZSwgdmFsLCAneCcpXG4gICAgICAgICAgICAgIHQueC5fcCA9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwueSkge1xuICAgICAgICAgICAgICBjWSA9IGluaXRHcmFiKHQsIGUsIHZhbCwgJ3knKVxuICAgICAgICAgICAgICB0LnkuX3AgPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnN0YXJ0KSB2YWwuc3RhcnQuX3ZhbC5jYWxsKHQsIGUsIHZhbClcbiAgICAgICAgICAgIHJlYWR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpIC8vZm9yIGFuZHJvaWRcbiAgICAgICAgICBpZiAoY1gpIHQueCA9IHsgX2U6IG5ld1ggLSBjWCB9XG4gICAgICAgICAgaWYgKGNZKSB0LnkgPSB7IF9lOiBuZXdZIC0gY1kgfVxuICAgICAgICAgIGlmIChtb3ZlKSBtb3ZlLmNhbGwodCwgZSwge1xuICAgICAgICAgICAgICB4OiBuZXdYIC0gc3RhcnRYLFxuICAgICAgICAgICAgICB5OiBuZXdZIC0gc3RhcnRZXG4gICAgICAgICAgICB9LHZhbCkgLy9jaGVjayBmb3Igc3BlZWRcbiAgICAgICAgfVxuICAgICAgfSwgaWQpXG4gICAgICBkb2MuYWRkRXZlbnQoJ3VwJywgdXBGbiwgaWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSB0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGdyYWIuY2FsbCh0W2ldLCBlLCBtZXRob2QsIHZhbCwgaSArIDEpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vL2FkZCB0aGUgZXZlbnRzXG5ldmVudHMuZHJhZyA9IHsgdmFsOiB7IGRvd246IGRyYWcgfSB9XG5ldmVudHMuZ3JhYiA9IHsgdmFsOiB7IGRvd246IGdyYWIgfSB9XG5ldmVudHMuYWN0aXZlID0geyB2YWw6IHsgZG93bjogYWN0aXZlIH0gfSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBldmVudHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJy4uL2Nhc2VzJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgdWEgPSByZXF1aXJlKCcuLi91YScpXG5cbmNhc2VzLiRoYXNUb3VjaCA9XG4oICggJ29udG91Y2hzdGFydCcgaW4gd2luZG93IClcbiAgfHwgd2luZG93LkRvY3VtZW50VG91Y2hcbiAgJiYgZG9jdW1lbnQgaW5zdGFuY2VvZiBEb2N1bWVudFRvdWNoXG4pXG58fCBuYXZpZ2F0b3IubXNNYXhUb3VjaFBvaW50c1xufHwgZmFsc2VcblxuZnVuY3Rpb24gX2Jhc2ljKGUsIG1ldGhvZCwgdmFsKSB7XG4gIGUueCA9IGUucGFnZVhcbiAgZS55ID0gZS5wYWdlWVxuICBtZXRob2QuY2FsbCh0aGlzLCBlLCB2YWwpXG59XG5cbnV0aWwuZGVmaW5lXG4oIGV2ZW50c1xuLCAnX291dCdcbiwgeyB2YWx1ZTogW10gfVxuKVxuLy9jbGlja291dCBjYW5ub3QgYmUgdXNlZCB0byBjcmVhdGUgY29tcGxleCBldmVudHMhIGl0J3MgdG9vIGN1c3RvbSBcbi8vdHJpZWQgdG8gZml4XG5cbmZ1bmN0aW9uIGtleUJvYXJkRXZlbnQoIG5hbWUsIGRvbUV2ZW50LCB3cmFwcGVyICkge1xuXG4gIHZhciBfbmFtZSA9ICdfJytuYW1lXG5cbiAgdXRpbC5kZWZpbmUoIGV2ZW50cywgX25hbWUsIHsgdmFsdWU6W10gfSApXG5cbiAgdmFyIGV2ZW50ID0gXG4gIHtcbiAgICBjcmVhdGU6IGZ1bmN0aW9uKCBmaWVsZCwgZnJvbSApIHtcbiAgICAgIHZhciBleGVjID0gZnVuY3Rpb24oIGUgKSB7XG5cbiAgICAgICAgLy9kaXQgZ2FhdCBoZWVsIHNuZWwgZm91dCBoaWVyb1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnbnUgZmYgb29rIGRlIHdyYXBwZXIgY2FsbGVuIScsIGZpZWxkLCBmcm9tLCBldmVudHNbZnJvbV0pXG4gICAgICAgICBpZiggdGhpcy5yZW5kZXJlZCApIHtcblxuICAgICAgICAgIGlmKCB3cmFwcGVyICkge1xuICAgICAgICAgICAgd3JhcHBlci5jYWxsKHRoaXMsIGUsIHRoaXMuZXZlbnRzW2Zyb21dLl92YWwgKVxuICAgICAgICAgICAgLy90aGlzLmV2ZW50c1tmcm9tXS5fdmFsLmNhbGwodGhpcywgZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiggZXZlbnRzW2Zyb21dICYmIGV2ZW50c1tmcm9tXS52YWwpIHtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSBldmVudHNbZnJvbV0udmFsXG4gICAgICAgICAgICBmb3IodmFyIGkgaW4gZXZlbnRzW2Zyb21dKSB7XG4gICAgICAgICAgICAgIGlmKCBjYXNlc1tpXSkge1xuICAgICAgICAgICAgICAgIG1ldGhvZCA9IGV2ZW50c1tmcm9tXVtpXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRob2QgPSBtZXRob2RbZmllbGRdXG4gICAgICAgICAgICBpZiggbWV0aG9kICkge1xuICAgICAgICAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBlLCB0aGlzLmV2ZW50c1tmcm9tXS5fdmFsIClcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgfSBlbHNlIGlmKCB0aGlzLmV2ZW50c1tmcm9tXSApIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2Zyb21dLl92YWwuY2FsbCh0aGlzLCBlKVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBldmVudHMuZG9jdW1lbnQuYWRkRXZlbnQoIGRvbUV2ZW50LCBmdW5jdGlvbihlKSB7XG5cbiAgICAgICAgZm9yICggdmFyIGFyciA9IGV2ZW50c1sgX25hbWUgXSwgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgICBleGVjLmNhbGwoIGFycltpXSwgZSApXG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIGFycltpXSApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnZG8gaXQgbm93IScsIF9uYW1lLCBhcnIsIGFycltpXSwgZSlcbiAgICAgICAgICAgIGFycltpXS5lYWNoSW5zdGFuY2UoIGV4ZWMsICdldmVudHMnLCBlIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSwgbmFtZSApXG4gICAgfSxcbiAgICBhZGQ6IGZ1bmN0aW9uKCBpZCwgZmllbGQgKSB7XG5cbiAgICAgIGZpZWxkID0gX25hbWVcblxuICAgICAgdGhpcy5zZXRTZXR0aW5nKFxuICAgICAgeyBuYW1lOiBmaWVsZFxuICAgICAgLCByZW1vdmU6IGV2ZW50c1sgbmFtZSBdLnJlbW92ZVxuICAgICAgfSlcblxuICAgICAgaWYgKCAhdXRpbC5jaGVja0FycmF5KCBldmVudHNbIF9uYW1lIF0sIHRoaXMgKSApIFxuICAgICAge1xuICAgICAgICBldmVudHNbIF9uYW1lIF0ucHVzaCh0aGlzKVxuICAgICAgfVxuXG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ1dST05HV1JPTkdXUk9ORyEhISEhJywgX25hbWUsIGV2ZW50c1tfbmFtZV0sIGV2ZW50cylcbiAgICAgIC8vc2VsZWN0ZWQgbW9ldCBtaXNjaGVpbiBhbGxlZW4gdmFudWl0IFZhbHVlICRmb2N1c2VkIC0tIG5pZXQgb3AgZWxrIGl0ZW0gb3Aga2V5IHVwLi4uLlxuICAgICAgLy9kb2UgZGl0IHNtYXJ0IC0tIGZvciBub3cgem91IGF1dG8gcmVtb3ZlIGt1bm5lbiBkb2VuIGFscyBpZXRzIGVyIG5pZXQgbWVlciBpcz9cbiAgICAgIHZhciBpbmRleCA9IHV0aWwuY2hlY2tBcnJheSggZXZlbnRzWyBfbmFtZSBdLCB0aGlzLCB0cnVlICkgXG4gICAgICBpZiggfmluZGV4ICkge1xuXG4gICAgICAgIHZhciBub1JlbW92ZVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd0aGlzOicsIHRoaXMgKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZnJvbSBiYXNlOicsIHRoaXMuX2Zyb20uYmFzZSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2V2ZW50IG5hbWU6JywgbmFtZSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2V2ZW50czonLCB0aGlzLmV2ZW50cyApXG4gICAgICAgIGlmKHRoaXMuZXZlbnRzICYmIHRoaXMuX2Zyb20uYmFzZS5ldmVudHMpIHsgXG4gICAgICAgICAgbm9SZW1vdmUgPSB0aGlzLmV2ZW50c1tuYW1lXSA9PT0gdGhpcy5fZnJvbS5iYXNlLmV2ZW50c1tuYW1lXVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdldmVudHMgZXF1YWxzIGNsYXNzOicsIG5vUmVtb3ZlIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdubyBuaWNlIGV2ZW50cycpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKCFub1JlbW92ZSkge1xuICAgICAgICAgIGV2ZW50c1sgX25hbWUgXS5zcGxpY2UoIGluZGV4LCAxIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhub1JlbW92ZSwgJ25vUmVtb3ZlIGV2bnQsIGFyZSB3ZSBzdXJlIC0gZml4IHRoaXMgYXNhcCcpXG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgLy8gdGhpcy5yZW1vdmVTZXR0aW5nKCBuYW1lICkgLS0tIHJlZG8gdGhpcyBsYXRlclxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV2ZW50c1sgbmFtZSBdID0gZXZlbnRcblxufVxuXG5ldmVudHMuJG1ha2VLZXlCb2FyZEV2ZW50ID0ga2V5Qm9hcmRFdmVudFxuXG5rZXlCb2FyZEV2ZW50KCAna2V5Ym9hcmQnLCAna2V5dXAnIClcbmtleUJvYXJkRXZlbnQoICdrZXlib2FyZERvd24nLCAna2V5ZG93bicgKVxua2V5Qm9hcmRFdmVudCggJ2tleWJvYXJkRG93biRkb3duJywgJ2tleWRvd24nIClcbmtleUJvYXJkRXZlbnQoICdrZXlib2FyZERvd24kY2xpY2snLCAna2V5ZG93bicgKVxuXG4vLy0tLS0tZGl0IGZmIGVjaHQgZ29lZCBmaXhlbiFcblxuZnVuY3Rpb24gYmFzaWNEb3duKGUsIG1ldGhvZCwgdmFsKSB7XG4gIGlmKCBlLndoaWNoIT09MSB8fCBldmVudHMuZG93bi5ibG9jayApIHJldHVyblxuICAgX2Jhc2ljLmNhbGwodGhpcyxlLCBtZXRob2QsIHZhbClcbn1cblxuZXZlbnRzLmRvd24gPVxueyAkaGFzVG91Y2g6XG4gIHsgdG91Y2hzdGFydDogZnVuY3Rpb24oZSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgIGlmKGV2ZW50cy5kb3duLmJsb2NrKSByZXR1cm5cbiAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gZS50YXJnZXRUb3VjaGVzWzBdIHx8IHt9XG4gICAgICBlLnggPSB0YXJnZXRUb3VjaGVzLnBhZ2VYXG4gICAgICBlLnkgPSB0YXJnZXRUb3VjaGVzLnBhZ2VZXG4gICAgICBtZXRob2QuY2FsbCh0aGlzLCBlLCB2YWwpXG4gICAgfVxuICB9XG4sIHZhbDogeyBtb3VzZWRvd246IGJhc2ljRG93biB9XG4vLyAsIHR2OiBcbi8vICAgeyAgLy8gbW91c2Vkb3duOiBiYXNpY0Rvd24gLy9jb21iaW5lcmVuIGJpbm5lbiBrb3J0IG1vZXQgdm9vciBMR1xuLy8gICAgICBrZXlib2FyZERvd24kZG93bjogZnVuY3Rpb24oIGUsIG1ldGhvZCwgdmFsICkge1xuLy8gICAgICAgLy90aGlzLl8kZm9jdXNlZCAmJiBcbi8vICAgICAgIGlmKCB0aGlzLl8kZm9jdXNlZCAmJiB1dGlsLmNoZWNrQXJyYXkoIFsgMTMsIDI5NDQzIF0gLCBlLmtleUNvZGUgKSAhPT0gZmFsc2UgKSBcbi8vICAgICAgIHtcbi8vICAgICAgICAgbWV0aG9kLmNhbGwodGhpcywgZSwgdmFsKVxuLy8gICAgICAgfVxuXG4vLyAgICAgfVxuLy8gICB9XG59XG5cbi8vcmlnaHQtZG93blxuZXZlbnRzLnJkb3duID1cbnsgJGhhc1RvdWNoOlxuICB7IHRvdWNoc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vMiBmaW5nZXJzP1xuICAgIH1cbiAgfVxuLCB2YWw6XG4gIHsgbW91c2Vkb3duOiBmdW5jdGlvbiAoZSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgIGlmKGUud2hpY2g9PT0zKSB7XG4gICAgICAgIGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIC8vIGUucmRvd24gPSB0cnVlXG4gICAgICAgIF9iYXNpYy5jYWxsKHRoaXMsZSxtZXRob2QsdmFsKVxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5vbmNvbnRleHRtZW51ID0gZmFsc2UgfSwgMClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy9tb3ZlXG5ldmVudHMubW92ZSA9IHtcbiAgJGhhc1RvdWNoOlxuICB7IHRvdWNobW92ZTogZnVuY3Rpb24gKGUsIG1ldGhvZCwgdmFsKSB7XG4gICAgICB2YXIgdGFyZ2V0VG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlc1swXVxuICAgICAgZS54ID0gdGFyZ2V0VG91Y2hlcy5wYWdlWFxuICAgICAgZS55ID0gdGFyZ2V0VG91Y2hlcy5wYWdlWVxuICAgICAgbWV0aG9kLmNhbGwodGhpcywgZSwgdmFsKVxuICAgICAgLy8gZG9jdW1lbnQud3JpdGUoZS50YXJnZXRUb3VjaGVzWzBdLnBhZ2VYKTtcbiAgICB9XG4gIH1cbiAgLCB2YWw6IHtcbiAgICBtb3VzZW1vdmU6IF9iYXNpY1xuICB9XG59XG5cbi8vdXBcbmV2ZW50cy51cCA9IHtcbiAgLy9rZXlVcFxuICAkaGFzVG91Y2g6IHtcbiAgICB0b3VjaGVuZDogZnVuY3Rpb24oZSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgIHZhciBjdCA9IGUuY2hhbmdlZFRvdWNoZXNcbiAgICAgIGUueCA9IGN0WzBdLnBhZ2VYXG4gICAgICBlLnkgPSBjdFswXS5wYWdlWVxuICAgICAgbWV0aG9kLmNhbGwodGhpcywgZSwgdmFsKVxuICAgIH1cbiAgfVxuLCB2YWw6IHtcbiAgICBtb3VzZXVwOiBfYmFzaWNcbiAgfVxufVxuXG4vL2NsaWNrXG5ldmVudHMuY2xpY2sgPSB7XG4gIC8vIHR2OiB7XG4gIC8vICAga2V5Ym9hcmREb3duJGNsaWNrOiBmdW5jdGlvbihlLCBtZXRob2QsIHZhbCApIHtcblxuICAvLyAgICAgaWYoIHRoaXMuXyRmb2N1c2VkICYmIHV0aWwuY2hlY2tBcnJheSggWyAxMywgMjk0NDMgXSAsIGUua2V5Q29kZSApICE9PSBmYWxzZSApIHtcbiAgLy8gICAgICAgbWV0aG9kLmNhbGwodGhpcywgZSwgdmFsKVxuICAvLyAgICAgfVxuXG4gIC8vICAgfVxuICAvLyB9LFxuICB2YWw6IHtcbiAgICBkb3duOiBmdW5jdGlvbihlLCBtZXRob2QsIHZhbCkge1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnQ0xJQ0sgSVQhJylcblxuICAgICAgdmFyIHQgPSB0aGlzXG4gICAgICAgICwgbmFtZSA9ICdjbGljaydcbiAgICAgIGlmKCFldmVudHMuY2xpY2suYmxvY2spe1xuICAgICAgICB0LmFkZEV2ZW50KCd1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB0LnJlbW92ZUV2ZW50KCd1cCcsIG5hbWUpXG4gICAgICAgICAgdmFyIG1zID0gZXZlbnRzLl9tYXliZXNjcm9sbFxuICAgICAgICAgIGlmKG1zKXtcbiAgICAgICAgICAgIGlmKG1zLmxlbmd0aCkgZXZlbnRzLl9tYXliZXNjcm9sbC51bnNoaWZ0KFttZXRob2QsdF0pXG4gICAgICAgICAgICBlbHNlIGV2ZW50cy5fbWF5YmVzY3JvbGwgPSBbW21ldGhvZCx0XV1cbiAgICAgICAgICB9ZWxzZSBpZighZXZlbnRzLmNsaWNrLmJsb2NrKSBtZXRob2QuY2FsbCh0LCBlLCB2YWwpXG4gICAgICAgIH0sIG5hbWUpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHQucmVtb3ZlRXZlbnQoJ3VwJywgbmFtZSlcbiAgICAgICAgfSwgMzAwKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5ldmVudHMucmNsaWNrID0ge1xuICB2YWw6IHtcbiAgICByZG93bjpldmVudHMuY2xpY2sudmFsLmRvd25cbiAgfVxufVxuXG52YXIgX291dFJlbW92ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmRleCA9IHV0aWwuY2hlY2tBcnJheShldmVudHMuX291dCwgdGhpcywgdHJ1ZSlcbiAgICBpZiAofmluZGV4KSB7XG4gICAgICBldmVudHMuX291dC5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICB0aGlzLnJlbW92ZVNldHRpbmcoJ19vdXQnLCBfb3V0U2V0dGluZylcblxuICAgICAgLy8gZGVidWdnZXJcblxuICAgIH1cbiAgfVxuLCBfb3V0U2V0dGluZyA9IHtcbiAgbmFtZTogJ19vdXQnLFxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdXRpbC5jaGVja0FycmF5KGV2ZW50cy5fb3V0LCB0aGlzKSkge1xuICAgICAgZXZlbnRzLl9vdXQucHVzaCh0aGlzKVxuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOiBfb3V0UmVtb3ZlXG59XG5cbmV2ZW50cy5vdXQgPSB7XG4gIGNyZWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5tID0gdHJ1ZTtcbiAgICBldmVudHMuZG9jdW1lbnQuYWRkRXZlbnQoJ3VwJywgZnVuY3Rpb24oZSkge1xuXG4gICAgICB2YXIgYmFzZSA9IGUudGFyZ2V0LFxuICAgICAgICBleGVjID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHAgPSBiYXNlXG4gICAgICAgICAgICAsIHRcbiAgICAgICAgICB3aGlsZSAocCAmJiAhdCkge1xuICAgICAgICAgICAgaWYgKHAuYmFzZSAmJiB0aGlzID09PSBwLmJhc2UpIHtcbiAgICAgICAgICAgICAgdCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwID0gcC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXQgJiYgdGhpcy5yZW5kZXJlZCkgdGhpcy5ldmVudHMub3V0Ll92YWwuY2FsbCh0aGlzLCBlKVxuICAgICAgICB9XG4gICAgICBmb3IgKHZhciBhcnIgPSBldmVudHMuX291dCwgaSA9IGFyci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBleGVjLmNhbGwoYXJyW2ldKVxuICAgICAgICBpZiAoYXJyW2ldKSBhcnJbaV0uZWFjaEluc3RhbmNlKGV4ZWMsICdldmVudHMnKVxuICAgICAgfVxuICAgIH0sJ291dCcpXG4gIH0sXG4gIGFkZDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSB0aGlzXG4gICAgIC8vIGV2ZW50cy5fb3V0LnB1c2godGhpcylcbiAgICB0aGlzLnNldFNldHRpbmcoX291dFNldHRpbmcpXG4gIH0sXG4gIHJlbW92ZTpfb3V0UmVtb3ZlXG59OyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi4vZWxlbWVudCcpXG4gICwgY2FzZXMgPSByZXF1aXJlKCcuLi9jYXNlcycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIEZpZWxkU3RvcmUgPSBmdW5jdGlvbiAoKSB7fVxuXG51dGlsLmRlZmluZShGaWVsZFN0b3JlLCAnX3VpZCcsIHsgdmFsdWU6IDAgfSlcblxuZXhwb3J0cy5fciA9IHt9IC8vbGlzdCBvZiBiYXNpYyAocmF3KSBldmVudHMgZS5nLiAnbW91c2Vkb3duJ1xuXG4vL3JlbW92ZSBldmVudHMgaWYgdGhlcmUgYXJlIG5vIGNoaWxkcmVuIHRoYXQgdXNlIHRoZW0gYW55bW9yZVxuXG5leHBvcnRzLmRvY3VtZW50ID0gbmV3IGVsZW1lbnQoeyBub2RlOiBkb2N1bWVudCB9KVxuXG5leHBvcnRzLmRvY3VtZW50LmV4ZWMgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG4gIGlmKCB0aGlzLl9fZVtldmVudF0gKVxuICB7XG4gICAgdmFyIGFyZ3MgPSB1dGlsLmFyZyggYXJndW1lbnRzLCAxIClcbiAgICBmb3IoIHZhciBpIGluIHRoaXMuX19lW2V2ZW50XSApXG4gICAge1xuICAgICAgdGhpcy5fX2VbZXZlbnRdW2ldLmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZSggaSwgZnJvbSApIHtcbiAgaWYoIGV4cG9ydHNbaV0gKVxuICB7XG4gICAgLy8gY29uc29sZS5sb2coJ2NvbXBsZXgnLCBpLCBmcm9tKVxuICAgIF9jcmVhdGVDb21wbGV4KCBpLCBmcm9tIClcbiAgfVxuICBlbHNlXG4gIHtcbiAgICAvLyBjb25zb2xlLmxvZygnX2Jhc2ljJywgaSlcblxuICAgIGV4cG9ydHNbaV0gPSB7IF9iYXNpYzogdHJ1ZSB9XG4gICAgX2NyZWF0ZUJhc2ljKCBpIClcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlV2hpbGUgKGksIG0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgcGFyZW50ID0gZS50YXJnZXRcbiAgICAgICwgYmFzZSwgZXZlbnRzXG4gICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgYmFzZSA9IHBhcmVudC5iYXNlXG4gICAgICBpZiAoYmFzZSkge1xuICAgICAgICBldmVudHMgPSBiYXNlLmV2ZW50c1xuICAgICAgICBpZiAoZXZlbnRzW2ldKSB7XG4gICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgIGV4cG9ydHNbaV0uX20uY2FsbChiYXNlLCBlLCBldmVudHNbaV0pXG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudHNbaV0uX3ZhbCkge1xuICAgICAgICAgICAgZXZlbnRzW2ldLl92YWwuY2FsbChiYXNlLCBlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZS5wcmV2ZW50KSByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBldmVudHMgPSBiYXNlLl9fZVxuICAgICAgICBpZiAoZXZlbnRzICYmIGV2ZW50c1tpXSkge1xuXG4gICAgICAgICAgZm9yICh2YXIgaiBpbiBldmVudHNbaV0pIHtcbiAgICAgICAgICAgIGlmKGohPT0nX3VpZCcpIHtcbiAgICAgICAgICAgICAgaWYgKG0pIHtcbiAgICAgICAgICAgICAgICBleHBvcnRzW2ldLl9tLmNhbGwoYmFzZSwgZSwgZXZlbnRzW2ldW2pdKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc/d2hhdCcsIGksIGosIGJhc2UsIGJhc2UuX25vZGUpXG4gICAgICAgICAgICAgICAgZXZlbnRzW2ldW2pdLmNhbGwoYmFzZSwgZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50KSByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVCYXNpYyAoaSwgcikge1xuICB2YXIgdHlwZSA9IGkgfHwgclxuXG4gIC8vIGNvbnNvbGUubG9nKCdjcmVhdGVCYXNpYycsIHR5cGUsaSlcblxuICBleHBvcnRzLl9yW2ldID0gdHJ1ZVxuICBpZih0eXBlID09PSAnc2Nyb2xsJykge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZnVuY3Rpb24oZSl7XG4gICAgICB2YXIgYmFzZSA9IGUudGFyZ2V0LmJhc2VcbiAgICAgICAgLCBldmVudHNcblxuICAgICAgaWYoYmFzZSkge1xuICAgICAgICBldmVudHMgPSBiYXNlLmV2ZW50c1xuICAgICAgICBpZihldmVudHMgJiYgZXZlbnRzW2ldKSBldmVudHNbaV0uX3ZhbC5jYWxsKGJhc2UsIGUpXG4gICAgICAgIGV2ZW50cyA9IGJhc2UuX19lXG4gICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzW2ldKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiBpbiBldmVudHNbaV0pIHtcbiAgICAgICAgICAgIGlmKGohPT0nX3VpZCcpIGV2ZW50c1tpXVtqXS5jYWxsKGJhc2UsIGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSx0cnVlKVxuICB9ZWxzZSBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIChleHBvcnRzW2ldLm0gPSBfY3JlYXRlV2hpbGUoaSkpKVxufVxuXG5mdW5jdGlvbiBfc2V0Q29tcGxleCAoIGksIG0sIHIsIGZyb20gKSB7XG4gIHZhciBtZXQgPSBleHBvcnRzW2ldLl9tID0gZnVuY3Rpb24gKGUsIHZhbCkge1xuICAgIGlmIChlLnByZXZlbnQpIHJldHVyblxuICAgIG0uY2FsbCh0aGlzLCBlLCAodmFsLl92YWwgfHwgdmFsLnZhbCB8fCB2YWwpLCB2YWwpXG4gIH1cbiAgZXhwb3J0c1tpXS5tID0gX2NyZWF0ZVdoaWxlKGksIHRydWUpXG4gIGV4cG9ydHMuX3JbaV0gPSB0cnVlXG4gIGlmIChleHBvcnRzW3JdKSB7XG4gICAgaWYgKCFleHBvcnRzW3JdLm0pIHtcbiAgICAgIF9jcmVhdGUociwgZnJvbSApXG4gICAgfVxuICAgIGlmICghZXhwb3J0c1tyXS5fYmFzaWMpIHtcbiAgICAgIGV4cG9ydHNbaV0uX19lID0gZXhwb3J0c1tyXS5fX2VcbiAgICAgIGV4cG9ydHNbaV0uX20gPSBmdW5jdGlvbiAoZSwgbSkge1xuICAgICAgICBleHBvcnRzW3JdLl9tLmNhbGwodGhpcywgZSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIG1ldC5jYWxsKHRoaXMsIGUsIG0pXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHNbaV0uX19lID0gclxuICAgIH1cbiAgfVxuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKChleHBvcnRzW3JdICYmIGV4cG9ydHNbcl0uX19lKSB8fCByLCBleHBvcnRzW2ldLm0pXG59XG5cbnZhciBhZGRXcmFwcGVyID0gZnVuY3Rpb24oIGFkZCwgZmllbGQsIG9yaWcgKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAvLyBjb25zb2xlLmxvZyggJ0FERCBXUkFQIScsIGZpZWxkLCBvcmlnICwgYXJndW1lbnRzIClcbiAgICByZXR1cm4gYWRkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ29tcGxleCggZmllbGQsIGZyb20gKSB7XG5cbiAgLy8gY29uc29sZS5sb2coJ19jcmVhdGVDb21wbGV4JyAsZmllbGQsIGZyb20gKVxuXG4gIGlmKCBleHBvcnRzW2ZpZWxkXS5jcmVhdGUgKSBleHBvcnRzW2ZpZWxkXS5jcmVhdGUoIGZpZWxkLCBmcm9tKVxuICB2YXIgbVxuICAgICwgaVxuICAgICwgalxuICBmb3IgKCBpIGluIGV4cG9ydHNbZmllbGRdICkge1xuICAgIGlmIChjYXNlc1tpXSA9PT0gdHJ1ZSkgbSA9IGV4cG9ydHNbZmllbGRdW2ldXG4gIH1cbiAgaWYgKCBtIHx8ICggbSA9IGV4cG9ydHNbZmllbGRdLnZhbCApICkge1xuICAgIGZvciAoaiBpbiBtKSAvL29ubHkgb25lXG4gICAgO2V4cG9ydHNbZmllbGRdLl9fZSA9IGpcblxuICAgIGlmIChtW2pdID09PSB0cnVlKSBcbiAgICB7XG4gICAgICBleHBvcnRzW2ZpZWxkXS5fYmFzaWMgPSB0cnVlXG4gICAgICBfY3JlYXRlQmFzaWMoZmllbGQsIGopXG4gICAgfSBcbiAgICBlbHNlIFxuICAgIHtcbiAgICAgIC8vYmFzaWMgZW4gbm9uIGJhc2ljIGlqbiBuaWV0IHRlIGNvbWJpbmVyZW4gLS0gY29tYmluZXJlbiBub2cga2Fwb3RcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXQgY29tcGxleCBmaWVsZCcsIGZpZWxkLCBtLCBqLCAgZXhwb3J0c1tqXSkgXG4gICAgICAvLyEhIXRyaXBwbGUgY2hlY2sgZGl0ISEhXG4gICAgICAgZm9yKCBqIGluIG0gKSBcbiAgICAgICB7IFxuICAgICAgICBpZiggZXhwb3J0c1tqXSAmJiBleHBvcnRzW2pdLmFkZCBcbiAgICAgICAgICYmIGV4cG9ydHNbZmllbGRdICYmICFleHBvcnRzW2ZpZWxkXS5hZGRcbiAgICAgICAgKSBcbiAgICAgICAge1xuICAgICAgICAgIGV4cG9ydHNbZmllbGRdLmFkZCA9IGFkZFdyYXBwZXIoIGV4cG9ydHNbal0uYWRkLCBmaWVsZCwgaiApXG4gICAgICAgIH1cbiAgICAgICAgX3NldENvbXBsZXgoZmllbGQsIG1bal0sIGosIGZyb20gKVxuICAgICAgfVxuICAgICAgLy8hISFkYW5nZXIgbG9vcCEhIVxuICAgIH1cblxuICB9XG59XG5cbmV4cG9ydHMuX3NldCA9IGZ1bmN0aW9uICh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGN2YWwsIGJsYWNrbGlzdCkge1xuICB2YXIgdCA9IHRoaXNcbiAgdmFsLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICBpZiAoIWJsYWNrbGlzdCB8fCAhYmxhY2tsaXN0W2ldKSB7XG4gICAgICBpZiAodGhpcy5fdmFsID09PSBmYWxzZSkge1xuICAgICAgICBpZiAoZXhwb3J0c1tpXSkge1xuICAgICAgICAgIGlmIChleHBvcnRzW2ldLnJlbW92ZSkgZXhwb3J0c1tpXS5yZW1vdmUuY2FsbCh0KVxuICAgICAgICAgIHQuZWFjaEluc3RhbmNlKGV4cG9ydHNbaV0ucmVtb3ZlLCB2YWwuX3Byb3AubmFtZSlcbiAgICAgICAgICB0aGlzLnJlbW92ZSgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFxuICAgICAgICAvLyBjb25zb2xlLmxvZygnX2NyZScsIGksIGV4cG9ydHNbaV0pXG5cbiAgICAgICAgaWYgKCEoZXhwb3J0c1tpXSAmJiBleHBvcnRzW2ldLm0pKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLXBhc3MnLCBpKVxuICAgICAgICAgIF9jcmVhdGUoaSwgaSlcbiAgICAgICAgfVxuICAgICAgICAvL2FkZCB3cmFwcGVyP1xuXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ19zZXQnLGksIGV4cG9ydHNbaV0uYWRkLCBleHBvcnRzW2ldKVxuXG4gICAgICAgIGlmIChleHBvcnRzW2ldLmFkZCkgZXhwb3J0c1tpXS5hZGQuY2FsbCggdCwgZmFsc2UsIGkgKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZWxlbWVudC5iYXNlLmV4dGVuZChcbnsgbmFtZTogJ2V2ZW50cydcbiwgc2V0OiBleHBvcnRzLl9zZXRcbn0pXG5cbnV0aWwuZGVmaW5lKGVsZW1lbnRcbiwgJ2FkZEV2ZW50JywgZnVuY3Rpb24oZmllbGQsIGZuLCBpZCkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdYWFhYJyxmaWVsZClcblxuICAgIGlmICghKGV4cG9ydHNbZmllbGRdICYmIGV4cG9ydHNbZmllbGRdLm0pKSBfY3JlYXRlKGZpZWxkKVxuICAgIHZhciBldmVudHMgPSB0aGlzLl9fZSB8fCAodGhpcy5fX2UgPSB7fSlcbiAgICAgICwgZiA9IGV2ZW50c1tmaWVsZF0gfHwgKGV2ZW50c1tmaWVsZF0gPSBuZXcgRmllbGRTdG9yZSgpKVxuXG4gICAgaWYgKCFpZCkge1xuICAgICAgZi5fdWlkKytcbiAgICAgIGlkID0gZi5fdWlkXG4gICAgfVxuICAgIGZbaWRdID0gZm5cblxuICAgIC8vIGNvbnNvbGUubG9nKCdhZGRFdmVudCEhIScsIGZpZWxkKVxuXG4gICAgaWYgKGV4cG9ydHNbZmllbGRdLmFkZCkgZXhwb3J0c1tmaWVsZF0uYWRkLmNhbGwodGhpcywgaWQsIGZpZWxkKVxuICAgIHJldHVybiB0aGlzXG4gIH1cbiwgJ3JlbW92ZUV2ZW50JywgZnVuY3Rpb24gKGZpZWxkLCBpZCwgZm4pIHtcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fX2VcbiAgICAgICwgcmVtb3ZlXG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgaWYgKGZpZWxkICYmIGV2ZW50c1tmaWVsZF0pIHtcbiAgICAgICAgcmVtb3ZlID0gKGV4cG9ydHNbZmllbGRdICYmIGV4cG9ydHNbZmllbGRdLnJlbW92ZSlcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgaWYgKGV2ZW50c1tmaWVsZF1baWRdICYmICghZm4gfHwgZXZlbnRzW2ZpZWxkXVtpZF0gPT09IGZuKSkge1xuICAgICAgICAgICAgaWYgKHJlbW92ZSkgZXhwb3J0c1tmaWVsZF0ucmVtb3ZlLmNhbGwodGhpcywgaWQpXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW2ZpZWxkXVtpZF1cbiAgICAgICAgICB9XG4gICAgICAgIH0gXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZvciAoaWQgaW4gZXZlbnRzW2ZpZWxkXSkge1xuICAgICAgICAgICAgaWYgKCFmbiB8fCBldmVudHNbZmllbGRdW2lkXSA9PT0gZm4pIHtcbiAgICAgICAgICAgICAgaWYgKHJlbW92ZSkgZXhwb3J0c1tmaWVsZF0ucmVtb3ZlLmNhbGwodGhpcywgaWQpXG4gICAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbZmllbGRdW2lkXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodXRpbC5lbXB0eShldmVudHNbZmllbGRdKSkgZGVsZXRlIGV2ZW50c1tmaWVsZF1cbiAgICAgIH0gXG4gICAgICBlbHNlIGlmICghZmllbGQpIHtcbiAgICAgICAgZm9yIChmaWVsZCBpbiBldmVudHMpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KGZpZWxkLCBpZCwgZm4pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHV0aWwuZW1wdHkoZXZlbnRzKSkgZGVsZXRlIHRoaXMuX19lXG4gICAgcmV0dXJuIHRoaXNcbiAgfSlcblxucmVxdWlyZSgnLi9iYXNpYycpXG4iLCJ2YXIgbWF0cml4ID0gcmVxdWlyZSgnLi4vZWxlbWVudC9wcm9wZXJ0aWVzL3V0aWwnKS5nZXRNYXRyaXhcbiAgLCB2aWdvdXIgPSByZXF1aXJlKCcuLi8uLi8nKVxuICAsIGNzcyA9IHJlcXVpcmUoJy4uL2NzcycpXG5cbmV4cG9ydHMubGVmdCA9IGV4cG9ydHMueCA9IGZ1bmN0aW9uICggb2JqZWN0LCBhcnIgKSB7XG4gIHJldHVybiBvZmZzZXQob2JqZWN0LGFyciwnbGVmdCcsJ29mZnNldExlZnQnLCA0KVxufVxuXG5leHBvcnRzLnRvcCA9IGV4cG9ydHMueSA9IGZ1bmN0aW9uICggb2JqZWN0LCBhcnIgKSB7XG4gIHJldHVybiBvZmZzZXQob2JqZWN0LGFyciwndG9wJywnb2Zmc2V0VG9wJywgNSlcbn0gXG5cbmZ1bmN0aW9uIG9mZnNldCAoIG9iamVjdCwgYXJyLCBwcm9wLCBwcm9wTCwgbWF0cml4SW5kZXggKSB7XG4gIGlmKCFvYmplY3QpIHJldHVybiAwXG4gIHZhciBzdGFydCA9IGZhbHNlXG4gIGlmKCFhcnIpIHtcbiAgICBhcnIgPSBbXVxuICAgIHN0YXJ0ID0gdHJ1ZVxuICB9XG4gIFxuICBpZih2aWdvdXIuRWxlbWVudCAmJiBvYmplY3QgaW5zdGFuY2VvZiB2aWdvdXIuRWxlbWVudCkgb2JqZWN0ID0gb2JqZWN0Lm5vZGVcblxuICB2YXIgYW1vdW50ID0gb2JqZWN0W3Byb3BMXVxuICAgICwgdGVtcCA9IDBcbiAgaWYodHlwZW9mKGFtb3VudCkgIT09ICdudW1iZXInKSBhbW91bnQgPSAwXG4gIGlmKG9iamVjdC5wYXJlbnROb2RlKSBleHBvcnRzW3Byb3BdKG9iamVjdC5wYXJlbnROb2RlLCBhcnIpXG4gICAgaWYoICggKG9iamVjdC5zdHlsZSAmJiBvYmplY3Quc3R5bGUucG9zaXRpb24pXG4gICAgICB8fG9iamVjdC5fX3ByZUNzc1xuICAgICAgfHxvYmplY3QuY2xhc3NOYW1lIFxuICAgICAgICAmJiAob2JqZWN0Ll9fcHJlQ3NzID0gY3NzKG9iamVjdC5jbGFzc05hbWUsICdwb3NpdGlvbicpfHx0cnVlKSkgXG4gICAgICAhPT0gJ2Fic29sdXRlJyApIHtcbiAgICAgICAgYXJyLnB1c2goWydyZWwnLCBhbW91bnRdKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWF0cml4QXJyYXkgPSBtYXRyaXgob2JqZWN0KVxuICAgICAgYXJyLnB1c2goWydhYnMnLCBtYXRyaXhBcnJheSBcbiAgICAgICAgPyBwYXJzZUludChtYXRyaXhBcnJheVttYXRyaXhJbmRleF0sMTApK2Ftb3VudCAvL25vcm1hbCBhbW91bnQgYXMgd2VsbFxuICAgICAgICA6IGFtb3VudCBdKVxuICAgIH1cbiAgXG4gIGlmKHN0YXJ0KSB7XG4gICAgdmFyIGxhc3RyZWxcbiAgICAgICwgYWJzID0gMFxuICAgICAgLCBpXG4gICAgZm9yKGkgaW4gYXJyKSB7XG4gICAgICBpZihhcnJbaV1bMF0gPT0gJ2FicycpIHtcbiAgICAgICAgYWJzICs9IGFycltpXVsxXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdHJlbCA9IGFycltpXVsxXVxuICAgICAgfVxuICAgIH1cbiAgICBhbW91bnQgPSBhcnJbYXJyLmxlbmd0aCAtIDFdWzBdID09PSAncmVsJyA/IGFicytsYXN0cmVsIDogYWJzXG4gIH1cbiAgcmV0dXJuIGFtb3VudCB8fCAwXG59XG5cbiAgXG5cblxuIiwidmFyIHJhZiA9IHJlcXVpcmUoJy4uL2FuaW1hdGlvbi9yYWYnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcblxuZXhwb3J0cy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZuLCBmcmFtZXMsIGJpbmQpIHtcbiAgZnJhbWVzIHx8IChmcmFtZXMgPSAyMCkgLy9+MC40c2VjXG4gIHZhciB0aW1lclxuICAgICwgYXJnXG4gICAgLCBub2JpbmQgPSAhYmluZFxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgYXJnID0gYXJndW1lbnRzXG4gICAgaWYobm9iaW5kKSBiaW5kID0gdGhpc1xuICAgIGlmKCF0aW1lcikge1xuICAgICAgdGltZXIgPSBmcmFtZXNcbiAgICAgIHJhZihmdW5jdGlvbiByZXBlYXQoKSB7XG4gICAgICAgIHRpbWVyLS1cbiAgICAgICAgaWYoIXRpbWVyKSB7XG4gICAgICAgICAgZm4uYXBwbHkoYmluZCxhcmcpIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhZihyZXBlYXQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbi8vVE9ETzogcG9zdHBvbmUgYmFzZWQgb24gZnJhbWVzXG5leHBvcnRzLnBvc3Rwb25lID0gZnVuY3Rpb24oZm4sIHRpbWUsIGJpbmQpIHtcbiAgdGltZSB8fCAodGltZSA9IDIwMCkgLy9ubyByYWYhXG4gIHZhciB0aW1lclxuICAgICwgYXJnXG4gICAgLCBub2JpbmQgPSAhYmluZFxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgYXJnID0gYXJndW1lbnRzXG4gICAgaWYobm9iaW5kKSBiaW5kID0gdGhpc1xuICAgIGlmKHRpbWVyKSBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgZm4uYXBwbHkoYmluZCxhcmcpXG4gICAgfSx0aW1lKVxuICAgIHJldHVybiB0aW1lclxuICB9XG59XG5cbi8vVE9ETzogdGVzdCBmb3IgbGVha3MuLi5cbmV4cG9ydHMuaW50ZXJ2YWwgPSBmdW5jdGlvbihmbiwgZnJhbWVzLCBiaW5kKSB7XG4gIGZyYW1lcyB8fCAoZnJhbWVzID0gMzApIC8vfjAuNXNlY1xuICB2YXIgdGltZXJcbiAgICAsIGNsZWFyXG4gICAgLCBhcmcgPSB1dGlsLmFyZyhhcmd1bWVudHMsMylcbiAgaWYoIXRpbWVyKSB7XG4gICAgdGltZXIgPSBmcmFtZXNcbiAgICByYWYoZnVuY3Rpb24gcmVwZWF0KCkge1xuICAgICAgdGltZXItLVxuICAgICAgaWYoIXRpbWVyKSB7XG4gICAgICAgIHRpbWVyID0gZnJhbWVzXG4gICAgICAgIGZuLmFwcGx5KGJpbmQsYXJnKVxuICAgICAgfSBcbiAgICAgIGlmKCFjbGVhcikgcmFmKHJlcGVhdClcbiAgICB9KVxuICB9XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBjbGVhcj10cnVlXG4gIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBfYSA9ICdhZGRFdmVudExpc3RlbmVyJ1xuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCB1YSA9IHJlcXVpcmUoJy4uL3VhJylcbiAgLCBjbnQgPSAwXG5cbi8qKlxuICogeGhyIHdyYXBwZXIsIGFkZHMgc29tZSBuaWNlIGV4dHJhcyBzdWNoIGFzIG11bHRpcGxlIHJlcXVlc3RzIHRvIGEgc2luZ2xlIGFwaSBjYWxsXG4gKiB4aHIgd3JhcHBlciB3aWxsIGluY2x1ZGUganNvbnAgaW4gYSBsYXRlciBzdGFnZVxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSAgIHtTdHJpbmd8QXJyYXl9IHBhcmFtcy51cmwgICAgICAgICBTcGVjaWZpeSB0aGUgdXJsLCBhcnJheSBmZXRjaGVzIG11bHRpcGxlIHVybCdzXG4gKiBAcGFyYW0gICB7U3RyaW5nfSAgIFtwYXJhbXMuYXBpXSAgICAgICAgICAgUmVwZWF0IHRoaXMgc3RyaW5nIGZvciB0aGUgdXJsIHRoYXQgbmVlZHMgdG8gYmUgY2FsbGVkXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IFtwYXJhbXMuY29tcGxldGVdICAgICAgU3BlY2lmeSBhIGNhbGxiYWNrIHdoZW4gYW4gYXJyYXkgaXMgcGFzc2VkIHRvIHVybCBjb21wbGV0ZSBpcyBjYWxsZWQgd2hlbiBhbGwgaXRlbXMgYXJlIGNvbXBsZXRlXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IFtwYXJhbXMuZXJyb3JdICAgICAgICAgT24gZXJyb3IgY2FsbGJhY2tcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gW3BhcmFtcy5jaGFuZ2VdICAgICAgICBGdW5jdGlvbiBjYWxsZWQgb24geGhyLm9ucmVhZHlzdGF0ZWNoYW5nZVxuICogQHBhcmFtICAge0Jvb2xlYW59ICBbcGFyYW1zLmFzeW5jXSAgICAgICAgIElmIHNldCB0byBmYWxzZSB3aWxsIGNhbGwgYW4gc3luY3Jvbm91cyByZXF1ZXN0IChub3QgcmVjb21tZW5kZWQhKVxuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLnVzZXJdICAgICAgICAgIFVzZXIgcGFyYW1ldGVyXG4gKiBAcGFyYW0gICB7U3RyaW5nfSAgIFtwYXJhbXMucGFzc10gICAgICAgICAgUGFzc3dvcmQgcGFyYW1ldGVyXG4gKiBAcGFyYW0gICB7Qm9vbGVhbn0gIFtwYXJhbXMucGFyc2VdICAgICAgICAgSWYgc2V0IHRvIGZhbHNlIHdpbGwgbm90IHRyeSB0byBwYXJzZSByZXNwb25zZSB0byBKU09OXG4gKiBAcGFyYW0gICB7U3RyaW5nfSAgIFtwYXJhbXMudHlwZXwubWV0aG9kXSAgUE9TVCBvciBHRVQsIGRlZmF1bHQgaXMgZ2V0O1xuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLmNvbnRlbnRUeXBlXSAgIHJlcXVlc3QgY29udGVudCB0eXBlIGRlZmF1bHQgaWQgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIlxuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLm1pbWVdICAgICAgICAgIGRlZmluZXMgbWltZSB0eXBlXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IFtwYXJhbXMucHJvZ3Jlc3NdICAgICAgUHJvZ3Jlc3MgY2FsbGJhY2tcbiAqIEBwYXJhbSAgIHtCb29sZWFufFN0cmluZ30gW3BhcmFtcy5qc29ucF0gICBVc2UganNvbnAgLCBpZiBwYXNzZWQgYXMgYSBzdHJpbmcgZGV0ZXJtaW5lcyBzY3JpcHQrP2NhbGxiYWNrPVxuICogQHBhcmFtICAge09iamVjdH0gICBbcGFyYW1zLmhlYWRlcl0gICAgICAgIFNldHMgcmVxdWVzdCBoZWFkZXJzXG4gKiBAcGFyYW0gICB7Kn0gICAgICAgIFtwYXJhbXMuZGF0YV0gICAgICAgICAgUGFzcyBkYXRhIHRvIHRoZSByZXF1ZXN0LCBkZWZhdWx0cyB0byA/IG9uIGdldDtcbiAqL1xuXG52YXIgaWZyYW1lc1xuICAsIGFqYXggPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHBhcmFtcywgdXJsc2V0KSB7XG4gICAgdmFyIF91cmwgPSBwYXJhbXMudXJsO1xuICAgIGlmICghdXJsc2V0ICYmIF91cmwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcGFyYW1zLm0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCgrK3BhcmFtcy5yKSA9PT0gcGFyYW1zLm4pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgYXJyID0gW10sIGwgPSBfdXJsLmxlbmd0aDsgaSA8IGw7IGFyci5wdXNoKHBhcmFtcy5kW191cmxbaSsrXV0pKTtcbiAgICAgICAgICBwYXJhbXMuY29tcGxldGUoYXJyKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHBhcmFtcy5yID0gMDtcbiAgICAgIHBhcmFtcy5kID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhcmFtcy5uID0gX3VybC5sZW5ndGg7IGkgPCBsOyBtb2R1bGUuZXhwb3J0cyhwYXJhbXMsIF91cmxbaSsrXSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZGF0YSA9IHBhcmFtcy5kYXRhXG4gICAgICAgICwgZW5jb2RlID0gcGFyYW1zLmVuY29kZVxuICAgICAgICAsIHVybCA9IChwYXJhbXMuYXBpIHx8ICcnKSArICh1cmxzZXQgfHwgX3VybClcbiAgICAgICAgLCBoZWFkZXJzID0gcGFyYW1zLmhlYWRlcnNcbiAgICAgICAgLCBzdWNjZXNzID0gcGFyYW1zLmNvbXBsZXRlXG4gICAgICAgICwgcHJvZ3Jlc3MgPSBwYXJhbXMucHJvZ3Jlc3NcbiAgICAgICAgLCBlcnJvciA9IHBhcmFtcy5lcnJvclxuICAgICAgICAsIGNoYW5nZSA9IHBhcmFtcy5jaGFuZ2VcbiAgICAgICAgLCBtaW1lID0gcGFyYW1zLm1pbWVcbiAgICAgICAgLCB1c2VyID0gcGFyYW1zLnVzZXJcbiAgICAgICAgLCBwYXNzID0gcGFyYW1zLnBhc3NcbiAgICAgICAgLCBqc29ucCA9IHBhcmFtcy5qc29ucFxuICAgICAgICAsIHBhcnNlID0gcGFyYW1zLnBhcnNlXG4gICAgICAgICwgaWZyYW1lID0gcGFyYW1zLmlmcmFtZVxuICAgICAgICAsIHJlcWRhdGEgPSBudWxsXG4gICAgICAgICwgZmFsbGJhY2sgPSBwYXJhbXMuZmFsbGJhY2tcbiAgICAgICAgLCBmYWxsYmFja0luZGV4ID0gcGFyYW1zLl9mYWxsYmFja0luZGV4XG4gICAgICAgICwgbWV0aG9kID0gcGFyYW1zLnR5cGUgfHwgcGFyYW1zLm1ldGhvZCB8fCAnR0VUJ1xuICAgICAgICAsIGNvbnRlbnRUeXBlID0gcGFyYW1zLmNvbnRlbnRUeXBlIHx8IGVuY29kZSA9PT0gJ2pzb24nXG4gICAgICAgICAgPyAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgICA6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgICAgICwgYXN5bmMgPSAocGFyYW1zLmFzeW5jID09PSBmYWxzZSkgPyBmYWxzZSA6IHRydWVcbiAgICAgICAgXG4gICAgICBpZigganNvbnAgKSBcbiAgICAgIHtcbiAgICAgICAgYWpheC5qc29ucCggdXJsLCBzdWNjZXNzLCBlcnJvciApICBcbiAgICAgICAgLy9mdW5jdGlvbiggdXJsLCBzdWNjZXNzLCBlcnJvciwgY29udGV4dCwgY2JOYW1lICkge1xuICAgICAgfSBcbiAgICAgIGVsc2UgXG4gICAgICB7XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBEQVRBXG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgICAgICBpZihpZnJhbWUpIHtcbiAgICAgICAgICBjbnQrK1xuICAgICAgICAgIHZhciBlbGVtXG4gICAgICAgICAgICAsIG1zZyA9IHt9XG4gICAgICAgICAgICAsIHJlcWlkID0gY250XG5cbiAgICAgICAgICBmb3IodmFyIGZpZWxkIGluIHBhcmFtcykge1xuICAgICAgICAgICAgaWYoZmllbGQhPT0nZXJyb3InJiZmaWVsZCE9PSdpZnJhbWUnJiZmaWVsZCE9PSdjb21wbGV0ZScpIHtcblxuICAgICAgICAgICAgICBtc2dbZmllbGRdPXBhcmFtc1tmaWVsZF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHNldG1zZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsZW1cbiAgICAgICAgICAgIGlmcmFtZXNbaWZyYW1lXS5vbmxvYWQgPSBudWxsXG4gICAgICAgICAgICB2YXIgbXNnY29tcGxldGUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0lGUkFNRSBSRVEgTVNHIENPTVBMRVRFJyxlLmRhdGEpXG4gICAgICAgICAgICAgIGlmKGUuZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBkXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGQgPSBKU09OLnBhcnNlKGUuZGF0YSlcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmKGVycm9yKSBlcnJvcihlKVxuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKGQuaWQhPT1yZXFpZCkgcmV0dXJuXG4gICAgICAgICAgICAgICAgaWYoZC5lcnIpIHtcbiAgICAgICAgICAgICAgICAgIGlmKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKGQuZXJyKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciByZXNwID0gZC5tc2dcbiAgICAgICAgICAgICAgICBpZihzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzcCA9IEpTT04ucGFyc2UocmVzcClcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3MocmVzcCxlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbXNnY29tcGxldGUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG1zZ2NvbXBsZXRlLCBmYWxzZSlcbiAgICAgICAgICAgICAgZWxlbSA9IGlmcmFtZXNbaWZyYW1lXS5jb250ZW50V2luZG93XG4gICAgICAgICAgICAgIG1zZyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBtc2c6bXNnLFxuICAgICAgICAgICAgICAgIGlkOnJlcWlkXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIGVsZW0ucG9zdE1lc3NhZ2UobXNnLCAnKicpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIWlmcmFtZXMpIGlmcmFtZXMgPSB7fVxuICAgICAgICAgIGlmKCFpZnJhbWVzW2lmcmFtZV0pIHtcbiAgICAgICAgICAgIGVsZW0gPSBpZnJhbWVzW2lmcmFtZV0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKVxuICAgICAgICAgICAgZWxlbS5zcmMgPSBpZnJhbWVcbiAgICAgICAgICAgIGVsZW0uY0xpc3RlbmVycyA9IFtcbiAgICAgICAgICAgICAgc2V0bXNnXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICBlbGVtLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBmb3IodmFyIGggaW4gZWxlbS5jTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZWxlbS5jTGlzdGVuZXJzW2hdKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbGVtLmNMaXN0ZW5lcnMgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtLnN0eWxlLnZpc2liaWxpdHk9J2hpZGRlbidcbiAgICAgICAgICAgIGVsZW0uc3R5bGUud2lkdGggPSAnMHB4J1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5oZWlnaHQgPSAnMHB4J1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbSlcbiAgICAgICAgICB9IGVsc2UgaWYoaWZyYW1lc1tpZnJhbWVdLmNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGlmcmFtZXNbaWZyYW1lXS5jTGlzdGVuZXJzLnB1c2goc2V0bXNnKVxuICAgICAgICAgICAgLy9lbGVtLmNMaXN0ZW5lcnNbaV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2V0bXNnKClcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEpIHtcblxuICAgICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICB1cmwgKz0gJz8nICsgZW5Db2RlKGRhdGEsICdHRVQnLCBlbmNvZGUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcWRhdGEgPSBlbkNvZGUoZGF0YSwgJ1BPU1QnLCBlbmNvZGUpXG4gIC8vICAgICAgICAgICBjb25zb2xlLmxvZyggcmVxZGF0YSApXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1FVEhPRCwgVVJMLCBBU1lOQywgVVNFUiAmIFBBU1NcbiAgICAgICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIGFzeW5jLCB1c2VyLCBwYXNzKVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gSEVBREVSU1xuICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgY29udGVudFR5cGUpXG4gICAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgZiBpbiBoZWFkZXJzKSB7XG4gICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihmLCBoZWFkZXJzW2ZdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRVZFTlRTXG4gICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgeGhyW19hXShcImxvYWRcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIHJlc3AgPSAoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KS5yZXNwb25zZTtcbiAgICAgICAgICAgIGlmIChwYXJzZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNwID0gSlNPTi5wYXJzZShyZXNwKVxuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5tKSB7XG4gICAgICAgICAgICAgIHBhcmFtcy5kW3VybHNldF0gPSByZXNwXG4gICAgICAgICAgICAgIHBhcmFtcy5tKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3MocmVzcCwgZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmYWxzZSlcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBpZighZmFsbGJhY2tJbmRleCkgcGFyYW1zLl9mYWxsYmFja0luZGV4ID0gMFxuICAgICAgICAgIGlmKGZhbGxiYWNrICYmIGZhbGxiYWNrSW5kZXghPT1mYWxsYmFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhcmFtcy5fZmFsbGJhY2tJbmRleCsrXG4gICAgICAgICAgICBwYXJhbXMgPSB1dGlsLm1lcmdlKHBhcmFtcyxmYWxsYmFja0luZGV4KVxuICAgICAgICAgICAgYWpheChwYXJhbXMsIHVybHNldClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeGhyW19hXShcImVycm9yXCIsIGVycm9yLCBmYWxzZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyZXNzKSB7XG4gICAgICAgICAgeGhyW19hXShcInByb2dyZXNzXCIsIHByb2dyZXNzLCBmYWxzZSlcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlKSB7XG4gICAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNoYW5nZVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNSU1FXG4gICAgICAgIGlmIChtaW1lKSB7XG4gICAgICAgICAgeGhyLm92ZXJyaWRlTWltZVR5cGUobWltZSlcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gU0VORFxuXG4gICAgICAgIHhoci5zZW5kKHJlcWRhdGEpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbnZhciBqc29ucFN0YW1wID0gMFxuXG5hamF4Lmpzb25wID0gZnVuY3Rpb24oIHVybCwgc3VjY2VzcywgZXJyb3IsIGNvbnRleHQsIGNiTmFtZSApIHtcblxuICBpZiggIWNiTmFtZSB8fCBjYk5hbWUgPT09IHRydWUgKSBjYk5hbWUgPSAnY2FsbGJhY2snXG5cbiAgdmFyIG5hbWUgPSAnX2pzb25wXycgKyBqc29ucFN0YW1wKytcbiAgICAsIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gIFxuICBpZiAodXJsLm1hdGNoKC9cXD8vKSkgXG4gIHsgXG4gICAgdXJsICs9ICcmJytjYk5hbWUrJz0nK25hbWVcbiAgfVxuICBlbHNlIFxuICB7XG4gICAgdXJsICs9ICc/JytjYk5hbWUrJz0nK25hbWVcbiAgfVxuICBcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0J1xuICBzY3JpcHQuc3JjID0gdXJsXG4gIFxuICBpZihlcnJvcikge1xuICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oIGUgKSB7XG4gICAgICBlcnJvciggZSApXG4gICAgfVxuICB9XG5cbiAgd2luZG93W25hbWVdID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgc3VjY2Vzcy5jYWxsKCggY29udGV4dCB8fCB3aW5kb3cgKSwgZGF0YSlcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLnJlbW92ZUNoaWxkKHNjcmlwdClcbiAgICBzY3JpcHQgPSBudWxsXG4gICAgZGVsZXRlIHdpbmRvd1tuYW1lXVxuICB9XG4gIFxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdClcblxufVxuXG52YXIgZW5Db2RlID0gYWpheC5lbmNvZGUgPSBmdW5jdGlvbihkYXRhLCBtZXRob2QsIGVuY29kZSkge1xuICB2YXIgcmVzdWx0ID0gJydcblxuICBpZihlbmNvZGUgPT09ICdqc29uJyl7XG4gICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgfSBlbHNlIGlmKGRhdGEgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBpZiAoIXV0aWwuaXNOb2RlICYmICh3aW5kb3cuRm9ybURhdGEgJiYgZGF0YSBpbnN0YW5jZW9mIEZvcm1EYXRhKSAmJiBtZXRob2QgIT09ICdHRVQnKSB7XG4gICAgICByZXN1bHQgPSBkYXRhXG4gICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KGRhdGFbZl0pXG4gICAgICBpZihlbmNvZGUgPT09ICd1cmknKSByZXN1bHQgPSBlbmNvZGVVUklDb21wb25lbnQocmVzdWx0KVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBmIGluIGRhdGEpIHtcbiAgICAgICAgdmFyIHZhbCA9IGRhdGFbZl1cbiAgICAgICAgaWYodmFsIGluc3RhbmNlb2YgT2JqZWN0KSB2YWwgPSBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICAgICAgIGlmKGVuY29kZSA9PT0gJ3VyaScpe1xuICAgICAgICAgIGYgPSBlbmNvZGVVUklDb21wb25lbnQoZilcbiAgICAgICAgICB2YWwgPSBlbmNvZGVVUklDb21wb25lbnQodmFsKVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBmICsgJz0nICsgdmFsICsgJyYnXG4gICAgICB9XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgLTEpXG5cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKGVuY29kZSA9PT0gJ3VyaScpID8gZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpIDogZGF0YVxuICB9XG4gIC8vIGNvbnNvbGUubG9nKCdlbmNvZGVkOicsIHJlc3VsdClcbiAgcmV0dXJuIHJlc3VsdFxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IE1hcmN1cyBCZXNqZXMsIG1hcmN1c0B2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChleHRlbmQpXG5cbmZ1bmN0aW9uIGV4dGVuZChDbG91ZCkge1xuICB1dGlsLmRlZmluZSggQ2xvdWRcbiAgLCAnYXV0aGVudGljYXRlJywgZnVuY3Rpb24gYXV0aGVudGljYXRlKHJlcSwgY2IsIHJlKXtcbiAgICAgIHdpbmRvdy5hdXRocmVxdWVzdCA9IHJlcVxuICAgICAgdmFyIGNsb3VkID0gdGhpc1xuXG4gICAgICBpZih0eXBlb2YgcmVxID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXEgPSByZXEoKVxuXG4gICAgICBpZighcmVxKVxuICAgICAgICByZXR1cm4gY2xvdWQuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgcmVBdXRoKVxuXG4gICAgICBjbG91ZC5lbWl0KCdhdXRoZW50aWNhdGUnLCByZXEsIGZ1bmN0aW9uKHJlcyl7XG4gICAgICAgIGlmKHJlcy5ob3ApXG4gICAgICAgICAgY2xvdWQuaG9wKHJlcy5ob3ApXG4gICAgICAgIGVsc2UgaWYoY2IpXG4gICAgICAgICAgY2IocmVzKVxuICAgICAgfSlcbiAgICAgXG4gICAgICBpZighcmUpe1xuICAgICAgICBjbG91ZC5vbignY29ubmVjdCcsIHJlQXV0aClcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVBdXRoKCl7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Nvbm5lY3QgLT4+PiByZUF1dGg/JylcbiAgICAgICAgaWYoY2xvdWQuX3N0YXR1cyA+IDIpe1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlY29ubmVjdCAtPj4+IHJlQXV0aCEnLCByZXEpXG4gICAgICAgICAgY2xvdWQuYXV0aGVudGljYXRlKHJlcSwgY2IsIHRydWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNsb3VkLl9yZUF1dGggPSByZUF1dGhcbiAgICB9XG4gICwgJ2xvZ291dCcsIGZ1bmN0aW9uIGxvZ291dCh1c2VyaWQpe1xuICAgICAgdmFyIGNsb3VkID0gdGhpc1xuXG4gICAgICBjbG91ZC5lbWl0KCdsb2dvdXQnLCB1c2VyaWQpXG5cbiAgICAgIGlmKFxuICAgICAgICBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0gJiYgXG4gICAgICAgICBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0uYWN0aXZlQ2xpZW50IFxuICAgICAgICAgJiYgY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdLmFjdGl2ZUNsaWVudC5mcm9tLl9uYW1lID09PSBjbG91ZC5jbGllbnRpZFxuICAgICAgICkgXG4gICAgICAge1xuICAgICAgICAgY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdLmFjdGl2ZUNsaWVudC5yZW1vdmUoKVxuICAgICAgIH1cblxuICAgICAgXG4gICAgICB2YXIgc3RhbXAgPSBjbG91ZC5zdGFtcFxuXG4gICAgICBpZih1c2VyaWQpe1xuICAgICAgICBpZihjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0pXG5cbiAgICAgICAgaWYoIFxuICAgICAgICAgIGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXS5hY3RpdmVDbGllbnQgXG4gICAgICAgICAgJiYgY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdLmFjdGl2ZUNsaWVudC5mcm9tLl9uYW1lID09PSBjbG91ZC5jbGllbnRpZCkgXG4gICAgICAgIHtcbiAgICAgICAgICBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0uYWN0aXZlQ2xpZW50LmZyb20gPSBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0uYWN0aXZlQ2xpZW50XG4gICAgICAgIH1cblxuICAgICAgICBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0ucmVtb3ZlKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgc3RhbXApXG4gICAgICAgIC8vIGVsc2VcbiAgICAgICAgLy8gICBjb25zb2xlLmVycm9yKCd0aGF0IHVzZXIgZG9lcyBub3QgZXhpc3QnKVxuICAgICAgfSBlbHNle1xuICAgICAgICBjbG91ZC5kYXRhLnVzZXJzLmVhY2goZnVuY3Rpb24odXNlcmlkKXtcbiAgICAgICAgICB0aGlzLnJlbW92ZSh2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHN0YW1wKVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICBjbG91ZC5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCBjbG91ZC5fcmVBdXRoKVxuICAgICAgY2xvdWQuX3JlQXV0aCA9IG51bGxcblxuICAgIH1cbiAgKVxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IE1hcmN1cyBCZXNqZXMsIG1hcmN1c0B2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vLi4vdXRpbCcgKVxuICAsIE5ldHdvcmtEYXRhID0gcmVxdWlyZSggJy4uL2RhdGEnIClcbiAgICAuaW5qZWN0KCByZXF1aXJlKCAnLi4vLi4vLi4vb2JqZWN0L2hhc2hwYXRoJyApIClcbiAgICAvL1RPRE86IGFkZCBsb2NhbHN0b3JhZ2UgLS0+ICwgIXV0aWwuaXNOb2RlICYmIHJlcXVpcmUoJy4uLy4uLy4uL29iamVjdC9sb2NhbHN0b3JhZ2UnKVxuICAsIG5ldHdvcmtEYXRhRWxlbWVudCA9IHJlcXVpcmUoICcuLi9kYXRhL2VsZW1lbnQnIClcbiAgLCBEYXRhID0gcmVxdWlyZSggJy4uLy4uLy4uL2RhdGEnIClcbiAgLCBwcmV2ZW50VXBkYXRlXG4gICwgdk9iamVjdCA9IHJlcXVpcmUoICcuLi8uLi8uLi9vYmplY3QnIClcbiAgLCBtb25vU3RhbXAgPSByZXF1aXJlKCAnbW9ub3RvbmljLXRpbWVzdGFtcCcgKVxuICAsIENsb3VkRGF0YSA9IE5ldHdvcmtEYXRhLm5ld1xuICAgICggZmFsc2UgLy9wdXQgc29tZSBzZXR0aW5ncyFcbiAgICAsIGZ1bmN0aW9uIENsb3VkRGF0YSggdmFsLCBob29rLCBwYXJlbnQsIGNsb3VkICkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzXG5cbiAgICAgICAgaWYoIGNsb3VkIClcbiAgICAgICAge1xuICAgICAgICAgIF90aGlzLmNsb3VkID0gY2xvdWRcbiAgICAgICAgICBfdGhpcy5hZGRMaXN0ZW5lcihjZExpc3RlbmVyKVxuXG4gICAgICAgICAgaWYoIXV0aWwuaXNOb2RlICYmICEhd2luZG93LmNvcmRvdmEpIFxuICAgICAgICAgIHtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy9UT0RPOiB0aGlzIGRvZXMgbm90IHdvcmsgeWV0IC0tIG1ha2UgcHJldmVudCB1cGRhdGUgYSB1c2FibGUgdGhpbmcgaW4gYXBwIGxvZ2ljICggZS5nLiBpbiBkZXZpY2UgbGlzdHMgb3IgY2xpZW50cyApXG4gICAgICAgICAgICAgIF90aGlzLnByZXZlbnRVcGRhdGUgPSB0cnVlXG4gICAgICAgICAgICB9LCBmYWxzZSlcblxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjbG91ZC5raWNrUGluZygpXG5cbiAgICAgICAgICAgICAgaWYoIF90aGlzLnRpbWVvdXQgKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KCBfdGhpcy50aW1lb3V0IClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiggX3RoaXMuZGVmZXJlZCApIFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLm1lcmdlKCBfdGhpcy5kZWZlcmVkLmRhdGEsIGZhbHNlLCBfdGhpcy5kZWZlcmVkLnN0YW1wIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucHJldmVudFVwZGF0ZSA9IG51bGxcbiAgICAgICAgICAgICAgICBfdGhpcy5kZWZlcmVkID0gbnVsbFxuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBudWxsXG4gICAgICAgICAgICAgIH0sIDEwMCApXG4gICAgICAgICAgICAgIC8vIF90aGlzLnByZXZlbnRVcGRhdGUgPSB0cnVlIC8vd2FpdCBmb3IgYW5vdGhlciB1cGRhdGUgYW5kIHRpbWVvdXRcbiAgICAgICAgICAgIH0sIGZhbHNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNsb3VkLm9uXG4gICAgICAgICAgKCAnc2V0J1xuICAgICAgICAgICwgZnVuY3Rpb24oIGRhdGEgKSB7XG4gXG4gICAgICAgICAgICAvLyBjb25zb2xlLmNsZWFyKClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29uc29sZS5ncm91cCgpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnXFxuLS0tLS0tLS0tLS1JTkNPTUlORyBDTE9VRC0tLS0tLS1cXG4nLCBkYXRhIClcblxuICAgICAgICAgICAgLy8gaWYoKVxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShkYXRhLCBmYWxzZSwgMikuc2xpY2UoMCwyMDApKVxuICAgICAgICAgICAgLy8gY29uc29sZS5ncm91cENvbGxhcHNlZCgpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShkYXRhLCBmYWxzZSwgMikpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0lOQ09NSU5HIVxcbicsIEpTT04uc3RyaW5naWZ5KGRhdGEpKVxuICAgICAgICAgICAgICB2YXIgc2V0ID0gZGF0YS5zXG4gICAgICAgICAgICAgICAgLCB2Y2xvY2sgPSBkYXRhLnZcbiAgICAgICAgICAgICAgICAvLyAsIHN0YW1wcyA9IHZjbG9ja1sxXVxuICAgICAgICAgICAgICAgICwgc3VicyA9IGNsb3VkLnN0YXRlLnN1YnMubWFwXG4gICAgICAgICAgICAgICAgLCBzdWJzdGFtcCA9IHZjbG9ja1sxXVxuXG4gICAgICAgICAgICAgIGlmKCB2Y2xvY2tbMF0gaW5zdGFuY2VvZiBBcnJheSApXG4gICAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAgIC8vdmNsb2NrIHdoZXJlIGlzIGl0Pz8/Pz8/XG5cbiAgICAgICAgICAgICAgICBmb3IoIHZhciBpID0gdmNsb2NrWzBdLmxlbmd0aDsgaGFzaCA9IHZjbG9ja1swXVstLWldOyApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdXBkYXRlU3ViKCBzdWJzW2hhc2hdLCBzdWJzdGFtcCApXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdXBkYXRlU3ViKCBzdWJzW2RhdGEudlswXV0sIHN1YnN0YW1wIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIHN1YnN0YW1wID0gMFxuXG4gICAgICAgICAgICAgIC8vIGZvciggdmFyIHMgaW4gc3RhbXBzIClcbiAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdidXJycicsIHN0YW1wc1tzXSlcbiAgICAgICAgICAgICAgLy8gICBpZiggc3RhbXBzW3NdID4gc3RhbXAgKSBzdGFtcCA9IHN0YW1wc1tzXVxuICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgdmFyIHN0YW1wID0gbW9ub1N0YW1wKClcbiAgICAgICAgICAgICAgY2xvdWQuc3RhbXAgPSBzdGFtcFxuXG4gICAgICAgICAgICAgIC8vIF90aGlzLl90aW1lXG5cbiAgICAgICAgICAgICAgaWYoICFfdGhpcy5wcmV2ZW50VXBkYXRlICkgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tZXJnZSggZGF0YS5zLCBmYWxzZSwgc3RhbXAgKVxuICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZighX3RoaXMuZGVmZXJlZClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAvL3BhdXNlIGdlZW4gdGltZW91dCBhbGxlZW4gbWFhciB1aXRzdGVsbGVuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5kZWZlcmVkID0gXG4gICAgICAgICAgICAgICAgICB7IGRhdGE6IGRhdGEuc1xuICAgICAgICAgICAgICAgICAgLCBzdGFtcDogc3RhbXBcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5kZWZlcmVkLnN0YW1wID0gc3RhbXBcbiAgICAgICAgICAgICAgICAgIF90aGlzLmRlZmVyZWQuZGF0YSA9IHV0aWwubWVyZ2UoIF90aGlzLmRlZmVyZWQuZGF0YSwgZGF0YS5zKVxuICAgICAgICAgICAgICAgICAgLy8gX3RoaXMuZGVmZXJlZC5kYXRhLl91cGRhdGUoIGRhdGEucyApXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgIClcblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoIHBhcmVudCApXG4gICAgICAgIHtcbiAgICAgICAgICBfdGhpcy5jbG91ZCA9IHBhcmVudC5jbG91ZFxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICApXG4gICwgX191cGRhdGVcblxubW9kdWxlLmV4cG9ydHMgPSBDbG91ZERhdGFcblxuZnVuY3Rpb24gdXBkYXRlU3ViKCBjYWNoZWQsIHZjbG9jayApIHtcbiAgaWYoICFjYWNoZWQgKSByZXR1cm5cblxuICByZXR1cm4gLy8gbm90IGltcGxlbWVudGVkXG5cbiAgLy8gdmFyIHN1YiA9IGNhY2hlZC5zdWJzb2JqXG4gIC8vIGlmKCAhc3ViLl92ICkgc3ViLnNldCggJ192Jywge30gKVxuXG4gIC8vIGZvciggdmFyIGYgaW4gdmNsb2NrIClcbiAgLy8ge1xuICAvLyAgIHN1Yi5fdi5zZXQoIGYsIHZjbG9ja1tmXSApXG4gIC8vIH1cblxufVxuXG5mdW5jdGlvbiBjcmVhdGVTdWIoIHBhdGgsIHN1YiwgcGFydGlhbFN1YiApIHtcblxuICBpZiggcGF0aC5sZW5ndGggKVxuICB7XG4gICAgdXRpbC5wYXRoKCBzdWIsIHBhdGgsIHBhcnRpYWxTdWIsIHRydWUgKVxuICAgIHJldHVybiBzdWJcbiAgfVxuICBlbHNlXG4gIHtcbiAgICByZXR1cm4gcGFydGlhbFN1YlxuICB9XG5cbn1cblxuZnVuY3Rpb24gdDR3YWxrZXIoIHZhbCApIHtcbi8vVE9ETzogcmVtb3ZlICR0OjRcbiAgZm9yKCB2YXIgaSBpbiB2YWwgKVxuICB7XG5cbiAgICBpZih2YWxbaV0gaW5zdGFuY2VvZiBPYmplY3QpXG4gICAge1xuXG4gICAgICBpZih2YWxbaV0gaW5zdGFuY2VvZiB2T2JqZWN0KVxuICAgICAge1xuICAgICAgICB2YWxbaV0gPSB7ICRwYXRoOiB2YWxbaV0uX3BhdGggfSAvLyAkdDogNCBcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgdDR3YWxrZXIoIHZhbFtpXSApXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGNkTGlzdGVuZXIoIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZCApe1xuICB2YXIgY2xvdWQgPSB0aGlzLmNsb3VkXG4gIC8vIGNvbnNvbGUubG9nKCdPT09PIGNsb3VkYXRhIGxpc3RlbmVyYnVyJywgdGhpcy5fcGF0aCwgdmFsKVxuICBpZiggc3RhbXAgPT09ICdsb2NhbFN0b3JhZ2UnIHx8IHN0YW1wPT09ZmFsc2UgIClcbiAge1xuICAgIC8vIGNvbnNvbGUubG9nKCdJIFdJTEwgTk9UIFVQREFURScucmVkLmludmVyc2UpXG4gICAgLy8gY29uc29sZS5sb2coJ0Nsb3VkIGZyb20gbG9jYWxzdG9yYWdlJy5pbnZlcnNlLnJlZClcbiAgICByZXR1cm5cbiAgfVxuXG5cbiAgaWYoIHN0YW1wICE9PSBjbG91ZC5zdGFtcCAmJiB2YWwgIT09IHZvaWQgMCApXG4gIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCc+Pj4+Pj4gc2hpbmVyJylcblxuICAgIC8vIGNvbnNvbGUubG9nKCdcXG5cXG5cXG5cXG5cXG51cGRhdGUgY2xvdWQnLCB2YWwpXG5cblxuXG4gICAgaWYoIHJlbW92ZSAmJiBmcm9tIClcbiAgICB7XG4gICAgICBpZiggZnJvbS5fcmVtb3ZlZCApXG4gICAgICB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJyEhISEhIVVQREFURSBDTE9VRCEhIScsIGZyb20gJiYgZnJvbS5fcGF0aCwgdmFsLCBzdGFtcClcblxuICAgICAgICBjbG91ZC5zZXQoZnJvbS5faGFzaHBhdGgsIFtmcm9tLl9wYXRoLCBudWxsLCBjbG91ZC50aW1lU3RhbXAoKV0pXG4gICAgICB9XG5cbiAgICB9XG4gICAgZWxzZSBpZiAoIGZyb20gJiYgIXRoaXMuX2Nsb3VkaWdub3JlIClcbiAgICB7XG5cblxuICAgICAgLy8gaWYoIHN0YW1wID09PSB2b2lkIDAgKSB7XG4gICAgICAvLyAgIGFsZXJ0KCdYJylcbiAgICAgIC8vIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coICdjY2NjY2NjY2NjY2MgdXBkYXRlIScsIHRoaXMuX3BhdGggLCBmcm9tLl91cGRhdGVPcmlnaW4sIGZyb20uX2NhY2hlZFBhdGgpXG5cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ191cGRhdGUgT3JpZ2luIGNhbGwgZnJvbSBjbG91ZC5kYXRhJykgXG4gICAgICBpZiggZnJvbS5fdXBkYXRlT3JpZ2luID09PSBmcm9tICkgLy9oaWVyIGdhYXQgaWV0cyBtaXNcbiAgICAgIHtcbiAgICAgICAgaWYoIGZyb20uX190ID09PSAyICYmIHZhbCBpbnN0YW5jZW9mIE9iamVjdCApIHtcbi8vICAgICAgICAgICBjb25zb2xlLmxvZyhmcm9tLCB2YWwpXG4gICAgICAgICAgdDR3YWxrZXIodmFsKVxuICAgICAgICB9XG5cblxuICAgICAgICAvL1tcInVzZXJzXCIsIFwiVV9mZTdjYzgwMDEzNmI3NjA4XCIsIFwiY2xpZW50c1wiLCBcIlZfa3VjbzJ6czJxZlwiXVxuICAgICAgICB2YXIgcCA9IGZyb20mJmZyb20uX3BhdGhcbiAgICAgICAgaWYocCAmJiBwWzBdID09PSAndXNlcnMnICYmIHBbcC5sZW5ndGgtMl0gJiYgcFtwLmxlbmd0aC0yXSA9PT0gJ2NsaWVudHMnICkge1xuICAgICAgICAgIC8vVE9ETzogdmVyeSBkaXJ0eSBmaXghXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignYnJlYWsgaXQgZG93biEnLCBwLCBwLCB2YWwgKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYocCAmJiBwWzBdID09PSAndXNlcnMnICYmIHBbMV0gPT09ICdtZWRpYScpIHtcbiAgICAgICAgICB0aHJvdyhuZXcgRXJyb3IoJ1RISVMgSVMgV1JPTkcgQUJPUlQhLS0tPiBzZXR0aW5nIHVzZXJzLm1lZGlhICcrcC5qb2luKCcuJykpKVxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1RISVMgSVMgV1JPTkcgQUJPUlQhLS0tPiBzZXR0aW5nIHVzZXJzLm1lZGlhJywgcClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG5cbiAgICAgICAgY2xvdWQuc2V0XG4gICAgICAgICggZnJvbS5faGFzaHBhdGhcbiAgICAgICAgLCBbIGZyb20uX3BhdGhcbiAgICAgICAgICAsIGZyb20uX190ID09PSA0ID8geyAgJHBhdGg6IHZhbC5fcGF0aCB9IDogdmFsIC8vJHQ6IDQsXG4gICAgICAgICAgLCBjbG91ZC50aW1lU3RhbXAoKVxuICAgICAgICAgIF1cbiAgICAgICAgKVxuXG4gICAgICB9XG5cbiAgICB9XG5cbiAgfVxuXG59XG5cbkNsb3VkRGF0YS5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdjbG91ZCcsICdkYXRhY2xvdWQnLCAnX2JhdGNoVW5zdWInLCdfY2xvdWRpZ25vcmUnLCAnX2xzdGFtcCcsICckdCcsICckbG9hZGVkJywgJ19mcm9tbGZyb20nKVxuXG5fX3VwZGF0ZSA9IENsb3VkRGF0YS5wcm90b3R5cGUuX191cGRhdGVcblxuQ2xvdWREYXRhLmluamVjdCggcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdC9mbGFncycpIClcblxuQ2xvdWREYXRhLmZsYWdzLiRwYXRoID0ge1xuICByZXNldDp0cnVlLFxuICBzZXQ6IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIHJlc2V0KSB7XG4gICAgXG4gICAgaWYoIHJlc2V0ICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbG91ZCBkYXRhICRwYXRoIGZsYWcgcmVzZXQ/Pz8nKVxuICAgIH1cbiAgXG4gICAgdmFyIHQgPSB0aGlzXG4gICAgaWYoc3RhbXAgIT09IHRoaXMuY2xvdWQuc3RhbXApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignc2V0IHdpdGggJHBhdGggb25seSBhbGxvd2VkIGZyb20gdGhlIGh1YicpXG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSB1dGlsLmNoYW5nZVR5cGUoIHZhbCApXG4gICAgaWYocGF0aC5sZW5ndGgpe1xuICAgICAgLy8gY29uc29sZS5sb2coJ19fX19fX19fX19fICRwYXRoIHNldCcpXG4gICAgICAgLy8gdmFsLCBzZXQsIG5vdHNlbGYsIHN0YW1wIFxuICAgICAgIC8vIG5vdXBkYXRlXG4gICAgICB0aGlzLl8kc2V0VmFsKCB0aGlzLmNsb3VkLmRhdGEuZ2V0KCBwYXRoLCB7fSwgdm9pZCAwLCBzdGFtcCApICxzdGFtcCxmYWxzZSx0cnVlKVxuICAgIH1cblxuICAgIGlmKHRoaXMuX190IT09NCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbG91ZCBkYXRhICRwYXRoIGZsYWcgX190ICE9PSA0JylcbiAgICB9XG5cbiAgfVxufVxuXG5cbnZhciBfc2V0ID0gQ2xvdWREYXRhLnByb3RvdHlwZS5zZXRcblxudmFyIF8kc2V0VmFsID0gQ2xvdWREYXRhLnByb3RvdHlwZS5fJHNldFZhbFxuXG4vL0Nsb3VkRGF0YSBhZGQgZmxhZ3NcblxuLy8oIG5hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tIClcbnV0aWwuZGVmaW5lXG4oIENsb3VkRGF0YVxuLCAnXyRzZXRWYWwnLCBmdW5jdGlvbiggdmFsLCBzdGFtcCApIHtcbiAgIC8vc2V0VmFsXG5cbiAgIC8vIGNvbnNvbGUubG9nKCcuLi4uLi4uLi4uLi4uJywgdGhpcy5fcGF0aCwgc3RhbXAsIHN0YW1wICYmIHRoaXMuY2xvdWQuc3RhbXAgPT09IHN0YW1wKVxuICAgaWYodGhpcy5jbG91ZC5zdGFtcCA9PT0gc3RhbXAgJiYgIXRoaXMuJGxvYWRlZCkge1xuICAgIC8vVE9ETzogZmFzdGVyIHRvIGRvICEgbG9hZGVkXG4gICAgdmFyIHBhcmVudCA9IHRoaXNcbiAgICB3aGlsZShwYXJlbnQgJiYgIXBhcmVudC4kbG9hZGVkKSB7XG4gICAgICBwYXJlbnQuJGxvYWRlZCA9IHRydWVcbiAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50XG4gICAgfVxuICAgfVxuXG4gICBfJHNldFZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgfVxuLCAnc2V0JywgZnVuY3Rpb24obmFtZSwgdmFsLCB2b2JqLCBzdGFtcCl7XG4gIGlmIChzdGFtcCAhPT0gdGhpcy5jbG91ZC5zdGFtcCAmJlxuICAgICAgdGhpcy5fbmFtZSA9PT0gJ2NsaWVudHMnICYmXG4gICAgICAhdGhpc1tuYW1lXSAmJiBcbiAgICAgIG5hbWUgIT09IHRoaXMuY2xvdWQuY2xpZW50aWRcbiAgICAgKSB7XG4gICAgY29uc29sZS5lcnJvcignXFxuXFxuSSBXQU5UIFRPIEJMT0NLIFRISVMgWUEgRFVSSycsXG4gICAgICAnXFxuc3RhbXAgIT09IHRoaXMuY2xvdWQuc3RhbXAnLCBzdGFtcCAhPT0gdGhpcy5jbG91ZC5zdGFtcCxcbiAgICAgIFwiXFxudGhpcy5fbmFtZSA9PT0gJ2NsaWVudHMnXCIsIHRoaXMuX25hbWUgPT09ICdjbGllbnRzJyxcbiAgICAgIFwiXFxuIXRoaXNbbmFtZV1cIiwgIXRoaXNbbmFtZV0sXG4gICAgICBcIlxcbm5hbWUgIT09IHRoaXMuY2xvdWQuY2xpZW50aWRcIiwgbmFtZSAhPT0gdGhpcy5jbG91ZC5jbGllbnRpZFxuICAgIClcbiAgICBkZWJ1Z2dlclxuICAgIC8vIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiBfc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cbiwgJ3VwZGF0ZVF1ZXVlJ1xuLCBmdW5jdGlvbigpIHtcbiAgICAvLyB3aHkgdGhpcz8/P1xuICB9XG4sICdzdGFtcCdcbiwgZnVuY3Rpb24oKXtcbiAgICBpZiggIXRoaXMuY2xvdWQgKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCAnV0FUIE5PIENMT1VEPyEgaW4gdGhpczpcXG4nLCB0aGlzIClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG91ZC50aW1lU3RhbXAoKVxuICB9XG4sICdfX3VwZGF0ZSdcbiwgZnVuY3Rpb24oIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApIHtcblxuICAgIC8vIGlmKHN0YW1wICYmIHRoaXMuX2xzdGFtcCA9PT0gc3RhbXApIHJldHVyblxuXG5cbiAgICAvLyBjb25zb2xlLmxvZyhmcm9tLCAnXFxuJywgdGhpcy5fbGZyb20sIGZyb20sIGZyb20mJmZyb20uX2xmcm9tLl9jYWNoZWRQYXRoLCB0aGlzLl9jYWNoZWRQYXRoLCB0aGlzLl9sZnJvbSlcbiAgICBpZihmcm9tICYmIGZyb20uX2xmcm9tKSB7XG5cbiAgICAgIHRoaXMuX2Zyb21sZnJvbSA9IGZyb20uX2xmcm9tXG4gICAgICAvLyBjb25zb2xlLmVycm9yKHRoaXMuX2Zyb21sZnJvbSlcbiAgICAgIC8vIHJldHVyblxuICAgIH1cblxuICAgIGlmKHRoaXMuX2Zyb21sZnJvbSAmJiB0aGlzLl9mcm9tbGZyb20gPT09IChmcm9tICYmIGZyb20uX2xmcm9tKSAmJiB0aGlzLl9sc3RhbXA9PT1zdGFtcCkge1xuICAgICAgLy9UT0RPOiB0aGlzIGlzIGEgbWVtb3J5IGxlYWsgZ2V0IHJpZCBvZiBpdCBjaXJjIHJlZnMgc2hvdWxkIGJlIHJlc29sdmVkIGZyb20gdm9iaiBpdHNlbGZcbiAgICAgIGRlbGV0ZSB0aGlzLl9mcm9tbGZyb21cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2xzdGFtcCA9IHN0YW1wXG5cbiAgICAvLyBpZih0aGlzLl9wYXRoWzBdPT09J2NsaWVudHMnKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZygnMicsIHRoaXMuX3BhdGgsIHN0YW1wPT09dGhpcy5jbG91ZC5zdGFtcClcbiAgICAvLyB9XG4gICAgLy8gY29uc29sZS5sb2coJzEgbGV0cyBfX3VwZGF0ZScsIHRoaXMuX3BhdGgsIGFyZ3VtZW50cylcbiAgICAvLyBpZiggdGhpcy5faWdub3JlICApIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCcyMSBsZXRzIF9fdXBkYXRlJywgdGhpcy5fcGF0aCwgYXJndW1lbnRzKVxuICAgICAgLy8gZGVsZXRlIHRoaXMuX2lnbm9yZVxuICAgICAgLy8gcmV0dXJuIGZhbHNlXG4gICAgLy8gfVxuICAgIC8vbW9zdCBuZXN0ZWQgdXBkYXRlIGhpZXIgYWRkaXRpb24gbWFrZW4gdm9vciBwcm9jZXNzXG4gICAgLy8gY29uc29sZS5sb2codmFsLCBzdGFtcCwgZnJvbSlcbiAgICAvL2lzIGRpdCBtYXliZSB3ZWlyZD8/P1xuICAgIHJldHVybiBfX3VwZGF0ZS5jYWxsKCB0aGlzLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKVxuICB9XG4sICdfc2V0J1xuLCBmdW5jdGlvbiAodmFsLCBzdGFtcCkge1xuICAgIGlmKCAhc3RhbXAgKSByZXR1cm5cbiAgICBpZiggdGhpcy5fbHN0YW1wID4gc3RhbXAgKVxuICAgIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnbGV0cyBzZXQgaXQhISEnLCB0aGlzLl9wYXRoLCBhcmd1bWVudHMpXG5cbiAgICByZXR1cm4gTmV0d29ya0RhdGEucHJvdG90eXBlLl9zZXQuYXBwbHkoIHRoaXMsYXJndW1lbnRzIClcbiAgfVxuLCAnc3Vic2NyaWJlJ1xuLCBmdW5jdGlvbiggdmFsLCBmcm9tLCBwYXJlbnRGaXhlciApIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3N0YXJ0JylcblxuICAgIGlmKCBmcm9tICYmIGZyb20uY2xvdWQgICYmIGZyb20uX3ZhbCA9PT0gdGhpcyApIHtcblxuICAgICAgICAvL0JVRzogZGl0IGthbiBoZWVsIHZlZWwgYnJva2VuIG1ha2VuISEhISEhIVxuLy8gICAgICAgICBjb25zb2xlLmxvZygnXFxuXFxuSFVSSyEhISEhISBESVQgSVMgVEVNUCBNT0VUIE5JRVQgRUVOIEVYVFJBIFNVQiBHRU1BQUtUIFdPUkRFTiEnIClcblxuICAgICAgICAvLyBmcm9tID0gdm9pZCAwXG5cbiAgICAgICAgLy9UT0RPOiBkaXQgaXMgaGVsZW1hYWwgd3JvbmcgR0VUIFJJRCBPRiBJVCEhISFcbiAgICAgICAgLy8gcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coICdsZXRzIGRvIGl0IHN1YiBzdWInLmN5YW4uaW52ZXJzZSwgdGhpcywgdmFsLCBmcm9tLCBwYXJlbnRGaXhlciApXG4gICAgLy8gaWYoZnJvbSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ0dPVCBGUk9NJywgZnJvbSAsICdTVUJTQ1JJQkUnKVxuICAgIC8vIH1cbiAgICAgaWYgKCF2YWwgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykgeyByZXR1cm47IH1cbiAgICAgLy8gaWYodmFsIGluc3RhbmNlb2Ygdk9iamVjdCkge1xuICAgICAvLyAgICB2YWwgPSB2YWwuZnJvbVxuICAgICAvLyB9XG5cblxuICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGhcbiAgICAgICAsIGVsZW0gPSB2YWxbMV1cbiAgICAgICAsIHN1YlxuICAgICAgICwgcGFydGlhbFN1YlxuICAgICAgICwgc3RyaW5naWZpZWRcbiAgICAgICAsIHN1YnNBcnJheVxuICAgICAgICwgZXhpc3RzXG4gICAgICAgLCBsaXN0ZW5lcnNcbiAgICAgICAsIGZyb21OYW1lXG5cbiAgICAgIHZhciBmb3VuZCA9IHBhdGggJiYgdXRpbC5jaGVja0FycmF5KCBwYXRoICwgJ3VzYWdlJyApXG4gICAgXG5cblxuICAgIC8vIGlmKCBmb3VuZCB8fCBmb3VuZD09PTApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsZXRzIHRyeSB0byBzdWInLCB2YWwgJiYgdmFsLl9wYXRoLCAnOicsIHRoaXMuX3BhdGggKVxuICAgICAgLy8gfVxuICAgXG5cbiAgICAvLyBpZihlbGVtKSB7XG4gICAgLy8gICBjb25zb2xlLmVycm9yKGVsZW0sIGVsZW0uX2NvbCwgZWxlbS5fZGZyb20sIGVsZW0uX2Ztb2RlbClcbiAgICAvLyB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygnU1VCU0NSSUJFJywgZWxlbS5fZGZyb20sIGVsZW0uX2Ztb2RlbCwgJ0RGUk9NLCBGTU9ERUwhJylcblxuICAgIC8vIGlmIChlbGVtICYmICFlbGVtLl9jb2wgJiYgKCFlbGVtLl9kZnJvbSB8fCBlbGVtLl9mbW9kZWwpKSB7XG4gICAgdmFyIGlzRWxlbSA9IChlbGVtICYmICFlbGVtLl9jb2wgJiYgKCFlbGVtLl9kZnJvbSB8fCBlbGVtLl9mbW9kZWwpKVxuXG4gICAgaWYoIGlzRWxlbSAmJiAhZWxlbS5nZXRNb2RlbCkge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignYmUgY2FyZWZ1bGwhIGNsb3VkIGRhdGEgZWxlbSBkb2VzIG5vdCBoYXZlIGdldE1vZGVsJylcbiAgICB9IGVsc2UgaWYoIGlzRWxlbSApIHtcblxuICAgICAgLy8gY29uc29sZS5lcnJvcignWFhYIScpXG4gICAgICAvL2hpZXIgZGluZ2VuIHZpbmRlbiB2b29yXG4gICAgICAvLyBjb25zb2xlLmxvZygnIURGUk9NIScpXG5cbiAgICAvL2lzRWxlbVxuXG4gICAgLy92YWwsIGZyb20sIHBhcmVudEZpeGVyXG5cbiAgICAvLyBpZih2YWxbM10gJiYgdmFsWzNdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAvLyAgICAgICBjb25zb2xlLmxvZyggJ1lFUyEhIScgKVxuXG4gICAgLy8gfVxuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coICchISEhISExMTExMTEnLCBhcmd1bWVudHMsIHZhbFszXSwgZnJvbSwgcGFyZW50Rml4ZXIsIHRoaXMsIHBhdGggKVxuXG4gICAgdmFyIGZpZWxkaWdub3JlXG4gICAgaWYoIHZhbFsxXS5faWdub3JlRmllbGRJblN1YnNjcmlwdGlvbiApIHtcbiAgICAgIC8vIGFsZXJ0KCchJyt2YWxbM10pXG4gICAgICBpZighdmFsWzNdKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdGSUVMRElHTk9SRScuYmx1ZS5pbnZlcnNlLCB2YWwsIHRoaXMsIHBhdGggKVxuICAgICAgICAvLyBkZWJ1Z2dlclxuXG4gICAgICAgIC8vIGlmKGZpKVxuXG4gICAgICAgIGZpZWxkaWdub3JlID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vVE9ETzogaGFzIHRvIGJlY29tZSB2YWxbMl0hISFcbiAgICAvL3R5cGVvZiBmcm9tID09PSAnc3RyaW5nJyA/IGZyb20gOlxuICAgICAgLy9kaXQgaXMgbmlldCBnb2VkISEhIVxuICAgICAgZnJvbU5hbWUgPSB2YWxbM11cblxuICAgIC8vIGNvbnNvbGUubG9nKCAnLS0tLS0tLS0yMiEhISEhITExMTExMScsIHBhcnRpYWxTdWIsIHZhbFszXSwgJ1xcblxcbj8nLCB2YWxbM10uX25hbWUgIClcblxuICAgICAgLy92YWxbM10gaW5zdGFuY2VvZiBEYXRhXG4gICAgICBwYXJ0aWFsU3ViID0gZWxlbS5nZXRNb2RlbCggdGhpcywgIHZhbFszXSAsIGZpZWxkaWdub3JlIClcbiAgICAgIC8vIGNvbnNvbGUuY2xlYXIoKVxuICAgIC8vIGNvbnNvbGUubG9nKCAnLS0tLSEhISEhITExMTExMScsIHBhcnRpYWxTdWIgKVxuICAgICAgLy8gaWYocGFydGlhbFN1YiAmJiBwYXJ0aWFsU3ViLnNwZWNpYWxGaXgpIHtcbiAgICAgIC8vICAgY29uc29sZS5sb2coJ0xFVFMgRE8gSVQgSVRJIElUJywgcGFydGlhbFN1YiwgcGFydGlhbFN1Yi5zcGVjaWFsRml4LCBwYXRoKVxuICAgICAgICBcbiAgICAgIC8vICAgLy8gaWYocGFydGlhbFN1Yi5zcGVjaWFsRml4IGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cbiAgICAgIC8vICAgLy8gICBjb25zb2xlLmxvZyggcGF0aCwgcGFydGlhbFN1Yi5zcGVjaWFsRml4LCBwYXJ0aWFsU3ViIClcbiAgICAgIC8vICAgLy8gICBpZihwYXRoW3BhdGgubGVuZ3RoLTFdID09PSBwYXJ0aWFsU3ViLnNwZWNpYWxGaXhbMF0pIHtcblxuICAgICAgLy8gICAvLyAgICAgaWYocGFydGlhbFN1Yi4kICYmIHBhcnRpYWxTdWIuJFtwYXJ0aWFsU3ViLnNwZWNpYWxGaXhbMV1dKSB7XG4gICAgICAvLyAgIC8vICAgICAgICAgY29uc29sZS5sb2coJ2RvIGl0IScpXG4gICAgICAvLyAgIC8vICAgICAgICAgcGFydGlhbFN1YiA9IHBhcnRpYWxTdWIuJFtwYXJ0aWFsU3ViLnNwZWNpYWxGaXhbMV1dXG4gICAgICAvLyAgIC8vICAgICB9XG5cbiAgICAgIC8vICAgLy8gICB9XG5cbiAgICAgIC8vICAgLy8gfSBlbHNlIFxuXG4gICAgICAvLyAgIGlmKHBhdGhbcGF0aC5sZW5ndGgtMV09PT1wYXJ0aWFsU3ViLnNwZWNpYWxGaXgpIHtcbiAgICAgIC8vICAgICBwYXRoLnBvcCgpXG4gICAgICAvLyAgIH1cbiAgICAgICAgXG4gICAgICAvLyAgIGRlbGV0ZSBwYXJ0aWFsU3ViLnNwZWNpYWxGaXhcbiAgICAgIC8vIH1cblxuICAgICAgLy8gY29uc29sZS5sb2coJ0xFVFMgRE8gSVQgSVRJIElUJy5ncmVlbi5pbnZlcnNlLCBwYXJ0aWFsU3ViKVxuXG4gICAgICAvLyBwYXJ0aWFsU3ViLkRFQlVHJGxvZygncGFydGlhbCcpXG5cbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIERhdGEgJiYgdmFsLl9fc3ViKSB7XG4gICAgLy9pc0RhdGErU3Vic2NyaXB0aW9uXG4gICAgICAvL2RpdCBtb2V0IG9vayBnZWZpeGVkISEhISEhISEhXG4gICAgICBwYXJ0aWFsU3ViID0gbmV0d29ya0RhdGFFbGVtZW50LnBhcnNlRGF0YSh2YWwpXG5cbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIHZPYmplY3QgKSB7XG4gICAgLy92T2JqZWN0XG4gICAgICBsaXN0ZW5lcnMgPSB2YWwuX2xpc3RlbmVyc1xuXG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9wYXRoLCAnTElTVEVORVInLCBmcm9tIClcblxuICAgICAgaWYobGlzdGVuZXJzKSB7XG4gICAgICAgIGZvciggdmFyIGxpc3RlbmVyJD0wLCBsZW4kPWxpc3RlbmVycy5sZW5ndGg7IGxpc3RlbmVyJDxsZW4kOyBsaXN0ZW5lciQrKyApIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnISEhISEhISEhISEgbGlzdG5lciQzMzMzMzMnLnJlZC5pbnZlcnNlLCBsaXN0ZW5lcnNbbGlzdGVuZXIkXSlcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLS0+Jyx0aGlzLl9wYXRoLCAnTElTVEVORVIsICcgLCBsaXN0ZW5lcnNbbGlzdGVuZXIkXS5fcGF0aCwgdmFsKVxuICAgICAgICAgIHRoaXMuc3Vic2NyaWJlKCBsaXN0ZW5lcnNbbGlzdGVuZXIkXSwgdmFsIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZih2YWwuX3BhcmVudCAmJiAhdmFsLl9wYXJlbnQuY2xvdWQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3BhcmVudCcsdmFsLl9wYXJlbnQsIHZhbC5fcGFyZW50Ll9saXN0ZW5lcnMpXG4gICAgICAvLyAgIGxpc3RlbmVycyA9IHZhbC5fcGFyZW50Ll9saXN0ZW5lcnNcblxuICAgICAgLy8gICAvLyB2YWwuX3BhXG4gICAgICAvLyAgIGlmKGxpc3RlbmVycykge1xuICAgICAgLy8gICAgIGZvciAodmFyIGxpc3RlbmVyJD0wLCBsZW4kPWxpc3RlbmVycy5sZW5ndGg7IGxpc3RlbmVyJDxsZW4kOyBsaXN0ZW5lciQrKykge1xuICAgICAgLy8gICAgICAgdGhpcy5zdWJzY3JpYmUobGlzdGVuZXJzW2xpc3RlbmVyJF0sIGZhbHNlLCB0cnVlKVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh2YWwgJiYgdXRpbC5pc09iaih2YWwpICYmICEodmFsIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAvL2lzTm9ybWFsU3Vic2NyaXB0aW9uXG4gICAgICAvLyBjb25zb2xlLmxvZygnSVMgT0JKJy5jeWFuKVxuICAgICAgcGFydGlhbFN1YiA9IHZhbFxuICAgICAgdmFsID0gSlNPTi5zdHJpbmdpZnkodmFsKVxuICAgIH1cblxuICAgIGlmIChwYXJ0aWFsU3ViKSB7XG5cbiAgICAgLy9pZiEgZW1wdHlcbiAgICAgLy8gY29uc29sZS5sb2coJzIgTEVUUyBETyBJVCBJVEkgSVQgMicsdGhpcyAsIHBhdGgsICdmcm9tOicsIGZyb20sICdzdWI6JywgbmV0d29ya0RhdGFFbGVtZW50LnBhcnNlRGF0YShmcm9tLCBwYXJ0aWFsU3ViLCB0aGlzLl9zdWJzICkgKVxuXG4gICAgIHZhciBmcm9tQ2hlY2tcbiAgICAgaWYoZnJvbSkgcGFydGlhbFN1YiA9IG5ldHdvcmtEYXRhRWxlbWVudC5wYXJzZURhdGEoZnJvbSwgcGFydGlhbFN1YiwgdGhpcy5fc3VicylcbiAgICAgIC8vZGUgY2hlY2sgbW9ldCBudSBpbiBmcm9tIGdlYmV1cmVuXG4gICAgICAvLyBjb25zb2xlLmxvZygnLnN1YnNjcmliZSBjbG91ZC5kYXRhIHBhcnRpYWxTdWIgYXJlIHdlIHN1cmUgdGhpcyBpcyBmcm9tIGEgcmVmIGluIHRoZSBjbG91ZCcuYmx1ZS5pbnZlcnNlLCBwYXJ0aWFsU3ViLCBwYXRoKSAvL3JlcGxhY2UgL3cgZnJvbVxuXG4gICAgICBpZihmcm9tICYmIGZyb20uY2xvdWQgJiYgZnJvbS5fdmFsID09PSB0aGlzKSB7XG4gICAgICAgIHBhdGggPSBmcm9tLl9wYXRoIC8vaWYgZnJvbSBpcyBjbG91ZFxuICAgICAgICAvLyBhbGVydCgnIScpXG4gICAgICAgIGZyb21DaGVjayA9IHRydWVcbiAgICAgICAgLy8gY29uc29sZS53YXJuKCdkbyBub3RoaW5nIHByb3AgZnJvbSBjbG91ZCcsIGZyb20pXG4gICAgICB9XG5cbiAgICAgc3ViID0gY3JlYXRlU3ViKHBhdGgsIHt9LCBwYXJ0aWFsU3ViKVxuICAgICBzdHJpbmdpZmllZCA9IEpTT04uc3RyaW5naWZ5KHN1YilcblxuICAgICB2YXIgc3Vic3RhcmdldCA9ICBmcm9tQ2hlY2sgPyBmcm9tIDogdGhpc1xuXG4gICAgIGlmKCFzdWJzdGFyZ2V0Ll9zdWJzKSBzdWJzdGFyZ2V0Ll9zdWJzID0gW11cbiAgICAgaWYoZWxlbSkgZWxlbS5fc3Vic2NyaWJlZCA9IHRydWVcbiAgICAgLy8gY29uc29sZS5sb2coJzNMRVRTIERPIElUIElUSSBJVCAzJy5yZWQuaW52ZXJzZSwgbmV0d29ya0RhdGFFbGVtZW50LnBhcnNlRGF0YShmcm9tLCBwYXJ0aWFsU3ViKSApXG5cbiAgICAgIHN1YnNBcnJheSA9IFsgcGFydGlhbFN1YiwgZWxlbSB8fCB2YWwgLCBzdHJpbmdpZmllZCBdXG5cbiAgICAgIGlmKGZyb21OYW1lKSB7XG4gICAgICAgIHN1YnNBcnJheS5wdXNoKGZyb21OYW1lKVxuICAgICAgfVxuXG4gICAgICBleGlzdHMgPSB1dGlsLmNoZWNrQXJyYXkoIHN1YnN0YXJnZXQuX3N1YnMsIHN0cmluZ2lmaWVkLCAyKVxuICAgICAgLy9tYXliZSBjaGVjayBpZiB2YWwgYWxyZWFkeSBleGlzdHNcbiAgICAgIC8vIGNvbnNvbGUubG9nKCcgVEVTVCBUUlVFIC0tLS0tIFNVQlNDUklCRScsIGZyb20sIGV4aXN0cywgdGhpcy5fc3Vicywgc3RyaW5naWZpZWQsIHBhcnRpYWxTdWIsIHN1YiApXG4gICAgICAvL1RPRE86IGNoZWNrIGlmIG5vdCBleGlzdHMgc3Vic0FycmF5IGVhY2ggZmllbGRcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdQVVNIISBTVUJTJy5ncmVlbi5pbnZlcnNlLCBzdWJzQXJyYXkgLHN0cmluZ2lmaWVkLCBleGlzdHMgKVxuICAgICAgdmFyIHNhbWVcbiAgICAgIGZvcih2YXIgaSBpbiBzdWJzdGFyZ2V0Ll9zdWJzICkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHN1YnN0YXJnZXQuX3N1YnNbaV0sIGksIHN1YnN0YXJnZXQuX3BhdGgpXG4gICAgICAgIC8vY29tcGFyZSBvYmplY3RzXG5cbiAgICAgICAgaWYoIHN1YnN0YXJnZXQuX3N1YnNbaV1bMV0gPT09IChlbGVtIHx8IHZhbCkgJiYgc3Vic3RhcmdldC5fc3Vic1tpXVsyXSA9PT0gc3RyaW5naWZpZWQgKSB7XG4gICAgICAgICAgLy9kaXN0aW5jYXRpb24hISEhXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1RIRSBTQU1FJy5jeWFuLmludmVyc2UpXG4gICAgICAgICAgc2FtZSA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmKCFzYW1lKSB7XG4gICAgICBzdWJzdGFyZ2V0Ll9zdWJzLnB1c2goIHN1YnNBcnJheSApXG4gICAgICAgIC8vanVzdCBkb250IHN1YnNjcmliZSAtLS1cbiAgICAgICAgaWYgKCBleGlzdHM9PT1mYWxzZSApIHtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcgVFJVRSAtLS0tLSBTVUJTQ1JJQkUnLCBKU09OLnN0cmluZ2lmeShzdWIsZmFsc2UsMikgKVxuICAgICAgICAgIHRoaXMuY2xvdWQuc3Vic2NyaWJlKHN1Yiwgc3RyaW5naWZpZWQpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCdBTExSRUFEWSBFWElTVFMhJywgc3ViLCBzdHJpbmdpZmllZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9XG4sICd1bnN1YnNjcmliZSdcbiwgZnVuY3Rpb24oIHZhbCwgZnJvbSApIHtcblxuICAgIC8vdG9kbzogZG91YmxlIGNoZWNrIGlmIHRoaXMgZ29lcyB3ZWxsXG4gICAgLy8gY29uc29sZS5lcnJvcignMXVuc3Vic2NyaWJlIScpXG5cbiAgICAvL2RvdW5kbGUgcmVtb3ZlXG5cbiAgICBpZiBcbiAgICAoICF2YWxcbiAgICAgIHx8IHZhbC5fY29sXG4gICAgICB8fCAodmFsLl9maWx0ZXIgJiYgdmFsLl9maWx0ZXIuX2NvbClcbiAgICAgIHx8ICEoIXZhbC5fZGZyb20gfHwgdmFsLl9mbW9kZWwpXG4gICAgKSBcbiAgICB7IFxuICAgICAgcmV0dXJuIFxuICAgIH1cblxuICAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGhcbiAgICAgICAsIHN0cmluZ2lmaWVkXG4gICAgICAgLCBzdWJzQXJyYXlcbiAgICAgICAsIHN1YlxuICAgICAgICwgZXhpc3RzXG4gICAgICAgLCBwYXJ0aWFsU3ViXG4gICAgICAgLCBpbmRleFxuICAgICAgICwgZmllbGRcbiAgICAgICAsIGxpc3RlbmVycyA9IHZhbC5fbGlzdGVuZXJzXG5cbiAgICAvLyBjb25zb2xlLmxvZygndW5zdWJzY3JpYmxleCcsJ3BhdGg6Jy5ibHVlLCBwYXRoLCAnc3RyaW5naWZpZWQ6Jy5ibHVlLCAgc3ViLCAndGhpczonLmJsdWUsdGhpcywgJ3ZhbDonLmJsdWUsIHZhbCwgJ2Zyb206Jyxmcm9tIClcblxuICAgIGlmICggdXRpbC5pc09iaiggdmFsICkgJiYgISggdmFsIGluc3RhbmNlb2YgQXJyYXkgKSApIHZhbCA9IEpTT04uc3RyaW5naWZ5KCB2YWwgKVxuXG4gICAgaW5kZXggPSB0aGlzLl9zdWJzICYmIHV0aWwuY2hlY2tBcnJheSggdGhpcy5fc3VicywgdmFsLCAxIClcbiAgICAvL25pZXQgYWxsZSAxJ3Mgd2VnaGFsZW5cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndW5zdWJzPz8/Pz8/Jy5yZWQuaW52ZXJzZSwgdXRpbC5jbG9uZSh0aGlzLl9zdWJzKSwgdmFsLCBpbmRleCwgdGhpcyApXG4gICAgICAgIC8vbWlzc2luZyBpbmRleCFcblxuXG4gICAgaWYgKCBpbmRleCE9PWZhbHNlICYmIGluZGV4ICE9PSB2b2lkIDAgKSB7XG5cblxuXG5cbiAgICAgIGlmKHZhbC5tb2RlbCAmJiB2YWwubW9kZWwucGFyc2luZykge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdNT0RFTCB1bnN1YnM/Pz8/Pz8nLnJlZC5pbnZlcnNlKVxuICAgICAgICAvLyB2YXIgcmVtb3ZlSVxuXG4gICAgICAgIC8vYmxvY2sgdW5zdWJzIG9uIG1vZGVsIHBhcnNpbmdcbiAgICAgICAgaWYodmFsLm1vZGVsICYmIHZhbC5tb2RlbC5maWVsZCApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmNsZWFyKClcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnV0FSTiEgdW5zdWJzIGZpZWxkIFdBUk4hJy5yZWQuaW52ZXJzZSwgZnJvbSwgdGhpcy5fc3Vic1tpbmRleF0gKVxuXG4gICAgICAgICAgLy9yZWFwcGx5IGlmIGZpZWxkXG4gICAgICAgICAgZmllbGQgPSB0aGlzLmdldCh2YWwubW9kZWwuZmllbGQudmFsKVxuICAgICAgICAgIGlmKCFmaWVsZC5fc3VicykgZmllbGQuX3N1YnMgPSBbXVxuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1dBUk4hIHVuc3VicyBmaWVsZCBXQVJOIScucmVkLmludmVyc2UsZmllbGQ9PT10aGlzLCBmaWVsZCwgZnJvbSwgdGhpcy5fc3Vic1tpbmRleF0gKVxuXG5cbiAgICAgICAgICB2YXIgX19zdWJzID0gdXRpbFxuICAgICAgICAgICAgLmdldCggdGhpcy5fc3Vic1tpbmRleF1bMF0sIHZhbC5tb2RlbC5maWVsZC52YWwgKVxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJ3N1YnNbMF0nLmJsdWUsICB0aGlzLl9zdWJzW2luZGV4XVswXSApXG5cbiAgICAgICAgICBpZiggX19zdWJzICkge1xuICAgICAgICAgIHRoaXMuX3N1YnNbaW5kZXhdWzBdID0gX19zdWJzXG4gICAgICAgICAgLy8gZmllbGQuX3N1YnMucHVzaCh0aGlzLl9zdWJzW2luZGV4XSlcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVNT1ZFIFNVQlMgYW5kIHB1c2gnLnJlZC5pbnZlcnNlLCBpbmRleCxmaWVsZC5fc3VicywgX19zdWJzLCB0aGlzLl9zdWJzW2luZGV4XSwgdGhpcy5fcGF0aClcbiAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAgIC8vIHRoaXMuX3N1YnMuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd3YXJuJy5yZWQpXG5cbiAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBfX3N1YnMgKVxuXG5cbiAgICAgICAgIFxuICAgICAgICAgIC8vZGl0IGZmIGJldGVyIGRvZW4gKG1lZXJkZXJlIF9zdWJzKVxuICAgICAgICAgIC8vdGVsIGNvdW50c1xuICAgICAgICAgIFxuICAgICAgICAgIC8vdm9vciBkZXplIHNwbGljZSBjaGVjayBvcCBpbmRleCBlbiBzdHJpbmdpZmllZCFcblxuICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgc3Vic0FycmF5ID0gdGhpcy5fc3Vic1tpbmRleF1cbiAgICAgIHN0cmluZ2lmaWVkID0gc3Vic0FycmF5WzJdXG4gICAgICBwYXJ0aWFsU3ViID0gc3Vic0FycmF5WzBdXG4gICAgICAvLyBpZihmcm9tKSBwYXJ0aWFsU3ViID0gbmV0d29ya0RhdGFFbGVtZW50LnBhcnNlRGF0YShmcm9tLCBwYXJ0aWFsU3ViKVxuXG4gICAgICAvLyBjb25zb2xlLmxvZyggJ3BhcnRpYWxTdWInLmludmVyc2UsIHBhcnRpYWxTdWIgKVxuXG4gICAgICBzdWIgPSBjcmVhdGVTdWIocGF0aCwge30sIHBhcnRpYWxTdWIpXG5cbiAgICAgIC8vdm9vciBkZXplIHNwbGljZSBjaGVjayBvcCBpbmRleCBlbiBzdHJpbmdpZmllZCFcbiAgICAgIC8va2FuIGR1cyBvb2sgZWZmaWNpZW50ZXJcbiAgICAgIC8vIGlmKCByZW1vdmVJICE9PSB2b2lkIDAgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUnLCBpbmRleClcbiAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgU1VCUycucmVkLmludmVyc2UsIGluZGV4LCB0aGlzLl9zdWJzLCB0aGlzLl9wYXRoIClcbiAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICB0aGlzLl9zdWJzLnNwbGljZShpbmRleCwgMSlcblxuICAgICAgLy8gfVxuXG5cblxuICAgICAgZXhpc3RzID0gdXRpbC5jaGVja0FycmF5KHRoaXMuX3N1YnMsIHN0cmluZ2lmaWVkLCAyKVxuXG4gICAgICBpZihleGlzdHMhPT1mYWxzZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnRVhJU1RTPz8/PycuY3lhbi5pbnZlcnNlLCBleGlzdHMsIHN0cmluZ2lmaWVkLCB0aGlzLl9zdWJzLCB0aGlzLl9wYXRoLCB0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJyFFWElTVFMnICwgZXhpc3RzLCBzdHJpbmdpZmllZClcbiAgICAgIH1cblxuICAgICAgaWYgKCBleGlzdHMgPT09IGZhbHNlICkgdGhpcy5jbG91ZC51bnN1YnNjcmliZShzdWIsIHN0cmluZ2lmaWVkKVxuICAgICAgICAvLyB0aGlzLl9zdWJzUkFGLnB1c2goW3N1Yiwgc3RyaW5naWZpZWRdKVxuICAgICAgICAvLyB0aGlzLl9zdWJzUkFGID0gW10gc2VhcmNoICYgcmVtb3ZlIHVzZSBkaWZmZXJlbnQgaWRlbnRpZmllcnMgZS5nLiBzdWJzIGFycmF5XG5cbiAgICB9IGVsc2UgaWYoIHZhbC5fcmVtb3ZlZCApIHtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Vuc3Vicz8/MjIyMjI/Pz8/IDIyMjIyMjInLnJlZC5pbnZlcnNlKVxuXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdpcyB0aGlzIHJlYWxseSBuZXNzZWNhcnk/IF9yZW1vdmVkICwgZnJvY2UgYWxsIGxpc3RlbmVycyByZW1vdmUgdGFnZXRzIGV0YycpXG4gICAgfSBlbHNlIGlmKGxpc3RlbmVycykge1xuXG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndW5zdWJzPz8zMzMzMzMzMzM/Pz8/IDIyMjIyMjInLnJlZC5pbnZlcnNlKVxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnLS0tLT4gdGhpcyBpcyBhbHNvIHByZXR0eSBkaWZmZXJlbnQhIF9saXN0ZW5lcnMnKVxuICAgICAgZm9yICh2YXIgbGlzdGVuZXIkPTAsIGxlbiQ9bGlzdGVuZXJzLmxlbmd0aDsgbGlzdGVuZXIkPGxlbiQ7IGxpc3RlbmVyJCsrKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcnNbbGlzdGVuZXIkXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZShsaXN0ZW5lcnNbbGlzdGVuZXIkXVsxXSwgdmFsKVxuICAgICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyc1tsaXN0ZW5lciRdLl9fdCkge1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUobGlzdGVuZXJzW2xpc3RlbmVyJF0sIHZhbClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gIH1cbilcbiIsIm1vZHVsZS5leHBvcnRzID0gRGF0YUNsb3VkXG5cbnZhciB0aW1lc3RhbXAgPSByZXF1aXJlKCdtb25vdG9uaWMtdGltZXN0YW1wJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL29iamVjdCcpLFxuICBDbG91ZERhdGEgPSByZXF1aXJlKCcuL2RhdGEnKSxcbiAgVk9iamVjdCA9IHJlcXVpcmUoJy4uLy4uLy4uL29iamVjdCcpLFxuICBCYXRjaCA9IFZPYmplY3QubmV3KHtcbiAgICBtZXJnZTogdHJ1ZVxuICB9KSxcbiAgQ2xvdWRTdGF0ZSA9IFZPYmplY3QubmV3KHtcbiAgICBtZXJnZTogdHJ1ZVxuICB9KSxcbiAgbWFrZUhhc2ggPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL2hhc2gnKSxcbiAgYmF0Y2h0aW1lID0gMjAsXG4gIFNVQlMgPSAnc3VicycsXG4gIFNFVFMgPSAnc2V0cycsXG4gIFVOU1VCUyA9ICd1bnN1YnMnXG5cbmZ1bmN0aW9uIERhdGFDbG91ZCAoKSB7XG4gIC8vIHdpbmRvdy5kYXRhY2xvdWQgPSB0aGlzXG4gIHZhciBjbG91ZCA9IHRoaXNcbiAgY2xvdWQuX2pvaW5zID0ge31cbiAgY2xvdWQuX3N0YXR1cyA9IDFcblxuICBjbG91ZC5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCctLS0tIGNsb3VkIGNvbm5lY3QgPj4gY2xvdWQuX3N0YXR1cysrIGNhbGwgX3JlY29ubmVjdCcpXG4gICAgY2xvdWQuX3N0YXR1cysrXG4gICAgY2xvdWQuX3JlY29ubmVjdCgpXG4gIH0pXG5cbiAgLy8gY29uc29sZS5sb2coJ3N0YXJ0IG1ha2luZyBzdGF0ZScpXG4gIGNsb3VkLnN0YXRlID0gbmV3IENsb3VkU3RhdGUoe1xuICAgICAgICBzdWJzOiB7XG4gICAgICAgICAgbWFwOiB7fSxcbiAgICAgICAgICB0cmVlOiB7fVxuICAgICAgICB9LFxuICAgICAgICBzZXRzOiB7XG4gICAgICAgICAgbWFwOiB7fSAvKiwgbGlzdDpbXSovXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vICwgeyBsb2NhbHN0b3JhZ2U6ICdWQyQnIH1cbiAgICApXG4gICAgLy8gY29uc29sZS5sb2coJ2RvbmUgbWFraW5nIHN0YXRlJywgSlNPTi5zdHJpbmdpZnkoY2xvdWQuc3RhdGUucmF3LGZhbHNlLDIpKVxuXG4gIGlmICghY2xvdWQuc3RhdGUuc2V0cy5saXN0KSBjbG91ZC5zdGF0ZS5zZXRzLnNldCgnbGlzdCcsIFtdKVxuICAgIC8vIF5eIHNldCBtZXQgbGVnZSBhcnJheSBtZXJnZWQgbmlldFxuXG4gIGNsb3VkLmJhdGNoID0ge1xuICAgIG1hcHM6IHtcbiAgICAgIHNldHM6IHt9LFxuICAgICAgc3Viczoge30sXG4gICAgICB1bnN1YnM6IHt9XG4gICAgfVxuICB9XG5cbiAgLy8gY29uc29sZS5sb2coJy0tLS0tLVNFVCBDIERBVEEnKVxuXG4gIGNsb3VkLmRhdGEgPSBuZXcgQ2xvdWREYXRhKHt9LCBmYWxzZSAvL3tsb2NhbHN0b3JhZ2U6J2Nsb3VkRGF0YSd9XG4gICAgLCBmYWxzZSwgdGhpcylcblxuICAvLyBjb25zb2xlLmxvZygnLS0tLS0tTE9HJylcblxuXG4gIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KCBjbG91ZC5kYXRhLnJhdyxmYWxzZSwyKSlcbiAgLy8gXl4gZGl0IGthbiBkb29yIHdlaXJkZSBzaGl0IGluIGxvY2FsU3RvcmFnZSBkZSBjb25zdHJ1Y3RvciBsYXRlbiBrYXBwZW4hXG5cbiAgLy8gY2xvdWQub24oJ2luY29taW5nOjpwb25nJywgdGhpcy5fY2xlYXJDYWNoZSlcbiAgLy8gY2xvdWQub24oJ2RhdGEnLCB0aGlzLl9jbGVhckNhY2hlKVxuXG4gIGNsb3VkLl9xVGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiBfcVRpbWVyICgpIHtcbiAgICBjbG91ZC5fZG9CYXRjaCgpXG4gIH0sIGJhdGNodGltZSlcblxuXG4gIC8vIGNsb3VkLm9uKCd3ZWxjb21lJywgZnVuY3Rpb24gb25XZWxjb21lKCl7XG5cbiAgLy8gfSlcblxuICBjbG91ZC5vbignc3Vic2NyaWJlZCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCc+Pj4gSGV5IENsb3VkIHNheXMgaW0gc3Vic2NyaWJlZCB0bycsIG1zZylcbiAgfSlcblxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLnRpbWVTeW5jID0gZnVuY3Rpb24gdGltZVN5bmMgKCkge1xuICAvLyBjb25zb2xlLmxvZygndGltZVN5bmMhJylcbiAgdmFyIGNsb3VkID0gdGhpcyxcbiAgICBvdXRzdGFtcCA9IERhdGUubm93KClcbiAgY2xvdWQuZW1pdCgndGltZScsIGZ1bmN0aW9uIChjbG91ZHN0YW1wKSB7XG5cbiAgICB2YXIgdHJhdmVsdGltZSA9IERhdGUubm93KCkgLSBvdXRzdGFtcCxcbiAgICAgIGFycml2YWwgPSBvdXRzdGFtcCArIHRyYXZlbHRpbWUgLyAyLFxuICAgICAgb2Zmc2V0ID0gY2xvdWRzdGFtcCAtIGFycml2YWxcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lc3RhbXAgaW4nLCB0cmF2ZWx0aW1lLCAnb2Zmc2V0Jywgb2Zmc2V0KVxuICAgIGlmICh0cmF2ZWx0aW1lIDwgY2xvdWQuX3RpbWVUcmF2ZWwpIHtcbiAgICAgIGNsb3VkLl90aW1lVHJhdmVsID0gdHJhdmVsdGltZVxuICAgICAgY2xvdWQuX3RpbWVPZmZzZXQgPSBvZmZzZXRcbiAgICB9XG4gICAgdmFyIHRyaWVzID0gY2xvdWQuX3RpbWVUcmllcysrXG4gICAgICBpZiAodHJhdmVsdGltZSA+IDc1ICYmIHRyaWVzIDwgMTAgfHwgdHJhdmVsdGltZSA+IDUwICYmIHRyaWVzIDwgNSB8fCB0cmF2ZWx0aW1lID4gMjAgJiYgdHJpZXMgPCAyKSB7XG4gICAgICAgIGNsb3VkLnRpbWVTeW5jKClcbiAgICAgIH1cbiAgfSlcbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS5vdXRMaXN0ID0gZnVuY3Rpb24gKGxhYmVsKSB7XG4gIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2hcbiAgaWYgKCFiYXRjaC5saXN0cykge1xuICAgIGJhdGNoLmxpc3RzID0ge31cbiAgICByZXR1cm4gYmF0Y2gubGlzdHNbbGFiZWxdID0gW11cbiAgfSBlbHNlIGlmICghYmF0Y2gubGlzdHNbbGFiZWxdKSB7XG4gICAgcmV0dXJuIGJhdGNoLmxpc3RzW2xhYmVsXSA9IFtdXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhdGNoLmxpc3RzW2xhYmVsXVxuICB9XG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUuX2RvQmF0Y2ggPSBmdW5jdGlvbiBfZG9CYXRjaCAoKSB7XG4gIHZhciBjbG91ZCA9IHRoaXMsXG4gICAgb3V0ID0gY2xvdWQuYmF0Y2gubGlzdHNcblxuICBpZiAob3V0KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2VtaXQgZGF0IGJhdGNoIG91dCEnKVxuICAgIC8vIGNvbnNvbGUubG9nKCdFTUlUVElORyEnLG91dClcbiAgICAvLyBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyl7XG4gICAgLy8gICBjb25zb2xlLmxvZygnd3JpdGluZyBvdXQnLCBKU09OLnN0cmluZ2lmeShvdXQpLnNsaWNlKDAsNTApKVxuICAgIC8vICAgY29uc29sZS5ncm91cENvbGxhcHNlZCgpXG4gICAgLy8gICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShvdXQsZmFsc2UsMikpXG4gICAgLy8gICBjb25zb2xlLmdyb3VwRW5kKClcbiAgICAvLyB9XG4gICAgY2xvdWQuZW1pdCgnYmF0Y2gnLCBvdXQpXG4gICAgICAvLyBjbG91ZC53cml0ZShvdXQpXG4gICAgICAvLyBjYWNoZSBzZXRzIHVudGlsbCBuZXh0IGhlYXJ0YmVhdFxuICAgICAgLy8gdmFyIHNldHNsaXN0ID0gb3V0LnNldHNcbiAgICAgIC8vIGlmKHNldHNsaXN0KSB7XG4gICAgICAvLyAgIHZhciBjYWNoZSA9IGNsb3VkLnN0YXRlLnNldHNcbiAgICAgIC8vICAgICAsIHNldHNtYXAgPSBjbG91ZC5iYXRjaC5tYXBzLnNldHNcblxuICAgIC8vICAgZm9yKHZhciBoYXNoIGluIHNldHNtYXApIHtcbiAgICAvLyAgICAgdmFyIHVwZGF0ZSA9IHNldHNtYXBbaGFzaF0udXBkYXRlXG4gICAgLy8gICAgIGlmKHVwZGF0ZVsxXSA9PT0gbnVsbClcbiAgICAvLyAgICAgICB1cGRhdGVbMV0gPSAnJCRudWxsJ1xuICAgIC8vICAgICBzdG9yZVNldChoYXNoLCB1cGRhdGUsIGNhY2hlLmxpc3QsIGNhY2hlLm1hcClcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gICAgY2xvdWQuYmF0Y2gubGlzdHMgPSBudWxsXG4gICAgY2xvdWQuYmF0Y2gubWFwcyA9IHtcbiAgICAgIHN1YnM6IHt9LFxuICAgICAgc2V0czoge30sXG4gICAgICB1bnN1YnM6IHt9XG4gICAgfVxuICB9XG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUuX2NsZWFyQ2FjaGUgPSBmdW5jdGlvbiBfY2xlYXJDYWNoZSAoKSB7XG4gIC8vIGlmKHRoaXMuc3RhdGUuc2V0cy5saXN0Lmxlbmd0aCl7XG4gIC8vICAgdGhpcy5zdGF0ZS5zZXRzLnJlbW92ZSgpXG4gIC8vICAgdGhpcy5zdGF0ZS5zZXQoJ3NldHMnLCB7bWFwOnt9LGxpc3Q6W119KVxuICAvLyB9XG4gIC8vIGNvdWxkIGJlIG5pY2VyIGlmIHdlIGhhdmUgYSBnb29kIHdheSBvZiBjbGVhcmluZyBhcnJheXNcbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUgKHN1YnNvYmosIHN0cikge1xuICAvLyBjb25zb2xlLmxvZygnc3Vic2NyaWJlIScsIHN0cilcbiAgdmFyIGNsb3VkID0gdGhpcyxcbiAgICBzdGF0ZSA9IGNsb3VkLnN0YXRlLFxuICAgIGhhc2gsIGNhY2hlZFxuXG4gIGlmIChzdWJzb2JqLmhhc2ggJiYgc3Vic29iai5zdWJzb2JqKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2RhcyBjYWNoZWQhJylcbiAgICBoYXNoID0gc3Vic29iai5oYXNoXG4gICAgY2FjaGVkID0gc3Vic29ialxuICB9IGVsc2Uge1xuICAgIGlmICghc3RyKVxuICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkoc3Vic29iailcbiAgICBoYXNoID0gbWFrZUhhc2goc3RyKVxuICAgIGNhY2hlZCA9IHN0YXRlLnN1YnMubWFwW2hhc2hdXG4gIH1cbiAgLy8gY29uc29sZS5sb2coJ2hhc2gnLCBoYXNoKVxuXG5cbiAgaWYgKCFjYWNoZWQpIHsgLy8gcGxhY2UgaW4gdHJlZVxuXG4gICAgLy8gY29uc29sZS5sb2coJ3NldCBhY3RpdmUhJylcblxuICAgIHN0YXRlLnN1YnMubWFwLnNldChoYXNoLCB7XG4gICAgICBoYXNoOiBoYXNoLFxuICAgICAgc3Vic29iajogc3Vic29iaixcbiAgICAgIGFjdGl2ZTogY2xvdWQuX3N0YXR1cyxcbiAgICAgIGNsZWFyZWQ6IGZhbHNlXG4gICAgfSlcbiAgICBjYWNoZWQgPSBzdGF0ZS5zdWJzLm1hcFtoYXNoXVxuICAgIHZhciB0cmVlID0gc3RhdGUuc3Vicy50cmVlXG4gICAgaW5zZXJ0TGVhZih0cmVlLCBjYWNoZWQuc3Vic29iaiwgY2FjaGVkKVxuICB9IGVsc2UgaWYgKCFjYWNoZWQuYWN0aXZlIHx8IGNhY2hlZC5hY3RpdmUuX3ZhbCkge1xuICAgIC8vIGNvbnNvbGUud2Fybignc3Vic2NyaXB0aW9uIGFscmVhZHkgYWN0aXZlIScsIGNhY2hlZCwgY2FjaGVkLmFjdGl2ZSlcbiAgICByZXR1cm5cbiAgfSBlbHNlIHtcbiAgICBjYWNoZWQuYWN0aXZlLnZhbCA9IGNsb3VkLl9zdGF0dXNcbiAgfVxuXG4gIHZhciB1bnN1YnNtYXAgPSBjbG91ZC5iYXRjaC5tYXBzLnVuc3VicyxcbiAgICB1bnN1YmluZGV4ID0gdW5zdWJzbWFwW2hhc2hdXG5cbiAgaWYgKHVuc3ViaW5kZXggIT09IHZvaWQgMCkge1xuICAgIGNsb3VkLmNhbmNlbChoYXNoLCB1bnN1YmluZGV4LCBVTlNVQlMpXG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3Vic2xpc3QgPSBjbG91ZC5vdXRMaXN0KFNVQlMpLFxuICAgIHN1YnNtYXAgPSBjbG91ZC5iYXRjaC5tYXBzLnN1YnMsXG4gICAgb3V0XG5cbiAgaWYgKCFjYWNoZWQuY2xlYXJlZC5fdmFsKSB7XG4gICAgY2FjaGVkLmNsZWFyZWQudmFsID0gY2xvdWQuX3N0YXR1c1xuICAgIHZhciBkZXBlbmRzID0gY2xvdWQuZ2V0RGVwcyhzdGF0ZS5zdWJzLnRyZWUsIGNhY2hlZC5zdWJzb2JqLCBjYWNoZWQsIHt9KVxuICAgIGlmICghdXRpbC5lbXB0eShkZXBlbmRzKSkge1xuICAgICAgb3V0ID0ge1xuICAgICAgICAkc3Vic29iajogY2FjaGVkLnN1YnNvYmoucmF3LFxuICAgICAgICAkZGVwZW5kczogZGVwZW5kc1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBjYWNoZWQuc3Vic29iai5yYXdcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0ID0gY2FjaGVkLnN1YnNvYmoucmF3XG4gICAgY2FjaGVkLmNsZWFyZWQudmFsID0gY2xvdWQuX3N0YXR1c1xuICB9XG5cbiAgc3Vic21hcFtoYXNoXSA9IHN1YnNsaXN0Lmxlbmd0aFxuICBzdWJzbGlzdC5wdXNoKG91dClcbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS5nZXREZXBzID0gZnVuY3Rpb24gZ2V0RGVwcyAodHJlZSwgd2Fsa2VyLCBjYWNoZWQsIGxpc3QpIHtcbiAgd2Fsa2VyLmVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICB2YXIgYnJhbmNoID0gdHJlZVtmXVxuICAgIGlmIChicmFuY2gpIHtcbiAgICAgIGlmIChicmFuY2guX3N1YnMpIHtcbiAgICAgICAgYnJhbmNoLl9zdWJzLmVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSB0aGlzLl92YWxcbiAgICAgICAgICBpZiAoZm91bmQuc3Vic29iai5fdiAmJiBmb3VuZC5oYXNoLl92YWwgIT09IGNhY2hlZC5oYXNoLl92YWwgJiYgIWZvdW5kLmNsZWFyZWQuX3ZhbCAmJiAhbGlzdFtmb3VuZC5oYXNoLl92YWxdKSB7XG4gICAgICAgICAgICBmb3VuZC5jbGVhcmVkLnZhbCA9IGNhY2hlZC5jbGVhcmVkLl92YWxcbiAgICAgICAgICAgIGxpc3RbZm91bmQuaGFzaC5fdmFsXSA9IGZvdW5kLnN1YnNvYmoucmF3XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgZ2V0RGVwcyhicmFuY2gsIHdhbGtlcltmXSwgY2FjaGVkLCBsaXN0KVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGxpc3Rcbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlIChzdWJzb2JqLCBzdHIpIHtcbiAgLy8gc3RpbGwgZG9cbiAgdmFyIGNsb3VkID0gdGhpc1xuICAvLyBjb25zb2xlLmVycm9yKCd1bnN1YnNjcmliZSEnLCBzdWJzb2JqKVxuICBpZiAoc3Vic29iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3Vuc3ViIHdpdGggYXJyYXknLCBzdWJzb2JqKVxuICAgIHZhciB0cmVlID0gY2xvdWQuc3RhdGUuc3Vicy50cmVlLFxuICAgICAgc3BvdCA9IHRyZWUuZ2V0KHN1YnNvYmopXG5cbiAgICBpZiAoc3BvdCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ09LIFVOU1VCU0NSSUJFIFRPIFRISVMgQ1JBUCcsIHNwb3QpXG4gICAgICByZWN1clVuc3ViKGNsb3VkLCBzcG90LCBzdHIpXG4gICAgfVxuICB9IGVsc2Uge1xuXG4gICAgdmFyIGJhdGNobWFwID0gY2xvdWQuYmF0Y2gubWFwcy5zdWJzLFxuICAgICAgaGFzaCxcbiAgICAgIGNhY2hlZFxuXG4gICAgaWYgKHN1YnNvYmouaGFzaCkge1xuICAgICAgaGFzaCA9IHN1YnNvYmouaGFzaC52YWxcbiAgICAgIGNhY2hlZCA9IHN1YnNvYmpcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzdHIpIHtcbiAgICAgICAgc3RyID0gSlNPTi5zdHJpbmdpZnkoc3Vic29iailcbiAgICAgIH1cbiAgICAgIGhhc2ggPSBtYWtlSGFzaChzdHIpXG5cbiAgICAgIHZhciBzdGF0ZW1hcCA9IGNsb3VkLnN0YXRlLnN1YnMubWFwXG5cbiAgICAgIGNhY2hlZCA9IHN0YXRlbWFwW2hhc2hdXG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gYmF0Y2htYXBbaGFzaF1cblxuICAgIGlmIChpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBjbG91ZC5jYW5jZWwoaGFzaCwgaW5kZXgsIFNVQlMpXG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxpc3QgPSBjbG91ZC5vdXRMaXN0KCd1bnN1YnMnKVxuICAgICAgY2xvdWQuYmF0Y2gubWFwcy51bnN1YnNbaGFzaF0gPSBsaXN0Lmxlbmd0aFxuICAgICAgbGlzdC5wdXNoKGhhc2gpXG4gICAgfVxuXG4gICAgY2FjaGVkLmFjdGl2ZS52YWwgPSBmYWxzZVxuICB9XG5cbn1cblxuZnVuY3Rpb24gcmVjdXJVbnN1YiAoY2xvdWQsIHNwb3QsIGNsZWFyKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdyZWN1clVuc3ViIScsIHNwb3QuX3BhdGgpXG4gIHNwb3QuZWFjaChmdW5jdGlvbiAoZikge1xuICAgIGlmICh0aGlzLl9zdWJzKSB7XG4gICAgICB0aGlzLl9zdWJzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndW5zdWIgb24gdGhpcyEnLCB0aGlzLnJhdywgJ2NsZWFyPycsIGNsZWFyKVxuICAgICAgICBpZiAoY2xlYXIgJiYgdGhpcy5mcm9tLnN1YnNvYmouX3YpIHtcbiAgICAgICAgICB0aGlzLmZyb20uc3Vic29iai5fdi5yZW1vdmUoKVxuICAgICAgICB9XG4gICAgICAgIGNsb3VkLnVuc3Vic2NyaWJlKHRoaXMuZnJvbSlcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmIChmICE9PSAnX3N1YnMnKSB7XG4gICAgICByZWN1clVuc3ViKGNsb3VkLCB0aGlzLCBjbGVhcilcbiAgICB9XG4gIH0pXG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUuY2FuY2VsID0gZnVuY3Rpb24gY2FuY2VsIChoYXNoLCBpbmRleCwgbGFiZWwpIHtcbiAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaCxcbiAgICBsaXN0ID0gYmF0Y2gubGlzdHNbbGFiZWxdXG4gIHJlbW92ZUluZGV4KGxpc3QsIGluZGV4KVxuICBpZiAoIWxpc3QubGVuZ3RoKSB7XG4gICAgZGVsZXRlIGJhdGNoLmxpc3RzW2xhYmVsXVxuICAgIGlmICh1dGlsLmVtcHR5KGJhdGNoLmxpc3RzKSkge1xuICAgICAgZGVsZXRlIGJhdGNoLmxpc3RzXG4gICAgfVxuICB9XG4gIHZhciBtYXAgPSBiYXRjaC5tYXBzW2xhYmVsXVxuICBkZWxldGUgbWFwW2hhc2hdXG4gIGZvciAoaGFzaCBpbiBtYXApXG4gICAgaWYgKG1hcFtoYXNoXSA+IGluZGV4KSB7XG4gICAgICBtYXBbaGFzaF0gLS1cbiAgICB9XG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0IChoYXNoLCB1cGRhdGUpIHtcblxuICAvLyBjb25zb2xlLmxvZygnU0VUIENMT1VEIScpXG5cbiAgaWYgKCF1cGRhdGVbMF0ubGVuZ3RoKSB7XG4gICAgLy8gY29uc29sZS5lcnJvcignRU1QVFkgUEFUSCcsIHVwZGF0ZSlcbiAgfVxuXG4gIHZhciBjbG91ZCA9IHRoaXMsXG4gICAgbGlzdCA9IGNsb3VkLm91dExpc3QoU0VUUyksXG4gICAgbWFwID0gY2xvdWQuYmF0Y2gubWFwcy5zZXRzXG5cbiAgc3RvcmVTZXQoaGFzaCwgdXBkYXRlLCBsaXN0LCBtYXApXG59XG5cbmZ1bmN0aW9uIHN0b3JlU2V0IChoYXNoLCB1cGRhdGUsIGxpc3QsIG1hcCkge1xuICAvLyBjb25zb2xlLmxvZygnc3RvcmVzZXQ/IScpXG4gIHZhciBWID0gbGlzdC5fX3QsXG4gICAgc3RvcmVkID0gbWFwW2hhc2hdXG5cbiAgaWYgKHN0b3JlZCkge1xuICAgIHZhciB2YWwgPSB1cGRhdGVbMV0sXG4gICAgICB0cyA9IHVwZGF0ZVsyXSxcbiAgICAgIG9sZHZhbCA9IHN0b3JlZC51cGRhdGVbMV1cblxuICAgIGlmIChWKSBvbGR2YWwgPSBvbGR2YWwucmF3XG5cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0ICYmIG9sZHZhbCBpbnN0YW5jZW9mIE9iamVjdCAmJiAhKHZhbC4kcGF0aCkgJiYgIShvbGR2YWwuJHBhdGgpKSB7XG4gICAgICBpZiAoIVYpIG9sZHZhbCA9IHV0aWwuY2xvbmUob2xkdmFsKVxuICAgICAgdmFsID0gdXRpbC5tZXJnZShvbGR2YWwsIHZhbClcbiAgICB9XG5cbiAgICBpZiAoVikge1xuICAgICAgc3RvcmVkLnVwZGF0ZS5zZXQoMSwgdmFsKVxuICAgICAgc3RvcmVkLnVwZGF0ZS5zZXQoMiwgdHMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JlZC51cGRhdGVbMV0gPSB2YWxcbiAgICAgIHN0b3JlZC51cGRhdGVbMl0gPSB0c1xuICAgIH1cblxuICAgIGlmICghVikge1xuICAgICAgdmFyIGkgPSBzdG9yZWQuaSxcbiAgICAgICAgZW5kID0gbGlzdC5sZW5ndGggLSAxXG4gICAgICBpZiAoaSAhPT0gZW5kKSB7XG4gICAgICAgIG1vdmVUb0VuZChsaXN0LCBpKVxuICAgICAgICBmb3IgKHZhciBtYXBoYXNoIGluIG1hcCkge1xuICAgICAgICAgIGlmIChtYXBbbWFwaGFzaF0uaSA+PSBpKSBtYXBbbWFwaGFzaF0uaS0tXG4gICAgICAgIH1cbiAgICAgICAgc3RvcmVkLmkgPSBlbmRcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNldG9iaiA9IHtcbiAgICAgIHVwZGF0ZTogdXBkYXRlLFxuICAgICAgaTogbGlzdC5sZW5ndGhcbiAgICB9XG4gICAgaWYgKFYpIHtcbiAgICAgIG1hcC5zZXQoaGFzaCwgc2V0b2JqKVxuICAgIH0gZWxzZSB7XG4gICAgICBtYXBbaGFzaF0gPSBzZXRvYmpcbiAgICB9XG5cbiAgICBzdG9yZWQgPSBtYXBbaGFzaF1cbiAgICBsaXN0LnB1c2goc3RvcmVkLnVwZGF0ZSlcbiAgfVxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLl9yZWNvbm5lY3QgPSBmdW5jdGlvbiBfcmVjb25uZWN0ICgpIHtcblxuICAvLyBhbGVydCgnKFJFKUNPTk5FQ1QhJylcbiAgLy8gY29uc29sZS5lcnJvcignLS0tLS0tLS0tLS0tLSAoUkUpQ09OTkVDVCEnKVxuXG4gIHZhciBjbG91ZCA9IHRoaXMsXG4gICAgc3RhdGUgPSBjbG91ZC5zdGF0ZSxcbiAgICBzdWJzID0gc3RhdGUuc3Vicy5tYXBcblxuICBjbG91ZC5fdGltZVRyaWVzID0gMFxuICBjbG91ZC5fdGltZVRyYXZlbCA9IEluZmluaXR5XG4gIGNsb3VkLnRpbWVTeW5jKClcblxuICAvLyBjbGVhbiBkYXRhXG4gIGNsb3VkLnN0YW1wID0gJ2NsZWFudXAnXG4gIGlmIChjbG91ZC5kYXRhLmNsaWVudHMpIHtcbiAgICB2YXIgbXljbGllbnQgPSBjbG91ZC5kYXRhLmNsaWVudHNbY2xvdWQuY2xpZW50aWRdXG5cbiAgICBpZihteWNsaWVudCkge1xuICAgICAgbXljbGllbnQgPSBteWNsaWVudC5yYXdcbiAgICAgIGRlbGV0ZSBteWNsaWVudC5rZXlcbiAgICAgIGRlbGV0ZSBteWNsaWVudC50eXBlXG4gICAgICBkZWxldGUgbXljbGllbnQuaXBcbiAgICAgIGRlbGV0ZSBteWNsaWVudC50b2tlblxuICAgIH1cblxuICAgIGNsb3VkLmRhdGEuc2V0KCdjbGllbnRzJywge1xuICAgICAgY2xlYXI6IHRydWVcbiAgICB9LCB2b2lkIDAsIGNsb3VkLnN0YW1wKVxuXG4gICAgLy8gVE9ETzogcHV0IGFsbCBjbG91ZC5jbGllbnQgbG9naWMgaW4gb25lIHBsYWNlXG4gICAgaWYoY2xvdWQuY2xpZW50aWQgJiYgY2xvdWQuY2xpZW50KSB7XG4gICAgICBjbG91ZC5jbGllbnQudmFsID0gY2xvdWQuZGF0YS5jbGllbnRzLmdldChjbG91ZC5jbGllbnRpZCwge30pXG4gICAgICBpZihteWNsaWVudCkge1xuICAgICAgICBjbG91ZC5jbGllbnQuZnJvbS52YWwgPSBteWNsaWVudFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChjbG91ZC5kYXRhLnVzZXJzKSB7XG4gICAgY2xvdWQuZGF0YS51c2Vycy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdDTEVBTiBDTE9VRDogY2xlYW4gdXNydCEhJywgdGhpcy5fbmFtZSlcblxuICAgICAgdGhpcy5zZXQoJ2NsaWVudHMnLCB7XG4gICAgICAgIGNsZWFyOiB0cnVlXG4gICAgICB9LCB2b2lkIDAsIGNsb3VkLnN0YW1wKVxuXG4gICAgICAvLyBDTEVBTiBNQUlOU0NSRUVOIEFORCBBQ1RJVkUgQ0xJRU5UPyFcblxuICAgICAgLy8gdGhpcy5tYWluc2NyZWVuLnNldCgnY2xpZW50UmVmJywgZmFsc2UsIHZvaWQgMCwgY2xvdWQuc3RhbXApXG4gICAgICAvLyB0aGlzLm1haW5zY3JlZW4uY2xpZW50UmVmLnJlbW92ZSh2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGNsb3VkLnN0YW1wKVxuXG4gICAgICAvLyB0aGlzLmFjdGl2ZUNsaWVudC5yZW1vdmUodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBjbG91ZC5zdGFtcClcblxuICAgIH0pXG4gIH1cblxuICAvLyBpZihzZXRzLmxlbmd0aCl7XG4gIC8vICAgc2V0cy5zb3J0KGJ5VHMpXG4gIC8vICAgZm9yKHZhciBpID0gMCwgc2V0IDsgc2V0ID0gc2V0c1tpKytdOyl7XG4gIC8vICAgICBpZihzZXRbMV0gPT09ICckJG51bGwnKVxuICAvLyAgICAgICBzZXRbMV0gPSBudWxsXG4gIC8vICAgfVxuICAvLyAgIGNsb3VkLndyaXRlKHtzZXRzOnNldHN9KVxuICAvLyAgIC8vIHdvdWxkIGJlIG5pY2VyIHRvIGluc2VydCB0aGVtIGludG8gY3VycmVudCBiYXRjaFxuICAvLyB9XG5cbiAgdmFyIHJlc3VicyA9IFtdXG4gIHN1YnMuZWFjaChmdW5jdGlvbiAoZikge1xuICAgIC8vIGNvbnNvbGUubG9nKCdyZXN1Yj8nLCBmKVxuICAgIHZhciBjYWNoZWQgPSB0aGlzLFxuICAgICAgYWN0aXZlID0gY2FjaGVkLmFjdGl2ZSxcbiAgICAgIGNsZWFyZWQgPSBjYWNoZWQuY2xlYXJlZFxuXG4gICAgaWYgKGFjdGl2ZS5fdmFsID09PSAxKSB7XG4gICAgICBhY3RpdmUudmFsID0gdHJ1ZVxuICAgICAgY2xlYXJlZC52YWwgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChhY3RpdmUuX3ZhbCkge1xuICAgICAgLy8gYWN0aXZlLl92YWwgPSBmYWxzZVxuXG4gICAgICBhY3RpdmUudmFsID0gZmFsc2VcbiAgICAgIC8vIGRpdCB3b3JkdCBuaWV0IGluIGxzIG9wZ2Vsc2FnZW5cblxuICAgICAgaWYgKGNsZWFyZWQuX3ZhbCA9PT0gMSkge1xuICAgICAgICBjbGVhcmVkLnZhbCA9IHRydWVcbiAgICAgIH0gZWxzZSBpZiAoY2xlYXJlZC5fdmFsKSB7XG4gICAgICAgIGNsZWFyZWQudmFsID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJlc3Vicy5wdXNoKGNhY2hlZClcbiAgICB9IGVsc2UgaWYgKGNsZWFyZWQuX3ZhbCkge1xuICAgICAgaWYgKGNsZWFyZWQuX3ZhbCA9PT0gMSkge1xuICAgICAgICBjbGVhcmVkLnZhbCA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsZWFyZWQudmFsID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgfSlcbiAgZm9yICh2YXIgaSA9IDAsIHJlc3ViOyByZXN1YiA9IHJlc3Vic1tpXTsgaSsrKSB7XG4gICAgLy8gY29uc29sZS5lcnJvcigncmVzdWJzY3JpYmUhIScsIHJlc3ViLnN1YnNvYmoucmF3KVxuICAgIGNsb3VkLnN1YnNjcmliZShyZXN1YilcbiAgfVxuICAvLyBjb25zb2xlLmVycm9yKCdkb25lIHJlc3Vic2NyaWJpbicpXG5cbiAgZm9yICh2YXIgaiBpbiBjbG91ZC5fam9pbnMpIHtcbiAgICBjbG91ZC5qb2luKGNsb3VkLl9qb2luc1tqXSwgdHJ1ZSlcbiAgfVxuXG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUudGltZVN0YW1wID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHMgPSB0aW1lc3RhbXAoKVxuICBpZiAodGhpcy5fdGltZU9mZnNldCkge1xuICAgIHRzICs9IHRoaXMuX3RpbWVPZmZzZXRcbiAgfVxuICByZXR1cm4gdHNcbn1cblxuZnVuY3Rpb24gaW5zZXJ0TGVhZiAodHJlZSwgc3Vic29iaiwgY2FjaGVkKSB7XG4gIHN1YnNvYmouZWFjaChmdW5jdGlvbiAoZikge1xuICAgIGlmIChmID09PSAnKicpIHtcbiAgICAgIGlmICghdHJlZS4kKSB7XG4gICAgICAgIHRyZWUuc2V0KCckJywge30pXG4gICAgICB9XG4gICAgICBzdWJzb2JqWycqJ10uZWFjaChmdW5jdGlvbiAocykge1xuICAgICAgICBzdWJzb2JqWycqJ11bc11bMV0uZWFjaChmdW5jdGlvbiAoc3MpIHtcbiAgICAgICAgICBpbnNlcnRMZWFmKHRyZWUuJCwgc3Vic29ialsnKiddW3NdWzFdW3NzXSwgY2FjaGVkKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoIXRyZWVbZl0pIHtcbiAgICAgIHRyZWUuc2V0KGYsIHt9KVxuICAgIH1cbiAgICBpZiAoc3Vic29ialtmXS52YWwgPT09IHRydWUpIHtcbiAgICAgIGlmICghdHJlZVtmXS5fc3Vicykge1xuICAgICAgICB0cmVlW2ZdLnNldCgnX3N1YnMnLCBbY2FjaGVkXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyZWVbZl0uX3N1YnMucHVzaChjYWNoZWQpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydExlYWYodHJlZVtmXSwgc3Vic29ialtmXSwgY2FjaGVkKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gbW92ZVRvRW5kIChhcnIsIGkpIHtcbiAgdmFyIHRtcCA9IGFycltpXVxuICB3aGlsZSAoYXJyW2kgKyAxXSkge1xuICAgIGFycltpXSA9IGFyclsrK2ldXG4gIH1cbiAgYXJyW2ldID0gdG1wXG59XG5cbmZ1bmN0aW9uIHJlbW92ZUluZGV4IChhcnIsIGkpIHtcbiAgd2hpbGUgKGFycltpICsgMV0pIHtcbiAgICBhcnJbaV0gPSBhcnJbKytpXVxuICB9XG4gIGFyci5wb3AoKVxufVxuXG4vLyBmdW5jdGlvbiBieVRzIChhLCBiKSB7XG4vLyAgIHJldHVybiBhWzJdIC0gYlsyXVxuLy8gfVxuIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogTWFyY3VzIEJlc2plcywgbWFyY3VzQHZpZ291ci5pb1xuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpLFxuICBpbyA9IHV0aWwuaXNOb2RlIFxuICAgID8gcmVxdWlyZSgnc29ja2V0LmlvLWNsaWVudCcpIFxuICAgIDogcmVxdWlyZSgnLi9zb2NrZXQuaW8ubWluLmpzJyksXG4gIEcgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL2dsb2JhbCcpLFxuICBpZCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvaWQnKSxcbiAgdXJsRW5jb2RlID0gcmVxdWlyZSgnLi4vYWpheCcpLmVuY29kZSxcbiAgVk9iamVjdCA9IHJlcXVpcmUoJy4uLy4uLy4uL29iamVjdCcpLFxuICBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlJyksXG4gIEVtaXR0ZXIgPSByZXF1aXJlKCcuL2VtaXR0ZXInKVxuXG52YXIgQ2xvdWQgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIENsb3VkICh1cmwsIHBhcmFtcykge1xuICBcbiAgaWYgKCFwYXJhbXMpIHtcbiAgICBwYXJhbXMgPSB7fVxuICB9XG5cbiAgdmFyIGNsb3VkID0gdGhpc1xuICBjbG91ZC5wYXJhbXMgPSBwYXJhbXNcbiAgY2xvdWQudXJsID0gdXJsXG4gIGNsb3VkLlZJRCA9IHBhcmFtcy5WSUQgPSBmaXhWSUQocGFyYW1zLlZJRClcbiAgICAvLyB2YXIgSElEID0gcGFyYW1zLkhJRCB8fCBHLmVudignSElEJylcbiAgICAvLyBpZihISUQpXG4gICAgLy8gICBjbG91ZC5ISUQgPSBwYXJhbXMuSElEID0gSElEXG4gIGNsb3VkLmNvbm5lY3RlZCA9IG5ldyBWYWx1ZShmYWxzZSlcblxuICAvLyBjbG91ZC5jb25uZWN0ZWQuYWRkTGlzdGVuZXIoZnVuY3Rpb24oKXtcbiAgLy8gICBjb25zb2xlLmxvZygnY29ubmVjdGVkOiBzdGF0ZSBjaGFuZ2UgPicsIHRoaXMudmFsKVxuICAvLyB9KVxuXG4gIGNsb3VkLmFwaSA9IG5ldyBWYWx1ZSh7XG4gICAgZGVmZXI6IGZ1bmN0aW9uICh1cGRhdGUsIGFyZ3MpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5mcm9tLl9fdFxuICAgICAgaWYgKHR5cGUgIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjbG91ZC5hcGkgbmVlZHMgdG8gYmUgYW4gT2JqZWN0JylcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpXG4gICAgfVxuICB9KVxuXG4gIC8vIGNsb3VkLmFwaS5vbihmdW5jdGlvbigpe1xuICAvLyAgY29uc29sZS5lcnJvcignbG9sayBjbG91ZC5hcGkgaXMgc2V0ISEgb24nLCB0aGlzLnZhbClcbiAgLy8gfSlcblxuICBpZiAocGFyYW1zLmFwaSkge1xuICAgIGNsb3VkLmFwaS52YWwgPSBwYXJhbXMuYXBpXG4gIH1cblxuICBjbG91ZC5hZGREb2N1bWVudExpc3RlbmVycygpXG5cbiAgaWYgKHVybCBpbnN0YW5jZW9mIFZPYmplY3QpIHtcbiAgICB2YXIgY3VycmVudCA9IHVybC52YWxcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdjdXJyZW50JywgY3VycmVudClcblxuICAgIGlmIChjdXJyZW50KSB7XG4gICAgICBjbG91ZC5pbml0KHVybCwgcGFyYW1zKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSBuZXcgRW1pdHRlcigpXG4gICAgICBwbGFjZWhvbGRlci5lbWl0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnVmZmVyID0gY2xvdWQuZW1pdGJ1ZmZlciB8fCAoY2xvdWQuZW1pdGJ1ZmZlciA9IFtdKVxuICAgICAgICBidWZmZXIucHVzaChhcmd1bWVudHMpXG4gICAgICB9XG4gICAgICBwbGFjZWhvbGRlci5wbGFjZWhvbGRlciA9IHRydWVcbiAgICAgIGNsb3VkLnNvY2tldCA9IHBsYWNlaG9sZGVyXG4gICAgICB1cmwuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKHZhbCwgcDEsIHAyLCBwMykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVVJMIFZBTCBDSEFOR0UnLCB0aGlzLnZhbClcbiAgICAgICAgaWYgKHRoaXMudmFsKSB7XG4gICAgICAgICAgY2xvdWQuaW5pdCh1cmwsIHBhcmFtcylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gY29uc29sZS5sb2coJ25vcm1hbCBidXJrIGp1c3QgaW5pdCcsIHVybClcbiAgICBjbG91ZC5pbml0KHVybCwgcGFyYW1zKVxuICB9XG5cbn1cblxuQ2xvdWQuaW5qZWN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9pbmplY3QnKVxuXG5DbG91ZC5wcm90b3R5cGUuYWRkRG9jdW1lbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBjbG91ZCA9IHRoaXNcbiAgaWYgKCF1dGlsLmlzTm9kZSAmJiB3aW5kb3cuY29yZG92YSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc3VtZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdjb25uZWN0ZWQ6IFJFU1VNRScpXG4gICAgICBjbG91ZC5jb25uZWN0ZWQudmFsID0gZmFsc2VcbiAgICB9LCBmYWxzZSlcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdjb25uZWN0ZWQ6IFBBVVNFJylcbiAgICAgIGNsb3VkLmNvbm5lY3RlZC52YWwgPSBmYWxzZVxuICAgIH0sIGZhbHNlKVxuICB9XG59XG5cbkNsb3VkLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdDTE9VRCBJTklUIScpXG4gIHZhciBjbG91ZCA9IHRoaXMsXG4gICAgc29ja2V0ID0gY2xvdWQuY29ubmVjdCh1cmwsIHBhcmFtcyxcbiAgICAgIHsgZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxvZygnZGlzY29ubmVjdCcpXG4gICAgICAgICAgY2xvdWQuY29ubmVjdGVkLnZhbCA9IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsb2coJ2Nvbm5lY3QnKVxuICAgICAgICAgIGNsb3VkLmNvbm5lY3RlZC52YWwgPSB0cnVlXG4gICAgICAgICAgc29ja2V0LmlvLmVuZ2luZS5vbignaGVhcnRiZWF0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2xvdWQuY29ubmVjdGVkLnZhbCA9IHRydWVcbiAgICAgICAgICB9KSAgICAgICAgICBcbiAgICAgICAgfSxcbiAgICAgICAgd2VsY29tZTogZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICAgICAgICBsb2coJ3dlbGNvbWUnKVxuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNwbGl0KCdAJylcblxuICAgICAgICAgIHZhciBjbGllbnRpZCA9IGNsb3VkLmNsaWVudGlkID0gYWRkcmVzc1swXSxcbiAgICAgICAgICAgIGh1YmlkID0gYWRkcmVzc1sxXSxcbiAgICAgICAgICAgIHN0YXRlID0gY2xvdWQuc3RhdGVcblxuICAgICAgICAgIGNsb3VkLmh1YiA9IHBhcmFtcy5oID0gaHViaWRcblxuICAgICAgICAgIGNsb3VkLnNvY2tldC5pby51cmkgPSBmaXhVcmwoY2xvdWQuc29ja2V0LmlvLnVyaSwgcGFyYW1zKVxuICAgICAgICB9LFxuICAgICAgICBob3A6IGZ1bmN0aW9uIChuZXdodWIpIHtcbiAgICAgICAgICBsb2coJ2hvcCcpXG4gICAgICAgICAgY2xvdWQuaG9wKG5ld2h1YilcbiAgICAgICAgfSxcbiAgICAgICAgZXJyOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycm9yKGVycilcbiAgICAgICAgICBpZiAoZXJyLnR5cGUgPT09ICd0b2tlbkNoZWNrJykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdwcm9kdWN0aW9udXNlclRva2VuJylcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXJJZCcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWNvbm5lY3Rpbmc6IGxvZ2dlcigncmVjb25uZWN0aW5nJyksXG4gICAgICAgIHJlY29ubmVjdF9hdHRlbXB0OiBsb2dnZXIoJ3JlY29ubmVjdF9hdHRlbXB0JyksXG4gICAgICAgIHJlY29ubmVjdDogbG9nZ2VyKCdyZWNvbm5lY3QnKSxcbiAgICAgICAgcmVjb25uZWN0X2ZhaWxlZDogbG9nZ2VyKCdyZWNvbm5lY3RfZmFpbGVkJylcbiAgICAgIH1cbiAgICApXG5cbiAgdmFyIGVtaXRidWZmZXIgPSBjbG91ZC5lbWl0YnVmZmVyXG4gIGlmIChlbWl0YnVmZmVyKSB7XG4gICAgZm9yICh2YXIgZSBpbiBlbWl0YnVmZmVyKSB7XG4gICAgICBzb2NrZXQuZW1pdC5hcHBseShzb2NrZXQsIGVtaXRidWZmZXJbZV0pXG4gICAgfVxuICAgIGNsb3VkLmVtaXRidWZmZXIgPSBudWxsXG4gIH1cblxufVxuXG5DbG91ZC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgbGlzdGVuZXJzKSB7XG5cbiAgdmFyIGNsb3VkID0gdGhpc1xuXG4gIGlmICghdXJsKVxuICAgIHVybCA9IGNsb3VkLnVybFxuICBpZiAoIXBhcmFtcylcbiAgICBwYXJhbXMgPSBjbG91ZC5wYXJhbXNcblxuICBpZiAodXJsIGluc3RhbmNlb2YgVk9iamVjdCkge1xuICAgIHVybCA9IHVybC52YWxcbiAgfVxuXG4gIHVybCA9IGZpeFVybCh1cmwsIHBhcmFtcylcblxuICB2YXIgb2xkc29ja2V0ID0gY2xvdWQuc29ja2V0XG5cbiAgaWYgKG9sZHNvY2tldCAmJiAhb2xkc29ja2V0LnBsYWNlaG9sZGVyKSB7XG4gICAgb2xkc29ja2V0LmRpc2Nvbm5lY3QoKVxuICAgIG9sZHNvY2tldC5pby5kaXNjb25uZWN0KClcbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tIGNsb3VkLmNvbm5lY3QhJywgdXJsLCBwYXJhbXMpXG5cbiAgdmFyIHNvY2tldCA9IGNsb3VkLnNvY2tldCA9IG5ldyBpbyh1cmwsIHtcbiAgICBmb3JjZU5ldzogdHJ1ZSxcbiAgICB0aW1lb3V0OiA1ZTNcbiAgfSlcblxuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgZm9yICh2YXIgbCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgIHNvY2tldC5vbihsLCBsaXN0ZW5lcnNbbF0pXG4gICAgfVxuICB9XG5cbiAgaWYgKG9sZHNvY2tldCkge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJy0tLS0tLS0tLS0tLS0gdHJhbnNmZXJyaW5nIG9sZCBsaXN0ZW5lcnMnLCBzb2NrZXQuX2NhbGxiYWNrcylcbiAgICBwYXNzT24ob2xkc29ja2V0LCBzb2NrZXQpXG4gIH1cblxuICAvLyAtLS0tLS0tIHRoZXNlIGV4dGVudGlvbnMgYXJlIG9ubHkgZm9yIGxvZ2dpbmdcbiAgLy8gd2luZG93LmNsb3VkbWVzc2FnZXMgPSBbXVxuICAvLyB2YXIgX29uZXZlbnQgPSBjbG91ZC5zb2NrZXQub25ldmVudFxuICAvLyBjbG91ZC5zb2NrZXQub25ldmVudCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgLy8gICB3aW5kb3cuY2xvdWRtZXNzYWdlcy5wdXNoKEpTT04uc3RyaW5naWZ5KHBhY2tldC5kYXRhLCBmYWxzZSwgMikpXG4gIC8vICAgY29uc29sZS5sb2coJ2luY29taW5nIGNsb3VkIG1lc3NhZ2UhJywgSlNPTi5zdHJpbmdpZnkocGFja2V0LmRhdGEsIGZhbHNlLCAyKSlcbiAgLy8gICBfb25ldmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIC8vIH1cbiAgLy8gdmFyIF9lbWl0ID0gY2xvdWQuc29ja2V0LmVtaXRcbiAgLy8gY2xvdWQuc29ja2V0LmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQsIGRhdGEpIHtcbiAgLy8gICBpZiAodHlwZW9mIGRhdGEgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIGNvbnNvbGUubG9nKCdcXG5jbG91ZC5zb2NrZXQuZW1pdDonLCBldmVudCwgZGF0YSlcbiAgLy8gICAgIGlmIChldmVudCA9PT0gJ2JhdGNoJykge1xuICAvLyAgICAgICBpZiAoZGF0YS5zdWJzKSB7XG4gIC8vICAgICAgICAgZm9yICh2YXIgcyBpbiBkYXRhLnN1YnMpIHtcbiAgLy8gICAgICAgICAgIGlmIChkYXRhLnN1YnNbc10ubXR2RGF0YSkge1xuICAvLyAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnXFxuc3Vic2NyaWJpbiB0byBtdHZEYXRhIScsIGRhdGEuc3Vic1tzXS5tdHZEYXRhKVxuICAvLyAgICAgICAgICAgfVxuICAvLyAgICAgICAgIH1cbiAgLy8gICAgICAgfVxuICAvLyAgICAgICBpZiAoZGF0YS5zZXRzKSB7XG4gIC8vICAgICAgICAgZm9yICh2YXIgcyBpbiBkYXRhLnNldHMpIHtcbiAgLy8gICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3NldDonLCBKU09OLnN0cmluZ2lmeShkYXRhLnNldHNbc10pKVxuICAvLyAgICAgICAgIH1cbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICBfZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIC8vIH1cbiAgLy8gLS0tLS0tLSB0aGVzZSBleHRlbnRpb25zIGFyZSBvbmx5IGZvciBsb2dnaW5nXG4gIFxuICByZXR1cm4gc29ja2V0XG5cbn1cblxuQ2xvdWQucHJvdG90eXBlLmhvcCA9IGZ1bmN0aW9uIGhvcCAobmV3aHViKSB7XG5cbiAgLy8gY29uc29sZS5sb2coJ0dPVCBPUkRFUiBUTyBIT1AgVE8nLCBuZXdodWIpXG5cbiAgdmFyIGNsb3VkID0gdGhpcyxcbiAgICBwYXJhbXMgPSBjbG91ZC5wYXJhbXNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0gZGV2XG4gIGlmIChuZXdodWIuaW5kZXhPZignQCcpICE9PSAtMSlcbiAgICBjbG91ZC51cmwgPSAnd3M6Ly8nICsgbmV3aHViLnNwbGl0KCdAJylbMV1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0gL2RldlxuICBjbG91ZC5odWIgPSBwYXJhbXMuaCA9IG5ld2h1YlxuICBjbG91ZC5jb25uZWN0KClcbn1cblxuQ2xvdWQucHJvdG90eXBlLndoZW5SZWFkeSA9IGZ1bmN0aW9uIHdoZW5SZWFkeSAoZm4pIHtcbiAgaWYgKHRoaXMuY2xpZW50aWQpXG4gICAgZm4oKVxuICBlbHNlXG4gICAgdGhpcy5vbmNlKCd3ZWxjb21lJywgZm4pXG59XG5cbkNsb3VkLnByb3RvdHlwZS5raWNrUGluZyA9IGZ1bmN0aW9uIGtpY2tQaW5nICh0aW1lKSB7XG4gIHZhciBlID0gdGhpcy5zb2NrZXQuaW8uZW5naW5lXG4gIGUucGluZygpXG4gIGUub25IZWFydGJlYXQodGltZSB8fCBlLnBpbmdUaW1lb3V0KVxuICBlLnNldFBpbmcoKVxufVxuXG5DbG91ZC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uIGRpc2Nvbm5lY3QgKCkge1xuICB2YXIgc29ja2V0ID0gdGhpcy5zb2NrZXRcbiAgaWYgKHNvY2tldCkge1xuICAgIHNvY2tldC5kaXNjb25uZWN0KClcbiAgICBzb2NrZXQuaW8uZGlzY29ubmVjdCgpXG4gIH1cbn1cblxuZGVsZWdhdGVMaXN0KENsb3VkLnByb3RvdHlwZSwgJ3NvY2tldCcsIFsnb24nLCAnb25jZScsICdlbWl0J10pXG5cbmZ1bmN0aW9uIGRlbGVnYXRlTGlzdCAob2JqLCB0YXJnZXQsIGxpc3QpIHtcbiAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBkZWxlZ2F0ZShvYmosIHRhcmdldCwgbGlzdFtpXSlcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWxlZ2F0ZSAob2JqLCB0YXJnZXQsIGZpZWxkKSB7XG4gIG9ialtmaWVsZF0gPSBmdW5jdGlvbiBkZWxlZ2F0ZWQgKCkge1xuICAgIHZhciB0aGluZyA9IHRoaXNbdGFyZ2V0XVxuICAgIHRoaW5nW2ZpZWxkXS5hcHBseSh0aGluZywgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGxvZ2l0IChmbGFnKSB7XG4gIHJldHVybiBmdW5jdGlvbiBsb2dnZXIgKCkge1xuICAgIGlmKHdpbmRvdy5nYXN0b24pe1xuICAgICAgY29uc29sZS5sb2coJzo6IHZpZ291ci1jbG91ZCA6OicsIGZsYWcsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIHZmbGFnID0gJzo6IHZpZ291ci1jbG91ZCA6OidcbmZ1bmN0aW9uIGxvZyAoKSB7XG4gIGlmKHdpbmRvdy5nYXN0b24pe1xuICAgIHZhciBhcmdzID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgIGFyZ3MudW5zaGlmdCh2ZmxhZylcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKVxuICB9XG59XG5sb2cuZXJyb3IgPSBmdW5jdGlvbiAoZmxhZywgZXJyKXtcbiAgY29uc29sZS5lcnJvcih2ZmxhZywgZmxhZywgJ1xcbicsIGVycilcbn1cbmZ1bmN0aW9uIGxvZ2dlciAoZmxhZyl7XG4gIHJldHVybiBmdW5jdGlvbiBsb2dnZXIgKCkge1xuICAgIHZhciBhcmdzID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgIGFyZ3MudW5zaGlmdCh2ZmxhZywgZmxhZylcbiAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpeFZJRCAoVklEKSB7XG4gIFZJRCA9IFZJRCB8fCBHLnNlc3Npb24oJ1ZJRCcpIHx8IGlkKCdWXycpXG4gIHJldHVybiBHLnNlc3Npb24oJ1ZJRCcsIFZJRClcbn1cblxuZnVuY3Rpb24gcGFzc09uIChmcm9tLCB0bykge1xuICBmb3IgKHZhciBlIGluIGZyb20uX2NhbGxiYWNrcykge1xuICAgIHZhciBmcm9tbGlzdCA9IGZyb20uX2NhbGxiYWNrc1tlXVxuICAgIGZvciAodmFyIGkgPSAwLCBmbjsgZm4gPSBmcm9tbGlzdFtpXTsgaSsrKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnaGFuZCBvdmVyIGRhdCBsaXN0bmVyJywgZm4ubmFtZSA9PT0gJ29uJyAmJiBmbi5mbiA/ICdvbmNlJyA6ICdvbicsZSwgZm4uZm4gfHwgZm4pXG4gICAgICBpZiAoZm4ubmFtZSA9PT0gJ29uJyAmJiBmbi5mbikge1xuICAgICAgICB0by5vbmNlKGUsIGZuLmZuKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG8ub24oZSwgZm4pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZyb20ub2ZmKClcbn1cblxuZnVuY3Rpb24gZml4VXJsICh1cmwsIHBhcmFtcykge1xuICB2YXIgY3V0b2ZmID0gdXJsLmluZGV4T2YoJz8nKVxuICBpZiAoY3V0b2ZmID4gLTEpIHtcbiAgICB1cmwgPSB1cmwuc2xpY2UoMCwgY3V0b2ZmKVxuICB9XG4gIHJldHVybiB1cmwgKyAnPycgKyB1cmxFbmNvZGUocGFyYW1zLCAnR0VUJywgJ3VyaScpXG59IiwiIWZ1bmN0aW9uKGUpe2lmKFwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgbW9kdWxlKW1vZHVsZS5leHBvcnRzPWUoKTtlbHNlIGlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZClkZWZpbmUoW10sZSk7ZWxzZXt2YXIgZjtcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P2Y9d2luZG93OlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWw/Zj1nbG9iYWw6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJihmPXNlbGYpLGYuaW89ZSgpfX0oZnVuY3Rpb24oKXt2YXIgZGVmaW5lLG1vZHVsZSxleHBvcnRzO3JldHVybiBmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30oezE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPV9kZXJlcV8oXCIuL2xpYi9cIil9LHtcIi4vbGliL1wiOjJ9XSwyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgdXJsPV9kZXJlcV8oXCIuL3VybFwiKTt2YXIgcGFyc2VyPV9kZXJlcV8oXCJzb2NrZXQuaW8tcGFyc2VyXCIpO3ZhciBNYW5hZ2VyPV9kZXJlcV8oXCIuL21hbmFnZXJcIik7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcInNvY2tldC5pby1jbGllbnRcIik7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1sb29rdXA7dmFyIGNhY2hlPWV4cG9ydHMubWFuYWdlcnM9e307ZnVuY3Rpb24gbG9va3VwKHVyaSxvcHRzKXtpZih0eXBlb2YgdXJpPT1cIm9iamVjdFwiKXtvcHRzPXVyaTt1cmk9dW5kZWZpbmVkfW9wdHM9b3B0c3x8e307dmFyIHBhcnNlZD11cmwodXJpKTt2YXIgc291cmNlPXBhcnNlZC5zb3VyY2U7dmFyIGlkPXBhcnNlZC5pZDt2YXIgaW87aWYob3B0cy5mb3JjZU5ld3x8b3B0c1tcImZvcmNlIG5ldyBjb25uZWN0aW9uXCJdfHxmYWxzZT09PW9wdHMubXVsdGlwbGV4KXtkZWJ1ZyhcImlnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXNcIixzb3VyY2UpO2lvPU1hbmFnZXIoc291cmNlLG9wdHMpfWVsc2V7aWYoIWNhY2hlW2lkXSl7ZGVidWcoXCJuZXcgaW8gaW5zdGFuY2UgZm9yICVzXCIsc291cmNlKTtjYWNoZVtpZF09TWFuYWdlcihzb3VyY2Usb3B0cyl9aW89Y2FjaGVbaWRdfXJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgpfWV4cG9ydHMucHJvdG9jb2w9cGFyc2VyLnByb3RvY29sO2V4cG9ydHMuY29ubmVjdD1sb29rdXA7ZXhwb3J0cy5NYW5hZ2VyPV9kZXJlcV8oXCIuL21hbmFnZXJcIik7ZXhwb3J0cy5Tb2NrZXQ9X2RlcmVxXyhcIi4vc29ja2V0XCIpfSx7XCIuL21hbmFnZXJcIjozLFwiLi9zb2NrZXRcIjo1LFwiLi91cmxcIjo2LGRlYnVnOjEwLFwic29ja2V0LmlvLXBhcnNlclwiOjQ2fV0sMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHVybD1fZGVyZXFfKFwiLi91cmxcIik7dmFyIGVpbz1fZGVyZXFfKFwiZW5naW5lLmlvLWNsaWVudFwiKTt2YXIgU29ja2V0PV9kZXJlcV8oXCIuL3NvY2tldFwiKTt2YXIgRW1pdHRlcj1fZGVyZXFfKFwiY29tcG9uZW50LWVtaXR0ZXJcIik7dmFyIHBhcnNlcj1fZGVyZXFfKFwic29ja2V0LmlvLXBhcnNlclwiKTt2YXIgb249X2RlcmVxXyhcIi4vb25cIik7dmFyIGJpbmQ9X2RlcmVxXyhcImNvbXBvbmVudC1iaW5kXCIpO3ZhciBvYmplY3Q9X2RlcmVxXyhcIm9iamVjdC1jb21wb25lbnRcIik7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcInNvY2tldC5pby1jbGllbnQ6bWFuYWdlclwiKTt2YXIgaW5kZXhPZj1fZGVyZXFfKFwiaW5kZXhvZlwiKTt2YXIgQmFja29mZj1fZGVyZXFfKFwiYmFja28yXCIpO21vZHVsZS5leHBvcnRzPU1hbmFnZXI7ZnVuY3Rpb24gTWFuYWdlcih1cmksb3B0cyl7aWYoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSxvcHRzKTtpZih1cmkmJlwib2JqZWN0XCI9PXR5cGVvZiB1cmkpe29wdHM9dXJpO3VyaT11bmRlZmluZWR9b3B0cz1vcHRzfHx7fTtvcHRzLnBhdGg9b3B0cy5wYXRofHxcIi9zb2NrZXQuaW9cIjt0aGlzLm5zcHM9e307dGhpcy5zdWJzPVtdO3RoaXMub3B0cz1vcHRzO3RoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uIT09ZmFsc2UpO3RoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0c3x8SW5maW5pdHkpO3RoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheXx8MWUzKTt0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXh8fDVlMyk7dGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3Rvcnx8LjUpO3RoaXMuYmFja29mZj1uZXcgQmFja29mZih7bWluOnRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxtYXg6dGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLGppdHRlcjp0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKX0pO3RoaXMudGltZW91dChudWxsPT1vcHRzLnRpbWVvdXQ/MmU0Om9wdHMudGltZW91dCk7dGhpcy5yZWFkeVN0YXRlPVwiY2xvc2VkXCI7dGhpcy51cmk9dXJpO3RoaXMuY29ubmVjdGVkPVtdO3RoaXMuZW5jb2Rpbmc9ZmFsc2U7dGhpcy5wYWNrZXRCdWZmZXI9W107dGhpcy5lbmNvZGVyPW5ldyBwYXJzZXIuRW5jb2Rlcjt0aGlzLmRlY29kZXI9bmV3IHBhcnNlci5EZWNvZGVyO3RoaXMuYXV0b0Nvbm5lY3Q9b3B0cy5hdXRvQ29ubmVjdCE9PWZhbHNlO2lmKHRoaXMuYXV0b0Nvbm5lY3QpdGhpcy5vcGVuKCl9TWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbD1mdW5jdGlvbigpe3RoaXMuZW1pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7Zm9yKHZhciBuc3AgaW4gdGhpcy5uc3BzKXt0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLGFyZ3VtZW50cyl9fTtNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHM9ZnVuY3Rpb24oKXtmb3IodmFyIG5zcCBpbiB0aGlzLm5zcHMpe3RoaXMubnNwc1tuc3BdLmlkPXRoaXMuZW5naW5lLmlkfX07RW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uPWZ1bmN0aW9uKHYpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247dGhpcy5fcmVjb25uZWN0aW9uPSEhdjtyZXR1cm4gdGhpc307TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHM9ZnVuY3Rpb24odil7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO3RoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzPXY7cmV0dXJuIHRoaXN9O01hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5PWZ1bmN0aW9uKHYpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTt0aGlzLl9yZWNvbm5lY3Rpb25EZWxheT12O3RoaXMuYmFja29mZiYmdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtyZXR1cm4gdGhpc307TWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3Rvcj1mdW5jdGlvbih2KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3Rvcjt0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yPXY7dGhpcy5iYWNrb2ZmJiZ0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO3JldHVybiB0aGlzfTtNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heD1mdW5jdGlvbih2KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7dGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg9djt0aGlzLmJhY2tvZmYmJnRoaXMuYmFja29mZi5zZXRNYXgodik7cmV0dXJuIHRoaXN9O01hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQ9ZnVuY3Rpb24odil7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3RpbWVvdXQ7dGhpcy5fdGltZW91dD12O3JldHVybiB0aGlzfTtNYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3Blbj1mdW5jdGlvbigpe2lmKCF0aGlzLnJlY29ubmVjdGluZyYmdGhpcy5fcmVjb25uZWN0aW9uJiZ0aGlzLmJhY2tvZmYuYXR0ZW1wdHM9PT0wKXt0aGlzLnJlY29ubmVjdCgpfX07TWFuYWdlci5wcm90b3R5cGUub3Blbj1NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0PWZ1bmN0aW9uKGZuKXtkZWJ1ZyhcInJlYWR5U3RhdGUgJXNcIix0aGlzLnJlYWR5U3RhdGUpO2lmKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZihcIm9wZW5cIikpcmV0dXJuIHRoaXM7ZGVidWcoXCJvcGVuaW5nICVzXCIsdGhpcy51cmkpO3RoaXMuZW5naW5lPWVpbyh0aGlzLnVyaSx0aGlzLm9wdHMpO3ZhciBzb2NrZXQ9dGhpcy5lbmdpbmU7dmFyIHNlbGY9dGhpczt0aGlzLnJlYWR5U3RhdGU9XCJvcGVuaW5nXCI7dGhpcy5za2lwUmVjb25uZWN0PWZhbHNlO3ZhciBvcGVuU3ViPW9uKHNvY2tldCxcIm9wZW5cIixmdW5jdGlvbigpe3NlbGYub25vcGVuKCk7Zm4mJmZuKCl9KTt2YXIgZXJyb3JTdWI9b24oc29ja2V0LFwiZXJyb3JcIixmdW5jdGlvbihkYXRhKXtkZWJ1ZyhcImNvbm5lY3RfZXJyb3JcIik7c2VsZi5jbGVhbnVwKCk7c2VsZi5yZWFkeVN0YXRlPVwiY2xvc2VkXCI7c2VsZi5lbWl0QWxsKFwiY29ubmVjdF9lcnJvclwiLGRhdGEpO2lmKGZuKXt2YXIgZXJyPW5ldyBFcnJvcihcIkNvbm5lY3Rpb24gZXJyb3JcIik7ZXJyLmRhdGE9ZGF0YTtmbihlcnIpfWVsc2V7c2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpfX0pO2lmKGZhbHNlIT09dGhpcy5fdGltZW91dCl7dmFyIHRpbWVvdXQ9dGhpcy5fdGltZW91dDtkZWJ1ZyhcImNvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWRcIix0aW1lb3V0KTt2YXIgdGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2RlYnVnKFwiY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZFwiLHRpbWVvdXQpO29wZW5TdWIuZGVzdHJveSgpO3NvY2tldC5jbG9zZSgpO3NvY2tldC5lbWl0KFwiZXJyb3JcIixcInRpbWVvdXRcIik7c2VsZi5lbWl0QWxsKFwiY29ubmVjdF90aW1lb3V0XCIsdGltZW91dCl9LHRpbWVvdXQpO3RoaXMuc3Vicy5wdXNoKHtkZXN0cm95OmZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRpbWVyKX19KX10aGlzLnN1YnMucHVzaChvcGVuU3ViKTt0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7cmV0dXJuIHRoaXN9O01hbmFnZXIucHJvdG90eXBlLm9ub3Blbj1mdW5jdGlvbigpe2RlYnVnKFwib3BlblwiKTt0aGlzLmNsZWFudXAoKTt0aGlzLnJlYWR5U3RhdGU9XCJvcGVuXCI7dGhpcy5lbWl0KFwib3BlblwiKTt2YXIgc29ja2V0PXRoaXMuZW5naW5lO3RoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCxcImRhdGFcIixiaW5kKHRoaXMsXCJvbmRhdGFcIikpKTt0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsXCJkZWNvZGVkXCIsYmluZCh0aGlzLFwib25kZWNvZGVkXCIpKSk7dGhpcy5zdWJzLnB1c2gob24oc29ja2V0LFwiZXJyb3JcIixiaW5kKHRoaXMsXCJvbmVycm9yXCIpKSk7dGhpcy5zdWJzLnB1c2gob24oc29ja2V0LFwiY2xvc2VcIixiaW5kKHRoaXMsXCJvbmNsb3NlXCIpKSl9O01hbmFnZXIucHJvdG90eXBlLm9uZGF0YT1mdW5jdGlvbihkYXRhKXt0aGlzLmRlY29kZXIuYWRkKGRhdGEpfTtNYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQ9ZnVuY3Rpb24ocGFja2V0KXt0aGlzLmVtaXQoXCJwYWNrZXRcIixwYWNrZXQpfTtNYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yPWZ1bmN0aW9uKGVycil7ZGVidWcoXCJlcnJvclwiLGVycik7dGhpcy5lbWl0QWxsKFwiZXJyb3JcIixlcnIpfTtNYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQ9ZnVuY3Rpb24obnNwKXt2YXIgc29ja2V0PXRoaXMubnNwc1tuc3BdO2lmKCFzb2NrZXQpe3NvY2tldD1uZXcgU29ja2V0KHRoaXMsbnNwKTt0aGlzLm5zcHNbbnNwXT1zb2NrZXQ7dmFyIHNlbGY9dGhpcztzb2NrZXQub24oXCJjb25uZWN0XCIsZnVuY3Rpb24oKXtzb2NrZXQuaWQ9c2VsZi5lbmdpbmUuaWQ7aWYoIX5pbmRleE9mKHNlbGYuY29ubmVjdGVkLHNvY2tldCkpe3NlbGYuY29ubmVjdGVkLnB1c2goc29ja2V0KX19KX1yZXR1cm4gc29ja2V0fTtNYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKHNvY2tldCl7dmFyIGluZGV4PWluZGV4T2YodGhpcy5jb25uZWN0ZWQsc29ja2V0KTtpZih+aW5kZXgpdGhpcy5jb25uZWN0ZWQuc3BsaWNlKGluZGV4LDEpO2lmKHRoaXMuY29ubmVjdGVkLmxlbmd0aClyZXR1cm47dGhpcy5jbG9zZSgpfTtNYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQ9ZnVuY3Rpb24ocGFja2V0KXtkZWJ1ZyhcIndyaXRpbmcgcGFja2V0ICVqXCIscGFja2V0KTt2YXIgc2VsZj10aGlzO2lmKCFzZWxmLmVuY29kaW5nKXtzZWxmLmVuY29kaW5nPXRydWU7dGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsZnVuY3Rpb24oZW5jb2RlZFBhY2tldHMpe2Zvcih2YXIgaT0wO2k8ZW5jb2RlZFBhY2tldHMubGVuZ3RoO2krKyl7c2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0pfXNlbGYuZW5jb2Rpbmc9ZmFsc2U7c2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKX0pfWVsc2V7c2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpfX07TWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlPWZ1bmN0aW9uKCl7aWYodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoPjAmJiF0aGlzLmVuY29kaW5nKXt2YXIgcGFjaz10aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO3RoaXMucGFja2V0KHBhY2spfX07TWFuYWdlci5wcm90b3R5cGUuY2xlYW51cD1mdW5jdGlvbigpe3ZhciBzdWI7d2hpbGUoc3ViPXRoaXMuc3Vicy5zaGlmdCgpKXN1Yi5kZXN0cm95KCk7dGhpcy5wYWNrZXRCdWZmZXI9W107dGhpcy5lbmNvZGluZz1mYWxzZTt0aGlzLmRlY29kZXIuZGVzdHJveSgpfTtNYW5hZ2VyLnByb3RvdHlwZS5jbG9zZT1NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0PWZ1bmN0aW9uKCl7dGhpcy5za2lwUmVjb25uZWN0PXRydWU7dGhpcy5iYWNrb2ZmLnJlc2V0KCk7dGhpcy5yZWFkeVN0YXRlPVwiY2xvc2VkXCI7dGhpcy5lbmdpbmUmJnRoaXMuZW5naW5lLmNsb3NlKCl9O01hbmFnZXIucHJvdG90eXBlLm9uY2xvc2U9ZnVuY3Rpb24ocmVhc29uKXtkZWJ1ZyhcImNsb3NlXCIpO3RoaXMuY2xlYW51cCgpO3RoaXMuYmFja29mZi5yZXNldCgpO3RoaXMucmVhZHlTdGF0ZT1cImNsb3NlZFwiO3RoaXMuZW1pdChcImNsb3NlXCIscmVhc29uKTtpZih0aGlzLl9yZWNvbm5lY3Rpb24mJiF0aGlzLnNraXBSZWNvbm5lY3Qpe3RoaXMucmVjb25uZWN0KCl9fTtNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Q9ZnVuY3Rpb24oKXtpZih0aGlzLnJlY29ubmVjdGluZ3x8dGhpcy5za2lwUmVjb25uZWN0KXJldHVybiB0aGlzO3ZhciBzZWxmPXRoaXM7aWYodGhpcy5iYWNrb2ZmLmF0dGVtcHRzPj10aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyl7ZGVidWcoXCJyZWNvbm5lY3QgZmFpbGVkXCIpO3RoaXMuYmFja29mZi5yZXNldCgpO3RoaXMuZW1pdEFsbChcInJlY29ubmVjdF9mYWlsZWRcIik7dGhpcy5yZWNvbm5lY3Rpbmc9ZmFsc2V9ZWxzZXt2YXIgZGVsYXk9dGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7ZGVidWcoXCJ3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHRcIixkZWxheSk7dGhpcy5yZWNvbm5lY3Rpbmc9dHJ1ZTt2YXIgdGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2lmKHNlbGYuc2tpcFJlY29ubmVjdClyZXR1cm47ZGVidWcoXCJhdHRlbXB0aW5nIHJlY29ubmVjdFwiKTtzZWxmLmVtaXRBbGwoXCJyZWNvbm5lY3RfYXR0ZW1wdFwiLHNlbGYuYmFja29mZi5hdHRlbXB0cyk7c2VsZi5lbWl0QWxsKFwicmVjb25uZWN0aW5nXCIsc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtpZihzZWxmLnNraXBSZWNvbm5lY3QpcmV0dXJuO3NlbGYub3BlbihmdW5jdGlvbihlcnIpe2lmKGVycil7ZGVidWcoXCJyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvclwiKTtzZWxmLnJlY29ubmVjdGluZz1mYWxzZTtzZWxmLnJlY29ubmVjdCgpO3NlbGYuZW1pdEFsbChcInJlY29ubmVjdF9lcnJvclwiLGVyci5kYXRhKX1lbHNle2RlYnVnKFwicmVjb25uZWN0IHN1Y2Nlc3NcIik7c2VsZi5vbnJlY29ubmVjdCgpfX0pfSxkZWxheSk7dGhpcy5zdWJzLnB1c2goe2Rlc3Ryb3k6ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGltZXIpfX0pfX07TWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3Q9ZnVuY3Rpb24oKXt2YXIgYXR0ZW1wdD10aGlzLmJhY2tvZmYuYXR0ZW1wdHM7dGhpcy5yZWNvbm5lY3Rpbmc9ZmFsc2U7dGhpcy5iYWNrb2ZmLnJlc2V0KCk7dGhpcy51cGRhdGVTb2NrZXRJZHMoKTt0aGlzLmVtaXRBbGwoXCJyZWNvbm5lY3RcIixhdHRlbXB0KX19LHtcIi4vb25cIjo0LFwiLi9zb2NrZXRcIjo1LFwiLi91cmxcIjo2LGJhY2tvMjo3LFwiY29tcG9uZW50LWJpbmRcIjo4LFwiY29tcG9uZW50LWVtaXR0ZXJcIjo5LGRlYnVnOjEwLFwiZW5naW5lLmlvLWNsaWVudFwiOjExLGluZGV4b2Y6NDIsXCJvYmplY3QtY29tcG9uZW50XCI6NDMsXCJzb2NrZXQuaW8tcGFyc2VyXCI6NDZ9XSw0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1vbjtmdW5jdGlvbiBvbihvYmosZXYsZm4pe29iai5vbihldixmbik7cmV0dXJue2Rlc3Ryb3k6ZnVuY3Rpb24oKXtvYmoucmVtb3ZlTGlzdGVuZXIoZXYsZm4pfX19fSx7fV0sNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHBhcnNlcj1fZGVyZXFfKFwic29ja2V0LmlvLXBhcnNlclwiKTt2YXIgRW1pdHRlcj1fZGVyZXFfKFwiY29tcG9uZW50LWVtaXR0ZXJcIik7dmFyIHRvQXJyYXk9X2RlcmVxXyhcInRvLWFycmF5XCIpO3ZhciBvbj1fZGVyZXFfKFwiLi9vblwiKTt2YXIgYmluZD1fZGVyZXFfKFwiY29tcG9uZW50LWJpbmRcIik7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcInNvY2tldC5pby1jbGllbnQ6c29ja2V0XCIpO3ZhciBoYXNCaW49X2RlcmVxXyhcImhhcy1iaW5hcnlcIik7bW9kdWxlLmV4cG9ydHM9ZXhwb3J0cz1Tb2NrZXQ7dmFyIGV2ZW50cz17Y29ubmVjdDoxLGNvbm5lY3RfZXJyb3I6MSxjb25uZWN0X3RpbWVvdXQ6MSxkaXNjb25uZWN0OjEsZXJyb3I6MSxyZWNvbm5lY3Q6MSxyZWNvbm5lY3RfYXR0ZW1wdDoxLHJlY29ubmVjdF9mYWlsZWQ6MSxyZWNvbm5lY3RfZXJyb3I6MSxyZWNvbm5lY3Rpbmc6MX07dmFyIGVtaXQ9RW1pdHRlci5wcm90b3R5cGUuZW1pdDtmdW5jdGlvbiBTb2NrZXQoaW8sbnNwKXt0aGlzLmlvPWlvO3RoaXMubnNwPW5zcDt0aGlzLmpzb249dGhpczt0aGlzLmlkcz0wO3RoaXMuYWNrcz17fTtpZih0aGlzLmlvLmF1dG9Db25uZWN0KXRoaXMub3BlbigpO3RoaXMucmVjZWl2ZUJ1ZmZlcj1bXTt0aGlzLnNlbmRCdWZmZXI9W107dGhpcy5jb25uZWN0ZWQ9ZmFsc2U7dGhpcy5kaXNjb25uZWN0ZWQ9dHJ1ZX1FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1NvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzPWZ1bmN0aW9uKCl7aWYodGhpcy5zdWJzKXJldHVybjt2YXIgaW89dGhpcy5pbzt0aGlzLnN1YnM9W29uKGlvLFwib3BlblwiLGJpbmQodGhpcyxcIm9ub3BlblwiKSksb24oaW8sXCJwYWNrZXRcIixiaW5kKHRoaXMsXCJvbnBhY2tldFwiKSksb24oaW8sXCJjbG9zZVwiLGJpbmQodGhpcyxcIm9uY2xvc2VcIikpXX07U29ja2V0LnByb3RvdHlwZS5vcGVuPVNvY2tldC5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbigpe2lmKHRoaXMuY29ubmVjdGVkKXJldHVybiB0aGlzO3RoaXMuc3ViRXZlbnRzKCk7dGhpcy5pby5vcGVuKCk7aWYoXCJvcGVuXCI9PXRoaXMuaW8ucmVhZHlTdGF0ZSl0aGlzLm9ub3BlbigpO3JldHVybiB0aGlzfTtTb2NrZXQucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24oKXt2YXIgYXJncz10b0FycmF5KGFyZ3VtZW50cyk7YXJncy51bnNoaWZ0KFwibWVzc2FnZVwiKTt0aGlzLmVtaXQuYXBwbHkodGhpcyxhcmdzKTtyZXR1cm4gdGhpc307U29ja2V0LnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKGV2KXtpZihldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKXtlbWl0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4gdGhpc312YXIgYXJncz10b0FycmF5KGFyZ3VtZW50cyk7dmFyIHBhcnNlclR5cGU9cGFyc2VyLkVWRU5UO2lmKGhhc0JpbihhcmdzKSl7cGFyc2VyVHlwZT1wYXJzZXIuQklOQVJZX0VWRU5UfXZhciBwYWNrZXQ9e3R5cGU6cGFyc2VyVHlwZSxkYXRhOmFyZ3N9O2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGFyZ3NbYXJncy5sZW5ndGgtMV0pe2RlYnVnKFwiZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkXCIsdGhpcy5pZHMpO3RoaXMuYWNrc1t0aGlzLmlkc109YXJncy5wb3AoKTtwYWNrZXQuaWQ9dGhpcy5pZHMrK31pZih0aGlzLmNvbm5lY3RlZCl7dGhpcy5wYWNrZXQocGFja2V0KX1lbHNle3RoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCl9cmV0dXJuIHRoaXN9O1NvY2tldC5wcm90b3R5cGUucGFja2V0PWZ1bmN0aW9uKHBhY2tldCl7cGFja2V0Lm5zcD10aGlzLm5zcDt0aGlzLmlvLnBhY2tldChwYWNrZXQpfTtTb2NrZXQucHJvdG90eXBlLm9ub3Blbj1mdW5jdGlvbigpe2RlYnVnKFwidHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nXCIpO2lmKFwiL1wiIT10aGlzLm5zcCl7dGhpcy5wYWNrZXQoe3R5cGU6cGFyc2VyLkNPTk5FQ1R9KX19O1NvY2tldC5wcm90b3R5cGUub25jbG9zZT1mdW5jdGlvbihyZWFzb24pe2RlYnVnKFwiY2xvc2UgKCVzKVwiLHJlYXNvbik7dGhpcy5jb25uZWN0ZWQ9ZmFsc2U7dGhpcy5kaXNjb25uZWN0ZWQ9dHJ1ZTtkZWxldGUgdGhpcy5pZDt0aGlzLmVtaXQoXCJkaXNjb25uZWN0XCIscmVhc29uKX07U29ja2V0LnByb3RvdHlwZS5vbnBhY2tldD1mdW5jdGlvbihwYWNrZXQpe2lmKHBhY2tldC5uc3AhPXRoaXMubnNwKXJldHVybjtzd2l0Y2gocGFja2V0LnR5cGUpe2Nhc2UgcGFyc2VyLkNPTk5FQ1Q6dGhpcy5vbmNvbm5lY3QoKTticmVhaztjYXNlIHBhcnNlci5FVkVOVDp0aGlzLm9uZXZlbnQocGFja2V0KTticmVhaztjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6dGhpcy5vbmV2ZW50KHBhY2tldCk7YnJlYWs7Y2FzZSBwYXJzZXIuQUNLOnRoaXMub25hY2socGFja2V0KTticmVhaztjYXNlIHBhcnNlci5CSU5BUllfQUNLOnRoaXMub25hY2socGFja2V0KTticmVhaztjYXNlIHBhcnNlci5ESVNDT05ORUNUOnRoaXMub25kaXNjb25uZWN0KCk7YnJlYWs7Y2FzZSBwYXJzZXIuRVJST1I6dGhpcy5lbWl0KFwiZXJyb3JcIixwYWNrZXQuZGF0YSk7YnJlYWt9fTtTb2NrZXQucHJvdG90eXBlLm9uZXZlbnQ9ZnVuY3Rpb24ocGFja2V0KXt2YXIgYXJncz1wYWNrZXQuZGF0YXx8W107ZGVidWcoXCJlbWl0dGluZyBldmVudCAlalwiLGFyZ3MpO2lmKG51bGwhPXBhY2tldC5pZCl7ZGVidWcoXCJhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50XCIpO2FyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKX1pZih0aGlzLmNvbm5lY3RlZCl7ZW1pdC5hcHBseSh0aGlzLGFyZ3MpfWVsc2V7dGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyl9fTtTb2NrZXQucHJvdG90eXBlLmFjaz1mdW5jdGlvbihpZCl7dmFyIHNlbGY9dGhpczt2YXIgc2VudD1mYWxzZTtyZXR1cm4gZnVuY3Rpb24oKXtpZihzZW50KXJldHVybjtzZW50PXRydWU7dmFyIGFyZ3M9dG9BcnJheShhcmd1bWVudHMpO2RlYnVnKFwic2VuZGluZyBhY2sgJWpcIixhcmdzKTt2YXIgdHlwZT1oYXNCaW4oYXJncyk/cGFyc2VyLkJJTkFSWV9BQ0s6cGFyc2VyLkFDSztzZWxmLnBhY2tldCh7dHlwZTp0eXBlLGlkOmlkLGRhdGE6YXJnc30pfX07U29ja2V0LnByb3RvdHlwZS5vbmFjaz1mdW5jdGlvbihwYWNrZXQpe2RlYnVnKFwiY2FsbGluZyBhY2sgJXMgd2l0aCAlalwiLHBhY2tldC5pZCxwYWNrZXQuZGF0YSk7dmFyIGZuPXRoaXMuYWNrc1twYWNrZXQuaWRdO2ZuLmFwcGx5KHRoaXMscGFja2V0LmRhdGEpO2RlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXX07U29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3Q9ZnVuY3Rpb24oKXt0aGlzLmNvbm5lY3RlZD10cnVlO3RoaXMuZGlzY29ubmVjdGVkPWZhbHNlO3RoaXMuZW1pdChcImNvbm5lY3RcIik7dGhpcy5lbWl0QnVmZmVyZWQoKX07U29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQ9ZnVuY3Rpb24oKXt2YXIgaTtmb3IoaT0wO2k8dGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDtpKyspe2VtaXQuYXBwbHkodGhpcyx0aGlzLnJlY2VpdmVCdWZmZXJbaV0pfXRoaXMucmVjZWl2ZUJ1ZmZlcj1bXTtmb3IoaT0wO2k8dGhpcy5zZW5kQnVmZmVyLmxlbmd0aDtpKyspe3RoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSl9dGhpcy5zZW5kQnVmZmVyPVtdfTtTb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdD1mdW5jdGlvbigpe2RlYnVnKFwic2VydmVyIGRpc2Nvbm5lY3QgKCVzKVwiLHRoaXMubnNwKTt0aGlzLmRlc3Ryb3koKTt0aGlzLm9uY2xvc2UoXCJpbyBzZXJ2ZXIgZGlzY29ubmVjdFwiKX07U29ja2V0LnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7aWYodGhpcy5zdWJzKXtmb3IodmFyIGk9MDtpPHRoaXMuc3Vicy5sZW5ndGg7aSsrKXt0aGlzLnN1YnNbaV0uZGVzdHJveSgpfXRoaXMuc3Vicz1udWxsfXRoaXMuaW8uZGVzdHJveSh0aGlzKX07U29ja2V0LnByb3RvdHlwZS5jbG9zZT1Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3Q9ZnVuY3Rpb24oKXtpZih0aGlzLmNvbm5lY3RlZCl7ZGVidWcoXCJwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKVwiLHRoaXMubnNwKTt0aGlzLnBhY2tldCh7dHlwZTpwYXJzZXIuRElTQ09OTkVDVH0pfXRoaXMuZGVzdHJveSgpO2lmKHRoaXMuY29ubmVjdGVkKXt0aGlzLm9uY2xvc2UoXCJpbyBjbGllbnQgZGlzY29ubmVjdFwiKX1yZXR1cm4gdGhpc319LHtcIi4vb25cIjo0LFwiY29tcG9uZW50LWJpbmRcIjo4LFwiY29tcG9uZW50LWVtaXR0ZXJcIjo5LGRlYnVnOjEwLFwiaGFzLWJpbmFyeVwiOjM4LFwic29ja2V0LmlvLXBhcnNlclwiOjQ2LFwidG8tYXJyYXlcIjo1MH1dLDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBwYXJzZXVyaT1fZGVyZXFfKFwicGFyc2V1cmlcIik7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcInNvY2tldC5pby1jbGllbnQ6dXJsXCIpO21vZHVsZS5leHBvcnRzPXVybDtmdW5jdGlvbiB1cmwodXJpLGxvYyl7dmFyIG9iaj11cmk7dmFyIGxvYz1sb2N8fGdsb2JhbC5sb2NhdGlvbjtpZihudWxsPT11cmkpdXJpPWxvYy5wcm90b2NvbCtcIi8vXCIrbG9jLmhvc3Q7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHVyaSl7aWYoXCIvXCI9PXVyaS5jaGFyQXQoMCkpe2lmKFwiL1wiPT11cmkuY2hhckF0KDEpKXt1cmk9bG9jLnByb3RvY29sK3VyaX1lbHNle3VyaT1sb2MuaG9zdG5hbWUrdXJpfX1pZighL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKXtkZWJ1ZyhcInByb3RvY29sLWxlc3MgdXJsICVzXCIsdXJpKTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgbG9jKXt1cmk9bG9jLnByb3RvY29sK1wiLy9cIit1cml9ZWxzZXt1cmk9XCJodHRwczovL1wiK3VyaX19ZGVidWcoXCJwYXJzZSAlc1wiLHVyaSk7b2JqPXBhcnNldXJpKHVyaSl9aWYoIW9iai5wb3J0KXtpZigvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSl7b2JqLnBvcnQ9XCI4MFwifWVsc2UgaWYoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKXtvYmoucG9ydD1cIjQ0M1wifX1vYmoucGF0aD1vYmoucGF0aHx8XCIvXCI7b2JqLmlkPW9iai5wcm90b2NvbCtcIjovL1wiK29iai5ob3N0K1wiOlwiK29iai5wb3J0O29iai5ocmVmPW9iai5wcm90b2NvbCtcIjovL1wiK29iai5ob3N0Kyhsb2MmJmxvYy5wb3J0PT1vYmoucG9ydD9cIlwiOlwiOlwiK29iai5wb3J0KTtyZXR1cm4gb2JqfX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7ZGVidWc6MTAscGFyc2V1cmk6NDR9XSw3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1CYWNrb2ZmO2Z1bmN0aW9uIEJhY2tvZmYob3B0cyl7b3B0cz1vcHRzfHx7fTt0aGlzLm1zPW9wdHMubWlufHwxMDA7dGhpcy5tYXg9b3B0cy5tYXh8fDFlNDt0aGlzLmZhY3Rvcj1vcHRzLmZhY3Rvcnx8Mjt0aGlzLmppdHRlcj1vcHRzLmppdHRlcj4wJiZvcHRzLmppdHRlcjw9MT9vcHRzLmppdHRlcjowO3RoaXMuYXR0ZW1wdHM9MH1CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbj1mdW5jdGlvbigpe3ZhciBtcz10aGlzLm1zKk1hdGgucG93KHRoaXMuZmFjdG9yLHRoaXMuYXR0ZW1wdHMrKyk7aWYodGhpcy5qaXR0ZXIpe3ZhciByYW5kPU1hdGgucmFuZG9tKCk7dmFyIGRldmlhdGlvbj1NYXRoLmZsb29yKHJhbmQqdGhpcy5qaXR0ZXIqbXMpO21zPShNYXRoLmZsb29yKHJhbmQqMTApJjEpPT0wP21zLWRldmlhdGlvbjptcytkZXZpYXRpb259cmV0dXJuIE1hdGgubWluKG1zLHRoaXMubWF4KXwwfTtCYWNrb2ZmLnByb3RvdHlwZS5yZXNldD1mdW5jdGlvbigpe3RoaXMuYXR0ZW1wdHM9MH07QmFja29mZi5wcm90b3R5cGUuc2V0TWluPWZ1bmN0aW9uKG1pbil7dGhpcy5tcz1taW59O0JhY2tvZmYucHJvdG90eXBlLnNldE1heD1mdW5jdGlvbihtYXgpe3RoaXMubWF4PW1heH07QmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyPWZ1bmN0aW9uKGppdHRlcil7dGhpcy5qaXR0ZXI9aml0dGVyfX0se31dLDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBzbGljZT1bXS5zbGljZTttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihvYmosZm4pe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBmbilmbj1vYmpbZm5dO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGZuKXRocm93IG5ldyBFcnJvcihcImJpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uXCIpO3ZhciBhcmdzPXNsaWNlLmNhbGwoYXJndW1lbnRzLDIpO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBmbi5hcHBseShvYmosYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSl9fX0se31dLDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPUVtaXR0ZXI7ZnVuY3Rpb24gRW1pdHRlcihvYmope2lmKG9iailyZXR1cm4gbWl4aW4ob2JqKX1mdW5jdGlvbiBtaXhpbihvYmope2Zvcih2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKXtvYmpba2V5XT1FbWl0dGVyLnByb3RvdHlwZVtrZXldfXJldHVybiBvYmp9RW1pdHRlci5wcm90b3R5cGUub249RW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihldmVudCxmbil7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e307KHRoaXMuX2NhbGxiYWNrc1tldmVudF09dGhpcy5fY2FsbGJhY2tzW2V2ZW50XXx8W10pLnB1c2goZm4pO3JldHVybiB0aGlzfTtFbWl0dGVyLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uKGV2ZW50LGZuKXt2YXIgc2VsZj10aGlzO3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9O2Z1bmN0aW9uIG9uKCl7c2VsZi5vZmYoZXZlbnQsb24pO2ZuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1vbi5mbj1mbjt0aGlzLm9uKGV2ZW50LG9uKTtyZXR1cm4gdGhpc307RW1pdHRlci5wcm90b3R5cGUub2ZmPUVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPUVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGV2ZW50LGZuKXt0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fTtpZigwPT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLl9jYWxsYmFja3M9e307cmV0dXJuIHRoaXN9dmFyIGNhbGxiYWNrcz10aGlzLl9jYWxsYmFja3NbZXZlbnRdO2lmKCFjYWxsYmFja3MpcmV0dXJuIHRoaXM7aWYoMT09YXJndW1lbnRzLmxlbmd0aCl7ZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07cmV0dXJuIHRoaXN9dmFyIGNiO2Zvcih2YXIgaT0wO2k8Y2FsbGJhY2tzLmxlbmd0aDtpKyspe2NiPWNhbGxiYWNrc1tpXTtpZihjYj09PWZufHxjYi5mbj09PWZuKXtjYWxsYmFja3Muc3BsaWNlKGksMSk7YnJlYWt9fXJldHVybiB0aGlzfTtFbWl0dGVyLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKGV2ZW50KXt0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fTt2YXIgYXJncz1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxjYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtpZihjYWxsYmFja3Mpe2NhbGxiYWNrcz1jYWxsYmFja3Muc2xpY2UoMCk7Zm9yKHZhciBpPTAsbGVuPWNhbGxiYWNrcy5sZW5ndGg7aTxsZW47KytpKXtjYWxsYmFja3NbaV0uYXBwbHkodGhpcyxhcmdzKX19cmV0dXJuIHRoaXN9O0VtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycz1mdW5jdGlvbihldmVudCl7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e307cmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF18fFtdfTtFbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnM9ZnVuY3Rpb24oZXZlbnQpe3JldHVybiEhdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aH19LHt9XSwxMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9ZGVidWc7ZnVuY3Rpb24gZGVidWcobmFtZSl7aWYoIWRlYnVnLmVuYWJsZWQobmFtZSkpcmV0dXJuIGZ1bmN0aW9uKCl7fTtyZXR1cm4gZnVuY3Rpb24oZm10KXtmbXQ9Y29lcmNlKGZtdCk7dmFyIGN1cnI9bmV3IERhdGU7dmFyIG1zPWN1cnItKGRlYnVnW25hbWVdfHxjdXJyKTtkZWJ1Z1tuYW1lXT1jdXJyO2ZtdD1uYW1lK1wiIFwiK2ZtdCtcIiArXCIrZGVidWcuaHVtYW5pemUobXMpO3dpbmRvdy5jb25zb2xlJiZjb25zb2xlLmxvZyYmRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csY29uc29sZSxhcmd1bWVudHMpfX1kZWJ1Zy5uYW1lcz1bXTtkZWJ1Zy5za2lwcz1bXTtkZWJ1Zy5lbmFibGU9ZnVuY3Rpb24obmFtZSl7dHJ5e2xvY2FsU3RvcmFnZS5kZWJ1Zz1uYW1lfWNhdGNoKGUpe312YXIgc3BsaXQ9KG5hbWV8fFwiXCIpLnNwbGl0KC9bXFxzLF0rLyksbGVuPXNwbGl0Lmxlbmd0aDtmb3IodmFyIGk9MDtpPGxlbjtpKyspe25hbWU9c3BsaXRbaV0ucmVwbGFjZShcIipcIixcIi4qP1wiKTtpZihuYW1lWzBdPT09XCItXCIpe2RlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cChcIl5cIituYW1lLnN1YnN0cigxKStcIiRcIikpfWVsc2V7ZGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKFwiXlwiK25hbWUrXCIkXCIpKX19fTtkZWJ1Zy5kaXNhYmxlPWZ1bmN0aW9uKCl7ZGVidWcuZW5hYmxlKFwiXCIpfTtkZWJ1Zy5odW1hbml6ZT1mdW5jdGlvbihtcyl7dmFyIHNlYz0xZTMsbWluPTYwKjFlMyxob3VyPTYwKm1pbjtpZihtcz49aG91cilyZXR1cm4obXMvaG91cikudG9GaXhlZCgxKStcImhcIjtpZihtcz49bWluKXJldHVybihtcy9taW4pLnRvRml4ZWQoMSkrXCJtXCI7aWYobXM+PXNlYylyZXR1cm4obXMvc2VjfDApK1wic1wiO3JldHVybiBtcytcIm1zXCJ9O2RlYnVnLmVuYWJsZWQ9ZnVuY3Rpb24obmFtZSl7Zm9yKHZhciBpPTAsbGVuPWRlYnVnLnNraXBzLmxlbmd0aDtpPGxlbjtpKyspe2lmKGRlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpe3JldHVybiBmYWxzZX19Zm9yKHZhciBpPTAsbGVuPWRlYnVnLm5hbWVzLmxlbmd0aDtpPGxlbjtpKyspe2lmKGRlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O2Z1bmN0aW9uIGNvZXJjZSh2YWwpe2lmKHZhbCBpbnN0YW5jZW9mIEVycm9yKXJldHVybiB2YWwuc3RhY2t8fHZhbC5tZXNzYWdlO3JldHVybiB2YWx9dHJ5e2lmKHdpbmRvdy5sb2NhbFN0b3JhZ2UpZGVidWcuZW5hYmxlKGxvY2FsU3RvcmFnZS5kZWJ1Zyl9Y2F0Y2goZSl7fX0se31dLDExOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1fZGVyZXFfKFwiLi9saWIvXCIpfSx7XCIuL2xpYi9cIjoxMn1dLDEyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1fZGVyZXFfKFwiLi9zb2NrZXRcIik7bW9kdWxlLmV4cG9ydHMucGFyc2VyPV9kZXJlcV8oXCJlbmdpbmUuaW8tcGFyc2VyXCIpfSx7XCIuL3NvY2tldFwiOjEzLFwiZW5naW5lLmlvLXBhcnNlclwiOjI1fV0sMTM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciB0cmFuc3BvcnRzPV9kZXJlcV8oXCIuL3RyYW5zcG9ydHNcIik7dmFyIEVtaXR0ZXI9X2RlcmVxXyhcImNvbXBvbmVudC1lbWl0dGVyXCIpO3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJlbmdpbmUuaW8tY2xpZW50OnNvY2tldFwiKTt2YXIgaW5kZXg9X2RlcmVxXyhcImluZGV4b2ZcIik7dmFyIHBhcnNlcj1fZGVyZXFfKFwiZW5naW5lLmlvLXBhcnNlclwiKTt2YXIgcGFyc2V1cmk9X2RlcmVxXyhcInBhcnNldXJpXCIpO3ZhciBwYXJzZWpzb249X2RlcmVxXyhcInBhcnNlanNvblwiKTt2YXIgcGFyc2Vxcz1fZGVyZXFfKFwicGFyc2Vxc1wiKTttb2R1bGUuZXhwb3J0cz1Tb2NrZXQ7ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBTb2NrZXQodXJpLG9wdHMpe2lmKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpcmV0dXJuIG5ldyBTb2NrZXQodXJpLG9wdHMpO29wdHM9b3B0c3x8e307aWYodXJpJiZcIm9iamVjdFwiPT10eXBlb2YgdXJpKXtvcHRzPXVyaTt1cmk9bnVsbH1pZih1cmkpe3VyaT1wYXJzZXVyaSh1cmkpO29wdHMuaG9zdD11cmkuaG9zdDtvcHRzLnNlY3VyZT11cmkucHJvdG9jb2w9PVwiaHR0cHNcInx8dXJpLnByb3RvY29sPT1cIndzc1wiO29wdHMucG9ydD11cmkucG9ydDtpZih1cmkucXVlcnkpb3B0cy5xdWVyeT11cmkucXVlcnl9dGhpcy5zZWN1cmU9bnVsbCE9b3B0cy5zZWN1cmU/b3B0cy5zZWN1cmU6Z2xvYmFsLmxvY2F0aW9uJiZcImh0dHBzOlwiPT1sb2NhdGlvbi5wcm90b2NvbDtpZihvcHRzLmhvc3Qpe3ZhciBwaWVjZXM9b3B0cy5ob3N0LnNwbGl0KFwiOlwiKTtvcHRzLmhvc3RuYW1lPXBpZWNlcy5zaGlmdCgpO2lmKHBpZWNlcy5sZW5ndGgpe29wdHMucG9ydD1waWVjZXMucG9wKCl9ZWxzZSBpZighb3B0cy5wb3J0KXtvcHRzLnBvcnQ9dGhpcy5zZWN1cmU/XCI0NDNcIjpcIjgwXCJ9fXRoaXMuYWdlbnQ9b3B0cy5hZ2VudHx8ZmFsc2U7dGhpcy5ob3N0bmFtZT1vcHRzLmhvc3RuYW1lfHwoZ2xvYmFsLmxvY2F0aW9uP2xvY2F0aW9uLmhvc3RuYW1lOlwibG9jYWxob3N0XCIpO3RoaXMucG9ydD1vcHRzLnBvcnR8fChnbG9iYWwubG9jYXRpb24mJmxvY2F0aW9uLnBvcnQ/bG9jYXRpb24ucG9ydDp0aGlzLnNlY3VyZT80NDM6ODApO3RoaXMucXVlcnk9b3B0cy5xdWVyeXx8e307aWYoXCJzdHJpbmdcIj09dHlwZW9mIHRoaXMucXVlcnkpdGhpcy5xdWVyeT1wYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTt0aGlzLnVwZ3JhZGU9ZmFsc2UhPT1vcHRzLnVwZ3JhZGU7dGhpcy5wYXRoPShvcHRzLnBhdGh8fFwiL2VuZ2luZS5pb1wiKS5yZXBsYWNlKC9cXC8kLyxcIlwiKStcIi9cIjt0aGlzLmZvcmNlSlNPTlA9ISFvcHRzLmZvcmNlSlNPTlA7dGhpcy5qc29ucD1mYWxzZSE9PW9wdHMuanNvbnA7dGhpcy5mb3JjZUJhc2U2ND0hIW9wdHMuZm9yY2VCYXNlNjQ7dGhpcy5lbmFibGVzWERSPSEhb3B0cy5lbmFibGVzWERSO3RoaXMudGltZXN0YW1wUGFyYW09b3B0cy50aW1lc3RhbXBQYXJhbXx8XCJ0XCI7dGhpcy50aW1lc3RhbXBSZXF1ZXN0cz1vcHRzLnRpbWVzdGFtcFJlcXVlc3RzO3RoaXMudHJhbnNwb3J0cz1vcHRzLnRyYW5zcG9ydHN8fFtcInBvbGxpbmdcIixcIndlYnNvY2tldFwiXTt0aGlzLnJlYWR5U3RhdGU9XCJcIjt0aGlzLndyaXRlQnVmZmVyPVtdO3RoaXMuY2FsbGJhY2tCdWZmZXI9W107dGhpcy5wb2xpY3lQb3J0PW9wdHMucG9saWN5UG9ydHx8ODQzO3RoaXMucmVtZW1iZXJVcGdyYWRlPW9wdHMucmVtZW1iZXJVcGdyYWRlfHxmYWxzZTt0aGlzLmJpbmFyeVR5cGU9bnVsbDt0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcz1vcHRzLm9ubHlCaW5hcnlVcGdyYWRlczt0aGlzLnBmeD1vcHRzLnBmeHx8bnVsbDt0aGlzLmtleT1vcHRzLmtleXx8bnVsbDt0aGlzLnBhc3NwaHJhc2U9b3B0cy5wYXNzcGhyYXNlfHxudWxsO3RoaXMuY2VydD1vcHRzLmNlcnR8fG51bGw7dGhpcy5jYT1vcHRzLmNhfHxudWxsO3RoaXMuY2lwaGVycz1vcHRzLmNpcGhlcnN8fG51bGw7dGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ9b3B0cy5yZWplY3RVbmF1dGhvcml6ZWR8fG51bGw7dGhpcy5vcGVuKCl9U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2Vzcz1mYWxzZTtFbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1NvY2tldC5wcm90b2NvbD1wYXJzZXIucHJvdG9jb2w7U29ja2V0LlNvY2tldD1Tb2NrZXQ7U29ja2V0LlRyYW5zcG9ydD1fZGVyZXFfKFwiLi90cmFuc3BvcnRcIik7U29ja2V0LnRyYW5zcG9ydHM9X2RlcmVxXyhcIi4vdHJhbnNwb3J0c1wiKTtTb2NrZXQucGFyc2VyPV9kZXJlcV8oXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1NvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0PWZ1bmN0aW9uKG5hbWUpe2RlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJyxuYW1lKTt2YXIgcXVlcnk9Y2xvbmUodGhpcy5xdWVyeSk7cXVlcnkuRUlPPXBhcnNlci5wcm90b2NvbDtxdWVyeS50cmFuc3BvcnQ9bmFtZTtpZih0aGlzLmlkKXF1ZXJ5LnNpZD10aGlzLmlkO3ZhciB0cmFuc3BvcnQ9bmV3IHRyYW5zcG9ydHNbbmFtZV0oe2FnZW50OnRoaXMuYWdlbnQsaG9zdG5hbWU6dGhpcy5ob3N0bmFtZSxwb3J0OnRoaXMucG9ydCxzZWN1cmU6dGhpcy5zZWN1cmUscGF0aDp0aGlzLnBhdGgscXVlcnk6cXVlcnksZm9yY2VKU09OUDp0aGlzLmZvcmNlSlNPTlAsanNvbnA6dGhpcy5qc29ucCxmb3JjZUJhc2U2NDp0aGlzLmZvcmNlQmFzZTY0LGVuYWJsZXNYRFI6dGhpcy5lbmFibGVzWERSLHRpbWVzdGFtcFJlcXVlc3RzOnRoaXMudGltZXN0YW1wUmVxdWVzdHMsdGltZXN0YW1wUGFyYW06dGhpcy50aW1lc3RhbXBQYXJhbSxwb2xpY3lQb3J0OnRoaXMucG9saWN5UG9ydCxzb2NrZXQ6dGhpcyxwZng6dGhpcy5wZngsa2V5OnRoaXMua2V5LHBhc3NwaHJhc2U6dGhpcy5wYXNzcGhyYXNlLGNlcnQ6dGhpcy5jZXJ0LGNhOnRoaXMuY2EsY2lwaGVyczp0aGlzLmNpcGhlcnMscmVqZWN0VW5hdXRob3JpemVkOnRoaXMucmVqZWN0VW5hdXRob3JpemVkfSk7cmV0dXJuIHRyYW5zcG9ydH07ZnVuY3Rpb24gY2xvbmUob2JqKXt2YXIgbz17fTtmb3IodmFyIGkgaW4gb2JqKXtpZihvYmouaGFzT3duUHJvcGVydHkoaSkpe29baV09b2JqW2ldfX1yZXR1cm4gb31Tb2NrZXQucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oKXt2YXIgdHJhbnNwb3J0O2lmKHRoaXMucmVtZW1iZXJVcGdyYWRlJiZTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzJiZ0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZihcIndlYnNvY2tldFwiKSE9LTEpe3RyYW5zcG9ydD1cIndlYnNvY2tldFwifWVsc2UgaWYoMD09dGhpcy50cmFuc3BvcnRzLmxlbmd0aCl7dmFyIHNlbGY9dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2VsZi5lbWl0KFwiZXJyb3JcIixcIk5vIHRyYW5zcG9ydHMgYXZhaWxhYmxlXCIpfSwwKTtyZXR1cm59ZWxzZXt0cmFuc3BvcnQ9dGhpcy50cmFuc3BvcnRzWzBdfXRoaXMucmVhZHlTdGF0ZT1cIm9wZW5pbmdcIjt2YXIgdHJhbnNwb3J0O3RyeXt0cmFuc3BvcnQ9dGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KX1jYXRjaChlKXt0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTt0aGlzLm9wZW4oKTtyZXR1cm59dHJhbnNwb3J0Lm9wZW4oKTt0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpfTtTb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydD1mdW5jdGlvbih0cmFuc3BvcnQpe2RlYnVnKFwic2V0dGluZyB0cmFuc3BvcnQgJXNcIix0cmFuc3BvcnQubmFtZSk7dmFyIHNlbGY9dGhpcztpZih0aGlzLnRyYW5zcG9ydCl7ZGVidWcoXCJjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXNcIix0aGlzLnRyYW5zcG9ydC5uYW1lKTt0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKX10aGlzLnRyYW5zcG9ydD10cmFuc3BvcnQ7dHJhbnNwb3J0Lm9uKFwiZHJhaW5cIixmdW5jdGlvbigpe3NlbGYub25EcmFpbigpfSkub24oXCJwYWNrZXRcIixmdW5jdGlvbihwYWNrZXQpe3NlbGYub25QYWNrZXQocGFja2V0KX0pLm9uKFwiZXJyb3JcIixmdW5jdGlvbihlKXtzZWxmLm9uRXJyb3IoZSl9KS5vbihcImNsb3NlXCIsZnVuY3Rpb24oKXtzZWxmLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgY2xvc2VcIil9KX07U29ja2V0LnByb3RvdHlwZS5wcm9iZT1mdW5jdGlvbihuYW1lKXtkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJyxuYW1lKTt2YXIgdHJhbnNwb3J0PXRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUse3Byb2JlOjF9KSxmYWlsZWQ9ZmFsc2Usc2VsZj10aGlzO1NvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3M9ZmFsc2U7ZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuKCl7aWYoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpe3ZhciB1cGdyYWRlTG9zZXNCaW5hcnk9IXRoaXMuc3VwcG9ydHNCaW5hcnkmJnNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O2ZhaWxlZD1mYWlsZWR8fHVwZ3JhZGVMb3Nlc0JpbmFyeX1pZihmYWlsZWQpcmV0dXJuO2RlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsbmFtZSk7dHJhbnNwb3J0LnNlbmQoW3t0eXBlOlwicGluZ1wiLGRhdGE6XCJwcm9iZVwifV0pO3RyYW5zcG9ydC5vbmNlKFwicGFja2V0XCIsZnVuY3Rpb24obXNnKXtpZihmYWlsZWQpcmV0dXJuO2lmKFwicG9uZ1wiPT1tc2cudHlwZSYmXCJwcm9iZVwiPT1tc2cuZGF0YSl7ZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsbmFtZSk7c2VsZi51cGdyYWRpbmc9dHJ1ZTtzZWxmLmVtaXQoXCJ1cGdyYWRpbmdcIix0cmFuc3BvcnQpO2lmKCF0cmFuc3BvcnQpcmV0dXJuO1NvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3M9XCJ3ZWJzb2NrZXRcIj09dHJhbnNwb3J0Lm5hbWU7ZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJyxzZWxmLnRyYW5zcG9ydC5uYW1lKTtzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbigpe2lmKGZhaWxlZClyZXR1cm47aWYoXCJjbG9zZWRcIj09c2VsZi5yZWFkeVN0YXRlKXJldHVybjtkZWJ1ZyhcImNoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldFwiKTtjbGVhbnVwKCk7c2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTt0cmFuc3BvcnQuc2VuZChbe3R5cGU6XCJ1cGdyYWRlXCJ9XSk7c2VsZi5lbWl0KFwidXBncmFkZVwiLHRyYW5zcG9ydCk7dHJhbnNwb3J0PW51bGw7c2VsZi51cGdyYWRpbmc9ZmFsc2U7c2VsZi5mbHVzaCgpfSl9ZWxzZXtkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLG5hbWUpO3ZhciBlcnI9bmV3IEVycm9yKFwicHJvYmUgZXJyb3JcIik7ZXJyLnRyYW5zcG9ydD10cmFuc3BvcnQubmFtZTtzZWxmLmVtaXQoXCJ1cGdyYWRlRXJyb3JcIixlcnIpfX0pfWZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCgpe2lmKGZhaWxlZClyZXR1cm47ZmFpbGVkPXRydWU7Y2xlYW51cCgpO3RyYW5zcG9ydC5jbG9zZSgpO3RyYW5zcG9ydD1udWxsfWZ1bmN0aW9uIG9uZXJyb3IoZXJyKXt2YXIgZXJyb3I9bmV3IEVycm9yKFwicHJvYmUgZXJyb3I6IFwiK2Vycik7ZXJyb3IudHJhbnNwb3J0PXRyYW5zcG9ydC5uYW1lO2ZyZWV6ZVRyYW5zcG9ydCgpO2RlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsbmFtZSxlcnIpO3NlbGYuZW1pdChcInVwZ3JhZGVFcnJvclwiLGVycm9yKX1mdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlKCl7b25lcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIil9ZnVuY3Rpb24gb25jbG9zZSgpe29uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpfWZ1bmN0aW9uIG9udXBncmFkZSh0byl7aWYodHJhbnNwb3J0JiZ0by5uYW1lIT10cmFuc3BvcnQubmFtZSl7ZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsdG8ubmFtZSx0cmFuc3BvcnQubmFtZSk7ZnJlZXplVHJhbnNwb3J0KCl9fWZ1bmN0aW9uIGNsZWFudXAoKXt0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJvcGVuXCIsb25UcmFuc3BvcnRPcGVuKTt0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLG9uZXJyb3IpO3RyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsb25UcmFuc3BvcnRDbG9zZSk7c2VsZi5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsb25jbG9zZSk7c2VsZi5yZW1vdmVMaXN0ZW5lcihcInVwZ3JhZGluZ1wiLG9udXBncmFkZSl9dHJhbnNwb3J0Lm9uY2UoXCJvcGVuXCIsb25UcmFuc3BvcnRPcGVuKTt0cmFuc3BvcnQub25jZShcImVycm9yXCIsb25lcnJvcik7dHJhbnNwb3J0Lm9uY2UoXCJjbG9zZVwiLG9uVHJhbnNwb3J0Q2xvc2UpO3RoaXMub25jZShcImNsb3NlXCIsb25jbG9zZSk7dGhpcy5vbmNlKFwidXBncmFkaW5nXCIsb251cGdyYWRlKTt0cmFuc3BvcnQub3BlbigpfTtTb2NrZXQucHJvdG90eXBlLm9uT3Blbj1mdW5jdGlvbigpe2RlYnVnKFwic29ja2V0IG9wZW5cIik7dGhpcy5yZWFkeVN0YXRlPVwib3BlblwiO1NvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3M9XCJ3ZWJzb2NrZXRcIj09dGhpcy50cmFuc3BvcnQubmFtZTt0aGlzLmVtaXQoXCJvcGVuXCIpO3RoaXMuZmx1c2goKTtpZihcIm9wZW5cIj09dGhpcy5yZWFkeVN0YXRlJiZ0aGlzLnVwZ3JhZGUmJnRoaXMudHJhbnNwb3J0LnBhdXNlKXtkZWJ1ZyhcInN0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzXCIpO2Zvcih2YXIgaT0wLGw9dGhpcy51cGdyYWRlcy5sZW5ndGg7aTxsO2krKyl7dGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKX19fTtTb2NrZXQucHJvdG90eXBlLm9uUGFja2V0PWZ1bmN0aW9uKHBhY2tldCl7aWYoXCJvcGVuaW5nXCI9PXRoaXMucmVhZHlTdGF0ZXx8XCJvcGVuXCI9PXRoaXMucmVhZHlTdGF0ZSl7ZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLHBhY2tldC50eXBlLHBhY2tldC5kYXRhKTt0aGlzLmVtaXQoXCJwYWNrZXRcIixwYWNrZXQpO3RoaXMuZW1pdChcImhlYXJ0YmVhdFwiKTtzd2l0Y2gocGFja2V0LnR5cGUpe2Nhc2VcIm9wZW5cIjp0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO2JyZWFrO2Nhc2VcInBvbmdcIjp0aGlzLnNldFBpbmcoKTticmVhaztjYXNlXCJlcnJvclwiOnZhciBlcnI9bmV3IEVycm9yKFwic2VydmVyIGVycm9yXCIpO2Vyci5jb2RlPXBhY2tldC5kYXRhO3RoaXMuZW1pdChcImVycm9yXCIsZXJyKTticmVhaztjYXNlXCJtZXNzYWdlXCI6dGhpcy5lbWl0KFwiZGF0YVwiLHBhY2tldC5kYXRhKTt0aGlzLmVtaXQoXCJtZXNzYWdlXCIscGFja2V0LmRhdGEpO2JyZWFrfX1lbHNle2RlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLHRoaXMucmVhZHlTdGF0ZSl9fTtTb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlPWZ1bmN0aW9uKGRhdGEpe3RoaXMuZW1pdChcImhhbmRzaGFrZVwiLGRhdGEpO3RoaXMuaWQ9ZGF0YS5zaWQ7dGhpcy50cmFuc3BvcnQucXVlcnkuc2lkPWRhdGEuc2lkO3RoaXMudXBncmFkZXM9dGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTt0aGlzLnBpbmdJbnRlcnZhbD1kYXRhLnBpbmdJbnRlcnZhbDt0aGlzLnBpbmdUaW1lb3V0PWRhdGEucGluZ1RpbWVvdXQ7dGhpcy5vbk9wZW4oKTtpZihcImNsb3NlZFwiPT10aGlzLnJlYWR5U3RhdGUpcmV0dXJuO3RoaXMuc2V0UGluZygpO3RoaXMucmVtb3ZlTGlzdGVuZXIoXCJoZWFydGJlYXRcIix0aGlzLm9uSGVhcnRiZWF0KTt0aGlzLm9uKFwiaGVhcnRiZWF0XCIsdGhpcy5vbkhlYXJ0YmVhdCl9O1NvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQ9ZnVuY3Rpb24odGltZW91dCl7Y2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7dmFyIHNlbGY9dGhpcztzZWxmLnBpbmdUaW1lb3V0VGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2lmKFwiY2xvc2VkXCI9PXNlbGYucmVhZHlTdGF0ZSlyZXR1cm47c2VsZi5vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpfSx0aW1lb3V0fHxzZWxmLnBpbmdJbnRlcnZhbCtzZWxmLnBpbmdUaW1lb3V0KX07U29ja2V0LnByb3RvdHlwZS5zZXRQaW5nPWZ1bmN0aW9uKCl7dmFyIHNlbGY9dGhpcztjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7c2VsZi5waW5nSW50ZXJ2YWxUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZGVidWcoXCJ3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXNcIixzZWxmLnBpbmdUaW1lb3V0KTtzZWxmLnBpbmcoKTtzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpfSxzZWxmLnBpbmdJbnRlcnZhbCl9O1NvY2tldC5wcm90b3R5cGUucGluZz1mdW5jdGlvbigpe3RoaXMuc2VuZFBhY2tldChcInBpbmdcIil9O1NvY2tldC5wcm90b3R5cGUub25EcmFpbj1mdW5jdGlvbigpe2Zvcih2YXIgaT0wO2k8dGhpcy5wcmV2QnVmZmVyTGVuO2krKyl7aWYodGhpcy5jYWxsYmFja0J1ZmZlcltpXSl7dGhpcy5jYWxsYmFja0J1ZmZlcltpXSgpfX10aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLHRoaXMucHJldkJ1ZmZlckxlbik7dGhpcy5jYWxsYmFja0J1ZmZlci5zcGxpY2UoMCx0aGlzLnByZXZCdWZmZXJMZW4pO3RoaXMucHJldkJ1ZmZlckxlbj0wO2lmKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoPT0wKXt0aGlzLmVtaXQoXCJkcmFpblwiKX1lbHNle3RoaXMuZmx1c2goKX19O1NvY2tldC5wcm90b3R5cGUuZmx1c2g9ZnVuY3Rpb24oKXtpZihcImNsb3NlZFwiIT10aGlzLnJlYWR5U3RhdGUmJnRoaXMudHJhbnNwb3J0LndyaXRhYmxlJiYhdGhpcy51cGdyYWRpbmcmJnRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKXtkZWJ1ZyhcImZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0XCIsdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO3RoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7dGhpcy5wcmV2QnVmZmVyTGVuPXRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO3RoaXMuZW1pdChcImZsdXNoXCIpfX07U29ja2V0LnByb3RvdHlwZS53cml0ZT1Tb2NrZXQucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24obXNnLGZuKXt0aGlzLnNlbmRQYWNrZXQoXCJtZXNzYWdlXCIsbXNnLGZuKTtyZXR1cm4gdGhpc307U29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0PWZ1bmN0aW9uKHR5cGUsZGF0YSxmbil7aWYoXCJjbG9zaW5nXCI9PXRoaXMucmVhZHlTdGF0ZXx8XCJjbG9zZWRcIj09dGhpcy5yZWFkeVN0YXRlKXtyZXR1cm59dmFyIHBhY2tldD17dHlwZTp0eXBlLGRhdGE6ZGF0YX07dGhpcy5lbWl0KFwicGFja2V0Q3JlYXRlXCIscGFja2V0KTt0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTt0aGlzLmNhbGxiYWNrQnVmZmVyLnB1c2goZm4pO3RoaXMuZmx1c2goKX07U29ja2V0LnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe2lmKFwib3BlbmluZ1wiPT10aGlzLnJlYWR5U3RhdGV8fFwib3BlblwiPT10aGlzLnJlYWR5U3RhdGUpe3RoaXMucmVhZHlTdGF0ZT1cImNsb3NpbmdcIjt2YXIgc2VsZj10aGlzO2Z1bmN0aW9uIGNsb3NlKCl7c2VsZi5vbkNsb3NlKFwiZm9yY2VkIGNsb3NlXCIpO2RlYnVnKFwic29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZVwiKTtzZWxmLnRyYW5zcG9ydC5jbG9zZSgpfWZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpe3NlbGYucmVtb3ZlTGlzdGVuZXIoXCJ1cGdyYWRlXCIsY2xlYW51cEFuZENsb3NlKTtzZWxmLnJlbW92ZUxpc3RlbmVyKFwidXBncmFkZUVycm9yXCIsY2xlYW51cEFuZENsb3NlKTtjbG9zZSgpfWZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCl7c2VsZi5vbmNlKFwidXBncmFkZVwiLGNsZWFudXBBbmRDbG9zZSk7c2VsZi5vbmNlKFwidXBncmFkZUVycm9yXCIsY2xlYW51cEFuZENsb3NlKX1pZih0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCl7dGhpcy5vbmNlKFwiZHJhaW5cIixmdW5jdGlvbigpe2lmKHRoaXMudXBncmFkaW5nKXt3YWl0Rm9yVXBncmFkZSgpfWVsc2V7Y2xvc2UoKX19KX1lbHNlIGlmKHRoaXMudXBncmFkaW5nKXt3YWl0Rm9yVXBncmFkZSgpfWVsc2V7Y2xvc2UoKX19cmV0dXJuIHRoaXN9O1NvY2tldC5wcm90b3R5cGUub25FcnJvcj1mdW5jdGlvbihlcnIpe2RlYnVnKFwic29ja2V0IGVycm9yICVqXCIsZXJyKTtTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzPWZhbHNlO3RoaXMuZW1pdChcImVycm9yXCIsZXJyKTt0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIixlcnIpfTtTb2NrZXQucHJvdG90eXBlLm9uQ2xvc2U9ZnVuY3Rpb24ocmVhc29uLGRlc2Mpe2lmKFwib3BlbmluZ1wiPT10aGlzLnJlYWR5U3RhdGV8fFwib3BlblwiPT10aGlzLnJlYWR5U3RhdGV8fFwiY2xvc2luZ1wiPT10aGlzLnJlYWR5U3RhdGUpe2RlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicscmVhc29uKTt2YXIgc2VsZj10aGlzO2NsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2VsZi53cml0ZUJ1ZmZlcj1bXTtzZWxmLmNhbGxiYWNrQnVmZmVyPVtdO3NlbGYucHJldkJ1ZmZlckxlbj0wfSwwKTt0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJjbG9zZVwiKTt0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO3RoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO3RoaXMucmVhZHlTdGF0ZT1cImNsb3NlZFwiO3RoaXMuaWQ9bnVsbDt0aGlzLmVtaXQoXCJjbG9zZVwiLHJlYXNvbixkZXNjKX19O1NvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXM9ZnVuY3Rpb24odXBncmFkZXMpe3ZhciBmaWx0ZXJlZFVwZ3JhZGVzPVtdO2Zvcih2YXIgaT0wLGo9dXBncmFkZXMubGVuZ3RoO2k8ajtpKyspe2lmKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsdXBncmFkZXNbaV0pKWZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSl9cmV0dXJuIGZpbHRlcmVkVXBncmFkZXN9fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtcIi4vdHJhbnNwb3J0XCI6MTQsXCIuL3RyYW5zcG9ydHNcIjoxNSxcImNvbXBvbmVudC1lbWl0dGVyXCI6OSxkZWJ1ZzoyMixcImVuZ2luZS5pby1wYXJzZXJcIjoyNSxpbmRleG9mOjQyLHBhcnNlanNvbjozNCxwYXJzZXFzOjM1LHBhcnNldXJpOjM2fV0sMTQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBwYXJzZXI9X2RlcmVxXyhcImVuZ2luZS5pby1wYXJzZXJcIik7dmFyIEVtaXR0ZXI9X2RlcmVxXyhcImNvbXBvbmVudC1lbWl0dGVyXCIpO21vZHVsZS5leHBvcnRzPVRyYW5zcG9ydDtmdW5jdGlvbiBUcmFuc3BvcnQob3B0cyl7dGhpcy5wYXRoPW9wdHMucGF0aDt0aGlzLmhvc3RuYW1lPW9wdHMuaG9zdG5hbWU7dGhpcy5wb3J0PW9wdHMucG9ydDt0aGlzLnNlY3VyZT1vcHRzLnNlY3VyZTt0aGlzLnF1ZXJ5PW9wdHMucXVlcnk7dGhpcy50aW1lc3RhbXBQYXJhbT1vcHRzLnRpbWVzdGFtcFBhcmFtO3RoaXMudGltZXN0YW1wUmVxdWVzdHM9b3B0cy50aW1lc3RhbXBSZXF1ZXN0czt0aGlzLnJlYWR5U3RhdGU9XCJcIjt0aGlzLmFnZW50PW9wdHMuYWdlbnR8fGZhbHNlO3RoaXMuc29ja2V0PW9wdHMuc29ja2V0O3RoaXMuZW5hYmxlc1hEUj1vcHRzLmVuYWJsZXNYRFI7dGhpcy5wZng9b3B0cy5wZng7dGhpcy5rZXk9b3B0cy5rZXk7dGhpcy5wYXNzcGhyYXNlPW9wdHMucGFzc3BocmFzZTt0aGlzLmNlcnQ9b3B0cy5jZXJ0O3RoaXMuY2E9b3B0cy5jYTt0aGlzLmNpcGhlcnM9b3B0cy5jaXBoZXJzO3RoaXMucmVqZWN0VW5hdXRob3JpemVkPW9wdHMucmVqZWN0VW5hdXRob3JpemVkfUVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7VHJhbnNwb3J0LnRpbWVzdGFtcHM9MDtUcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3I9ZnVuY3Rpb24obXNnLGRlc2Mpe3ZhciBlcnI9bmV3IEVycm9yKG1zZyk7ZXJyLnR5cGU9XCJUcmFuc3BvcnRFcnJvclwiO2Vyci5kZXNjcmlwdGlvbj1kZXNjO3RoaXMuZW1pdChcImVycm9yXCIsZXJyKTtyZXR1cm4gdGhpc307VHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKCl7aWYoXCJjbG9zZWRcIj09dGhpcy5yZWFkeVN0YXRlfHxcIlwiPT10aGlzLnJlYWR5U3RhdGUpe3RoaXMucmVhZHlTdGF0ZT1cIm9wZW5pbmdcIjt0aGlzLmRvT3BlbigpfXJldHVybiB0aGlzfTtUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7aWYoXCJvcGVuaW5nXCI9PXRoaXMucmVhZHlTdGF0ZXx8XCJvcGVuXCI9PXRoaXMucmVhZHlTdGF0ZSl7dGhpcy5kb0Nsb3NlKCk7dGhpcy5vbkNsb3NlKCl9cmV0dXJuIHRoaXN9O1RyYW5zcG9ydC5wcm90b3R5cGUuc2VuZD1mdW5jdGlvbihwYWNrZXRzKXtpZihcIm9wZW5cIj09dGhpcy5yZWFkeVN0YXRlKXt0aGlzLndyaXRlKHBhY2tldHMpfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwb3J0IG5vdCBvcGVuXCIpfX07VHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW49ZnVuY3Rpb24oKXt0aGlzLnJlYWR5U3RhdGU9XCJvcGVuXCI7dGhpcy53cml0YWJsZT10cnVlO3RoaXMuZW1pdChcIm9wZW5cIil9O1RyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhPWZ1bmN0aW9uKGRhdGEpe3ZhciBwYWNrZXQ9cGFyc2VyLmRlY29kZVBhY2tldChkYXRhLHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO3RoaXMub25QYWNrZXQocGFja2V0KX07VHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldD1mdW5jdGlvbihwYWNrZXQpe3RoaXMuZW1pdChcInBhY2tldFwiLHBhY2tldCl9O1RyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZT1mdW5jdGlvbigpe3RoaXMucmVhZHlTdGF0ZT1cImNsb3NlZFwiO3RoaXMuZW1pdChcImNsb3NlXCIpfX0se1wiY29tcG9uZW50LWVtaXR0ZXJcIjo5LFwiZW5naW5lLmlvLXBhcnNlclwiOjI1fV0sMTU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBYTUxIdHRwUmVxdWVzdD1fZGVyZXFfKFwieG1saHR0cHJlcXVlc3RcIik7dmFyIFhIUj1fZGVyZXFfKFwiLi9wb2xsaW5nLXhoclwiKTt2YXIgSlNPTlA9X2RlcmVxXyhcIi4vcG9sbGluZy1qc29ucFwiKTt2YXIgd2Vic29ja2V0PV9kZXJlcV8oXCIuL3dlYnNvY2tldFwiKTtleHBvcnRzLnBvbGxpbmc9cG9sbGluZztleHBvcnRzLndlYnNvY2tldD13ZWJzb2NrZXQ7ZnVuY3Rpb24gcG9sbGluZyhvcHRzKXt2YXIgeGhyO3ZhciB4ZD1mYWxzZTt2YXIgeHM9ZmFsc2U7dmFyIGpzb25wPWZhbHNlIT09b3B0cy5qc29ucDtpZihnbG9iYWwubG9jYXRpb24pe3ZhciBpc1NTTD1cImh0dHBzOlwiPT1sb2NhdGlvbi5wcm90b2NvbDt2YXIgcG9ydD1sb2NhdGlvbi5wb3J0O2lmKCFwb3J0KXtwb3J0PWlzU1NMPzQ0Mzo4MH14ZD1vcHRzLmhvc3RuYW1lIT1sb2NhdGlvbi5ob3N0bmFtZXx8cG9ydCE9b3B0cy5wb3J0O3hzPW9wdHMuc2VjdXJlIT1pc1NTTH1vcHRzLnhkb21haW49eGQ7b3B0cy54c2NoZW1lPXhzO3hocj1uZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7aWYoXCJvcGVuXCJpbiB4aHImJiFvcHRzLmZvcmNlSlNPTlApe3JldHVybiBuZXcgWEhSKG9wdHMpfWVsc2V7aWYoIWpzb25wKXRocm93IG5ldyBFcnJvcihcIkpTT05QIGRpc2FibGVkXCIpO3JldHVybiBuZXcgSlNPTlAob3B0cyl9fX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7XCIuL3BvbGxpbmctanNvbnBcIjoxNixcIi4vcG9sbGluZy14aHJcIjoxNyxcIi4vd2Vic29ja2V0XCI6MTkseG1saHR0cHJlcXVlc3Q6MjB9XSwxNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIFBvbGxpbmc9X2RlcmVxXyhcIi4vcG9sbGluZ1wiKTt2YXIgaW5oZXJpdD1fZGVyZXFfKFwiY29tcG9uZW50LWluaGVyaXRcIik7bW9kdWxlLmV4cG9ydHM9SlNPTlBQb2xsaW5nO3ZhciByTmV3bGluZT0vXFxuL2c7dmFyIHJFc2NhcGVkTmV3bGluZT0vXFxcXG4vZzt2YXIgY2FsbGJhY2tzO3ZhciBpbmRleD0wO2Z1bmN0aW9uIGVtcHR5KCl7fWZ1bmN0aW9uIEpTT05QUG9sbGluZyhvcHRzKXtQb2xsaW5nLmNhbGwodGhpcyxvcHRzKTtcbnRoaXMucXVlcnk9dGhpcy5xdWVyeXx8e307aWYoIWNhbGxiYWNrcyl7aWYoIWdsb2JhbC5fX19laW8pZ2xvYmFsLl9fX2Vpbz1bXTtjYWxsYmFja3M9Z2xvYmFsLl9fX2Vpb310aGlzLmluZGV4PWNhbGxiYWNrcy5sZW5ndGg7dmFyIHNlbGY9dGhpcztjYWxsYmFja3MucHVzaChmdW5jdGlvbihtc2cpe3NlbGYub25EYXRhKG1zZyl9KTt0aGlzLnF1ZXJ5Lmo9dGhpcy5pbmRleDtpZihnbG9iYWwuZG9jdW1lbnQmJmdsb2JhbC5hZGRFdmVudExpc3RlbmVyKXtnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLGZ1bmN0aW9uKCl7aWYoc2VsZi5zY3JpcHQpc2VsZi5zY3JpcHQub25lcnJvcj1lbXB0eX0sZmFsc2UpfX1pbmhlcml0KEpTT05QUG9sbGluZyxQb2xsaW5nKTtKU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5PWZhbHNlO0pTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZT1mdW5jdGlvbigpe2lmKHRoaXMuc2NyaXB0KXt0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTt0aGlzLnNjcmlwdD1udWxsfWlmKHRoaXMuZm9ybSl7dGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTt0aGlzLmZvcm09bnVsbDt0aGlzLmlmcmFtZT1udWxsfVBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKX07SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGw9ZnVuY3Rpb24oKXt2YXIgc2VsZj10aGlzO3ZhciBzY3JpcHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtpZih0aGlzLnNjcmlwdCl7dGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7dGhpcy5zY3JpcHQ9bnVsbH1zY3JpcHQuYXN5bmM9dHJ1ZTtzY3JpcHQuc3JjPXRoaXMudXJpKCk7c2NyaXB0Lm9uZXJyb3I9ZnVuY3Rpb24oZSl7c2VsZi5vbkVycm9yKFwianNvbnAgcG9sbCBlcnJvclwiLGUpfTt2YXIgaW5zZXJ0QXQ9ZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIilbMF07aW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LGluc2VydEF0KTt0aGlzLnNjcmlwdD1zY3JpcHQ7dmFyIGlzVUFnZWNrbz1cInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiYvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO2lmKGlzVUFnZWNrbyl7c2V0VGltZW91dChmdW5jdGlvbigpe3ZhciBpZnJhbWU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7ZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpfSwxMDApfX07SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlPWZ1bmN0aW9uKGRhdGEsZm4pe3ZhciBzZWxmPXRoaXM7aWYoIXRoaXMuZm9ybSl7dmFyIGZvcm09ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZvcm1cIik7dmFyIGFyZWE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO3ZhciBpZD10aGlzLmlmcmFtZUlkPVwiZWlvX2lmcmFtZV9cIit0aGlzLmluZGV4O3ZhciBpZnJhbWU7Zm9ybS5jbGFzc05hbWU9XCJzb2NrZXRpb1wiO2Zvcm0uc3R5bGUucG9zaXRpb249XCJhYnNvbHV0ZVwiO2Zvcm0uc3R5bGUudG9wPVwiLTEwMDBweFwiO2Zvcm0uc3R5bGUubGVmdD1cIi0xMDAwcHhcIjtmb3JtLnRhcmdldD1pZDtmb3JtLm1ldGhvZD1cIlBPU1RcIjtmb3JtLnNldEF0dHJpYnV0ZShcImFjY2VwdC1jaGFyc2V0XCIsXCJ1dGYtOFwiKTthcmVhLm5hbWU9XCJkXCI7Zm9ybS5hcHBlbmRDaGlsZChhcmVhKTtkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO3RoaXMuZm9ybT1mb3JtO3RoaXMuYXJlYT1hcmVhfXRoaXMuZm9ybS5hY3Rpb249dGhpcy51cmkoKTtmdW5jdGlvbiBjb21wbGV0ZSgpe2luaXRJZnJhbWUoKTtmbigpfWZ1bmN0aW9uIGluaXRJZnJhbWUoKXtpZihzZWxmLmlmcmFtZSl7dHJ5e3NlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSl9Y2F0Y2goZSl7c2VsZi5vbkVycm9yKFwianNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvclwiLGUpfX10cnl7dmFyIGh0bWw9JzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrc2VsZi5pZnJhbWVJZCsnXCI+JztpZnJhbWU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKX1jYXRjaChlKXtpZnJhbWU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtpZnJhbWUubmFtZT1zZWxmLmlmcmFtZUlkO2lmcmFtZS5zcmM9XCJqYXZhc2NyaXB0OjBcIn1pZnJhbWUuaWQ9c2VsZi5pZnJhbWVJZDtzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtzZWxmLmlmcmFtZT1pZnJhbWV9aW5pdElmcmFtZSgpO2RhdGE9ZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSxcIlxcXFxcXG5cIik7dGhpcy5hcmVhLnZhbHVlPWRhdGEucmVwbGFjZShyTmV3bGluZSxcIlxcXFxuXCIpO3RyeXt0aGlzLmZvcm0uc3VibWl0KCl9Y2F0Y2goZSl7fWlmKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KXt0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZihzZWxmLmlmcmFtZS5yZWFkeVN0YXRlPT1cImNvbXBsZXRlXCIpe2NvbXBsZXRlKCl9fX1lbHNle3RoaXMuaWZyYW1lLm9ubG9hZD1jb21wbGV0ZX19fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtcIi4vcG9sbGluZ1wiOjE4LFwiY29tcG9uZW50LWluaGVyaXRcIjoyMX1dLDE3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgWE1MSHR0cFJlcXVlc3Q9X2RlcmVxXyhcInhtbGh0dHByZXF1ZXN0XCIpO3ZhciBQb2xsaW5nPV9kZXJlcV8oXCIuL3BvbGxpbmdcIik7dmFyIEVtaXR0ZXI9X2RlcmVxXyhcImNvbXBvbmVudC1lbWl0dGVyXCIpO3ZhciBpbmhlcml0PV9kZXJlcV8oXCJjb21wb25lbnQtaW5oZXJpdFwiKTt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwiZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhoclwiKTttb2R1bGUuZXhwb3J0cz1YSFI7bW9kdWxlLmV4cG9ydHMuUmVxdWVzdD1SZXF1ZXN0O2Z1bmN0aW9uIGVtcHR5KCl7fWZ1bmN0aW9uIFhIUihvcHRzKXtQb2xsaW5nLmNhbGwodGhpcyxvcHRzKTtpZihnbG9iYWwubG9jYXRpb24pe3ZhciBpc1NTTD1cImh0dHBzOlwiPT1sb2NhdGlvbi5wcm90b2NvbDt2YXIgcG9ydD1sb2NhdGlvbi5wb3J0O2lmKCFwb3J0KXtwb3J0PWlzU1NMPzQ0Mzo4MH10aGlzLnhkPW9wdHMuaG9zdG5hbWUhPWdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZXx8cG9ydCE9b3B0cy5wb3J0O3RoaXMueHM9b3B0cy5zZWN1cmUhPWlzU1NMfX1pbmhlcml0KFhIUixQb2xsaW5nKTtYSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5PXRydWU7WEhSLnByb3RvdHlwZS5yZXF1ZXN0PWZ1bmN0aW9uKG9wdHMpe29wdHM9b3B0c3x8e307b3B0cy51cmk9dGhpcy51cmkoKTtvcHRzLnhkPXRoaXMueGQ7b3B0cy54cz10aGlzLnhzO29wdHMuYWdlbnQ9dGhpcy5hZ2VudHx8ZmFsc2U7b3B0cy5zdXBwb3J0c0JpbmFyeT10aGlzLnN1cHBvcnRzQmluYXJ5O29wdHMuZW5hYmxlc1hEUj10aGlzLmVuYWJsZXNYRFI7b3B0cy5wZng9dGhpcy5wZng7b3B0cy5rZXk9dGhpcy5rZXk7b3B0cy5wYXNzcGhyYXNlPXRoaXMucGFzc3BocmFzZTtvcHRzLmNlcnQ9dGhpcy5jZXJ0O29wdHMuY2E9dGhpcy5jYTtvcHRzLmNpcGhlcnM9dGhpcy5jaXBoZXJzO29wdHMucmVqZWN0VW5hdXRob3JpemVkPXRoaXMucmVqZWN0VW5hdXRob3JpemVkO3JldHVybiBuZXcgUmVxdWVzdChvcHRzKX07WEhSLnByb3RvdHlwZS5kb1dyaXRlPWZ1bmN0aW9uKGRhdGEsZm4pe3ZhciBpc0JpbmFyeT10eXBlb2YgZGF0YSE9PVwic3RyaW5nXCImJmRhdGEhPT11bmRlZmluZWQ7dmFyIHJlcT10aGlzLnJlcXVlc3Qoe21ldGhvZDpcIlBPU1RcIixkYXRhOmRhdGEsaXNCaW5hcnk6aXNCaW5hcnl9KTt2YXIgc2VsZj10aGlzO3JlcS5vbihcInN1Y2Nlc3NcIixmbik7cmVxLm9uKFwiZXJyb3JcIixmdW5jdGlvbihlcnIpe3NlbGYub25FcnJvcihcInhociBwb3N0IGVycm9yXCIsZXJyKX0pO3RoaXMuc2VuZFhocj1yZXF9O1hIUi5wcm90b3R5cGUuZG9Qb2xsPWZ1bmN0aW9uKCl7ZGVidWcoXCJ4aHIgcG9sbFwiKTt2YXIgcmVxPXRoaXMucmVxdWVzdCgpO3ZhciBzZWxmPXRoaXM7cmVxLm9uKFwiZGF0YVwiLGZ1bmN0aW9uKGRhdGEpe3NlbGYub25EYXRhKGRhdGEpfSk7cmVxLm9uKFwiZXJyb3JcIixmdW5jdGlvbihlcnIpe3NlbGYub25FcnJvcihcInhociBwb2xsIGVycm9yXCIsZXJyKX0pO3RoaXMucG9sbFhocj1yZXF9O2Z1bmN0aW9uIFJlcXVlc3Qob3B0cyl7dGhpcy5tZXRob2Q9b3B0cy5tZXRob2R8fFwiR0VUXCI7dGhpcy51cmk9b3B0cy51cmk7dGhpcy54ZD0hIW9wdHMueGQ7dGhpcy54cz0hIW9wdHMueHM7dGhpcy5hc3luYz1mYWxzZSE9PW9wdHMuYXN5bmM7dGhpcy5kYXRhPXVuZGVmaW5lZCE9b3B0cy5kYXRhP29wdHMuZGF0YTpudWxsO3RoaXMuYWdlbnQ9b3B0cy5hZ2VudDt0aGlzLmlzQmluYXJ5PW9wdHMuaXNCaW5hcnk7dGhpcy5zdXBwb3J0c0JpbmFyeT1vcHRzLnN1cHBvcnRzQmluYXJ5O3RoaXMuZW5hYmxlc1hEUj1vcHRzLmVuYWJsZXNYRFI7dGhpcy5wZng9b3B0cy5wZng7dGhpcy5rZXk9b3B0cy5rZXk7dGhpcy5wYXNzcGhyYXNlPW9wdHMucGFzc3BocmFzZTt0aGlzLmNlcnQ9b3B0cy5jZXJ0O3RoaXMuY2E9b3B0cy5jYTt0aGlzLmNpcGhlcnM9b3B0cy5jaXBoZXJzO3RoaXMucmVqZWN0VW5hdXRob3JpemVkPW9wdHMucmVqZWN0VW5hdXRob3JpemVkO3RoaXMuY3JlYXRlKCl9RW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7UmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlPWZ1bmN0aW9uKCl7dmFyIG9wdHM9e2FnZW50OnRoaXMuYWdlbnQseGRvbWFpbjp0aGlzLnhkLHhzY2hlbWU6dGhpcy54cyxlbmFibGVzWERSOnRoaXMuZW5hYmxlc1hEUn07b3B0cy5wZng9dGhpcy5wZng7b3B0cy5rZXk9dGhpcy5rZXk7b3B0cy5wYXNzcGhyYXNlPXRoaXMucGFzc3BocmFzZTtvcHRzLmNlcnQ9dGhpcy5jZXJ0O29wdHMuY2E9dGhpcy5jYTtvcHRzLmNpcGhlcnM9dGhpcy5jaXBoZXJzO29wdHMucmVqZWN0VW5hdXRob3JpemVkPXRoaXMucmVqZWN0VW5hdXRob3JpemVkO3ZhciB4aHI9dGhpcy54aHI9bmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO3ZhciBzZWxmPXRoaXM7dHJ5e2RlYnVnKFwieGhyIG9wZW4gJXM6ICVzXCIsdGhpcy5tZXRob2QsdGhpcy51cmkpO3hoci5vcGVuKHRoaXMubWV0aG9kLHRoaXMudXJpLHRoaXMuYXN5bmMpO2lmKHRoaXMuc3VwcG9ydHNCaW5hcnkpe3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwifWlmKFwiUE9TVFwiPT10aGlzLm1ldGhvZCl7dHJ5e2lmKHRoaXMuaXNCaW5hcnkpe3hoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIil9ZWxzZXt4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLFwidGV4dC9wbGFpbjtjaGFyc2V0PVVURi04XCIpfX1jYXRjaChlKXt9fWlmKFwid2l0aENyZWRlbnRpYWxzXCJpbiB4aHIpe3hoci53aXRoQ3JlZGVudGlhbHM9dHJ1ZX1pZih0aGlzLmhhc1hEUigpKXt4aHIub25sb2FkPWZ1bmN0aW9uKCl7c2VsZi5vbkxvYWQoKX07eGhyLm9uZXJyb3I9ZnVuY3Rpb24oKXtzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCl9fWVsc2V7eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKDQhPXhoci5yZWFkeVN0YXRlKXJldHVybjtpZigyMDA9PXhoci5zdGF0dXN8fDEyMjM9PXhoci5zdGF0dXMpe3NlbGYub25Mb2FkKCl9ZWxzZXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2VsZi5vbkVycm9yKHhoci5zdGF0dXMpfSwwKX19fWRlYnVnKFwieGhyIGRhdGEgJXNcIix0aGlzLmRhdGEpO3hoci5zZW5kKHRoaXMuZGF0YSl9Y2F0Y2goZSl7c2V0VGltZW91dChmdW5jdGlvbigpe3NlbGYub25FcnJvcihlKX0sMCk7cmV0dXJufWlmKGdsb2JhbC5kb2N1bWVudCl7dGhpcy5pbmRleD1SZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdPXRoaXN9fTtSZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3M9ZnVuY3Rpb24oKXt0aGlzLmVtaXQoXCJzdWNjZXNzXCIpO3RoaXMuY2xlYW51cCgpfTtSZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24oZGF0YSl7dGhpcy5lbWl0KFwiZGF0YVwiLGRhdGEpO3RoaXMub25TdWNjZXNzKCl9O1JlcXVlc3QucHJvdG90eXBlLm9uRXJyb3I9ZnVuY3Rpb24oZXJyKXt0aGlzLmVtaXQoXCJlcnJvclwiLGVycik7dGhpcy5jbGVhbnVwKHRydWUpfTtSZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwPWZ1bmN0aW9uKGZyb21FcnJvcil7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHRoaXMueGhyfHxudWxsPT09dGhpcy54aHIpe3JldHVybn1pZih0aGlzLmhhc1hEUigpKXt0aGlzLnhoci5vbmxvYWQ9dGhpcy54aHIub25lcnJvcj1lbXB0eX1lbHNle3RoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZT1lbXB0eX1pZihmcm9tRXJyb3Ipe3RyeXt0aGlzLnhoci5hYm9ydCgpfWNhdGNoKGUpe319aWYoZ2xvYmFsLmRvY3VtZW50KXtkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XX10aGlzLnhocj1udWxsfTtSZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQ9ZnVuY3Rpb24oKXt2YXIgZGF0YTt0cnl7dmFyIGNvbnRlbnRUeXBlO3RyeXtjb250ZW50VHlwZT10aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKS5zcGxpdChcIjtcIilbMF19Y2F0Y2goZSl7fWlmKGNvbnRlbnRUeXBlPT09XCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIil7ZGF0YT10aGlzLnhoci5yZXNwb25zZX1lbHNle2lmKCF0aGlzLnN1cHBvcnRzQmluYXJ5KXtkYXRhPXRoaXMueGhyLnJlc3BvbnNlVGV4dH1lbHNle2RhdGE9XCJva1wifX19Y2F0Y2goZSl7dGhpcy5vbkVycm9yKGUpfWlmKG51bGwhPWRhdGEpe3RoaXMub25EYXRhKGRhdGEpfX07UmVxdWVzdC5wcm90b3R5cGUuaGFzWERSPWZ1bmN0aW9uKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QmJiF0aGlzLnhzJiZ0aGlzLmVuYWJsZXNYRFJ9O1JlcXVlc3QucHJvdG90eXBlLmFib3J0PWZ1bmN0aW9uKCl7dGhpcy5jbGVhbnVwKCl9O2lmKGdsb2JhbC5kb2N1bWVudCl7UmVxdWVzdC5yZXF1ZXN0c0NvdW50PTA7UmVxdWVzdC5yZXF1ZXN0cz17fTtpZihnbG9iYWwuYXR0YWNoRXZlbnQpe2dsb2JhbC5hdHRhY2hFdmVudChcIm9udW5sb2FkXCIsdW5sb2FkSGFuZGxlcil9ZWxzZSBpZihnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcil7Z2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIix1bmxvYWRIYW5kbGVyLGZhbHNlKX19ZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpe2Zvcih2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKXtpZihSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKXtSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCl9fX19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se1wiLi9wb2xsaW5nXCI6MTgsXCJjb21wb25lbnQtZW1pdHRlclwiOjksXCJjb21wb25lbnQtaW5oZXJpdFwiOjIxLGRlYnVnOjIyLHhtbGh0dHByZXF1ZXN0OjIwfV0sMTg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBUcmFuc3BvcnQ9X2RlcmVxXyhcIi4uL3RyYW5zcG9ydFwiKTt2YXIgcGFyc2Vxcz1fZGVyZXFfKFwicGFyc2Vxc1wiKTt2YXIgcGFyc2VyPV9kZXJlcV8oXCJlbmdpbmUuaW8tcGFyc2VyXCIpO3ZhciBpbmhlcml0PV9kZXJlcV8oXCJjb21wb25lbnQtaW5oZXJpdFwiKTt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwiZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nXCIpO21vZHVsZS5leHBvcnRzPVBvbGxpbmc7dmFyIGhhc1hIUjI9ZnVuY3Rpb24oKXt2YXIgWE1MSHR0cFJlcXVlc3Q9X2RlcmVxXyhcInhtbGh0dHByZXF1ZXN0XCIpO3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0KHt4ZG9tYWluOmZhbHNlfSk7cmV0dXJuIG51bGwhPXhoci5yZXNwb25zZVR5cGV9KCk7ZnVuY3Rpb24gUG9sbGluZyhvcHRzKXt2YXIgZm9yY2VCYXNlNjQ9b3B0cyYmb3B0cy5mb3JjZUJhc2U2NDtpZighaGFzWEhSMnx8Zm9yY2VCYXNlNjQpe3RoaXMuc3VwcG9ydHNCaW5hcnk9ZmFsc2V9VHJhbnNwb3J0LmNhbGwodGhpcyxvcHRzKX1pbmhlcml0KFBvbGxpbmcsVHJhbnNwb3J0KTtQb2xsaW5nLnByb3RvdHlwZS5uYW1lPVwicG9sbGluZ1wiO1BvbGxpbmcucHJvdG90eXBlLmRvT3Blbj1mdW5jdGlvbigpe3RoaXMucG9sbCgpfTtQb2xsaW5nLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbihvblBhdXNlKXt2YXIgcGVuZGluZz0wO3ZhciBzZWxmPXRoaXM7dGhpcy5yZWFkeVN0YXRlPVwicGF1c2luZ1wiO2Z1bmN0aW9uIHBhdXNlKCl7ZGVidWcoXCJwYXVzZWRcIik7c2VsZi5yZWFkeVN0YXRlPVwicGF1c2VkXCI7b25QYXVzZSgpfWlmKHRoaXMucG9sbGluZ3x8IXRoaXMud3JpdGFibGUpe3ZhciB0b3RhbD0wO2lmKHRoaXMucG9sbGluZyl7ZGVidWcoXCJ3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlXCIpO3RvdGFsKys7dGhpcy5vbmNlKFwicG9sbENvbXBsZXRlXCIsZnVuY3Rpb24oKXtkZWJ1ZyhcInByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlXCIpOy0tdG90YWx8fHBhdXNlKCl9KX1pZighdGhpcy53cml0YWJsZSl7ZGVidWcoXCJ3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlXCIpO3RvdGFsKys7dGhpcy5vbmNlKFwiZHJhaW5cIixmdW5jdGlvbigpe2RlYnVnKFwicHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGVcIik7LS10b3RhbHx8cGF1c2UoKX0pfX1lbHNle3BhdXNlKCl9fTtQb2xsaW5nLnByb3RvdHlwZS5wb2xsPWZ1bmN0aW9uKCl7ZGVidWcoXCJwb2xsaW5nXCIpO3RoaXMucG9sbGluZz10cnVlO3RoaXMuZG9Qb2xsKCk7dGhpcy5lbWl0KFwicG9sbFwiKX07UG9sbGluZy5wcm90b3R5cGUub25EYXRhPWZ1bmN0aW9uKGRhdGEpe3ZhciBzZWxmPXRoaXM7ZGVidWcoXCJwb2xsaW5nIGdvdCBkYXRhICVzXCIsZGF0YSk7dmFyIGNhbGxiYWNrPWZ1bmN0aW9uKHBhY2tldCxpbmRleCx0b3RhbCl7aWYoXCJvcGVuaW5nXCI9PXNlbGYucmVhZHlTdGF0ZSl7c2VsZi5vbk9wZW4oKX1pZihcImNsb3NlXCI9PXBhY2tldC50eXBlKXtzZWxmLm9uQ2xvc2UoKTtyZXR1cm4gZmFsc2V9c2VsZi5vblBhY2tldChwYWNrZXQpfTtwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsY2FsbGJhY2spO2lmKFwiY2xvc2VkXCIhPXRoaXMucmVhZHlTdGF0ZSl7dGhpcy5wb2xsaW5nPWZhbHNlO3RoaXMuZW1pdChcInBvbGxDb21wbGV0ZVwiKTtpZihcIm9wZW5cIj09dGhpcy5yZWFkeVN0YXRlKXt0aGlzLnBvbGwoKX1lbHNle2RlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsdGhpcy5yZWFkeVN0YXRlKX19fTtQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlPWZ1bmN0aW9uKCl7dmFyIHNlbGY9dGhpcztmdW5jdGlvbiBjbG9zZSgpe2RlYnVnKFwid3JpdGluZyBjbG9zZSBwYWNrZXRcIik7c2VsZi53cml0ZShbe3R5cGU6XCJjbG9zZVwifV0pfWlmKFwib3BlblwiPT10aGlzLnJlYWR5U3RhdGUpe2RlYnVnKFwidHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nXCIpO2Nsb3NlKCl9ZWxzZXtkZWJ1ZyhcInRyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZVwiKTt0aGlzLm9uY2UoXCJvcGVuXCIsY2xvc2UpfX07UG9sbGluZy5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24ocGFja2V0cyl7dmFyIHNlbGY9dGhpczt0aGlzLndyaXRhYmxlPWZhbHNlO3ZhciBjYWxsYmFja2ZuPWZ1bmN0aW9uKCl7c2VsZi53cml0YWJsZT10cnVlO3NlbGYuZW1pdChcImRyYWluXCIpfTt2YXIgc2VsZj10aGlzO3BhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsdGhpcy5zdXBwb3J0c0JpbmFyeSxmdW5jdGlvbihkYXRhKXtzZWxmLmRvV3JpdGUoZGF0YSxjYWxsYmFja2ZuKX0pfTtQb2xsaW5nLnByb3RvdHlwZS51cmk9ZnVuY3Rpb24oKXt2YXIgcXVlcnk9dGhpcy5xdWVyeXx8e307dmFyIHNjaGVtYT10aGlzLnNlY3VyZT9cImh0dHBzXCI6XCJodHRwXCI7dmFyIHBvcnQ9XCJcIjtpZihmYWxzZSE9PXRoaXMudGltZXN0YW1wUmVxdWVzdHMpe3F1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dPStuZXcgRGF0ZStcIi1cIitUcmFuc3BvcnQudGltZXN0YW1wcysrfWlmKCF0aGlzLnN1cHBvcnRzQmluYXJ5JiYhcXVlcnkuc2lkKXtxdWVyeS5iNjQ9MX1xdWVyeT1wYXJzZXFzLmVuY29kZShxdWVyeSk7aWYodGhpcy5wb3J0JiYoXCJodHRwc1wiPT1zY2hlbWEmJnRoaXMucG9ydCE9NDQzfHxcImh0dHBcIj09c2NoZW1hJiZ0aGlzLnBvcnQhPTgwKSl7cG9ydD1cIjpcIit0aGlzLnBvcnR9aWYocXVlcnkubGVuZ3RoKXtxdWVyeT1cIj9cIitxdWVyeX1yZXR1cm4gc2NoZW1hK1wiOi8vXCIrdGhpcy5ob3N0bmFtZStwb3J0K3RoaXMucGF0aCtxdWVyeX19LHtcIi4uL3RyYW5zcG9ydFwiOjE0LFwiY29tcG9uZW50LWluaGVyaXRcIjoyMSxkZWJ1ZzoyMixcImVuZ2luZS5pby1wYXJzZXJcIjoyNSxwYXJzZXFzOjM1LHhtbGh0dHByZXF1ZXN0OjIwfV0sMTk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBUcmFuc3BvcnQ9X2RlcmVxXyhcIi4uL3RyYW5zcG9ydFwiKTt2YXIgcGFyc2VyPV9kZXJlcV8oXCJlbmdpbmUuaW8tcGFyc2VyXCIpO3ZhciBwYXJzZXFzPV9kZXJlcV8oXCJwYXJzZXFzXCIpO3ZhciBpbmhlcml0PV9kZXJlcV8oXCJjb21wb25lbnQtaW5oZXJpdFwiKTt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwiZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXRcIik7dmFyIFdlYlNvY2tldD1fZGVyZXFfKFwid3NcIik7bW9kdWxlLmV4cG9ydHM9V1M7ZnVuY3Rpb24gV1Mob3B0cyl7dmFyIGZvcmNlQmFzZTY0PW9wdHMmJm9wdHMuZm9yY2VCYXNlNjQ7aWYoZm9yY2VCYXNlNjQpe3RoaXMuc3VwcG9ydHNCaW5hcnk9ZmFsc2V9VHJhbnNwb3J0LmNhbGwodGhpcyxvcHRzKX1pbmhlcml0KFdTLFRyYW5zcG9ydCk7V1MucHJvdG90eXBlLm5hbWU9XCJ3ZWJzb2NrZXRcIjtXUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnk9dHJ1ZTtXUy5wcm90b3R5cGUuZG9PcGVuPWZ1bmN0aW9uKCl7aWYoIXRoaXMuY2hlY2soKSl7cmV0dXJufXZhciBzZWxmPXRoaXM7dmFyIHVyaT10aGlzLnVyaSgpO3ZhciBwcm90b2NvbHM9dm9pZCAwO3ZhciBvcHRzPXthZ2VudDp0aGlzLmFnZW50fTtvcHRzLnBmeD10aGlzLnBmeDtvcHRzLmtleT10aGlzLmtleTtvcHRzLnBhc3NwaHJhc2U9dGhpcy5wYXNzcGhyYXNlO29wdHMuY2VydD10aGlzLmNlcnQ7b3B0cy5jYT10aGlzLmNhO29wdHMuY2lwaGVycz10aGlzLmNpcGhlcnM7b3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ9dGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7dGhpcy53cz1uZXcgV2ViU29ja2V0KHVyaSxwcm90b2NvbHMsb3B0cyk7aWYodGhpcy53cy5iaW5hcnlUeXBlPT09dW5kZWZpbmVkKXt0aGlzLnN1cHBvcnRzQmluYXJ5PWZhbHNlfXRoaXMud3MuYmluYXJ5VHlwZT1cImFycmF5YnVmZmVyXCI7dGhpcy5hZGRFdmVudExpc3RlbmVycygpfTtXUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnM9ZnVuY3Rpb24oKXt2YXIgc2VsZj10aGlzO3RoaXMud3Mub25vcGVuPWZ1bmN0aW9uKCl7c2VsZi5vbk9wZW4oKX07dGhpcy53cy5vbmNsb3NlPWZ1bmN0aW9uKCl7c2VsZi5vbkNsb3NlKCl9O3RoaXMud3Mub25tZXNzYWdlPWZ1bmN0aW9uKGV2KXtzZWxmLm9uRGF0YShldi5kYXRhKX07dGhpcy53cy5vbmVycm9yPWZ1bmN0aW9uKGUpe3NlbGYub25FcnJvcihcIndlYnNvY2tldCBlcnJvclwiLGUpfX07aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKXtXUy5wcm90b3R5cGUub25EYXRhPWZ1bmN0aW9uKGRhdGEpe3ZhciBzZWxmPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe1RyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhLmNhbGwoc2VsZixkYXRhKX0sMCl9fVdTLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihwYWNrZXRzKXt2YXIgc2VsZj10aGlzO3RoaXMud3JpdGFibGU9ZmFsc2U7Zm9yKHZhciBpPTAsbD1wYWNrZXRzLmxlbmd0aDtpPGw7aSsrKXtwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldHNbaV0sdGhpcy5zdXBwb3J0c0JpbmFyeSxmdW5jdGlvbihkYXRhKXt0cnl7c2VsZi53cy5zZW5kKGRhdGEpfWNhdGNoKGUpe2RlYnVnKFwid2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudFwiKX19KX1mdW5jdGlvbiBvbmRyYWluKCl7c2VsZi53cml0YWJsZT10cnVlO3NlbGYuZW1pdChcImRyYWluXCIpfXNldFRpbWVvdXQob25kcmFpbiwwKX07V1MucHJvdG90eXBlLm9uQ2xvc2U9ZnVuY3Rpb24oKXtUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKX07V1MucHJvdG90eXBlLmRvQ2xvc2U9ZnVuY3Rpb24oKXtpZih0eXBlb2YgdGhpcy53cyE9PVwidW5kZWZpbmVkXCIpe3RoaXMud3MuY2xvc2UoKX19O1dTLnByb3RvdHlwZS51cmk9ZnVuY3Rpb24oKXt2YXIgcXVlcnk9dGhpcy5xdWVyeXx8e307dmFyIHNjaGVtYT10aGlzLnNlY3VyZT9cIndzc1wiOlwid3NcIjt2YXIgcG9ydD1cIlwiO2lmKHRoaXMucG9ydCYmKFwid3NzXCI9PXNjaGVtYSYmdGhpcy5wb3J0IT00NDN8fFwid3NcIj09c2NoZW1hJiZ0aGlzLnBvcnQhPTgwKSl7cG9ydD1cIjpcIit0aGlzLnBvcnR9aWYodGhpcy50aW1lc3RhbXBSZXF1ZXN0cyl7cXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV09K25ldyBEYXRlfWlmKCF0aGlzLnN1cHBvcnRzQmluYXJ5KXtxdWVyeS5iNjQ9MX1xdWVyeT1wYXJzZXFzLmVuY29kZShxdWVyeSk7aWYocXVlcnkubGVuZ3RoKXtxdWVyeT1cIj9cIitxdWVyeX1yZXR1cm4gc2NoZW1hK1wiOi8vXCIrdGhpcy5ob3N0bmFtZStwb3J0K3RoaXMucGF0aCtxdWVyeX07V1MucHJvdG90eXBlLmNoZWNrPWZ1bmN0aW9uKCl7cmV0dXJuISFXZWJTb2NrZXQmJiEoXCJfX2luaXRpYWxpemVcImluIFdlYlNvY2tldCYmdGhpcy5uYW1lPT09V1MucHJvdG90eXBlLm5hbWUpfX0se1wiLi4vdHJhbnNwb3J0XCI6MTQsXCJjb21wb25lbnQtaW5oZXJpdFwiOjIxLGRlYnVnOjIyLFwiZW5naW5lLmlvLXBhcnNlclwiOjI1LHBhcnNlcXM6MzUsd3M6Mzd9XSwyMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGhhc0NPUlM9X2RlcmVxXyhcImhhcy1jb3JzXCIpO21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKG9wdHMpe3ZhciB4ZG9tYWluPW9wdHMueGRvbWFpbjt2YXIgeHNjaGVtZT1vcHRzLnhzY2hlbWU7dmFyIGVuYWJsZXNYRFI9b3B0cy5lbmFibGVzWERSO3RyeXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgWE1MSHR0cFJlcXVlc3QmJigheGRvbWFpbnx8aGFzQ09SUykpe3JldHVybiBuZXcgWE1MSHR0cFJlcXVlc3R9fWNhdGNoKGUpe310cnl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFhEb21haW5SZXF1ZXN0JiYheHNjaGVtZSYmZW5hYmxlc1hEUil7cmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdH19Y2F0Y2goZSl7fWlmKCF4ZG9tYWluKXt0cnl7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTWljcm9zb2Z0LlhNTEhUVFBcIil9Y2F0Y2goZSl7fX19fSx7XCJoYXMtY29yc1wiOjQwfV0sMjE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGEsYil7dmFyIGZuPWZ1bmN0aW9uKCl7fTtmbi5wcm90b3R5cGU9Yi5wcm90b3R5cGU7YS5wcm90b3R5cGU9bmV3IGZuO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWF9fSx7fV0sMjI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe2V4cG9ydHM9bW9kdWxlLmV4cG9ydHM9X2RlcmVxXyhcIi4vZGVidWdcIik7ZXhwb3J0cy5sb2c9bG9nO2V4cG9ydHMuZm9ybWF0QXJncz1mb3JtYXRBcmdzO2V4cG9ydHMuc2F2ZT1zYXZlO2V4cG9ydHMubG9hZD1sb2FkO2V4cG9ydHMudXNlQ29sb3JzPXVzZUNvbG9ycztleHBvcnRzLmNvbG9ycz1bXCJsaWdodHNlYWdyZWVuXCIsXCJmb3Jlc3RncmVlblwiLFwiZ29sZGVucm9kXCIsXCJkb2RnZXJibHVlXCIsXCJkYXJrb3JjaGlkXCIsXCJjcmltc29uXCJdO2Z1bmN0aW9uIHVzZUNvbG9ycygpe3JldHVyblwiV2Via2l0QXBwZWFyYW5jZVwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlfHx3aW5kb3cuY29uc29sZSYmKGNvbnNvbGUuZmlyZWJ1Z3x8Y29uc29sZS5leGNlcHRpb24mJmNvbnNvbGUudGFibGUpfHxuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSYmcGFyc2VJbnQoUmVnRXhwLiQxLDEwKT49MzF9ZXhwb3J0cy5mb3JtYXR0ZXJzLmo9ZnVuY3Rpb24odil7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpfTtmdW5jdGlvbiBmb3JtYXRBcmdzKCl7dmFyIGFyZ3M9YXJndW1lbnRzO3ZhciB1c2VDb2xvcnM9dGhpcy51c2VDb2xvcnM7YXJnc1swXT0odXNlQ29sb3JzP1wiJWNcIjpcIlwiKSt0aGlzLm5hbWVzcGFjZSsodXNlQ29sb3JzP1wiICVjXCI6XCIgXCIpK2FyZ3NbMF0rKHVzZUNvbG9ycz9cIiVjIFwiOlwiIFwiKStcIitcIitleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7aWYoIXVzZUNvbG9ycylyZXR1cm4gYXJnczt2YXIgYz1cImNvbG9yOiBcIit0aGlzLmNvbG9yO2FyZ3M9W2FyZ3NbMF0sYyxcImNvbG9yOiBpbmhlcml0XCJdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLDEpKTt2YXIgaW5kZXg9MDt2YXIgbGFzdEM9MDthcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZyxmdW5jdGlvbihtYXRjaCl7aWYoXCIlXCI9PT1tYXRjaClyZXR1cm47aW5kZXgrKztpZihcIiVjXCI9PT1tYXRjaCl7bGFzdEM9aW5kZXh9fSk7YXJncy5zcGxpY2UobGFzdEMsMCxjKTtyZXR1cm4gYXJnc31mdW5jdGlvbiBsb2coKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgY29uc29sZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgY29uc29sZS5sb2cmJkZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLGNvbnNvbGUsYXJndW1lbnRzKX1mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpe3RyeXtpZihudWxsPT1uYW1lc3BhY2VzKXtsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcImRlYnVnXCIpfWVsc2V7bG9jYWxTdG9yYWdlLmRlYnVnPW5hbWVzcGFjZXN9fWNhdGNoKGUpe319ZnVuY3Rpb24gbG9hZCgpe3ZhciByO3RyeXtyPWxvY2FsU3RvcmFnZS5kZWJ1Z31jYXRjaChlKXt9cmV0dXJuIHJ9ZXhwb3J0cy5lbmFibGUobG9hZCgpKX0se1wiLi9kZWJ1Z1wiOjIzfV0sMjM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe2V4cG9ydHM9bW9kdWxlLmV4cG9ydHM9ZGVidWc7ZXhwb3J0cy5jb2VyY2U9Y29lcmNlO2V4cG9ydHMuZGlzYWJsZT1kaXNhYmxlO2V4cG9ydHMuZW5hYmxlPWVuYWJsZTtleHBvcnRzLmVuYWJsZWQ9ZW5hYmxlZDtleHBvcnRzLmh1bWFuaXplPV9kZXJlcV8oXCJtc1wiKTtleHBvcnRzLm5hbWVzPVtdO2V4cG9ydHMuc2tpcHM9W107ZXhwb3J0cy5mb3JtYXR0ZXJzPXt9O3ZhciBwcmV2Q29sb3I9MDt2YXIgcHJldlRpbWU7ZnVuY3Rpb24gc2VsZWN0Q29sb3IoKXtyZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKyslZXhwb3J0cy5jb2xvcnMubGVuZ3RoXX1mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2Upe2Z1bmN0aW9uIGRpc2FibGVkKCl7fWRpc2FibGVkLmVuYWJsZWQ9ZmFsc2U7ZnVuY3Rpb24gZW5hYmxlZCgpe3ZhciBzZWxmPWVuYWJsZWQ7dmFyIGN1cnI9K25ldyBEYXRlO3ZhciBtcz1jdXJyLShwcmV2VGltZXx8Y3Vycik7c2VsZi5kaWZmPW1zO3NlbGYucHJldj1wcmV2VGltZTtzZWxmLmN1cnI9Y3VycjtwcmV2VGltZT1jdXJyO2lmKG51bGw9PXNlbGYudXNlQ29sb3JzKXNlbGYudXNlQ29sb3JzPWV4cG9ydHMudXNlQ29sb3JzKCk7aWYobnVsbD09c2VsZi5jb2xvciYmc2VsZi51c2VDb2xvcnMpc2VsZi5jb2xvcj1zZWxlY3RDb2xvcigpO3ZhciBhcmdzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7YXJnc1swXT1leHBvcnRzLmNvZXJjZShhcmdzWzBdKTtpZihcInN0cmluZ1wiIT09dHlwZW9mIGFyZ3NbMF0pe2FyZ3M9W1wiJW9cIl0uY29uY2F0KGFyZ3MpfXZhciBpbmRleD0wO2FyZ3NbMF09YXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZyxmdW5jdGlvbihtYXRjaCxmb3JtYXQpe2lmKG1hdGNoPT09XCIlXCIpcmV0dXJuIG1hdGNoO2luZGV4Kys7dmFyIGZvcm1hdHRlcj1leHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZm9ybWF0dGVyKXt2YXIgdmFsPWFyZ3NbaW5kZXhdO21hdGNoPWZvcm1hdHRlci5jYWxsKHNlbGYsdmFsKTthcmdzLnNwbGljZShpbmRleCwxKTtpbmRleC0tfXJldHVybiBtYXRjaH0pO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3Mpe2FyZ3M9ZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsYXJncyl9dmFyIGxvZ0ZuPWVuYWJsZWQubG9nfHxleHBvcnRzLmxvZ3x8Y29uc29sZS5sb2cuYmluZChjb25zb2xlKTtsb2dGbi5hcHBseShzZWxmLGFyZ3MpfWVuYWJsZWQuZW5hYmxlZD10cnVlO3ZhciBmbj1leHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKT9lbmFibGVkOmRpc2FibGVkO2ZuLm5hbWVzcGFjZT1uYW1lc3BhY2U7cmV0dXJuIGZufWZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKXtleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7dmFyIHNwbGl0PShuYW1lc3BhY2VzfHxcIlwiKS5zcGxpdCgvW1xccyxdKy8pO3ZhciBsZW49c3BsaXQubGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuO2krKyl7aWYoIXNwbGl0W2ldKWNvbnRpbnVlO25hbWVzcGFjZXM9c3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csXCIuKj9cIik7aWYobmFtZXNwYWNlc1swXT09PVwiLVwiKXtleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cChcIl5cIituYW1lc3BhY2VzLnN1YnN0cigxKStcIiRcIikpfWVsc2V7ZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrbmFtZXNwYWNlcytcIiRcIikpfX19ZnVuY3Rpb24gZGlzYWJsZSgpe2V4cG9ydHMuZW5hYmxlKFwiXCIpfWZ1bmN0aW9uIGVuYWJsZWQobmFtZSl7dmFyIGksbGVuO2ZvcihpPTAsbGVuPWV4cG9ydHMuc2tpcHMubGVuZ3RoO2k8bGVuO2krKyl7aWYoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKXtyZXR1cm4gZmFsc2V9fWZvcihpPTAsbGVuPWV4cG9ydHMubmFtZXMubGVuZ3RoO2k8bGVuO2krKyl7aWYoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfWZ1bmN0aW9uIGNvZXJjZSh2YWwpe2lmKHZhbCBpbnN0YW5jZW9mIEVycm9yKXJldHVybiB2YWwuc3RhY2t8fHZhbC5tZXNzYWdlO3JldHVybiB2YWx9fSx7bXM6MjR9XSwyNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHM9MWUzO3ZhciBtPXMqNjA7dmFyIGg9bSo2MDt2YXIgZD1oKjI0O3ZhciB5PWQqMzY1LjI1O21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKHZhbCxvcHRpb25zKXtvcHRpb25zPW9wdGlvbnN8fHt9O2lmKFwic3RyaW5nXCI9PXR5cGVvZiB2YWwpcmV0dXJuIHBhcnNlKHZhbCk7cmV0dXJuIG9wdGlvbnMubG9uZz9sb25nKHZhbCk6c2hvcnQodmFsKX07ZnVuY3Rpb24gcGFyc2Uoc3RyKXt2YXIgbWF0Y2g9L14oKD86XFxkKyk/XFwuP1xcZCspICoobXN8c2Vjb25kcz98c3xtaW51dGVzP3xtfGhvdXJzP3xofGRheXM/fGR8eWVhcnM/fHkpPyQvaS5leGVjKHN0cik7aWYoIW1hdGNoKXJldHVybjt2YXIgbj1wYXJzZUZsb2F0KG1hdGNoWzFdKTt2YXIgdHlwZT0obWF0Y2hbMl18fFwibXNcIikudG9Mb3dlckNhc2UoKTtzd2l0Y2godHlwZSl7Y2FzZVwieWVhcnNcIjpjYXNlXCJ5ZWFyXCI6Y2FzZVwieVwiOnJldHVybiBuKnk7Y2FzZVwiZGF5c1wiOmNhc2VcImRheVwiOmNhc2VcImRcIjpyZXR1cm4gbipkO2Nhc2VcImhvdXJzXCI6Y2FzZVwiaG91clwiOmNhc2VcImhcIjpyZXR1cm4gbipoO2Nhc2VcIm1pbnV0ZXNcIjpjYXNlXCJtaW51dGVcIjpjYXNlXCJtXCI6cmV0dXJuIG4qbTtjYXNlXCJzZWNvbmRzXCI6Y2FzZVwic2Vjb25kXCI6Y2FzZVwic1wiOnJldHVybiBuKnM7Y2FzZVwibXNcIjpyZXR1cm4gbn19ZnVuY3Rpb24gc2hvcnQobXMpe2lmKG1zPj1kKXJldHVybiBNYXRoLnJvdW5kKG1zL2QpK1wiZFwiO2lmKG1zPj1oKXJldHVybiBNYXRoLnJvdW5kKG1zL2gpK1wiaFwiO2lmKG1zPj1tKXJldHVybiBNYXRoLnJvdW5kKG1zL20pK1wibVwiO2lmKG1zPj1zKXJldHVybiBNYXRoLnJvdW5kKG1zL3MpK1wic1wiO3JldHVybiBtcytcIm1zXCJ9ZnVuY3Rpb24gbG9uZyhtcyl7cmV0dXJuIHBsdXJhbChtcyxkLFwiZGF5XCIpfHxwbHVyYWwobXMsaCxcImhvdXJcIil8fHBsdXJhbChtcyxtLFwibWludXRlXCIpfHxwbHVyYWwobXMscyxcInNlY29uZFwiKXx8bXMrXCIgbXNcIn1mdW5jdGlvbiBwbHVyYWwobXMsbixuYW1lKXtpZihtczxuKXJldHVybjtpZihtczxuKjEuNSlyZXR1cm4gTWF0aC5mbG9vcihtcy9uKStcIiBcIituYW1lO3JldHVybiBNYXRoLmNlaWwobXMvbikrXCIgXCIrbmFtZStcInNcIn19LHt9XSwyNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIGtleXM9X2RlcmVxXyhcIi4va2V5c1wiKTt2YXIgaGFzQmluYXJ5PV9kZXJlcV8oXCJoYXMtYmluYXJ5XCIpO3ZhciBzbGljZUJ1ZmZlcj1fZGVyZXFfKFwiYXJyYXlidWZmZXIuc2xpY2VcIik7dmFyIGJhc2U2NGVuY29kZXI9X2RlcmVxXyhcImJhc2U2NC1hcnJheWJ1ZmZlclwiKTt2YXIgYWZ0ZXI9X2RlcmVxXyhcImFmdGVyXCIpO3ZhciB1dGY4PV9kZXJlcV8oXCJ1dGY4XCIpO3ZhciBpc0FuZHJvaWQ9bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTt2YXIgaXNQaGFudG9tSlM9L1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7dmFyIGRvbnRTZW5kQmxvYnM9aXNBbmRyb2lkfHxpc1BoYW50b21KUztleHBvcnRzLnByb3RvY29sPTM7dmFyIHBhY2tldHM9ZXhwb3J0cy5wYWNrZXRzPXtvcGVuOjAsY2xvc2U6MSxwaW5nOjIscG9uZzozLG1lc3NhZ2U6NCx1cGdyYWRlOjUsbm9vcDo2fTt2YXIgcGFja2V0c2xpc3Q9a2V5cyhwYWNrZXRzKTt2YXIgZXJyPXt0eXBlOlwiZXJyb3JcIixkYXRhOlwicGFyc2VyIGVycm9yXCJ9O3ZhciBCbG9iPV9kZXJlcV8oXCJibG9iXCIpO2V4cG9ydHMuZW5jb2RlUGFja2V0PWZ1bmN0aW9uKHBhY2tldCxzdXBwb3J0c0JpbmFyeSx1dGY4ZW5jb2RlLGNhbGxiYWNrKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBzdXBwb3J0c0JpbmFyeSl7Y2FsbGJhY2s9c3VwcG9ydHNCaW5hcnk7c3VwcG9ydHNCaW5hcnk9ZmFsc2V9aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdXRmOGVuY29kZSl7Y2FsbGJhY2s9dXRmOGVuY29kZTt1dGY4ZW5jb2RlPW51bGx9dmFyIGRhdGE9cGFja2V0LmRhdGE9PT11bmRlZmluZWQ/dW5kZWZpbmVkOnBhY2tldC5kYXRhLmJ1ZmZlcnx8cGFja2V0LmRhdGE7aWYoZ2xvYmFsLkFycmF5QnVmZmVyJiZkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpe3JldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsc3VwcG9ydHNCaW5hcnksY2FsbGJhY2spfWVsc2UgaWYoQmxvYiYmZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKXtyZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsc3VwcG9ydHNCaW5hcnksY2FsbGJhY2spfWlmKGRhdGEmJmRhdGEuYmFzZTY0KXtyZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCxjYWxsYmFjayl9dmFyIGVuY29kZWQ9cGFja2V0c1twYWNrZXQudHlwZV07aWYodW5kZWZpbmVkIT09cGFja2V0LmRhdGEpe2VuY29kZWQrPXV0ZjhlbmNvZGU/dXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSk6U3RyaW5nKHBhY2tldC5kYXRhKX1yZXR1cm4gY2FsbGJhY2soXCJcIitlbmNvZGVkKX07ZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCxjYWxsYmFjayl7dmFyIG1lc3NhZ2U9XCJiXCIrZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXStwYWNrZXQuZGF0YS5kYXRhO3JldHVybiBjYWxsYmFjayhtZXNzYWdlKX1mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsc3VwcG9ydHNCaW5hcnksY2FsbGJhY2spe2lmKCFzdXBwb3J0c0JpbmFyeSl7cmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCxjYWxsYmFjayl9dmFyIGRhdGE9cGFja2V0LmRhdGE7dmFyIGNvbnRlbnRBcnJheT1uZXcgVWludDhBcnJheShkYXRhKTt2YXIgcmVzdWx0QnVmZmVyPW5ldyBVaW50OEFycmF5KDErZGF0YS5ieXRlTGVuZ3RoKTtyZXN1bHRCdWZmZXJbMF09cGFja2V0c1twYWNrZXQudHlwZV07Zm9yKHZhciBpPTA7aTxjb250ZW50QXJyYXkubGVuZ3RoO2krKyl7cmVzdWx0QnVmZmVyW2krMV09Y29udGVudEFycmF5W2ldfXJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKX1mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsc3VwcG9ydHNCaW5hcnksY2FsbGJhY2spe2lmKCFzdXBwb3J0c0JpbmFyeSl7cmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCxjYWxsYmFjayl9dmFyIGZyPW5ldyBGaWxlUmVhZGVyO2ZyLm9ubG9hZD1mdW5jdGlvbigpe3BhY2tldC5kYXRhPWZyLnJlc3VsdDtleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsc3VwcG9ydHNCaW5hcnksdHJ1ZSxjYWxsYmFjayl9O3JldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSl9ZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsc3VwcG9ydHNCaW5hcnksY2FsbGJhY2spe2lmKCFzdXBwb3J0c0JpbmFyeSl7cmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCxjYWxsYmFjayl9aWYoZG9udFNlbmRCbG9icyl7cmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCxzdXBwb3J0c0JpbmFyeSxjYWxsYmFjayl9dmFyIGxlbmd0aD1uZXcgVWludDhBcnJheSgxKTtsZW5ndGhbMF09cGFja2V0c1twYWNrZXQudHlwZV07dmFyIGJsb2I9bmV3IEJsb2IoW2xlbmd0aC5idWZmZXIscGFja2V0LmRhdGFdKTtyZXR1cm4gY2FsbGJhY2soYmxvYil9ZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQ9ZnVuY3Rpb24ocGFja2V0LGNhbGxiYWNrKXt2YXIgbWVzc2FnZT1cImJcIitleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO2lmKEJsb2ImJnBhY2tldC5kYXRhIGluc3RhbmNlb2YgQmxvYil7dmFyIGZyPW5ldyBGaWxlUmVhZGVyO2ZyLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBiNjQ9ZnIucmVzdWx0LnNwbGl0KFwiLFwiKVsxXTtjYWxsYmFjayhtZXNzYWdlK2I2NCl9O3JldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKX12YXIgYjY0ZGF0YTt0cnl7YjY0ZGF0YT1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKX1jYXRjaChlKXt2YXIgdHlwZWQ9bmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO3ZhciBiYXNpYz1uZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtmb3IodmFyIGk9MDtpPHR5cGVkLmxlbmd0aDtpKyspe2Jhc2ljW2ldPXR5cGVkW2ldfWI2NGRhdGE9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLGJhc2ljKX1tZXNzYWdlKz1nbG9iYWwuYnRvYShiNjRkYXRhKTtyZXR1cm4gY2FsbGJhY2sobWVzc2FnZSl9O2V4cG9ydHMuZGVjb2RlUGFja2V0PWZ1bmN0aW9uKGRhdGEsYmluYXJ5VHlwZSx1dGY4ZGVjb2RlKXtpZih0eXBlb2YgZGF0YT09XCJzdHJpbmdcInx8ZGF0YT09PXVuZGVmaW5lZCl7aWYoZGF0YS5jaGFyQXQoMCk9PVwiYlwiKXtyZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksYmluYXJ5VHlwZSl9aWYodXRmOGRlY29kZSl7dHJ5e2RhdGE9dXRmOC5kZWNvZGUoZGF0YSl9Y2F0Y2goZSl7cmV0dXJuIGVycn19dmFyIHR5cGU9ZGF0YS5jaGFyQXQoMCk7aWYoTnVtYmVyKHR5cGUpIT10eXBlfHwhcGFja2V0c2xpc3RbdHlwZV0pe3JldHVybiBlcnJ9aWYoZGF0YS5sZW5ndGg+MSl7cmV0dXJue3R5cGU6cGFja2V0c2xpc3RbdHlwZV0sZGF0YTpkYXRhLnN1YnN0cmluZygxKX19ZWxzZXtyZXR1cm57dHlwZTpwYWNrZXRzbGlzdFt0eXBlXX19fXZhciBhc0FycmF5PW5ldyBVaW50OEFycmF5KGRhdGEpO3ZhciB0eXBlPWFzQXJyYXlbMF07dmFyIHJlc3Q9c2xpY2VCdWZmZXIoZGF0YSwxKTtpZihCbG9iJiZiaW5hcnlUeXBlPT09XCJibG9iXCIpe3Jlc3Q9bmV3IEJsb2IoW3Jlc3RdKX1yZXR1cm57dHlwZTpwYWNrZXRzbGlzdFt0eXBlXSxkYXRhOnJlc3R9fTtleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldD1mdW5jdGlvbihtc2csYmluYXJ5VHlwZSl7dmFyIHR5cGU9cGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07aWYoIWdsb2JhbC5BcnJheUJ1ZmZlcil7cmV0dXJue3R5cGU6dHlwZSxkYXRhOntiYXNlNjQ6dHJ1ZSxkYXRhOm1zZy5zdWJzdHIoMSl9fX12YXIgZGF0YT1iYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtpZihiaW5hcnlUeXBlPT09XCJibG9iXCImJkJsb2Ipe2RhdGE9bmV3IEJsb2IoW2RhdGFdKX1yZXR1cm57dHlwZTp0eXBlLGRhdGE6ZGF0YX19O2V4cG9ydHMuZW5jb2RlUGF5bG9hZD1mdW5jdGlvbihwYWNrZXRzLHN1cHBvcnRzQmluYXJ5LGNhbGxiYWNrKXtpZih0eXBlb2Ygc3VwcG9ydHNCaW5hcnk9PVwiZnVuY3Rpb25cIil7Y2FsbGJhY2s9c3VwcG9ydHNCaW5hcnk7c3VwcG9ydHNCaW5hcnk9bnVsbH12YXIgaXNCaW5hcnk9aGFzQmluYXJ5KHBhY2tldHMpO2lmKHN1cHBvcnRzQmluYXJ5JiZpc0JpbmFyeSl7aWYoQmxvYiYmIWRvbnRTZW5kQmxvYnMpe3JldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cyxjYWxsYmFjayl9cmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cyxjYWxsYmFjayl9aWYoIXBhY2tldHMubGVuZ3RoKXtyZXR1cm4gY2FsbGJhY2soXCIwOlwiKX1mdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSl7cmV0dXJuIG1lc3NhZ2UubGVuZ3RoK1wiOlwiK21lc3NhZ2V9ZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCxkb25lQ2FsbGJhY2spe2V4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwhaXNCaW5hcnk/ZmFsc2U6c3VwcG9ydHNCaW5hcnksdHJ1ZSxmdW5jdGlvbihtZXNzYWdlKXtkb25lQ2FsbGJhY2sobnVsbCxzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpfSl9bWFwKHBhY2tldHMsZW5jb2RlT25lLGZ1bmN0aW9uKGVycixyZXN1bHRzKXtyZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKFwiXCIpKX0pfTtmdW5jdGlvbiBtYXAoYXJ5LGVhY2gsZG9uZSl7dmFyIHJlc3VsdD1uZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7dmFyIG5leHQ9YWZ0ZXIoYXJ5Lmxlbmd0aCxkb25lKTt2YXIgZWFjaFdpdGhJbmRleD1mdW5jdGlvbihpLGVsLGNiKXtlYWNoKGVsLGZ1bmN0aW9uKGVycm9yLG1zZyl7cmVzdWx0W2ldPW1zZztjYihlcnJvcixyZXN1bHQpfSl9O2Zvcih2YXIgaT0wO2k8YXJ5Lmxlbmd0aDtpKyspe2VhY2hXaXRoSW5kZXgoaSxhcnlbaV0sbmV4dCl9fWV4cG9ydHMuZGVjb2RlUGF5bG9hZD1mdW5jdGlvbihkYXRhLGJpbmFyeVR5cGUsY2FsbGJhY2spe2lmKHR5cGVvZiBkYXRhIT1cInN0cmluZ1wiKXtyZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSxiaW5hcnlUeXBlLGNhbGxiYWNrKX1pZih0eXBlb2YgYmluYXJ5VHlwZT09PVwiZnVuY3Rpb25cIil7Y2FsbGJhY2s9YmluYXJ5VHlwZTtiaW5hcnlUeXBlPW51bGx9dmFyIHBhY2tldDtpZihkYXRhPT1cIlwiKXtyZXR1cm4gY2FsbGJhY2soZXJyLDAsMSl9dmFyIGxlbmd0aD1cIlwiLG4sbXNnO2Zvcih2YXIgaT0wLGw9ZGF0YS5sZW5ndGg7aTxsO2krKyl7dmFyIGNocj1kYXRhLmNoYXJBdChpKTtpZihcIjpcIiE9Y2hyKXtsZW5ndGgrPWNocn1lbHNle2lmKFwiXCI9PWxlbmd0aHx8bGVuZ3RoIT0obj1OdW1iZXIobGVuZ3RoKSkpe3JldHVybiBjYWxsYmFjayhlcnIsMCwxKX1tc2c9ZGF0YS5zdWJzdHIoaSsxLG4pO2lmKGxlbmd0aCE9bXNnLmxlbmd0aCl7cmV0dXJuIGNhbGxiYWNrKGVyciwwLDEpfWlmKG1zZy5sZW5ndGgpe3BhY2tldD1leHBvcnRzLmRlY29kZVBhY2tldChtc2csYmluYXJ5VHlwZSx0cnVlKTtpZihlcnIudHlwZT09cGFja2V0LnR5cGUmJmVyci5kYXRhPT1wYWNrZXQuZGF0YSl7cmV0dXJuIGNhbGxiYWNrKGVyciwwLDEpfXZhciByZXQ9Y2FsbGJhY2socGFja2V0LGkrbixsKTtpZihmYWxzZT09PXJldClyZXR1cm59aSs9bjtsZW5ndGg9XCJcIn19aWYobGVuZ3RoIT1cIlwiKXtyZXR1cm4gY2FsbGJhY2soZXJyLDAsMSl9fTtleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyPWZ1bmN0aW9uKHBhY2tldHMsY2FsbGJhY2spe2lmKCFwYWNrZXRzLmxlbmd0aCl7cmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSl9ZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCxkb25lQ2FsbGJhY2spe2V4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCx0cnVlLHRydWUsZnVuY3Rpb24oZGF0YSl7cmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLGRhdGEpfSl9bWFwKHBhY2tldHMsZW5jb2RlT25lLGZ1bmN0aW9uKGVycixlbmNvZGVkUGFja2V0cyl7dmFyIHRvdGFsTGVuZ3RoPWVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MscCl7dmFyIGxlbjtpZih0eXBlb2YgcD09PVwic3RyaW5nXCIpe2xlbj1wLmxlbmd0aH1lbHNle2xlbj1wLmJ5dGVMZW5ndGh9cmV0dXJuIGFjYytsZW4udG9TdHJpbmcoKS5sZW5ndGgrbGVuKzJ9LDApO3ZhciByZXN1bHRBcnJheT1uZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7dmFyIGJ1ZmZlckluZGV4PTA7ZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKXt2YXIgaXNTdHJpbmc9dHlwZW9mIHA9PT1cInN0cmluZ1wiO3ZhciBhYj1wO2lmKGlzU3RyaW5nKXt2YXIgdmlldz1uZXcgVWludDhBcnJheShwLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxwLmxlbmd0aDtpKyspe3ZpZXdbaV09cC5jaGFyQ29kZUF0KGkpfWFiPXZpZXcuYnVmZmVyfWlmKGlzU3RyaW5nKXtyZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXT0wfWVsc2V7cmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK109MX12YXIgbGVuU3RyPWFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtmb3IodmFyIGk9MDtpPGxlblN0ci5sZW5ndGg7aSsrKXtyZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXT1wYXJzZUludChsZW5TdHJbaV0pfXJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdPTI1NTt2YXIgdmlldz1uZXcgVWludDhBcnJheShhYik7Zm9yKHZhciBpPTA7aTx2aWV3Lmxlbmd0aDtpKyspe3Jlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdPXZpZXdbaV19fSk7cmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcil9KX07ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iPWZ1bmN0aW9uKHBhY2tldHMsY2FsbGJhY2spe2Z1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsZG9uZUNhbGxiYWNrKXtleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsdHJ1ZSx0cnVlLGZ1bmN0aW9uKGVuY29kZWQpe3ZhciBiaW5hcnlJZGVudGlmaWVyPW5ldyBVaW50OEFycmF5KDEpO2JpbmFyeUlkZW50aWZpZXJbMF09MTtpZih0eXBlb2YgZW5jb2RlZD09PVwic3RyaW5nXCIpe3ZhciB2aWV3PW5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGVuY29kZWQubGVuZ3RoO2krKyl7dmlld1tpXT1lbmNvZGVkLmNoYXJDb2RlQXQoaSl9ZW5jb2RlZD12aWV3LmJ1ZmZlcjtiaW5hcnlJZGVudGlmaWVyWzBdPTB9dmFyIGxlbj1lbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/ZW5jb2RlZC5ieXRlTGVuZ3RoOmVuY29kZWQuc2l6ZTt2YXIgbGVuU3RyPWxlbi50b1N0cmluZygpO3ZhciBsZW5ndGhBcnk9bmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCsxKTtmb3IodmFyIGk9MDtpPGxlblN0ci5sZW5ndGg7aSsrKXtsZW5ndGhBcnlbaV09cGFyc2VJbnQobGVuU3RyW2ldKX1sZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF09MjU1O2lmKEJsb2Ipe3ZhciBibG9iPW5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlcixsZW5ndGhBcnkuYnVmZmVyLGVuY29kZWRdKTtkb25lQ2FsbGJhY2sobnVsbCxibG9iKX19KX1tYXAocGFja2V0cyxlbmNvZGVPbmUsZnVuY3Rpb24oZXJyLHJlc3VsdHMpe3JldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSl9KX07ZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnk9ZnVuY3Rpb24oZGF0YSxiaW5hcnlUeXBlLGNhbGxiYWNrKXtpZih0eXBlb2YgYmluYXJ5VHlwZT09PVwiZnVuY3Rpb25cIil7Y2FsbGJhY2s9YmluYXJ5VHlwZTtiaW5hcnlUeXBlPW51bGx9dmFyIGJ1ZmZlclRhaWw9ZGF0YTt2YXIgYnVmZmVycz1bXTt2YXIgbnVtYmVyVG9vTG9uZz1mYWxzZTt3aGlsZShidWZmZXJUYWlsLmJ5dGVMZW5ndGg+MCl7dmFyIHRhaWxBcnJheT1uZXcgVWludDhBcnJheShidWZmZXJUYWlsKTt2YXIgaXNTdHJpbmc9dGFpbEFycmF5WzBdPT09MDt2YXIgbXNnTGVuZ3RoPVwiXCI7Zm9yKHZhciBpPTE7O2krKyl7aWYodGFpbEFycmF5W2ldPT0yNTUpYnJlYWs7aWYobXNnTGVuZ3RoLmxlbmd0aD4zMTApe251bWJlclRvb0xvbmc9dHJ1ZTticmVha31tc2dMZW5ndGgrPXRhaWxBcnJheVtpXX1pZihudW1iZXJUb29Mb25nKXJldHVybiBjYWxsYmFjayhlcnIsMCwxKTtidWZmZXJUYWlsPXNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsMittc2dMZW5ndGgubGVuZ3RoKTttc2dMZW5ndGg9cGFyc2VJbnQobXNnTGVuZ3RoKTt2YXIgbXNnPXNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsMCxtc2dMZW5ndGgpO2lmKGlzU3RyaW5nKXt0cnl7bXNnPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuZXcgVWludDhBcnJheShtc2cpKX1jYXRjaChlKXt2YXIgdHlwZWQ9bmV3IFVpbnQ4QXJyYXkobXNnKTttc2c9XCJcIjtmb3IodmFyIGk9MDtpPHR5cGVkLmxlbmd0aDtpKyspe21zZys9U3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSl9fX1idWZmZXJzLnB1c2gobXNnKTtidWZmZXJUYWlsPXNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsbXNnTGVuZ3RoKX12YXIgdG90YWw9YnVmZmVycy5sZW5ndGg7YnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlcixpKXtjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsYmluYXJ5VHlwZSx0cnVlKSxpLHRvdGFsKX0pfX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7XCIuL2tleXNcIjoyNixhZnRlcjoyNyxcImFycmF5YnVmZmVyLnNsaWNlXCI6MjgsXCJiYXNlNjQtYXJyYXlidWZmZXJcIjoyOSxibG9iOjMwLFwiaGFzLWJpbmFyeVwiOjMxLHV0Zjg6MzN9XSwyNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uIGtleXMob2JqKXt2YXIgYXJyPVtdO3ZhciBoYXM9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtmb3IodmFyIGkgaW4gb2JqKXtpZihoYXMuY2FsbChvYmosaSkpe2Fyci5wdXNoKGkpfX1yZXR1cm4gYXJyfX0se31dLDI3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1hZnRlcjtmdW5jdGlvbiBhZnRlcihjb3VudCxjYWxsYmFjayxlcnJfY2Ipe3ZhciBiYWlsPWZhbHNlO2Vycl9jYj1lcnJfY2J8fG5vb3A7cHJveHkuY291bnQ9Y291bnQ7cmV0dXJuIGNvdW50PT09MD9jYWxsYmFjaygpOnByb3h5O2Z1bmN0aW9uIHByb3h5KGVycixyZXN1bHQpe2lmKHByb3h5LmNvdW50PD0wKXt0aHJvdyBuZXcgRXJyb3IoXCJhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXNcIil9LS1wcm94eS5jb3VudDtpZihlcnIpe2JhaWw9dHJ1ZTtjYWxsYmFjayhlcnIpO2NhbGxiYWNrPWVycl9jYn1lbHNlIGlmKHByb3h5LmNvdW50PT09MCYmIWJhaWwpe2NhbGxiYWNrKG51bGwscmVzdWx0KX19fWZ1bmN0aW9uIG5vb3AoKXt9fSx7fV0sMjg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGFycmF5YnVmZmVyLHN0YXJ0LGVuZCl7dmFyIGJ5dGVzPWFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7c3RhcnQ9c3RhcnR8fDA7ZW5kPWVuZHx8Ynl0ZXM7aWYoYXJyYXlidWZmZXIuc2xpY2Upe3JldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCxlbmQpfWlmKHN0YXJ0PDApe3N0YXJ0Kz1ieXRlc31pZihlbmQ8MCl7ZW5kKz1ieXRlc31pZihlbmQ+Ynl0ZXMpe2VuZD1ieXRlc31pZihzdGFydD49Ynl0ZXN8fHN0YXJ0Pj1lbmR8fGJ5dGVzPT09MCl7cmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKX12YXIgYWJ2PW5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTt2YXIgcmVzdWx0PW5ldyBVaW50OEFycmF5KGVuZC1zdGFydCk7Zm9yKHZhciBpPXN0YXJ0LGlpPTA7aTxlbmQ7aSsrLGlpKyspe3Jlc3VsdFtpaV09YWJ2W2ldfXJldHVybiByZXN1bHQuYnVmZmVyfX0se31dLDI5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oY2hhcnMpe1widXNlIHN0cmljdFwiO2V4cG9ydHMuZW5jb2RlPWZ1bmN0aW9uKGFycmF5YnVmZmVyKXt2YXIgYnl0ZXM9bmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLGksbGVuPWJ5dGVzLmxlbmd0aCxiYXNlNjQ9XCJcIjtmb3IoaT0wO2k8bGVuO2krPTMpe2Jhc2U2NCs9Y2hhcnNbYnl0ZXNbaV0+PjJdO2Jhc2U2NCs9Y2hhcnNbKGJ5dGVzW2ldJjMpPDw0fGJ5dGVzW2krMV0+PjRdO2Jhc2U2NCs9Y2hhcnNbKGJ5dGVzW2krMV0mMTUpPDwyfGJ5dGVzW2krMl0+PjZdO2Jhc2U2NCs9Y2hhcnNbYnl0ZXNbaSsyXSY2M119aWYobGVuJTM9PT0yKXtiYXNlNjQ9YmFzZTY0LnN1YnN0cmluZygwLGJhc2U2NC5sZW5ndGgtMSkrXCI9XCJ9ZWxzZSBpZihsZW4lMz09PTEpe2Jhc2U2ND1iYXNlNjQuc3Vic3RyaW5nKDAsYmFzZTY0Lmxlbmd0aC0yKStcIj09XCJ9cmV0dXJuIGJhc2U2NH07ZXhwb3J0cy5kZWNvZGU9ZnVuY3Rpb24oYmFzZTY0KXt2YXIgYnVmZmVyTGVuZ3RoPWJhc2U2NC5sZW5ndGgqLjc1LGxlbj1iYXNlNjQubGVuZ3RoLGkscD0wLGVuY29kZWQxLGVuY29kZWQyLGVuY29kZWQzLGVuY29kZWQ0O2lmKGJhc2U2NFtiYXNlNjQubGVuZ3RoLTFdPT09XCI9XCIpe2J1ZmZlckxlbmd0aC0tO2lmKGJhc2U2NFtiYXNlNjQubGVuZ3RoLTJdPT09XCI9XCIpe2J1ZmZlckxlbmd0aC0tfX12YXIgYXJyYXlidWZmZXI9bmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksYnl0ZXM9bmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO2ZvcihpPTA7aTxsZW47aSs9NCl7ZW5jb2RlZDE9Y2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO2VuY29kZWQyPWNoYXJzLmluZGV4T2YoYmFzZTY0W2krMV0pO2VuY29kZWQzPWNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO2VuY29kZWQ0PWNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO2J5dGVzW3ArK109ZW5jb2RlZDE8PDJ8ZW5jb2RlZDI+PjQ7Ynl0ZXNbcCsrXT0oZW5jb2RlZDImMTUpPDw0fGVuY29kZWQzPj4yO2J5dGVzW3ArK109KGVuY29kZWQzJjMpPDw2fGVuY29kZWQ0JjYzfXJldHVybiBhcnJheWJ1ZmZlcn19KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIil9LHt9XSwzMDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIEJsb2JCdWlsZGVyPWdsb2JhbC5CbG9iQnVpbGRlcnx8Z2xvYmFsLldlYktpdEJsb2JCdWlsZGVyfHxnbG9iYWwuTVNCbG9iQnVpbGRlcnx8Z2xvYmFsLk1vekJsb2JCdWlsZGVyO3ZhciBibG9iU3VwcG9ydGVkPWZ1bmN0aW9uKCl7dHJ5e3ZhciBiPW5ldyBCbG9iKFtcImhpXCJdKTtyZXR1cm4gYi5zaXplPT0yfWNhdGNoKGUpe3JldHVybiBmYWxzZX19KCk7dmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkPUJsb2JCdWlsZGVyJiZCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kJiZCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtmdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSxvcHRpb25zKXtvcHRpb25zPW9wdGlvbnN8fHt9O3ZhciBiYj1uZXcgQmxvYkJ1aWxkZXI7Zm9yKHZhciBpPTA7aTxhcnkubGVuZ3RoO2krKyl7YmIuYXBwZW5kKGFyeVtpXSl9cmV0dXJuIG9wdGlvbnMudHlwZT9iYi5nZXRCbG9iKG9wdGlvbnMudHlwZSk6YmIuZ2V0QmxvYigpfW1vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKCl7aWYoYmxvYlN1cHBvcnRlZCl7cmV0dXJuIGdsb2JhbC5CbG9ifWVsc2UgaWYoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpe3JldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yfWVsc2V7cmV0dXJuIHVuZGVmaW5lZH19KCl9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se31dLDMxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgaXNBcnJheT1fZGVyZXFfKFwiaXNhcnJheVwiKTttb2R1bGUuZXhwb3J0cz1oYXNCaW5hcnk7ZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpe2Z1bmN0aW9uIF9oYXNCaW5hcnkob2JqKXtpZighb2JqKXJldHVybiBmYWxzZTtpZihnbG9iYWwuQnVmZmVyJiZnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iail8fGdsb2JhbC5BcnJheUJ1ZmZlciYmb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fGdsb2JhbC5CbG9iJiZvYmogaW5zdGFuY2VvZiBCbG9ifHxnbG9iYWwuRmlsZSYmb2JqIGluc3RhbmNlb2YgRmlsZSl7cmV0dXJuIHRydWV9aWYoaXNBcnJheShvYmopKXtmb3IodmFyIGk9MDtpPG9iai5sZW5ndGg7aSsrKXtpZihfaGFzQmluYXJ5KG9ialtpXSkpe3JldHVybiB0cnVlfX19ZWxzZSBpZihvYmomJlwib2JqZWN0XCI9PXR5cGVvZiBvYmope2lmKG9iai50b0pTT04pe29iaj1vYmoudG9KU09OKCl9Zm9yKHZhciBrZXkgaW4gb2JqKXtpZihvYmouaGFzT3duUHJvcGVydHkoa2V5KSYmX2hhc0JpbmFyeShvYmpba2V5XSkpe3JldHVybiB0cnVlfX19cmV0dXJuIGZhbHNlfXJldHVybiBfaGFzQmluYXJ5KGRhdGEpfX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7aXNhcnJheTozMn1dLDMyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihhcnIpe3JldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKT09XCJbb2JqZWN0IEFycmF5XVwifX0se31dLDMzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXsoZnVuY3Rpb24ocm9vdCl7dmFyIGZyZWVFeHBvcnRzPXR5cGVvZiBleHBvcnRzPT1cIm9iamVjdFwiJiZleHBvcnRzO3ZhciBmcmVlTW9kdWxlPXR5cGVvZiBtb2R1bGU9PVwib2JqZWN0XCImJm1vZHVsZSYmbW9kdWxlLmV4cG9ydHM9PWZyZWVFeHBvcnRzJiZtb2R1bGU7dmFyIGZyZWVHbG9iYWw9dHlwZW9mIGdsb2JhbD09XCJvYmplY3RcIiYmZ2xvYmFsO2lmKGZyZWVHbG9iYWwuZ2xvYmFsPT09ZnJlZUdsb2JhbHx8ZnJlZUdsb2JhbC53aW5kb3c9PT1mcmVlR2xvYmFsKXtyb290PWZyZWVHbG9iYWx9dmFyIHN0cmluZ0Zyb21DaGFyQ29kZT1TdHJpbmcuZnJvbUNoYXJDb2RlO2Z1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKXt2YXIgb3V0cHV0PVtdO3ZhciBjb3VudGVyPTA7dmFyIGxlbmd0aD1zdHJpbmcubGVuZ3RoO3ZhciB2YWx1ZTt2YXIgZXh0cmE7d2hpbGUoY291bnRlcjxsZW5ndGgpe3ZhbHVlPXN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7aWYodmFsdWU+PTU1Mjk2JiZ2YWx1ZTw9NTYzMTkmJmNvdW50ZXI8bGVuZ3RoKXtleHRyYT1zdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO2lmKChleHRyYSY2NDUxMik9PTU2MzIwKXtvdXRwdXQucHVzaCgoKHZhbHVlJjEwMjMpPDwxMCkrKGV4dHJhJjEwMjMpKzY1NTM2KX1lbHNle291dHB1dC5wdXNoKHZhbHVlKTtjb3VudGVyLS19fWVsc2V7b3V0cHV0LnB1c2godmFsdWUpfX1yZXR1cm4gb3V0cHV0fWZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpe3ZhciBsZW5ndGg9YXJyYXkubGVuZ3RoO3ZhciBpbmRleD0tMTt2YXIgdmFsdWU7dmFyIG91dHB1dD1cIlwiO3doaWxlKCsraW5kZXg8bGVuZ3RoKXt2YWx1ZT1hcnJheVtpbmRleF07aWYodmFsdWU+NjU1MzUpe3ZhbHVlLT02NTUzNjtcbm91dHB1dCs9c3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlPj4+MTAmMTAyM3w1NTI5Nik7dmFsdWU9NTYzMjB8dmFsdWUmMTAyM31vdXRwdXQrPXN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSl9cmV0dXJuIG91dHB1dH1mdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCxzaGlmdCl7cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQ+PnNoaWZ0JjYzfDEyOCl9ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCl7aWYoKGNvZGVQb2ludCY0Mjk0OTY3MTY4KT09MCl7cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpfXZhciBzeW1ib2w9XCJcIjtpZigoY29kZVBvaW50JjQyOTQ5NjUyNDgpPT0wKXtzeW1ib2w9c3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludD4+NiYzMXwxOTIpfWVsc2UgaWYoKGNvZGVQb2ludCY0Mjk0OTAxNzYwKT09MCl7c3ltYm9sPXN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQ+PjEyJjE1fDIyNCk7c3ltYm9sKz1jcmVhdGVCeXRlKGNvZGVQb2ludCw2KX1lbHNlIGlmKChjb2RlUG9pbnQmNDI5Mjg3MDE0NCk9PTApe3N5bWJvbD1zdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50Pj4xOCY3fDI0MCk7c3ltYm9sKz1jcmVhdGVCeXRlKGNvZGVQb2ludCwxMik7c3ltYm9sKz1jcmVhdGVCeXRlKGNvZGVQb2ludCw2KX1zeW1ib2wrPXN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQmNjN8MTI4KTtyZXR1cm4gc3ltYm9sfWZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKXt2YXIgY29kZVBvaW50cz11Y3MyZGVjb2RlKHN0cmluZyk7dmFyIGxlbmd0aD1jb2RlUG9pbnRzLmxlbmd0aDt2YXIgaW5kZXg9LTE7dmFyIGNvZGVQb2ludDt2YXIgYnl0ZVN0cmluZz1cIlwiO3doaWxlKCsraW5kZXg8bGVuZ3RoKXtjb2RlUG9pbnQ9Y29kZVBvaW50c1tpbmRleF07Ynl0ZVN0cmluZys9ZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCl9cmV0dXJuIGJ5dGVTdHJpbmd9ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKXtpZihieXRlSW5kZXg+PWJ5dGVDb3VudCl7dGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJ5dGUgaW5kZXhcIil9dmFyIGNvbnRpbnVhdGlvbkJ5dGU9Ynl0ZUFycmF5W2J5dGVJbmRleF0mMjU1O2J5dGVJbmRleCsrO2lmKChjb250aW51YXRpb25CeXRlJjE5Mik9PTEyOCl7cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUmNjN9dGhyb3cgRXJyb3IoXCJJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXCIpfWZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpe3ZhciBieXRlMTt2YXIgYnl0ZTI7dmFyIGJ5dGUzO3ZhciBieXRlNDt2YXIgY29kZVBvaW50O2lmKGJ5dGVJbmRleD5ieXRlQ291bnQpe3Rocm93IEVycm9yKFwiSW52YWxpZCBieXRlIGluZGV4XCIpfWlmKGJ5dGVJbmRleD09Ynl0ZUNvdW50KXtyZXR1cm4gZmFsc2V9Ynl0ZTE9Ynl0ZUFycmF5W2J5dGVJbmRleF0mMjU1O2J5dGVJbmRleCsrO2lmKChieXRlMSYxMjgpPT0wKXtyZXR1cm4gYnl0ZTF9aWYoKGJ5dGUxJjIyNCk9PTE5Mil7dmFyIGJ5dGUyPXJlYWRDb250aW51YXRpb25CeXRlKCk7Y29kZVBvaW50PShieXRlMSYzMSk8PDZ8Ynl0ZTI7aWYoY29kZVBvaW50Pj0xMjgpe3JldHVybiBjb2RlUG9pbnR9ZWxzZXt0aHJvdyBFcnJvcihcIkludmFsaWQgY29udGludWF0aW9uIGJ5dGVcIil9fWlmKChieXRlMSYyNDApPT0yMjQpe2J5dGUyPXJlYWRDb250aW51YXRpb25CeXRlKCk7Ynl0ZTM9cmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtjb2RlUG9pbnQ9KGJ5dGUxJjE1KTw8MTJ8Ynl0ZTI8PDZ8Ynl0ZTM7aWYoY29kZVBvaW50Pj0yMDQ4KXtyZXR1cm4gY29kZVBvaW50fWVsc2V7dGhyb3cgRXJyb3IoXCJJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXCIpfX1pZigoYnl0ZTEmMjQ4KT09MjQwKXtieXRlMj1yZWFkQ29udGludWF0aW9uQnl0ZSgpO2J5dGUzPXJlYWRDb250aW51YXRpb25CeXRlKCk7Ynl0ZTQ9cmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtjb2RlUG9pbnQ9KGJ5dGUxJjE1KTw8MTh8Ynl0ZTI8PDEyfGJ5dGUzPDw2fGJ5dGU0O2lmKGNvZGVQb2ludD49NjU1MzYmJmNvZGVQb2ludDw9MTExNDExMSl7cmV0dXJuIGNvZGVQb2ludH19dGhyb3cgRXJyb3IoXCJJbnZhbGlkIFVURi04IGRldGVjdGVkXCIpfXZhciBieXRlQXJyYXk7dmFyIGJ5dGVDb3VudDt2YXIgYnl0ZUluZGV4O2Z1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZyl7Ynl0ZUFycmF5PXVjczJkZWNvZGUoYnl0ZVN0cmluZyk7Ynl0ZUNvdW50PWJ5dGVBcnJheS5sZW5ndGg7Ynl0ZUluZGV4PTA7dmFyIGNvZGVQb2ludHM9W107dmFyIHRtcDt3aGlsZSgodG1wPWRlY29kZVN5bWJvbCgpKSE9PWZhbHNlKXtjb2RlUG9pbnRzLnB1c2godG1wKX1yZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKX12YXIgdXRmOD17dmVyc2lvbjpcIjIuMC4wXCIsZW5jb2RlOnV0ZjhlbmNvZGUsZGVjb2RlOnV0ZjhkZWNvZGV9O2lmKHR5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmdHlwZW9mIGRlZmluZS5hbWQ9PVwib2JqZWN0XCImJmRlZmluZS5hbWQpe2RlZmluZShmdW5jdGlvbigpe3JldHVybiB1dGY4fSl9ZWxzZSBpZihmcmVlRXhwb3J0cyYmIWZyZWVFeHBvcnRzLm5vZGVUeXBlKXtpZihmcmVlTW9kdWxlKXtmcmVlTW9kdWxlLmV4cG9ydHM9dXRmOH1lbHNle3ZhciBvYmplY3Q9e307dmFyIGhhc093blByb3BlcnR5PW9iamVjdC5oYXNPd25Qcm9wZXJ0eTtmb3IodmFyIGtleSBpbiB1dGY4KXtoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0Zjgsa2V5KSYmKGZyZWVFeHBvcnRzW2tleV09dXRmOFtrZXldKX19fWVsc2V7cm9vdC51dGY4PXV0Zjh9fSkodGhpcyl9KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se31dLDM0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgcnZhbGlkY2hhcnM9L15bXFxdLDp7fVxcc10qJC87dmFyIHJ2YWxpZGVzY2FwZT0vXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO3ZhciBydmFsaWR0b2tlbnM9L1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO3ZhciBydmFsaWRicmFjZXM9Lyg/Ol58OnwsKSg/OlxccypcXFspKy9nO3ZhciBydHJpbUxlZnQ9L15cXHMrLzt2YXIgcnRyaW1SaWdodD0vXFxzKyQvO21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKXtpZihcInN0cmluZ1wiIT10eXBlb2YgZGF0YXx8IWRhdGEpe3JldHVybiBudWxsfWRhdGE9ZGF0YS5yZXBsYWNlKHJ0cmltTGVmdCxcIlwiKS5yZXBsYWNlKHJ0cmltUmlnaHQsXCJcIik7aWYoZ2xvYmFsLkpTT04mJkpTT04ucGFyc2Upe3JldHVybiBKU09OLnBhcnNlKGRhdGEpfWlmKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSxcIkBcIikucmVwbGFjZShydmFsaWR0b2tlbnMsXCJdXCIpLnJlcGxhY2UocnZhbGlkYnJhY2VzLFwiXCIpKSl7cmV0dXJuIG5ldyBGdW5jdGlvbihcInJldHVybiBcIitkYXRhKSgpfX19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se31dLDM1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtleHBvcnRzLmVuY29kZT1mdW5jdGlvbihvYmope3ZhciBzdHI9XCJcIjtmb3IodmFyIGkgaW4gb2JqKXtpZihvYmouaGFzT3duUHJvcGVydHkoaSkpe2lmKHN0ci5sZW5ndGgpc3RyKz1cIiZcIjtzdHIrPWVuY29kZVVSSUNvbXBvbmVudChpKStcIj1cIitlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKX19cmV0dXJuIHN0cn07ZXhwb3J0cy5kZWNvZGU9ZnVuY3Rpb24ocXMpe3ZhciBxcnk9e307dmFyIHBhaXJzPXFzLnNwbGl0KFwiJlwiKTtmb3IodmFyIGk9MCxsPXBhaXJzLmxlbmd0aDtpPGw7aSsrKXt2YXIgcGFpcj1wYWlyc1tpXS5zcGxpdChcIj1cIik7cXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV09ZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pfXJldHVybiBxcnl9fSx7fV0sMzY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciByZT0vXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLzt2YXIgcGFydHM9W1wic291cmNlXCIsXCJwcm90b2NvbFwiLFwiYXV0aG9yaXR5XCIsXCJ1c2VySW5mb1wiLFwidXNlclwiLFwicGFzc3dvcmRcIixcImhvc3RcIixcInBvcnRcIixcInJlbGF0aXZlXCIsXCJwYXRoXCIsXCJkaXJlY3RvcnlcIixcImZpbGVcIixcInF1ZXJ5XCIsXCJhbmNob3JcIl07bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gcGFyc2V1cmkoc3RyKXt2YXIgc3JjPXN0cixiPXN0ci5pbmRleE9mKFwiW1wiKSxlPXN0ci5pbmRleE9mKFwiXVwiKTtpZihiIT0tMSYmZSE9LTEpe3N0cj1zdHIuc3Vic3RyaW5nKDAsYikrc3RyLnN1YnN0cmluZyhiLGUpLnJlcGxhY2UoLzovZyxcIjtcIikrc3RyLnN1YnN0cmluZyhlLHN0ci5sZW5ndGgpfXZhciBtPXJlLmV4ZWMoc3RyfHxcIlwiKSx1cmk9e30saT0xNDt3aGlsZShpLS0pe3VyaVtwYXJ0c1tpXV09bVtpXXx8XCJcIn1pZihiIT0tMSYmZSE9LTEpe3VyaS5zb3VyY2U9c3JjO3VyaS5ob3N0PXVyaS5ob3N0LnN1YnN0cmluZygxLHVyaS5ob3N0Lmxlbmd0aC0xKS5yZXBsYWNlKC87L2csXCI6XCIpO3VyaS5hdXRob3JpdHk9dXJpLmF1dGhvcml0eS5yZXBsYWNlKFwiW1wiLFwiXCIpLnJlcGxhY2UoXCJdXCIsXCJcIikucmVwbGFjZSgvOy9nLFwiOlwiKTt1cmkuaXB2NnVyaT10cnVlfXJldHVybiB1cml9fSx7fV0sMzc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBnbG9iYWw9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKTt2YXIgV2ViU29ja2V0PWdsb2JhbC5XZWJTb2NrZXR8fGdsb2JhbC5Nb3pXZWJTb2NrZXQ7bW9kdWxlLmV4cG9ydHM9V2ViU29ja2V0P3dzOm51bGw7ZnVuY3Rpb24gd3ModXJpLHByb3RvY29scyxvcHRzKXt2YXIgaW5zdGFuY2U7aWYocHJvdG9jb2xzKXtpbnN0YW5jZT1uZXcgV2ViU29ja2V0KHVyaSxwcm90b2NvbHMpfWVsc2V7aW5zdGFuY2U9bmV3IFdlYlNvY2tldCh1cmkpfXJldHVybiBpbnN0YW5jZX1pZihXZWJTb2NrZXQpd3MucHJvdG90eXBlPVdlYlNvY2tldC5wcm90b3R5cGV9LHt9XSwzODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIGlzQXJyYXk9X2RlcmVxXyhcImlzYXJyYXlcIik7bW9kdWxlLmV4cG9ydHM9aGFzQmluYXJ5O2Z1bmN0aW9uIGhhc0JpbmFyeShkYXRhKXtmdW5jdGlvbiBfaGFzQmluYXJ5KG9iail7aWYoIW9iailyZXR1cm4gZmFsc2U7aWYoZ2xvYmFsLkJ1ZmZlciYmZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopfHxnbG9iYWwuQXJyYXlCdWZmZXImJm9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxnbG9iYWwuQmxvYiYmb2JqIGluc3RhbmNlb2YgQmxvYnx8Z2xvYmFsLkZpbGUmJm9iaiBpbnN0YW5jZW9mIEZpbGUpe3JldHVybiB0cnVlfWlmKGlzQXJyYXkob2JqKSl7Zm9yKHZhciBpPTA7aTxvYmoubGVuZ3RoO2krKyl7aWYoX2hhc0JpbmFyeShvYmpbaV0pKXtyZXR1cm4gdHJ1ZX19fWVsc2UgaWYob2JqJiZcIm9iamVjdFwiPT10eXBlb2Ygb2JqKXtpZihvYmoudG9KU09OKXtvYmo9b2JqLnRvSlNPTigpfWZvcih2YXIga2V5IGluIG9iail7aWYoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaixrZXkpJiZfaGFzQmluYXJ5KG9ialtrZXldKSl7cmV0dXJuIHRydWV9fX1yZXR1cm4gZmFsc2V9cmV0dXJuIF9oYXNCaW5hcnkoZGF0YSl9fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtpc2FycmF5OjM5fV0sMzk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPV9kZXJlcV8oMzIpfSx7fV0sNDA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBnbG9iYWw9X2RlcmVxXyhcImdsb2JhbFwiKTt0cnl7bW9kdWxlLmV4cG9ydHM9XCJYTUxIdHRwUmVxdWVzdFwiaW4gZ2xvYmFsJiZcIndpdGhDcmVkZW50aWFsc1wiaW4gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdH1jYXRjaChlcnIpe21vZHVsZS5leHBvcnRzPWZhbHNlfX0se2dsb2JhbDo0MX1dLDQxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpfSx7fV0sNDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBpbmRleE9mPVtdLmluZGV4T2Y7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYXJyLG9iail7aWYoaW5kZXhPZilyZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtmb3IodmFyIGk9MDtpPGFyci5sZW5ndGg7KytpKXtpZihhcnJbaV09PT1vYmopcmV0dXJuIGl9cmV0dXJuLTF9fSx7fV0sNDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBoYXM9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtleHBvcnRzLmtleXM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKG9iail7dmFyIGtleXM9W107Zm9yKHZhciBrZXkgaW4gb2JqKXtpZihoYXMuY2FsbChvYmosa2V5KSl7a2V5cy5wdXNoKGtleSl9fXJldHVybiBrZXlzfTtleHBvcnRzLnZhbHVlcz1mdW5jdGlvbihvYmope3ZhciB2YWxzPVtdO2Zvcih2YXIga2V5IGluIG9iail7aWYoaGFzLmNhbGwob2JqLGtleSkpe3ZhbHMucHVzaChvYmpba2V5XSl9fXJldHVybiB2YWxzfTtleHBvcnRzLm1lcmdlPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBrZXkgaW4gYil7aWYoaGFzLmNhbGwoYixrZXkpKXthW2tleV09YltrZXldfX1yZXR1cm4gYX07ZXhwb3J0cy5sZW5ndGg9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gZXhwb3J0cy5rZXlzKG9iaikubGVuZ3RofTtleHBvcnRzLmlzRW1wdHk9ZnVuY3Rpb24ob2JqKXtyZXR1cm4gMD09ZXhwb3J0cy5sZW5ndGgob2JqKX19LHt9XSw0NDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHJlPS9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO3ZhciBwYXJ0cz1bXCJzb3VyY2VcIixcInByb3RvY29sXCIsXCJhdXRob3JpdHlcIixcInVzZXJJbmZvXCIsXCJ1c2VyXCIsXCJwYXNzd29yZFwiLFwiaG9zdFwiLFwicG9ydFwiLFwicmVsYXRpdmVcIixcInBhdGhcIixcImRpcmVjdG9yeVwiLFwiZmlsZVwiLFwicXVlcnlcIixcImFuY2hvclwiXTttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBwYXJzZXVyaShzdHIpe3ZhciBtPXJlLmV4ZWMoc3RyfHxcIlwiKSx1cmk9e30saT0xNDt3aGlsZShpLS0pe3VyaVtwYXJ0c1tpXV09bVtpXXx8XCJcIn1yZXR1cm4gdXJpfX0se31dLDQ1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgaXNBcnJheT1fZGVyZXFfKFwiaXNhcnJheVwiKTt2YXIgaXNCdWY9X2RlcmVxXyhcIi4vaXMtYnVmZmVyXCIpO2V4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQ9ZnVuY3Rpb24ocGFja2V0KXt2YXIgYnVmZmVycz1bXTt2YXIgcGFja2V0RGF0YT1wYWNrZXQuZGF0YTtmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSl7aWYoIWRhdGEpcmV0dXJuIGRhdGE7aWYoaXNCdWYoZGF0YSkpe3ZhciBwbGFjZWhvbGRlcj17X3BsYWNlaG9sZGVyOnRydWUsbnVtOmJ1ZmZlcnMubGVuZ3RofTtidWZmZXJzLnB1c2goZGF0YSk7cmV0dXJuIHBsYWNlaG9sZGVyfWVsc2UgaWYoaXNBcnJheShkYXRhKSl7dmFyIG5ld0RhdGE9bmV3IEFycmF5KGRhdGEubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGRhdGEubGVuZ3RoO2krKyl7bmV3RGF0YVtpXT1fZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSl9cmV0dXJuIG5ld0RhdGF9ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZGF0YSYmIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpe3ZhciBuZXdEYXRhPXt9O2Zvcih2YXIga2V5IGluIGRhdGEpe25ld0RhdGFba2V5XT1fZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKX1yZXR1cm4gbmV3RGF0YX1yZXR1cm4gZGF0YX12YXIgcGFjaz1wYWNrZXQ7cGFjay5kYXRhPV9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtwYWNrLmF0dGFjaG1lbnRzPWJ1ZmZlcnMubGVuZ3RoO3JldHVybntwYWNrZXQ6cGFjayxidWZmZXJzOmJ1ZmZlcnN9fTtleHBvcnRzLnJlY29uc3RydWN0UGFja2V0PWZ1bmN0aW9uKHBhY2tldCxidWZmZXJzKXt2YXIgY3VyUGxhY2VIb2xkZXI9MDtmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSl7aWYoZGF0YSYmZGF0YS5fcGxhY2Vob2xkZXIpe3ZhciBidWY9YnVmZmVyc1tkYXRhLm51bV07cmV0dXJuIGJ1Zn1lbHNlIGlmKGlzQXJyYXkoZGF0YSkpe2Zvcih2YXIgaT0wO2k8ZGF0YS5sZW5ndGg7aSsrKXtkYXRhW2ldPV9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKX1yZXR1cm4gZGF0YX1lbHNlIGlmKGRhdGEmJlwib2JqZWN0XCI9PXR5cGVvZiBkYXRhKXtmb3IodmFyIGtleSBpbiBkYXRhKXtkYXRhW2tleV09X3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSl9cmV0dXJuIGRhdGF9cmV0dXJuIGRhdGF9cGFja2V0LmRhdGE9X3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtwYWNrZXQuYXR0YWNobWVudHM9dW5kZWZpbmVkO3JldHVybiBwYWNrZXR9O2V4cG9ydHMucmVtb3ZlQmxvYnM9ZnVuY3Rpb24oZGF0YSxjYWxsYmFjayl7ZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaixjdXJLZXksY29udGFpbmluZ09iamVjdCl7aWYoIW9iailyZXR1cm4gb2JqO2lmKGdsb2JhbC5CbG9iJiZvYmogaW5zdGFuY2VvZiBCbG9ifHxnbG9iYWwuRmlsZSYmb2JqIGluc3RhbmNlb2YgRmlsZSl7cGVuZGluZ0Jsb2JzKys7dmFyIGZpbGVSZWFkZXI9bmV3IEZpbGVSZWFkZXI7ZmlsZVJlYWRlci5vbmxvYWQ9ZnVuY3Rpb24oKXtpZihjb250YWluaW5nT2JqZWN0KXtjb250YWluaW5nT2JqZWN0W2N1cktleV09dGhpcy5yZXN1bHR9ZWxzZXtibG9ibGVzc0RhdGE9dGhpcy5yZXN1bHR9aWYoIS0tcGVuZGluZ0Jsb2JzKXtjYWxsYmFjayhibG9ibGVzc0RhdGEpfX07ZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopfWVsc2UgaWYoaXNBcnJheShvYmopKXtmb3IodmFyIGk9MDtpPG9iai5sZW5ndGg7aSsrKXtfcmVtb3ZlQmxvYnMob2JqW2ldLGksb2JqKX19ZWxzZSBpZihvYmomJlwib2JqZWN0XCI9PXR5cGVvZiBvYmomJiFpc0J1ZihvYmopKXtmb3IodmFyIGtleSBpbiBvYmope19yZW1vdmVCbG9icyhvYmpba2V5XSxrZXksb2JqKX19fXZhciBwZW5kaW5nQmxvYnM9MDt2YXIgYmxvYmxlc3NEYXRhPWRhdGE7X3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7aWYoIXBlbmRpbmdCbG9icyl7Y2FsbGJhY2soYmxvYmxlc3NEYXRhKX19fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtcIi4vaXMtYnVmZmVyXCI6NDcsaXNhcnJheTo0OH1dLDQ2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwic29ja2V0LmlvLXBhcnNlclwiKTt2YXIganNvbj1fZGVyZXFfKFwianNvbjNcIik7dmFyIGlzQXJyYXk9X2RlcmVxXyhcImlzYXJyYXlcIik7dmFyIEVtaXR0ZXI9X2RlcmVxXyhcImNvbXBvbmVudC1lbWl0dGVyXCIpO3ZhciBiaW5hcnk9X2RlcmVxXyhcIi4vYmluYXJ5XCIpO3ZhciBpc0J1Zj1fZGVyZXFfKFwiLi9pcy1idWZmZXJcIik7ZXhwb3J0cy5wcm90b2NvbD00O2V4cG9ydHMudHlwZXM9W1wiQ09OTkVDVFwiLFwiRElTQ09OTkVDVFwiLFwiRVZFTlRcIixcIkJJTkFSWV9FVkVOVFwiLFwiQUNLXCIsXCJCSU5BUllfQUNLXCIsXCJFUlJPUlwiXTtleHBvcnRzLkNPTk5FQ1Q9MDtleHBvcnRzLkRJU0NPTk5FQ1Q9MTtleHBvcnRzLkVWRU5UPTI7ZXhwb3J0cy5BQ0s9MztleHBvcnRzLkVSUk9SPTQ7ZXhwb3J0cy5CSU5BUllfRVZFTlQ9NTtleHBvcnRzLkJJTkFSWV9BQ0s9NjtleHBvcnRzLkVuY29kZXI9RW5jb2RlcjtleHBvcnRzLkRlY29kZXI9RGVjb2RlcjtmdW5jdGlvbiBFbmNvZGVyKCl7fUVuY29kZXIucHJvdG90eXBlLmVuY29kZT1mdW5jdGlvbihvYmosY2FsbGJhY2spe2RlYnVnKFwiZW5jb2RpbmcgcGFja2V0ICVqXCIsb2JqKTtpZihleHBvcnRzLkJJTkFSWV9FVkVOVD09b2JqLnR5cGV8fGV4cG9ydHMuQklOQVJZX0FDSz09b2JqLnR5cGUpe2VuY29kZUFzQmluYXJ5KG9iaixjYWxsYmFjayl9ZWxzZXt2YXIgZW5jb2Rpbmc9ZW5jb2RlQXNTdHJpbmcob2JqKTtjYWxsYmFjayhbZW5jb2RpbmddKX19O2Z1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iail7dmFyIHN0cj1cIlwiO3ZhciBuc3A9ZmFsc2U7c3RyKz1vYmoudHlwZTtpZihleHBvcnRzLkJJTkFSWV9FVkVOVD09b2JqLnR5cGV8fGV4cG9ydHMuQklOQVJZX0FDSz09b2JqLnR5cGUpe3N0cis9b2JqLmF0dGFjaG1lbnRzO3N0cis9XCItXCJ9aWYob2JqLm5zcCYmXCIvXCIhPW9iai5uc3Ape25zcD10cnVlO3N0cis9b2JqLm5zcH1pZihudWxsIT1vYmouaWQpe2lmKG5zcCl7c3RyKz1cIixcIjtuc3A9ZmFsc2V9c3RyKz1vYmouaWR9aWYobnVsbCE9b2JqLmRhdGEpe2lmKG5zcClzdHIrPVwiLFwiO3N0cis9anNvbi5zdHJpbmdpZnkob2JqLmRhdGEpfWRlYnVnKFwiZW5jb2RlZCAlaiBhcyAlc1wiLG9iaixzdHIpO3JldHVybiBzdHJ9ZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLGNhbGxiYWNrKXtmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSl7dmFyIGRlY29uc3RydWN0aW9uPWJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO3ZhciBwYWNrPWVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7dmFyIGJ1ZmZlcnM9ZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztidWZmZXJzLnVuc2hpZnQocGFjayk7Y2FsbGJhY2soYnVmZmVycyl9YmluYXJ5LnJlbW92ZUJsb2JzKG9iaix3cml0ZUVuY29kaW5nKX1mdW5jdGlvbiBEZWNvZGVyKCl7dGhpcy5yZWNvbnN0cnVjdG9yPW51bGx9RW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7RGVjb2Rlci5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKG9iail7dmFyIHBhY2tldDtpZihcInN0cmluZ1wiPT10eXBlb2Ygb2JqKXtwYWNrZXQ9ZGVjb2RlU3RyaW5nKG9iaik7aWYoZXhwb3J0cy5CSU5BUllfRVZFTlQ9PXBhY2tldC50eXBlfHxleHBvcnRzLkJJTkFSWV9BQ0s9PXBhY2tldC50eXBlKXt0aGlzLnJlY29uc3RydWN0b3I9bmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtpZih0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzPT09MCl7dGhpcy5lbWl0KFwiZGVjb2RlZFwiLHBhY2tldCl9fWVsc2V7dGhpcy5lbWl0KFwiZGVjb2RlZFwiLHBhY2tldCl9fWVsc2UgaWYoaXNCdWYob2JqKXx8b2JqLmJhc2U2NCl7aWYoIXRoaXMucmVjb25zdHJ1Y3Rvcil7dGhyb3cgbmV3IEVycm9yKFwiZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0XCIpfWVsc2V7cGFja2V0PXRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO2lmKHBhY2tldCl7dGhpcy5yZWNvbnN0cnVjdG9yPW51bGw7dGhpcy5lbWl0KFwiZGVjb2RlZFwiLHBhY2tldCl9fX1lbHNle3Rocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIrb2JqKX19O2Z1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpe3ZhciBwPXt9O3ZhciBpPTA7cC50eXBlPU51bWJlcihzdHIuY2hhckF0KDApKTtpZihudWxsPT1leHBvcnRzLnR5cGVzW3AudHlwZV0pcmV0dXJuIGVycm9yKCk7aWYoZXhwb3J0cy5CSU5BUllfRVZFTlQ9PXAudHlwZXx8ZXhwb3J0cy5CSU5BUllfQUNLPT1wLnR5cGUpe3ZhciBidWY9XCJcIjt3aGlsZShzdHIuY2hhckF0KCsraSkhPVwiLVwiKXtidWYrPXN0ci5jaGFyQXQoaSk7aWYoaSsxPT1zdHIubGVuZ3RoKWJyZWFrfWlmKGJ1ZiE9TnVtYmVyKGJ1Zil8fHN0ci5jaGFyQXQoaSkhPVwiLVwiKXt0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGF0dGFjaG1lbnRzXCIpfXAuYXR0YWNobWVudHM9TnVtYmVyKGJ1Zil9aWYoXCIvXCI9PXN0ci5jaGFyQXQoaSsxKSl7cC5uc3A9XCJcIjt3aGlsZSgrK2kpe3ZhciBjPXN0ci5jaGFyQXQoaSk7aWYoXCIsXCI9PWMpYnJlYWs7cC5uc3ArPWM7aWYoaSsxPT1zdHIubGVuZ3RoKWJyZWFrfX1lbHNle3AubnNwPVwiL1wifXZhciBuZXh0PXN0ci5jaGFyQXQoaSsxKTtpZihcIlwiIT09bmV4dCYmTnVtYmVyKG5leHQpPT1uZXh0KXtwLmlkPVwiXCI7d2hpbGUoKytpKXt2YXIgYz1zdHIuY2hhckF0KGkpO2lmKG51bGw9PWN8fE51bWJlcihjKSE9Yyl7LS1pO2JyZWFrfXAuaWQrPXN0ci5jaGFyQXQoaSk7aWYoaSsxPT1zdHIubGVuZ3RoKWJyZWFrfXAuaWQ9TnVtYmVyKHAuaWQpfWlmKHN0ci5jaGFyQXQoKytpKSl7dHJ5e3AuZGF0YT1qc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpfWNhdGNoKGUpe3JldHVybiBlcnJvcigpfX1kZWJ1ZyhcImRlY29kZWQgJXMgYXMgJWpcIixzdHIscCk7cmV0dXJuIHB9RGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe2lmKHRoaXMucmVjb25zdHJ1Y3Rvcil7dGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKX19O2Z1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KXt0aGlzLnJlY29uUGFjaz1wYWNrZXQ7dGhpcy5idWZmZXJzPVtdfUJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhPWZ1bmN0aW9uKGJpbkRhdGEpe3RoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO2lmKHRoaXMuYnVmZmVycy5sZW5ndGg9PXRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKXt2YXIgcGFja2V0PWJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjayx0aGlzLmJ1ZmZlcnMpO3RoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO3JldHVybiBwYWNrZXR9cmV0dXJuIG51bGx9O0JpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb249ZnVuY3Rpb24oKXt0aGlzLnJlY29uUGFjaz1udWxsO3RoaXMuYnVmZmVycz1bXX07ZnVuY3Rpb24gZXJyb3IoZGF0YSl7cmV0dXJue3R5cGU6ZXhwb3J0cy5FUlJPUixkYXRhOlwicGFyc2VyIGVycm9yXCJ9fX0se1wiLi9iaW5hcnlcIjo0NSxcIi4vaXMtYnVmZmVyXCI6NDcsXCJjb21wb25lbnQtZW1pdHRlclwiOjksZGVidWc6MTAsaXNhcnJheTo0OCxqc29uMzo0OX1dLDQ3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXttb2R1bGUuZXhwb3J0cz1pc0J1ZjtmdW5jdGlvbiBpc0J1ZihvYmope3JldHVybiBnbG9iYWwuQnVmZmVyJiZnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iail8fGdsb2JhbC5BcnJheUJ1ZmZlciYmb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ9fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHt9XSw0ODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9X2RlcmVxXygzMil9LHt9XSw0OTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKHdpbmRvdyl7dmFyIGdldENsYXNzPXt9LnRvU3RyaW5nLGlzUHJvcGVydHksZm9yRWFjaCx1bmRlZjt2YXIgaXNMb2FkZXI9dHlwZW9mIGRlZmluZT09PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZDt2YXIgbmF0aXZlSlNPTj10eXBlb2YgSlNPTj09XCJvYmplY3RcIiYmSlNPTjt2YXIgSlNPTjM9dHlwZW9mIGV4cG9ydHM9PVwib2JqZWN0XCImJmV4cG9ydHMmJiFleHBvcnRzLm5vZGVUeXBlJiZleHBvcnRzO2lmKEpTT04zJiZuYXRpdmVKU09OKXtKU09OMy5zdHJpbmdpZnk9bmF0aXZlSlNPTi5zdHJpbmdpZnk7SlNPTjMucGFyc2U9bmF0aXZlSlNPTi5wYXJzZX1lbHNle0pTT04zPXdpbmRvdy5KU09OPW5hdGl2ZUpTT058fHt9fXZhciBpc0V4dGVuZGVkPW5ldyBEYXRlKC0weGM3ODJiNWI4MDBjZWMpO3RyeXtpc0V4dGVuZGVkPWlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKT09LTEwOTI1MiYmaXNFeHRlbmRlZC5nZXRVVENNb250aCgpPT09MCYmaXNFeHRlbmRlZC5nZXRVVENEYXRlKCk9PT0xJiZpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCk9PTEwJiZpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKT09MzcmJmlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpPT02JiZpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpPT03MDh9Y2F0Y2goZXhjZXB0aW9uKXt9ZnVuY3Rpb24gaGFzKG5hbWUpe2lmKGhhc1tuYW1lXSE9PXVuZGVmKXtyZXR1cm4gaGFzW25hbWVdfXZhciBpc1N1cHBvcnRlZDtpZihuYW1lPT1cImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKXtpc1N1cHBvcnRlZD1cImFcIlswXSE9XCJhXCJ9ZWxzZSBpZihuYW1lPT1cImpzb25cIil7aXNTdXBwb3J0ZWQ9aGFzKFwianNvbi1zdHJpbmdpZnlcIikmJmhhcyhcImpzb24tcGFyc2VcIil9ZWxzZXt2YXIgdmFsdWUsc2VyaWFsaXplZD0ne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztpZihuYW1lPT1cImpzb24tc3RyaW5naWZ5XCIpe3ZhciBzdHJpbmdpZnk9SlNPTjMuc3RyaW5naWZ5LHN0cmluZ2lmeVN1cHBvcnRlZD10eXBlb2Ygc3RyaW5naWZ5PT1cImZ1bmN0aW9uXCImJmlzRXh0ZW5kZWQ7aWYoc3RyaW5naWZ5U3VwcG9ydGVkKXsodmFsdWU9ZnVuY3Rpb24oKXtyZXR1cm4gMX0pLnRvSlNPTj12YWx1ZTt0cnl7c3RyaW5naWZ5U3VwcG9ydGVkPXN0cmluZ2lmeSgwKT09PVwiMFwiJiZzdHJpbmdpZnkobmV3IE51bWJlcik9PT1cIjBcIiYmc3RyaW5naWZ5KG5ldyBTdHJpbmcpPT0nXCJcIicmJnN0cmluZ2lmeShnZXRDbGFzcyk9PT11bmRlZiYmc3RyaW5naWZ5KHVuZGVmKT09PXVuZGVmJiZzdHJpbmdpZnkoKT09PXVuZGVmJiZzdHJpbmdpZnkodmFsdWUpPT09XCIxXCImJnN0cmluZ2lmeShbdmFsdWVdKT09XCJbMV1cIiYmc3RyaW5naWZ5KFt1bmRlZl0pPT1cIltudWxsXVwiJiZzdHJpbmdpZnkobnVsbCk9PVwibnVsbFwiJiZzdHJpbmdpZnkoW3VuZGVmLGdldENsYXNzLG51bGxdKT09XCJbbnVsbCxudWxsLG51bGxdXCImJnN0cmluZ2lmeSh7YTpbdmFsdWUsdHJ1ZSxmYWxzZSxudWxsLFwiXFx4MDBcXGJcXG5cXGZcXHIgXCJdfSk9PXNlcmlhbGl6ZWQmJnN0cmluZ2lmeShudWxsLHZhbHVlKT09PVwiMVwiJiZzdHJpbmdpZnkoWzEsMl0sbnVsbCwxKT09XCJbXFxuIDEsXFxuIDJcXG5dXCImJnN0cmluZ2lmeShuZXcgRGF0ZSgtODY0ZTEzKSk9PSdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyYmc3RyaW5naWZ5KG5ldyBEYXRlKDg2NGUxMykpPT0nXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicmJnN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKT09J1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInJiZzdHJpbmdpZnkobmV3IERhdGUoLTEpKT09J1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInfWNhdGNoKGV4Y2VwdGlvbil7c3RyaW5naWZ5U3VwcG9ydGVkPWZhbHNlfX1pc1N1cHBvcnRlZD1zdHJpbmdpZnlTdXBwb3J0ZWR9aWYobmFtZT09XCJqc29uLXBhcnNlXCIpe3ZhciBwYXJzZT1KU09OMy5wYXJzZTtpZih0eXBlb2YgcGFyc2U9PVwiZnVuY3Rpb25cIil7dHJ5e2lmKHBhcnNlKFwiMFwiKT09PTAmJiFwYXJzZShmYWxzZSkpe3ZhbHVlPXBhcnNlKHNlcmlhbGl6ZWQpO3ZhciBwYXJzZVN1cHBvcnRlZD12YWx1ZVtcImFcIl0ubGVuZ3RoPT01JiZ2YWx1ZVtcImFcIl1bMF09PT0xO2lmKHBhcnNlU3VwcG9ydGVkKXt0cnl7cGFyc2VTdXBwb3J0ZWQ9IXBhcnNlKCdcIiAgXCInKX1jYXRjaChleGNlcHRpb24pe31pZihwYXJzZVN1cHBvcnRlZCl7dHJ5e3BhcnNlU3VwcG9ydGVkPXBhcnNlKFwiMDFcIikhPT0xfWNhdGNoKGV4Y2VwdGlvbil7fX1pZihwYXJzZVN1cHBvcnRlZCl7dHJ5e3BhcnNlU3VwcG9ydGVkPXBhcnNlKFwiMS5cIikhPT0xfWNhdGNoKGV4Y2VwdGlvbil7fX19fX1jYXRjaChleGNlcHRpb24pe3BhcnNlU3VwcG9ydGVkPWZhbHNlfX1pc1N1cHBvcnRlZD1wYXJzZVN1cHBvcnRlZH19cmV0dXJuIGhhc1tuYW1lXT0hIWlzU3VwcG9ydGVkfWlmKCFoYXMoXCJqc29uXCIpKXt2YXIgZnVuY3Rpb25DbGFzcz1cIltvYmplY3QgRnVuY3Rpb25dXCI7dmFyIGRhdGVDbGFzcz1cIltvYmplY3QgRGF0ZV1cIjt2YXIgbnVtYmVyQ2xhc3M9XCJbb2JqZWN0IE51bWJlcl1cIjt2YXIgc3RyaW5nQ2xhc3M9XCJbb2JqZWN0IFN0cmluZ11cIjt2YXIgYXJyYXlDbGFzcz1cIltvYmplY3QgQXJyYXldXCI7dmFyIGJvb2xlYW5DbGFzcz1cIltvYmplY3QgQm9vbGVhbl1cIjt2YXIgY2hhckluZGV4QnVnZ3k9aGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO2lmKCFpc0V4dGVuZGVkKXt2YXIgZmxvb3I9TWF0aC5mbG9vcjt2YXIgTW9udGhzPVswLDMxLDU5LDkwLDEyMCwxNTEsMTgxLDIxMiwyNDMsMjczLDMwNCwzMzRdO3ZhciBnZXREYXk9ZnVuY3Rpb24oeWVhcixtb250aCl7cmV0dXJuIE1vbnRoc1ttb250aF0rMzY1Kih5ZWFyLTE5NzApK2Zsb29yKCh5ZWFyLTE5NjkrKG1vbnRoPSsobW9udGg+MSkpKS80KS1mbG9vcigoeWVhci0xOTAxK21vbnRoKS8xMDApK2Zsb29yKCh5ZWFyLTE2MDErbW9udGgpLzQwMCl9fWlmKCEoaXNQcm9wZXJ0eT17fS5oYXNPd25Qcm9wZXJ0eSkpe2lzUHJvcGVydHk9ZnVuY3Rpb24ocHJvcGVydHkpe3ZhciBtZW1iZXJzPXt9LGNvbnN0cnVjdG9yO2lmKChtZW1iZXJzLl9fcHJvdG9fXz1udWxsLG1lbWJlcnMuX19wcm90b19fPXt0b1N0cmluZzoxfSxtZW1iZXJzKS50b1N0cmluZyE9Z2V0Q2xhc3Mpe2lzUHJvcGVydHk9ZnVuY3Rpb24ocHJvcGVydHkpe3ZhciBvcmlnaW5hbD10aGlzLl9fcHJvdG9fXyxyZXN1bHQ9cHJvcGVydHkgaW4odGhpcy5fX3Byb3RvX189bnVsbCx0aGlzKTt0aGlzLl9fcHJvdG9fXz1vcmlnaW5hbDtyZXR1cm4gcmVzdWx0fX1lbHNle2NvbnN0cnVjdG9yPW1lbWJlcnMuY29uc3RydWN0b3I7aXNQcm9wZXJ0eT1mdW5jdGlvbihwcm9wZXJ0eSl7dmFyIHBhcmVudD0odGhpcy5jb25zdHJ1Y3Rvcnx8Y29uc3RydWN0b3IpLnByb3RvdHlwZTtyZXR1cm4gcHJvcGVydHkgaW4gdGhpcyYmIShwcm9wZXJ0eSBpbiBwYXJlbnQmJnRoaXNbcHJvcGVydHldPT09cGFyZW50W3Byb3BlcnR5XSl9fW1lbWJlcnM9bnVsbDtyZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMscHJvcGVydHkpfX12YXIgUHJpbWl0aXZlVHlwZXM9e1wiYm9vbGVhblwiOjEsbnVtYmVyOjEsc3RyaW5nOjEsdW5kZWZpbmVkOjF9O3ZhciBpc0hvc3RUeXBlPWZ1bmN0aW9uKG9iamVjdCxwcm9wZXJ0eSl7dmFyIHR5cGU9dHlwZW9mIG9iamVjdFtwcm9wZXJ0eV07cmV0dXJuIHR5cGU9PVwib2JqZWN0XCI/ISFvYmplY3RbcHJvcGVydHldOiFQcmltaXRpdmVUeXBlc1t0eXBlXX07Zm9yRWFjaD1mdW5jdGlvbihvYmplY3QsY2FsbGJhY2spe3ZhciBzaXplPTAsUHJvcGVydGllcyxtZW1iZXJzLHByb3BlcnR5OyhQcm9wZXJ0aWVzPWZ1bmN0aW9uKCl7dGhpcy52YWx1ZU9mPTB9KS5wcm90b3R5cGUudmFsdWVPZj0wO21lbWJlcnM9bmV3IFByb3BlcnRpZXM7Zm9yKHByb3BlcnR5IGluIG1lbWJlcnMpe2lmKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLHByb3BlcnR5KSl7c2l6ZSsrfX1Qcm9wZXJ0aWVzPW1lbWJlcnM9bnVsbDtpZighc2l6ZSl7bWVtYmVycz1bXCJ2YWx1ZU9mXCIsXCJ0b1N0cmluZ1wiLFwidG9Mb2NhbGVTdHJpbmdcIixcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXCJpc1Byb3RvdHlwZU9mXCIsXCJoYXNPd25Qcm9wZXJ0eVwiLFwiY29uc3RydWN0b3JcIl07Zm9yRWFjaD1mdW5jdGlvbihvYmplY3QsY2FsbGJhY2spe3ZhciBpc0Z1bmN0aW9uPWdldENsYXNzLmNhbGwob2JqZWN0KT09ZnVuY3Rpb25DbGFzcyxwcm9wZXJ0eSxsZW5ndGg7dmFyIGhhc1Byb3BlcnR5PSFpc0Z1bmN0aW9uJiZ0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yIT1cImZ1bmN0aW9uXCImJmlzSG9zdFR5cGUob2JqZWN0LFwiaGFzT3duUHJvcGVydHlcIik/b2JqZWN0Lmhhc093blByb3BlcnR5OmlzUHJvcGVydHk7Zm9yKHByb3BlcnR5IGluIG9iamVjdCl7aWYoIShpc0Z1bmN0aW9uJiZwcm9wZXJ0eT09XCJwcm90b3R5cGVcIikmJmhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LHByb3BlcnR5KSl7Y2FsbGJhY2socHJvcGVydHkpfX1mb3IobGVuZ3RoPW1lbWJlcnMubGVuZ3RoO3Byb3BlcnR5PW1lbWJlcnNbLS1sZW5ndGhdO2hhc1Byb3BlcnR5LmNhbGwob2JqZWN0LHByb3BlcnR5KSYmY2FsbGJhY2socHJvcGVydHkpKTt9fWVsc2UgaWYoc2l6ZT09Mil7Zm9yRWFjaD1mdW5jdGlvbihvYmplY3QsY2FsbGJhY2spe3ZhciBtZW1iZXJzPXt9LGlzRnVuY3Rpb249Z2V0Q2xhc3MuY2FsbChvYmplY3QpPT1mdW5jdGlvbkNsYXNzLHByb3BlcnR5O2Zvcihwcm9wZXJ0eSBpbiBvYmplY3Qpe2lmKCEoaXNGdW5jdGlvbiYmcHJvcGVydHk9PVwicHJvdG90eXBlXCIpJiYhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMscHJvcGVydHkpJiYobWVtYmVyc1twcm9wZXJ0eV09MSkmJmlzUHJvcGVydHkuY2FsbChvYmplY3QscHJvcGVydHkpKXtjYWxsYmFjayhwcm9wZXJ0eSl9fX19ZWxzZXtmb3JFYWNoPWZ1bmN0aW9uKG9iamVjdCxjYWxsYmFjayl7dmFyIGlzRnVuY3Rpb249Z2V0Q2xhc3MuY2FsbChvYmplY3QpPT1mdW5jdGlvbkNsYXNzLHByb3BlcnR5LGlzQ29uc3RydWN0b3I7Zm9yKHByb3BlcnR5IGluIG9iamVjdCl7aWYoIShpc0Z1bmN0aW9uJiZwcm9wZXJ0eT09XCJwcm90b3R5cGVcIikmJmlzUHJvcGVydHkuY2FsbChvYmplY3QscHJvcGVydHkpJiYhKGlzQ29uc3RydWN0b3I9cHJvcGVydHk9PT1cImNvbnN0cnVjdG9yXCIpKXtjYWxsYmFjayhwcm9wZXJ0eSl9fWlmKGlzQ29uc3RydWN0b3J8fGlzUHJvcGVydHkuY2FsbChvYmplY3QscHJvcGVydHk9XCJjb25zdHJ1Y3RvclwiKSl7Y2FsbGJhY2socHJvcGVydHkpfX19cmV0dXJuIGZvckVhY2gob2JqZWN0LGNhbGxiYWNrKX07aWYoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKXt2YXIgRXNjYXBlcz17OTI6XCJcXFxcXFxcXFwiLDM0OidcXFxcXCInLDg6XCJcXFxcYlwiLDEyOlwiXFxcXGZcIiwxMDpcIlxcXFxuXCIsMTM6XCJcXFxcclwiLDk6XCJcXFxcdFwifTt2YXIgbGVhZGluZ1plcm9lcz1cIjAwMDAwMFwiO3ZhciB0b1BhZGRlZFN0cmluZz1mdW5jdGlvbih3aWR0aCx2YWx1ZSl7cmV0dXJuKGxlYWRpbmdaZXJvZXMrKHZhbHVlfHwwKSkuc2xpY2UoLXdpZHRoKX07dmFyIHVuaWNvZGVQcmVmaXg9XCJcXFxcdTAwXCI7dmFyIHF1b3RlPWZ1bmN0aW9uKHZhbHVlKXt2YXIgcmVzdWx0PSdcIicsaW5kZXg9MCxsZW5ndGg9dmFsdWUubGVuZ3RoLGlzTGFyZ2U9bGVuZ3RoPjEwJiZjaGFySW5kZXhCdWdneSxzeW1ib2xzO2lmKGlzTGFyZ2Upe3N5bWJvbHM9dmFsdWUuc3BsaXQoXCJcIil9Zm9yKDtpbmRleDxsZW5ndGg7aW5kZXgrKyl7dmFyIGNoYXJDb2RlPXZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO3N3aXRjaChjaGFyQ29kZSl7Y2FzZSA4OmNhc2UgOTpjYXNlIDEwOmNhc2UgMTI6Y2FzZSAxMzpjYXNlIDM0OmNhc2UgOTI6cmVzdWx0Kz1Fc2NhcGVzW2NoYXJDb2RlXTticmVhaztkZWZhdWx0OmlmKGNoYXJDb2RlPDMyKXtyZXN1bHQrPXVuaWNvZGVQcmVmaXgrdG9QYWRkZWRTdHJpbmcoMixjaGFyQ29kZS50b1N0cmluZygxNikpO2JyZWFrfXJlc3VsdCs9aXNMYXJnZT9zeW1ib2xzW2luZGV4XTpjaGFySW5kZXhCdWdneT92YWx1ZS5jaGFyQXQoaW5kZXgpOnZhbHVlW2luZGV4XX19cmV0dXJuIHJlc3VsdCsnXCInfTt2YXIgc2VyaWFsaXplPWZ1bmN0aW9uKHByb3BlcnR5LG9iamVjdCxjYWxsYmFjayxwcm9wZXJ0aWVzLHdoaXRlc3BhY2UsaW5kZW50YXRpb24sc3RhY2spe3ZhciB2YWx1ZSxjbGFzc05hbWUseWVhcixtb250aCxkYXRlLHRpbWUsaG91cnMsbWludXRlcyxzZWNvbmRzLG1pbGxpc2Vjb25kcyxyZXN1bHRzLGVsZW1lbnQsaW5kZXgsbGVuZ3RoLHByZWZpeCxyZXN1bHQ7dHJ5e3ZhbHVlPW9iamVjdFtwcm9wZXJ0eV19Y2F0Y2goZXhjZXB0aW9uKXt9aWYodHlwZW9mIHZhbHVlPT1cIm9iamVjdFwiJiZ2YWx1ZSl7Y2xhc3NOYW1lPWdldENsYXNzLmNhbGwodmFsdWUpO2lmKGNsYXNzTmFtZT09ZGF0ZUNsYXNzJiYhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLFwidG9KU09OXCIpKXtpZih2YWx1ZT4tMS8wJiZ2YWx1ZTwxLzApe2lmKGdldERheSl7ZGF0ZT1mbG9vcih2YWx1ZS84NjRlNSk7Zm9yKHllYXI9Zmxvb3IoZGF0ZS8zNjUuMjQyNSkrMTk3MC0xO2dldERheSh5ZWFyKzEsMCk8PWRhdGU7eWVhcisrKTtmb3IobW9udGg9Zmxvb3IoKGRhdGUtZ2V0RGF5KHllYXIsMCkpLzMwLjQyKTtnZXREYXkoeWVhcixtb250aCsxKTw9ZGF0ZTttb250aCsrKTtkYXRlPTErZGF0ZS1nZXREYXkoeWVhcixtb250aCk7dGltZT0odmFsdWUlODY0ZTUrODY0ZTUpJTg2NGU1O2hvdXJzPWZsb29yKHRpbWUvMzZlNSklMjQ7bWludXRlcz1mbG9vcih0aW1lLzZlNCklNjA7c2Vjb25kcz1mbG9vcih0aW1lLzFlMyklNjA7bWlsbGlzZWNvbmRzPXRpbWUlMWUzfWVsc2V7eWVhcj12YWx1ZS5nZXRVVENGdWxsWWVhcigpO21vbnRoPXZhbHVlLmdldFVUQ01vbnRoKCk7ZGF0ZT12YWx1ZS5nZXRVVENEYXRlKCk7aG91cnM9dmFsdWUuZ2V0VVRDSG91cnMoKTttaW51dGVzPXZhbHVlLmdldFVUQ01pbnV0ZXMoKTtzZWNvbmRzPXZhbHVlLmdldFVUQ1NlY29uZHMoKTttaWxsaXNlY29uZHM9dmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCl9dmFsdWU9KHllYXI8PTB8fHllYXI+PTFlND8oeWVhcjwwP1wiLVwiOlwiK1wiKSt0b1BhZGRlZFN0cmluZyg2LHllYXI8MD8teWVhcjp5ZWFyKTp0b1BhZGRlZFN0cmluZyg0LHllYXIpKStcIi1cIit0b1BhZGRlZFN0cmluZygyLG1vbnRoKzEpK1wiLVwiK3RvUGFkZGVkU3RyaW5nKDIsZGF0ZSkrXCJUXCIrdG9QYWRkZWRTdHJpbmcoMixob3VycykrXCI6XCIrdG9QYWRkZWRTdHJpbmcoMixtaW51dGVzKStcIjpcIit0b1BhZGRlZFN0cmluZygyLHNlY29uZHMpK1wiLlwiK3RvUGFkZGVkU3RyaW5nKDMsbWlsbGlzZWNvbmRzKStcIlpcIn1lbHNle3ZhbHVlPW51bGx9fWVsc2UgaWYodHlwZW9mIHZhbHVlLnRvSlNPTj09XCJmdW5jdGlvblwiJiYoY2xhc3NOYW1lIT1udW1iZXJDbGFzcyYmY2xhc3NOYW1lIT1zdHJpbmdDbGFzcyYmY2xhc3NOYW1lIT1hcnJheUNsYXNzfHxpc1Byb3BlcnR5LmNhbGwodmFsdWUsXCJ0b0pTT05cIikpKXt2YWx1ZT12YWx1ZS50b0pTT04ocHJvcGVydHkpfX1pZihjYWxsYmFjayl7dmFsdWU9Y2FsbGJhY2suY2FsbChvYmplY3QscHJvcGVydHksdmFsdWUpfWlmKHZhbHVlPT09bnVsbCl7cmV0dXJuXCJudWxsXCJ9Y2xhc3NOYW1lPWdldENsYXNzLmNhbGwodmFsdWUpO2lmKGNsYXNzTmFtZT09Ym9vbGVhbkNsYXNzKXtyZXR1cm5cIlwiK3ZhbHVlfWVsc2UgaWYoY2xhc3NOYW1lPT1udW1iZXJDbGFzcyl7cmV0dXJuIHZhbHVlPi0xLzAmJnZhbHVlPDEvMD9cIlwiK3ZhbHVlOlwibnVsbFwifWVsc2UgaWYoY2xhc3NOYW1lPT1zdHJpbmdDbGFzcyl7cmV0dXJuIHF1b3RlKFwiXCIrdmFsdWUpfWlmKHR5cGVvZiB2YWx1ZT09XCJvYmplY3RcIil7Zm9yKGxlbmd0aD1zdGFjay5sZW5ndGg7bGVuZ3RoLS07KXtpZihzdGFja1tsZW5ndGhdPT09dmFsdWUpe3Rocm93IFR5cGVFcnJvcigpfX1zdGFjay5wdXNoKHZhbHVlKTtyZXN1bHRzPVtdO3ByZWZpeD1pbmRlbnRhdGlvbjtpbmRlbnRhdGlvbis9d2hpdGVzcGFjZTtpZihjbGFzc05hbWU9PWFycmF5Q2xhc3Mpe2ZvcihpbmRleD0wLGxlbmd0aD12YWx1ZS5sZW5ndGg7aW5kZXg8bGVuZ3RoO2luZGV4Kyspe2VsZW1lbnQ9c2VyaWFsaXplKGluZGV4LHZhbHVlLGNhbGxiYWNrLHByb3BlcnRpZXMsd2hpdGVzcGFjZSxpbmRlbnRhdGlvbixzdGFjayk7cmVzdWx0cy5wdXNoKGVsZW1lbnQ9PT11bmRlZj9cIm51bGxcIjplbGVtZW50KX1yZXN1bHQ9cmVzdWx0cy5sZW5ndGg/d2hpdGVzcGFjZT9cIltcXG5cIitpbmRlbnRhdGlvbityZXN1bHRzLmpvaW4oXCIsXFxuXCIraW5kZW50YXRpb24pK1wiXFxuXCIrcHJlZml4K1wiXVwiOlwiW1wiK3Jlc3VsdHMuam9pbihcIixcIikrXCJdXCI6XCJbXVwifWVsc2V7Zm9yRWFjaChwcm9wZXJ0aWVzfHx2YWx1ZSxmdW5jdGlvbihwcm9wZXJ0eSl7dmFyIGVsZW1lbnQ9c2VyaWFsaXplKHByb3BlcnR5LHZhbHVlLGNhbGxiYWNrLHByb3BlcnRpZXMsd2hpdGVzcGFjZSxpbmRlbnRhdGlvbixzdGFjayk7aWYoZWxlbWVudCE9PXVuZGVmKXtyZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpK1wiOlwiKyh3aGl0ZXNwYWNlP1wiIFwiOlwiXCIpK2VsZW1lbnQpfX0pO3Jlc3VsdD1yZXN1bHRzLmxlbmd0aD93aGl0ZXNwYWNlP1wie1xcblwiK2luZGVudGF0aW9uK3Jlc3VsdHMuam9pbihcIixcXG5cIitpbmRlbnRhdGlvbikrXCJcXG5cIitwcmVmaXgrXCJ9XCI6XCJ7XCIrcmVzdWx0cy5qb2luKFwiLFwiKStcIn1cIjpcInt9XCJ9c3RhY2sucG9wKCk7cmV0dXJuIHJlc3VsdH19O0pTT04zLnN0cmluZ2lmeT1mdW5jdGlvbihzb3VyY2UsZmlsdGVyLHdpZHRoKXt2YXIgd2hpdGVzcGFjZSxjYWxsYmFjayxwcm9wZXJ0aWVzLGNsYXNzTmFtZTtpZih0eXBlb2YgZmlsdGVyPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBmaWx0ZXI9PVwib2JqZWN0XCImJmZpbHRlcil7aWYoKGNsYXNzTmFtZT1nZXRDbGFzcy5jYWxsKGZpbHRlcikpPT1mdW5jdGlvbkNsYXNzKXtjYWxsYmFjaz1maWx0ZXJ9ZWxzZSBpZihjbGFzc05hbWU9PWFycmF5Q2xhc3Mpe3Byb3BlcnRpZXM9e307Zm9yKHZhciBpbmRleD0wLGxlbmd0aD1maWx0ZXIubGVuZ3RoLHZhbHVlO2luZGV4PGxlbmd0aDt2YWx1ZT1maWx0ZXJbaW5kZXgrK10sKGNsYXNzTmFtZT1nZXRDbGFzcy5jYWxsKHZhbHVlKSxjbGFzc05hbWU9PXN0cmluZ0NsYXNzfHxjbGFzc05hbWU9PW51bWJlckNsYXNzKSYmKHByb3BlcnRpZXNbdmFsdWVdPTEpKTt9fWlmKHdpZHRoKXtpZigoY2xhc3NOYW1lPWdldENsYXNzLmNhbGwod2lkdGgpKT09bnVtYmVyQ2xhc3Mpe2lmKCh3aWR0aC09d2lkdGglMSk+MCl7Zm9yKHdoaXRlc3BhY2U9XCJcIix3aWR0aD4xMCYmKHdpZHRoPTEwKTt3aGl0ZXNwYWNlLmxlbmd0aDx3aWR0aDt3aGl0ZXNwYWNlKz1cIiBcIik7fX1lbHNlIGlmKGNsYXNzTmFtZT09c3RyaW5nQ2xhc3Mpe3doaXRlc3BhY2U9d2lkdGgubGVuZ3RoPD0xMD93aWR0aDp3aWR0aC5zbGljZSgwLDEwKX19cmV0dXJuIHNlcmlhbGl6ZShcIlwiLCh2YWx1ZT17fSx2YWx1ZVtcIlwiXT1zb3VyY2UsdmFsdWUpLGNhbGxiYWNrLHByb3BlcnRpZXMsd2hpdGVzcGFjZSxcIlwiLFtdKX19aWYoIWhhcyhcImpzb24tcGFyc2VcIikpe3ZhciBmcm9tQ2hhckNvZGU9U3RyaW5nLmZyb21DaGFyQ29kZTt2YXIgVW5lc2NhcGVzPXs5MjpcIlxcXFxcIiwzNDonXCInLDQ3OlwiL1wiLDk4OlwiXFxiXCIsMTE2OlwiICBcIiwxMTA6XCJcXG5cIiwxMDI6XCJcXGZcIiwxMTQ6XCJcXHJcIn07dmFyIEluZGV4LFNvdXJjZTt2YXIgYWJvcnQ9ZnVuY3Rpb24oKXtJbmRleD1Tb3VyY2U9bnVsbDt0aHJvdyBTeW50YXhFcnJvcigpfTt2YXIgbGV4PWZ1bmN0aW9uKCl7dmFyIHNvdXJjZT1Tb3VyY2UsbGVuZ3RoPXNvdXJjZS5sZW5ndGgsdmFsdWUsYmVnaW4scG9zaXRpb24saXNTaWduZWQsY2hhckNvZGU7d2hpbGUoSW5kZXg8bGVuZ3RoKXtjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChJbmRleCk7c3dpdGNoKGNoYXJDb2RlKXtjYXNlIDk6Y2FzZSAxMDpjYXNlIDEzOmNhc2UgMzI6SW5kZXgrKzticmVhaztjYXNlIDEyMzpjYXNlIDEyNTpjYXNlIDkxOmNhc2UgOTM6Y2FzZSA1ODpjYXNlIDQ0OnZhbHVlPWNoYXJJbmRleEJ1Z2d5P3NvdXJjZS5jaGFyQXQoSW5kZXgpOnNvdXJjZVtJbmRleF07SW5kZXgrKztyZXR1cm4gdmFsdWU7Y2FzZSAzNDpmb3IodmFsdWU9XCJAXCIsSW5kZXgrKztJbmRleDxsZW5ndGg7KXtjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChJbmRleCk7aWYoY2hhckNvZGU8MzIpe2Fib3J0KCl9ZWxzZSBpZihjaGFyQ29kZT09OTIpe2NoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO3N3aXRjaChjaGFyQ29kZSl7Y2FzZSA5MjpjYXNlIDM0OmNhc2UgNDc6Y2FzZSA5ODpjYXNlIDExNjpjYXNlIDExMDpjYXNlIDEwMjpjYXNlIDExNDp2YWx1ZSs9VW5lc2NhcGVzW2NoYXJDb2RlXTtJbmRleCsrO2JyZWFrO2Nhc2UgMTE3OmJlZ2luPSsrSW5kZXg7Zm9yKHBvc2l0aW9uPUluZGV4KzQ7SW5kZXg8cG9zaXRpb247SW5kZXgrKyl7Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO2lmKCEoY2hhckNvZGU+PTQ4JiZjaGFyQ29kZTw9NTd8fGNoYXJDb2RlPj05NyYmY2hhckNvZGU8PTEwMnx8Y2hhckNvZGU+PTY1JiZjaGFyQ29kZTw9NzApKXthYm9ydCgpfX12YWx1ZSs9ZnJvbUNoYXJDb2RlKFwiMHhcIitzb3VyY2Uuc2xpY2UoYmVnaW4sSW5kZXgpKTticmVhaztkZWZhdWx0OmFib3J0KCl9fWVsc2V7aWYoY2hhckNvZGU9PTM0KXticmVha31jaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChJbmRleCk7YmVnaW49SW5kZXg7d2hpbGUoY2hhckNvZGU+PTMyJiZjaGFyQ29kZSE9OTImJmNoYXJDb2RlIT0zNCl7Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoKytJbmRleCl9dmFsdWUrPXNvdXJjZS5zbGljZShiZWdpbixJbmRleCl9fWlmKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KT09MzQpe0luZGV4Kys7cmV0dXJuIHZhbHVlfWFib3J0KCk7ZGVmYXVsdDpiZWdpbj1JbmRleDtpZihjaGFyQ29kZT09NDUpe2lzU2lnbmVkPXRydWU7Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoKytJbmRleCl9aWYoY2hhckNvZGU+PTQ4JiZjaGFyQ29kZTw9NTcpe2lmKGNoYXJDb2RlPT00OCYmKGNoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KzEpLGNoYXJDb2RlPj00OCYmY2hhckNvZGU8PTU3KSl7YWJvcnQoKX1pc1NpZ25lZD1mYWxzZTtmb3IoO0luZGV4PGxlbmd0aCYmKGNoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSxjaGFyQ29kZT49NDgmJmNoYXJDb2RlPD01Nyk7SW5kZXgrKyk7aWYoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpPT00Nil7cG9zaXRpb249KytJbmRleDtmb3IoO3Bvc2l0aW9uPGxlbmd0aCYmKGNoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSxjaGFyQ29kZT49NDgmJmNoYXJDb2RlPD01Nyk7cG9zaXRpb24rKyk7aWYocG9zaXRpb249PUluZGV4KXthYm9ydCgpfUluZGV4PXBvc2l0aW9ufWNoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtpZihjaGFyQ29kZT09MTAxfHxjaGFyQ29kZT09Njkpe2NoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO2lmKGNoYXJDb2RlPT00M3x8Y2hhckNvZGU9PTQ1KXtJbmRleCsrfWZvcihwb3NpdGlvbj1JbmRleDtwb3NpdGlvbjxsZW5ndGgmJihjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbiksY2hhckNvZGU+PTQ4JiZjaGFyQ29kZTw9NTcpO3Bvc2l0aW9uKyspO2lmKHBvc2l0aW9uPT1JbmRleCl7YWJvcnQoKX1JbmRleD1wb3NpdGlvbn1yZXR1cm4rc291cmNlLnNsaWNlKGJlZ2luLEluZGV4KX1pZihpc1NpZ25lZCl7YWJvcnQoKX1pZihzb3VyY2Uuc2xpY2UoSW5kZXgsSW5kZXgrNCk9PVwidHJ1ZVwiKXtJbmRleCs9NDtyZXR1cm4gdHJ1ZX1lbHNlIGlmKHNvdXJjZS5zbGljZShJbmRleCxJbmRleCs1KT09XCJmYWxzZVwiKXtJbmRleCs9NTtyZXR1cm4gZmFsc2V9ZWxzZSBpZihzb3VyY2Uuc2xpY2UoSW5kZXgsSW5kZXgrNCk9PVwibnVsbFwiKXtJbmRleCs9NDtyZXR1cm4gbnVsbH1hYm9ydCgpfX1yZXR1cm5cIiRcIn07dmFyIGdldD1mdW5jdGlvbih2YWx1ZSl7dmFyIHJlc3VsdHMsaGFzTWVtYmVycztpZih2YWx1ZT09XCIkXCIpe2Fib3J0KCl9aWYodHlwZW9mIHZhbHVlPT1cInN0cmluZ1wiKXtpZigoY2hhckluZGV4QnVnZ3k/dmFsdWUuY2hhckF0KDApOnZhbHVlWzBdKT09XCJAXCIpe3JldHVybiB2YWx1ZS5zbGljZSgxKX1pZih2YWx1ZT09XCJbXCIpe3Jlc3VsdHM9W107Zm9yKDs7aGFzTWVtYmVyc3x8KGhhc01lbWJlcnM9dHJ1ZSkpe3ZhbHVlPWxleCgpO2lmKHZhbHVlPT1cIl1cIil7YnJlYWt9aWYoaGFzTWVtYmVycyl7aWYodmFsdWU9PVwiLFwiKXt2YWx1ZT1sZXgoKTtpZih2YWx1ZT09XCJdXCIpe2Fib3J0KCl9fWVsc2V7YWJvcnQoKX19aWYodmFsdWU9PVwiLFwiKXthYm9ydCgpfXJlc3VsdHMucHVzaChnZXQodmFsdWUpKX1yZXR1cm4gcmVzdWx0c31lbHNlIGlmKHZhbHVlPT1cIntcIil7cmVzdWx0cz17fTtmb3IoOztoYXNNZW1iZXJzfHwoaGFzTWVtYmVycz10cnVlKSl7dmFsdWU9bGV4KCk7aWYodmFsdWU9PVwifVwiKXticmVha31pZihoYXNNZW1iZXJzKXtpZih2YWx1ZT09XCIsXCIpe3ZhbHVlPWxleCgpO2lmKHZhbHVlPT1cIn1cIil7YWJvcnQoKX19ZWxzZXthYm9ydCgpfX1pZih2YWx1ZT09XCIsXCJ8fHR5cGVvZiB2YWx1ZSE9XCJzdHJpbmdcInx8KGNoYXJJbmRleEJ1Z2d5P3ZhbHVlLmNoYXJBdCgwKTp2YWx1ZVswXSkhPVwiQFwifHxsZXgoKSE9XCI6XCIpe2Fib3J0KCl9cmVzdWx0c1t2YWx1ZS5zbGljZSgxKV09Z2V0KGxleCgpKX1yZXR1cm4gcmVzdWx0c31hYm9ydCgpfXJldHVybiB2YWx1ZX07dmFyIHVwZGF0ZT1mdW5jdGlvbihzb3VyY2UscHJvcGVydHksY2FsbGJhY2spe3ZhciBlbGVtZW50PXdhbGsoc291cmNlLHByb3BlcnR5LGNhbGxiYWNrKTtpZihlbGVtZW50PT09dW5kZWYpe2RlbGV0ZSBzb3VyY2VbcHJvcGVydHldfWVsc2V7c291cmNlW3Byb3BlcnR5XT1lbGVtZW50fX07dmFyIHdhbGs9ZnVuY3Rpb24oc291cmNlLHByb3BlcnR5LGNhbGxiYWNrKXt2YXIgdmFsdWU9c291cmNlW3Byb3BlcnR5XSxsZW5ndGg7aWYodHlwZW9mIHZhbHVlPT1cIm9iamVjdFwiJiZ2YWx1ZSl7aWYoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk9PWFycmF5Q2xhc3Mpe2ZvcihsZW5ndGg9dmFsdWUubGVuZ3RoO2xlbmd0aC0tOyl7dXBkYXRlKHZhbHVlLGxlbmd0aCxjYWxsYmFjayl9fWVsc2V7Zm9yRWFjaCh2YWx1ZSxmdW5jdGlvbihwcm9wZXJ0eSl7dXBkYXRlKHZhbHVlLHByb3BlcnR5LGNhbGxiYWNrKX0pfX1yZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UscHJvcGVydHksdmFsdWUpfTtKU09OMy5wYXJzZT1mdW5jdGlvbihzb3VyY2UsY2FsbGJhY2spe3ZhciByZXN1bHQsdmFsdWU7SW5kZXg9MDtTb3VyY2U9XCJcIitzb3VyY2U7cmVzdWx0PWdldChsZXgoKSk7aWYobGV4KCkhPVwiJFwiKXthYm9ydCgpfUluZGV4PVNvdXJjZT1udWxsO3JldHVybiBjYWxsYmFjayYmZ2V0Q2xhc3MuY2FsbChjYWxsYmFjayk9PWZ1bmN0aW9uQ2xhc3M/d2FsaygodmFsdWU9e30sdmFsdWVbXCJcIl09cmVzdWx0LHZhbHVlKSxcIlwiLGNhbGxiYWNrKTpyZXN1bHR9fX1pZihpc0xvYWRlcil7ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIEpTT04zfSl9fSkodGhpcyl9LHt9XSw1MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9dG9BcnJheTtmdW5jdGlvbiB0b0FycmF5KGxpc3QsaW5kZXgpe3ZhciBhcnJheT1bXTtpbmRleD1pbmRleHx8MDtmb3IodmFyIGk9aW5kZXh8fDA7aTxsaXN0Lmxlbmd0aDtpKyspe2FycmF5W2ktaW5kZXhdPWxpc3RbaV19cmV0dXJuIGFycmF5fX0se31dfSx7fSxbMV0pKDEpfSk7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcbiAgLCBlbGVtZW50ID0gcmVxdWlyZSgnLi4vLi4vZWxlbWVudCcpXG4gICwgdXRpbEhhc2ggPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL2hhc2gnKVxuICAsIHZPYmplY3QgPSByZXF1aXJlKCcuLi8uLi8uLi9vYmplY3QnKVxuXG4vKnRoaXMgZmlsZSBoYXMgbm90aGluZyB0byBkbyB3aXRoIHRoZSBuZXR3b3JrZGF0YSBDbGFzc1xuICBpdCBvbmx5IHJlYWRzIG91dCBtb2RlbHMgZm9yIGVsZW1lbnRzIHNvIHlvdSBjYW4gbWFrZSBhIHN1YnNjcmlwdGlvblxuKi9cblxuZnVuY3Rpb24gc29ydEZpZWxkKCBmaWx0ZXIsIG9iaiApIHtcbiAgaWYoIGZpbHRlci5zb3J0ICYmIGZpbHRlci5zb3J0LmZpZWxkICkgXG4gIHtcbiAgICB2YXIgc29ydCA9IHsgJDp7fSB9XG4gICAgc29ydC4kW2ZpbHRlci5zb3J0LmZpZWxkXSA9IHRydWVcbiAgICB1dGlsLm1lcmdlKCBvYmosIHNvcnQgKVxuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG4vL1RPRE86IGhhcyB0byB3b3JrIGluIHRoZSBodWJcbnZhciBkaXNhYmxlU2VsZWN0aW9ucyA9IHRydWVcblxuZXhwb3J0cy5wYXJzZURhdGEgPSBmdW5jdGlvbiggdmFsLCBmcm9tdGFyZ2V0cywgbG9nZ2VyICkge1xuXG5cbiAgLy9pbXBvcnRhbnQgZm9yIHVuU3Vic2NyaWJlID8/P1xuICAgIC8vIGNvbnNvbGUubG9nKCdMRVRTIFBBUlNFIERBVEEhJy5jeWFuLmludmVyc2UgLCB2YWwsIEpTT04uc3RyaW5naWZ5KGZyb210YXJnZXRzKSlcbiAgXG5cbiAgLy8gY29uc29sZS5sb2coJ0xFVFMgUEFSU0UgREFUQSEnLmN5YW4uaW52ZXJzZSAsIHZhbCwgSlNPTi5zdHJpbmdpZnkoZnJvbXRhcmdldHMpKVxuXG4gIGlmKCF2YWwpIHJldHVyblxuICAgIC8vIGNvbnNvbGUubG9nKCdMRVRTIFBBUlNFIERBVEEhMicuY3lhbi5pbnZlcnNlICwgdmFsLCBKU09OLnN0cmluZ2lmeShmcm9tdGFyZ2V0cykpXG5cbiAgdmFyIHN1YnNvYmogPSB7fVxuICAgICwgZiA9IHZhbC5fZmlsdGVyXG4gICAgLCB0YXJnZXRzID0gZnJvbXRhcmdldHMgfHwgdmFsLl9fc3ViXG5cbiAgaWYgKHRhcmdldHMpIHtcbiAgICAvLyBjb25zb2xlLmxvZygndGFyZ2V0cycsIHRhcmdldHMpXG4gICAgaWYgKGYgJiYgIWRpc2FibGVTZWxlY3Rpb25zKSB7XG4gICAgICBpZighc3Vic29ialsnKiddKSBzdWJzb2JqWycqJ109W11cbiAgICAgIHN1YnNvYmpbJyonXS5wdXNoKFtcbiAgICAgICAgdXRpbC5jbG9uZShmLCB7c3Vic09iajp0cnVlLCBmbjp0cnVlLCB0eXBlOnRydWV9KVxuICAgICAgICAsIHNvcnRGaWVsZChmLCBmcm9tdGFyZ2V0cyB8fCB7ICQ6IHRhcmdldHMgfSlcbiAgICAgIF0pXG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ0lNIERPSU5HIFNFTEVDVFMgcGFyc2VEYXRlbGV4Jywgc3Vic29iaiApXG4gICAgLy9URU1QRklYISEhIVxuICAgIGZvcih2YXIgaSBpbiBzdWJzb2JqWycqJ11bMV0gKSB7XG4gICAgICAvL3dlbCBmZiBkZSBmaWVsZHMgb29rIGRvZW4gcHJvYlxuXG4gICAgICBzdWJzb2JqW2ldID0gc3Vic29ialsnKiddWzFdW2ldXG4gICAgfVxuICAgIGRlbGV0ZSBzdWJzb2JqWycqJ11cblxuICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coICd0YXJnZXRzIElNIERPSU5HIFNFTEVDVFMgcGFyc2VEYXRlbGV4JywgdGFyZ2V0cyApXG5cbiAgICAgIHN1YnNvYmogPSB0YXJnZXRzXG4gICAgfVxuICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTEVUUyBQQVJTRSBEQVRBITQnLmN5YW4uaW52ZXJzZSAsIHZhbCwgSlNPTi5zdHJpbmdpZnkoZnJvbXRhcmdldHMpKVxuXG4gICAgLy8gY29uc29sZS53YXJuKCAnY2FudFxcJ3QgZmluZCB0YXJnZXQgLS0gbGV0cyBkbyBzdHVmZiEnLCB2YWwgIClcbiAgICAvL1RPRE86Z3VhcmQgdm9vciBhbHMgaGV0IGhldCBuaWV0IHdpbCAtLSBtaXNjaGllbmQgZG9vciBfc3VicyB6b2VrZW5cblxuICAgIC8vIGlmKHZhbC5fcGF0aCkge1xuICAgIC8vICAgY29uc29sZS5sb2codmFsLl9wYXRoKVxuICAgIC8vIH1cblxuICAgIC8vbm8gdHJhZ2V0cyBkb250IGRvIGFueXRoaW5nP1xuICB9XG5cbiAgLy8gY29uc29sZS5sb2coJ1JFU1VMVCEnLCBKU09OLnN0cmluZ2lmeShzdWJzb2JqKSlcblxuICByZXR1cm4gc3Vic29ialxufVxuXG5mdW5jdGlvbiBzZXRGbGFnKCBvYmosIHN0cmluZywgZmxhZywgZmllbGQsIHZhbCwgZnJvbSwgZWxlbSApIHtcblxuXG5cbiAgdmFyIG5vbkNsb3VkRGF0YUJpbmRpbmdzXG4gICAgLCBmcm9tS2V5XG5cbiAgICAsIGJlVHJpcHBwaW5cblxuXG4gIGlmKCBmcm9tICkge1xuICAgIGZyb21LZXkgPSBmcm9tLl9uYW1lICE9PSB2b2lkIDAgPyBmcm9tLl9uYW1lIDogZnJvbVxuXG4gICAgaWYoIGZyb20gaW5zdGFuY2VvZiB2T2JqZWN0KSB7XG5cbiAgICAgIC8vdGVnZW5vdmVyIGdlc3RlbGRlIGJpalxuICAgICAgLy8gaWYoZnJvbS5fX3QgPT09IDQpIHtcbiAgICAgICAgLy8gaWYoZnJvbS5fdmFsICYmIGZyb20uX3ZhbC5jbG91ZCkge1xuICAgICAgICAgIC8vaGFhbCBqdWlzdCBmaWVsZCB3ZWdcbiAgICAgICAgLy8gfVxuICAgICAgLy8gfSBcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdGUk9NIScsIGZyb20uX25hbWUsIGZyb20uX3BhdGggKVxuICAgICAgZnJvbUtleSA9IGZyb20uX25hbWVcbiAgICB9XG5cbiAgICBpZihmcm9tIGluc3RhbmNlb2YgQXJyYXkgJiYgZnJvbVsxXSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2JlIHRyaXBwaW5nIScsIGZyb20pXG4gICAgICAvLyAgIGZyb21LZXkgPSBmcm9tWzFdICYmIGZyb21bMV0uX25hbWVcblxuICAgICAgLy8gYmVUcmlwcHBpbiA9IGZyb21bMF0uX25hbWVcblxuICAgIH1cblxuICB9XG5cbiAgdmFyIGRkID0gZWxlbSAmJiBmcm9tICYmICggZWxlbS5fZCB8fCBlbGVtLmNoZWNrUGFyZW50KCdkYXRhJywgdHJ1ZSkgKVxuXG4gIC8vIGlmKGJlVHJpcHBwaW4pIHtcbiAgLy8gICBjb25zb2xlLmxvZyhkZCwgZnJvbUtleSwgYmVUcmlwcHBpbilcbiAgLy8gfVxuXG5cbiAgaWYgKGZpZWxkID09PSAnY29sbGVjdGlvbicpIHtcbiAgICB2YXIgb2JqMlxuXG4gICAgaWYgKGZsYWcuZmlsdGVyICYmIGZsYWcuZmlsdGVyLnZhbCE9PXRydWUgJiYgIWRpc2FibGVTZWxlY3Rpb25zKSBcbiAgICB7XG4gICAgICAvL2RpdCBub2cgaGFuZGVsZW4gb3AgcmVmc1xuICAgICAgb2JqMiA9IHt9XG5cblxuICAgICAgLy9FTkFCTEUgRk9SIFNFTEVDVElPTlxuICAgICAgLy8gaWYgKHN0cmluZyA9PT0gdHJ1ZSkge1xuXG4gICAgICAvLyAgIHN0cmluZyA9ICcqJ1xuICAgICAgLy8gfSBlbHNlIHtcblxuICAgICAgLy8gICBzdHJpbmcgPSBzdHJpbmcgKyAnLionXG4gICAgICAvLyB9XG4gICAgICB2YXIgZiA9IGZsYWcuZmlsdGVyLnJhd1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAnU0VUIEZMQUcnLCBhcmd1bWVudHMgKVxuXG5cbiAgLy8gY29uc29sZS5sb2coICdGSUVMRCE6JywgZmllbGQgLCAnRlJPTTonLCBmcm9tLCAgc3RyaW5nLnNwbGl0KCcuJyksIHN0cmluZyApXG5cbiAgICAgIHZhciBhcnIgPSB1dGlsLnBhdGgob2JqLCBzdHJpbmcuc3BsaXQoJy4nKSwgW10pXG5cbiAgICAgIGFyci5wdXNoKCBcbiAgICAgICAgW2YsIHtcbiAgICAgICAgICAkOiBzb3J0RmllbGQoZixvYmoyKVxuICAgICAgICB9XVxuICAgICAgKVxuXG4gICAgICAvL29iaiwgcGF0aCwgdmFsLCBvdmVyd3JpdGVcblxuICAgICAgLy9URU1QRklYISEhIVxuICAgICAgdmFyIHRlbXAgPSB1dGlsLnBhdGgoIG9iaiwgc3RyaW5nLnNwbGl0KCcuJyksIHt9LCB0cnVlIClcbiAgICAgIGZvcih2YXIgaSBpbiBhcnJbYXJyLmxlbmd0aC0xXVsxXSApIHtcbiAgICAgICAgLy93ZWwgZmYgZGUgZmllbGRzIG9vayBkb2VuIHByb2JcblxuICAgICAgICB0ZW1wW2ldID0gYXJyW2Fyci5sZW5ndGgtMV1bMV1baV1cbiAgICAgIH1cbiAgICAgIGFyciA9IHRlbXBcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnSU0gRE9JTkcgU0VMRUNQUyBDT0wgQ09MIScsIGFyciApXG5cblxuICAgIH0gZWxzZSB7XG5cbiAgICAgIHZhciBmID0gc3RyaW5nID09PSB0cnVlID8gJyQnIDogc3RyaW5nICsgJy4kJ1xuICAgICAgICAsIHAgPSAgZi5zcGxpdCgnLicpXG5cbiAgICAgICAgLCBzcGVjaWFsRml4XG5cbiAgICAgIGlmKCBkZCAmJiBkZFsgZnJvbUtleSBdICkgXG4gICAgICB7XG4gICAgICAgIG5vbkNsb3VkRGF0YUJpbmRpbmdzID0gdHJ1ZVxuICAgICAgICBpZiggcFswXSA9PT0gZnJvbUtleSApIFxuICAgICAgICB7XG4gICAgICAgICAgcC5zaGlmdCgpXG4gICAgICAgICAgbm9uQ2xvdWREYXRhQmluZGluZ3MgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBub25DbG91ZERhdGFCaW5kaW5ncyApIFxuICAgICAge1xuICAgICAgICBpZihzcGVjaWFsRml4KSB7XG4gICAgICAgICAgb2JqLnNwZWNpYWxGaXggPSBmcm9tS2V5XG4gICAgICAgICAgaWYoYmVUcmlwcHBpbikge1xuICAgICAgICAgICAgb2JqLnNwZWNpYWxGaXggPSBbIGZyb21LZXksIGJlVHJpcHBwaW4gXVxuICAgICAgICAgIH1cbiAgICAgICAgICBvYmoyID0gdXRpbC5wYXRoKG9iaiwgcCAsIHt9KVxuICAgICAgICAgIHJlYWRNb2RlbChmbGFnLmVsZW1lbnQuX3ZhbCBpbnN0YW5jZW9mIGVsZW1lbnQgPyBmbGFnLmVsZW1lbnQuX3ZhbCA6IGZsYWcuZWxlbWVudC5fdmFsLmJhc2UsIG9iajIgKVxuICAgICAgICB9XG4gICAgICB9IFxuICAgICAgZWxzZSBcbiAgICAgIHtcbiAgICAgICAgb2JqMiA9IHV0aWwucGF0aChvYmosIHAgLCB7fSlcbiAgICAgICAgcmVhZE1vZGVsKGZsYWcuZWxlbWVudC5fdmFsIGluc3RhbmNlb2YgZWxlbWVudCA/IGZsYWcuZWxlbWVudC5fdmFsIDogZmxhZy5lbGVtZW50Ll92YWwuYmFzZSwgb2JqMiApXG4gICAgICB9XG5cbiAgICB9XG5cbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAgJ3h4eFhYMTExMjIyMlhYeHgnLCBzdHJpbmcsIG9iaiApIC8vLCBmcm9tS2V5LCBlbGVtLl9kLCBlbGVtLmRhdGEsIGVsZW0uY2hlY2tQYXJlbnQoJ2RhdGEnLCB0cnVlKSApXG5cblxuICB9IGVsc2Uge1xuXG4gICAgaWYoIGRkICYmIGRkWyBmcm9tS2V5IF0gKSBcbiAgICB7XG4gICAgICBub25DbG91ZERhdGFCaW5kaW5ncyA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoIHN0cmluZyBpbnN0YW5jZW9mIEFycmF5ICkgXG4gICAge1xuICAgICAgZm9yICh2YXIgaSBpbiBzdHJpbmcpIFxuICAgICAge1xuICAgICAgICBpZiggbm9uQ2xvdWREYXRhQmluZGluZ3MgKVxuICAgICAgICB7XG4gICAgICAgICAgLy9UT0RPOiB0aGlzIGlzIGEgdGVtcGZpeFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdOT04gY2xvdWQgYmluZGluZ3MnLCBzdHJpbmcsIHN0cmluZ1tpXSlcbiAgICAgICAgICBpZiggc3RyaW5nW2ldIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnIUAhQCFAJylcbiAgICAgICAgICAgIHN0cmluZ1tpXSA9IHN0cmluZ1tpXVswXVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJpbmdbaV0gPSBzdHJpbmdbaV0uc3BsaXQoJy4nKVxuICAgICAgICAgIGlmKCBzdHJpbmdbaV1bMF0gPT09IGZyb21LZXkgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdHJpbmdbaV0uc2hpZnQoKVxuICAgICAgICAgICAgdXRpbC5wYXRoKCBvYmosIHN0cmluZ1tpXSwgdHJ1ZSApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIC8vVE9ETzogdGhpcyBpcyBhIHRlbXBmaXhcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnT0JKOicgLCBvYmosICdTVFJJTkdbaV06Jywgc3RyaW5nW2ldLCAnU1RSSU5HOicsIHN0cmluZywgZnJvbUtleSlcbiAgICAgICAgICAgaWYoIHN0cmluZ1tpXSBpbnN0YW5jZW9mIEFycmF5ICkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzIhQCFAIUAnKVxuICAgICAgICAgICAgc3RyaW5nW2ldID0gc3RyaW5nW2ldWzBdXG4gICAgICAgICAgfVxuICAgICAgICAgIHV0aWwucGF0aChvYmosIHN0cmluZ1tpXS5zcGxpdCgnLicpLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBcbiAgICBlbHNlIGlmICggc3RyaW5nICE9PSB0cnVlICYmIHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnICkgXG4gICAge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggICd4eHhYWFhYeHgnLCBzdHJpbmcsIG9iaiApIC8vLCBmcm9tS2V5LCBlbGVtLl9kLCBlbGVtLmRhdGEsIGVsZW0uY2hlY2tQYXJlbnQoJ2RhdGEnLCB0cnVlKSApXG5cbiAgICAgIGlmKCBub25DbG91ZERhdGFCaW5kaW5ncyApXG4gICAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBub25DbG91ZERhdGFCaW5kaW5ncyAsICdOT05DTE9VRCcpXG4gICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNwbGl0KCcuJylcbiAgICAgICAgICBpZiggc3RyaW5nWzBdID09PSBmcm9tS2V5ICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RyaW5nLnNoaWZ0KClcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICdGSUVMRCE6MjIyMjIyJywgc3RyaW5nIClcblxuICAgICAgICAgICAgaWYoc3RyaW5nLmxlbmd0aCA+IDApIHV0aWwucGF0aCggb2JqLCBzdHJpbmcsIHRydWUgKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggbm9uQ2xvdWREYXRhQmluZGluZ3MgLCAnTk9OQ0xPVUQnLCBzdHJpbmcsIG9iaiApXG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCAgJ3h4eHh4Jywgc3RyaW5nLCBvYmogKSAvLywgZnJvbUtleSwgZWxlbS5fZCwgZWxlbS5kYXRhLCBlbGVtLmNoZWNrUGFyZW50KCdkYXRhJywgdHJ1ZSkgKVxuICAgICAgICB1dGlsLnBhdGgoIG9iaiwgc3RyaW5nLnNwbGl0KCcuJyksIHRydWUgKVxuICAgICAgfVxuICAgIH0gXG4gICAgZWxzZSBcbiAgICB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnLS0tLT4gMicuaW52ZXJzZSwgc3RyaW5nLCBvYmosIGZsYWcsIGZpZWxkKVxuICAgICAgLy8gY29uc29sZS5lcnJvcigneHh4eHh4JylcbiAgICAgIC8vIG9ialsnX18jX18nXSA9IHRydWVcbiAgICAgIC8vIG9iaiA9IHRydWU7XG4gICAgICAvLyBjb25zb2xlLmxvZygnISEhJyxvYmosIHBhcmVudCk7XG4gICAgICAvLyBvYmpbJyMnXSA9IHRydWU7XG4gICAgfVxuICAgIFxuXG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcmUoIG9iaiwgZmxhZywgZmllbGQsIHZhbCwgZnJvbSwgZWxlbSApIHtcblxuICAvLyBjb25zb2xlLmxvZygnU1RPUkUnLCBhcmd1bWVudHMgKVxuXG4gIGlmIChmbGFnIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZsYWcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZXRGbGFnKG9iaiwgZmxhZ1tpXS5fZmxhZy5kYXRhWzJdLCBmbGFnLCBmaWVsZCwgdmFsLCBmcm9tLCBlbGVtIClcblxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLT4nLnJlZCxmbGFnKVxuXG4gICAgc2V0RmxhZyhvYmosIGZsYWcuX2ZsYWcuZGF0YVsyXSwgZmxhZywgZmllbGQsIHZhbCwgZnJvbSwgZWxlbSApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZE1vZGVsKCBlbGVtLCBvYmosIHZhbCwgZnJvbSAsIGlnbm9yZWZpZWxkKSB7XG5cbiAgLy8gY29uc29sZS5sb2coICdsZXRzIHJlYWQgbW9kZWwnLnllbGxvdy5pbnZlcnNlLCB2YWwgJiYgdmFsLl9wYXRoIHx8ICdubyB2YWxQYXRoJywgZnJvbSAmJiBmcm9tLl9wYXRoIHx8ICdubyBmcm9tUGF0aCcgLCB2YWwsIGVsZW0sIG9iaiwgdmFsLCBmcm9tIClcbiAgICAvL2hpZXIgbW9ldCBoZXQgZ2Vjb21iaW5lZXJkIHdvcmRlbiBtZXQgZWVuIHZhbHVlIHdhYXIgaGV0IGFhbiBnZWJpbmQgaXMhXG5cbiAgaWYgKGVsZW0ubW9kZWwgJiYgKGVsZW0ubW9kZWwuZmxhZ3N8fGVsZW0ubW9kZWwuc3Vic2NyaXB0aW9ufHxlbGVtLm1vZGVsLmZpZWxkKSkge1xuICAgIFxuICAgIC8vIGlmKG9iaikgY29uc29sZS5sb2coJ1hYWDEyMTIxMlhYWCBDT0xMRUNUSU9OJywgIGVsZW0ubW9kZWwuZmllbGQgJiYgZWxlbS5tb2RlbC5maWVsZC52YWwgKVxuICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgU09SVEZJRUxEISAyLjEyJywgSlNPTi5zdHJpbmdpZnkob2JqLGZhbHNlLDIpLCBlbGVtLm1vZGVsLmZpZWxkICYmIGVsZW0ubW9kZWwuZmllbGQudmFsKVxuXG4gICAgdmFyIGEgPSBvYmpcbiAgICAgICwgZmllbGRcbiAgICAgICwgZG9JdElnbm9yZUZsYWdzXG5cbiAgICAgIC8vW1widXNlcnNcIiwgXCJVX2JhMzIxNWExYjEwMzhhNzBcIiwgXCJuYXZpZ2F0aW9uXCIsIFwiZXBpc29kZVwiXSBcbiAgICAvLyBjb25zb2xlLmxvZyggJ1xcblxcblxcblxcblxcbi0tLS0tLS0tPicsIGVsZW0ubW9kZWwuZmllbGQgJiYgZWxlbS5tb2RlbC5maWVsZC52YWwsIGVsZW0ubW9kZWwucGFyc2luZyAmJiAhZWxlbS5tb2RlbC5wYXJzZWQgIClcblxuICAgIGlmKGlnbm9yZWZpZWxkKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnU1RPUCEgaWdub3JlZmllbGQnLCBvYmosIGVsZW0ubW9kZWwuZmllbGQgJiYgZWxlbS5tb2RlbC5maWVsZC52YWwsIGZyb20sIGZyb20gJiYgZnJvbS5fcGF0aClcbiAgICAgIC8vIGRlYnVnZ2VyXG4gICAgfVxuICAgIC8vVE9ETzogY29tcGFyZSBhcnJheXMgXG4gICAgZWxzZSBpZihlbGVtLm1vZGVsLmZpZWxkICYmIGVsZW0ubW9kZWwuZmllbGQudmFsICYmICFlbGVtLm1vZGVsLnBhcnNpbmcgJiYgIWVsZW0ubW9kZWxQYXJzZWQgJiYgKCB0eXBlb2YgZnJvbSAhPT0gJ3N0cmluZycgfHwgZWxlbS5tb2RlbC5maWVsZC52YWwgPT09IGZyb20gICkgICkge1xuICAgICAgZmllbGQgPSBlbGVtLm1vZGVsLmZpZWxkLnZhbC5zcGxpdCgnLicpXG4gICAgICBcbiAgICAgIGlmKCBlbGVtLm1vZGVsLmZpZWxkLnZhbCA9PT0gZnJvbSApIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnSEVSRSBJVFMgSU5URVJFU1RJTkcgRE8nLCBlbGVtLm1vZGVsLmZpZWxkLnZhbCAsIGZyb20gKVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gdXRpbC5wYXRoKG9iaixmaWVsZCx7fSx0cnVlKVxuICAgICAgICBkb0l0SWdub3JlRmxhZ3MgPSB0cnVlXG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoZnJvbSAmJiBlbGVtLm1vZGVsLmZpZWxkICYmIGVsZW0ubW9kZWwuZmllbGQudmFsICE9PSBmcm9tKSB7XG4gICAgICAgIHJldHVybiB2b2lkIDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZihlbGVtLm1vZGVsICYmIGVsZW0ubW9kZWwuc3Vic2NyaXB0aW9uICkge1xuXG4gICAgICB2YXIgc3VicyA9IGVsZW0ubW9kZWwuc3Vic2NyaXB0aW9uLnJhd1xuICAgICAgaWYoc3VicyA9PT0gdHJ1ZSkge1xuICAgICAgICBpZihmaWVsZCkge1xuICAgICAgICAgIGlmKGZpZWxkLmxlbmd0aD4xKSB7XG4gICAgICAgICAgYSA9IHV0aWwucGF0aChvYmosZmllbGQsdHJ1ZSx0cnVlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvYmpbZmllbGRbMF1dID0gdHJ1ZVxuICAgICAgICAgICAgYSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzdWIgPSBlbGVtLm1vZGVsLnN1YnNjcmlwdGlvbi5yYXdcbiAgICAgICAgaWYoIHR5cGVvZiBzdWIgPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgIHZhciBvbGQgPSBzdWJcbiAgICAgICAgICBzdWIgPSB7fVxuICAgICAgICAgIHN1YltvbGRdID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIHV0aWwubWVyZ2UoYSxzdWIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSBpbiBlbGVtLm1vZGVsLmZsYWdzKSB7XG4gICAgICBzdG9yZShhLCBlbGVtLm1vZGVsLmZsYWdzW2ldLCBpLCB2YWwsIGZyb20sIGVsZW0gKVxuICAgIH1cbiAgICBcbiAgfVxuXG4gIGlmKCAhZWxlbS5tb2RlbCB8fCAhZWxlbS5tb2RlbC5ibG9jayB8fCAhZWxlbS5tb2RlbC5ibG9jay52YWwgKSB7XG5cbiAgICBmb3IgKFxuICAgICAgdmFyIGNoaWxkcmVuID0gZWxlbS5jaGlsZHJlblxuICAgICAgLCBjaGlsZFxuICAgICAgLCBjaGlsZCQgPSAwXG4gICAgICAsIGNoaWxkcmVuJGxlbiA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aFxuICAgICAgOyBjaGlsZCQgPCBjaGlsZHJlbiRsZW5cbiAgICAgIDsgY2hpbGQgPSBjaGlsZCQrK1xuICAgICkge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltjaGlsZCRdXG4gICAgICBpZiAoKCFjaGlsZC5tb2RlbCB8fCAoIWNoaWxkLm1vZGVsLmluaGVyaXQgfHwgY2hpbGQubW9kZWwuaW5oZXJpdC52YWwhPT1mYWxzZSkpXG4gICAgICAgICYmICFjaGlsZC5fY29sICYmICFjaGlsZC5kYXRhIHx8IGNoaWxkLl9kZnJvbSkgeyAvL2RpdCBrYW4gYmV0ZXIhXG4gICAgICAgIHJlYWRNb2RlbChjaGlsZCwgYSB8fCBvYmosIHZhbCwgZnJvbSApXG4gICAgICAvL2VsZW0sIG9iaiwgdmFsLCBmcm9tICwgaWdub3JlZmllbGQsIGZpZWxkXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYob2JqWydfXyNfXyddKSB7XG4gICAgLy8gb2JqLiQgPSB0cnVlXG4gICAgLy8gdXRpbC5tZXJnZShvYmosIG9ialsnX18jX18nXSlcbiAgICBkZWxldGUgb2JqWydfXyNfXyddXG4gIH1cblxuICByZXR1cm4gZWxlbS5tb2RlbCAmJiBlbGVtLm1vZGVsLmJsb2NrICYmIGVsZW0ubW9kZWwuYmxvY2sudmFsPT09J2FsbCcgPyB2b2lkIDAgOiBvYmpcbn1cblxudXRpbC5kZWZpbmUoZWxlbWVudCwgJ2dldE1vZGVsJywgZnVuY3Rpb24oIHZhbCwgZnJvbSwgaWdub3JlZmllbGQgKSB7XG5cbiAgdmFyIHN1YnNjcmlwdGlvbiA9IHJlYWRNb2RlbCggdGhpcywge30sIHZhbCwgZnJvbSwgaWdub3JlZmllbGQgKVxuXG4gIC8vIGNvbnNvbGUuZXJyb3IoJ3BhcnNlZCBzdWJzY3JpcHRpb24hJywgSlNPTi5zdHJpbmdpZnkoc3Vic2NyaXB0aW9uLCBmYWxzZSwgMikgKVxuICAvL3dhYXJvbSBrb210IGllIDN4IGV4dHJhP1xuXG4gIHJldHVybiAhdXRpbC5lbXB0eSggc3Vic2NyaXB0aW9uICkgPyBzdWJzY3JpcHRpb24gOiBudWxsXG59KSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBvYmplY3QgPSByZXF1aXJlKCcuLi8uLi8uLi9vYmplY3QnKVxuICAsIGRhdGEgPSByZXF1aXJlKCcuLi8uLi8uLi9kYXRhJylcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG4gICwgdmlnb3VyID0gcmVxdWlyZSgnLi4vLi4vLi4vJylcbiAgLCBfbmV0d29ya2RhdGEgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB2aWdvdXIuTmV0d29ya2RhdGEgPSBkYXRhLm5ldyh7XG4gICAgICBtaXhlZDogNCwgLy9taXNjaGllbiBuaWV0IG1peGVkXG4gICAgICBtZXJnZTogdHJ1ZVxuICAgIH0pXG4gICwgX3N1YiA9ICdzdWJzY3JpYmUnXG4gICwgX3Vuc3ViID0gJ3VuJyArIF9zdWJcbiAgLCBfbGlzdGVuZXIgPSAnTGlzdGVuZXInXG4gICwgX2FsID0gJ2FkZCcgKyBfbGlzdGVuZXJcbiAgLCBfcmwgPSAncmVtb3ZlJyArIF9saXN0ZW5lclxuICAsIF9wcm90byA9IG9iamVjdC5wcm90b3R5cGVcbiAgLCBfcHJvdG9BZGRMaXN0ZW5lciA9IF9wcm90b1tfYWxdXG4gICwgX3Byb3RvUmVtb3ZlTGlzdGVuZXIgPSBfcHJvdG9bX3JsXVxuICAsIF9jaGVja1N1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uKCBmaWVsZCwgdmFsICkge1xuICAgICAgdmFyIGEgPSB0aGlzXG4gICAgICB3aGlsZSAoYSAmJiBhLl9fdCA9PT0gNCkge1xuICAgICAgICBpZihhLl9fYmxvY2spIHJldHVyblxuICAgICAgICBhID0gYS5fdmFsXG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZyhmaWVsZCwgYSlcbiAgICAgIGlmKChhIGluc3RhbmNlb2YgX25ldHdvcmtkYXRhKSAmJiBhW2ZpZWxkXSkgYVtmaWVsZF0odmFsLCB0aGlzKVxuICAgIH1cbiAgLCBWID0gcmVxdWlyZSgnLi4vLi4vLi4vJylcblxuX25ldHdvcmtkYXRhLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ19zdWJzJywnX2NvbXBsZXRlJylcbi8vJ18nICsgX3N1YiwgJ18nICsgX3Vuc3ViLCB3ZSBkb250IHVzZSB0aGVyZSBub3dcbi8vIF9zdWJzY3JpYmUoX3N1Yik7XG4vLyBfc3Vic2NyaWJlKF91bnN1Yik7XG5cblxuLy9UT0RPOiBmaXggbWFyayEhISEhISEhISEhIG1hcms6dHJ1ZVxudXRpbC5kZWZpbmUoX25ldHdvcmtkYXRhLFxuICAnZ2V0JywgZnVuY3Rpb24oIHZhbCwgc2V0LCBub3RzZWxmLCBzdGFtcCApIHtcbiAgICBcbiAgICAvLyBJTSBHRVRUSU5HISBbXCJ1c2Vyc1wiLCBcInVfYmEzMjE1YTFiMTAzOGE3MFwiLCBcIm10dkRhdGFcIiwgXCJOTFwiLCBcIm5sXCIsIFwic2hvd3NcIl0gdW5kZWZpbmVkXG4gICAgLy9vYmosIHBhdGgsIHZhbCwgb3ZlcndyaXRlLCB3cml0ZUhhbmRsZXIsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgc2VsZiwgdWlkLCBpXG4gICAgLy8gdmFyIGJsYSA9ICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgPyB2YWwgOiBTdHJpbmcodmFsKS5zcGxpdCgnLicpXG4gICAgLy8gY29uc29sZS5sb2coJ0lNIEdFVFRJTkchJywgYmxhLCB2YWwsIHNldCwgdGhpcywgdGhpcy5wYXRoKVxuXG4gICAgLy9UT0RPOiBBbHdheXMgZ2l2ZSBtZSB0aGUgbm9uLWZyb20gaXMgcG9zc2libGVcbiAgICAvLyBjb25zb2xlLndhcm4oJ0dldCAtLSBzZWxmIGlzIG5vdyBvbiBvbiBkZWZ1YWx0IHNob3VsZCBiZWNvbWUgc29tZXRoaW5nIGRpZmZlcmVudCEnKVxuICAgIC8vb2JqLCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYsXG4gICAgLy9jb25kaXRpb25hbCBzZWxmXG5cbiAgICByZXR1cm4gdGhpcy5wYXRoXG4gICAgICAoICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgPyB2YWwgOiBTdHJpbmcodmFsKS5zcGxpdCgnLicpXG4gICAgICAsIHNldCAhPT0gdm9pZCAwID8gc2V0IDoge31cbiAgICAgICwgZmFsc2VcbiAgICAgICwgZmFsc2VcbiAgICAgICwgZmFsc2VcbiAgICAgICwgc3RhbXAgfHwgZmFsc2UgLy9zdGFtcHlcbiAgICAgICwgdHJ1ZVxuICAgICAgLCAhbm90c2VsZlxuICAgICAgKVxuXG4gIH0sXG4gIC8vICdfY2hhbmdldm9iaicsIGZ1bmN0aW9uKHZhbCxzdGFtcCkge1xuICAvLyAgIGNvbnNvbGUuZXJyb3IodmFsLHN0YW1wKVxuICAvLyAgIHJldHVybiBfY2hhbmdldm9iai5hcHBseSh0aGlzLGFyZ3VtZW50cylcbiAgLy8gfSxcbiAgLy8gJ19ob29rJywgZnVuY3Rpb24odmFsLCBwYXJhbSkge1xuICAvLyAgIGZvciAodmFyIGkgaW4gcGFyYW0pIHtcbiAgLy8gICAgIHRoaXNbJ18nICsgaV0gPSBwYXJhbVtpXTtcbiAgLy8gICB9XG4gIC8vIH0sIC8vZG9udCB1c2UgdGhpcyBub3cgc28gbGV0cyBhZGQgd2hlbiB1c2VkXG4gIF9hbCwgZnVuY3Rpb24oIHZhbCApIHtcbiAgICAvLyBjb25zb2xlLmxvZygnTEVUUyBHTyEnLCBfc3ViLCB2YWwsICEhdGhpc1tfc3ViXSlcbiAgICBpZih0aGlzW19zdWJdKSB0aGlzW19zdWJdKHZhbClcbiAgICBfcHJvdG9BZGRMaXN0ZW5lci5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgfSxcbiAgX3JsLCBmdW5jdGlvbiggdmFsLCBtYXJrICkge1xuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgJiYgdGhpc1tfdW5zdWJdKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnUkVNT1ZFIF9MJy5yZWQuaW52ZXJzZSwgbWFyaylcbiAgICAgIHRoaXNbX3Vuc3ViXSggbWFyayApXG4gICAgfVxuICAgIF9wcm90b1JlbW92ZUxpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICB9XG4pO1xuXG4vLy0tLS0tLS1EQVRBLS0tLS0tLS0tXG51dGlsLmRlZmluZShkYXRhLCBcbiAgX2FsLCBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnMC0tLS0tLS0tLT4nLHZhbClcbiAgICBpZighdGhpcy5fX2Jsb2NrKSBfY2hlY2tTdWJzY3JpcHRpb24uY2FsbCh0aGlzLCBfc3ViLCB2YWwpO1xuICAgIF9wcm90b0FkZExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH0sXG4gIF9ybCwgZnVuY3Rpb24odmFsLCBtYXJrKSB7XG4gICAgIC8vIGNvbnNvbGUuZXJyb3IoJzIuMSBSRU1PVkUgX0wnLCBtYXJrLCB2YWwsIF91bnN1YilcbiAgICBpZighdGhpcy5fX2Jsb2NrKSBfY2hlY2tTdWJzY3JpcHRpb24uY2FsbCh0aGlzLCBfdW5zdWIsIG1hcmspO1xuICAgIF9wcm90b1JlbW92ZUxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cbik7XG5cbi8vLS0tLS0tLVZhbHVlLS0tLS0tLS0tXG5cbi8vIHV0aWwuZGVmaW5lKFZhbHVlLCAvL3Rlc3QgaXMgdGhpcyBpbXBhY3RzIHBlcmZvcm1hbmNlIHRvIG11Y2hcbi8vICAgX2FsLCBmdW5jdGlvbih2YWwpIHtcbi8vICAgICAvLyBjb25zb2xlLmxvZygnMC0tLS0tLS0tLT4nLHZhbClcbi8vICAgICBpZighdGhpcy5fX2Jsb2NrKSBfY2hlY2tTdWJzY3JpcHRpb24uY2FsbCh0aGlzLCBfc3ViLCB2YWwpO1xuLy8gICAgIF9wcm90b0FkZExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4vLyAgIH0sXG4vLyAgIF9ybCwgZnVuY3Rpb24odmFsLCBtYXJrKSB7XG4vLyAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJzIuMSBSRU1PVkUgX0wnLCBtYXJrLCB2YWwsIF91bnN1Yilcbi8vICAgICBpZighdGhpcy5fX2Jsb2NrKSBfY2hlY2tTdWJzY3JpcHRpb24uY2FsbCh0aGlzLCBfdW5zdWIsIG1hcmspO1xuLy8gICAgIF9wcm90b1JlbW92ZUxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4vLyAgIH1cbi8vICk7XG5cblxuXG5cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgVmFsdWUgPSByZXF1aXJlKCcuLi8uLi92YWx1ZScpXG4gICwgY29uZmlnID0gcmVxdWlyZSgnLi4vLi4vdXRpbC9jb25maWcnKVxuICAsIHByb2Nlc3MgPSByZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy9wcm9jZXNzJylcbiAgLCByYWYgPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL2FuaW1hdGlvbi9yYWYnKVxuICAsIHBvc3Rwb25lID0gcmVxdWlyZSgnLi4vLi4vYnJvd3Nlci9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG4gICwgdWEgPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL3VhJylcblxuVmFsdWUucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX2xhc3QnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgVmFsdWUoKVxuLy9UT0RPOiAucGFyYW1zIC93IGxpc3RlbmVycyFcblxuY29uZmlnLmhhc2hVcmwgPSB1YS5kZXZpY2UgPT09ICd0dicgJiYgdWEucGxhdGZvcm0gPT09ICdsZycgPyBmYWxzZSA6ICBjb25maWcuaGFzaFVybFxuXG4vLyBoaXN0b3J5LnB1c2hTdGF0ZSh7fSwgJycsJycgKVxuLy8gaGlzdG9yeS5nbygwKVxuLy8gaGlzdG9yeS5iYWNrKClcblxudmFyIHBzdGF0ZSA9ICFjb25maWcuaGFzaFVybCAvLz0gIXdpbmRvdy5ERUJVRyQgJiYgd2luZG93Lmhpc3RvcnkgJiYgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlXG4gICwgY250ID0gMFxuICAsIHRpbWVkU3RhdGVcbiAgLCBzdGF0ZSA9IHBvc3Rwb25lICggcHN0YXRlID8gZnVuY3Rpb24odmFsKSB7XG4gICAgICAvL2xvYWQgY3VycmVudCBwYXJhbXMgYXMgd2VsbFxuICAgICAgLy9zYW1lIGdvZXMgZm9yIHRoZSBvdGhlclxuICAgICAgLy93ZSBjb3VsZCBhZGQgYSBkZWxheSBoZXJlIVxuICAgICAgaHJlZiA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG5cbiAgICAgIGNvbnNvbGUubG9nKHZhbCwgIHZhbC5yZXBsYWNlKC8gL2csICcrJykucmVwbGFjZSgvXiNcXC8vLCAnJykudG9Mb3dlckNhc2UoKSlcblxuICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKCB7fSwgdmFsLCB2YWwucmVwbGFjZSgvIC9nLCAnKycpLnJlcGxhY2UoL14jXFwvLywgJycpLnRvTG93ZXJDYXNlKCkgKVxuICAgIH0gOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGV4cG9ydHMuYmxvY2sgPSB0cnVlXG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9ICcjLycgKyB2YWwucmVwbGFjZSgvIC9nLCAnKycpLnRvTG93ZXJDYXNlKClcbiAgICAgIGV4cG9ydHMuYmxvY2sgPSBmYWxzZVxuICAgIH0gKVxuICAsIF9zZXQgPSBWYWx1ZS5wcm90b3R5cGUuX3NldFxuICAsIHBhcnNlID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXBzdGF0ZSkgXG4gICAgICB7XG4gICAgICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZi5zcGxpdCgnIycpXG4gICAgICAgIHZhciBwYXJhbXMgPSAnJ1xuICAgICAgICBpZiggdXJsICYmIHVybC5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgcGFyYW1zID0gcXVlcnkoIHVybFswXSApXG4gICAgICAgICAgdXJsWzBdID0gdXJsWzBdLnJlcGxhY2UocGFyYW1zLCAnJylcbiAgICAgICAgICAvLyB3aW5kb3cubG9jYXRpb24gPSAnIy8nK3BhcmFtc1xuICAgICAgICAgIC8vIHJldHVybiA9ICd4J1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCB1cmwsICggdXJsLmxlbmd0aCA+IDEgPyB1cmxbMV0ucmVwbGFjZSgvXFwrL2csICcgJykgOiAnICcgKS5zbGljZSgxKSwgcGFyYW1zIClcbiAgICAgICAgLy8gK3BhcmFtc1xuICAgICAgICByZXR1cm4gKCB1cmwubGVuZ3RoID4gMSA/IHVybFsxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSA6ICcgJyApLnNsaWNlKDEpK3BhcmFtc1xuICAgICAgfSBlbHNlIFxuICAgICAge1xuICAgICAgICBcbiAgICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmXG4gICAgICAgIGlmKCB1cmwgKSB7XG4gICAgICAgICAgcGFyYW1zID0gcXVlcnkoIHVybCApXG4gICAgICAgICAgdXJsID0gdXJsLnJlcGxhY2UocGFyYW1zLCAnJylcbiAgICAgICAgICAvLyB3aW5kb3cubG9jYXRpb24gPSAnIy8nK3BhcmFtc1xuICAgICAgICAgIC8vIHJldHVybiA9ICd4J1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFN0cmluZyh3aW5kb3cubG9jYXRpb24uaHJlZilcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKFN0cmluZyh3aW5kb3cubG9jYXRpb24ub3JpZ2luKSArICcvJywgJycpXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvXiNcXC8vLCAnJylcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXCsvZywgJyAnKVxuICAgICAgICAgICAgICAgfHwgJydcbiAgICAgIH1cbiAgICB9XG4gICwgcXVlcnkgPSBmdW5jdGlvbiggc3RyICkge1xuICAgICAgaWYoIXN0cikgc3RyID0gcGFyc2UoKSB8fCAnJ1xuICAgICAgdmFyIGFyciA9IHN0ci5zcGxpdCgnPycpXG4gICAgICAgICwgbGVuID0gYXJyLmxlbmd0aFxuICAgICAgc3RyID0gbGVuID4gMSAmJiBhcnJbIGFyci5sZW5ndGggLSAxIF0gPyAnPycrYXJyWyBhcnIubGVuZ3RoIC0gMSBdIDogJydcbiAgICAgIHJldHVybiBzdHJcbiAgICB9XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZVxuXG4vL1RPRE86IGJhY2sgYnRuIGhpamFjayAoZXZlbnQgaGlqYWNrIGFkZCByYW5kb20gcGFyYW0pXG4vL1RPRE86IHVzZSByYWYgZm9yIHVwZGF0ZXNcbmV4cG9ydHMudmFsID0geyBcbiAgc3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RyID0gcGFyc2UoKVxuICAgIHJldHVybiBzdHIucmVwbGFjZSggcXVlcnkoIHN0ciApLCAnJyApXG4gIH0sXG4gIHBhcmFtczoge1xuICAgIHZhbDogZnVuY3Rpb24oKSB7IHJldHVybiBxdWVyeSgpIH0sXG4gICAgZGVmZXI6ZnVuY3Rpb24oIHVwZGF0ZSwgYXJncyApIHtcblxuICAgICAgdGhpcy5jbGVhckNhY2hlKCkgLy9tYXliZSBub3Q/XG5cbiAgICAgIHZhciB2YWwgPSB0aGlzLnZhbFxuICAgICAgICAsIHBhcmFtc1xuICAgICAgICAsIG5lc3RlZHBhcmFtc1xuICAgICAgICAsIGNcblxuICAgICAgaWYoIHZhbCAmJiB2YWwhPT10aGlzLl9sYXN0ICkge1xuICAgICAgICB0aGlzLl9sYXN0ID0gdmFsXG4gICAgICAgIHBhcmFtcyA9IHZhbC5zbGljZSgxKS5zcGxpdCgnJicpXG4gICAgICAgIG5lc3RlZHBhcmFtcyA9IHt9XG4gICAgICAgIGZvciggdmFyIGkgaW4gcGFyYW1zICkge1xuICAgICAgICAgIGMgPSBwYXJhbXNbaV0uc3BsaXQoJz0nKVxuICAgICAgICAgIGlmKCBjLmxlbmd0aD4xICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmVzdGVkcGFyYW1zW2NbMF1dID0gY1sxXVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigndXJsOiBubyBba2V5XT1bdmFsdWVdIGZvcm1hdCAtLSBub3QgaW1wbGVtZW50ZWQgeWV0JylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWwgPSBuZXN0ZWRwYXJhbXNcbiAgICAgIH1cbiAgICAgIHJhZihmdW5jdGlvbigpIHsgdXBkYXRlKCkgfSlcbiAgICB9XG4gIH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24oIHYsIGN2ICkge1xuICAgIHJldHVybiBjdlxuICB9LFxuICBkZWZlcjogZnVuY3Rpb24oIHVwZGF0ZSwgYXJncyApIHtcbiAgICBpZiggYXJnc1sxXSAmJiBhcmdzWzFdWzBdID09PSAndScgKSBcbiAgICB7XG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgcmFmKCBmdW5jdGlvbigpIHtcbiAgICAgICAgdXBkYXRlKClcbiAgICAgIH0pXG4gICAgfSBlbHNlIFxuICAgIHtcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICB2YXIgYSA9ICggdHlwZW9mIGFyZ3NbMF0gPT09ICdzdHJpbmcnICA/IGFyZ3NbMF0gOiBhcmdzWzBdICYmIGFyZ3NbMF0udmFsIHx8IHRoaXMudmFsIClcbiAgICAgIGlmKGEpIFxuICAgICAge1xuICAgICAgICBleHBvcnRzLmJsb2NrcyA9IGNudFxuXG4gICAgICAgIHN0YXRlKCBhICsgdGhpcy5wYXJhbXMudmFsIClcbiAgICAgIH1cbiAgICAgIHJldHVybiAgdHJ1ZVxuICAgICAgLy9UT0RPOiB1cGRhdGUoIHRydWUgKSBibG9ja3MgYWxsIGNvbnNlY3V0aXZlIHVwZGF0ZXNcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXJsRXZlbnQoZSkge1xuICB2YXIgc3RhbXBcblxuICBpZiggIWNvbmZpZy5oYXNoVXJsIHx8IGV4cG9ydHMuYmxvY2tzIT09Y250ICkgXG4gIHtcbiAgICBjbnQrK1xuICAgIHN0YW1wID0gJ3UnK2NudFxuICAgIGV4cG9ydHMuY2xlYXJDYWNoZSgpXG4gICAgZXhwb3J0cy5zdHJpbmcuY2xlYXJDYWNoZSgpIC8vbWF5YmUgbm90IGNsZWFyIG9uIHN0cmluZz9cbiAgICAvLyBleHBvcnRzLl91cGRhdGUoIHBhcnNlKCksICd1cmwnIClcbiAgICBleHBvcnRzLnN0cmluZy5fdXBkYXRlKCBleHBvcnRzLnN0cmluZy52YWwgLCBzdGFtcCApXG4gICAgZXhwb3J0cy5wYXJhbXMuX3VwZGF0ZSggZXhwb3J0cy5zdHJpbmcudmFsLCBzdGFtcCApXG4gICAgZXhwb3J0cy5fdXBkYXRlKCBleHBvcnRzLnN0cmluZy52YWwsIHN0YW1wIClcbiAgICBleHBvcnRzLl9sc3RhbXAgPSBudWxsXG5cbiAgfSBlbHNlIHtcbiAgICBjbnQrK1xuICB9XG59XG5cbnV0aWwuZGVmaW5lKCBleHBvcnRzLCAndXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gIHVybEV2ZW50KClcbn0pXG5cbnV0aWwuZGVmaW5lKCBleHBvcnRzLnN0cmluZywgJ3JhdycsIHtcbiAgZ2V0OmZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZhbC5yZXBsYWNlKCAvIC9nLCAnKycgKVxuICB9XG59KVxuXG5pZiggY29uZmlnLmhhc2hVcmwgKVxue1xuICB3aW5kb3cub25oYXNoY2hhbmdlID0gdXJsRXZlbnRcbn1cbmVsc2VcbntcbiAgd2luZG93Lm9ucG9wc3RhdGUgPSB1cmxFdmVudFxufVxuLy9UT0RPOiBhZGQgcG9wc3RhdGVcblxuIiwiLypcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG4vKlxuLypcbiAgdXNlcmFnZW50IHNuaWZmaW5nIGlzIG5ldmVyIHVzZWQgZm9yIGZlYXR1cmUgZGV0ZWN0aW9uLCBmb3IgYSBtdWx0aS1zY3JlZW4gYXBwIHlvdSBkbyBuZWVkIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkZXZpY2UgYWxzbyB3aGVuIHJ1bm5pbmcgaW4gdGhlIGJyb3dzZXJcbiAgaGFzIGZpZWxkcyBWLnVhLnBsYXRmb3JtLCBkZXZpY2UsIGJyb3dzZXIgYW5kIHZlcnNpb24uIFRoaXMgaW1wbGVtZW50YXRpb24gd2hlbiBjb21waWxlZCwgaXMgb25seSA3MDAgYnl0ZXNcbiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuLyoqXG4gKiB0ZXN0XG4gKiBzZWFyY2ggZm9yIHJlZ2V4cHMgaW4gdGhlIHVzZXJBZ2VudFxuICogZm4gaXMgYSBvbiBzdWNjZXMgY2FsbGJhY2tcbiAqIGNoZWNrIGh0dHA6Ly93d3cudXNlcmFnZW50c3RyaW5nLmNvbS8gdG8gdGVzdCBmb3IgdXNlckFnZW50c1xuICogQG1ldGhvZFxuICovXG4sIHRlc3QgPSBleHBvcnRzLnRlc3QgPSBmdW5jdGlvbiggX3VhLCBmbiApIHtcblxuICBmb3JcbiAgKCB2YXIgdGVzdHMgPSB1dGlsLmFyZyggYXJndW1lbnRzLCAxIClcbiAgICAgICwgaSA9IHRlc3RzLmxlbmd0aCAtIDFcbiAgICAgICwgcXVlcnkgPSB0ZXN0c1tpXVswXVxuICAgIDsgcXVlcnkgIT09IHRydWUgJiYgIW5ldyBSZWdFeHAoIHF1ZXJ5ICkudGVzdCggX3VhIClcbiAgICA7IHF1ZXJ5ID0gdGVzdHNbLS1pXVswXVxuICApXG5cbiAgO2lmKCBmbi5zbGljZSB8fCBmbi5jYWxsKCB0aGlzLCBxdWVyeSwgdGVzdHNbaV0gKSApXG4gIHtcbiAgICB0aGlzW2ZuXSA9IHRlc3RzW2ldWzFdXG4gIH1cblxufVxuLCBwYXJzZSA9IGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihfdWEsIG9iaikge1xuXG4gIGlmKCAhX3VhIClcbiAge1xuICAgIG9iaiA9IGV4cG9ydHNcbiAgICBfdWEgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKVxuICAgICAgICA6ICdubyBuYXZpZ2F0b3InXG4gIH1cblxuICBfdWEgPSBfdWEudG9Mb3dlckNhc2UoKVxuXG4gIGlmKCAhb2JqICkgb2JqID0ge31cblxuICAvLyBfdWEgPSAnd2Vib3M7IGxpbnV4IC0gbGFyZ2Ugc2NyZWVuJ1xuXG4gIHZhciBfZmYgPSAnZmlyZWZveCdcbiAgICAsIF9hbmRyb2lkID0gJ2FuZHJvaWQnXG4gICAgLCBfbW9iaWxlID0gJy4rbW9iaWxlJ1xuICAgICwgX3dlYmtpdCA9ICd3ZWJraXQnXG4gICAgLCBfcHMgPSAncGxheXN0YXRpb24nXG4gICAgLCBfeGJveCA9ICd4Ym94J1xuICAgICwgX2xpbnV4ID0gJ2xpbnV4J1xuICAgICwgX2Nhc3REZXRlY3QgPSAnY3JrZXknXG4gICAgLCBfY2hyb21lY2FzdCA9ICdjaHJvbWVjYXN0J1xuICAgICwgX3RhYmxldCA9ICd0YWJsZXQnXG4gICAgLCBfd2luZG93cyA9ICd3aW5kb3dzJ1xuICAgICwgX3Bob25lID0gJ3Bob25lJ1xuICAgICwgX2lwaG9uZVZlcnNpb25cblxuICB0ZXN0LmNhbGxcbiAgKCBvYmpcbiAgLCBfdWFcbiAgLCBmdW5jdGlvbiggcXVlcnksIGFyciApIHtcblxuICAgICAgb2JqLmJyb3dzZXIgPSBhcnJbMl0gfHwgcXVlcnlcblxuICAgICAgdmFyIF92ID0gX3VhLm1hdGNoXG4gICAgICAoIG5ldyBSZWdFeHBcbiAgICAgICAgKCAnKCgoW1xcXFwvIF12ZXJzaW9ufCdcbiAgICAgICAgKyBhcnJbMF1cbiAgICAgICAgKyAnKD8hLit2ZXJzaW9uKSlbXFwvIF0pfCBydjopKFswLTldezEsNH1cXFxcLlswLTldezAsMn0pJ1xuICAgICAgICApXG4gICAgICApXG5cbiAgICAgIG9iai52ZXJzaW9uID0gX3YgPyBOdW1iZXIoIF92WzRdICkgOiAwXG4gICAgICBvYmoucHJlZml4ID0gYXJyWzFdXG4gICAgICAvL1RPRE86IGFkZCBwcmVmaXggZm9yIG9wZXJhIHY+MTIuMTU7XG4gICAgICAvL1RPRE86IHdpbmRvd3MgY2hlY2sgZm9yIGllIDExIG1heSBiZSB0b28gZ2VuZXJhbDtcbiAgICB9XG4gICwgWyB0cnVlLCBfd2Via2l0IF1cbiAgLCBbICdcXFxcKHdpbmRvd3MnLCAnbXMnLCAnaWUnIF1cbiAgLCBbICdzYWZhcmknLCBfd2Via2l0IF1cbiAgLCBbIF9mZiwgJ01veicgXVxuICAsIFsgJ29wZXJhJywgJ08nIF1cbiAgLCBbICdtc2llJywgJ21zJywgJ2llJyBdXG4gICwgWyAnY2hyb21lfGNyaW9zXFwvJywgX3dlYmtpdCwgJ2Nocm9tZScgXVxuICApXG5cbiAgLyoqXG4gICogcGxhdGZvcm0gZGV0ZWN0aW9uXG4gICovXG4gIHRlc3QuY2FsbFxuICAoIG9ialxuICAsIF91YVxuICAsICdwbGF0Zm9ybSdcbiAgLCBbIHRydWUsIF93aW5kb3dzIF1cbiAgLCBbIF9saW51eCwgX2xpbnV4IF1cbiAgLCBbICdsZy57MCwzfW5ldGNhc3QnLCAnbGcnIF0gLy9UT0RPOnByb3BhYmx5IG5lZWQgdG8gYWRkIG1vcmUhXG4gICwgWyBfZmYgKyBfbW9iaWxlLCBfZmYgXVxuICAsIFsgJ21hYyBvcyB4JywgJ21hYycgXVxuICAsIFsgJ2lwaG9uZXxpcG9kfGlwYWQnLCAnaW9zJyBdXG4gICwgWyBfeGJveCwgX3hib3ggXVxuICAsIFsgX3BzLCBfcHMgXVxuICAsIFsgX2FuZHJvaWQsIF9hbmRyb2lkIF1cbiAgLCBbIF93aW5kb3dzLCBfd2luZG93cyBdXG4gICwgWyBfY2FzdERldGVjdCwgX2Nocm9tZWNhc3QgXVxuICAsIFsgJ3NtYXJ0LXR2O3w7c2Ftc3VuZztzbWFydHR2JywgJ3NhbXN1bmcnIF0gLy9TbWFydFRWMjAxM1xuICApXG5cbiAgLyoqXG4gICogZGV2aWNlIGRldGVjdGlvblxuICAqL1xuICB0ZXN0LmNhbGxcbiAgKCBvYmpcbiAgLCBfdWFcbiAgLCAnZGV2aWNlJ1xuICAsIFsgdHJ1ZSwgJ2Rlc2t0b3AnIF1cbiAgLCBbIF93aW5kb3dzICsgJy4rdG91Y2h8aXBhZHwnICsgX2FuZHJvaWQsICBfdGFibGV0IF1cbiAgLCBbICdpcGhvbmV8KCcgKyBfYW5kcm9pZCArIF9tb2JpbGUgKyAnKXwoJyArIF9mZiArIF9tb2JpbGUgKyAnKXwnICsgX3dpbmRvd3MgKyAnIHBob25lfGllbW9iaWxlJ1xuICAgICwgX3Bob25lXG4gICAgXVxuICAsIFsgX3hib3ggKyAnfCcgKyBfcHMsICdjb25zb2xlJyBdXG4gICwgWyAndHZ8c21hcnR0dnxnb29nbGV0dnxhcHBsZXR2fGhiYnR2fHBvdl90dnxuZXRjYXN0LnR2fHdlYm9zLitsYXJnZScsICd0dicgXVxuICAsIFsgX2Nhc3REZXRlY3QsIF9jaHJvbWVjYXN0IF1cbiAgLCBbICdhbWF6b24tZmlyZW9zJywgX3RhYmxldCBdXG4gIClcblxuICAvL1RPRE86IGFtYXpvbiBmaXJldHYgYW5kIHBob25lXG4gICAgLy8gYWxlcnQod2luZG93LmlubmVyV2lkdGgqd2luZG93LmlubmVySGVpZ2h0ICsgICcgICcrIDQxNCAqIDczNilcbiAgXG4gIC8vNDE0IMOXIDczNlxuICB2YXIgaXBob25lNnBsdXMgPSA0MTQgKiA3MzZcbiAgaWZcbiAgKCBvYmoucGxhdGZvcm0gPT09IF9hbmRyb2lkXG4gICAgJiYgIXV0aWwuaXNOb2RlXG4gICAgJiYgb2JqLmRldmljZSA9PT0gX3Bob25lXG4gICAgJiYgd2luZG93LmlubmVyV2lkdGgqd2luZG93LmlubmVySGVpZ2h0ID4gaXBob25lNnBsdXNcbiAgICAvLyAmJiB+X3VhLmluZGV4T2YoJ2Nyb3Nzd2FsaycpXG4gIClcbiAge1xuICAgIG9iai5kZXZpY2UgPSAndGFibGV0J1xuICB9XG5cbiAgcmV0dXJuIG9ialxufVxuXG5pZiggIXV0aWwuaXNOb2RlICkgXG57IFxuICBwYXJzZSgpXG4gIC8vVE9ETzogdGhpcyBpcyB2ZXJ5IHVnbHksIHRyeSB0byBmaW5kIGEgYmV0dGVyIHNvbHV0aW9uXG4gIGlmKCB3aW5kb3cuX191YV9fICkgXG4gIHtcbiAgICBmb3IoIHZhciBmaWVsZCBpbiB3aW5kb3cuX191YV9fIClcbiAgICB7XG4gICAgICBleHBvcnRzW2ZpZWxkXSA9IHdpbmRvdy5fX3VhX19bZmllbGRdXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogcHJvcFxuICogcmUtd3JpdGVzIGpzIHByb3BlcnRpZXMgdG8gdGhlaXIgY3NzIGNvdW50ZXJwYXJ0XG4gKiBlLmcuIHdlYmtpdFRyYW5zZm9ybSAtLT4gLXdlYmtpdC10cmFuc2Zvcm1cbiAqIG5vdyBpdHMgY29tbWVudGVkIHNpbmNlIGl0cyBub3QgbmVzc2VjYXJ5IHlldFxuICogQG1ldGhvZFxuICovXG4vLyB0aGlzLnByb3AgPSBmdW5jdGlvbihzdHIpIHtcbi8vICByZXR1cm4gc3RyLnJlcGxhY2UodGhpcy5wcmVmaXgsJy0nK3RoaXMucHJlZml4KyctJykudG9Mb3dlckNhc2UoKTtcbi8vIH1cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciAgZGF0YSA9IHJlcXVpcmUoJy4vJylcbiAgLCBiYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIGZsYWdzID0gcmVxdWlyZSgnLi4vdmFsdWUvZmxhZ3MvZGF0YScpXG4gICwgdk9iamVjdCA9IHJlcXVpcmUoJy4uL29iamVjdCcpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoIGZ1bmN0aW9uKGJhc2UsIGV4dGVuc2lvbnMsIG1vZGVsYmxhY2tsaXN0KSB7XG5cbiAgLy8gdmFyIF9ibGFja2xpc3QgPSB1dGlsLmFkZChbJ2ZsYWdzJywgJ3JlZicsICdwYXJzZScsICdwYXJzaW5nJ10sIG1vZGVsYmxhY2tsaXN0KSxcbiAgICB2YXIgX2NvbXBhcmUgPSB1dGlsLmNvbXBhcmVBcnJheXMsXG4gICAgbWV0aG9kcyA9IHtcbiAgICAgIF9kVXBkYXRlOiBmdW5jdGlvbihvYmosIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgaW5zdGFuY2VzLCBhcmd4MSwgYXJneDIgKSB7XG4gICAgICAgIC8vIGlmKHdpbmRvdy5oZXJlKSBjb25zb2xlLmxvZygnWCcsc3RhbXApXG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7XG4gICAgICAgICAgLy8kbmRhdGFcbiAgICAgICAgICAvL1RPRE86IHZlcnkgZGlydHkgZml4IGdldCByaWQgb2YgdGhpcyFcbiAgICAgICAgICBpZiggb2JqID09PSAnJG5kYXRhJyApe1xuICAgICAgICAgICAgdmFsID0gZnJvbVxuICAgICAgICAgICAgc3RhbXAgPSByZW1vdmVcbiAgICAgICAgICAgIGZyb20gPSBhZGRlZFxuICAgICAgICAgICAgcmVtb3ZlID0gb2xkdmFsXG4gICAgICAgICAgICBhZGRlZCA9IGluc3RhbmNlc1xuICAgICAgICAgICAgb2xkdmFsID0gYXJneDFcbiAgICAgICAgICAgIGluc3RhbmNlcyA9IGFyZ3gyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnIUAjIUAjIUAjIUAjQCEjIUAjIUAjIUAjJy5yZWQuaW52ZXJzZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyB2YXIgbm9uID0gMFxuICAgICAgICAgIC8vICAgLCBjbnQgPSAwXG4gICAgICAgICAgLy8gZm9yKCB2YXIgaSBpbiBhcmd1bWVudHMgKSBcbiAgICAgICAgICAvLyB7XG4gICAgICAgICAgLy8gICBjbnQrK1xuICAgICAgICAgIC8vICAgaWYoIWFyZ3VtZW50c1tpXSkge1xuICAgICAgICAgIC8vICAgICBub24rK1xuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vICAgY29uc29sZS5sb2coIGFyZ3VtZW50c1tpXSApXG4gICAgICAgICAgLy8gfVxuICAgICAgICAgIC8vIGlmKG5vbiA9PT0gY250KSB7XG4gICAgICAgICAgLy8gICBhbGVydCgnbm8gYXJncycpXG4gICAgICAgICAgLy8gICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIGlmICghdGhpcy5fZCAmJiB0aGlzLnBhcmVudCkge1xuICAgICAgICAgICAgdmFyIHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghdGhpcy5fZCAmJiBwKSB7XG4gICAgICAgICAgICAgIGlmIChwLl9kKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignU0VUIERBVEEnKVxuICAgICAgICAgICAgICAgIHRoaXMuX2RTZXQocC5fZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0ID0gdGhpcyxcbiAgICAgICAgICAgIG1vZGVsID0gdC5tb2RlbCxcbiAgICAgICAgICAgIGYgPSBtb2RlbC5mbGFncyxcblxuICAgICAgICAgICAgLy8gZiA9IG1vZGVsID8gbW9kZWwuZmxhZ3MgOiBmYWxzZSBiZSBjYXJlZnVsbCB3aXRoIHVwZGF0ZXMgaW4gdmFsdWVzIHRoYXQgaGF2ZSBkYXRhXG5cbiAgICAgICAgICAgIHBhdGggPSB0Ll9kICYmIHQuX2QuX3BhdGggfHwgW10sXG4gICAgICAgICAgICBuYW1lID0gKGZyb20gfHwgKGZyb20gPSAodC5fZCAmJiB0Ll9kLl91cGRhdGVPcmlnaW4pKSAmJiAhKGZyb20gPT09IHQuX2QgJiYgKGZyb20gPSBmYWxzZSkpKSAmJiBmcm9tLnVwZGF0ZVBhdGgsXG4gICAgICAgICAgICBmcm9tUGF0aCA9IGZyb20gJiYgZnJvbS5fcGF0aCxcbiAgICAgICAgICAgIG1ldGhvZCA9IGZ1bmN0aW9uKGksIGZpZWxkKSB7XG5cbiAgICAgICAgICAgICAgdmFyIHNlbGVjdCwgcGFzcywgZnIsIGxmaWVsZDtcbiAgICAgICAgICAgICAgLy8gaWYoIGZpZWxkLl9mbGFnWzJdLl9fdCkge1xuICAgICAgICAgICAgICAvL211bHRpcGxlIGZsYWdzIVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdGTEFHJy5pbnZlcnNlLCBuYW1lLCBmaWVsZC5fZmxhZylcbiAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgIGlmKCFmaWVsZC5fZmxhZy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTk8gREFUQSBGTEFHJywgbmFtZSwgZmllbGQuX2ZsYWcsIHZhbCwgb2JqLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmllbGQgPSBmaWVsZC5fZmxhZy5kYXRhWzJdO1xuXG4gICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnREFUQSBVUERBVEUnLm1hZ2VudGEuaW52ZXJzZSxcbiAgICAgICAgICAgICAgIC8vICAgICAgJ29iajonLCBvYmpcbiAgICAgICAgICAgICAgIC8vICAgICwgJ3ZhbDonLCB2YWxcbiAgICAgICAgICAgICAgIC8vICAgICwgJ3N0YW1wOicsIHN0YW1wXG4gICAgICAgICAgICAgICAvLyAgICAsICdmcm9tOicsIGZyb21cbiAgICAgICAgICAgICAgIC8vICAgICwgJ3JlbW92ZTonLCByZW1vdmVcbiAgICAgICAgICAgICAgIC8vICAgICwgJ2FkZGVkOicsIGFkZGVkXG4gICAgICAgICAgICAgICAvLyAgICAsICdmaWVsZDonLCBmaWVsZFxuICAgICAgICAgICAgICAgLy8gIClcbiAgICAgICAgICAgICAgLy8gdmFyIHRlc3QgPSAoaT09PSd0ZXh0JyAmJiBmaWVsZCA9PT0gJ3JlYWwuZHVyYXRpb24nKVxuICAgICAgICAgICAgICAvLyBpZih0ZXN0KSBjb25zb2xlLmxvZyhmaWVsZCxpKVxuICAgICAgICAgICAgICAvLyBpZih0ZXN0KSBwYXNzID0gdHJ1ZVxuXG4gICAgICAgICAgICAgIGlmIChpID09PSAnY29sbGVjdGlvbicgJiYgdC5fY29sRmlsdGVyKSByZXR1cm5cbiAgICAgICAgICAgICAgLy9pZiBub3Qgb3duIGNvbGZpbHRlciAtLT4gaGFuZGxlIHlvdXJzZWxmITtcbiAgICAgICAgICAgICAgLy8gaWYgZGF0YSBoYXMgY2hhbmdlZCBjaGFuZ2UgY29sZmlsdGVyIGFkbiBzZW5kIHVwZGF0ZVxuICAgICAgICAgICAgICAvL2JlIGNhcmVmdWxsIC93IGNoYW5nZXMhOyB0b28gY3J1ZGVcblxuICAgICAgICAgICAgICBpZiAoZmllbGQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUEFTUycuaW52ZXJzZSxuYW1lKVxuICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGZpZWxkLnBvcCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5hbWUsJz8/PycpXG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tPicsZmllbGQsIGZpZWxkLnBvcClcblxuICAgICAgICAgICAgICAgIGZpZWxkID0gZmllbGQuY29uY2F0KCk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gZmllbGQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgIGlmICghbGZpZWxkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ID0gdXRpbC5nZXQodC5fZCwgZmllbGRbal0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBsZmllbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBmaWVsZFtqXSA9IGZpZWxkW2pdLnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0RPIERPIScuaW52ZXJzZSxuYW1lLCB0Ll9kICYmIHQuX2QuX3VwZGF0ZU9yaWdpbilcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5hbWUsIHBhdGgsIHNlbGVjdCwgb2JqLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIGluc3RhbmNlcylcblxuICAgICAgICAgICAgICAgIGZpZWxkID0gZmllbGQuc3BsaXQoJy4nKVxuXG4gICAgICAgICAgICAgICAgc2VsZWN0ID0gdXRpbC5nZXQodC5fZCwgZmllbGQpXG5cbiAgICAgICAgICAgICAgICBpZighc2VsZWN0ICYmIHQuX2QgJiYgdC5fZC5mcm9tICYmIGZpZWxkICkge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ05PIFNFTEVDVCcucmVkLmludmVyc2UsIHQuX2QgKVxuICAgICAgICAgICAgICAgICAgc2VsZWN0ID0gdXRpbC5nZXQodC5fZC5mcm9tLCBmaWVsZClcbiAgICAgICAgICAgICAgICAgIC8vIGlmKHNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgLy8gICAvLyBjb25zb2xlLmxvZygnRk9VTkQgU0VMRUNUJy5ncmVlbi5pbnZlcnNlLCBzZWxlY3QpXG4gICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgIGlmKHNlbGVjdCAmJiBmcm9tICYmIGZyb20uX190ID09PSA0KSBsZmllbGQgPSB0cnVlIC8vdGVzdCBkaXQgb2YgaGV0IGFsbGVzIHNsb3cgbWFha3RcblxuICAgICAgICAgICAgICAgIC8vIGlmKHRlc3QmJnNlbGVjdCkgY29uc29sZS5sb2coc2VsZWN0Ll92YWwpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXBhc3MgJiYgZnJvbSkge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rlc3RpbmcuLi4uPycsIG5hbWUsIGZyb20sIHNlbGVjdCwgbGZpZWxkKVxuICAgICAgICAgICAgICAgIC8vIGlmKHRlc3QpIGNvbnNvbGUubG9nKG5hbWUsIHNlbGVjdCwgbGZpZWxkLCBmcm9tKTtcblxuICAgICAgICAgICAgICAgIGZyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgZnJvbUZyb21cblxuICAgICAgICAgICAgICAgIGlmICggZnJvbSA9PT0gc2VsZWN0IHx8ICggZnJvbUZyb20gPSBmcm9tLmZyb20gKSA9PT0gc2VsZWN0ICkge1xuICAgICAgICAgICAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0Ll9kLl9maWx0ZXIgJiYgc2VsZWN0ICYmIHNlbGVjdC5fYW5jZXN0b3IoZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vZmllbGQgb29rIHZvb3IgYXJyYXlzITtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGZpZWxkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2dvdCBsZmllbGQhISEhJylcblxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IGZpZWxkLmxlbmd0aDsgbisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUgJiYgX2NvbXBhcmUobmFtZSwgZmllbGRbbl0pIHx8IGZpZWxkW25dWzBdID09PSBuYW1lWzBdICYmIHV0aWwuZ2V0KHZhbCwgZmllbGRbbl0uY29uY2F0KCkuc2hpZnQoKSkpIFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKChfY29tcGFyZShwYXRoLmNvbmNhdChmaWVsZFtuXSksIGZyb21QYXRoKSB8fCBfY29tcGFyZShmaWVsZFtuXSwgZnJvbVBhdGgpKSkgXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdIRVJFPycuY3lhbi5pbnZlcnNlLCAnXFxuXFxuXFxuJywgc2VsZWN0LmZyb20ucmF3LCAndmFsOidcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgLCB2YWwsICdmaWVsZDonLCBmaWVsZCwgJ2ZuJywgZmllbGRbbl0sICduOicsIG4sICdjaGVjayBmaWVsZDonLCB2YWwgJiYgdmFsW2ZpZWxkW25dXSwgJ3JlZjonLCB2YWwuZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb21pbmcgdHJ1Z2gnLCBzZWxlY3QgJiYgZnJvbS5fdmFsICE9PSBudWxsICYmIHZhbCwgZmllbGRbbl1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgLCBzZWxlY3QgJiYgZnJvbS5fdmFsICE9PSBudWxsICYmIHZhbCAmJiAoIHZhbFtmaWVsZFtuXV0gfHwgdmFsLl9fdCA9PT0gNCAmJiB2YWwuZnJvbVtmaWVsZFtuXV0gKSApXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE86IG5lZWQgdG8gYWRkIG1vcmUgZ2F1cmRpbmcgZm9yIHZhbC4kcGF0aCBjaGVjayBpZiB0aGlzIGlzIGNsb3VkIGFuZCByZWZcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc2VsZWN0ICYmIGZyb20uX3ZhbCAhPT0gbnVsbCAmJiB2YWwgJiYgKHZhbFtmaWVsZFtuXV0gfHwgdmFsLiRwYXRoIHx8IHZhbC5fX3QgPT09IDQpICYmIChzZWxlY3QuX2FuY2VzdG9yKGZyb20pIHx8IHNlbGVjdC5mcm9tLl9hbmNlc3RvciggZnJvbUZyb20gKSAgKSkgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbCwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnLS0tJywgc2VsZWN0LCB2YWwsIGZpZWxkLCBmcm9tLCAnZnJvbVBhdGg6JyAsIGZyb21QYXRoIClcblxuICAgICAgICAgICAgICAgICAgICBpZih2YWw9PT1udWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaWYoREVCVUckKSB0Ll9kLkRFQlVHJGxvZygnZGF0YS9iYXNlIC0tLT4gRVJST1IgdmFsIGlzIG51bGwgIC0tLT4nK3QuX2QuX3JlbW92ZWQgKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYodmFsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBoYW5kbGUgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdcXG5cXG5cXG4gdW5kZWZpbmVkIHdoYXQgdG8gZG8gbm93PycsIGFyZ3VtZW50cyx0aGlzKVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUgJiYgX2NvbXBhcmUobmFtZSwgZmllbGQpIHx8IGZpZWxkWzBdID09PSBuYW1lICYmIG5hbWVbMF0gJiYgdXRpbC5nZXQodmFsLCBmaWVsZC5jb25jYXQoKS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGZyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGF0aCAmJiAoX2NvbXBhcmUocGF0aC5jb25jYXQoZmllbGQpLCBmcm9tUGF0aCkgfHwgX2NvbXBhcmUoZmllbGQsIGZyb21QYXRoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdCAmJiAodmFsW2ZpZWxkWzBdXSkgJiYgc2VsZWN0Ll9hbmNlc3RvciAmJiBzZWxlY3QuX2FuY2VzdG9yKGZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmFsLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgcGFzcyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKCB0Ll9fY2hlY2tLZXlzX18gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2xldHMgY2hlY2tqIHRoZSBrZXlzIScpXG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGZpZWxkLCBuYW1lLCB2YWwsIHBhdGgsIHNlbGVjdCwgdmFsW2ZpZWxkWzBdXSwgZnJvbSwgdGhpcyApXG4gICAgICAgICAgICAgICAgICAgICAgZm9yKCB2YXIga2V5JCBpbiB0Ll9fY2hlY2tLZXlzX18gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggZmllbGQgPT09IHQuX19jaGVja0tleXNfX1trZXkkXSB8fCBmaWVsZFswXSA9PT0gdC5fX2NoZWNrS2V5c19fW2tleSRdICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbWF5YmU/PyEhQCMhQCcsIGksIHQuX19jaGVja0tleXNfX1trZXkkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWwsIGZpZWxkWzBdLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gcGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdQQVNTPj4+Pj4+Pj4+PycubWFnZW50YS5pbnZlcnNlLCBwYXNzID8gJ09LIScuZ3JlZW4uaW52ZXJzZSA6ICdOTyEnLnJlZC5pbnZlcnNlICBcbiAgICAgICAgICAgICAgLy8gICAsICd2YWw6Jy5ibHVlLCB2YWxcbiAgICAgICAgICAgICAgLy8gICAsICdvYmouX3BhdGg6Jy5ibHVlLCBvYmogJiYgb2JqLl9wYXRoXG4gICAgICAgICAgICAgIC8vICAgLCAnZmllbGQ6Jy5ibHVlLCBmaWVsZFxuICAgICAgICAgICAgICAvLyAgICwgJ2Zyb21QYXRoOicuYmx1ZSwgZnJvbVBhdGhcbiAgICAgICAgICAgICAgLy8gICAsICdmcm9tOicuYmx1ZSwgZnJvbVxuICAgICAgICAgICAgICAvLyAgICwgJ3NlbGVjdCcuYmx1ZSwgc2VsZWN0XG4gICAgICAgICAgICAgIC8vICAgKVxuXG4gICAgICAgICAgICAgIC8vIGlmKCEgcGFzcyAmJiApXG5cbiAgICAgICAgICAgICAgLy8gcGFzcyA9IHRydWVcblxuICAgICAgICAgICAgICAvL3x8IHJlbW92ZSBcblxuICAgICAgICAgICAgICBpZiAocGFzcyB8fCByZW1vdmUgfHwgKGluc3RhbmNlcyB8fCByZW1vdmUgfHwgc2VsZWN0ICE9PSB2b2lkIDApICYmICggIWZyIHx8IHJlbW92ZSA9PT0gMSkpIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGluZyEnLmN5YW4uaW52ZXJzZSwgaSwgdmFsLCBpbnN0YW5jZXMsIHJlbW92ZSwgc2VsZWN0LCBmciwgZnJvbSlcbiAgICAgICAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAgICAgICAgIC8vc3RhbXAgbWVlZ2V2ZW4/Pz8/XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICdGUk9NISEhISEnLmdyZWVuLmludmVyc2UsIGZyb20gKVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubFxuICAgICAgICAgICAgICAgIHRbaV0uX3VwZGF0ZSh2YWwsIGZhbHNlLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsICFpbnN0YW5jZXMsIHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgICAgLy9hZGQgYWR2YW5jZWQgbW9kZWxzIChsaWtlIG9uIHdlYnNpdGUpXG4gICAgICAgICAgICAvL25vdCB0ZXN0ZWQgYW5kIHN0aWxsIHByZXR0eSBicm9rZW5cbiAgICAgICAgICAgdmFyIHBhcnNlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2QpIHtcbiAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLCBhXG4gICAgICAgICAgICAgIC8vaWYgYWRkZWQgb3IgZmlyc3QgcnVuXG4gICAgICAgICAgICAgIHQubW9kZWwudmFsIC8vc2V0IF9jYWxsZXJcbiAgICAgICAgICAgICAgLy8gaWYgKG1vZGVsLmZpZWxkKSBjb25zb2xlLmxvZygnPz8/PycsIHRoaXMuZmllbGQsIG1vZGVsLmZpZWxkKVxuXG4gICAgICAgICAgICAgIGlmIChtb2RlbC5maWVsZCkgYSA9IHV0aWwuZ2V0KHQuX2QsIG1vZGVsLmZpZWxkLnZhbClcbiAgICAgICAgICAgICAgaWYgKG1vZGVsLl92YWwpIGEgPSBtb2RlbC5fdmFsLmNhbGwodCwgYSB8fCB0Ll9kKSB8fCBhXG4gICAgICAgICAgICAgIGlmIChhICYmIHQuX2QgIT09IGEpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5wYXJzaW5nID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGlmKG1vZGVsLmZpZWxkKSB0aGlzLm1vZGVsUGFyc2VkID0gbW9kZWwuZmllbGQudmFsXG4gICAgICAgICAgICAgICAgdGhpcy5fZFNldChhKVxuICAgICAgICAgICAgICAgIG1vZGVsLnBhcnNpbmcgPSBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlci5jYWxsKHQpXG4gICAgICAgICAgaWYgKGluc3RhbmNlcykgdC5lYWNoSW5zdGFuY2UocGFyc2VyLCAnbW9kZWwnKVxuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgaWYgKGYgJiYgKGluc3RhbmNlcyB8fCB0Ll9kKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBmKSB7XG4gICAgICAgICAgICAgIGlmICghZltpXS5fX3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IGZbaV0ubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWV0aG9kKGksIGZbaV1bal0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXRob2QoaSwgZltpXSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgIGlmKHRoaXMubW9kZWwuY29tcGxldGUpIHRoaXMubW9kZWwuY29tcGxldGUuX3ZhbC5jYWxsKHRoaXMsZGF0YSlcblxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgX2RTZXQ6IGZ1bmN0aW9uKHZhbCwgZGZyb20pIHtcblxuXG4gICAgICAgIC8vIGlmKHZhbCkge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdfRHNldCcuY3lhbi5pbnZlcnNlLCB2YWwuX3BhdGgsIGRmcm9tKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmKHRoaXMubW9kZWwuX2ZsYWcgJiYgdGhpcy5tb2RlbC5fZmxhZy5wcm9jZXNzICYmICF0aGlzLl9fcHJvY2Vzc2luZykge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdvbzInKVxuICAgICAgICAvLyAgIHRoaXMubW9kZWwuX3VwZGF0ZSgpXG4gICAgICAgIC8vICAgcmV0dXJuXG4gICAgICAgIC8vIH1cblxuICAgICAgICBpZih0aGlzLm1vZGVsLl9mbGFnICYmIHRoaXMubW9kZWwuX2ZsYWcuZGVmZXIgICYmICF0aGlzLl9fcHJvY2Vzc2luZykge1xuICAgICAgICAgIHRoaXMuX19wRmxhZyA9IFsgdmFsLCBkZnJvbSBdXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICAvL2Rmcm9tIG1vZXQgbmlldCBub2cgZWVuIHN1YnNjcmliZSBkb2VuISAtLSBhbHMgaGV0IGdvZWQgaXMgaXMgem4gcGFyZW50IGFsIHN1YnNjcmliZWRcblxuICAgICAgICBpZiAodGhpcy5fZCAmJiB0aGlzLl9kLl9fdCkgdGhpcy5fZC5yZW1vdmVMaXN0ZW5lcih0cnVlLCB0aGlzKVxuICAgICAgICB0aGlzLl9kID0gdmFsXG4gICAgICAgIGlmIChkZnJvbSkgdGhpcy5fZGZyb20gPSB0cnVlXG4gICAgICAgIHRoaXMuX2RMaXN0ZW4oKVxuXG5cblxuICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgfSxcbiAgICAgIF9kTGlzdGVuOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdIRUVFRUVFJywgdGhpcy5tb2RlbClcblxuICAgICAgICAvLyBpZih0aGlzLm1vZGVsLl9mbGFnICYmIHRoaXMubW9kZWwuX2ZsYWcucHJvY2VzcyAmJiAhdGhpcy5fX3Byb2Nlc3NpbmcpIHtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZygnb28yJylcbiAgICAgICAgLy8gICB0aGlzLm1vZGVsLl91cGRhdGUoKVxuICAgICAgICAvLyAgIHJldHVyblxuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy9oaWVyIGdhYW4gd2UgcyBmZnRqZXMgd2Vya2VuIG1ldCBlYWNoXG5cbiAgICAgICAgLy8gdGhpcy5fZGZyb20gPSB0cnVlO1xuICAgICAgICB2YXIgX3RoaXNcblxuICAgICAgICBpZiAodGhpcy5tb2RlbCAmJiB0aGlzLl9kICYmIHRoaXMuX2QgaW5zdGFuY2VvZiB2T2JqZWN0KSBcbiAgICAgICAgeyAvL3RoaXMgbW9kZWwgbWF5YmUgbm90IG5lc3NlY2FyeT9cblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLT4nLmN5YW4uaW52ZXJzZSwgdGhpcy5fZCApXG5cbiAgICAgICAgICB0aGlzLl9kLmFkZExpc3RlbmVyKFt0aGlzLl9kVXBkYXRlLCB0aGlzXSlcblxuICAgICAgICAgIF90aGlzID0gdGhpc1xuICAgICAgICAgIFxuICAgICAgICAgIC8vaGllciBmaWx0ZXJlbiBvcCBjbG91ZERhdGEgLS0tIG9vayB3ZXJrZW4gdmFudWl0IHJlbW92ZSEhIVxuICAgICAgICAgICAgLy9uZXZlciBkbyBmb3IgY2xvdWQgZGF0YVxuICAgICAgICAgXG4gICAgICAgICAgaWYoICF0aGlzLl9kLmNsb3VkIClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9kLmVhY2goXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICBfdGhpcy5fX2NoZWNrS2V5c19fID0gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fX3QgPT09IDQgKSB0aGlzLmFkZExpc3RlbmVyKFsgX3RoaXMuX2RVcGRhdGUsIF90aGlzLCAnJG5kYXRhJywgdGhpcyBdKSBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvL2V2ZW50dWVlbCAudmFsIGdlYnJ1aWtlbiB2b29yIFZhbHVlcyAqYXdlc2p1bWUhXG4gICAgICAgICAgLy9ldmVudHVlZWwgaGllciBkaW5nZW4gYWRkZW4gYWFuIG1vZGVsXG5cbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSBpZiggdGhpcy5tb2RlbCAmJiB0aGlzLl9kICkgXG4gICAgICAgIHtcbiAgICAgICAgICBmb3IoIHZhciBrZXkgaW4gdGhpcy5fZCApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmKCF0aGlzLl9fY2hlY2tLZXlzX18gfHwgdGhpcy5fX2NoZWNrS2V5c19fID09PSB0cnVlKSB0aGlzLl9fY2hlY2tLZXlzX18gPSBbXVxuICAgICAgICAgICAgaWYoIHRoaXMuX2Rba2V5XSBpbnN0YW5jZW9mIHZPYmplY3QgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZighdGhpcy5fX2NoZWNrS2V5c19fLnB1c2gpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd4eHh4eHgnLCB0aGlzLCB0aGlzLl9fY2hlY2tLZXlzX18sIGtleSwgdGhpcy5fZClcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX19jaGVja0tleXNfXy5wdXNoKCBrZXkgKVxuICAgICAgICAgICAgICB0aGlzLl9kW2tleV0uYWRkTGlzdGVuZXIoWyB0aGlzLl9kVXBkYXRlLCB0aGlzLCAnJG5kYXRhJywga2V5IF0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1cGRhdGVEYXRhOiBmdW5jdGlvbihpbnN0YW5jZXMpIHtcblxuICAgICAgICBpZih0aGlzLm1vZGVsLl9mbGFnICYmIHRoaXMubW9kZWwuX2ZsYWcuZGVmZXIgJiYgIXRoaXMuX19wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ29vMicpXG4gICAgICAgICAgdGhpcy5fX3BGbGFnVSA9IFsgaW5zdGFuY2VzIF1cbiAgICAgICAgICB0aGlzLm1vZGVsLl91cGRhdGUoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCchRE9JVCB1cGRhdGVEYXRhJy5jeWFuLmludmVyc2UpXG5cbiAgICAgICAgdGhpcy5fZFVwZGF0ZSh0aGlzLl9kLCB2b2lkIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgaW5zdGFuY2VzKVxuICAgICAgfVxuICAgIH0sXG4gICAgZXh0ZW5kID0gZnVuY3Rpb24oaSkge1xuICAgICAgYmFzZS5leHRlbmQoe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICB0eXBlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IChleHRlbnNpb25zICYmIGV4dGVuc2lvbnNbaV0pID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgbWV0aG9kc1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIGV4dGVuc2lvbnNbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSA6IG1ldGhvZHNbaV1cbiAgICAgIH0pO1xuICAgIH07XG4gIGZvciAodmFyIGkgaW4gbWV0aG9kcykge1xuICAgIGV4dGVuZChpKVxuICB9XG4gIGJhc2UuZXh0ZW5kKHtcbiAgICBuYW1lOiAnbW9kZWwnLFxuICAgIGNhY2hlOiBmYWxzZSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICBpZih0aGlzLl9fcEZsYWcgfHwgdGhpcy5fX3BGbGFnVSkge1xuICAgICAgICAvKlxuICAgICAgICBUT0RPOiB0ZXN0IGRlZmVyIGJldHRlciEhIVxuICAgICAgICB0aGlzLl9fcEZsYWcgPSBbIHZhbCBdXG4gICAgICAgIHRoaXMuX19wRmxhZ1UgPSBbIHRydWUgXVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLl9fcHJvY2Vzc2luZyA9IHRydWVcbiAgICAgICAgdGhpcy5tb2RlbC5wYXJzaW5nID0gZmFsc2VcbiAgICAgICAgaWYodGhpcy5fX3BGbGFnKSB7XG4gICAgICAgICAgdGhpcy5fZFNldC5hcHBseSh0aGlzLHRoaXMuX19wRmxhZylcbiAgICAgICAgfVxuICAgICAgICAvL3N1YnNjcmliZSBoZWxlbWFhbCBmdWNrZWQgbWV0IGZpZWxkIGVyYmlqXG4gICAgICAgIGlmKHRoaXMuX19wRmxhZ1UpIHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZURhdGEuYXBwbHkodGhpcyx0aGlzLl9fcEZsYWdVKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19wRmxhZ1UgPSBudWxsXG4gICAgICAgIHRoaXMuX19wRmxhZyA9IG51bGxcbiAgICAgICAgdGhpcy5fX3Byb2Nlc3NpbmcgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmKHZhbC5maWVsZCAmJiB2YWwuZmllbGQudmFsICE9PSB0aGlzLm1vZGVsUGFyc2VkKSB7XG4gICAgICAgIHZhciBhID0gdGhpcy5tb2RlbFBhcnNlZCAmJiB0aGlzLm1vZGVsUGFyc2VkLnNwbGl0KCcuJylcbiAgICAgICAgICAsIHBhcmVudFxuICAgICAgICB0aGlzLm1vZGVsUGFyc2VkID0gbnVsbFxuICAgICAgICBpZih0aGlzLl9kKSB7XG4gICAgICAgICAgcGFyZW50ID0gdGhpcy5fZFxuICAgICAgICAgIGlmKGEpIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IGEubGVuZ3RoLTE7IGkgPj0wIDsgaS0tKSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihwYXJlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZFNldChwYXJlbnQpXG4gICAgICAgICAgICAgIHRoaXMudXBkYXRlRGF0YSh0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURhdGEodHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbFBhcnNlZCA9IG51bGxcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiggdGhpcy5fZCApXG4gICAgICB7XG4gICAgICAgIGlmICggdGhpcy5fZC5fX3QgKSAgXG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLl9kLnJlbW92ZUxpc3RlbmVyKCB2b2lkIDAsIHRoaXMgKVxuXG4gICAgICAgICAgaWYoICF0aGlzLl9kLmNsb3VkIClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAgICAgICB0aGlzLl9kLmVhY2goXG4gICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICAvLyBfdGhpcy5fX2NoZWNrS2V5c19fID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX190ID09PSA0ICkgdGhpcy5yZW1vdmVMaXN0ZW5lciggdm9pZCAwLCBfdGhpcyApIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiggdGhpcy5fX2NoZWNrS2V5c19fKSBcbiAgICAgICAge1xuICAgICAgICAgIGZvciggdmFyIGtleSQgaW4gdGhpcy5fX2NoZWNrS2V5c19fICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYoIHRoaXMuX2RbdGhpcy5fX2NoZWNrS2V5c19fW2tleSRdXSBpbnN0YW5jZW9mIHZPYmplY3QgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLl9kW3RoaXMuX19jaGVja0tleXNfX1trZXkkXV0ucmVtb3ZlTGlzdGVuZXIoIHZvaWQgMCwgdGhpcyApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHBhcmVudDogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgLy8gICBpZiggcGFyZW50LmRhdGEgJiYgKCFwYXJlbnQucGFyZW50IHx8IHBhcmVudC5wYXJlbnQuZGF0YSE9PXBhcmVudC5kYXRhKSApIHtcblxuICAgIC8vICAgICBjb25zb2xlLmVycm9yKCdXVEY/JylcblxuICAgIC8vICAgICB0aGlzLmRhdGEgPSBwYXJlbnQuZGF0YVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgfSwge1xuICAgIG5hbWU6ICdkYXRhJyxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnPycsdmFsKVxuICAgICAgaWYoIHRoaXMuX2QgPT09IHZhbCApIHJldHVyblxuXG4gICAgICAvLyBpZighdGhpcy5tb2RlbCkgdGhpcy5tb2RlbCA9IHt9IC8vZGl0IG1ldCBoZXQgbm9vaXQgc2V0dGVuIHZhbiBmbW9kZWwgc2NoZWVsIG9wIHNob3cgYWwgMy85IHN1YnNjcmlwdGlvbnNcbiAgICAgIC8vbnUgbm9nIHNoYXJlZCBzdWJzIG1ha2VuIC0tICdzaG93cycgKG9vayBtZXRlZW4gcHJvY2VzcykgZW4gZGFuIHdvcmQgdGhldCBhbHMgaGV0IGdvZWQgaXMgbm9nIGVlbiBzdHVrIG1pbmRlclxuICAgIFxuICAgICAgLy8gdGhpcy5tb2RlbCA9IHt9IC8vcGFzIG9wIG1ldCBkZXplXG4gICAgICAvLyBjb25zb2xlLmxvZygnPzInKVxuXG4gICAgICBpZiggdGhpcy5tb2RlbC5fZmxhZyAmJiB0aGlzLm1vZGVsLl9mbGFnLmRlZmVyICkge1xuICAgICAgICB0aGlzLl9fcEZsYWcgPSBbIHZhbCBdXG4gICAgICAgIHRoaXMuX19wRmxhZ1UgPSBbIHRydWUgXVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnIUAjIUAjIUAjIE9PT08nLnJlZClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJyEhISEhTU9ERUwgLS0gZGl0IG1vZXQgem92ZWVsIG1vZ2VsaWprIGdlcmVkdWNlZCcsIHRoaXMubW9kZWwpXG5cbiAgICAgIHRoaXMubW9kZWwucGFyc2luZyA9IGZhbHNlXG4gICAgICB0aGlzLl9kU2V0KHZhbClcblxuICAgICAgLy9zdWJzY3JpYmUgaGVsZW1hYWwgZnVja2VkIG1ldCBmaWVsZCBlcmJpalxuICAgICAgdGhpcy51cGRhdGVEYXRhKHRydWUpXG5cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZFxuICAgIH1cbiAgfSlcbn0pIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogTWFyY3VzIEJlc2plcywgbWFyY3VzQHZpZ291ci5pb1xuICovXG52YXIgZGF0YSA9IHJlcXVpcmUoJy4vJyksXG4gIGNudCA9IDAsXG4gIGhhbmRsZVRlc3QgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRlc3QsIHN1YnNPYmopIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdoYW5kbGVUZXN0IScsIHRlc3QpXG4gICAgaWYgKHRlc3QgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVzdCk7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXNbMF1cbiAgICAgICAgICAsIHZhbGNoZWNrID0gaGFuZGxlRmllbGQoa2V5LCB0ZXN0W2tleV0sIHN1YnNPYmopXG4gICAgICAgICAgXG4gICAgICAgIHJldHVybiBzdWJzT2JqLl9jaGVjayA9IGZ1bmN0aW9uKGRvYyl7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1RFU1RJTkcnLCB0ZXN0LCBkb2MgJiYgZG9jLnJhdylcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY2hlY2tpbmcgZm9yIGtleScsIGtleSlcbiAgICAgICAgICB2YXIgdmFsID0gZ2V0VmFsdWUoZG9jKVxuICAgICAgICAgIHJldHVybiB2YWxjaGVjayh2YWwpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsaXN0ID0gW10sXG4gICAgICAgICAga2V5O1xuICAgICAgICBmb3IgKHZhciBrID0gMCwgbCA9IGtleXMubGVuZ3RoOyBrIDwgbDsgaysrKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1trXTtcbiAgICAgICAgICBsaXN0LnB1c2goaGFuZGxlRmllbGQoa2V5LCB0ZXN0W2tleV0sIHN1YnNPYmopKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3Vic09iai5fY2hlY2sgPSBtYWtlQU5EKGxpc3QpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3Vic09iai5fY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGdldFZhbHVlKGRvYykgPT09IHRlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbmZ1bmN0aW9uIGhhbmRsZUZpZWxkKGtleSwgdmFsdWUsIHN1YnNPYmopIHtcbiAgLy8gY29uc29sZS53YXJuKCdoYW5kbGVGaWVsZCBbJywga2V5LCAnXSB2YWx1ZScsIHZhbHVlKVxuICB2YXIgY2hlY2s7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAnJG5vdCc6XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdmFyIGZvbGxvdyA9IGhhbmRsZVRlc3QodmFsdWUsIHN1YnNPYmopO1xuICAgICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgIHJldHVybiBmb2xsb3coZG9jKSA9PT0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgIHJldHVybiBkb2MgIT09IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5lJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MgIT09IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRhbmQnOlxuICAgICAgdmFyIGxpc3QgPSBtYWtlTGlzdCh2YWx1ZSwgc3Vic09iaik7XG4gICAgICBjaGVjayA9IG1ha2VBTkQobGlzdCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmFuZCc6XG4gICAgICB2YXIgbGlzdCA9IG1ha2VMaXN0KHZhbHVlLCBzdWJzT2JqKTtcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAobGlzdFtpXShkb2MpID09PSBmYWxzZSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRvcic6XG4gICAgICB2YXIgbGlzdCA9IG1ha2VMaXN0KHZhbHVlLCBzdWJzT2JqKTtcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAobGlzdFtpXShkb2MpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5vcic6XG4gICAgICB2YXIgbGlzdCA9IG1ha2VMaXN0KHZhbHVlLCBzdWJzT2JqKTtcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAobGlzdFtpXShkb2MpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGV2ZXJ5JzpcbiAgICAgIHN1YnNPYmouc2V0KCckJywge30pO1xuICAgICAgLy8gc3Vic09iai4kID0ge1xuICAgICAgLy8gICBfdXA6IHN1YnNPYmpcbiAgICAgIC8vIH07XG4gICAgICB2YXIgZm9sbG93ID0gaGFuZGxlVGVzdCh2YWx1ZSwgc3Vic09iai4kKTtcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGlmIChkb2MgJiYgZG9jLl9fdCA8IDMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICBkb2MuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghZm9sbG93KHRoaXMpKSByZXR1cm4gIShyZXN1bHQgPSBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmV2ZXJ5JzpcbiAgICAgIHN1YnNPYmouc2V0KCckJywge30pO1xuICAgICAgLy8gc3Vic09iai4kID0ge1xuICAgICAgLy8gICBfdXA6IHN1YnNPYmpcbiAgICAgIC8vIH07XG4gICAgICB2YXIgZm9sbG93ID0gaGFuZGxlVGVzdCh2YWx1ZSwgc3Vic09iai4kKTtcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGlmIChkb2MgJiYgZG9jLl9fdCA8IDMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgICAgZG9jLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWZvbGxvdyh0aGlzKSkgcmV0dXJuIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyQnOlxuICAgIGNhc2UgJyRzb21lJzpcbiAgICAgIHN1YnNPYmouc2V0KCckJywge30pO1xuICAgICAgLy8gc3Vic09iai4kID0ge1xuICAgICAgLy8gICBfdXA6IHN1YnNPYmpcbiAgICAgIC8vIH07XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdmFyIGZvbGxvdyA9IGhhbmRsZVRlc3QodmFsdWUsIHN1YnNPYmouJCk7XG4gICAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgaWYgKGRvYyAmJiBkb2MuX190IDwgMykge1xuICAgICAgICAgICAgdmFyIGZvdW5kO1xuICAgICAgICAgICAgZG9jLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmIChmb2xsb3codGhpcykpIHJldHVybiBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCB8fCBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICBpZiAoZG9jICYmIGRvYy5fX3QgPCAzKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQ7XG4gICAgICAgICAgICBkb2MuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMgPT09IHZhbHVlKSByZXR1cm4gZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgfHwgZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3Vic09iai4kLl9jaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgIHJldHVybiBkb2MgPT09IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5zb21lJzpcbiAgICAgIHN1YnNPYmouc2V0KCckJywge30pO1xuICAgICAgLy8gc3Vic09iai4kID0ge1xuICAgICAgLy8gICBfdXA6IHN1YnNPYmpcbiAgICAgIC8vIH07XG4gICAgICB2YXIgZm9sbG93ID0gaGFuZGxlVGVzdCh2YWx1ZSwgc3Vic09iai4kKTtcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGlmIChkb2MgJiYgZG9jLl9fdCA8IDMpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICBkb2MuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChmb2xsb3codGhpcykpIHJldHVybiAhKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGx0JzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdidXJrIGx0JywgZG9jLCB2YWx1ZSlcbiAgICAgICAgcmV0dXJuIGRvYyA8IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRsdGUnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYyA8PSB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckZ3QnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYyA+IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRndGUnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYyA+PSB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckY29udGFpbnMnOlxuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCh2YWx1ZSwgJ2knKTtcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KGRvYyk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5jb250YWlucyc6XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHZhbHVlLCAnaScpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuICFyZWdleC50ZXN0KGRvYyk7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGNvbnRhaW5zYWxsJzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuY29udGFpbnNhbGwnOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGhhcyc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jICYmIGRvY1t2YWx1ZV0gIT09IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmhhcyc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gIWRvYyB8fCBkb2NbdmFsdWVdID09PSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGV4aXN0cyc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gKGRvYyAhPT0gdm9pZCAwICYmIGRvYyAhPT0gbnVsbCkgPT09IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRpbic6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChkb2MgPT09IHZhbHVlW2ldKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5pbic6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChkb2MgPT09IHZhbHVlW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJHJlZ2V4JzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50ZXN0KGRvYyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHZhciBkc3Vic09iaiA9IHN1YnNPYmpba2V5XTtcblxuICAgICAgICBpZiAoZHN1YnNPYmopIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYWxyZWFkeSBtYWRlIHRoYXQgZHN1YnNPYmogd2l0aCBrZXknLCBrZXkpO1xuICAgICAgICAgIC8vIGRzdWJzT2JqLl91cCA9IHN1YnNPYmpcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdWJzT2JqLnNldChrZXksIHt9KTtcbiAgICAgICAgICBkc3Vic09iaiA9IHN1YnNPYmpba2V5XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9sbG93ID0gaGFuZGxlVGVzdCh2YWx1ZSwgZHN1YnNPYmopO1xuXG4gICAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1RFU1RJTkc6IGNoZWNrIE9CSkVDVCcsIGRvYyAmJiBkb2MucmF3IHx8IGRvYywgJ2ZvciBmaWVsZCcsIGtleSlcbiAgICAgICAgICBkb2MgPSBnZXRGaWVsZChkb2MsIGtleSlcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd3dXBzJywgZG9jICYmIGRvYy5yYXcgfHwgZG9jKVxuICAgICAgICAgIHJldHVybiBmb2xsb3coZG9jKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgZG9jID0gZ2V0RmllbGQoZG9jLCBrZXkpXG4gICAgICAgICAgXG4gICAgICAgICAgLy8gZG9jID0gZ2V0VmFsdWUoZG9jKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdURVNUSU5HOiBjaGVjayBWQUxVRScsIGRvYyAmJiBkb2MucmF3IHx8IGRvYywgdmFsdWUsIGRvYyA9PT0gdmFsdWUpXG4gICAgICAgICAgcmV0dXJuIGRvYyA9PT0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHN1YnNPYmouc2V0KGtleSwge30pO1xuICAgICAgICBzdWJzT2JqW2tleV0uX2NoZWNrID0gY2hlY2tcbiAgICAgICAgLy8gc3Vic09ialtrZXldID0ge1xuICAgICAgICAvLyAgIF91cDogc3Vic09iaixcbiAgICAgICAgLy8gICBfY2hlY2s6IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAvLyAgICAgcmV0dXJuIGRvYyA9PT0gdmFsdWU7XG4gICAgICAgIC8vICAgfVxuICAgICAgICAvLyB9O1xuICAgICAgfVxuXG4gIH1cbiAgcmV0dXJuIHN1YnNPYmogPyBzdWJzT2JqLl9jaGVjayA9IGNoZWNrIDogY2hlY2s7XG59XG5cbmZ1bmN0aW9uIG1ha2VMaXN0KGFyciwgc3Vic09iaikge1xuICB2YXIgbGlzdCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsaXN0LnB1c2goaGFuZGxlVGVzdChhcnJbaV0sIHN1YnNPYmopKTtcbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuZnVuY3Rpb24gbWFrZUFORChsaXN0LCBzdWJzT2JqKSB7XG4gIHJldHVybiBmdW5jdGlvbihkb2MpIHtcbiAgICB2YXIgdmFsID0gZ2V0VmFsdWUoZG9jKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAobGlzdFtpXSh2YWwpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUodGhpbmcpe1xuICB2YXIgdmFsID0gdGhpbmcgJiYgdGhpbmcuZnJvbSAmJiB0aGluZy5mcm9tLnZhbFxuICByZXR1cm4gdmFsICE9PSB2b2lkIDAgPyB2YWwgOiB0aGluZ1xuICBcbn1cbmZ1bmN0aW9uIGdldEZpZWxkKHRoaW5nLCBmaWVsZCl7XG4gIC8vIGNvbnNvbGUuZXJyb3IoJ2dldEZpZWxkIGZpZWxkJywgZmllbGQsICdmcm9tJywgdGhpbmcgJiYgdGhpbmcucmF3IHx8IHRoaW5nKVxuICB0aGluZyA9IGdldFZhbHVlKHRoaW5nKVxuICByZXR1cm4gdGhpbmcgPyBnZXRWYWx1ZSh0aGluZ1tmaWVsZF0pIDogdm9pZCAwXG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIFYgPSByZXF1aXJlKCd2aWdvdXItanMnKSxcbiAgb2JqZWN0ID0gcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdCcpLFxuICB1dGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gVi5EYXRhID0gb2JqZWN0Lm5ldygpO1xuZXhwb3J0cy5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfX3N1YicsJ19fYmxvY2snKTtcbnV0aWwuZGVmaW5lKGV4cG9ydHMsICdfaG9vaycsIGZ1bmN0aW9uKHZhbCwgb2JqKSB7XG4gIGlmIChvYmouc3Vic2NyaXB0aW9uKSB7XG4gICAgdGhpcy5fX3N1YiA9IG9iai5zdWJzY3JpcHRpb247XG4gICAgZGVsZXRlIG9iai5zdWJzY3JpcHRpb247XG4gIH1cbiAgaWYob2JqLmJsb2NrKSB7XG4gICAgdGhpcy5fX2Jsb2NrID0gdHJ1ZVxuICAgIGRlbGV0ZSBvYmouYmxvY2tcbiAgfVxufSk7XG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IE1hcmN1cyBCZXNqZXMsIG1hcmN1c0B2aWdvdXIuaW9cbiAqL1xuXG52YXIgY29uZGl0aW9ucyA9IHJlcXVpcmUoJy4vY29uZGl0aW9ucycpXG4gICwgdXRpbEhhc2ggPSByZXF1aXJlKCcuLi91dGlsL2hhc2gnKVxuICAsIFZPYmplY3QgPSByZXF1aXJlKCcuLi9vYmplY3QnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBTZWxlY3Rpb25cbiAqIENsYXNzIGV4dGVudGlvbiBmb3Igc2VsZWN0aW9uIC8gZmlsdGVyaW5nIGZ1bmN0aW9uYWxpdHlcbiAqIEBDbGFzc1xuICovXG5cbmV4cG9ydHMuU3Vic09iaiA9IFZPYmplY3QubmV3KClcbmV4cG9ydHMuU3Vic09iai5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCAnX3Jvb3QnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ19jaGVjaydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX3NvcnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ191aWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbihiYXNlKXtcblxuICBiYXNlLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goICdfZmlsdGVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdfdWlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdfaGFzaCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX2luZGV4Q2FjaGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ19zdWJzY250J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG5cbiAgdmFyIF91cGRhdGUgPSBiYXNlLnByb3RvdHlwZS5fdXBkYXRlXG4gICAgLCBfaG9vayA9IGJhc2UucHJvdG90eXBlLl9ob29rXG4gICAgLCBfcmVtb3ZlID0gYmFzZS5wcm90b3R5cGUucmVtb3ZlXG5cbiAgdXRpbC5kZWZpbmUoIGJhc2VcbiAgICAsICdyZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxcbiAgICAgICAgaWYodGhpcy5fZmlsdGVyICYmIChsID0gdGhpcy5sZW5ndGgpKXtcbiAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbDsgaSsrKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXNbaV1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3JlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICB9XG4gICAgLCAnZmlsdGVyJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maWx0ZXJcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbmV3IGZpbHRlciBcXG4gZnJvbSAtLS0+JywgdGhpcy5fZmlsdGVyLCAnXFxuIHRvIC0tLS0+J1xuICAgICAgICAgIC8vICAgICAgICAgICAgLCB2YWxcbiAgICAgICAgICAvLyAgICAgICAgICAgIClcbiAgICAgICAgICB0aGlzLl9maWx0ZXIgPSB2YWwgLy9tb2V0IG9vayB3ZXJrZW4gYWxzIGRhdGEgbm9nIGdlZW4gc2VsZWN0aW9uIGlzXG4gICAgICAgICAgdGhpcy5fYnVpbGQodW5kZWZpbmVkLCB0cnVlKVxuICAgICAgICAgIF91cGRhdGUuY2FsbCggdGhpcywgdm9pZCAwLCB0aGlzLnN0YW1wKCksIHZvaWQgMCwgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAsIGZhbHNlLCB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAsICdfaG9vaycsIGZ1bmN0aW9uKHZhbCwgZmlsdGVyKSB7XG4gICAgICAgIGlmIChfaG9vaykge1xuICAgICAgICAgIF9ob29rLmNhbGwodGhpcywgdmFsLCBmaWx0ZXIpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmVtcHR5KGZpbHRlcikgJiYgdmFsKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXNcbiAgICAgICAgICBzZWxlY3Rpb24uX3N1YnNjbnQgPSAwXG4gICAgICAgICAgc2VsZWN0aW9uLl9maWx0ZXIgPSBmaWx0ZXJcblxuICAgICAgICAgIHNlbGVjdGlvbi5faGFzaCA9IHV0aWxIYXNoKHZhbC5fcGF0aCArIEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgWyBmaWx0ZXIuY29uZGl0aW9uXG4gICAgICAgICAgICAsIGZpbHRlci5yYW5nZVxuICAgICAgICAgICAgLCBmaWx0ZXIuc29ydFxuICAgICAgICAgICAgXSlcbiAgICAgICAgICApXG4gICAgICAgICAgLy8hb25seSBuZXNzZWNhcnkgc2VydmVyc2lkZSFcbiAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5fdWlkKSBzZWxlY3Rpb24uX3VpZCA9IHNlbGVjdGlvbi5faGFzaFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICwgJ19idWlsZCcsIGZ1bmN0aW9uKHZhbCwgbm91cGRhdGUpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXNcbiAgICAgICAgXG4gICAgICAgIGlmICghdmFsKSB2YWwgPSBzZWxlY3Rpb24uX3ZhbFxuICAgICAgICBpZighdmFsKSByZXR1cm5cbiAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGgpIHNlbGVjdGlvbi5fY2xlYXIoKSBcblxuICAgICAgICB2YXIgbGlzdCA9IFtdXG4gICAgICAgICAgLCBpdGVtc0hhbmRsZXIgPSB0aGlzLl9pdGVtc0hhbmRsZXJcbiAgICAgICAgICAsIGZpbHRlciA9IHNlbGVjdGlvbi5fZmlsdGVyXG4gICAgICAgICAgLCBzdWJzT2JqID0gZmlsdGVyLnN1YnNPYmogfHwgbmV3IGV4cG9ydHMuU3Vic09iaih7fSwgc2VsZWN0aW9uKVxuICAgICAgICAgICwgc3RhbXAgPSB0aGlzLnN0YW1wKClcbiAgICAgICAgICAsIHNvcnQsIGl0ZW1cblxuICAgICAgICBpZiAodmFsLl9fdCA9PT0gNCAmJiAhdmFsLl9maWx0ZXIpIHtcbiAgICAgICAgICB2YWwgPSB2YWwuZnJvbTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWx0ZXIuc29ydCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgZmlsdGVyLnNvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmaWx0ZXIuc29ydCA9IHtcbiAgICAgICAgICAgICAgZmllbGQ6IGZpbHRlci5zb3J0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNvcnQgPSBmaWx0ZXIuc29ydFxuICAgICAgICAgIGlmICghc29ydC5mbikge1xuICAgICAgICAgICAgaWYgKCFzb3J0LnR5cGUpIHNvcnQudHlwZSA9ICdzdHJpbmcnXG4gICAgICAgICAgICBzb3J0LmZuID0gc29ydE1ha2Vyc1tzb3J0LnR5cGVdKHNvcnQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHN1YnNPYmoucGF0aChzb3J0LmZpZWxkLnNwbGl0KCcuJyksIHt9KS5zZXQoJ19zb3J0JywgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnYnVpbGRpbmc/IScpXG4gICAgICAgIGlmIChmaWx0ZXIuY29uZGl0aW9uKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZvdW5kIGNvbmRpdGlvbicsIGZpbHRlci5jb25kaXRpb24pXG4gICAgICAgICAgdmFyIHBjbnQgPSAwXG4gICAgICAgICAgICAsIHJjbnQgPSAwXG4gICAgICAgICAgdmFyIGNoZWNrID0gZmlsdGVyLmNoZWNrIFxuICAgICAgICAgICAgICAgICB8fCAoIGZpbHRlci5jaGVjayA9IGNvbmRpdGlvbnMoIGZpbHRlci5jb25kaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCBzdWJzT2JqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgIGZpbHRlci5zdWJzT2JqID0gc3Vic09ialxuICAgICAgICAgIHZhbC5lYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIGl0ZW0gPSB0aGlzXG4gICAgICAgICAgICBpZiAoaXRlbXNIYW5kbGVyKSBpdGVtc0hhbmRsZXIoaXRlbSwgc3Vic09iaiwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgaWYgKGNoZWNrKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIHBjbnQrK1xuICAgICAgICAgICAgICBsaXN0LnB1c2goaXRlbSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uLl9oYXMoaXRlbSkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0gPiByZW1vdmVkIGZyb20gc2VsZWN0aW9uIGJ5IGNvbmRpdGlvbjonXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICwgaXRlbS5yYXdcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB1bnN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgICBpZighbm91cGRhdGUpe1xuICAgICAgICAgICAgICAgIF91cGRhdGUuY2FsbChzZWxlY3Rpb24sIGl0ZW0sIHN0YW1wLCBzZWxlY3Rpb24sIGl0ZW0sIGZhbHNlLCBudWxsKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJjbnQrK1xuICAgICAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgICAgIHJjbnQrK1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JhbiBjb25kaXRpb246IHBhc3NlZDonLCBwY250LCAncmVqZWN0czonLCByY250KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGl0ZW1zSGFuZGxlcikgaXRlbXNIYW5kbGVyKHRoaXMsIHN1YnNPYmosIHNlbGVjdGlvbilcbiAgICAgICAgICAgIGxpc3QucHVzaCh0aGlzKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXIuc3Vic09iaiA9IHN1YnNPYmpcblxuICAgICAgICBpZiAoc29ydCAmJiBsaXN0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBsaXN0LnNvcnQoZmlsdGVyLnNvcnQuZm4pXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaSwgaXRlbVxuXG4gICAgICAgIHZhciByYW5nZSA9IGZpbHRlci5yYW5nZVxuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgcmFuZ2UgPSBmaWx0ZXIucmFuZ2UgPSBbMCwgZmlsdGVyLnJhbmdlXVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobGlzdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBuZXdsaXN0ID0gbGlzdC5zcGxpY2UocmFuZ2VbMF0sIHJhbmdlWzFdKVxuICAgICAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGg7IGl0ZW0gPSBsaXN0Wy0taV07KSB7XG4gICAgICAgICAgICAgIGlmKHNlbGVjdGlvbi5faGFzKGl0ZW0pICE9PSB2b2lkIDApe1xuICAgICAgICAgICAgICAgIHVuc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgLy8gaWYoIW5vdXBkYXRlKXtcbiAgICAgICAgICAgICAgICAvLyAgIF91cGRhdGUuY2FsbChzZWxlY3Rpb24sIGl0ZW0sIHN0YW1wLCBzZWxlY3Rpb24sIGl0ZW0sIGZhbHNlXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAsIG51bGxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QgPSBuZXdsaXN0XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoLCBpdGVtOyBpdGVtID0gbGlzdFstLWldOykge1xuICAgICAgICAgIHNlbGVjdGlvbltpXSA9IGl0ZW1cbiAgICAgICAgICB2YXIgaXNuZXcgPSBzZWxlY3Rpb24uX2hhcyhpdGVtKSA9PT0gdm9pZCAwXG4gICAgICAgICAgc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24sIGkpXG4gICAgICAgICAgLy8gaWYgKGlzbmV3KSB7XG4gICAgICAgICAgLy8gICBpZighbm91cGRhdGUpe1xuICAgICAgICAgIC8vICAgICBjb25zb2xlLmxvZygnZG9pbmcgdXBkYXRlIHdpY2tlZHMnKVxuICAgICAgICAgIC8vICAgICBfdXBkYXRlLmNhbGwoc2VsZWN0aW9uLCBpdGVtLCBzdGFtcCwgc2VsZWN0aW9uLCBmYWxzZSwgaXRlbSwgbnVsbCkgIFxuICAgICAgICAgIC8vICAgfVxuICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb24ubGVuZ3RoID0gbGlzdC5sZW5ndGhcbiAgICAgIH1cbiAgICAsICdfdXBkYXRlJywgZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZpbHRlcikge1xuICAgICAgICAgICAvLyBpZih3aW5kb3cuaGVyZSkgY29uc29sZS5sb2coJ2h1cHMgX3VwZGF0ZSBvbiBzZWxlY3Rpb24hJylcblxuICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzXG4gICAgICAgICAgICAsIHVwYXRoID0gc2VsZWN0aW9uLnVwZGF0ZVBhdGhcblxuICAgICAgICAgIGlmICh1cGF0aFswXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgc2hvcnRwYXRoID0gdXBhdGgubGVuZ3RoID09PSAxXG4gICAgICAgICAgICAgICwgaXRlbXJlbW92ZSA9IHNob3J0cGF0aCAmJiByZW1vdmVcbiAgICAgICAgICAgICAgLCBpdGVtID0gaXRlbXJlbW92ZSA/IHNlbGVjdGlvbi5fbGZyb20gOiBzZWxlY3Rpb24udmFsW3VwYXRoWzBdXVxuICAgICAgICAgICAgICAsIHJlbGV2YW50XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uX3ZhbC5fZmlsdGVyKSB7XG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uX3ZhbC5faGFzKGl0ZW0pID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLl9oYXMoaXRlbSkgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLl9jaGVja0l0ZW0oaXRlbSwgZmFsc2UsIHZhbCwgc3RhbXApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaGludCA9IGl0ZW1yZW1vdmUgPyBmYWxzZSA6IChzaG9ydHBhdGggJiYgYWRkZWQpID8gdm9pZCAwIDogdXBhdGhcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5fY2hlY2tJdGVtKGl0ZW0sIGhpbnQsIHZhbCwgc3RhbXApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfdXBkYXRlLmFwcGx5KHNlbGVjdGlvbiwgYXJndW1lbnRzKSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2hpdCBvbiBzZWxlY3Rpb24gaXRzZWxmPyEnKVxuICAgICAgICAgICAgaWYgKCFmcm9tKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdcXG4+Pj4+Pj4gaGl0IG9uIHNlbGVjdGlvbiBpdHNlbGYgKFYuRGF0YSknKVxuICAgICAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGgpIHNlbGVjdGlvbi5fY2xlYXIoKSAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fYnVpbGQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3VwZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAvLyBpZih3aW5kb3cuaGVyZSkgY29uc29sZS5sb2coJ2h1cHMgX3VwZGF0ZSBvbiBzZWxlY3Rpb24hJyx0aGlzKVxuICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU0VMRUNUJywgdGhpcywgYXJndW1lbnRzLCB0aGlzLl9wYXRoKVxuICAgICAgICAgIHJldHVybiBfdXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICwgJ19oYXMnLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIHZhciBpbmRleENhY2hlID0gaXRlbS5faW5kZXhDYWNoZVxuICAgICAgICAgICwgdWlkID0gdGhpcy5fdWlkXG4gICAgICAgICAgLCBpY1xuXG4gICAgICAgIGlmIChpbmRleENhY2hlICYmIHVpZCAmJiAoaWMgPSBpbmRleENhY2hlW3VpZF0pKSB7XG4gICAgICAgICAgcmV0dXJuIGljWzBdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAsICdfY2xlYXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgIHNlbGYuZWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgc2VsZltmXSA9IHZvaWQgMFxuICAgICAgICAgIGRlbGV0ZSBzZWxmW2ZdXG4gICAgICAgIH0pXG4gICAgICAgIHNlbGYubGVuZ3RoID0gMFxuICAgICAgfVxuICAgICwgJ19jaGVja0l0ZW0nLCBmdW5jdGlvbihpdGVtLCBoaW50LCB2YWwsIHN0YW1wKSB7XG4gICAgICAgIGlmKCFpdGVtKSB7IHJldHVybiB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdfY2hlY2tJdGVtIScsIGl0ZW0ucmF3LCBoaW50KVxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpc1xuICAgICAgICAgICwgZnJvbSA9IGl0ZW1cbiAgICAgICAgICAsIGZpbHRlciA9IHNlbGVjdGlvbi5fZmlsdGVyXG4gICAgICAgICAgLCBzb3J0ID0gZmlsdGVyLnNvcnRcbiAgICAgICAgICAsIHJhbmdlID0gZmlsdGVyLnJhbmdlXG4gICAgICAgICAgLCByYW5nZWQgPSByYW5nZSAmJiAhKCAgcmFuZ2VbMF0gPT09IDAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJiYgcmFuZ2VbMV0gPj0gc2VsZWN0aW9uLl92YWwubGVuZ3RoIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHx8IHNlbGVjdGlvbi5sZW5ndGggPCByYW5nZVsxXSAtIHJhbmdlWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICwgcmVtb3ZlZCA9IGhpbnQgPT09IGZhbHNlIHx8IGl0ZW0uX3JlbW92ZWRcbiAgICAgICAgICAsIGFkZGVkLCBpbmRleCwgaXNpblxuICAgICAgICAgICwgcmVzdWx0ID0gaXNpbiA9IChpbmRleCA9IHNlbGVjdGlvbi5faGFzKGl0ZW0pKSAhPT0gdm9pZCAwXG5cbiAgICAgICAgdmFyIGNoZWNrID0gZmlsdGVyLmNoZWNrXG4gICAgICAgICAgLCBwYXNzID0gcmVtb3ZlZCBcbiAgICAgICAgICAgICAgICAgICA/IGZhbHNlIFxuICAgICAgICAgICAgICAgICAgIDogKCFyYW5nZWQgJiYgaGludCA9PT0gMSkgXG4gICAgICAgICAgICAgICAgICAgICA/IGlzaW4gXG4gICAgICAgICAgICAgICAgICAgICA6ICFjaGVjayB8fCBjaGVjayhpdGVtKVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09IGNoZWNraXRlbSBpbicsIHNlbGVjdGlvbi5fcGF0aClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2l0ZW13ZXgnLCBpdGVtLl92YWwgJiYgaXRlbS5fdmFsLnJhdylcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2lzaW4nLCBpc2luLCAncGFzcycsIHBhc3MsICdyZXN1bHQnLCByZXN1bHQpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tIGNoZWNrZWQgaXRlbScsIHBhc3MpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVkPycsIHJlbW92ZWQpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdyYW5nZWQ/IChwYXNzID09IGFscmVhZHkgaW4pJywgKCFyYW5nZWQgJiYgaGludCA9PT0gMSksIGlzaW4pXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvayB0aW1lIGZvciBjaGVja2luZycsIGNoZWNrKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY29uZGl0aW9ucycsIGZpbHRlci5jb25kaXRpb24pXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjaGVjaz8nLCBjaGVjayAmJiBjaGVjayhpdGVtKSlcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0nKVxuICAgICAgICBcbiAgICAgICAgaWYgKGlzaW4gIT09IHBhc3MpIHtcbiAgICAgICAgICBpZiAoaXNpbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgdW5zdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbilcbiAgICAgICAgICAgIHJlbW92ZWQgPSBpdGVtXG4gICAgICAgICAgICB2YXIgbWFya1xuICAgICAgICAgICAgd2hpbGUgKG1hcmsgPSBzZWxlY3Rpb25bKytpbmRleF0pIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW2luZGV4IC0gMV0gPSBtYXJrXG4gICAgICAgICAgICAgIHN0b3JlSW5kZXgobWFyaywgc2VsZWN0aW9uLCBpbmRleCAtIDEpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbmQgPSBpbmRleCAtIDFcbiAgICAgICAgICAgIHNlbGVjdGlvbltlbmRdID0gbnVsbFxuICAgICAgICAgICAgZGVsZXRlIHNlbGVjdGlvbltlbmRdXG5cbiAgICAgICAgICAgIHZhciByZXBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHJhbmdlZCkge1xuICAgICAgICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fdmFsLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoICBzZWxlY3Rpb24uX2hhcyh0aGlzKSA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICAgICAgICAgJiYgKCFzZWxlY3Rpb25bZW5kXSB8fCBzb3J0LmZuKHRoaXMsIHNlbGVjdGlvbltlbmRdKSA8IDApIFxuICAgICAgICAgICAgICAgICAgICAgJiYgKCFjaGVjayB8fCBjaGVjayh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHNlbGVjdGlvbltlbmRdID0gdGhpc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLl92YWwuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmICggc2VsZWN0aW9uLl9oYXModGhpcykgPT09IHZvaWQgMCBcbiAgICAgICAgICAgICAgICAgICAgICYmICghY2hlY2sgfHwgY2hlY2sodGhpcykpXG4gICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VtZW50ID0gc2VsZWN0aW9uW2VuZF0gPSB0aGlzXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb24ubGVuZ3RoLS1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0b3JlSW5kZXgocmVwbGFjZW1lbnQsIHNlbGVjdGlvbiwgaW5kZXggLSAxKVxuICAgICAgICAgICAgICBhZGRlZCA9IHJlcGxhY2VtZW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuZXdpbmRleFxuICAgICAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgICAgdmFyIHNvcnRmbiA9IHNvcnQuZm5cbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc29ydGZuKGl0ZW0sIHRoaXMpIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3aW5kZXggPSBmXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobmV3aW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDFcbiAgICAgICAgICAgICAgICBuZXdpbmRleCA9IE51bWJlcihuZXdpbmRleClcbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbiwgbmV3aW5kZXgpXG4gICAgICAgICAgICAgICAgYWRkZWQgPSBpdGVtXG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHNlbGVjdGlvbltzZWxlY3Rpb24ubGVuZ3RoIC0gMV1cbiAgICAgICAgICAgICAgICAgIHVuc3RvcmVJbmRleChyZW1vdmVkLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMubGVuZ3RoKytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gc2VsZWN0aW9uLmxlbmd0aCAtIDJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPj0gbmV3aW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIHN0b3JlSW5kZXgoc2VsZWN0aW9uW2luZGV4XSwgc2VsZWN0aW9uLCBpbmRleCArIDEpXG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb25baW5kZXggKyAxXSA9IHNlbGVjdGlvbltpbmRleC0tXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25bbmV3aW5kZXhdID0gaXRlbVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFyYW5nZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAxXG4gICAgICAgICAgICAgICAgbmV3aW5kZXggPSBzZWxlY3Rpb24ubGVuZ3RoKytcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25bbmV3aW5kZXhdID0gaXRlbVxuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uLCBuZXdpbmRleClcbiAgICAgICAgICAgICAgICBhZGRlZCA9IGl0ZW1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghcmFuZ2VkKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IDFcbiAgICAgICAgICAgICAgbmV3aW5kZXggPSBzZWxlY3Rpb24ubGVuZ3RoKytcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW25ld2luZGV4XSA9IGl0ZW1cbiAgICAgICAgICAgICAgc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24sIG5ld2luZGV4KVxuICAgICAgICAgICAgICBhZGRlZCA9IGl0ZW1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNpbiAmJiBzb3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz8/PycsIHNvcnQsIHNvcnQuZmllbGQsIGhpbnQpXG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaXNpbiArIHNvcnQhIHJlc29ydD8nKVxuICAgICAgICAgIGlmIChoaW50ICYmIGhpbnQubGVuZ3RoICYmIHNvcnQuZmllbGQpIHtcbiAgICAgICAgICAgIGlmICh+c29ydC5maWVsZC5pbmRleE9mKCcuJykpIHtcbiAgICAgICAgICAgICAgdmFyIHNvcnRwYXRoID0gc29ydC5maWVsZC5zcGxpdCgnLicpXG4gICAgICAgICAgICAgIGlmICghdXRpbC5jb21wYXJlQXJyYXlzKGhpbnQuc2xpY2UoMSksIHNvcnRwYXRoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGhpbnRbMV0gIT09IHNvcnQuZmllbGQpIHJldHVybiByZXN1bHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zb2xlLmxvZygnPycpXG5cbiAgICAgICAgICB2YXIgbmV3aW5kZXhcbiAgICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICBpZiAoZiAhPSBpbmRleCkge1xuICAgICAgICAgICAgICB2YXIgcyA9IHNvcnQuZm4oaXRlbSwgdGhpcylcbiAgICAgICAgICAgICAgaWYgKHMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGYgPT0gaW5kZXggKyAxKSByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIG5ld2luZGV4ID0gZiA8IGluZGV4ID8gZiA6IGYgLSAxXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmID49IGluZGV4ICsgMSAmJiBzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBuZXdpbmRleCA9IGZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCduZXdpbmRleCcsIG5ld2luZGV4KVxuICAgICAgICAgIGlmIChuZXdpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAxXG4gICAgICAgICAgICB2YXIgdG1wXG4gICAgICAgICAgICBpZiAoaW5kZXggPiBuZXdpbmRleCkge1xuICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPiBuZXdpbmRleCkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHNlbGVjdGlvbltpbmRleF0gPSBzZWxlY3Rpb25bLS1pbmRleF1cbiAgICAgICAgICAgICAgICBpZiAodG1wKSBzdG9yZUluZGV4KHRtcCwgc2VsZWN0aW9uLCBpbmRleCArIDEpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IG5ld2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdG1wID0gc2VsZWN0aW9uW2luZGV4XSA9IHNlbGVjdGlvblsrK2luZGV4XVxuICAgICAgICAgICAgICAgIGlmICh0bXApIHN0b3JlSW5kZXgodG1wLCBzZWxlY3Rpb24sIGluZGV4IC0gMSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZWN0aW9uW25ld2luZGV4XSA9IGl0ZW1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZW5kID0gc2VsZWN0aW9uLmxlbmd0aCAtIDFcblxuICAgICAgICAgIGlmICggIHJhbmdlZCBcbiAgICAgICAgICAgICAmJiAobmV3aW5kZXggPT0gZW5kIHx8IG5ld2luZGV4ID09PSB2b2lkIDAgXG4gICAgICAgICAgICAgJiYgaW5kZXggPT0gZW5kKVxuICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgdmFyIHJlcGxhY2VkXG4gICAgICAgICAgICBzZWxlY3Rpb24uX3ZhbC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoICBzZWxlY3Rpb24uX2hhcyh0aGlzKSA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICAgICAmJiBzb3J0LmZuKHRoaXMsIGl0ZW0pID09PSAtMSBcbiAgICAgICAgICAgICAgICAgJiYgKCFjaGVjayB8fCBjaGVjayh0aGlzKSlcbiAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXBsYWNlZCkgcmVwbGFjZWQgPSBpdGVtXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW2VuZF0gPSBpdGVtID0gdGhpc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24sIGVuZClcbiAgICAgICAgICAgIGlmIChyZXBsYWNlZCkge1xuICAgICAgICAgICAgICB1bnN0b3JlSW5kZXgocmVwbGFjZWQsIHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgcmVtb3ZlZCA9IHJlcGxhY2VkXG4gICAgICAgICAgICAgIGFkZGVkID0gaXRlbVxuICAgICAgICAgICAgICByZXN1bHQgPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXdpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBzdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbiwgTnVtYmVyKG5ld2luZGV4KSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0ID09PSAxKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3VwZGF0ZSBmcm9tIF9jaGVja0l0ZW0hJylcbiAgICAgICAgICBzZWxlY3Rpb24uX191cGRhdGUodmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlZCwgYWRkZWQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgIClcblxufSlcblxudmFyIHN0b3JlSW5kZXggPSBleHBvcnRzLnN0b3JlSW5kZXggPSBmdW5jdGlvbihpdGVtLCBzZWxlY3Rpb24sIGluZGV4KSB7XG4gIC8vIGNvbnNvbGUubG9nKCdzdG9yZUluZGV4ISBpdGVtJywgaXRlbS5fbmFtZSwgJ0AnLCBpbmRleClcbiAgdmFyIGluZGV4Q2FjaGUgPSBpdGVtLl9pbmRleENhY2hlXG4gICAgLCBpY1xuICBpZiAoaW5kZXhDYWNoZSkge1xuICAgIGljID0gaW5kZXhDYWNoZVtzZWxlY3Rpb24uX3VpZF1cbiAgICBpZiAoaWMpIHtcbiAgICAgIGljWzFdID0gaWNbMF1cbiAgICAgIGljWzBdID0gaW5kZXhcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kZXhDYWNoZVtzZWxlY3Rpb24uX3VpZF0gPSBbaW5kZXhdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGl0ZW0uX2luZGV4Q2FjaGUgPSB7fVxuICAgIGl0ZW0uX2luZGV4Q2FjaGVbc2VsZWN0aW9uLl91aWRdID0gW2luZGV4XVxuICB9XG59XG5cbnZhciB1bnN0b3JlSW5kZXggPSBleHBvcnRzLnVuc3RvcmVJbmRleCA9IGZ1bmN0aW9uKGl0ZW0sIHNlbGVjdGlvbikge1xuICB2YXIgaW5kZXhDYWNoZSA9IGl0ZW0uX2luZGV4Q2FjaGVcbiAgaWYgKGluZGV4Q2FjaGUpIHtcbiAgICB2YXIgaWMgPSBpbmRleENhY2hlW3NlbGVjdGlvbi5fdWlkXVxuICAgIGljWzFdID0gaWNbMF1cbiAgICBpY1swXSA9IHZvaWQgMFxuICB9XG59XG5cbnZhciBzb3J0TWFrZXJzID0ge1xuICBudW1iZXI6IGZ1bmN0aW9uKHNvcnQpIHtcbiAgICB2YXIgZmllbGQgPSBzb3J0LmZpZWxkXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIHZhciB2YSA9IGFbZmllbGRdICYmIGFbZmllbGRdLnZhbFxuICAgICAgICAsIHZiID0gYltmaWVsZF0gJiYgYltmaWVsZF0udmFsXG4gICAgICBpZiAodmEgPT09IHZvaWQgMCB8fCB2YiA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHJldHVybiB2YSA9PT0gdmIgXG4gICAgICAgICAgICAgICA/IDAgXG4gICAgICAgICAgICAgICA6IHZhID09PSB2b2lkIDAgXG4gICAgICAgICAgICAgICAgID8gMSBcbiAgICAgICAgICAgICAgICAgOiAtMVxuICAgICAgfVxuICAgICAgcmV0dXJuIHNvcnQub3JkZXIgXG4gICAgICAgICAgICAgPyAodmEgLSB2YikgKiAtMSBcbiAgICAgICAgICAgICA6IHZhIC0gdmJcbiAgICB9XG4gIH0sXG4gIHN0cmluZzogZnVuY3Rpb24oc29ydCkge1xuICAgIHZhciBmaWVsZCA9IHNvcnQuZmllbGRcbiAgICBpZiAofmZpZWxkLmluZGV4T2YoJy4nKSkge1xuICAgICAgdmFyIHBhdGggPSBmaWVsZC5zcGxpdCgnLicpXG4gICAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBhID0gZ2V0RG90RmllbGRWYWwoYSwgcGF0aClcbiAgICAgICAgYiA9IGdldERvdEZpZWxkVmFsKGIsIHBhdGgpXG4gICAgICAgIGlmIChhID09PSB2b2lkIDAgfHwgYiA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0dXJuIGEgPT09IGIgXG4gICAgICAgICAgICAgICAgID8gMCBcbiAgICAgICAgICAgICAgICAgOiBhID09PSB2b2lkIDAgXG4gICAgICAgICAgICAgICAgICAgPyAxIFxuICAgICAgICAgICAgICAgICAgIDogLTFcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmUgPSBhID4gYiBcbiAgICAgICAgICAgICAgICAgPyAxIFxuICAgICAgICAgICAgICAgICA6IGEgPT09IGIgXG4gICAgICAgICAgICAgICAgICAgPyAwIFxuICAgICAgICAgICAgICAgICAgIDogLTFcbiAgICAgICAgcmV0dXJuIHNvcnQub3JkZXIgPyByZSAqIC0xIDogcmVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgYSA9IGdldEZpZWxkVmFsKGEsIGZpZWxkKVxuICAgICAgICBiID0gZ2V0RmllbGRWYWwoYiwgZmllbGQpXG4gICAgICAgIHZhciB3ZWFrQSA9IGEgPT09IHZvaWQgMCB8fCBhID09PSBudWxsXG4gICAgICAgICAgLCB3ZWFrQiA9IGIgPT09IHZvaWQgMCB8fCBiID09PSBudWxsXG4gICAgICAgIGlmICh3ZWFrQSB8fCB3ZWFrQikge1xuICAgICAgICAgIHJldHVybiBhID09PSBiID8gMCA6IHdlYWtBID8gMSA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlID0gYSA+IGIgXG4gICAgICAgICAgICAgICAgID8gMSBcbiAgICAgICAgICAgICAgICAgOiBhID09PSBiIFxuICAgICAgICAgICAgICAgICAgID8gMCBcbiAgICAgICAgICAgICAgICAgICA6IC0xXG4gICAgICAgIHJldHVybiBzb3J0Lm9yZGVyID8gcmUgKiAtMSA6IHJlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZpZWxkVmFsKG9iaiwgZmllbGQpIHtcbiAgdmFyIHYgPSBvYmoudmFsXG4gIHJldHVybiB2ICYmIHZbZmllbGRdICYmIHZbZmllbGRdLnZhbFxufVxuXG5mdW5jdGlvbiBnZXREb3RGaWVsZFZhbChvYmosIGZpZWxkKSB7XG4gIHZhciB2ID0gb2JqLnBhdGgoZmllbGQpXG4gIHJldHVybiB2ICYmIHYudmFsXG59XG5cbmZ1bmN0aW9uIHB1dFNvcnQocGF0aCkge1xuICB2YXIgb2JqID0gcGFydCA9IHt9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwYXJ0ID0gcGFydFtwYXRoW2ldXSA9IHtcbiAgICAgIF91cDogcGFydFxuICAgIH1cbiAgfVxuICBwYXJ0Ll9zb3J0ID0gdHJ1ZVxuICByZXR1cm4gb2JqXG59XG4iLCIvL1Ygb25seSB1c2VkIGFzIGEgcmVmZXJlbmNlIG5vdy4uLlxuIiwiLypcbmNvbG9ycy5qc1xuXG5Db3B5cmlnaHQgKGMpIDIwMTBcblxuTWFyYWsgU3F1aXJlc1xuQWxleGlzIFNlbGxpZXIgKGNsb3VkaGVhZClcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuXG4qL1xuXG52YXIgaXNIZWFkbGVzcyA9IGZhbHNlO1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgaXNIZWFkbGVzcyA9IHRydWU7XG59XG5cbmlmICghaXNIZWFkbGVzcykge1xuICB2YXIgZXhwb3J0cyA9IHt9O1xuICB2YXIgbW9kdWxlID0ge307XG4gIHZhciBjb2xvcnMgPSBleHBvcnRzO1xuICBleHBvcnRzLm1vZGUgPSBcImJyb3dzZXJcIjtcbn0gZWxzZSB7XG4gIGV4cG9ydHMubW9kZSA9IFwiY29uc29sZVwiO1xufVxuXG4vL1xuLy8gUHJvdG90eXBlcyB0aGUgc3RyaW5nIG9iamVjdCB0byBoYXZlIGFkZGl0aW9uYWwgbWV0aG9kIGNhbGxzIHRoYXQgYWRkIHRlcm1pbmFsIGNvbG9yc1xuLy9cbnZhciBhZGRQcm9wZXJ0eSA9IGZ1bmN0aW9uIChjb2xvciwgZnVuYykge1xuICBleHBvcnRzW2NvbG9yXSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICByZXR1cm4gZnVuYy5hcHBseShzdHIpO1xuICB9O1xuICBTdHJpbmcucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX18oY29sb3IsIGZ1bmMpO1xufTtcblxuZnVuY3Rpb24gc3R5bGl6ZShzdHIsIHN0eWxlKSB7XG5cbiAgdmFyIHN0eWxlcztcblxuICBpZiAoZXhwb3J0cy5tb2RlID09PSAnY29uc29sZScpIHtcbiAgICBzdHlsZXMgPSB7XG4gICAgICAvL3N0eWxlc1xuICAgICAgJ2JvbGQnICAgICAgOiBbJ1xceDFCWzFtJywgICdcXHgxQlsyMm0nXSxcbiAgICAgICdpdGFsaWMnICAgIDogWydcXHgxQlszbScsICAnXFx4MUJbMjNtJ10sXG4gICAgICAndW5kZXJsaW5lJyA6IFsnXFx4MUJbNG0nLCAgJ1xceDFCWzI0bSddLFxuICAgICAgJ2ludmVyc2UnICAgOiBbJ1xceDFCWzdtJywgICdcXHgxQlsyN20nXSxcbiAgICAgICdzdHJpa2V0aHJvdWdoJyA6IFsnXFx4MUJbOW0nLCAgJ1xceDFCWzI5bSddLFxuICAgICAgLy90ZXh0IGNvbG9yc1xuICAgICAgLy9ncmF5c2NhbGVcbiAgICAgICd3aGl0ZScgICAgIDogWydcXHgxQlszN20nLCAnXFx4MUJbMzltJ10sXG4gICAgICAnZ3JleScgICAgICA6IFsnXFx4MUJbOTBtJywgJ1xceDFCWzM5bSddLFxuICAgICAgJ2JsYWNrJyAgICAgOiBbJ1xceDFCWzMwbScsICdcXHgxQlszOW0nXSxcbiAgICAgIC8vY29sb3JzXG4gICAgICAnYmx1ZScgICAgICA6IFsnXFx4MUJbMzRtJywgJ1xceDFCWzM5bSddLFxuICAgICAgJ2N5YW4nICAgICAgOiBbJ1xceDFCWzM2bScsICdcXHgxQlszOW0nXSxcbiAgICAgICdncmVlbicgICAgIDogWydcXHgxQlszMm0nLCAnXFx4MUJbMzltJ10sXG4gICAgICAnbWFnZW50YScgICA6IFsnXFx4MUJbMzVtJywgJ1xceDFCWzM5bSddLFxuICAgICAgJ3JlZCcgICAgICAgOiBbJ1xceDFCWzMxbScsICdcXHgxQlszOW0nXSxcbiAgICAgICd5ZWxsb3cnICAgIDogWydcXHgxQlszM20nLCAnXFx4MUJbMzltJ10sXG4gICAgICAvL2JhY2tncm91bmQgY29sb3JzXG4gICAgICAvL2dyYXlzY2FsZVxuICAgICAgJ3doaXRlQkcnICAgICA6IFsnXFx4MUJbNDdtJywgJ1xceDFCWzQ5bSddLFxuICAgICAgJ2dyZXlCRycgICAgICA6IFsnXFx4MUJbNDk7NTs4bScsICdcXHgxQls0OW0nXSxcbiAgICAgICdibGFja0JHJyAgICAgOiBbJ1xceDFCWzQwbScsICdcXHgxQls0OW0nXSxcbiAgICAgIC8vY29sb3JzXG4gICAgICAnYmx1ZUJHJyAgICAgIDogWydcXHgxQls0NG0nLCAnXFx4MUJbNDltJ10sXG4gICAgICAnY3lhbkJHJyAgICAgIDogWydcXHgxQls0Nm0nLCAnXFx4MUJbNDltJ10sXG4gICAgICAnZ3JlZW5CRycgICAgIDogWydcXHgxQls0Mm0nLCAnXFx4MUJbNDltJ10sXG4gICAgICAnbWFnZW50YUJHJyAgIDogWydcXHgxQls0NW0nLCAnXFx4MUJbNDltJ10sXG4gICAgICAncmVkQkcnICAgICAgIDogWydcXHgxQls0MW0nLCAnXFx4MUJbNDltJ10sXG4gICAgICAneWVsbG93QkcnICAgIDogWydcXHgxQls0M20nLCAnXFx4MUJbNDltJ11cbiAgICB9O1xuICB9IGVsc2UgaWYgKGV4cG9ydHMubW9kZSA9PT0gJ2Jyb3dzZXInKSB7XG4gICAgc3R5bGVzID0ge1xuICAgICAgLy9zdHlsZXNcbiAgICAgICdib2xkJyAgICAgIDogWyc8Yj4nLCAgJzwvYj4nXSxcbiAgICAgICdpdGFsaWMnICAgIDogWyc8aT4nLCAgJzwvaT4nXSxcbiAgICAgICd1bmRlcmxpbmUnIDogWyc8dT4nLCAgJzwvdT4nXSxcbiAgICAgICdpbnZlcnNlJyAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6YmxhY2s7Y29sb3I6d2hpdGU7XCI+JywgICc8L3NwYW4+J10sXG4gICAgICAnc3RyaWtldGhyb3VnaCcgOiBbJzxkZWw+JywgICc8L2RlbD4nXSxcbiAgICAgIC8vdGV4dCBjb2xvcnNcbiAgICAgIC8vZ3JheXNjYWxlXG4gICAgICAnd2hpdGUnICAgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjp3aGl0ZTtcIj4nLCAgICc8L3NwYW4+J10sXG4gICAgICAnZ3JleScgICAgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjpncmF5O1wiPicsICAgICc8L3NwYW4+J10sXG4gICAgICAnYmxhY2snICAgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjpibGFjaztcIj4nLCAgICc8L3NwYW4+J10sXG4gICAgICAvL2NvbG9yc1xuICAgICAgJ2JsdWUnICAgICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6Ymx1ZTtcIj4nLCAgICAnPC9zcGFuPiddLFxuICAgICAgJ2N5YW4nICAgICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6Y3lhbjtcIj4nLCAgICAnPC9zcGFuPiddLFxuICAgICAgJ2dyZWVuJyAgICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6Z3JlZW47XCI+JywgICAnPC9zcGFuPiddLFxuICAgICAgJ21hZ2VudGEnICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6bWFnZW50YTtcIj4nLCAnPC9zcGFuPiddLFxuICAgICAgJ3JlZCcgICAgICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6cmVkO1wiPicsICAgICAnPC9zcGFuPiddLFxuICAgICAgJ3llbGxvdycgICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6eWVsbG93O1wiPicsICAnPC9zcGFuPiddLFxuICAgICAgLy9iYWNrZ3JvdW5kIGNvbG9yc1xuICAgICAgLy9ncmF5c2NhbGVcbiAgICAgICd3aGl0ZUJHJyAgICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjp3aGl0ZTtcIj4nLCAgICc8L3NwYW4+J10sXG4gICAgICAnZ3JleUJHJyAgICAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6Z3JheTtcIj4nLCAgICAnPC9zcGFuPiddLFxuICAgICAgJ2JsYWNrQkcnICAgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrO1wiPicsICAgJzwvc3Bhbj4nXSxcbiAgICAgIC8vY29sb3JzXG4gICAgICAnYmx1ZUJHJyAgICAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6Ymx1ZTtcIj4nLCAgICAnPC9zcGFuPiddLFxuICAgICAgJ2N5YW5CRycgICAgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOmN5YW47XCI+JywgICAgJzwvc3Bhbj4nXSxcbiAgICAgICdncmVlbkJHJyAgICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpncmVlbjtcIj4nLCAgICc8L3NwYW4+J10sXG4gICAgICAnbWFnZW50YUJHJyAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6bWFnZW50YTtcIj4nLCAnPC9zcGFuPiddLFxuICAgICAgJ3JlZEJHJyAgICAgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOnJlZDtcIj4nLCAgICAgJzwvc3Bhbj4nXSxcbiAgICAgICd5ZWxsb3dCRycgICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjp5ZWxsb3c7XCI+JywgICc8L3NwYW4+J11cbiAgICB9O1xuICB9IGVsc2UgaWYgKGV4cG9ydHMubW9kZSA9PT0gJ25vbmUnKSB7XG4gICAgcmV0dXJuIHN0ciArICcnO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCd1bnN1cHBvcnRlZCBtb2RlLCB0cnkgXCJicm93c2VyXCIsIFwiY29uc29sZVwiIG9yIFwibm9uZVwiJyk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlc1tzdHlsZV1bMF0gKyBzdHIgKyBzdHlsZXNbc3R5bGVdWzFdO1xufVxuXG5mdW5jdGlvbiBhcHBseVRoZW1lKHRoZW1lKSB7XG5cbiAgLy9cbiAgLy8gUmVtYXJrOiBUaGlzIGlzIGEgbGlzdCBvZiBtZXRob2RzIHRoYXQgZXhpc3RcbiAgLy8gb24gU3RyaW5nIHRoYXQgeW91IHNob3VsZCBub3Qgb3ZlcndyaXRlLlxuICAvL1xuICB2YXIgc3RyaW5nUHJvdG90eXBlQmxhY2tsaXN0ID0gW1xuICAgICdfX2RlZmluZUdldHRlcl9fJywgJ19fZGVmaW5lU2V0dGVyX18nLCAnX19sb29rdXBHZXR0ZXJfXycsICdfX2xvb2t1cFNldHRlcl9fJywgJ2NoYXJBdCcsICdjb25zdHJ1Y3RvcicsXG4gICAgJ2hhc093blByb3BlcnR5JywgJ2lzUHJvdG90eXBlT2YnLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAndG9Mb2NhbGVTdHJpbmcnLCAndG9TdHJpbmcnLCAndmFsdWVPZicsICdjaGFyQ29kZUF0JyxcbiAgICAnaW5kZXhPZicsICdsYXN0SW5kZXhvZicsICdsZW5ndGgnLCAnbG9jYWxlQ29tcGFyZScsICdtYXRjaCcsICdyZXBsYWNlJywgJ3NlYXJjaCcsICdzbGljZScsICdzcGxpdCcsICdzdWJzdHJpbmcnLFxuICAgICd0b0xvY2FsZUxvd2VyQ2FzZScsICd0b0xvY2FsZVVwcGVyQ2FzZScsICd0b0xvd2VyQ2FzZScsICd0b1VwcGVyQ2FzZScsICd0cmltJywgJ3RyaW1MZWZ0JywgJ3RyaW1SaWdodCdcbiAgXTtcblxuICBPYmplY3Qua2V5cyh0aGVtZSkuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIGlmIChzdHJpbmdQcm90b3R5cGVCbGFja2xpc3QuaW5kZXhPZihwcm9wKSAhPT0gLTEpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd3YXJuOiAnLnJlZCArICgnU3RyaW5nLnByb3RvdHlwZScgKyBwcm9wKS5tYWdlbnRhICsgJyBpcyBwcm9iYWJseSBzb21ldGhpbmcgeW91IGRvblxcJ3Qgd2FudCB0byBvdmVycmlkZS4gSWdub3Jpbmcgc3R5bGUgbmFtZScpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YodGhlbWVbcHJvcF0pID09PSAnc3RyaW5nJykge1xuICAgICAgICBhZGRQcm9wZXJ0eShwcm9wLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cG9ydHNbdGhlbWVbcHJvcF1dKHRoaXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBhZGRQcm9wZXJ0eShwcm9wLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIHJldCA9IHRoaXM7XG4gICAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGVtZVtwcm9wXS5sZW5ndGg7IHQrKykge1xuICAgICAgICAgICAgcmV0ID0gZXhwb3J0c1t0aGVtZVtwcm9wXVt0XV0ocmV0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuXG4vL1xuLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBkZWZhdWx0IHN0eWxlcyBhbmQgY29sb3JzXG4vL1xudmFyIHggPSBbJ2JvbGQnLCAndW5kZXJsaW5lJywgJ3N0cmlrZXRocm91Z2gnLCAnaXRhbGljJywgJ2ludmVyc2UnLCAnZ3JleScsICdibGFjaycsICd5ZWxsb3cnLCAncmVkJywgJ2dyZWVuJywgJ2JsdWUnLCAnd2hpdGUnLCAnY3lhbicsICdtYWdlbnRhJywgJ2dyZXlCRycsICdibGFja0JHJywgJ3llbGxvd0JHJywgJ3JlZEJHJywgJ2dyZWVuQkcnLCAnYmx1ZUJHJywgJ3doaXRlQkcnLCAnY3lhbkJHJywgJ21hZ2VudGFCRyddO1xueC5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZSkge1xuXG4gIC8vIF9fZGVmaW5lR2V0dGVyX18gYXQgdGhlIGxlYXN0IHdvcmtzIGluIG1vcmUgYnJvd3NlcnNcbiAgLy8gaHR0cDovL3JvYmVydG55bWFuLmNvbS9qYXZhc2NyaXB0L2phdmFzY3JpcHQtZ2V0dGVycy1zZXR0ZXJzLmh0bWxcbiAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5IG9ubHkgd29ya3MgaW4gQ2hyb21lXG4gIGFkZFByb3BlcnR5KHN0eWxlLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHN0eWxpemUodGhpcywgc3R5bGUpO1xuICB9KTtcbn0pO1xuXG5mdW5jdGlvbiBzZXF1ZW5jZXIobWFwKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc0hlYWRsZXNzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKC8oICkvLCAnJDEnKTtcbiAgICB9XG4gICAgdmFyIGV4cGxvZGVkID0gdGhpcy5zcGxpdChcIlwiKSwgaSA9IDA7XG4gICAgZXhwbG9kZWQgPSBleHBsb2RlZC5tYXAobWFwKTtcbiAgICByZXR1cm4gZXhwbG9kZWQuam9pbihcIlwiKTtcbiAgfTtcbn1cblxudmFyIHJhaW5ib3dNYXAgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgcmFpbmJvd0NvbG9ycyA9IFsncmVkJywgJ3llbGxvdycsICdncmVlbicsICdibHVlJywgJ21hZ2VudGEnXTsgLy9Sb1kgRyBCaVZcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gICAgaWYgKGxldHRlciA9PT0gXCIgXCIpIHtcbiAgICAgIHJldHVybiBsZXR0ZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdHlsaXplKGxldHRlciwgcmFpbmJvd0NvbG9yc1tpKysgJSByYWluYm93Q29sb3JzLmxlbmd0aF0pO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5cbmV4cG9ydHMudGhlbWVzID0ge307XG5cbmV4cG9ydHMuYWRkU2VxdWVuY2VyID0gZnVuY3Rpb24gKG5hbWUsIG1hcCkge1xuICBhZGRQcm9wZXJ0eShuYW1lLCBzZXF1ZW5jZXIobWFwKSk7XG59O1xuXG5leHBvcnRzLmFkZFNlcXVlbmNlcigncmFpbmJvdycsIHJhaW5ib3dNYXApO1xuZXhwb3J0cy5hZGRTZXF1ZW5jZXIoJ3plYnJhJywgZnVuY3Rpb24gKGxldHRlciwgaSwgZXhwbG9kZWQpIHtcbiAgcmV0dXJuIGkgJSAyID09PSAwID8gbGV0dGVyIDogbGV0dGVyLmludmVyc2U7XG59KTtcblxuZXhwb3J0cy5zZXRUaGVtZSA9IGZ1bmN0aW9uICh0aGVtZSkge1xuICBpZiAodHlwZW9mIHRoZW1lID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICBleHBvcnRzLnRoZW1lc1t0aGVtZV0gPSByZXF1aXJlKHRoZW1lKTtcbiAgICAgIGFwcGx5VGhlbWUoZXhwb3J0cy50aGVtZXNbdGhlbWVdKTtcbiAgICAgIHJldHVybiBleHBvcnRzLnRoZW1lc1t0aGVtZV07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhlcnIpO1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYXBwbHlUaGVtZSh0aGVtZSk7XG4gIH1cbn07XG5cblxuYWRkUHJvcGVydHkoJ3N0cmlwQ29sb3JzJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gKFwiXCIgKyB0aGlzKS5yZXBsYWNlKC9cXHgxQlxcW1xcZCttL2csICcnKTtcbn0pO1xuXG4vLyBwbGVhc2Ugbm9cbmZ1bmN0aW9uIHphbGdvKHRleHQsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdWwgPSB7XG4gICAgXCJ1cFwiIDogW1xuICAgICAgJ8yNJywgJ8yOJywgJ8yEJywgJ8yFJyxcbiAgICAgICfMvycsICfMkScsICfMhicsICfMkCcsXG4gICAgICAnzZInLCAnzZcnLCAnzZEnLCAnzIcnLFxuICAgICAgJ8yIJywgJ8yKJywgJ82CJywgJ8yTJyxcbiAgICAgICfMiCcsICfNiicsICfNiycsICfNjCcsXG4gICAgICAnzIMnLCAnzIInLCAnzIwnLCAnzZAnLFxuICAgICAgJ8yAJywgJ8yBJywgJ8yLJywgJ8yPJyxcbiAgICAgICfMkicsICfMkycsICfMlCcsICfMvScsXG4gICAgICAnzIknLCAnzaMnLCAnzaQnLCAnzaUnLFxuICAgICAgJ82mJywgJ82nJywgJ82oJywgJ82pJyxcbiAgICAgICfNqicsICfNqycsICfNrCcsICfNrScsXG4gICAgICAnza4nLCAnza8nLCAnzL4nLCAnzZsnLFxuICAgICAgJ82GJywgJ8yaJ1xuICAgIF0sXG4gICAgXCJkb3duXCIgOiBbXG4gICAgICAnzJYnLCAnzJcnLCAnzJgnLCAnzJknLFxuICAgICAgJ8ycJywgJ8ydJywgJ8yeJywgJ8yfJyxcbiAgICAgICfMoCcsICfMpCcsICfMpScsICfMpicsXG4gICAgICAnzKknLCAnzKonLCAnzKsnLCAnzKwnLFxuICAgICAgJ8ytJywgJ8yuJywgJ8yvJywgJ8ywJyxcbiAgICAgICfMsScsICfMsicsICfMsycsICfMuScsXG4gICAgICAnzLonLCAnzLsnLCAnzLwnLCAnzYUnLFxuICAgICAgJ82HJywgJ82IJywgJ82JJywgJ82NJyxcbiAgICAgICfNjicsICfNkycsICfNlCcsICfNlScsXG4gICAgICAnzZYnLCAnzZknLCAnzZonLCAnzKMnXG4gICAgXSxcbiAgICBcIm1pZFwiIDogW1xuICAgICAgJ8yVJywgJ8ybJywgJ8yAJywgJ8yBJyxcbiAgICAgICfNmCcsICfMoScsICfMoicsICfMpycsXG4gICAgICAnzKgnLCAnzLQnLCAnzLUnLCAnzLYnLFxuICAgICAgJ82cJywgJ82dJywgJ82eJyxcbiAgICAgICfNnycsICfNoCcsICfNoicsICfMuCcsXG4gICAgICAnzLcnLCAnzaEnLCAnINKJJ1xuICAgIF1cbiAgfSxcbiAgYWxsID0gW10uY29uY2F0KHNvdWwudXAsIHNvdWwuZG93biwgc291bC5taWQpLFxuICB6YWxnbyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHJhbmRvbU51bWJlcihyYW5nZSkge1xuICAgIHZhciByID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmFuZ2UpO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNfY2hhcihjaGFyYWN0ZXIpIHtcbiAgICB2YXIgYm9vbCA9IGZhbHNlO1xuICAgIGFsbC5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIGJvb2wgPSAoaSA9PT0gY2hhcmFjdGVyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm9vbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhlQ29tZXModGV4dCwgb3B0aW9ucykge1xuICAgIHZhciByZXN1bHQgPSAnJywgY291bnRzLCBsO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIG9wdGlvbnNbXCJ1cFwiXSA9IG9wdGlvbnNbXCJ1cFwiXSB8fCB0cnVlO1xuICAgIG9wdGlvbnNbXCJtaWRcIl0gPSBvcHRpb25zW1wibWlkXCJdIHx8IHRydWU7XG4gICAgb3B0aW9uc1tcImRvd25cIl0gPSBvcHRpb25zW1wiZG93blwiXSB8fCB0cnVlO1xuICAgIG9wdGlvbnNbXCJzaXplXCJdID0gb3B0aW9uc1tcInNpemVcIl0gfHwgXCJtYXhpXCI7XG4gICAgdGV4dCA9IHRleHQuc3BsaXQoJycpO1xuICAgIGZvciAobCBpbiB0ZXh0KSB7XG4gICAgICBpZiAoaXNfY2hhcihsKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHRleHRbbF07XG4gICAgICBjb3VudHMgPSB7XCJ1cFwiIDogMCwgXCJkb3duXCIgOiAwLCBcIm1pZFwiIDogMH07XG4gICAgICBzd2l0Y2ggKG9wdGlvbnMuc2l6ZSkge1xuICAgICAgY2FzZSAnbWluaSc6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcig4KTtcbiAgICAgICAgY291bnRzLm1pbiA9IHJhbmRvbU51bWJlcigyKTtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoOCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbWF4aSc6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcigxNikgKyAzO1xuICAgICAgICBjb3VudHMubWluID0gcmFuZG9tTnVtYmVyKDQpICsgMTtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoNjQpICsgMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb3VudHMudXAgPSByYW5kb21OdW1iZXIoOCkgKyAxO1xuICAgICAgICBjb3VudHMubWlkID0gcmFuZG9tTnVtYmVyKDYpIC8gMjtcbiAgICAgICAgY291bnRzLmRvd24gPSByYW5kb21OdW1iZXIoOCkgKyAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGFyciA9IFtcInVwXCIsIFwibWlkXCIsIFwiZG93blwiXTtcbiAgICAgIGZvciAodmFyIGQgaW4gYXJyKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGFycltkXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDw9IGNvdW50c1tpbmRleF07IGkrKykge1xuICAgICAgICAgIGlmIChvcHRpb25zW2luZGV4XSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgc291bFtpbmRleF1bcmFuZG9tTnVtYmVyKHNvdWxbaW5kZXhdLmxlbmd0aCldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiBoZUNvbWVzKHRleHQpO1xufVxuXG5cbi8vIGRvbid0IHN1bW1vbiB6YWxnb1xuYWRkUHJvcGVydHkoJ3phbGdvJywgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gemFsZ28odGhpcyk7XG59KTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSAgcmVxdWlyZSgnLi9saWIvJyk7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZWpzb24gPSByZXF1aXJlKCdwYXJzZWpzb24nKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIE5vb3AgZnVuY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe31cblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdCA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZSA6XG4gICAgKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdCkge1xuICAgIHZhciBwaWVjZXMgPSBvcHRzLmhvc3Quc3BsaXQoJzonKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGllY2VzLnNoaWZ0KCk7XG4gICAgaWYgKHBpZWNlcy5sZW5ndGgpIHtcbiAgICAgIG9wdHMucG9ydCA9IHBpZWNlcy5wb3AoKTtcbiAgICB9IGVsc2UgaWYgKCFvcHRzLnBvcnQpIHtcbiAgICAgIC8vIGlmIG5vIHBvcnQgaXMgc3BlY2lmaWVkIG1hbnVhbGx5LCB1c2UgdGhlIHByb3RvY29sIGRlZmF1bHRcbiAgICAgIG9wdHMucG9ydCA9IHRoaXMuc2VjdXJlID8gJzQ0MycgOiAnODAnO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/XG4gICAgICAgbG9jYXRpb24ucG9ydCA6XG4gICAgICAgKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuanNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy5lbmFibGVzWERSID0gISFvcHRzLmVuYWJsZXNYRFI7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIgPSBbXTtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeCB8fCBudWxsO1xuICB0aGlzLmtleSA9IG9wdHMua2V5IHx8IG51bGw7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZSB8fCBudWxsO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQgfHwgbnVsbDtcbiAgdGhpcy5jYSA9IG9wdHMuY2EgfHwgbnVsbDtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzIHx8IG51bGw7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgfHwgbnVsbDtcblxuICB0aGlzLm9wZW4oKTtcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBqc29ucDogdGhpcy5qc29ucCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpcyxcbiAgICBwZng6IHRoaXMucGZ4LFxuICAgIGtleTogdGhpcy5rZXksXG4gICAgcGFzc3BocmFzZTogdGhpcy5wYXNzcGhyYXNlLFxuICAgIGNlcnQ6IHRoaXMuY2VydCxcbiAgICBjYTogdGhpcy5jYSxcbiAgICBjaXBoZXJzOiB0aGlzLmNpcGhlcnMsXG4gICAgcmVqZWN0VW5hdXRob3JpemVkOiB0aGlzLnJlamVjdFVuYXV0aG9yaXplZFxuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIGlmICgwID09IHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAvLyBFbWl0IGVycm9yIG9uIG5leHQgdGljayBzbyBpdCBjYW4gYmUgbGlzdGVuZWQgdG9cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCAnTm8gdHJhbnNwb3J0cyBhdmFpbGFibGUnKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnRzWzBdO1xuICB9XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcblxuICAvLyBSZXRyeSB3aXRoIHRoZSBuZXh0IHRyYW5zcG9ydCBpZiB0aGUgdHJhbnNwb3J0IGlzIGRpc2FibGVkIChqc29ucDogZmFsc2UpXG4gIHZhciB0cmFuc3BvcnQ7XG4gIHRyeSB7XG4gICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMudHJhbnNwb3J0cy5zaGlmdCgpO1xuICAgIHRoaXMub3BlbigpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG4gIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0LiBEaXNhYmxlcyB0aGUgZXhpc3Rpbmcgb25lIChpZiBhbnkpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0KXtcbiAgZGVidWcoJ3NldHRpbmcgdHJhbnNwb3J0ICVzJywgdHJhbnNwb3J0Lm5hbWUpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudHJhbnNwb3J0KSB7XG4gICAgZGVidWcoJ2NsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlcycsIHRoaXMudHJhbnNwb3J0Lm5hbWUpO1xuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydFxuICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0IGxpc3RlbmVyc1xuICB0cmFuc3BvcnRcbiAgLm9uKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkRyYWluKCk7XG4gIH0pXG4gIC5vbigncGFja2V0JywgZnVuY3Rpb24ocGFja2V0KXtcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH0pXG4gIC5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoZSk7XG4gIH0pXG4gIC5vbignY2xvc2UnLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgndHJhbnNwb3J0IGNsb3NlJyk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBQcm9iZXMgYSB0cmFuc3BvcnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnByb2JlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSwgeyBwcm9iZTogMSB9KVxuICAgICwgZmFpbGVkID0gZmFsc2VcbiAgICAsIHNlbGYgPSB0aGlzO1xuXG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtcbiAgICBpZiAoc2VsZi5vbmx5QmluYXJ5VXBncmFkZXMpIHtcbiAgICAgIHZhciB1cGdyYWRlTG9zZXNCaW5hcnkgPSAhdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiBzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtcbiAgICAgIGZhaWxlZCA9IGZhaWxlZCB8fCB1cGdyYWRlTG9zZXNCaW5hcnk7XG4gICAgfVxuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIG9wZW5lZCcsIG5hbWUpO1xuICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICdwaW5nJywgZGF0YTogJ3Byb2JlJyB9XSk7XG4gICAgdHJhbnNwb3J0Lm9uY2UoJ3BhY2tldCcsIGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgIGlmICgncG9uZycgPT0gbXNnLnR5cGUgJiYgJ3Byb2JlJyA9PSBtc2cuZGF0YSkge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJywgbmFtZSk7XG4gICAgICAgIHNlbGYudXBncmFkaW5nID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRpbmcnLCB0cmFuc3BvcnQpO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydCkgcmV0dXJuO1xuICAgICAgICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICAgICAgZGVidWcoJ3BhdXNpbmcgY3VycmVudCB0cmFuc3BvcnQgXCIlc1wiJywgc2VsZi50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIHNlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICAgICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICAgIGRlYnVnKCdjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXQnKTtcblxuICAgICAgICAgIGNsZWFudXAoKTtcblxuICAgICAgICAgIHNlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3VwZ3JhZGUnIH1dKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGUnLCB0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgICAgc2VsZi51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLmZsdXNoKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJywgbmFtZSk7XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yJyk7XG4gICAgICAgIGVyci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcbiAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCkge1xuICAgIGlmIChmYWlsZWQpIHJldHVybjtcblxuICAgIC8vIEFueSBjYWxsYmFjayBjYWxsZWQgYnkgdHJhbnNwb3J0IHNob3VsZCBiZSBpZ25vcmVkIHNpbmNlIG5vd1xuICAgIGZhaWxlZCA9IHRydWU7XG5cbiAgICBjbGVhbnVwKCk7XG5cbiAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0cmFuc3BvcnQgPSBudWxsO1xuICB9XG5cbiAgLy9IYW5kbGUgYW55IGVycm9yIHRoYXQgaGFwcGVucyB3aGlsZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXJyKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcjogJyArIGVycik7XG4gICAgZXJyb3IudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG5cbiAgICBmcmVlemVUcmFuc3BvcnQoKTtcblxuICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCBiZWNhdXNlIG9mIGVycm9yOiAlcycsIG5hbWUsIGVycik7XG5cbiAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycm9yKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtcbiAgICBvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIGNsb3NlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKXtcbiAgICBvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKTtcbiAgfVxuXG4gIC8vV2hlbiB0aGUgc29ja2V0IGlzIHVwZ3JhZGVkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb251cGdyYWRlKHRvKXtcbiAgICBpZiAodHJhbnNwb3J0ICYmIHRvLm5hbWUgIT0gdHJhbnNwb3J0Lm5hbWUpIHtcbiAgICAgIGRlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLCB0by5uYW1lLCB0cmFuc3BvcnQubmFtZSk7XG4gICAgICBmcmVlemVUcmFuc3BvcnQoKTtcbiAgICB9XG4gIH1cblxuICAvL1JlbW92ZSBhbGwgbGlzdGVuZXJzIG9uIHRoZSB0cmFuc3BvcnQgYW5kIG9uIHNlbGZcbiAgZnVuY3Rpb24gY2xlYW51cCgpe1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG4gIH1cblxuICB0cmFuc3BvcnQub25jZSgnb3BlbicsIG9uVHJhbnNwb3J0T3Blbik7XG4gIHRyYW5zcG9ydC5vbmNlKCdlcnJvcicsIG9uZXJyb3IpO1xuICB0cmFuc3BvcnQub25jZSgnY2xvc2UnLCBvblRyYW5zcG9ydENsb3NlKTtcblxuICB0aGlzLm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHRoaXMub25jZSgndXBncmFkaW5nJywgb251cGdyYWRlKTtcblxuICB0cmFuc3BvcnQub3BlbigpO1xuXG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIGNvbm5lY3Rpb24gaXMgZGVlbWVkIG9wZW4uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ3NvY2tldCBvcGVuJyk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRoaXMudHJhbnNwb3J0Lm5hbWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuICB0aGlzLmZsdXNoKCk7XG5cbiAgLy8gd2UgY2hlY2sgZm9yIGByZWFkeVN0YXRlYCBpbiBjYXNlIGFuIGBvcGVuYFxuICAvLyBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlZCB0aGUgc29ja2V0XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudXBncmFkZSAmJiB0aGlzLnRyYW5zcG9ydC5wYXVzZSkge1xuICAgIGRlYnVnKCdzdGFydGluZyB1cGdyYWRlIHByb2JlcycpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy51cGdyYWRlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhhbmRsZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJywgcGFja2V0LnR5cGUsIHBhY2tldC5kYXRhKTtcblxuICAgIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcblxuICAgIC8vIFNvY2tldCBpcyBsaXZlIC0gYW55IHBhY2tldCBjb3VudHNcbiAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcpO1xuXG4gICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgY2FzZSAnb3Blbic6XG4gICAgICAgIHRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgdGhpcy5zZXRQaW5nKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ3NlcnZlciBlcnJvcicpO1xuICAgICAgICBlcnIuY29kZSA9IHBhY2tldC5kYXRhO1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ21lc3NhZ2UnOlxuICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdwYWNrZXQgcmVjZWl2ZWQgd2l0aCBzb2NrZXQgcmVhZHlTdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGhhbmRzaGFrZSBjb21wbGV0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYW5kc2hha2Ugb2JqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGFuZHNoYWtlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgdGhpcy5lbWl0KCdoYW5kc2hha2UnLCBkYXRhKTtcbiAgdGhpcy5pZCA9IGRhdGEuc2lkO1xuICB0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy51cGdyYWRlcyA9IHRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7XG4gIHRoaXMucGluZ0ludGVydmFsID0gZGF0YS5waW5nSW50ZXJ2YWw7XG4gIHRoaXMucGluZ1RpbWVvdXQgPSBkYXRhLnBpbmdUaW1lb3V0O1xuICB0aGlzLm9uT3BlbigpO1xuICAvLyBJbiBjYXNlIG9wZW4gaGFuZGxlciBjbG9zZXMgc29ja2V0XG4gIGlmICAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSByZXR1cm47XG4gIHRoaXMuc2V0UGluZygpO1xuXG4gIC8vIFByb2xvbmcgbGl2ZW5lc3Mgb2Ygc29ja2V0IG9uIGhlYXJ0YmVhdFxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbiAgdGhpcy5vbignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG59O1xuXG4vKipcbiAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHNlbGYucGluZ1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICBzZWxmLm9uQ2xvc2UoJ3BpbmcgdGltZW91dCcpO1xuICB9LCB0aW1lb3V0IHx8IChzZWxmLnBpbmdJbnRlcnZhbCArIHNlbGYucGluZ1RpbWVvdXQpKTtcbn07XG5cbi8qKlxuICogUGluZ3Mgc2VydmVyIGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRQaW5nID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgc2VsZi5waW5nSW50ZXJ2YWxUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXMnLCBzZWxmLnBpbmdUaW1lb3V0KTtcbiAgICBzZWxmLnBpbmcoKTtcbiAgICBzZWxmLm9uSGVhcnRiZWF0KHNlbGYucGluZ1RpbWVvdXQpO1xuICB9LCBzZWxmLnBpbmdJbnRlcnZhbCk7XG59O1xuXG4vKipcbiogU2VuZHMgYSBwaW5nIHBhY2tldC5cbipcbiogQGFwaSBwdWJsaWNcbiovXG5cblNvY2tldC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdwaW5nJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBvbiBgZHJhaW5gIGV2ZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkRyYWluID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wcmV2QnVmZmVyTGVuOyBpKyspIHtcbiAgICBpZiAodGhpcy5jYWxsYmFja0J1ZmZlcltpXSkge1xuICAgICAgdGhpcy5jYWxsYmFja0J1ZmZlcltpXSgpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIuc3BsaWNlKDAsIHRoaXMucHJldkJ1ZmZlckxlbik7XG5cbiAgLy8gc2V0dGluZyBwcmV2QnVmZmVyTGVuID0gMCBpcyB2ZXJ5IGltcG9ydGFudFxuICAvLyBmb3IgZXhhbXBsZSwgd2hlbiB1cGdyYWRpbmcsIHVwZ3JhZGUgcGFja2V0IGlzIHNlbnQgb3ZlcixcbiAgLy8gYW5kIGEgbm9uemVybyBwcmV2QnVmZmVyTGVuIGNvdWxkIGNhdXNlIHByb2JsZW1zIG9uIGBkcmFpbmBcbiAgdGhpcy5wcmV2QnVmZmVyTGVuID0gMDtcblxuICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGggPT0gMCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRmx1c2ggd3JpdGUgYnVmZmVycy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZsdXNoID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlICYmIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgIXRoaXMudXBncmFkaW5nICYmIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgZGVidWcoJ2ZsdXNoaW5nICVkIHBhY2tldHMgaW4gc29ja2V0JywgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpO1xuICAgIHRoaXMudHJhbnNwb3J0LnNlbmQodGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgLy8ga2VlcCB0cmFjayBvZiBjdXJyZW50IGxlbmd0aCBvZiB3cml0ZUJ1ZmZlclxuICAgIC8vIHNwbGljZSB3cml0ZUJ1ZmZlciBhbmQgY2FsbGJhY2tCdWZmZXIgb24gYGRyYWluYFxuICAgIHRoaXMucHJldkJ1ZmZlckxlbiA9IHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoO1xuICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLndyaXRlID1cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChtc2csIGZuKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgnbWVzc2FnZScsIG1zZywgZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2tldCB0eXBlLlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBmdW5jdGlvbi5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldCA9IGZ1bmN0aW9uICh0eXBlLCBkYXRhLCBmbikge1xuICBpZiAoJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFja2V0ID0geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG4gIHRoaXMuZW1pdCgncGFja2V0Q3JlYXRlJywgcGFja2V0KTtcbiAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIucHVzaChmbik7XG4gIHRoaXMuZmx1c2goKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2luZyc7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIHNlbGYub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgICAgc2VsZi50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKSB7XG4gICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhaXRGb3JVcGdyYWRlKCkge1xuICAgICAgLy8gd2FpdCBmb3IgdXBncmFkZSB0byBmaW5pc2ggc2luY2Ugd2UgY2FuJ3Qgc2VuZCBwYWNrZXRzIHdoaWxlIHBhdXNpbmcgYSB0cmFuc3BvcnRcbiAgICAgIHNlbGYub25jZSgndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICBzZWxmLm9uY2UoJ3VwZ3JhZGVFcnJvcicsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnVwZ3JhZGluZykge1xuICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLCByZWFzb24pO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIGNsZWFyIHRpbWVyc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcblxuICAgIC8vIGNsZWFuIGJ1ZmZlcnMgaW4gbmV4dCB0aWNrLCBzbyBkZXZlbG9wZXJzIGNhbiBzdGlsbFxuICAgIC8vIGdyYWIgdGhlIGJ1ZmZlcnMgb24gYGNsb3NlYCBldmVudFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLndyaXRlQnVmZmVyID0gW107XG4gICAgICBzZWxmLmNhbGxiYWNrQnVmZmVyID0gW107XG4gICAgICBzZWxmLnByZXZCdWZmZXJMZW4gPSAwO1xuICAgIH0sIDApO1xuXG4gICAgLy8gc3RvcCBldmVudCBmcm9tIGZpcmluZyBhZ2FpbiBmb3IgdHJhbnNwb3J0XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCdjbG9zZScpO1xuXG4gICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXG4gICAgLy8gaWdub3JlIGZ1cnRoZXIgdHJhbnNwb3J0IGNvbW11bmljYXRpb25cbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcblxuICAgIC8vIHNldCByZWFkeSBzdGF0ZVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuXG4gICAgLy8gY2xlYXIgc2Vzc2lvbiBpZFxuICAgIHRoaXMuaWQgPSBudWxsO1xuXG4gICAgLy8gZW1pdCBjbG9zZSBldmVudFxuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24sIGRlc2MpO1xuICB9XG59O1xuXG4vKipcbiAqIEZpbHRlcnMgdXBncmFkZXMsIHJldHVybmluZyBvbmx5IHRob3NlIG1hdGNoaW5nIGNsaWVudCB0cmFuc3BvcnRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHNlcnZlciB1cGdyYWRlc1xuICogQGFwaSBwcml2YXRlXG4gKlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmlsdGVyVXBncmFkZXMgPSBmdW5jdGlvbiAodXBncmFkZXMpIHtcbiAgdmFyIGZpbHRlcmVkVXBncmFkZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGogPSB1cGdyYWRlcy5sZW5ndGg7IGk8ajsgaSsrKSB7XG4gICAgaWYgKH5pbmRleCh0aGlzLnRyYW5zcG9ydHMsIHVwZ3JhZGVzW2ldKSkgZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKTtcbiAgfVxuICByZXR1cm4gZmlsdGVyZWRVcGdyYWRlcztcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEEgY291bnRlciB1c2VkIHRvIHByZXZlbnQgY29sbGlzaW9ucyBpbiB0aGUgdGltZXN0YW1wcyB1c2VkXG4gKiBmb3IgY2FjaGUgYnVzdGluZy5cbiAqL1xuXG5UcmFuc3BvcnQudGltZXN0YW1wcyA9IDA7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgcGFja2V0ID0gcGFyc2VyLmRlY29kZVBhY2tldChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTtcbiAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBhIGRlY29kZWQgcGFja2V0LlxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScpO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG52YXIgWEhSID0gcmVxdWlyZSgnLi9wb2xsaW5nLXhocicpO1xudmFyIEpTT05QID0gcmVxdWlyZSgnLi9wb2xsaW5nLWpzb25wJyk7XG52YXIgd2Vic29ja2V0ID0gcmVxdWlyZSgnLi93ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnQgdHJhbnNwb3J0cy5cbiAqL1xuXG5leHBvcnRzLnBvbGxpbmcgPSBwb2xsaW5nO1xuZXhwb3J0cy53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG5cbi8qKlxuICogUG9sbGluZyB0cmFuc3BvcnQgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKiBEZWNpZGVzIG9uIHhociB2cyBqc29ucCBiYXNlZCBvbiBmZWF0dXJlIGRldGVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb2xsaW5nKG9wdHMpe1xuICB2YXIgeGhyO1xuICB2YXIgeGQgPSBmYWxzZTtcbiAgdmFyIHhzID0gZmFsc2U7XG4gIHZhciBqc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgeHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICBvcHRzLnhzY2hlbWUgPSB4cztcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWpzb25wKSB0aHJvdyBuZXcgRXJyb3IoJ0pTT05QIGRpc2FibGVkJyk7XG4gICAgcmV0dXJuIG5ldyBKU09OUChvcHRzKTtcbiAgfVxufVxuIiwiXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIENhbGxiYWNrcyBjb3VudC5cbiAqL1xuXG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0sIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KEpTT05QUG9sbGluZywgUG9sbGluZyk7XG5cbi8qXG4gKiBKU09OUCBvbmx5IHN1cHBvcnRzIGJpbmFyeSBhcyBiYXNlNjQgZW5jb2RlZCBzdHJpbmdzXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuXG4vKipcbiAqIENsb3NlcyB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgaWYgKHRoaXMuZm9ybSkge1xuICAgIHRoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7XG4gICAgdGhpcy5mb3JtID0gbnVsbDtcbiAgICB0aGlzLmlmcmFtZSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJysgc2VsZi5pZnJhbWVJZCArJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcbiIsIi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpO1xudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUjtcbm1vZHVsZS5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIEVtcHR5IGZ1bmN0aW9uXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoKXt9XG5cbi8qKlxuICogWEhSIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gWEhSKG9wdHMpe1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHRoaXMueGQgPSBvcHRzLmhvc3RuYW1lICE9IGdsb2JhbC5sb2NhdGlvbi5ob3N0bmFtZSB8fFxuICAgICAgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gICAgdGhpcy54cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24ob3B0cyl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLnhzID0gdGhpcy54cztcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICBvcHRzLmVuYWJsZXNYRFIgPSB0aGlzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbihkYXRhLCBmbil7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG9wdHMpe1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLnhzID0gISFvcHRzLnhzO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5pc0JpbmFyeSA9IG9wdHMuaXNCaW5hcnk7XG4gIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBvcHRzLnN1cHBvcnRzQmluYXJ5O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHRoaXMuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbigpe1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQsIHhzY2hlbWU6IHRoaXMueHMsIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUiB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgIC8vIFRoaXMgaGFzIHRvIGJlIGRvbmUgYWZ0ZXIgb3BlbiBiZWNhdXNlIEZpcmVmb3ggaXMgc3R1cGlkXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMjE2OTAzL2dldC1iaW5hcnktZGF0YS13aXRoLXhtbGh0dHByZXF1ZXN0LWluLWEtZmlyZWZveC1leHRlbnNpb25cbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIH1cblxuICAgIGlmICgnUE9TVCcgPT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmluYXJ5KSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ3RleHQvcGxhaW47Y2hhcnNldD1VVEYtOCcpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7fVxuICAgIH1cblxuICAgIC8vIGllNiBjaGVja1xuICAgIGlmICgnd2l0aENyZWRlbnRpYWxzJyBpbiB4aHIpIHtcbiAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgICB4aHIub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgIH07XG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09IHhoci5zdGF0dXMgfHwgMTIyMyA9PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgc2VsZi5vbkxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIGRlYnVnKCd4aHIgZGF0YSAlcycsIHRoaXMuZGF0YSk7XG4gICAgeGhyLnNlbmQodGhpcy5kYXRhKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIE5lZWQgdG8gZGVmZXIgc2luY2UgLmNyZWF0ZSgpIGlzIGNhbGxlZCBkaXJlY3RseSBmaHJvbSB0aGUgY29uc3RydWN0b3JcbiAgICAvLyBhbmQgdGh1cyB0aGUgJ2Vycm9yJyBldmVudCBjYW4gb25seSBiZSBvbmx5IGJvdW5kICphZnRlciogdGhpcyBleGNlcHRpb25cbiAgICAvLyBvY2N1cnMuICBUaGVyZWZvcmUsIGFsc28sIHdlIGNhbm5vdCB0aHJvdyBoZXJlIGF0IGFsbC5cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICB0aGlzLmluZGV4ID0gUmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7XG4gICAgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XSA9IHRoaXM7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZXNwb25zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vblN1Y2Nlc3MgPSBmdW5jdGlvbigpe1xuICB0aGlzLmVtaXQoJ3N1Y2Nlc3MnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCBpZiB3ZSBoYXZlIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHRoaXMuZW1pdCgnZGF0YScsIGRhdGEpO1xuICB0aGlzLm9uU3VjY2VzcygpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMuY2xlYW51cCh0cnVlKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbihmcm9tRXJyb3Ipe1xuICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIGlmICh0aGlzLmhhc1hEUigpKSB7XG4gICAgdGhpcy54aHIub25sb2FkID0gdGhpcy54aHIub25lcnJvciA9IGVtcHR5O1xuICB9IGVsc2Uge1xuICAgIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuICB9XG5cbiAgaWYgKGZyb21FcnJvcikge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2goZSkge31cbiAgfVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gbG9hZC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkxvYWQgPSBmdW5jdGlvbigpe1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICB2YXIgY29udGVudFR5cGU7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnRlbnRUeXBlID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpLnNwbGl0KCc7JylbMF07XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICBkYXRhID0gdGhpcy54aHIucmVzcG9uc2VUZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9ICdvayc7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy5vbkVycm9yKGUpO1xuICB9XG4gIGlmIChudWxsICE9IGRhdGEpIHtcbiAgICB0aGlzLm9uRGF0YShkYXRhKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpdCBoYXMgWERvbWFpblJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuaGFzWERSID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICd1bmRlZmluZWQnICE9PSB0eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmICF0aGlzLnhzICYmIHRoaXMuZW5hYmxlc1hEUjtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIFJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG4gIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcbiAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyLCBmYWxzZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyB4ZG9tYWluOiBmYWxzZSB9KTtcbiAgcmV0dXJuIG51bGwgIT0geGhyLnJlc3BvbnNlVHlwZTtcbn0pKCk7XG5cbi8qKlxuICogUG9sbGluZyBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFBvbGxpbmcob3B0cyl7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoIWhhc1hIUjIgfHwgZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChQb2xsaW5nLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm5hbWUgPSAncG9sbGluZyc7XG5cbi8qKlxuICogT3BlbnMgdGhlIHNvY2tldCAodHJpZ2dlcnMgcG9sbGluZykuIFdlIHdyaXRlIGEgUElORyBtZXNzYWdlIHRvIGRldGVybWluZVxuICogd2hlbiB0aGUgdHJhbnNwb3J0IGlzIG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5wb2xsKCk7XG59O1xuXG4vKipcbiAqIFBhdXNlcyBwb2xsaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHVwb24gYnVmZmVycyBhcmUgZmx1c2hlZCBhbmQgdHJhbnNwb3J0IGlzIHBhdXNlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbihvblBhdXNlKXtcbiAgdmFyIHBlbmRpbmcgPSAwO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ3BhdXNpbmcnO1xuXG4gIGZ1bmN0aW9uIHBhdXNlKCl7XG4gICAgZGVidWcoJ3BhdXNlZCcpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdwYXVzZWQnO1xuICAgIG9uUGF1c2UoKTtcbiAgfVxuXG4gIGlmICh0aGlzLnBvbGxpbmcgfHwgIXRoaXMud3JpdGFibGUpIHtcbiAgICB2YXIgdG90YWwgPSAwO1xuXG4gICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ3BvbGxDb21wbGV0ZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMud3JpdGFibGUpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHdyaXRpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCl7XG4gICAgICAgIGRlYnVnKCdwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZScpO1xuICAgICAgICAtLXRvdGFsIHx8IHBhdXNlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGF1c2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTdGFydHMgcG9sbGluZyBjeWNsZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygncG9sbGluZycpO1xuICB0aGlzLnBvbGxpbmcgPSB0cnVlO1xuICB0aGlzLmRvUG9sbCgpO1xuICB0aGlzLmVtaXQoJ3BvbGwnKTtcbn07XG5cbi8qKlxuICogT3ZlcmxvYWRzIG9uRGF0YSB0byBkZXRlY3QgcGF5bG9hZHMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZGVidWcoJ3BvbGxpbmcgZ290IGRhdGEgJXMnLCBkYXRhKTtcbiAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24ocGFja2V0LCBpbmRleCwgdG90YWwpIHtcbiAgICAvLyBpZiBpdHMgdGhlIGZpcnN0IG1lc3NhZ2Ugd2UgY29uc2lkZXIgdGhlIHRyYW5zcG9ydCBvcGVuXG4gICAgaWYgKCdvcGVuaW5nJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgIHNlbGYub25PcGVuKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgaXRzIGEgY2xvc2UgcGFja2V0LCB3ZSBjbG9zZSB0aGUgb25nb2luZyByZXF1ZXN0c1xuICAgIGlmICgnY2xvc2UnID09IHBhY2tldC50eXBlKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UgYnlwYXNzIG9uRGF0YSBhbmQgaGFuZGxlIHRoZSBtZXNzYWdlXG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9O1xuXG4gIC8vIGRlY29kZSBwYXlsb2FkXG4gIHBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcblxuICAvLyBpZiBhbiBldmVudCBkaWQgbm90IHRyaWdnZXIgY2xvc2luZ1xuICBpZiAoJ2Nsb3NlZCcgIT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgLy8gaWYgd2UgZ290IGRhdGEgd2UncmUgbm90IHBvbGxpbmdcbiAgICB0aGlzLnBvbGxpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BvbGxDb21wbGV0ZScpO1xuXG4gICAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgIHRoaXMucG9sbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLCB0aGlzLnJlYWR5U3RhdGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBGb3IgcG9sbGluZywgc2VuZCBhIGNsb3NlIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIGNsb3NlKCl7XG4gICAgZGVidWcoJ3dyaXRpbmcgY2xvc2UgcGFja2V0Jyk7XG4gICAgc2VsZi53cml0ZShbeyB0eXBlOiAnY2xvc2UnIH1dKTtcbiAgfVxuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3RyYW5zcG9ydCBvcGVuIC0gY2xvc2luZycpO1xuICAgIGNsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaW4gY2FzZSB3ZSdyZSB0cnlpbmcgdG8gY2xvc2Ugd2hpbGVcbiAgICAvLyBoYW5kc2hha2luZyBpcyBpbiBwcm9ncmVzcyAoR0gtMTY0KVxuICAgIGRlYnVnKCd0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2UnKTtcbiAgICB0aGlzLm9uY2UoJ29wZW4nLCBjbG9zZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0cyBwYXlsb2FkLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGRhdGEgcGFja2V0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZHJhaW4gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICB2YXIgY2FsbGJhY2tmbiA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICBzZWxmLmRvV3JpdGUoZGF0YSwgY2FsbGJhY2tmbik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICdodHRwcycgOiAnaHR0cCc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gY2FjaGUgYnVzdGluZyBpcyBmb3JjZWRcbiAgaWYgKGZhbHNlICE9PSB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSArbmV3IERhdGUgKyAnLScgKyBUcmFuc3BvcnQudGltZXN0YW1wcysrO1xuICB9XG5cbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmICFxdWVyeS5zaWQpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCdodHRwcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpIHx8XG4gICAgICgnaHR0cCcgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIHRoaXMuaG9zdG5hbWUgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0Jyk7XG5cbi8qKlxuICogYHdzYCBleHBvc2VzIGEgV2ViU29ja2V0LWNvbXBhdGlibGUgaW50ZXJmYWNlIGluXG4gKiBOb2RlLCBvciB0aGUgYFdlYlNvY2tldGAgb3IgYE1veldlYlNvY2tldGAgZ2xvYmFsc1xuICogaW4gdGhlIGJyb3dzZXIuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IHJlcXVpcmUoJ3dzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXUztcblxuLyoqXG4gKiBXZWJTb2NrZXQgdHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkge09iamVjdH0gY29ubmVjdGlvbiBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFdTKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoV1MsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUubmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vKlxuICogV2ViU29ja2V0cyBzdXBwb3J0IGJpbmFyeVxuICovXG5cbldTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogT3BlbnMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuY2hlY2soKSkge1xuICAgIC8vIGxldCBwcm9iZSB0aW1lb3V0XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdXJpID0gdGhpcy51cmkoKTtcbiAgdmFyIHByb3RvY29scyA9IHZvaWQoMCk7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCB9O1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG5cbiAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uT3BlbigpO1xuICB9O1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KXtcbiAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYG9uRGF0YWAgdG8gdXNlIGEgdGltZXIgb24gaU9TLlxuICogU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tbG91Z2hyYW4vMjA1MjAwNlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yXG4gICYmIC9pUGFkfGlQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICBXUy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhLmNhbGwoc2VsZiwgZGF0YSk7XG4gICAgfSwgMCk7XG4gIH07XG59XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWNrZXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0c1tpXSwgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgLy9Tb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAvL2hhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgLy90aHJvdyBhbiBlcnJvclxuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfVxuICAvLyBmYWtlIGRyYWluXG4gIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgc2V0VGltZW91dChvbmRyYWluLCAwKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcbiAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKVxuICAgIHx8ICgnd3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0gK25ldyBEYXRlO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyB0aGlzLmhvc3RuYW1lICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIHNjaGVtZSBtdXN0IGJlIHNhbWUgd2hlbiB1c2lnbiBYRG9tYWluUmVxdWVzdFxuICAvLyBodHRwOi8vYmxvZ3MubXNkbi5jb20vYi9pZWludGVybmFscy9hcmNoaXZlLzIwMTAvMDUvMTMveGRvbWFpbnJlcXVlc3QtcmVzdHJpY3Rpb25zLWxpbWl0YXRpb25zLWFuZC13b3JrYXJvdW5kcy5hc3B4XG4gIHZhciB4c2NoZW1lID0gb3B0cy54c2NoZW1lO1xuXG4gIC8vIFhEb21haW5SZXF1ZXN0IGhhcyBhIGZsb3cgb2Ygbm90IHNlbmRpbmcgY29va2llLCB0aGVyZWZvcmUgaXQgc2hvdWxkIGJlIGRpc2FibGVkIGFzIGEgZGVmYXVsdC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0F1dG9tYXR0aWMvZW5naW5lLmlvLWNsaWVudC9wdWxsLzIxN1xuICB2YXIgZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgLy8gVXNlIFhEb21haW5SZXF1ZXN0IGZvciBJRTggaWYgZW5hYmxlc1hEUiBpcyB0cnVlXG4gIC8vIGJlY2F1c2UgbG9hZGluZyBiYXIga2VlcHMgZmxhc2hpbmcgd2hlbiB1c2luZyBqc29ucC1wb2xsaW5nXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS95dWppb3Nha2Evc29ja2UuaW8taWU4LWxvYWRpbmctZXhhbXBsZVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWERvbWFpblJlcXVlc3QgJiYgIXhzY2hlbWUgJiYgZW5hYmxlc1hEUikge1xuICAgICAgcmV0dXJuIG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoKGUpIHsgfVxuICB9XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG4gIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcbiAgZm4ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGZuO1xuICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG59OyIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGVidWcnKTtcbmV4cG9ydHMubG9nID0gbG9nO1xuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuICAnbGlnaHRzZWFncmVlbicsXG4gICdmb3Jlc3RncmVlbicsXG4gICdnb2xkZW5yb2QnLFxuICAnZG9kZ2VyYmx1ZScsXG4gICdkYXJrb3JjaGlkJyxcbiAgJ2NyaW1zb24nXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gaXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcbiAgcmV0dXJuICgnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlKSB8fFxuICAgIC8vIGlzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgICAod2luZG93LmNvbnNvbGUgJiYgKGNvbnNvbGUuZmlyZWJ1ZyB8fCAoY29uc29sZS5leGNlcHRpb24gJiYgY29uc29sZS50YWJsZSkpKSB8fFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuICAgIChuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSk7XG59XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG59O1xuXG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncygpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBhcmdzWzBdID0gKHVzZUNvbG9ycyA/ICclYycgOiAnJylcbiAgICArIHRoaXMubmFtZXNwYWNlXG4gICAgKyAodXNlQ29sb3JzID8gJyAlYycgOiAnICcpXG4gICAgKyBhcmdzWzBdXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXG4gICAgKyAnKycgKyBleHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybiBhcmdzO1xuXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcbiAgYXJncyA9IFthcmdzWzBdLCBjLCAnY29sb3I6IGluaGVyaXQnXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgMSkpO1xuXG4gIC8vIHRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cbiAgLy8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIGlmICgnJSUnID09PSBtYXRjaCkgcmV0dXJuO1xuICAgIGluZGV4Kys7XG4gICAgaWYgKCclYycgPT09IG1hdGNoKSB7XG4gICAgICAvLyB3ZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG5cbiAgYXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xuICByZXR1cm4gYXJncztcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmxvZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb2coKSB7XG4gIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4LFxuICAvLyB3aGVyZSB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT0gdHlwZW9mIGNvbnNvbGVcbiAgICAmJiAnZnVuY3Rpb24nID09IHR5cGVvZiBjb25zb2xlLmxvZ1xuICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcbiAgdHJ5IHtcbiAgICBpZiAobnVsbCA9PSBuYW1lc3BhY2VzKSB7XG4gICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYWxTdG9yYWdlLmRlYnVnID0gbmFtZXNwYWNlcztcbiAgICB9XG4gIH0gY2F0Y2goZSkge31cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2FkKCkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICByID0gbG9jYWxTdG9yYWdlLmRlYnVnO1xuICB9IGNhdGNoKGUpIHt9XG4gIHJldHVybiByO1xufVxuXG4vKipcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXG4gKi9cblxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucyl7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHZhbCkgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIHJldHVybiBvcHRpb25zLmxvbmdcbiAgICA/IGxvbmcodmFsKVxuICAgIDogc2hvcnQodmFsKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICB2YXIgbWF0Y2ggPSAvXigoPzpcXGQrKT9cXC4/XFxkKykgKihtc3xzZWNvbmRzP3xzfG1pbnV0ZXM/fG18aG91cnM/fGh8ZGF5cz98ZHx5ZWFycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2hvcnQobXMpIHtcbiAgaWYgKG1zID49IGQpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIGlmIChtcyA+PSBoKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICBpZiAobXMgPj0gbSkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgaWYgKG1zID49IHMpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb25nKG1zKSB7XG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKVxuICAgIHx8IHBsdXJhbChtcywgaCwgJ2hvdXInKVxuICAgIHx8IHBsdXJhbChtcywgbSwgJ21pbnV0ZScpXG4gICAgfHwgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJylcbiAgICB8fCBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbiwgbmFtZSkge1xuICBpZiAobXMgPCBuKSByZXR1cm47XG4gIGlmIChtcyA8IG4gKiAxLjUpIHJldHVybiBNYXRoLmZsb29yKG1zIC8gbikgKyAnICcgKyBuYW1lO1xuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgaGFzQmluYXJ5ID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xudmFyIHNsaWNlQnVmZmVyID0gcmVxdWlyZSgnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGluIFBoYW50b21KUy5cbiAqIFVwbG9hZGluZyBhIEJsb2Igd2l0aCBQaGFudG9tSlMgZG9lcyBub3Qgd29yayBjb3JyZWN0bHksIGFzIHJlcG9ydGVkIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTM5NVxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgaXNQaGFudG9tSlMgPSAvUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBXaGVuIHRydWUsIGF2b2lkcyB1c2luZyBCbG9icyB0byBlbmNvZGUgcGF5bG9hZHMuXG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBkb250U2VuZEJsb2JzID0gaXNBbmRyb2lkIHx8IGlzUGhhbnRvbUpTO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBzdXBwb3J0c0JpbmFyeSkge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiB1dGY4ZW5jb2RlKSB7XG4gICAgY2FsbGJhY2sgPSB1dGY4ZW5jb2RlO1xuICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIG1pZ2h0IGJlIGFuIG9iamVjdCB3aXRoIHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgIHJldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIC8vIHBhY2tldCBkYXRhIGlzIGFuIG9iamVjdCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdICsgcGFja2V0LmRhdGEuZGF0YTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoZG9udFNlbmRCbG9icykge1xuICAgIHJldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGxlbmd0aFswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLCBwYWNrZXQuZGF0YV0pO1xuXG4gIHJldHVybiBjYWxsYmFjayhibG9iKTtcbn1cblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuXG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgY2FsbGJhY2spIHtcbiAgdmFyIG1lc3NhZ2UgPSAnYicgKyBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBpZiAoQmxvYiAmJiBwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGI2NCA9IGZyLnJlc3VsdC5zcGxpdCgnLCcpWzFdO1xuICAgICAgY2FsbGJhY2sobWVzc2FnZSArIGI2NCk7XG4gICAgfTtcbiAgICByZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSk7XG4gIH1cblxuICB2YXIgYjY0ZGF0YTtcbiAgdHJ5IHtcbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgd2l0aCB0eXBlZCBhcnJheXNcbiAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7XG4gICAgdmFyIGJhc2ljID0gbmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgYmFzaWNbaV0gPSB0eXBlZFtpXTtcbiAgICB9XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYmFzaWMpO1xuICB9XG4gIG1lc3NhZ2UgKz0gZ2xvYmFsLmJ0b2EoYjY0ZGF0YSk7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gQ2hhbmdlcyBmb3JtYXQgdG8gQmxvYiBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBhY2tldCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCB1dGY4ZGVjb2RlKSB7XG4gIC8vIFN0cmluZyBkYXRhXG4gIGlmICh0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJyB8fCBkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoZGF0YS5jaGFyQXQoMCkgPT0gJ2InKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgIH1cblxuICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICB2YXIgaXNCaW5hcnkgPSBoYXNCaW5hcnkocGFja2V0cyk7XG5cbiAgaWYgKHN1cHBvcnRzQmluYXJ5ICYmIGlzQmluYXJ5KSB7XG4gICAgaWYgKEJsb2IgJiYgIWRvbnRTZW5kQmxvYnMpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsICFpc0JpbmFyeSA/IGZhbHNlIDogc3VwcG9ydHNCaW5hcnksIHRydWUsIGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbignJykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQXN5bmMgYXJyYXkgbWFwIHVzaW5nIGFmdGVyXG4gKi9cblxuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KGFyeS5sZW5ndGgpO1xuICB2YXIgbmV4dCA9IGFmdGVyKGFyeS5sZW5ndGgsIGRvbmUpO1xuXG4gIHZhciBlYWNoV2l0aEluZGV4ID0gZnVuY3Rpb24oaSwgZWwsIGNiKSB7XG4gICAgZWFjaChlbCwgZnVuY3Rpb24oZXJyb3IsIG1zZykge1xuICAgICAgcmVzdWx0W2ldID0gbXNnO1xuICAgICAgY2IoZXJyb3IsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBlYWNoV2l0aEluZGV4KGksIGFyeVtpXSwgbmV4dCk7XG4gIH1cbn1cblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgZGF0YSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgcGFja2V0O1xuICBpZiAoZGF0YSA9PSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSAnJ1xuICAgICwgbiwgbXNnO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG5cbiAgICBpZiAoJzonICE9IGNocikge1xuICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCcnID09IGxlbmd0aCB8fCAobGVuZ3RoICE9IChuID0gTnVtYmVyKGxlbmd0aCkpKSkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG5cbiAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgfVxuXG4gICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICBwYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIHRydWUpO1xuXG4gICAgICAgIGlmIChlcnIudHlwZSA9PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICAgIC8vIHBhcnNlciBlcnJvciBpbiBpbmRpdmlkdWFsIHBhY2tldCAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXQgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgaWYgKGZhbHNlID09PSByZXQpIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgIGkgKz0gbjtcbiAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsZW5ndGggIT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0FycmF5QnVmZmVyfSBlbmNvZGVkIHBheWxvYWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBBcnJheUJ1ZmZlcigwKSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIGVuY29kZWRQYWNrZXRzKSB7XG4gICAgdmFyIHRvdGFsTGVuZ3RoID0gZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYywgcCkge1xuICAgICAgdmFyIGxlbjtcbiAgICAgIGlmICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpe1xuICAgICAgICBsZW4gPSBwLmxlbmd0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IHAuYnl0ZUxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2MgKyBsZW4udG9TdHJpbmcoKS5sZW5ndGggKyBsZW4gKyAyOyAvLyBzdHJpbmcvYmluYXJ5IGlkZW50aWZpZXIgKyBzZXBhcmF0b3IgPSAyXG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0QXJyYXkgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG5cbiAgICB2YXIgYnVmZmVySW5kZXggPSAwO1xuICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIHAgPT09ICdzdHJpbmcnO1xuICAgICAgdmFyIGFiID0gcDtcbiAgICAgIGlmIChpc1N0cmluZykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IHAuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBhYiA9IHZpZXcuYnVmZmVyO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNTdHJpbmcpIHsgLy8gbm90IHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMDtcbiAgICAgIH0gZWxzZSB7IC8vIHRydWUgYmluYXJ5XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlblN0ciA9IGFiLmJ5dGVMZW5ndGgudG9TdHJpbmcoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gMjU1O1xuXG4gICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGFiKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHZpZXdbaV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEVuY29kZSBhcyBCbG9iXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihlbmNvZGVkKSB7XG4gICAgICB2YXIgYmluYXJ5SWRlbnRpZmllciA9IG5ldyBVaW50OEFycmF5KDEpO1xuICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDE7XG4gICAgICBpZiAodHlwZW9mIGVuY29kZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gZW5jb2RlZC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGVuY29kZWQgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgICAgYmluYXJ5SWRlbnRpZmllclswXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSAoZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICA/IGVuY29kZWQuYnl0ZUxlbmd0aFxuICAgICAgICA6IGVuY29kZWQuc2l6ZTtcblxuICAgICAgdmFyIGxlblN0ciA9IGxlbi50b1N0cmluZygpO1xuICAgICAgdmFyIGxlbmd0aEFyeSA9IG5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGggKyAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuU3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxlbmd0aEFyeVtpXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICBsZW5ndGhBcnlbbGVuU3RyLmxlbmd0aF0gPSAyNTU7XG5cbiAgICAgIGlmIChCbG9iKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLCBsZW5ndGhBcnkuYnVmZmVyLCBlbmNvZGVkXSk7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBibG9iKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQmxvYihyZXN1bHRzKSk7XG4gIH0pO1xufTtcblxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG4gKlxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcblxuICB2YXIgbnVtYmVyVG9vTG9uZyA9IGZhbHNlO1xuICB3aGlsZSAoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoID4gMCkge1xuICAgIHZhciB0YWlsQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJUYWlsKTtcbiAgICB2YXIgaXNTdHJpbmcgPSB0YWlsQXJyYXlbMF0gPT09IDA7XG4gICAgdmFyIG1zZ0xlbmd0aCA9ICcnO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG5cbiAgICAgIGlmIChtc2dMZW5ndGgubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgIG51bWJlclRvb0xvbmcgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgbXNnTGVuZ3RoICs9IHRhaWxBcnJheVtpXTtcbiAgICB9XG5cbiAgICBpZihudW1iZXJUb29Mb25nKSByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcblxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIG1zZ0xlbmd0aCk7XG4gIH1cblxuICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgYnVmZmVycy5mb3JFYWNoKGZ1bmN0aW9uKGJ1ZmZlciwgaSkge1xuICAgIGNhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgfSk7XG59O1xuIiwiXG4vKipcbiAqIEdldHMgdGhlIGtleXMgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuICB2YXIgYXJyID0gW107XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gYWZ0ZXJcblxuZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcbiAgICB2YXIgYmFpbCA9IGZhbHNlXG4gICAgZXJyX2NiID0gZXJyX2NiIHx8IG5vb3BcbiAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cbiAgICByZXR1cm4gKGNvdW50ID09PSAwKSA/IGNhbGxiYWNrKCkgOiBwcm94eVxuXG4gICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHByb3h5LmNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcbiAgICAgICAgfVxuICAgICAgICAtLXByb3h5LmNvdW50XG5cbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgZXJyb3IsIHJlc3QgYXJlIHBhc3NlZCB0byBlcnJfY2JcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgYmFpbCA9IHRydWVcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIC8vIGZ1dHVyZSBlcnJvciBjYWxsYmFja3Mgd2lsbCBnbyB0byBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuICAgICAgICB9IGVsc2UgaWYgKHByb3h5LmNvdW50ID09PSAwICYmICFiYWlsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcbiIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbihjaGFycyl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcbiAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG4gICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG4iLCIvKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CbG9iO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcbiIsIlxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICBpZiAob2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8qISBodHRwOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cDovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShjb2RlUG9pbnRzLm1hcChmdW5jdGlvbih4KSB7XG5cdFx0Ly8gXHRyZXR1cm4gJ1UrJyArIHgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdFx0Ly8gfSkpKTtcblxuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHR2YXIgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpIHtcblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjAuMCcsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJ2dsb2JhbCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICpcbiAqIExvZ2ljIGJvcnJvd2VkIGZyb20gTW9kZXJuaXpyOlxuICpcbiAqICAgLSBodHRwczovL2dpdGh1Yi5jb20vTW9kZXJuaXpyL01vZGVybml6ci9ibG9iL21hc3Rlci9mZWF0dXJlLWRldGVjdHMvY29ycy5qc1xuICovXG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gJ1hNTEh0dHBSZXF1ZXN0JyBpbiBnbG9iYWwgJiZcbiAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KCk7XG59IGNhdGNoIChlcnIpIHtcbiAgLy8gaWYgWE1MSHR0cCBzdXBwb3J0IGlzIGRpc2FibGVkIGluIElFIHRoZW4gaXQgd2lsbCB0aHJvd1xuICAvLyB3aGVuIHRyeWluZyB0byBjcmVhdGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbn1cbiIsIlxuLyoqXG4gKiBSZXR1cm5zIGB0aGlzYC4gRXhlY3V0ZSB0aGlzIHdpdGhvdXQgYSBcImNvbnRleHRcIiAoaS5lLiB3aXRob3V0IGl0IGJlaW5nXG4gKiBhdHRhY2hlZCB0byBhbiBvYmplY3Qgb2YgdGhlIGxlZnQtaGFuZCBzaWRlKSwgYW5kIGB0aGlzYCBwb2ludHMgdG8gdGhlXG4gKiBcImdsb2JhbFwiIHNjb3BlIG9mIHRoZSBjdXJyZW50IEpTIGV4ZWN1dGlvbi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIi8qKlxuICogSlNPTiBwYXJzZS5cbiAqXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuICB9XG59OyIsIi8qKlxuICogQ29tcGlsZXMgYSBxdWVyeXN0cmluZ1xuICogUmV0dXJucyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIGlmIChzdHIubGVuZ3RoKSBzdHIgKz0gJyYnO1xuICAgICAgc3RyICs9IGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHNpbXBsZSBxdWVyeXN0cmluZyBpbnRvIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbihxcyl7XG4gIHZhciBxcnkgPSB7fTtcbiAgdmFyIHBhaXJzID0gcXMuc3BsaXQoJyYnKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWlycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgcXJ5W2RlY29kZVVSSUNvbXBvbmVudChwYWlyWzBdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gIH1cbiAgcmV0dXJuIHFyeTtcbn07XG4iLCIvKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCcsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgICB2YXIgc3JjID0gc3RyLFxuICAgICAgICBiID0gc3RyLmluZGV4T2YoJ1snKSxcbiAgICAgICAgZSA9IHN0ci5pbmRleE9mKCddJyk7XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgYikgKyBzdHIuc3Vic3RyaW5nKGIsIGUpLnJlcGxhY2UoLzovZywgJzsnKSArIHN0ci5zdWJzdHJpbmcoZSwgc3RyLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJyksXG4gICAgICAgIHVyaSA9IHt9LFxuICAgICAgICBpID0gMTQ7XG5cbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICAgIH1cblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgdXJpLnNvdXJjZSA9IHNyYztcbiAgICAgICAgdXJpLmhvc3QgPSB1cmkuaG9zdC5zdWJzdHJpbmcoMSwgdXJpLmhvc3QubGVuZ3RoIC0gMSkucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuYXV0aG9yaXR5ID0gdXJpLmF1dGhvcml0eS5yZXBsYWNlKCdbJywgJycpLnJlcGxhY2UoJ10nLCAnJykucmVwbGFjZSgvOy9nLCAnOicpO1xuICAgICAgICB1cmkuaXB2NnVyaSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVyaTtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKi9cblxudmFyIFdlYlNvY2tldCA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldCA/IHdzIDogbnVsbDtcblxuLyoqXG4gKiBXZWJTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogVGhlIHRoaXJkIGBvcHRzYCBvcHRpb25zIG9iamVjdCBnZXRzIGlnbm9yZWQgaW4gd2ViIGJyb3dzZXJzLCBzaW5jZSBpdCdzXG4gKiBub24tc3RhbmRhcmQsIGFuZCB0aHJvd3MgYSBUeXBlRXJyb3IgaWYgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2VpbmFyb3Mvd3MvaXNzdWVzLzIyN1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyAob3B0aW9uYWwpXG4gKiBAcGFyYW0ge09iamVjdCkgb3B0cyAob3B0aW9uYWwpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHdzKHVyaSwgcHJvdG9jb2xzLCBvcHRzKSB7XG4gIHZhciBpbnN0YW5jZTtcbiAgaWYgKHByb3RvY29scykge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scyk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSk7XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG5pZiAoV2ViU29ja2V0KSB3cy5wcm90b3R5cGUgPSBXZWJTb2NrZXQucHJvdG90eXBlO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2NvcmUuanMnKVxucmVxdWlyZSgnLi9saWIvZG9uZS5qcycpXG5yZXF1aXJlKCcuL2xpYi9lczYtZXh0ZW5zaW9ucy5qcycpXG5yZXF1aXJlKCcuL2xpYi9ub2RlLWV4dGVuc2lvbnMuanMnKSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJylcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlcyBtdXN0IGJlIGNvbnN0cnVjdGVkIHZpYSBuZXcnKVxuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpXG4gIHZhciBzdGF0ZSA9IG51bGxcbiAgdmFyIHZhbHVlID0gbnVsbFxuICB2YXIgZGVmZXJyZWRzID0gW11cbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgdGhpcy50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICByZXR1cm4gbmV3IHNlbGYuY29uc3RydWN0b3IoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBoYW5kbGUobmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCkpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZShkZWZlcnJlZCkge1xuICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgZGVmZXJyZWRzLnB1c2goZGVmZXJyZWQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYXNhcChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjYiA9IHN0YXRlID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkXG4gICAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgKHN0YXRlID8gZGVmZXJyZWQucmVzb2x2ZSA6IGRlZmVycmVkLnJlamVjdCkodmFsdWUpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdmFyIHJldFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0ID0gY2IodmFsdWUpXG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QoZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBkZWZlcnJlZC5yZXNvbHZlKHJldClcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzb2x2ZShuZXdWYWx1ZSkge1xuICAgIHRyeSB7IC8vUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgICAgIGlmIChuZXdWYWx1ZSA9PT0gc2VsZikgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKVxuICAgICAgaWYgKG5ld1ZhbHVlICYmICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuXG4gICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGRvUmVzb2x2ZSh0aGVuLmJpbmQobmV3VmFsdWUpLCByZXNvbHZlLCByZWplY3QpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXRlID0gdHJ1ZVxuICAgICAgdmFsdWUgPSBuZXdWYWx1ZVxuICAgICAgZmluYWxlKClcbiAgICB9IGNhdGNoIChlKSB7IHJlamVjdChlKSB9XG4gIH1cblxuICBmdW5jdGlvbiByZWplY3QobmV3VmFsdWUpIHtcbiAgICBzdGF0ZSA9IGZhbHNlXG4gICAgdmFsdWUgPSBuZXdWYWx1ZVxuICAgIGZpbmFsZSgpXG4gIH1cblxuICBmdW5jdGlvbiBmaW5hbGUoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgIGhhbmRsZShkZWZlcnJlZHNbaV0pXG4gICAgZGVmZXJyZWRzID0gbnVsbFxuICB9XG5cbiAgZG9SZXNvbHZlKGZuLCByZXNvbHZlLCByZWplY3QpXG59XG5cblxuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0KXtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbFxuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsXG4gIHRoaXMucmVzb2x2ZSA9IHJlc29sdmVcbiAgdGhpcy5yZWplY3QgPSByZWplY3Rcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgZm4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICBkb25lID0gdHJ1ZVxuICAgICAgb25GdWxmaWxsZWQodmFsdWUpXG4gICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgaWYgKGRvbmUpIHJldHVyblxuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIG9uUmVqZWN0ZWQocmVhc29uKVxuICAgIH0pXG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGRvbmUpIHJldHVyblxuICAgIGRvbmUgPSB0cnVlXG4gICAgb25SZWplY3RlZChleClcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2VcblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzXG4gIHNlbGYudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlcnJcbiAgICB9KVxuICB9KVxufSIsIid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGZpbGUgY29udGFpbnMgdGhlIEVTNiBleHRlbnNpb25zIHRvIHRoZSBjb3JlIFByb21pc2VzL0ErIEFQSVxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2VcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG5mdW5jdGlvbiBWYWx1ZVByb21pc2UodmFsdWUpIHtcbiAgdGhpcy50aGVuID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBvbkZ1bGZpbGxlZCAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmVzb2x2ZShvbkZ1bGZpbGxlZCh2YWx1ZSkpXG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9XG59XG5WYWx1ZVByb21pc2UucHJvdG90eXBlID0gUHJvbWlzZS5wcm90b3R5cGVcblxudmFyIFRSVUUgPSBuZXcgVmFsdWVQcm9taXNlKHRydWUpXG52YXIgRkFMU0UgPSBuZXcgVmFsdWVQcm9taXNlKGZhbHNlKVxudmFyIE5VTEwgPSBuZXcgVmFsdWVQcm9taXNlKG51bGwpXG52YXIgVU5ERUZJTkVEID0gbmV3IFZhbHVlUHJvbWlzZSh1bmRlZmluZWQpXG52YXIgWkVSTyA9IG5ldyBWYWx1ZVByb21pc2UoMClcbnZhciBFTVBUWVNUUklORyA9IG5ldyBWYWx1ZVByb21pc2UoJycpXG5cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gdmFsdWVcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBOVUxMXG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gVU5ERUZJTkVEXG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkgcmV0dXJuIFRSVUVcbiAgaWYgKHZhbHVlID09PSBmYWxzZSkgcmV0dXJuIEZBTFNFXG4gIGlmICh2YWx1ZSA9PT0gMCkgcmV0dXJuIFpFUk9cbiAgaWYgKHZhbHVlID09PSAnJykgcmV0dXJuIEVNUFRZU1RSSU5HXG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGVuID0gdmFsdWUudGhlblxuICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh0aGVuLmJpbmQodmFsdWUpKVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3QoZXgpXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgVmFsdWVQcm9taXNlKHZhbHVlKVxufVxuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpXG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiByZXNvbHZlKFtdKVxuICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aFxuICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlblxuICAgICAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhlbi5jYWxsKHZhbCwgZnVuY3Rpb24gKHZhbCkgeyByZXMoaSwgdmFsKSB9LCByZWplY3QpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJnc1tpXSA9IHZhbFxuICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZWplY3QoZXgpXG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzKGksIGFyZ3NbaV0pXG4gICAgfVxuICB9KVxufVxuXG5Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBcbiAgICByZWplY3QodmFsdWUpO1xuICB9KTtcbn1cblxuUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KVxuICB9KTtcbn1cblxuLyogUHJvdG90eXBlIE1ldGhvZHMgKi9cblxuUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgZmlsZSBjb250YWlucyB0aGVuL3Byb21pc2Ugc3BlY2lmaWMgZXh0ZW5zaW9ucyB0aGF0IGFyZSBvbmx5IHVzZWZ1bCBmb3Igbm9kZS5qcyBpbnRlcm9wXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJylcbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZVxuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cblByb21pc2UuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGZuLCBhcmd1bWVudENvdW50KSB7XG4gIGFyZ3VtZW50Q291bnQgPSBhcmd1bWVudENvdW50IHx8IEluZmluaXR5XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHdoaWxlIChhcmdzLmxlbmd0aCAmJiBhcmdzLmxlbmd0aCA+IGFyZ3VtZW50Q291bnQpIHtcbiAgICAgICAgYXJncy5wb3AoKVxuICAgICAgfVxuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKVxuICAgICAgICBlbHNlIHJlc29sdmUocmVzKVxuICAgICAgfSlcbiAgICAgIHZhciByZXMgPSBmbi5hcHBseShzZWxmLCBhcmdzKVxuICAgICAgaWYgKHJlcyAmJiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcyA9PT0gJ2Z1bmN0aW9uJykgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlc29sdmUocmVzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblByb21pc2Uubm9kZWlmeSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIHZhciBjYWxsYmFjayA9IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicgPyBhcmdzLnBvcCgpIDogbnVsbFxuICAgIHZhciBjdHggPSB0aGlzXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLm5vZGVpZnkoY2FsbGJhY2ssIGN0eClcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyByZWplY3QoZXgpIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlLm5vZGVpZnkgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrICE9ICdmdW5jdGlvbicpIHJldHVybiB0aGlzXG5cbiAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2suY2FsbChjdHgsIG51bGwsIHZhbHVlKVxuICAgIH0pXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlcnIpXG4gICAgfSlcbiAgfSlcbn1cbiIsIlxuLy8gVXNlIHRoZSBmYXN0ZXN0IHBvc3NpYmxlIG1lYW5zIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGEgZnV0dXJlIHR1cm5cbi8vIG9mIHRoZSBldmVudCBsb29wLlxuXG4vLyBsaW5rZWQgbGlzdCBvZiB0YXNrcyAoc2luZ2xlLCB3aXRoIGhlYWQgbm9kZSlcbnZhciBoZWFkID0ge3Rhc2s6IHZvaWQgMCwgbmV4dDogbnVsbH07XG52YXIgdGFpbCA9IGhlYWQ7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciByZXF1ZXN0Rmx1c2ggPSB2b2lkIDA7XG52YXIgaXNOb2RlSlMgPSBmYWxzZTtcblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgLyoganNoaW50IGxvb3BmdW5jOiB0cnVlICovXG5cbiAgICB3aGlsZSAoaGVhZC5uZXh0KSB7XG4gICAgICAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICAgICAgIHZhciB0YXNrID0gaGVhZC50YXNrO1xuICAgICAgICBoZWFkLnRhc2sgPSB2b2lkIDA7XG4gICAgICAgIHZhciBkb21haW4gPSBoZWFkLmRvbWFpbjtcblxuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBoZWFkLmRvbWFpbiA9IHZvaWQgMDtcbiAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhc2soKTtcblxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoaXNOb2RlSlMpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBub2RlLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBjb25zaWRlcmVkIGZhdGFsIGVycm9ycy5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIHN5bmNocm9ub3VzbHkgdG8gaW50ZXJydXB0IGZsdXNoaW5nIVxuXG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvbnRpbnVhdGlvbiBpZiB0aGUgdW5jYXVnaHQgZXhjZXB0aW9uIGlzIHN1cHByZXNzZWRcbiAgICAgICAgICAgICAgICAvLyBsaXN0ZW5pbmcgXCJ1bmNhdWdodEV4Y2VwdGlvblwiIGV2ZW50cyAoYXMgZG9tYWlucyBkb2VzKS5cbiAgICAgICAgICAgICAgICAvLyBDb250aW51ZSBpbiBuZXh0IGV2ZW50IHRvIGF2b2lkIHRpY2sgcmVjdXJzaW9uLlxuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEluIGJyb3dzZXJzLCB1bmNhdWdodCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBhc3luY2hyb25vdXNseSB0byBhdm9pZCBzbG93LWRvd25zLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG5pZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5uZXh0VGljaykge1xuICAgIC8vIE5vZGUuanMgYmVmb3JlIDAuOS4gTm90ZSB0aGF0IHNvbWUgZmFrZS1Ob2RlIGVudmlyb25tZW50cywgbGlrZSB0aGVcbiAgICAvLyBNb2NoYSB0ZXN0IHJ1bm5lciwgaW50cm9kdWNlIGEgYHByb2Nlc3NgIGdsb2JhbCB3aXRob3V0IGEgYG5leHRUaWNrYC5cbiAgICBpc05vZGVKUyA9IHRydWU7XG5cbiAgICByZXF1ZXN0Rmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG5cbn0gZWxzZSBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgLy8gSW4gSUUxMCwgTm9kZS5qcyAwLjkrLCBvciBodHRwczovL2dpdGh1Yi5jb20vTm9ibGVKUy9zZXRJbW1lZGlhdGVcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXF1ZXN0Rmx1c2ggPSBzZXRJbW1lZGlhdGUuYmluZCh3aW5kb3csIGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXF1ZXN0Rmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2gpO1xuICAgICAgICB9O1xuICAgIH1cblxufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAvLyBtb2Rlcm4gYnJvd3NlcnNcbiAgICAvLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmbHVzaDtcbiAgICByZXF1ZXN0Rmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4gICAgfTtcblxufSBlbHNlIHtcbiAgICAvLyBvbGQgYnJvd3NlcnNcbiAgICByZXF1ZXN0Rmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIHRhaWwgPSB0YWlsLm5leHQgPSB7XG4gICAgICAgIHRhc2s6IHRhc2ssXG4gICAgICAgIGRvbWFpbjogaXNOb2RlSlMgJiYgcHJvY2Vzcy5kb21haW4sXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKCFmbHVzaGluZykge1xuICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgICAgIHJlcXVlc3RGbHVzaCgpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYXNhcDtcblxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBpbztcblxuICBpZiAob3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8IGZhbHNlID09PSBvcHRzLm11bHRpcGxleCkge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuXG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWNvbXBvbmVudCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBCYWNrb2ZmID0gcmVxdWlyZSgnYmFja28yJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyKHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKG9wdHMucmFuZG9taXphdGlvbkZhY3RvciB8fCAwLjUpO1xuICB0aGlzLmJhY2tvZmYgPSBuZXcgQmFja29mZih7XG4gICAgbWluOiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksXG4gICAgbWF4OiB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksXG4gICAgaml0dGVyOiB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3IoKVxuICB9KTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGVkID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IHBhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLmF1dG9Db25uZWN0ID0gb3B0cy5hdXRvQ29ubmVjdCAhPT0gZmFsc2U7XG4gIGlmICh0aGlzLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGUgYHNvY2tldC5pZGAgb2YgYWxsIHNvY2tldHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVTb2NrZXRJZHMgPSBmdW5jdGlvbigpe1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgdGhpcy5uc3BzW25zcF0uaWQgPSB0aGlzLmVuZ2luZS5pZDtcbiAgfVxufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1pbih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7XG4gIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3IgPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG1heGltdW0gZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheU1heCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXggPSB2O1xuICB0aGlzLmJhY2tvZmYgJiYgdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAvLyBPbmx5IHRyeSB0byByZWNvbm5lY3QgaWYgaXQncyB0aGUgZmlyc3QgdGltZSB3ZSdyZSBjb25uZWN0aW5nXG4gIGlmICghdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uICYmIHRoaXMuYmFja29mZi5hdHRlbXB0cyA9PT0gMCkge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQgYHNvY2tldGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gb3B0aW9uYWwsIGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9wZW4gPVxuTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKGZuKXtcbiAgZGVidWcoJ3JlYWR5U3RhdGUgJXMnLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKCdvcGVuJykpIHJldHVybiB0aGlzO1xuXG4gIGRlYnVnKCdvcGVuaW5nICVzJywgdGhpcy51cmkpO1xuICB0aGlzLmVuZ2luZSA9IGVpbyh0aGlzLnVyaSwgdGhpcy5vcHRzKTtcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gZmFsc2U7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPbmx5IGRvIHRoaXMgaWYgdGhlcmUgaXMgbm8gZm4gdG8gaGFuZGxlIHRoZSBlcnJvclxuICAgICAgc2VsZi5tYXliZVJlY29ubmVjdE9uT3BlbigpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbihuc3Ape1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3ApO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAgICAgc29ja2V0LmlkID0gc2VsZi5lbmdpbmUuaWQ7XG4gICAgICBpZiAoIX5pbmRleE9mKHNlbGYuY29ubmVjdGVkLCBzb2NrZXQpKSB7XG4gICAgICAgIHNlbGYuY29ubmVjdGVkLnB1c2goc29ja2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHNvY2tldCl7XG4gIHZhciBpbmRleCA9IGluZGV4T2YodGhpcy5jb25uZWN0ZWQsIHNvY2tldCk7XG4gIGlmICh+aW5kZXgpIHRoaXMuY29ubmVjdGVkLnNwbGljZShpbmRleCwgMSk7XG4gIGlmICh0aGlzLmNvbm5lY3RlZC5sZW5ndGgpIHJldHVybjtcblxuICB0aGlzLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBkZWJ1Zygnd3JpdGluZyBwYWNrZXQgJWonLCBwYWNrZXQpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCFzZWxmLmVuY29kaW5nKSB7XG4gICAgLy8gZW5jb2RlLCB0aGVuIHdyaXRlIHRvIGVuZ2luZSB3aXRoIHJlc3VsdFxuICAgIHNlbGYuZW5jb2RpbmcgPSB0cnVlO1xuICAgIHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LCBmdW5jdGlvbihlbmNvZGVkUGFja2V0cykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkUGFja2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSk7XG4gICAgICB9XG4gICAgICBzZWxmLmVuY29kaW5nID0gZmFsc2U7XG4gICAgICBzZWxmLnByb2Nlc3NQYWNrZXRRdWV1ZSgpO1xuICAgIH0pO1xuICB9IGVsc2UgeyAvLyBhZGQgcGFja2V0IHRvIHRoZSBxdWV1ZVxuICAgIHNlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxufTtcblxuLyoqXG4gKiBJZiBwYWNrZXQgYnVmZmVyIGlzIG5vbi1lbXB0eSwgYmVnaW5zIGVuY29kaW5nIHRoZVxuICogbmV4dCBwYWNrZXQgaW4gbGluZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aCA+IDAgJiYgIXRoaXMuZW5jb2RpbmcpIHtcbiAgICB2YXIgcGFjayA9IHRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7XG4gICAgdGhpcy5wYWNrZXQocGFjayk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2xlYW4gdXAgdHJhbnNwb3J0IHN1YnNjcmlwdGlvbnMgYW5kIHBhY2tldCBidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzdWI7XG4gIHdoaWxlIChzdWIgPSB0aGlzLnN1YnMuc2hpZnQoKSkgc3ViLmRlc3Ryb3koKTtcblxuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTtcbn07XG5cbi8qKlxuICogQ2xvc2UgdGhlIGN1cnJlbnQgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlID1cbk1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSB0cnVlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW5naW5lICYmIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCByZWFzb24pO1xuICBpZiAodGhpcy5fcmVjb25uZWN0aW9uICYmICF0aGlzLnNraXBSZWNvbm5lY3QpIHtcbiAgICB0aGlzLnJlY29ubmVjdCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEF0dGVtcHQgYSByZWNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMucmVjb25uZWN0aW5nIHx8IHRoaXMuc2tpcFJlY29ubmVjdCkgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPj0gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuICAgIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5iYWNrb2ZmLmR1cmF0aW9uKCk7XG4gICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIGRlYnVnKCdhdHRlbXB0aW5nIHJlY29ubmVjdCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfYXR0ZW1wdCcsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYmFja29mZi5hdHRlbXB0cyk7XG5cbiAgICAgIC8vIGNoZWNrIGFnYWluIGZvciB0aGUgY2FzZSBzb2NrZXQgY2xvc2VkIGluIGFib3ZlIGV2ZW50c1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYmFja29mZi5hdHRlbXB0cztcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMudXBkYXRlU29ja2V0SWRzKCk7XG4gIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0JywgYXR0ZW1wdCk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gb247XG5cbi8qKlxuICogSGVscGVyIGZvciBzdWJzY3JpcHRpb25zLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fEV2ZW50RW1pdHRlcn0gb2JqIHdpdGggYEVtaXR0ZXJgIG1peGluIG9yIGBFdmVudEVtaXR0ZXJgXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gb24ob2JqLCBldiwgZm4pIHtcbiAgb2JqLm9uKGV2LCBmbik7XG4gIHJldHVybiB7XG4gICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgIG9iai5yZW1vdmVMaXN0ZW5lcihldiwgZm4pO1xuICAgIH1cbiAgfTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJ3RvLWFycmF5Jyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGhhc0JpbiA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQoaW8sIG5zcCl7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICBpZiAodGhpcy5pby5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gb3BlbiwgY2xvc2UgYW5kIHBhY2tldCBldmVudHNcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cyA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zdWJzKSByZXR1cm47XG5cbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5zdWJFdmVudHMoKTtcbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldil7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG4gIGlmIChoYXNCaW4oYXJncykpIHsgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7IH0gLy8gYmluYXJ5XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBvcGVuYC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmcnKTtcblxuICAvLyB3cml0ZSBjb25uZWN0IHBhY2tldCBpZiBuZWNlc3NhcnlcbiAgaWYgKCcvJyAhPSB0aGlzLm5zcCkge1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkNPTk5FQ1QgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGBjbG9zZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ2Nsb3NlICglcyknLCByZWFzb24pO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIGRlbGV0ZSB0aGlzLmlkO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBpZiAocGFja2V0Lm5zcCAhPSB0aGlzLm5zcCkgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24oaWQpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICB2YXIgdHlwZSA9IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSztcbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgdmFyIGZuID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGZuLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuc3Vicykge1xuICAgIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnN1YnNbaV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLnN1YnMgPSBudWxsO1xuICB9XG5cbiAgdGhpcy5pby5kZXN0cm95KHRoaXMpO1xufTtcblxuLyoqXG4gKiBEaXNjb25uZWN0cyB0aGUgc29ja2V0IG1hbnVhbGx5LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID1cblNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGRlYnVnKCdwZXJmb3JtaW5nIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgLy8gZmlyZSBldmVudHNcbiAgICB0aGlzLm9uY2xvc2UoJ2lvIGNsaWVudCBkaXNjb25uZWN0Jyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCh1cmksIGxvYyl7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgdmFyIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0O1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDEpKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0bmFtZSArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBvYmouaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgb2JqLmhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuIiwiXG4vKipcbiAqIEV4cG9zZSBgQmFja29mZmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBCYWNrb2ZmO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYmFja29mZiB0aW1lciB3aXRoIGBvcHRzYC5cbiAqXG4gKiAtIGBtaW5gIGluaXRpYWwgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgWzEwMF1cbiAqIC0gYG1heGAgbWF4IHRpbWVvdXQgWzEwMDAwXVxuICogLSBgaml0dGVyYCBbMF1cbiAqIC0gYGZhY3RvcmAgWzJdXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQmFja29mZihvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICB0aGlzLm1zID0gb3B0cy5taW4gfHwgMTAwO1xuICB0aGlzLm1heCA9IG9wdHMubWF4IHx8IDEwMDAwO1xuICB0aGlzLmZhY3RvciA9IG9wdHMuZmFjdG9yIHx8IDI7XG4gIHRoaXMuaml0dGVyID0gb3B0cy5qaXR0ZXIgPiAwICYmIG9wdHMuaml0dGVyIDw9IDEgPyBvcHRzLmppdHRlciA6IDA7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgYmFja29mZiBkdXJhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24oKXtcbiAgdmFyIG1zID0gdGhpcy5tcyAqIE1hdGgucG93KHRoaXMuZmFjdG9yLCB0aGlzLmF0dGVtcHRzKyspO1xuICBpZiAodGhpcy5qaXR0ZXIpIHtcbiAgICB2YXIgcmFuZCA9ICBNYXRoLnJhbmRvbSgpO1xuICAgIHZhciBkZXZpYXRpb24gPSBNYXRoLmZsb29yKHJhbmQgKiB0aGlzLmppdHRlciAqIG1zKTtcbiAgICBtcyA9IChNYXRoLmZsb29yKHJhbmQgKiAxMCkgJiAxKSA9PSAwICA/IG1zIC0gZGV2aWF0aW9uIDogbXMgKyBkZXZpYXRpb247XG4gIH1cbiAgcmV0dXJuIE1hdGgubWluKG1zLCB0aGlzLm1heCkgfCAwO1xufTtcblxuLyoqXG4gKiBSZXNldCB0aGUgbnVtYmVyIG9mIGF0dGVtcHRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtaW5pbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW4gPSBmdW5jdGlvbihtaW4pe1xuICB0aGlzLm1zID0gbWluO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1heGltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1heCA9IGZ1bmN0aW9uKG1heCl7XG4gIHRoaXMubWF4ID0gbWF4O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGppdHRlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0Sml0dGVyID0gZnVuY3Rpb24oaml0dGVyKXtcbiAgdGhpcy5qaXR0ZXIgPSBqaXR0ZXI7XG59O1xuXG4iLCIvKipcbiAqIFNsaWNlIHJlZmVyZW5jZS5cbiAqL1xuXG52YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuLyoqXG4gKiBCaW5kIGBvYmpgIHRvIGBmbmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGZuIG9yIHN0cmluZ1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBmbil7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZm4pIGZuID0gb2JqW2ZuXTtcbiAgaWYgKCdmdW5jdGlvbicgIT0gdHlwZW9mIGZuKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmQoKSByZXF1aXJlcyBhIGZ1bmN0aW9uJyk7XG4gIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1R5cGV9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWUpIHtcbiAgaWYgKCFkZWJ1Zy5lbmFibGVkKG5hbWUpKSByZXR1cm4gZnVuY3Rpb24oKXt9O1xuXG4gIHJldHVybiBmdW5jdGlvbihmbXQpe1xuICAgIGZtdCA9IGNvZXJjZShmbXQpO1xuXG4gICAgdmFyIGN1cnIgPSBuZXcgRGF0ZTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKGRlYnVnW25hbWVdIHx8IGN1cnIpO1xuICAgIGRlYnVnW25hbWVdID0gY3VycjtcblxuICAgIGZtdCA9IG5hbWVcbiAgICAgICsgJyAnXG4gICAgICArIGZtdFxuICAgICAgKyAnICsnICsgZGVidWcuaHVtYW5pemUobXMpO1xuXG4gICAgLy8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRThcbiAgICAvLyB3aGVyZSBgY29uc29sZS5sb2dgIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gICAgd2luZG93LmNvbnNvbGVcbiAgICAgICYmIGNvbnNvbGUubG9nXG4gICAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMuXG4gKi9cblxuZGVidWcubmFtZXMgPSBbXTtcbmRlYnVnLnNraXBzID0gW107XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZS4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5kZWJ1Zy5lbmFibGUgPSBmdW5jdGlvbihuYW1lKSB7XG4gIHRyeSB7XG4gICAgbG9jYWxTdG9yYWdlLmRlYnVnID0gbmFtZTtcbiAgfSBjYXRjaChlKXt9XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWUgfHwgJycpLnNwbGl0KC9bXFxzLF0rLylcbiAgICAsIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmFtZSA9IHNwbGl0W2ldLnJlcGxhY2UoJyonLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVbMF0gPT09ICctJykge1xuICAgICAgZGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWUuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgZGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWUgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5kZWJ1Zy5kaXNhYmxlID0gZnVuY3Rpb24oKXtcbiAgZGVidWcuZW5hYmxlKCcnKTtcbn07XG5cbi8qKlxuICogSHVtYW5pemUgdGhlIGdpdmVuIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmRlYnVnLmh1bWFuaXplID0gZnVuY3Rpb24obXMpIHtcbiAgdmFyIHNlYyA9IDEwMDBcbiAgICAsIG1pbiA9IDYwICogMTAwMFxuICAgICwgaG91ciA9IDYwICogbWluO1xuXG4gIGlmIChtcyA+PSBob3VyKSByZXR1cm4gKG1zIC8gaG91cikudG9GaXhlZCgxKSArICdoJztcbiAgaWYgKG1zID49IG1pbikgcmV0dXJuIChtcyAvIG1pbikudG9GaXhlZCgxKSArICdtJztcbiAgaWYgKG1zID49IHNlYykgcmV0dXJuIChtcyAvIHNlYyB8IDApICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmRlYnVnLmVuYWJsZWQgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChkZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChkZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cbi8vIHBlcnNpc3RcblxudHJ5IHtcbiAgaWYgKHdpbmRvdy5sb2NhbFN0b3JhZ2UpIGRlYnVnLmVuYWJsZShsb2NhbFN0b3JhZ2UuZGVidWcpO1xufSBjYXRjaChlKXt9XG4iLCJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIF9oYXNCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gX2hhc0JpbmFyeShkYXRhKTtcbn1cbiIsIlxuLyoqXG4gKiBIT1AgcmVmLlxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFJldHVybiBvd24ga2V5cyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKXtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cbi8qKlxuICogUmV0dXJuIG93biB2YWx1ZXMgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24ob2JqKXtcbiAgdmFyIHZhbHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHMucHVzaChvYmpba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuLyoqXG4gKiBNZXJnZSBgYmAgaW50byBgYWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uKGEsIGIpe1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGlmIChoYXMuY2FsbChiLCBrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gbGVuZ3RoIG9mIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5sZW5ndGggPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gZXhwb3J0cy5rZXlzKG9iaikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmlzRW1wdHkgPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gMCA9PSBleHBvcnRzLmxlbmd0aChvYmopO1xufTsiLCIvKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCdcbiAgLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpXG4gICAgLCB1cmkgPSB7fVxuICAgICwgaSA9IDE0O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgfVxuXG4gIHJldHVybiB1cmk7XG59O1xuIiwiLypnbG9iYWwgQmxvYixGaWxlKi9cblxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIGluIHBhY2tldCB3aXRoIGEgbnVtYmVyZWQgcGxhY2Vob2xkZXIuXG4gKiBBbnl0aGluZyB3aXRoIGJsb2JzIG9yIGZpbGVzIHNob3VsZCBiZSBmZWQgdGhyb3VnaCByZW1vdmVCbG9icyBiZWZvcmUgY29taW5nXG4gKiBoZXJlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICBmdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgICBpZiAoaXNCdWYoZGF0YSkpIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH0gZWxzZSBpZiAoJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBuZXdEYXRhW2tleV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBwYWNrID0gcGFja2V0O1xuICBwYWNrLmRhdGEgPSBfZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7XG4gIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn07XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cbiAgZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgIHJldHVybiBidWY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSk7XG4gIHBhY2tldC5hdHRhY2htZW50cyA9IHVuZGVmaW5lZDsgLy8gbm8gbG9uZ2VyIHVzZWZ1bFxuICByZXR1cm4gcGFja2V0O1xufTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcbiAgZnVuY3Rpb24gX3JlbW92ZUJsb2JzKG9iaiwgY3VyS2V5LCBjb250YWluaW5nT2JqZWN0KSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG5cbiAgICAvLyBjb252ZXJ0IGFueSBibG9iXG4gICAgaWYgKChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpIHtcbiAgICAgIHBlbmRpbmdCbG9icysrO1xuXG4gICAgICAvLyBhc3luYyBmaWxlcmVhZGVyXG4gICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkgeyAvLyB0aGlzLnJlc3VsdCA9PSBhcnJheWJ1ZmZlclxuICAgICAgICBpZiAoY29udGFpbmluZ09iamVjdCkge1xuICAgICAgICAgIGNvbnRhaW5pbmdPYmplY3RbY3VyS2V5XSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGJsb2JsZXNzRGF0YSA9IHRoaXMucmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgbm90aGluZyBwZW5kaW5nIGl0cyBjYWxsYmFjayB0aW1lXG4gICAgICAgIGlmKCEgLS1wZW5kaW5nQmxvYnMpIHtcbiAgICAgICAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iaik7IC8vIGJsb2IgLT4gYXJyYXlidWZmZXJcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIF9yZW1vdmVCbG9icyhvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nQmxvYnMgPSAwO1xuICB2YXIgYmxvYmxlc3NEYXRhID0gZGF0YTtcbiAgX3JlbW92ZUJsb2JzKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBqc29uID0gcmVxdWlyZSgnanNvbjMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGJpbmFyeSA9IHJlcXVpcmUoJy4vYmluYXJ5Jyk7XG52YXIgaXNCdWYgPSByZXF1aXJlKCcuL2lzLWJ1ZmZlcicpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdBQ0snLFxuICAnQklOQVJZX0FDSycsXG4gICdFUlJPUidcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbi8qKlxuICogRW5jb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXI7XG5cbi8qKlxuICogRGVjb2RlciBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRGVjb2RlciA9IERlY29kZXI7XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW5jb2RlcigpIHt9XG5cbi8qKlxuICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gKiBidWZmZXIgc2VxdWVuY2UsIGRlcGVuZGluZyBvbiBwYWNrZXQgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBmdW5jdGlvbiB0byBoYW5kbGUgZW5jb2RpbmdzIChsaWtlbHkgZW5naW5lLndyaXRlKVxuICogQHJldHVybiBDYWxscyBjYWxsYmFjayB3aXRoIEFycmF5IG9mIGVuY29kaW5nc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKXtcbiAgZGVidWcoJ2VuY29kaW5nIHBhY2tldCAlaicsIG9iaik7XG5cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBlbmNvZGluZyA9IGVuY29kZUFzU3RyaW5nKG9iaik7XG4gICAgY2FsbGJhY2soW2VuY29kaW5nXSk7XG4gIH1cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuICB2YXIgbnNwID0gZmFsc2U7XG5cbiAgLy8gZmlyc3QgaXMgdHlwZVxuICBzdHIgKz0gb2JqLnR5cGU7XG5cbiAgLy8gYXR0YWNobWVudHMgaWYgd2UgaGF2ZSB0aGVtXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzO1xuICAgIHN0ciArPSAnLSc7XG4gIH1cblxuICAvLyBpZiB3ZSBoYXZlIGEgbmFtZXNwYWNlIG90aGVyIHRoYW4gYC9gXG4gIC8vIHdlIGFwcGVuZCBpdCBmb2xsb3dlZCBieSBhIGNvbW1hIGAsYFxuICBpZiAob2JqLm5zcCAmJiAnLycgIT0gb2JqLm5zcCkge1xuICAgIG5zcCA9IHRydWU7XG4gICAgc3RyICs9IG9iai5uc3A7XG4gIH1cblxuICAvLyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSB0aGUgaWRcbiAgaWYgKG51bGwgIT0gb2JqLmlkKSB7XG4gICAgaWYgKG5zcCkge1xuICAgICAgc3RyICs9ICcsJztcbiAgICAgIG5zcCA9IGZhbHNlO1xuICAgIH1cbiAgICBzdHIgKz0gb2JqLmlkO1xuICB9XG5cbiAgLy8ganNvbiBkYXRhXG4gIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgaWYgKG5zcCkgc3RyICs9ICcsJztcbiAgICBzdHIgKz0ganNvbi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuICB9XG5cbiAgZGVidWcoJ2VuY29kZWQgJWogYXMgJXMnLCBvYmosIHN0cik7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gKiBkZWNvbnN0cnVjdGluZyBwYWNrZXQgaW50byBvYmplY3Qgd2l0aCBwbGFjZWhvbGRlcnMgYW5kXG4gKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaiwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiB3cml0ZUVuY29kaW5nKGJsb2JsZXNzRGF0YSkge1xuICAgIHZhciBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeS5kZWNvbnN0cnVjdFBhY2tldChibG9ibGVzc0RhdGEpO1xuICAgIHZhciBwYWNrID0gZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTtcbiAgICB2YXIgYnVmZmVycyA9IGRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7XG5cbiAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgY2FsbGJhY2soYnVmZmVycyk7IC8vIHdyaXRlIGFsbCB0aGUgYnVmZmVyc1xuICB9XG5cbiAgYmluYXJ5LnJlbW92ZUJsb2JzKG9iaiwgd3JpdGVFbmNvZGluZyk7XG59XG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZWNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcGFja2V0O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cbiAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG4gICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKGlzQnVmKG9iaikgfHwgb2JqLmJhc2U2NCkgeyAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICBpZiAocGFja2V0KSB7IC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIG9iaik7XG4gIH1cbn07XG5cbi8qKlxuICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gIHZhciBwID0ge307XG4gIHZhciBpID0gMDtcblxuICAvLyBsb29rIHVwIHR5cGVcbiAgcC50eXBlID0gTnVtYmVyKHN0ci5jaGFyQXQoMCkpO1xuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcC50eXBlKSB7XG4gICAgdmFyIGJ1ZiA9ICcnO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT0gJy0nKSB7XG4gICAgICBidWYgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT0gJy0nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgYXR0YWNobWVudHMnKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBuYW1lc3BhY2UgKGlmIGFueSlcbiAgaWYgKCcvJyA9PSBzdHIuY2hhckF0KGkgKyAxKSkge1xuICAgIHAubnNwID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKCcsJyA9PSBjKSBicmVhaztcbiAgICAgIHAubnNwICs9IGM7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPT0gbmV4dCAmJiBOdW1iZXIobmV4dCkgPT0gbmV4dCkge1xuICAgIHAuaWQgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAobnVsbCA9PSBjIHx8IE51bWJlcihjKSAhPSBjKSB7XG4gICAgICAgIC0taTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBwLmlkICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5pZCA9IE51bWJlcihwLmlkKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICB0cnkge1xuICAgICAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn1cblxuLyoqXG4gKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG4gKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuICogZGVjb2RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGJpbmFyeSBwYWNrZXQgcmVjb25zdHJ1Y3Rpb24gdmFyaWFibGVzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn07XG5cbmZ1bmN0aW9uIGVycm9yKGRhdGEpe1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcidcbiAgfTtcbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZjtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG59XG4iLCIvKiEgSlNPTiB2My4yLjYgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxMywgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICh3aW5kb3cpIHtcbiAgLy8gQ29udmVuaWVuY2UgYWxpYXNlcy5cbiAgdmFyIGdldENsYXNzID0ge30udG9TdHJpbmcsIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gIC8vIERldGVjdCB0aGUgYGRlZmluZWAgZnVuY3Rpb24gZXhwb3NlZCBieSBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuIFRoZVxuICAvLyBzdHJpY3QgYGRlZmluZWAgY2hlY2sgaXMgbmVjZXNzYXJ5IGZvciBjb21wYXRpYmlsaXR5IHdpdGggYHIuanNgLlxuICB2YXIgaXNMb2FkZXIgPSB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZDtcblxuICAvLyBEZXRlY3QgbmF0aXZlIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIG5hdGl2ZUpTT04gPSB0eXBlb2YgSlNPTiA9PSBcIm9iamVjdFwiICYmIEpTT047XG5cbiAgLy8gU2V0IHVwIHRoZSBKU09OIDMgbmFtZXNwYWNlLCBwcmVmZXJyaW5nIHRoZSBDb21tb25KUyBgZXhwb3J0c2Agb2JqZWN0IGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgdmFyIEpTT04zID0gdHlwZW9mIGV4cG9ydHMgPT0gXCJvYmplY3RcIiAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbiAgaWYgKEpTT04zICYmIG5hdGl2ZUpTT04pIHtcbiAgICAvLyBFeHBsaWNpdGx5IGRlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgaW4gQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIEpTT04zLnN0cmluZ2lmeSA9IG5hdGl2ZUpTT04uc3RyaW5naWZ5O1xuICAgIEpTT04zLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycywgSmF2YVNjcmlwdCBlbmdpbmVzLCBhbmQgYXN5bmNocm9ub3VzIG1vZHVsZVxuICAgIC8vIGxvYWRlcnMsIHVzaW5nIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBpZiBhdmFpbGFibGUuXG4gICAgSlNPTjMgPSB3aW5kb3cuSlNPTiA9IG5hdGl2ZUpTT04gfHwge307XG4gIH1cblxuICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICB0cnkge1xuICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICBpc0V4dGVuZGVkID0gaXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpID09IC0xMDkyNTIgJiYgaXNFeHRlbmRlZC5nZXRVVENNb250aCgpID09PSAwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpID09PSAxICYmXG4gICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgIC8vIHNpZ25lZCAzMi1iaXQgaW50ZWdlcnMgKFstMiAqKiAzMSwgMiAqKiAzMSAtIDFdKS5cbiAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgd2hldGhlciB0aGUgbmF0aXZlIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBwYXJzZWBcbiAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgIGlmIChoYXNbbmFtZV0gIT09IHVuZGVmKSB7XG4gICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgIH1cblxuICAgIHZhciBpc1N1cHBvcnRlZDtcbiAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAvLyBicmFja2V0IG5vdGF0aW9uLiBJRSA4IG9ubHkgc3VwcG9ydHMgdGhpcyBmb3IgcHJpbWl0aXZlcy5cbiAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAvLyBJbmRpY2F0ZXMgd2hldGhlciBib3RoIGBKU09OLnN0cmluZ2lmeWAgYW5kIGBKU09OLnBhcnNlYCBhcmVcbiAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICBpZiAobmFtZSA9PSBcImpzb24tc3RyaW5naWZ5XCIpIHtcbiAgICAgICAgdmFyIHN0cmluZ2lmeSA9IEpTT04zLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgaWYgKHN0cmluZ2lmeVN1cHBvcnRlZCkge1xuICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9XG4gICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSgwKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IE51bWJlcigpKSA9PT0gXCIwXCIgJiZcbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAvLyBkb2VzIG5vdCBkZWZpbmUgYSBjYW5vbmljYWwgSlNPTiByZXByZXNlbnRhdGlvbiAodGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KGdldENsYXNzKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KHVuZGVmKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoKSA9PT0gdW5kZWYgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcyBhcyB3ZWxsLCB1bmxlc3MgdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSh2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAvLyBgXCJbbnVsbF1cImAuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsKSA9PSBcIm51bGxcIiAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAvLyBlbGlkZXMgbm9uLUpTT04gdmFsdWVzIGZyb20gb2JqZWN0cyBhbmQgYXJyYXlzLCB1bmxlc3MgdGhleVxuICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgLy8gU2ltcGxlIHNlcmlhbGl6YXRpb24gdGVzdC4gRkYgMy4xYjEgdXNlcyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZXNcbiAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEgYW5kIGIyIGlnbm9yZSB0aGUgYGZpbHRlcmAgYW5kIGB3aWR0aGAgYXJndW1lbnRzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAvLyBKU09OIDIsIFByb3RvdHlwZSA8PSAxLjcsIGFuZCBvbGRlciBXZWJLaXQgYnVpbGRzIGluY29ycmVjdGx5XG4gICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgIC8vIFRoZSBtaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCB5ZWFycyBpbnN0ZWFkIG9mIHNpeC1kaWdpdCB5ZWFycy4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAvLyB2YWx1ZXMgbGVzcyB0aGFuIDEwMDAuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHN0cmluZ2lmeVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc1N1cHBvcnRlZCA9IHN0cmluZ2lmeVN1cHBvcnRlZDtcbiAgICAgIH1cbiAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXBhcnNlXCIpIHtcbiAgICAgICAgdmFyIHBhcnNlID0gSlNPTjMucGFyc2U7XG4gICAgICAgIGlmICh0eXBlb2YgcGFyc2UgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgIC8vIENvbmZvcm1pbmcgaW1wbGVtZW50YXRpb25zIHNob3VsZCBhbHNvIGNvZXJjZSB0aGUgaW5pdGlhbCBhcmd1bWVudCB0b1xuICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAvLyBTaW1wbGUgcGFyc2luZyB0ZXN0LlxuICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSAhcGFyc2UoJ1wiXFx0XCInKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgIC8vIGNlcnRhaW4gb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAsIDQuMC4xLCBhbmQgUmhpbm8gMS43UjMtUjQgYWxsb3cgdHJhaWxpbmcgZGVjaW1hbFxuICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIxLlwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzU3VwcG9ydGVkID0gcGFyc2VTdXBwb3J0ZWQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNbbmFtZV0gPSAhIWlzU3VwcG9ydGVkO1xuICB9XG5cbiAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgLy8gQ29tbW9uIGBbW0NsYXNzXV1gIG5hbWUgYWxpYXNlcy5cbiAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIjtcbiAgICB2YXIgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCI7XG4gICAgdmFyIG51bWJlckNsYXNzID0gXCJbb2JqZWN0IE51bWJlcl1cIjtcbiAgICB2YXIgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiO1xuICAgIHZhciBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiO1xuICAgIHZhciBib29sZWFuQ2xhc3MgPSBcIltvYmplY3QgQm9vbGVhbl1cIjtcblxuICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAvLyBEZWZpbmUgYWRkaXRpb25hbCB1dGlsaXR5IG1ldGhvZHMgaWYgdGhlIGBEYXRlYCBtZXRob2RzIGFyZSBidWdneS5cbiAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAvLyBBIG1hcHBpbmcgYmV0d2VlbiB0aGUgbW9udGhzIG9mIHRoZSB5ZWFyIGFuZCB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlblxuICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgLy8gSW50ZXJuYWw6IENhbGN1bGF0ZXMgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW4gdGhlIFVuaXggZXBvY2ggYW5kIHRoZVxuICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgcmV0dXJuIE1vbnRoc1ttb250aF0gKyAzNjUgKiAoeWVhciAtIDE5NzApICsgZmxvb3IoKHllYXIgLSAxOTY5ICsgKG1vbnRoID0gKyhtb250aCA+IDEpKSkgLyA0KSAtIGZsb29yKCh5ZWFyIC0gMTkwMSArIG1vbnRoKSAvIDEwMCkgKyBmbG9vcigoeWVhciAtIDE2MDEgKyBtb250aCkgLyA0MDApO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiBhIHByb3BlcnR5IGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIHRoZSBnaXZlblxuICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgIGlmICghKGlzUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAvLyBUaGUgKnByb3RvKiBwcm9wZXJ0eSBjYW5ub3QgYmUgc2V0IG11bHRpcGxlIHRpbWVzIGluIHJlY2VudFxuICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgfSwgbWVtYmVycykudG9TdHJpbmcgIT0gZ2V0Q2xhc3MpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgIC8vIHVuc2FmZSB0cmFuc2Zvcm1hdGlvbiBieSB0aGUgQ2xvc3VyZSBDb21waWxlci5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gb3JpZ2luYWw7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAvLyBVc2UgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgdG8gc2ltdWxhdGUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW5cbiAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9ICh0aGlzLmNvbnN0cnVjdG9yIHx8IGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7XG4gICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEludGVybmFsOiBBIHNldCBvZiBwcmltaXRpdmUgdHlwZXMgdXNlZCBieSBgaXNIb3N0VHlwZWAuXG4gICAgdmFyIFByaW1pdGl2ZVR5cGVzID0ge1xuICAgICAgJ2Jvb2xlYW4nOiAxLFxuICAgICAgJ251bWJlcic6IDEsXG4gICAgICAnc3RyaW5nJzogMSxcbiAgICAgICd1bmRlZmluZWQnOiAxXG4gICAgfTtcblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBvYmplY3QgYHByb3BlcnR5YCB2YWx1ZSBpcyBhXG4gICAgLy8gbm9uLXByaW1pdGl2ZS5cbiAgICB2YXIgaXNIb3N0VHlwZSA9IGZ1bmN0aW9uIChvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmplY3RbcHJvcGVydHldO1xuICAgICAgcmV0dXJuIHR5cGUgPT0gJ29iamVjdCcgPyAhIW9iamVjdFtwcm9wZXJ0eV0gOiAhUHJpbWl0aXZlVHlwZXNbdHlwZV07XG4gICAgfTtcblxuICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgLy8gZW52aXJvbm1lbnRzLiBFYWNoIGVudW1lcmF0ZWQga2V5IGlzIHlpZWxkZWQgdG8gYSBgY2FsbGJhY2tgIGZ1bmN0aW9uLlxuICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgLy8gVGVzdHMgZm9yIGJ1Z3MgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQncyBgZm9yLi4uaW5gIGFsZ29yaXRobS4gVGhlXG4gICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgLy8gSXRlcmF0ZSBvdmVyIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBgUHJvcGVydGllc2AgY2xhc3MuXG4gICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAvLyBJZ25vcmUgYWxsIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgIHNpemUrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAvLyBOb3JtYWxpemUgdGhlIGl0ZXJhdGlvbiBhbGdvcml0aG0uXG4gICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICBtZW1iZXJzID0gW1widmFsdWVPZlwiLCBcInRvU3RyaW5nXCIsIFwidG9Mb2NhbGVTdHJpbmdcIiwgXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLCBcImlzUHJvdG90eXBlT2ZcIiwgXCJoYXNPd25Qcm9wZXJ0eVwiLCBcImNvbnN0cnVjdG9yXCJdO1xuICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9ICdmdW5jdGlvbicgJiYgaXNIb3N0VHlwZShvYmplY3QsICdoYXNPd25Qcm9wZXJ0eScpID8gb2JqZWN0Lmhhc093blByb3BlcnR5IDogaXNQcm9wZXJ0eTtcbiAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAvLyBlbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGlzQ29uc3RydWN0b3I7XG4gICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgZHVlIHRvXG4gICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8vIFB1YmxpYzogU2VyaWFsaXplcyBhIEphdmFTY3JpcHQgYHZhbHVlYCBhcyBhIEpTT04gc3RyaW5nLiBUaGUgb3B0aW9uYWxcbiAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgIC8vIGluZGljYXRlcyB3aGljaCBwcm9wZXJ0aWVzIHNob3VsZCBiZSBzZXJpYWxpemVkLiBUaGUgb3B0aW9uYWwgYHdpZHRoYFxuICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgaWYgKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSkge1xuICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICA5MjogXCJcXFxcXFxcXFwiLFxuICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgMTI6IFwiXFxcXGZcIixcbiAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgOTogXCJcXFxcdFwiXG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgIC8vIGxlbmd0aCBpcyBhdCBsZWFzdCBlcXVhbCB0byBgd2lkdGhgLiBUaGUgYHdpZHRoYCBtdXN0IGJlIDw9IDYuXG4gICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgIC8vIFRoZSBgfHwgMGAgZXhwcmVzc2lvbiBpcyBuZWNlc3NhcnkgdG8gd29yayBhcm91bmQgYSBidWcgaW5cbiAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgLy8gdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgdmFyIHF1b3RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgaXNMYXJnZSA9IGxlbmd0aCA+IDEwICYmIGNoYXJJbmRleEJ1Z2d5LCBzeW1ib2xzO1xuICAgICAgICBpZiAoaXNMYXJnZSkge1xuICAgICAgICAgIHN5bWJvbHMgPSB2YWx1ZS5zcGxpdChcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICB2YXIgY2hhckNvZGUgPSB2YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1bmljb2RlUHJlZml4ICsgdG9QYWRkZWRTdHJpbmcoMiwgY2hhckNvZGUudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHQgKz0gaXNMYXJnZSA/IHN5bWJvbHNbaW5kZXhdIDogY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoaW5kZXgpIDogdmFsdWVbaW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0ICsgJ1wiJztcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgIC8vIGBTdHIoa2V5LCBob2xkZXIpYCwgYEpPKHZhbHVlKWAsIGFuZCBgSkEodmFsdWUpYCBvcGVyYXRpb25zLlxuICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGRhdGVDbGFzcyAmJiAhaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuOS41LjQ0LiBTZWUgc2VjdGlvbiAxNS45LjEuMTVcbiAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGNvbXB1dGUgdGhlIHllYXIsIG1vbnRoLCBkYXRlLCBob3VycywgbWludXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgIGRhdGUgPSBmbG9vcih2YWx1ZSAvIDg2NGU1KTtcbiAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICBkYXRlID0gMSArIGRhdGUgLSBnZXREYXkoeWVhciwgbW9udGgpO1xuICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAvLyB0byBjb21wdXRlIGBBIG1vZHVsbyBCYCwgYXMgdGhlIGAlYCBvcGVyYXRvciBkb2VzIG5vdFxuICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgYXJlIG9idGFpbmVkIGJ5XG4gICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSBmbG9vcih0aW1lIC8gNmU0KSAlIDYwO1xuICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgIGRhdGUgPSB2YWx1ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IHZhbHVlLmdldFVUQ1NlY29uZHMoKTtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBTZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMgY29ycmVjdGx5LlxuICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgLy8gTW9udGhzLCBkYXRlcywgaG91cnMsIG1pbnV0ZXMsIGFuZCBzZWNvbmRzIHNob3VsZCBoYXZlIHR3b1xuICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgIC8vIE1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNS4wLCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIGFkZHMgbm9uLXN0YW5kYXJkIGB0b0pTT05gIG1ldGhvZHMgdG8gdGhlXG4gICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAvLyBkZWZpbmVkIGRpcmVjdGx5IG9uIGFuIGluc3RhbmNlLlxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgLy8gZm9yIHNlcmlhbGl6YXRpb24uXG4gICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAvLyBgXCJudWxsXCJgLlxuICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgLy8gU3RyaW5ncyBhcmUgZG91YmxlLXF1b3RlZCBhbmQgZXNjYXBlZC5cbiAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgIC8vIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZiB1bmlxdWUgbmVzdGVkIG9iamVjdHMuXG4gICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgIC8vIEN5Y2xpYyBzdHJ1Y3R1cmVzIGNhbm5vdCBiZSBzZXJpYWxpemVkIGJ5IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICBpbmRlbnRhdGlvbiArPSB3aGl0ZXNwYWNlO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdCBtZW1iZXJzLiBNZW1iZXJzIGFyZSBzZWxlY3RlZCBmcm9tXG4gICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICBmb3JFYWNoKHByb3BlcnRpZXMgfHwgdmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBBY2NvcmRpbmcgdG8gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMzogXCJJZiBgZ2FwYCB7d2hpdGVzcGFjZX1cbiAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgLy8gVGhlIFwiYHNwYWNlYCBjaGFyYWN0ZXJcIiByZWZlcnMgdG8gdGhlIGxpdGVyYWwgc3BhY2VcbiAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocXVvdGUocHJvcGVydHkpICsgXCI6XCIgKyAod2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIikgKyBlbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJ7XFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIn1cIiA6IChcIntcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIn1cIikpIDogXCJ7fVwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICBKU09OMy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAoc291cmNlLCBmaWx0ZXIsIHdpZHRoKSB7XG4gICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIGZpbHRlciA9PSBcIm9iamVjdFwiICYmIGZpbHRlcikge1xuICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMCwgbGVuZ3RoID0gZmlsdGVyLmxlbmd0aCwgdmFsdWU7IGluZGV4IDwgbGVuZ3RoOyB2YWx1ZSA9IGZpbHRlcltpbmRleCsrXSwgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKSksIGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcyB8fCBjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpICYmIChwcm9wZXJ0aWVzW3ZhbHVlXSA9IDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoKSB7XG4gICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgIC8vIGB3aWR0aGAgbnVtYmVyIG9mIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgLy8gKGBcIlwiYCkgb25seSBpZiB0aGV5IGFyZSB1c2VkIGRpcmVjdGx5IHdpdGhpbiBhbiBvYmplY3QgbWVtYmVyIGxpc3RcbiAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgaWYgKCFoYXMoXCJqc29uLXBhcnNlXCIpKSB7XG4gICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgIC8vIGVxdWl2YWxlbnRzLlxuICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAzNDogJ1wiJyxcbiAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgMTE2OiBcIlxcdFwiLFxuICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgMTE0OiBcIlxcclwiXG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICB2YXIgSW5kZXgsIFNvdXJjZTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgdGhyb3cgU3ludGF4RXJyb3IoKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgIC8vIHRoZSBlbmQgb2YgdGhlIHNvdXJjZSBzdHJpbmcuIEEgdG9rZW4gbWF5IGJlIGEgc3RyaW5nLCBudW1iZXIsIGBudWxsYFxuICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IFNvdXJjZSwgbGVuZ3RoID0gc291cmNlLmxlbmd0aCwgdmFsdWUsIGJlZ2luLCBwb3NpdGlvbiwgaXNTaWduZWQsIGNoYXJDb2RlO1xuICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgIC8vIGZlZWRzLCBhbmQgc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyMzogY2FzZSAxMjU6IGNhc2UgOTE6IGNhc2UgOTM6IGNhc2UgNTg6IGNhc2UgNDQ6XG4gICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgIHZhbHVlID0gY2hhckluZGV4QnVnZ3kgPyBzb3VyY2UuY2hhckF0KEluZGV4KSA6IHNvdXJjZVtJbmRleF07XG4gICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgMzQ6XG4gICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgLy8gc2VudGluZWwgYEBgIGNoYXJhY3RlciB0byBkaXN0aW5ndWlzaCB0aGVtIGZyb20gcHVuY3R1YXRvcnMgYW5kXG4gICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAvLyBsZXNzIHRoYW4gdGhlIHNwYWNlIGNoYXJhY3RlcikgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEEgcmV2ZXJzZSBzb2xpZHVzIChgXFxgKSBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGFuIGVzY2FwZWRcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBhbmQgdmFsaWRhdGUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXggKyA0OyBJbmRleCA8IHBvc2l0aW9uOyBJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW5zZW5zaXRpdmUpIHRoYXQgZm9ybSBhIHNpbmdsZSBoZXhhZGVjaW1hbCB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgLy8gUmV2aXZlIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbiB1bmVzY2FwZWQgZG91YmxlLXF1b3RlIGNoYXJhY3RlciBtYXJrcyB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgLy8gT3B0aW1pemUgZm9yIHRoZSBjb21tb24gY2FzZSB3aGVyZSBhIHN0cmluZyBpcyB2YWxpZC5cbiAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZCByZXR1cm4gdGhlIHJldml2ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgLy8gQWR2YW5jZSBwYXN0IHRoZSBuZWdhdGl2ZSBzaWduLCBpZiBvbmUgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpIHtcbiAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIG9jdGFsIGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgLy8gRmxvYXRzIGNhbm5vdCBjb250YWluIGEgbGVhZGluZyBkZWNpbWFsIHBvaW50OyBob3dldmVyLCB0aGlzXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgZXhwb25lbnRzLiBUaGUgYGVgIGRlbm90aW5nIHRoZSBleHBvbmVudCBpc1xuICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDEwMSB8fCBjaGFyQ29kZSA9PSA2OSkge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT0gSW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENvZXJjZSB0aGUgcGFyc2VkIHZhbHVlIHRvIGEgSmF2YVNjcmlwdCBudW1iZXIuXG4gICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBBIG5lZ2F0aXZlIHNpZ24gbWF5IG9ubHkgcHJlY2VkZSBudW1iZXJzLlxuICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgIEluZGV4ICs9IDU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgIEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVW5yZWNvZ25pemVkIHRva2VuLlxuICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICByZXR1cm4gXCIkXCI7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgdmFyIGdldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgLy8gVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQuXG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiW1wiKSB7XG4gICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBJZiB0aGUgYXJyYXkgbGl0ZXJhbCBjb250YWlucyBlbGVtZW50cywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEVsaXNpb25zIGFuZCBsZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIGN1cmx5IGJyYWNlIG1hcmtzIHRoZSBlbmQgb2YgdGhlIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICBpZiAoaGFzTWVtYmVycykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBMZWFkaW5nIGNvbW1hcyBhcmUgbm90IHBlcm1pdHRlZCwgb2JqZWN0IHByb3BlcnR5IG5hbWVzIG11c3QgYmVcbiAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIgfHwgdHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIgfHwgKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pICE9IFwiQFwiIHx8IGxleCgpICE9IFwiOlwiKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXSA9IGdldChsZXgoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBVcGRhdGVzIGEgdHJhdmVyc2VkIG9iamVjdCBtZW1iZXIuXG4gICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24oc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgLy8gYGNhbGxiYWNrYCBmdW5jdGlvbiBmb3IgZWFjaCB2YWx1ZS4gVGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdmFsdWUgPSBzb3VyY2VbcHJvcGVydHldLCBsZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAvLyBiZWNhdXNlIGl0cyBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIGBmYWxzZWBcbiAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzb3VyY2UsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICBKU09OMy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICBJbmRleCA9IDA7XG4gICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgIC8vIElmIGEgSlNPTiBzdHJpbmcgY29udGFpbnMgbXVsdGlwbGUgdG9rZW5zLCBpdCBpcyBpbnZhbGlkLlxuICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrICYmIGdldENsYXNzLmNhbGwoY2FsbGJhY2spID09IGZ1bmN0aW9uQ2xhc3MgPyB3YWxrKCh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHJlc3VsdCwgdmFsdWUpLCBcIlwiLCBjYWxsYmFjaykgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8vIEV4cG9ydCBmb3IgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLlxuICBpZiAoaXNMb2FkZXIpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIEpTT04zO1xuICAgIH0pO1xuICB9XG59KHRoaXMpKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gdG9BcnJheVxuXG5mdW5jdGlvbiB0b0FycmF5KGxpc3QsIGluZGV4KSB7XG4gICAgdmFyIGFycmF5ID0gW11cblxuICAgIGluZGV4ID0gaW5kZXggfHwgMFxuXG4gICAgZm9yICh2YXIgaSA9IGluZGV4IHx8IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycmF5W2kgLSBpbmRleF0gPSBsaXN0W2ldXG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgb2JqZWN0ID0gcmVxdWlyZSgnLi8nKTtcblxudXRpbC5kZWZpbmUob2JqZWN0LFxuICAvKipcbiAgICogVi5PYmplY3QncyBlcXVpdmFsZW50IHRvIEFycmF5LnB1c2goKVxuICAgKiBAbWV0aG9kIHB1c2hcbiAgICogQHBhcmFtICB7QXJndW1lbnRzfSAgVGhlIGl0ZW0ocykgdG8gYWRkIHRvIHRoZSBhcnJheVxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICBUaGUgbmV3IGxlbmd0aCBvZiB0aGUgYXJyYXlcbiAgICovXG4gICdwdXNoJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX190ID09PSAxKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5fcHVzaChhcmd1bWVudHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSxcbiAgJ19wdXNoJywgZnVuY3Rpb24odmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb20pIHtcbiAgICAvL2FtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb21cbiAgICB0aGlzLmxlbmd0aCsrO1xuICAgIHRoaXMuc2V0KCh0aGlzLmxlbmd0aCAtIDEpLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSk7XG4gICAgcmV0dXJuIHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgfSxcbiAgLyoqXG4gICAqIFYuT2JqZWN0J3MgZXF1aXZhbGVudCB0byBBcnJheS5wb3AoKVxuICAgKiBAbWV0aG9kIHBvcFxuICAgKiBAcmV0dXJuIHsqfSAgVGhlIHJlbW92ZWQgYXJyYXkgaXRlbVxuICAgKi9cbiAgJ3BvcCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgdmFyIGwgPSB0aGlzLmxlbmd0aFxuICAgICAgaWYobCAhPT0gMCl7XG4gICAgICAgIHQgPSB0aGlzW2wgLSAxXTtcbiAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgdC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiB0OyAvL3ByZXR0eSB3ZWlyZCBzaW5jZSB0aGlzIG9iamVjdCBhbHdheXMgaGFzIHZhbHVlIG51bGw7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogVi5PYmplY3QncyBlcXVpdmFsZW50IHRvIEFycmF5LnNwbGljZSgpXG4gICAqIEBtZXRob2Qgc3BsaWNlXG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgaW5kZXggICBBbiBpbnRlZ2VyIHRoYXQgc3BlY2lmaWVzIGF0IHdoYXQgcG9zaXRpb24gdG8gYWRkL3JlbW92ZSBpdGVtcywgVXNlIG5lZ2F0aXZlIHZhbHVlcyB0byBzcGVjaWZ5IHRoZSBwb3NpdGlvbiBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5XG4gICAqIEBwYXJhbSAge051bWJlcn0gICAgaG93bWFueSBUaGUgbnVtYmVyIG9mIGl0ZW1zIHRvIGJlIHJlbW92ZWQuIElmIHNldCB0byAwLCBubyBpdGVtcyB3aWxsIGJlIHJlbW92ZWRcbiAgICogQHBhcmFtICB7QXJndW1lbnRzfSAgICAgICAgIFRoZSBuZXcgaXRlbShzKSB0byBiZSBhZGRlZCB0byB0aGUgYXJyYXlcbiAgICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgIEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIHJlbW92ZWQgaXRlbXMsIGlmIGFueVxuICAgKi9cbiAgJ3NwbGljZScsIGZ1bmN0aW9uKGluZGV4LCBob3dtYW55KSB7IC8vY2FuIGJlY29tZSBzaG9ydGVyO1xuICAgIGlmIChpbmRleCA+IC0xICYmIHRoaXMuX190ID09PSAxKSB7IC8vaG93IG1hbnkgYW5kIC1pIGFyZSBpZ25vcmVkXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoLCBzaGlmdDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgICAgICAgIC8vIHRoaXMubGVuZ3RoLS07XG4gICAgICAgICAgICB0aGlzW2ldID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tpXSA9IHRoaXNbaSArIDFdO1xuICAgICAgICAgICAgdGhpc1tpXS5fbmFtZSA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpID09PSBpbmRleCkge1xuICAgICAgICAgICAgaWYgKGkgPT09IGwgLSAxKSB7XG4gICAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgICAgICAgIHRoaXNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIHRoaXNbaV0gPSB0aGlzW2kgKyAxXTtcbiAgICAgICAgICAgICAgdGhpc1tpXS5fbmFtZSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQWRkcyB2YWx1ZSB0byBhcnJheSBpZiBpdCBpcyBub3QgY29udGFpbmVkIGluIGFycmF5LCBleGVjdXRlcyBoYW5kbGVyIG9uIGVuY291bnRlcmluZyB2YWwgaW4gYXJyYXlcbiAgICogQG1ldGhvZCBpbmNsdWRlXG4gICAqIEBwYXJhbSAgeyp9ICAgICAgICAgdmFsICAgICAgIFZhbHVlIHRvIGFkZFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gIFtoYW5kbGVyXSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVuY291bnRlcmluZyB2YWwgaW4gYXJyYXlcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgVHJ1ZS9mYWxzZVxuICAgKi9cbiAgJ2luY2x1ZGUnLCBmdW5jdGlvbih2YWwsIGhhbmRsZXIsIGFycikge1xuICAgIHJldHVybiB1dGlsLmluY2x1ZGUodGhpcywgdmFsLCBoYW5kbGVyLCBhcnIpO1xuICB9LFxuICAnY29uY2F0JywgZnVuY3Rpb24odmFsKSB7IFxuXG4gICAgLy8gaWYoIXZhbCkge1xuICAgIC8vICAgcmV0dXJuXG4gICAgLy8gfVxuICAgIFxuICAgIHZhciBhcnIgPSB0aGlzXG4gICAgdmFyIGxsID0gYXJyLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGFyci5fcHVzaCh2YWxbaV0sIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGFyci5fdXBkYXRlKHZhbCk7XG4gICAgcmV0dXJuIGFycjtcbiAgfSxcbiAgJ21vdmVJdGVtJywgZnVuY3Rpb24oZnJvbSwgdG8pIHsgdmFyIGFyciA9IHRoaXNcbiAgICBpZih0byA9PT0gdm9pZCAwKSB0byA9IGFyci5sZW5ndGggLSAxXG4gICAgaWYoZnJvbSA9PT0gdG8pIHJldHVyblxuICAgIHZhciBtb3ZlciA9IGFycltmcm9tXVxuICAgIGlmKCFtb3ZlcikgcmV0dXJuXG4gICAgdmFyIHN0ZXAgPSBmcm9tIDwgdG8gPyAxIDogLTFcbiAgICBkbyB7XG4gICAgICBhcnJbZnJvbV0gPSBudWxsXG4gICAgICBhcnIuc2V0KGZyb20sIGFycltmcm9tICsgc3RlcF0sIHRydWUpXG4gICAgICBmcm9tICs9IHN0ZXBcbiAgICB9IHdoaWxlKGZyb20gIT09IHRvKVxuICAgIGFyclt0b10gPSBudWxsXG4gICAgYXJyLnNldCh0bywgbW92ZXIsIHRydWUpXG4gIH1cbilcbiIsIlxuXG52YXIgVk9iamVjdCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QnKS5pbmplY3QoXG4gICAgcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlL2xlbmd0aCcpXG4gICksXG4gIHV0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbCcpLFxuICB1aWQgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9pZCcpXG5cbnZhciBTQU1FUEFUSCA9ICdjb3VsZCBub3QgY3JlYXRlIGNvbXBvdW5kIG9mIHR3byBPYmplY3RzIHdpdGggdGhlIHNhbWUgcGF0aCdcblxuLy8gZnVuY3Rpb24gQ29tcG91bmQodmFsKXtcbi8vICAgdmFyIGNvbXBvdW5kID0gdGhpc1xuLy8gICBjb21wb3VuZC4kc291cmNlcyA9IG5ldyBTb3VyY2VMaXN0KGNvbXBvdW5kLCB2YWwpXG4vLyAgIHRoaXMuX190ID0gMlxuLy8gfVxuXG4vLyB2YXIgRGF0YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9kYXRhJylcblxudmFyIENvbXBvdW5kID0gVk9iamVjdC5uZXcodm9pZCAwLCBmdW5jdGlvbih2YWwpe1xuICB2YXIgY29tcG91bmQgPSB0aGlzXG4gIGNvbXBvdW5kLiRzb3VyY2VzID0gbmV3IFNvdXJjZUxpc3QoY29tcG91bmQsIHZhbClcbiAgdGhpcy5fX3QgPSAyXG4gIHJldHVybiBmYWxzZVxufSlcbnV0aWwuZGVmaW5lKENvbXBvdW5kLCAnX2NsYXNzJywgVk9iamVjdClcblxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvdW5kXG4vLyBDb21wb3VuZC5wcm90b3R5cGUgPSBuZXcgVk9iamVjdCgpXG5cbkNvbXBvdW5kLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goXG4gICckc291cmNlcydcbilcblxudXRpbC5kZWZpbmUoIENvbXBvdW5kLFxuICAnX2Fic29yYicsIGZ1bmN0aW9uIF9hYnNvcmIoZW50cnkpIHtcbiAgICB2YXIgY29tcG91bmQgPSB0aGlzXG4gICAgdmFyIHNvdXJjZSA9IGVudHJ5LnNvdXJjZVxuICAgIHZhciBwcmVmaXggPSBlbnRyeS5uYW1lXG4gICAgXG4gICAgdmFyIGVuZHBvaW50ID0gc291cmNlXG4gICAgd2hpbGUoZW5kcG9pbnQgJiYgZW5kcG9pbnQuX190ID09PSA0ICYmICFlbmRwb2ludC5fZmlsdGVyKSB7XG4gICAgICBlbmRwb2ludCA9IGVuZHBvaW50Ll92YWxcbiAgICB9XG4gICAgZW50cnkuZW5kcG9pbnQgPSBlbmRwb2ludFxuICAgIFxuICAgIGlmKGVuZHBvaW50KSB7XG4gICAgICBlbmRwb2ludC5lYWNoKGZ1bmN0aW9uIGFic29yYkVhY2goKXtcbiAgICAgICAgY29tcG91bmQuc2V0KHByZWZpeCArICctJyArdGhpcy5fbmFtZSwgdGhpcylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29tcG91bmQuZWFjaChmdW5jdGlvbiBjbGVhbk9sZCgpe1xuICAgICAgdmFyIHBvaW50ZXIgPSB0aGlzXG4gICAgICB2YXIgcG9pbnRlZCA9IHBvaW50ZXIuX3ZhbFxuXG4gICAgICAvLyBza2lwIGNsZWFudXAgY2hlY2sgb24gY29uc3RydWN0aW9uXG4gICAgICBpZighY29tcG91bmQuJHNvdXJjZXMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGNoZWNrIGlmIHRoaW5nIGlzIHN0aWxsIGluIGFuIGVucG9pbnRcbiAgICAgIC8vIGdldCB0aGUgZW5kcG9pbnQgdGhlIGl0ZW0gc2hvdWxkIGJlIGluXG4gICAgICB2YXIgc291cmNlbmFtZSA9IHBvaW50ZXIuX25hbWUuc3BsaXQoJy0nKVswXVxuICAgICAgdmFyIGVwID0gY29tcG91bmQuJHNvdXJjZXNbc291cmNlbmFtZV0uZW5kcG9pbnRcbiAgICAgIHZhciBva1xuICAgICAgZXAuZWFjaChmdW5jdGlvbiBva0NoZWNrKCl7XG4gICAgICAgIGlmKHRoaXMgPT09IHBvaW50ZWQpIHtcbiAgICAgICAgICByZXR1cm4gb2sgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZighb2spIHtcbiAgICAgICAgcG9pbnRlci5yZW1vdmUoKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gICdfYWRkQ29tcG91bmRMaXN0ZW5lcicsIGZ1bmN0aW9uIF9hZGRDb21wb3VuZExpc3RlbmVyKGVudHJ5KSB7XG4gICAgdmFyIGNvbXBvdW5kID0gdGhpc1xuICAgIGVudHJ5LnNvdXJjZS5vbihmdW5jdGlvbiBjb21wb3VuZExpc3RlbmVyKCl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnY2hhbmdlIGluIHNvdXJjZSwgcnVuIGFic29yYiBvbicsIGVudHJ5LCBcbiAgICAgIC8vICAgJ1xcbnZhbCcsIGFyZ3VtZW50c1swXSxcbiAgICAgIC8vICAgJ1xcbnN0YW1wJywgYXJndW1lbnRzWzFdXG4gICAgICAvLyApXG4gICAgICBjb21wb3VuZC5fYWJzb3JiKGVudHJ5KVxuICAgIH0pXG4gIH1cbilcblxuZnVuY3Rpb24gU291cmNlTGlzdChjb21wb3VuZCwgdmFsKSB7XG4gIHZhciBzb3VyY2VsaXN0ID0gdGhpc1xuICBzb3VyY2VsaXN0Ll9wYXJlbnQgPSBjb21wb3VuZFxuICBpZih2YWwpe1xuICAgIGlmKCEodmFsIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB2YWwgPSBbdmFsXVxuICAgIH1cbiAgICB0aGlzLnB1c2guYXBwbHkodGhpcywgdmFsKVxuICB9XG59XG5cblNvdXJjZUxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoU291cmNlKCl7XG4gIHZhciBzb3VyY2VsaXN0ID0gdGhpc1xuICB2YXIgY29tcG91bmQgPSBzb3VyY2VsaXN0Ll9wYXJlbnRcblxuICAvLyBjb25zb2xlLmxvZygncHVzaCBkYXQgc291cmNlcycsIGFyZ3VtZW50cy5sZW5ndGgpXG4gIHZhciBhbCA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgZm9yKHZhciBpID0gMCwgc291cmNlOyBzb3VyY2UgPSBhcmd1bWVudHNbaV0gOyBpKyspe1xuXG4gICAgdmFyIHNvdXJjZW5hbWUgPSB1aWQoKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ1NPVVJDRU5BTUUgSVMnLCBzb3VyY2VuYW1lKVxuXG4gICAgdmFyIGVudHJ5ID0gc291cmNlbGlzdFtzb3VyY2VuYW1lXSA9IHtcbiAgICAgIG5hbWU6IHNvdXJjZW5hbWUsXG4gICAgICBzb3VyY2U6IHNvdXJjZVxuICAgIH1cblxuICAgIGNvbXBvdW5kLl9hYnNvcmIoZW50cnkpXG4gICAgY29tcG91bmQuX2FkZENvbXBvdW5kTGlzdGVuZXIoZW50cnkpXG5cbiAgfVxufVxuXG5cblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcblxuLyoqXG4gKiBGbGFncyBhcmUgc3BlY2lhbCBwcm9wZXJ0aWVzIHdoZXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkXG4gKiBkaWZmZXJlbnQgZnJvbSBvcGVyYXRvcnMgc2luY2UgZmxhZ3MgbWF5IGhhdmUgbm90aGluZyB0byBkbyB3aXRoIHZhbHVlIGNhbGN1bGF0aW9uXG4gKiBleHRlbmRzIGRlZmF1bHQgc2V0IGZyb20gVi5PYmplY3RcbiAqIEBwcm9wZXJ0eVxuICovXG4vKipcbiAqIEFkZHMgbmV3IGZsYWdzIHRvIFYuT2JqZWN0XG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICB7T2JqZWN0fSAgIG9iamVjdCBWLk9iamVjdCB0byBleHRlbmQgZmxhZ3MgdG9cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBbc2V0XSAgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZnVuY3Rpb24ob2JqZWN0LCBzZXQpIHtcbiAgXG4gIC8vbXVsdGlwbGUgZmxhZ3MgXG4gIFxuICAvLyBhYnN0cmFjdCBmbGFncyBhcnJheSBhd2F5IVxuICAvLyBcbiAgLy8gZmxhZ3Mgb2JqZWN0IC0tPiBmaWVsZFxuICAvLyBcbiAgLy8gY2hlY2sgL3cgY2FzZXNcbiAgLy8gY2hlY2sgL3cgcGFyZW50XG4gIC8vIGZsYWc0IGlzIGR5bmFtaWMgaGFzIHN0YWNrIGFzIG9wdGlvblxuICBcbiAgdmFyIF9wcm90byA9IG9iamVjdC5wcm90b3R5cGVcbiAgICAsIF9jb252ZXJ0ID0gX3Byb3RvLmNvbnZlcnRcbiAgICAsIF9zZXQgPSBfcHJvdG8uX3NldFxuICAgICwgX3JlbW92ZSA9IF9wcm90by5fcmVtb3ZlXG4gICAgLCBfY2hlY2sgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZjtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqZWN0LmZsYWdzLmR5bmFtaWMpIHtcbiAgICAgICAgZiA9IG9iamVjdC5mbGFncy5keW5hbWljW2ldKG5hbWUpXG4gICAgICAgIGlmKGYpIGJyZWFrXG4gICAgICB9XG4gICAgICByZXR1cm4gZlxuICAgIH1cbiAgICAsIGNoZWNrSWZGbGFnT3ZlcndyaXRlID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICBmb3IodmFyIGkgaW4gdmFsKSB7XG4gICAgICAgIGlmKG9iamVjdC5mbGFnc1tpXSB8fCBfY2hlY2soaSkpIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gIGlmICghc2V0KSBzZXQgPSBfcHJvdG8uc2V0XG5cbiAgX3Byb3RvLl9ibGFja2xpc3QucHVzaCgnX2ZsYWcnKTtcbiAgdXRpbC5kZWZpbmUob2JqZWN0LFxuICAgIC8qKlxuICAgICAqIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAbWV0aG9kIGNvbnZlcnRcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHZhbCBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICdjb252ZXJ0JywgZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgIC8vaGllciBvb2sgd2VlciBmb3JcbiAgICAgIHZhciBvYmogPSBfY29udmVydC5jYWxsKHRoaXMsIHZhbCk7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdJIFNIT1VMRCBCRSBDT05WRVJUSU5HIScsIHZhbCwgb2JqLCB0aGlzLl9mbGFnKVxuXG5cblxuXG5cbiAgICAgIGlmICh0aGlzLl9mbGFnICYmICghdmFsIHx8ICF1dGlsLmlzT2JqKHZhbCkgfHwgdmFsLnZhbCB8fCBjaGVja0lmRmxhZ092ZXJ3cml0ZSh2YWwpICkpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnSSBTSE9VTEQgQkUgQ09OVkVSVElORyEgc3RlcCAyJylcblxuICAgICAgICAvL2ZmIHVzZVZhbCBnZWJydWlrZW5cblxuICAgICAgICBmb3IodmFyIGkgaW4gdGhpcy5fZmxhZykge1xuICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgIGlmICghZmxhZ1s0XSB8fCAhZmxhZ1s0XS5zdGFjaykge1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ09OVkVSVCBORUVEUyBGSVgnLnJlZC5ib2xkLmludmVyc2UpXG5cbiAgICAgICAgICAgIGlmIChvYmogPT09IGZsYWdbMV0pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzIgQ09OVkVSVCBORUVEUyBGSVgnLnJlZC5ib2xkLmludmVyc2UpXG4gICAgICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9iai52YWwgPT09IGZsYWdbMV0pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzMgQ09OVkVSVCBORUVEUyBGSVgnLnJlZC5ib2xkLmludmVyc2UpXG4gICAgICAgICAgICAgIGRlbGV0ZSBvYmoudmFsO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIG9ialtmbGFnWzBdXSA9IGZsYWdbMl1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvL3N0aWxsIGhhdmUgdG8gdGFrZSBjYXJlIG9mIHRoaXMgc2l0dWF0aW9uXG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd0cnlpbmcgY29udmVydCBhIHN0YWNrLWR5bmFtaWMgZmxhZycsIGZsYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdDT05WRVJURUQgLS0tLT4nLG9iailcblxuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgQHByb3BlcnR5IF9fZmxhZ3NfX1xuICAgICovXG4gICAgJ19fZmxhZ3NfXycsIHt9LFxuICAgIC8qKlxuICAgICAqIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZnJvbSAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHVwZGF0ZSBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFtcCAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAnX3JlbW92ZScsIGZ1bmN0aW9uKGZyb20sIHVwZGF0ZSwgc3RhbXApIHtcblxuICAgICAgaWYodGhpcy5fZmxhZykge1xuICAgICAgICBmb3IodmFyIGkgaW4gdGhpcy5fZmxhZykge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGksIHRoaXMuX2ZsYWcpXG4gICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgLy9mb3IgXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ19yZW1vdmUnKVxuICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICAvL2RpdCBtb2V0IHdlbCBmZiBsdWtrZW5cbiAgICAgICAgICAgIGlmIChvYmplY3QuZmxhZ3NbZmxhZ1swXV0pIHtcbiAgICAgICAgICAgICAgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dLnJlbW92ZSAmJiBvYmplY3QuZmxhZ3NbZmxhZ1swXV0ucmVtb3ZlLmNhbGwodGhpcywgZmxhZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmbGFnWzRdLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9mbGFnID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBfcmVtb3ZlLmNhbGwodGhpcywgZnJvbSwgdXBkYXRlLCBzdGFtcCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBbZGVzY3JpcHRpb25dXG4gICAgICogQG1ldGhvZCBfc2V0XG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB2YWwgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFtcCAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmcm9tICAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSByZW1vdmUgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub3VwZGF0ZSBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJ19zZXQnLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIG5vdXBkYXRlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnbWFrZSBfc2V0Jyx0aGlzLl9uYW1lLHZhbCk7XG4gICAgICBfc2V0LmNhbGwodGhpcywgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBub3VwZGF0ZSlcblxuICAgICAgLy9mbGFnIG1vZXQgZHVzIG9vayBtZWVyIGVlbiBjb3BpZWQgdmFsdWUgd29yZGVuXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdfc2V0JywgdGhpcy5fZmxhZywgdmFsKVxuXG5cbiAgICAgIGlmKHRoaXMuX2ZsYWcpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnb3ZlcndyaXRlPj8tLS0tJywgdGhpcy5fZmxhZywgdmFsKVxuXG4gICAgICAgIGZvcih2YXIgaSBpbiB0aGlzLl9mbGFnKSB7XG4gICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIHZhciBzZXRGbCA9IG9iamVjdC5mbGFnc1tmbGFnWzBdXSB8fCBmbGFnWzRdXG4gICAgICAgICAgICAvL3doYXQgdG8gZG8gd2l0aCByZXNldD9cbiAgICAgICAgICAgIC8vY2hhbmdlIGZpeGVuIGJpaiBjYXNlcz9cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzIgb3ZlcndyaXRlPj8tLS0tJywgZmxhZywgdGhpcy5fdmFsLCB0aGlzLl92YWwgIT09IGZsYWdbMV0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLl92YWwgIT09IGZsYWdbMV0gJiYgc2V0RmwudXNlVmFsKSB7XG5cbiAgICAgICAgICAgICAgLy8gbnUgZmYgaGllciBvb2sgbm9nIVxuXG4gICAgICAgICAgICAgIGlmIChvYmplY3QuZmxhZ3NbZmxhZ1swXV0pIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgZmxhZyBub3JtYWwnLGZsYWcsIGZsYWdbNF0sIGksIHRoaXMpXG5cbiAgICAgICAgICAgICAgICBvYmplY3QuZmxhZ3NbZmxhZ1swXV0ucmVtb3ZlICYmIG9iamVjdC5mbGFnc1tmbGFnWzBdXS5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKVxuICAgICAgICAgICAgICAgIC8vaWYgdGhpcyBlbXB0eVxuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSB0aGlzLl9mbGFnO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICAgICAgaWYodXRpbC5lbXB0eSh0aGlzLl9mbGFnKSkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5fdXBkYXRlKClcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghZmxhZ1s1XSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgZmxhZyAvdyBmbGFnWzRdIGFuZCBub3QgZmxhZ1s1XScsZmxhZywgZmxhZ1s0XSwgaSlcbiAgICAgICAgICAgICAgICBmbGFnWzRdLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgICAgIC8vIGlmKHRoaXMuKVxuICAgICAgICAgICAgICAgIC8vZGVsZXRlIHRoaXMuX2ZsYWc7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICAgICAgICBpZih1dGlsLmVtcHR5KHRoaXMuX2ZsYWcpKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3QuZmxhZ3NbZmxhZ1swXV0gJiYgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dLnJlc2V0ICYmIGZsYWdbM10gIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignUkVTRVRUSU5HIC0tIGluZ25vcmUgL3cgYSBjbGVhciEnLGZsYWdbMF0pIFxuICAgICAgICAgICAgICBvYmplY3QuZmxhZ3NbZmxhZ1swXV0uc2V0LmNhbGwodGhpcywgZmxhZ1syXSwgc3RhbXAsIHRydWUsIHRoaXMuX25hbWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmFtZSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdmFsICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdm9iaiAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhbXAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm91cGRhdGUgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICdzZXQnLCBmdW5jdGlvbihuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSkge1xuICAgICAgdmFyIGZsID0gb2JqZWN0LmZsYWdzW25hbWVdIHx8IF9jaGVjayhuYW1lKVxuICAgICAgICAsIHJcbiAgICAgICAgLCBzYW1lXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2cobmFtZSwgdmFsLCB2b2JqKVxuXG4gICAgICBpZiAoZmwpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0Pj8tLS0tJywgbmFtZSwgdmFsLCB0aGlzLl9mbGFnKVxuICAgICAgIFxuICAgICAgaWYodmFsPT09ZmFsc2UpIHtcbiAgICAgICAgICAvL3N0YWNrIC0tIGFsbGUgZmxhZ3MgbmFtZSBwcm92aWRlbiFcbiAgICAgICAgICB2YXIgaSA9IGZsLnN0YWNrfHxuYW1lIFxuICAgICAgICAgICAgLCBmbGFnID0gdGhpcy5fZmxhZyAmJiB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgaWYoZmxhZyAmJiBmbC5yZW1vdmUpIHtcbiAgICAgICAgICAgIHZhciBkID0gZmwucmVtb3ZlLmNhbGwodGhpcywgZmxhZywgbmFtZSlcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgRkxBRyBGUk9NIEZBTFNFJy5pbnZlcnNlLCBmbCwgbmFtZSwgdmFsLCBzdGFtcCwgdGhpcylcbiAgICAgICAgICAgIGlmKCFkKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICAgIGlmKHV0aWwuZW1wdHkodGhpcy5fZmxhZykpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZmxhZyBpcyBlbXB0eSwgZGVsZXRlJylcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBcbiAgICAgICAgICByID0gdHJ1ZVxuICAgICAgICAgIC8vIGlmKHRoaXMuX2ZsYWcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgIGlmKHRoaXMuX2ZsYWcpIHtcbiAgICAgICAgICAvL2NoZWNrIGlmIG5lZWQgdG8gcmVtb3ZlISAtLSBvbmx5IGluIGNhc2VcbiAgICAgICAgICBmb3IodmFyIGkgaW4gdGhpcy5fZmxhZykge1xuICAgICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICBpZiAoZmxhZyAmJiBmbC5yZW1vdmUpIHtcblxuICAgICAgICAgICAgICBpZighZmwuc3RhY2sgJiYgbmFtZSA9PT0gZmxhZ1swXSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+JyxmbGFnWzBdKVxuICAgICAgICAgICAgICAgIGlmKHZhbCE9PWZsYWdbMl0pIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgZmxhZyEgLS0tPiBvdmVyd3JpdGUgYnlteXNlbGYgLS0tPicsIGZsYWdbMF0sICBzZXRGbCwgJ2J5OicgLG5hbWUsIGZsLCB2YWwsIGZsYWdbMl0pXG4gICAgICAgICAgICAgICAgICBmbC5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgc2FtZSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghZmwuc3RhY2sgfHwgZmwuc3RhY2sgIT09IGZsYWdbMF0pIHtcblxuICAgICAgICAgICAgICAgIC8vdGhpcy5fZmxhZ1xuXG4gICAgICAgICAgICAgICAgLy9pZiB2YWw6dHJ1ZSBcbiAgICAgICAgICAgICAgICAvL2dvIGNoZWNrIGlmIHlvdSBuZWVkIHRvIHJlbW92ZSBtb2Zvc1xuXG4gICAgICAgICAgICAgICAgdmFyIHNldEZsID0gb2JqZWN0LmZsYWdzW2ZsYWdbMF1dIHx8IGZsYWdbNF1cblxuICAgICAgICAgICAgICAgIGlmKHNldEZsLnVzZVZhbCAmJiBmbC51c2VWYWwpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSBmbGFnISAtLSBjbGVhcmx5IGhhcyBzb21lIHVzZVZhbCcsIGZsYWdbMF0sICBzZXRGbCwgJ2J5OicgLG5hbWUsIGZsKVxuXG4gICAgICAgICAgICAgICAgICBzZXRGbC5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICAgICAgICBpZih1dGlsLmVtcHR5KHRoaXMuX2ZsYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmbGFnIGlzIGVtcHR5LCBkZWxldGUnKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSBmbGFnIScsIGZsYWcsIGZsYWdbMF0sIGZsYWdbNF0sICBvYmplY3QuZmxhZ3NbZmxhZ1swXV0gICwgZmwsIG5hbWUpIC8vY2hlY2sgaWYgaXQgbmVlZHMgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgICAgICAgIC8vIHZhciBmbCBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL2ZsID0gb2JqZWN0LmZsYWdzW25hbWVdIHx8IF9jaGVjayhuYW1lKVxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy9oaWVyIGlldHMgbWVlIGRvZW4gd2VlciB6b2VrZW4gbmFhciBmbGFnIHNldFxuXG5cbiAgICAgICAgICAgICAgICAvL2RvIHRoZSBzcGVjaWFsIGNoZWNrIGlmIHZhbHVlIGlzIHRpZ2h0IHRvIGZsYWcgY2hlY2sgKGZvciBib3RoISBmbC52YWx1ZSlcblxuICAgICAgICAgICAgICAgIC8vIGZsLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGlmKCFzYW1lKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1NFVCBGTEFHJy5pbnZlcnNlLCBuYW1lLCB2YWwsIHN0YW1wLCB0aGlzKVxuICAgICAgICAgIGZsLnNldC5jYWxsKHRoaXMsIHZhbCwgc3RhbXAsIGZhbHNlLCBuYW1lKTtcbiAgICAgICAgICByID0gdHJ1ZSAvL25pZXQgYWx0aWpkIHdhYXIgb2Zjb3Vyc2UhXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0ZMQUcgSVMgU0FNRScucmVkLmludmVyc2UsIG5hbWUsIHZhbCwgc3RhbXAsIHRoaXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICAgdGhpc1tuYW1lXSAmJiB0aGlzW25hbWVdLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciA9IHNldC5jYWxsKHRoaXMsIG5hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByO1xuICAgIH0pO1xuICBvYmplY3QuZmxhZ3MgPSBfcHJvdG8uX19mbGFnc19fO1xuICB1dGlsLmRlZmluZShvYmplY3QuZmxhZ3MsICdkeW5hbWljJywge30pO1xufSkiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIGhhc2ggPSByZXF1aXJlKCcuLi91dGlsL2hhc2gnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGZ1bmN0aW9uKGJhc2UpIHtcbiAgYmFzZS5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfX2hwJylcbiAgdXRpbC5kZWZpbmUoIGJhc2VcbiAgLCAnX2hhc2hwYXRoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19ocCB8fCAodGhpcy5fX2hwID0gaGFzaCh0aGlzLl9wYXRoLnRvU3RyaW5nKCkpKVxuICAgICAgfVxuICAgIH1cbiAgKVxufSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIHZpZ291ciA9IHJlcXVpcmUoJy4uLycpXG4gICwgaW5qZWN0ID0gcmVxdWlyZSgnLi4vdXRpbC9pbmplY3QnKVxuLyoqXG4gKiBWLk9iamVjdHMgYXJlIHVzZWQgaW5zdGVhZCBvZiBub3JtYWwgb2JqZWN0cyBpbiB2aWdvdXIgbGlzdGVuZXJzIGFyZSBhdXRvbWF0aWNhbGx5IGFkZGVkIGFuZCByZW1vdmVkXG4gKiB0eXBlOiBfX3QgOiAxID0gYXJyYXkgLCAyID0gb2JqZWN0ICwgMyA9IGhhcyBmaWVsZCAoY2FuIG5ldmVyIGJlIGFuIGFycmF5KSAsIDQgPSBmaWVsZCByZWYgdG8gb3RoZXIgVi5PYmplY3RcbiAqIG5vdGUgeW91IGNhbiBtYWtlIGFuIG9iamVjdCBvdXQgb2YgYSBmaWVsZCBvciBmaWVsZCByZWYgdGhlIHR5cGUgd2lsbCBiZSAzIG9yIDQgdGhvdWdoIVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gIHsqfSAgICAgIFt2YWxdICAgIFZhbHVlXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtwYXJlbnRdIFBhcmVudG9iamVjdFxuICovXG52YXIgb2JqZWN0ID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gdmlnb3VyLk9iamVjdCA9IGZ1bmN0aW9uKHZhbCwgaG9vaywgcGFyZW50KSB7XG4gIGlmIChwYXJlbnQpIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICBpZiAoaG9vayAmJiB0aGlzLl9ob29rKSB0aGlzLl9ob29rKHZhbCwgaG9vaylcbiAgaWYgKHZhbCAhPT0gdm9pZCAwKSB0aGlzLnZhbCA9IHZhbFxufVxub2JqZWN0LmluamVjdCA9IGluamVjdFxuLyoqXG4gKiBVc2VkIHRvIHNldCAudmFsXG4gKiBAbWV0aG9kIF9zZXRcbiAqIEBwYXJhbSAgeyp9ICAgICAgICAgICAgICB2YWwgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgW3N0YW1wID0gbmV3IHN0YW1wXSAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7T2JqZWN0fEJvb2xlYW59IFtmcm9tXSAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBbbm91cGRhdGVdICAgICAgICAgICBXaGVuIHRydWUsIG5vIHVwZGF0ZXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBbYWRkXSAgICAgICAgICAgICAgICBXaGVuIHRydWUsIHRoaXMgaXMgYW4gYWRkXG4gKi9cbnZhciBfc2V0ID0gZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgbm91cGRhdGUsIGFkZCkge1xuXG4gIGlmKHZhbD09PW51bGwpIHtcbiAgICBpZiAoIXN0YW1wKSBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuICAgIHRoaXMucmVtb3ZlKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSlcbiAgfVxuXG4gIGlmICghdGhpcy5fX3QgfHwgdGhpcy5fX3QgPCAzIHx8ICggdmFsICE9PSB0aGlzLl92YWwgfHwgdGhpcy5faWdub3JlVmFsdWUgKSApIHtcblxuICAgIC8vIGNvbnNvbGUuZXJyb3IodGhpcylcbiAgICBpZighdGhpcy5zdGFtcCkge1xuICAgICAgLy9tb2V0IGFsbGVtYWFsIGV2ZW50IGVtaXR0ZXJzIHdvcmRlbiAob24oJ2Vycm9yJykpXG4gICAgICAvL3RoaXMuX3VwZGF0ZSgnZXJyb3InKSBlbiBhbmRlcnMgVi5kZWJ1Zy5lcnJvci5fdXBkYXRlKCAnb2JqZWN0JyApXG4gICAgICBjb25zb2xlLmVycm9yKCAnRVJST1IgaW4gdmlnb3VyLWpzL29iamVjdCwgIE9CSkVDVCBubyAuc3RhbXAnLCB0aGlzIClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghc3RhbXApIHN0YW1wID0gdGhpcy5zdGFtcCgpXG5cbiAgICB2YXIgb2xkdmFsID0gdGhpcy5fdmFsXG4gICAgICAsIG5lc3RlZHZhbFxuICAgICAgLCBub3NldFxuICAgICAgLCBpc1NldFxuICAgICAgLCBpc0FycmF5XG4gICAgICAsIHZhbElzU2V0XG5cbiAgICBpZiAodGhpcy5fY2hhbmdldm9iaiBcbiAgICAgICYmICgodGhpcy5fX3QgPCA0ICYmIHZhbCBpbnN0YW5jZW9mIG9iamVjdCkgXG4gICAgICB8fCB0aGlzLl9fdCA9PT0gNCAmJiAoKCF0aGlzLl9taXhlZHx8dGhpcy5fbWl4ZWQ9PT00KSB8fCB2YWwgaW5zdGFuY2VvZiBBcnJheSBcbiAgICAgICAgfHwgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCBcbiAgICAgICAgICAmJiAodmFsIGluc3RhbmNlb2Ygb2JqZWN0IHx8IHZhbC52YWwpKSkpKSB7IC8vdHJ5IHRvIG1ha2UgdGhpcyBzaG9ydGVyXG4gICAgICAgICB0aGlzLl9jaGFuZ2V2b2JqKHZhbCwgc3RhbXApXG4gICAgICAgICBpZih0aGlzLl9taXhlZD09PTQpIHRoaXMuX3ZhbCA9IG51bGxcbiAgICB9XG5cbiAgICBpZiAodmlnb3VyLkJhc2UgJiYgKHZhbCBpbnN0YW5jZW9mIHZpZ291ci5CYXNlKSkge1xuICAgICAgdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBzdGFtcClcbiAgICAgIHRoaXMuX190ID0gNVxuICAgICAgdGhpcy5fdmFsID0gdmFsXG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgIGlmICgodGhpcy5fX3QgPCAzICYmICF0aGlzLl9taXhlZCkgfHwgdGhpcy5fX3QgPT09IDEpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgZmFsc2UsIHZvaWQgMCwgc3RhbXApIC8vY2hlY2sgaWYgMm5kIHBhcmFtIHRydWUgaXMgYWJzb2x1dGVseSBuZXNzZWNhcnkgKGVsc2UgaXQgd2lsbCBiZSByZW1vdmVkKVxuICAgICAgfVxuICAgICAgdGhpcy5fdmFsID0gdmFsXG4gICAgICB0aGlzLl9fdCA9IDRcbiAgICAgIGlmICh0aGlzLl9zZXR2b2JqKSB0aGlzLl9zZXR2b2JqKHZhbClcbiAgICB9IGVsc2Uge1xuXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGVvZiB2YWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgdGhpcy5fdmFsID0gdm9pZCAwXG4gICAgICAgICAgdGhpcy5fX3QgPSAxXG4gICAgICAgICAgdGhpcy5sZW5ndGggPSB2YWwubGVuZ3RoXG4gICAgICAgICAgbm9zZXQgPSB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCB2YWwsIGZhbHNlLCBzdGFtcClcbiAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2V0KGksIHZhbFtpXSwgZmFsc2UsIHN0YW1wLCBub3VwZGF0ZSwgdHJ1ZSkgJiYgbm9zZXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIG5vc2V0ID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbm9zZXQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vbm9ybWFsIG9iamVjdFxuXG4gICAgICAgICAgaWYgKHZhbC5jbGVhcikge1xuICAgICAgICAgICAgbm9zZXQgPSB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHN0YW1wKVxuICAgICAgICAgICAgZGVsZXRlIHZhbC5jbGVhclxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5fbWl4ZWQgIT09IDEgJiYgdGhpcy5fbWl4ZWQhPT00KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBzdGFtcCkgLy9vbW1pdGluZyBzdGFtcCBjYW4gYmUgYSBwcm9ibGVtXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNBcnJheSA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbWVyZ2UgJiYgKCF0aGlzLl9taXhlZCB8fCB0aGlzLl9fdCA9PT0gMikpIHtcbiAgICAgICAgICAgICAgbm9zZXQgPSB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCB2YWwsIGZhbHNlLCBzdGFtcClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbC52YWwgJiYgdXRpbC5pc09iaih2YWwudmFsKSkge1xuICAgICAgICAgICAgdmFsSXNTZXQgPSB0cnVlXG4gICAgICAgICAgICB0aGlzLl8kc2V0VmFsKCBuZXcgdGhpcy5fY2xhc3ModmFsLnZhbCwgZmFsc2UsIHRoaXMpLCBzdGFtcCwgZnJvbSwgdHJ1ZSlcbiAgICAgICAgICAgIHRoaXMuX3ZhbC5fY29udGFpbmVkID0gdHJ1ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX21peGVkKSB7XG4gICAgICAgICAgICB0aGlzLl92YWwgPSB2b2lkIDAgLy90aGlzIG1lc3NlcyB1cCBwcm9wZXJ0eSB1cGRhdGVzISEgKHlvdXJpKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghaXNBcnJheSkgdGhpcy5fX3QgPSAyXG5cbiAgICAgICAgICBmb3IgKHZhciBqIGluIHZhbCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmNoZWNrQXJyYXkodGhpcy5fYmxhY2tsaXN0LCBqKSkge1xuICAgICAgICAgICAgICBpZiAoaiA9PT0gJ3ZhbCcpIHtcbiAgICAgICAgICAgICAgICBpZighdmFsSXNTZXQpIGlzU2V0ID0gdGhpcy5fJHNldFZhbCggdmFsLnZhbCwgc3RhbXAsIGZyb20sIHRydWUgKVxuICAgICAgICAgICAgICAgIG5lc3RlZHZhbCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy9kbyBub3QgYWx3YXlzIGlnbm9yZSB1cGRhdGVzIGF0IHRoaXMgcG9pbnRcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2V0KGosIHZhbFtqXSwgZmFsc2UsIHN0YW1wLCBub3VwZGF0ZSwgdHJ1ZSkgJiYgbm9zZXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICBub3NldCA9IHRydWVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbm9zZXQgPSBmYWxzZSAvL3RoaXMgaXMgdGhlIHBsYWNlIHdoZXJlIHNldCBpcyBwYXNzZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCh0aGlzLl9fdCA8IDMgJiYgIXRoaXMuX21peGVkKSB8fCB0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlKHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSwgc3RhbXApXG4gICAgICAgICAgaWYgKHRoaXMuX190ID09PSAxKSBkZWxldGUgdGhpcy5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09PSB0aGlzLl92YWwgJiYgIXRoaXMuX2lnbm9yZVZhbHVlICkge1xuICAgICAgICAgIC8vbWF5YmUgdXNlIHN0YW1wIGZvciBpZ25vcmVWYWx1ZSBhcyB3ZWxsP1xuICAgICAgICAgIGlmIChub3NldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRoaXMuX190ID0gM1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3ZhbCA9IHZhbFxuICAgICAgICAgIHRoaXMuX190ID0gM1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChuZXN0ZWR2YWwpIHtcblxuICAgICAgaWYgKHRoaXMuX3NldCAmJiAoaXNTZXQgIT09IGZhbHNlIHx8IG5vc2V0ID09PSBmYWxzZSkpIHtcbiAgICAgICAgdGhpcy5fc2V0KHZhbCwgc3RhbXAsIGZyb20sIGZhbHNlLCBub3VwZGF0ZSwgYWRkLCBvbGR2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zZXQpIHtcbiAgICAgIGlmICghbm9zZXQpIHtcbiAgICAgICAgdGhpcy5fc2V0KHZhbCwgc3RhbXAsIGZyb20sIGZhbHNlLCBub3VwZGF0ZSwgYWRkLCBvbGR2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZih3aW5kb3cuc211dCkgY29uc29sZS5sb2coJyExJyxhcmd1bWVudHMpXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmKHdpbmRvdy5zbXV0KSBjb25zb2xlLmxvZygnITEnLGFyZ3VtZW50cylcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG59LFxuLyoqXG4gKiBzdGFtcFxuICogcGFpbnQgdGhlIHNldCBvcmlnaW5cbiAqIEBtZXRob2RcbiAqL1xuX3N0YW1wID0gMCxcbl9wYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMsIGxpc3QpIHtcbiAgZm9yICh2YXIgaSA9IGxpc3QubGVuZ3RoIC0gMSwgcDsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAocGFyYW1zICYmIHBhcmFtc1tsaXN0W2ldXSE9PXZvaWQgMCkge1xuICAgICAgcCA9ICdfJyArIGxpc3RbaV1cbiAgICAgIHV0aWwuZGVmaW5lKHRoaXMsIHAsIHBhcmFtc1tsaXN0W2ldXSlcbiAgICB9XG4gIH1cbn1cbi8qKlxuKiBHZW5lcmF0ZXMgdW5pcXVlIHN0YW1wXG4qIEBtZXRob2Qgc3RhbXBcbiogQHJldHVybiB7TnVtYmVyfSBSZXR1cm5zIHN0YW1wXG4qL1xuZXhwb3J0cy5zdGFtcCA9IGZ1bmN0aW9uKCkge1xuLy9pZiBzdGFtcCA+IHggcmVzZXQgP1xucmV0dXJuIF9zdGFtcCsrXG59XG5cbmV4cG9ydHMuc2V0ID0gX3NldFxuXG4vLyBvYmplY3RVdGlscy5leHRlbmQoZXhwb3J0cyk7ICBcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBjb25zdHJ1Y3RvciBiYXNlZCBvbiBhIFYuT2JqZWN0XG4gKiBQYXJhbXMgY2FuIGJlIHBhc3NlZFxuICogTWl4ZWQgY3JlYXRlcyBtaXhlZCB0eXBlcyBmb3IgdGhlIG5ldyBjbGFzcyBpLmUgaGF2aW5nIGEgc3RyaW5nIGFuZCBwcm9wZXJ0aWVzXG4gKiBAbWV0aG9kIG5ld1xuICogQHBhcmFtICB7T2JqZWN0fSBwYXJhbXMgUGFyYW1ldGVyc29iamVjdFxuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgUmV0dXJucyBWLk9iamVjdFxuICovXG4vLyB3aW5kb3cuY250ID0gMFxuLy8gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbi8vICAgd2luZG93LnNtdXQgPSB0cnVlXG4vLyB9LDIwMDApXG5cbm9iamVjdC5uZXcgPSBmdW5jdGlvbihwYXJhbXMsIGNvbnN0cnVjdG9yKSB7XG4gIHZhciB2T2JqID0gZnVuY3Rpb24odmFsLCBob29rLCBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQpIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgICAgdmFyIGNvbnJlc3VsdFxuICAgICAgaWYgKGNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGNvbnJlc3VsdCA9IGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgaWYgKGhvb2sgJiYgdGhpcy5faG9vaykgdGhpcy5faG9vayh2YWwsIGhvb2spXG4gICAgICBpZiAodGhpcy5fb25Db25zdHJ1Y3QpIHRoaXMuX29uQ29uc3RydWN0KHZhbCwgaG9vaylcblxuICAgICAgaWYodmFsICE9PSB2b2lkIDAgJiYgY29ucmVzdWx0ICE9PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnZhbCA9IHZhbFxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvdG8gPSB2T2JqLnByb3RvdHlwZSA9IG5ldyB0aGlzKClcbiAgdk9iai5uZXcgPSBvYmplY3QubmV3XG4gIHZPYmouaW5qZWN0ID0gaW5qZWN0IC8vbm90IGhhbmRlbGVkIHdlbGwgeWV0XG4gIHV0aWwuZGVmaW5lKHZPYmosICdfYmxhY2tsaXN0JywgcHJvdG8uX2JsYWNrbGlzdC5jb25jYXQoKSlcbiAgX3BhcmFtcy5jYWxsKHZPYmosIHBhcmFtcywgWydtaXhlZCcsICdtZXJnZSddKVxuICB1dGlsLmRlZmluZSh2T2JqLCAnX2NsYXNzJywgdk9iailcbiAgcmV0dXJuIHZPYmpcbn1cblxudXRpbC5kZWZpbmUob2JqZWN0LFxuXG4vLyAnX3NldCwgc2V0ICwgJ1xuXG4gJ18kc2V0VmFsJywgX3NldCxcblxuLyoqXG4gKiBJdGVtcyBpbiB0aGUgYmxhY2tsaXN0IHNraXBwZWQgaW4gZWFjaCBmdW5jdGlvblxuICogQG1ldGhvZCBfYmxhY2tsaXN0XG4gKi9cbidfYmxhY2tsaXN0JywgWydfJywgJ19fJywgJ19fdCcsICdfdmFsJywgJ2xlbmd0aCcsICdfbmFtZScsICdfcGFyZW50JywgJ19jb250YWluZWQnLCAnX3JlbW92ZWQnLCdleHRlbnNpb25zJywgJ19fY2FjaGVkUGF0aCcsICdfaWdub3JlVmFsdWUnLCAnX2luZGV4Q2FjaGUnXSxcbi8qKlxuICogUmVwbGFjZXMgZGVmYXVsdCBjb25zdHJ1Y3RvciBwcm9wZXJ0eSAsbmVjZXNzYXJ5IGZvciBjbGFzc2VzIG1hZGUgd2l0aCBWLk9iamVjdC5uZXdcbiAqIEBjb25zdHJ1Y3RvciBfY2xhc3NcbiAqL1xuJ19jbGFzcycsIG9iamVjdCxcbi8qKlxuICogU3RhbXAgaXMgYSBtZXRob2Qgb2YgVk9iamVjdCBzbyB0aGF0IGl0IGNhbiBiZSBleHRlbmRlZCBpbiBzdWJjbGFzc2VzXG4gKiBAcmV0dXJuIHsqfSBhIHVuaXF1ZSBpZGVudGlmaWVyIGZvciBhIG11dGF0aW9uXG4gKi9cbidzdGFtcCcsIG9iamVjdC5zdGFtcCxcbi8qKlxuICogVXNlZCB0byBnZXQgLnZhbCB3aGljaCByZXR1cm5zIGZpZWxkIHZhbHVlcyBpLmUuIGEgc3RyaW5nXG4gKiBAbWV0aG9kIF9nZXRcbiAqIEByZXR1cm4geyp9IFJldHVybnMgdmFsdWVcbiAqL1xuJ19nZXQnLCBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gc2VsZi5fX3RcbiAgICAsIHZhbFxuXG4gIGlmICh0eXBlIDwgMykge1xuICAgIHJldHVybiBzZWxmXG4gIH0gZWxzZSB7XG4gICAgdmFsID0gc2VsZi5fdmFsXG4gICAgcmV0dXJuICh0eXBlICE9PSA0KSA/IHZhbCA6IHZhbCAmJiB2YWwuX2dldCgpXG4gIH1cbn0sXG4vKipcbiAqIFVzZWQgdG8gZ2V0IC52YWwgd2hpY2ggcmV0dXJucyBmaWVsZCB2YWx1ZXMgaS5lLiBhIHN0cmluZ1xuICogU2V0IGNyZWF0ZXMgaW5zdGFuY2VzIG9mIHRoZSBfY2xhc3MgZm9yIG5lc3RlZCBwcm9wZXJ0aWVzXG4gKiBAcHJvcGVydHlcbiAqL1xuJ3ZhbCcsIHtcbiAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyB3aW5kb3cuY250KytcbiAgICAvLyBpZih3aW5kb3cuc211dCkge1xuICAgICAgLy8gY29uc29sZS5lcnJvcih3aW5kb3cuY250LCAnd2hhdHMgaGFwcGVuaW5nJywgdGhpcy5fcGF0aCwgdGhpcy5fcHJvcCAmJiB0aGlzLl9wcm9wLm5hbWUsIHRoaXMsIHRoaXMuX3VwZGF0ZU9yaWdpbilcbiAgICAvLyB9XG4gICAgcmV0dXJuIHRoaXMuXyRzZXRWYWwodmFsKVxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoKVxuICB9XG59LFxuLyoqXG4gKiBBZGQgYSBwcm9wZXJ0eSB0byBhIG9iamVjdFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSAge1N0cmluZ30gIG5hbWUgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Kn0gICAgICAgdmFsICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbdm9ial0gICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge051bWJlcn0gIFtzdGFtcCA9IG5ldyBzdGFtcF0gW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Qm9vbGVhbn0gW25vdXBkYXRlXSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuJ3NldCcsIGZ1bmN0aW9uKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApIHtcblxuICAvL2Z1bmN0aW9uKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApIFxuXG4gIC8vIGNvbnNvbGUubG9nKG5hbWUsIHN0YW1wKVxuXG4gIGZyb20gPSBmcm9tICYmIHRoaXNcbiAgaWYgKCF2b2JqICYmICh0aGlzW25hbWVdIGluc3RhbmNlb2Ygb2JqZWN0KSkge1xuICAgIGlmICh0aGlzLl8kc2V0VmFsLmNhbGwodGhpc1tuYW1lXSwgdmFsLCBzdGFtcCwgZnJvbSwgbm91cGRhdGUpID09PSBmYWxzZSAmJiBzdGFtcCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2b2JqKSB7XG4gICAgICBpZih0aGlzW25hbWVdKSB0aGlzW25hbWVdLnJlbW92ZSgpXG4gICAgICB0aGlzW25hbWVdID0gdmFsXG4gICAgICB0aGlzW25hbWVdLl9uYW1lID0gbmFtZVxuICAgICAgdGhpc1tuYW1lXS5fcGFyZW50ID0gdGhpc1xuICAgICAgaWYoIW5vdXBkYXRlKSB2YWwuX3VwZGF0ZSh2YWwsIHN0YW1wIHx8IHRoaXMuc3RhbXAoKSwgZnJvbSwgdm9pZCAwLCB0cnVlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW25hbWVdID0gbmV3IHRoaXMuX2NsYXNzKHZvaWQgMCwgZmFsc2UsIHRoaXMpXG4gICAgICB0aGlzW25hbWVdLl9uYW1lID0gbmFtZVxuICAgICAgdGhpcy5fJHNldFZhbC5jYWxsKHRoaXNbbmFtZV0sIHZhbCwgc3RhbXAsIGZyb20sIG5vdXBkYXRlLCB0cnVlKVxuICAgIH1cbiAgICBpZiAodGhpcy5fX3QgPT09IDEgJiYgdGhpcy5fc2V0QXJyYXlJdGVtKSB7XG4gICAgICB0aGlzLl9zZXRBcnJheUl0ZW0oIHRoaXNbbmFtZV0sIHZhbCApXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59LFxuLyoqXG4gKiBSZW1vdmVzIGEgVi5PYmplY3QgaW5jbHVkaW5nIGFsbCBuZXN0ZWQgZmllbGRzIGFuZCB2YWx1ZXNcbiAqIEBtZXRob2QgcmVtb3ZlXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgW25lc3RlZF0gICAgICAgICAgICAgV2hlbiB0cnVlIHJlbW92ZSBuZXN0ZWQgb2JqZWN0c1xuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFtibF0gICAgICAgICAgICAgICAgIFdoZW4gdHJ1ZSBkb2Vzbid0IHJlbW92ZSBibGFja2xpc3RlZCBpdGVtc1xuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFtub3RdICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge0Jvb2xlYW58T2JqZWN0fSBbZnJvbV0gICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgW3N0YW1wID0gbmV3IHN0YW1wXSAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFtub3VwZGF0ZV0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbiAvLyAgICB0aGlzLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpXG5cbidyZW1vdmUnLCBmdW5jdGlvbihuZXN0ZWQsIGJsLCBub3QsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSkgeyAvL25vIHVwZGF0ZSBmaXJzdCA+IChleHRlbmRlZCBpbiBzZWxlY3Rpb24uanMpXG4gIGlmICghbmVzdGVkKSB0aGlzLl9yZW1vdmVkID0gdHJ1ZVxuICB2YXIgciwgaSwgb2xkdmFsXG4gIGlmICghc3RhbXApIHN0YW1wID0gdGhpcy5zdGFtcCgpXG4gIC8vIGNvbnNvbGUubG9nKCdTVEFSVCcsc3RhbXAsdGhpcy5fbmFtZSk7XG4gIGlmICghbmVzdGVkKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudCkge1xuICAgICAgdGhpcy5fcGFyZW50W3RoaXMuX25hbWVdID0gbnVsbFxuICAgICAgZGVsZXRlIHRoaXMuX3BhcmVudFt0aGlzLl9uYW1lXVxuICAgIH1cbiAgICBpZiAodGhpcy5fdmFsICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh0aGlzLl92YWwgaW5zdGFuY2VvZiBvYmplY3QgJiYgdGhpcy5fdmFsLl9jb250YWluZWQpIHtcbiAgICAgICAgdGhpcy5fdmFsLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmcm9tIHx8IHRoaXMsIHN0YW1wLCBub3VwZGF0ZSlcbiAgICAgIH1cbiAgICAgIG9sZHZhbCA9IHRoaXMuX3ZhbFxuICAgICAgdGhpcy5fdmFsID0gbnVsbFxuICAgIH1cbiAgfVxuICBmb3IgKGkgaW4gdGhpcykge1xuICAgIGlmICgoIW5vdCB8fCAhbm90W2ldKSAmJiAhdXRpbC5jaGVja0FycmF5KHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgIGlmICh0aGlzW2ldIGluc3RhbmNlb2Ygb2JqZWN0KSB7XG4gICAgICAgIHIgPSBmYWxzZVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnREVMRVRFJyxzdGFtcCxpLHRoaXNbaV0pO1xuICAgICAgICB0aGlzW2ldLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmcm9tIHx8IHRoaXMsIHN0YW1wLCBub3VwZGF0ZSlcbiAgICAgIH1cbiAgICAgIHRoaXNbaV0gPSBudWxsXG4gICAgICBkZWxldGUgdGhpc1tpXSAvL2RlbGV0ZSBpcyBwcmV0dHkgbmFzdHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgfVxuICB9XG4gIGlmICghbmVzdGVkKSB7XG4gICAgaWYgKHRoaXMuX3JlbW92ZSkge1xuICAgICAgLy9yXG4gICAgICB0aGlzLl9yZW1vdmUoZnJvbSwgbm91cGRhdGUgPyBmYWxzZSA6IGZyb20gLyp8fHIqLyAsIHN0YW1wLCBvbGR2YWwpO1xuICAgICAgaWYgKCFibCkge1xuICAgICAgICBmb3IgKHZhciBqIGluIHRoaXMpIHtcbiAgICAgICAgICBpZiAodGhpc1tqXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBpZiAoaiAhPT0gJ19wYXJlbnQnICYmIHRoaXNbal0gaW5zdGFuY2VvZiBvYmplY3QgJiYgdGhpc1tqXS5fY29udGFpbmVkKSB7XG4gICAgICAgICAgICAgIHRoaXNbal0ucmVtb3ZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbal0gPSBudWxsXG4gICAgICAgICAgICBkZWxldGUgdGhpc1tqXVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZW1vdmVkID0gdHJ1ZVxuICB9XG4gIHJldHVybiByXG59KVxuXG5cbi8vLS0tLXRoaXMgaGFzIHRvIGJlIGluaXRpYWxpemVkIGFmdGVyIGRlZmluaW5nIHRoZSBibGFja2xpc3QgcHJvcGVydHk7XG5leHBvcnRzLmxpc3RlbiA9IHJlcXVpcmUoJy4vbGlzdGVuJylcbnJlcXVpcmUoJy4vYXJyYXknKVxucmVxdWlyZSgnLi91dGlsJykiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIHZPYmplY3QgPSByZXF1aXJlKCcuLycpXG4gICwgViA9IHJlcXVpcmUoJy4uLycpXG4gIC8vVE9ETzogdGhpcyBpcyBhIHRlbXAgZml4IHRvIGVtdWxhdGUgb24gbmV4dCB0aWNrXG4gICwgcmFmID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicpXG4gICwgUHJvbWlzZSA9IHJlcXVpcmUoJ3Byb21pc2UnKVxuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIoIG9iaiwgZm4sIG1hcmssIG9yaWdpbmFsICkge1xuICAvL3ZhbCwgbWFyaywgc2tpcGNoZWNrLCBpZ25vcmV2YWwsIG9yZ2luYWxcbiAgaWYoIG1hcmsgKSBcbiAge1xuICAgIC8vIGNvbnNvbGUubG9nKCdoZXkgZ290IG9yZ2luYWwhJywgb3JpZ2luYWwpXG4gICAgLy9uKCB2YWwsIG1hcmssIHNraXBjaGVjaywgaWdub3JldmFsLCBvcmlnaW5hbCApXG4gICAgb2JqLmFkZExpc3RlbmVyKFsgZm4sIG1hcmsgXSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBvcmlnaW5hbCAgKVxuICB9IFxuICBlbHNlIFxuICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdoZXkgZ290IG9yZ2luYWwhJywgb3JpZ2luYWwpXG5cbiAgICBvYmouYWRkTGlzdGVuZXIoIGZuLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBvcmlnaW5hbCApXG4gIH1cbn1cblxuLypcbiAgX3VwZGF0ZSBjYWxscyBsaXN0ZW5lcnMgb24gYSBnaXZlbiBPYmplY3QgKGxpc3RlbmVycyBpbmNsdWRlIGxpbmtpbmcgZmllbGRzIGluIG90aGVyIFYuT2JqZWN0cylcbiAgVi5PYmplY3QuX3VwZGF0ZSBjYW4gYmUgbW9kaWZpZWQgdG8gY2hhbmdlIHVwZGF0ZSBiZWhhdmlvcjpcbiAgICAtIHN0YW5kYXJkOiB1cGRhdGUgT2JqZWN0IGFuZCBpdCdzIHBhcmVudHMgLyBhbmNlc3RvcnMgcmVjdXJzaXZlbHkuXG4gICAgLSBwYXJlbnRPbmx5OiB1cGRhdGUgT2JqZWN0IGFuZCBvbmx5IGl0cyBkaXJlY3QgcGFyZW50LlxuICAgIC0ganVzdCBfdXBkYXRlOiB1cGRhdGUgb25seSB0aGUgT2JqZWN0LlxuKi9cbnZhciBfdXBkYXRlID0gZXhwb3J0cy5fdXBkYXRlID0gZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCB0ZXN0KSB7XG5cbiAgLy8gaWYod2luZG93LmhlcmUpIGNvbnNvbGUubG9nKCdVUERBVEUhJyx0aGlzLl9wYXRoKVxuXG4gIHZhciBfbCA9IHRoaXMuX2xpc3RlbmVyc1xuICAgICwgaVxuICAgICwgbGlzdGVuZXJcblxuICBpZiAoX2wpIHtcbiAgICBmb3IgKGkgPSBfbC5sZW5ndGg7IGxpc3RlbmVyID0gX2xbLS1pXTspIHsgLy9vcmRlciBpcyBpcnJlbGV2YW50XG4gICAgICBpZiAobGlzdGVuZXIgaW5zdGFuY2VvZiB2T2JqZWN0KSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3VwZGF0ZT8/Pz8/JywgbGlzdGVuZXIuX3BhdGgsIHRoaXMuX3BhdGgsIGZyb20pXG5cbiAgICAgICAgLy8gaWYgKGZyb20pIHtcbiAgICAgICAgbGlzdGVuZXIuX2xmcm9tID0gZnJvbSB8fCB0aGlzXG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgIGxpc3RlbmVyLl91cGRhdGUodmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbClcblxuICAgICAgICBpZiAobGlzdGVuZXIpIGxpc3RlbmVyLl9sZnJvbSA9IG51bGxcblxuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lclswXSkge1xuICAgICAgICBpZighdGVzdCB8fCAhdGVzdChsaXN0ZW5lcikpIHtcbiAgICAgICAgICBpZiAobGlzdGVuZXIubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgZm9yICh2YXIgbCA9IGxpc3RlbmVyLmxlbmd0aCAtIDJcbiAgICAgICAgICAgICAgLCBsMiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgLCBhID0gW10sIGogPSAtMVxuICAgICAgICAgICAgICAsIGxhID0gbCArIGwyXG4gICAgICAgICAgICAgIDsgaiA8IGxhXG4gICAgICAgICAgICAgIDsgYVsrK2pdID0gaiA8IGxcbiAgICAgICAgICAgICAgICA/IGxpc3RlbmVyW2ogKyAyXVxuICAgICAgICAgICAgICAgIDogaiA9PT0gbCA/IHRoaXMgOiBhcmd1bWVudHNbaiAtIGwgLSAxXVxuICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBsaXN0ZW5lclswXS5hcHBseShsaXN0ZW5lclsxXSwgYSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXJbMF0uY2FsbChsaXN0ZW5lclsxXSwgdGhpcywgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblxuLy8gdXRpbC5kZWZpbmUodk9iamVjdCwgXG4vLyAgICdfbm9kZVBhdGhfJywgZnVuY3Rpb24oKSB7XG4vLyAgICAgaWYodGhpcy5fY2FsbGVyKSB7XG5cbi8vICAgICAgIHZhciBhcnIgPSBbXVxuLy8gICAgICAgdmFyIHAgPSB0aGlzLl9jYWxsZXJcblxuLy8gICAgICAgd2hpbGUocCkge1xuLy8gICAgICAgICBhcnIucHVzaCggcC5fbmFtZSB8fCBwLl9ub2RlICYmIHAuX25vZGUuY2xhc3NOYW1lIClcbi8vICAgICAgICAgcCA9IHAuX25vZGUgJiYgcC5wYXJlbnRcbi8vICAgICAgIH1cbi8vICAgICAgIGFyci5yZXZlcnNlKClcbi8vICAgICAgIHJldHVybiBhcnJcblxuXG4vLyAgICAgfVxuLy8gICB9XG5cbi8vIClcblxuXG52T2JqZWN0LnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ19saXN0ZW5lcnMnLCAnX2xpc3RlbnMnLCAnX2xmcm9tJywgJ19saXN0ZW5NYXAnKTtcblxudXRpbC5kZWZpbmUodk9iamVjdCxcbiAgLyoqXG4gICAqIF9zZXRcbiAgICogaXMgY2FsbGVkIHdoZW4gYSB2YWx1ZSBpcyBzZXRcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ19zZXQnLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIG5vdXBkYXRlLCBhZGRlZCwgb2xkdmFsKSB7XG4gICAgaWYgKCFub3VwZGF0ZSkge1xuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5fcGF0aCwgdmFsKVxuICAgICAgdGhpcy5fdXBkYXRlKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCk7XG4gICAgfVxuICB9LFxuXG4gICdpcycsIGZ1bmN0aW9uICh2YWwsIGNiLCBuZXh0VGljayApIHtcblxuICAgIC8vb24gcmVtb3ZhbCBvZiBwcm9taXNlIHJlbW92ZSBsaXN0ZW5lclxuXG4gICAgaWYoIWNiIHx8ICggdHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgbmV4dFRpY2sgPSBjYlxuICAgICAgLy8gY29uc29sZS5lcnJvcignbXkgbW9mbycsIG5leHRUaWNrKVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKCByZXNvbHZlLCByZWplY3QgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCczMTIxMjMxMjMyMTMnLCB2YWwpXG4gICAgICAgIF90aGlzLmlzKCB2YWwsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9LCBuZXh0VGljaylcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2xlenpnbycpXG4gICAgICB2YXIgY2J4ID0gbmV4dFRpY2sgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gICAgICAgICAgLCBfdGhpcyA9IHRoaXNcbiAgICAgICAgcmFmKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNiLmNhbGwoX3RoaXMpXG4gICAgICAgIH0pXG4gICAgICB9IDogY2JcbiAgICAgIC8vVE9ETzogYWRkIG9yaWdpbmFsIGlmIGl0cyBub3QgXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignLS0tLS0tLS0tLS0tLS0nLCB2YWwpXG5cbiAgICAgIGlmKHZhbD09PSdsb2FkZWQnKSB7XG4gICAgICAgIGlmKHRoaXMuJGxvYWRlZCB8fCB0aGlzLmZyb20uJGxvYWRlZCkge1xuICAgICAgICAgIGNieC5jYWxsKHRoaXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5vbmNlKCdsb2FkZWQnLCBjYngpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXRcbiAgICAgICAgLy8gdmFyIGlnbm9yZVxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCcxIUAjQCMhIUAjJywgcmV0LCB2YWwpXG5cbiAgICAgICAgaWYodGhpcy52YWwgPT0gdmFsICkge1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJzIhQCNAIyEhQCMnLCByZXQsIHZhbClcblxuICAgICAgICAgIHJldHVybiBjYnguY2FsbCh0aGlzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJyFAI3h4eHh4MTIxMjEyMTIxMjIxMTJAIyEhQCMnLCByZXQsIHZhbClcblxuICAgICAgICAgIHJldCA9ICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSAmJiB2YWwuY2FsbCh0aGlzKVxuICAgICAgICAgIC8vIGlnbm9yZSA9IHRydWVcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCcyMjIyMjIyMjIyIUAjQCMhIUAjJywgcmV0LCB2YWwpXG4gICAgICAgIH1cbiAgICAgICAgaWYocmV0KSB7XG4gICAgICAgICAgaWYoIHJldCBpbnN0YW5jZW9mIFByb21pc2UgKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdwcm9taXNlJylcbiAgICAgICAgICAgIHJldHVybiByZXRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJz8/Pz8hISEnKVxuICAgICAgICAgICAgcmV0dXJuIGNieC5jYWxsKHRoaXMpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJzIyMjIyIUAhQCMhQCMnLCB2YWwpXG4gICAgICAgICAgaWYodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5vbmNlKHZhbCwgY2J4KVxuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub25jZSh7XG4gICAgICAgICAgICAgICR2YWw6IHZhbFxuICAgICAgICAgICAgfSwgY2J4KVxuICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIF9fdXBkYXRlXG4gICAqIGNhbGxzIGxpc3RlbmVycyBhdHRhY2hlZCB0byB0aGUgT2JqZWN0XG4gICAqIHR5cGVzIC0tIGZ1bmN0aW9uIG9yIFYuT2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICovXG4gICdfX3VwZGF0ZScsIF91cGRhdGUsXG4gIC8qKlxuICAgKiBfdXBkYXRlXG4gICAqIGVzY2FsYXRlcyBhbiB1cGRhdGUgdXAgaXQncyBzdHJ1Y3R1cmUgYW5kIGNhbGxzIF9fdXBkYXRlIHRvIGNhbGwgbGlzdGVuZXJzXG4gICAqIHR5cGVzIC0tIGZ1bmN0aW9uIG9yIFYuT2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICovXG4gICdfdXBkYXRlJywgZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCB0ZXN0KSB7IC8vaGVyZSB5b3UgY2FuIHNlZSBpZiBpdHMgYW4gdXBkYXRlIGZyb20gYW5vdGhlciBvYmplY3QgKGZyb20pXG4gICAgLy8gY29uc29sZS5sb2coJ1YuT2JqZWN0IE9HIF91cGRhdGUnLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpXG4gICAgdmFyIGN1cnIgPSB0aGlzLFxuICAgIHMgPSB0cnVlXG5cbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgLy8gdmFyIHAgPSBjdXJyLl9wYXRoXG4gICAgICAvLyBfdXBkYXRlIFtcImNsaWVudHNcIiwgXCJWXzJweGNld3YzZzRrXCJdIFxuICAgICAgLy8gY29uc29sZS5sb2coJ191cGRhdGUnLCBwLCB2YWwsIGZyb20gfHwgKCghcyAmJiB0aGlzKSA/IHRoaXMgOiB2b2lkIDAsIHRoaXMpIClcblxuICAgICAgLy9UT0RPIDEwIGRvdWJsZSBjaGVjayB0aGlzXG4gICAgICBjdXJyLl9fdXBkYXRlKHZhbCwgc3RhbXAsIGZyb20gfHwgKHMhPT10cnVlKSA/IHRoaXMgOiBmYWxzZSAsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdGVzdClcbiAgICAgIGN1cnIgPSBmcm9tID8gZmFsc2UgOiBjdXJyLl9wYXJlbnRcbiAgICAgIHMgPSBmYWxzZVxuICAgICAgaWYgKHJlbW92ZSkgcmVtb3ZlID0gMVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIF9yZW1vdmVcbiAgICogY2FsbGVkIG9uIHJlbW92ZVxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX3JlbW92ZScsIGZ1bmN0aW9uKGZyb20sIHVwZGF0ZSwgc3RhbXAsIG9sZHZhbCkge1xuICAgIGlmICh1cGRhdGUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLl91cGRhdGUobnVsbCwgc3RhbXAsIGZyb20sIHRydWUsIGZhbHNlLCBvbGR2YWwpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCk7XG4gICAgdmFyIF9sID0gdGhpcy5fbGlzdGVucyxcbiAgICAgIGksIGxpc3RlbmVyO1xuICAgIGlmIChfbCkge1xuICAgICAgLy9vcHRpbWl6ZSBsYXRlclxuICAgICAgLy90aGlzLHRoaXMgaXMgd2VpcmQgdG8gYWx3YXlzIHVzZSB0aGlzLi4uXG4gICAgICBmb3IgKGkgPSBfbC5sZW5ndGggLSAxOyBpID49IDA7IF9sW2ktLV0ucmVtb3ZlTGlzdGVuZXIodGhpcywgdm9pZCAwLCBmYWxzZSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIF9zZXR2b2JqXG4gICAqIGlmIGEgdmFsdWUgaXMgc2V0IHRvIGEgVi5PYmplY3RcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ19zZXR2b2JqJywgZnVuY3Rpb24odmFsKSB7XG4gICAgdmFsLmFkZExpc3RlbmVyKHRoaXMpO1xuICB9LFxuICAvKipcbiAgICogX2NoYW5nZXZvYmpcbiAgICogaWYgYSB2YWx1ZSBpcyBjaGFuZ2VkIGZyb20gYSBWLk9iamVjdFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX2NoYW5nZXZvYmonLCBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAodGhpcy5fX3QgPT09IDQpIHtcbiAgICAgIHZhciBfbCA9IHRoaXMuX2xpc3RlbnMsXG4gICAgICAgIF92YWwgPSB0aGlzLl92YWwsXG4gICAgICAgIGk7XG4gICAgICBpZiAoX2wpIHtcbiAgICAgICAgZm9yIChpID0gX2wubGVuZ3RoOyBpID49IDA7IF9sWy0taV0gJiYgX2xbaV0ucmVtb3ZlTGlzdGVuZXIodGhpcywgdGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKF92YWwgaW5zdGFuY2VvZiB2T2JqZWN0ICYmIF92YWwuX2NvbnRhaW5lZCkge1xuICAgICAgICBfdmFsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIGFkZExpc3RlbmVyXG4gICAqIGFkZHMgYSBsaXN0ZW5lciB0byBhbiBvYmplY3QgY2FuIGJlIGEgZnVuY3Rpb24gb3IgVi5PYmplY3RcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ2FkZExpc3RlbmVyJywgZnVuY3Rpb24oIHZhbCwgbWFyaywgc2tpcGNoZWNrLCBpZ25vcmV2YWwsIG9yaWdpbmFsICkge1xuICAgIHZhciBfbCA9IHRoaXMuX2xpc3RlbmVycyB8fCAodGhpcy5fbGlzdGVuZXJzID0gW10pLFxuICAgICAgdGFyZ2V0LCBnO1xuXG4gICAgaWYob3JpZ2luYWwpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdPUkdJTkFMIScsIG9yaWdpbmFsKVxuICAgICAgaWYoIXRoaXMuX2xpc3Rlbk1hcCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5NYXAgPSBbXVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vbW9yZSBzcGVlZCB2b29yIGNoZWNrYXJyYXlcbiAgICBpZiAobWFyaykge1xuICAgICAgZyA9IHV0aWwuY2hlY2tBcnJheShfbCwgdmFsWzFdLCAxKTtcbiAgICAgIGlmIChnID09PSBmYWxzZVxuICAgICAgICB8fCAhaWdub3JldmFsICYmIHV0aWwuY2hlY2tBcnJheShfbCwgdmFsWzBdLCAwKSA9PT0gZmFsc2VcbiAgICAgICAgfHwgKG1hcmsgIT09IHRydWUgJiYgbWFyay5jYWxsKHRoaXMsIF9sW2ddLCBfbCwgZywgdmFsKSA9PT0gdHJ1ZSkpIHtcbiAgICAgICAgXG4gICAgICAgIC8vVE9ETzogZml4IHRoaXMgdWx0cmEgZGlydHkgc3R1ZmZcbiAgICAgICAgaWYoIG9yaWdpbmFsICYmIHZhbCAhPT0gb3JnaW5hbCApIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5NYXAucHVzaChbIG9yZ2luYWwsIHZhbCBdKVxuICAgICAgICB9XG5cbiAgICAgICAgX2wucHVzaCh2YWwpO1xuICAgICAgfSBlbHNlICB7XG4gICAgICAgICByZXR1cm4gX2xbZ107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdmFsLl9fdCB8fCAhdXRpbC5jaGVja0FycmF5KF9sLCB2YWwpKSB7XG5cbiAgICAgIGlmKCBvcmlnaW5hbCAmJiB2YWwgIT09IG9yaWdpbmFsICkge1xuICAgICAgICB0aGlzLl9saXN0ZW5NYXAucHVzaChbIG9yaWdpbmFsLCB2YWwgXSlcbiAgICAgIH1cblxuICAgICAgX2wucHVzaCh2YWwpO1xuICAgIH1cbiAgICBpZiAobWFyayB8fCB2YWwgaW5zdGFuY2VvZiB2T2JqZWN0KSB7XG4gICAgICB0YXJnZXQgPSBtYXJrID8gdmFsWzFdIDogdmFsO1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIHZPYmplY3QpIHtcbiAgICAgICAgX2xpID0gdGFyZ2V0Ll9saXN0ZW5zIHx8ICh0YXJnZXQuX2xpc3RlbnMgPSBbXSk7XG4gICAgICAgIGlmIChza2lwY2hlY2sgfHwgIXV0aWwuY2hlY2tBcnJheShfbGksIHRoaXMpKSB7XG5cbiAgICAgICAgICBpZiggb3JpZ2luYWwgJiYgdmFsICE9PSBvcmlnaW5hbCApIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3Rlbk1hcC5wdXNoKFsgb3JpZ2luYWwsIHZhbCBdKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF9saS5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAgJ29uY2UnLCBmdW5jdGlvbiggdmFsLCBtZXRob2QsIG1hcmsgKSB7XG5cbiAgICAvL3ZhbCwgbWFyaywgc2tpcGNoZWNrLCBpZ25vcmV2YWwsIG9yZ2luYWxcblxuICAgIC8vVE9ETzp1bmlmeSAvdyBvblxuICAgIHZhciBtdmFsXG5cbiAgICB2YXIgbGlzdGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICBcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoIG12YWwsIG1hcmsgKVxuICAgICAgLy8gdGhpcy5yZW1vdmVMaXN0ZW5lciggbGlzdGVuIClcblxuICAgICAgbXZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgIC8vb3JpZ2luYWwgcGVyaGFwcz8/Pz9cbiAgICB9XG5cbiAgICBpZiggbWV0aG9kICkge1xuICAgICAgbXZhbCA9IG1ldGhvZFxuICAgICAgdGhpcy5vbiggdmFsLCBsaXN0ZW4sIGZhbHNlLCBtdmFsICkgLy9kZXplIGZuIG1vZXQgd2VsIGdlcmVtb3ZlZCB3b3JkZW4gZ2ViZXVyZCBudSBuaWV0IVxuICAgIH0gZWxzZSB7XG4gICAgICBtdmFsID0gdmFsXG4gICAgICB0aGlzLm9uKCBsaXN0ZW4sIGZhbHNlLCBmYWxzZSwgbXZhbCApXG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXNcblxuICB9LFxuICAnb24nLCBmdW5jdGlvbiggdmFsLCBtZXRob2QsIG1hcmssIG9yaWdpbmFsICkge1xuICAgICAgLyoqXG4gICAgICAgICogdmFsIGNhbiBiZSBhIGNvbmRpdGlvbiBvciBhIGNvbXBhcmlzb24gb3IgYSBtZXRob2RcbiAgICAgICoqL1xuICAgICAgaWYoIFYuQmFzZSAmJiBtZXRob2QgaW5zdGFuY2VvZiBWLkJhc2UgKSBcbiAgICAgIHtcbiAgICAgICAgbWFyayA9IG1ldGhvZCAvL21ha2UgZXhjZXB0aW9uIGZvciB2YWx1ZXMhXG4gICAgICAgIG1ldGhvZCA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYoIW9yaWdpbmFsKSB7XG4gICAgICAgIG9yaWdpbmFsID0gbWV0aG9kXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0IG9yaWdpbmFsIScsIG9yaWdpbmFsLCBtZXRob2QgKVxuICAgICAgfVxuXG4gICAgICBpZiggIW1ldGhvZCApIFxuICAgICAge1xuICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIHZhbCwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgfVxuICAgICAgZWxzZSBcbiAgICAgIHtcbiAgICAgICAgaWYoIHV0aWwuaXNPYmooIHZhbCApIClcbiAgICAgICAge1xuICAgICAgICAgIC8vIGNvbnNvbGUud2FybigndGhpcyB3aWxsIGJlY29tZSBhIGNvbmRpdGlvbiBsYXRlciBvbiBmb3Igbm93IGl0cyBub3Qgc3VwcG9ydGVkISwgY29uZGl0aW9ucyB3aWxsIGJlIHVzZWQgZXZleXJ3aGVyZScpXG4gICAgICAgICAgLy9IYXMgdG8gYmVjb21lIGEgY29uZGl0aW9uXG4gICAgICAgICAgaWYodmFsLiR2YWwpIHtcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwgKSB7XG4gICAgICAgICAgICAgIGlmKCB0aGlzLnZhbCA9PT0gdmFsLiR2YWwgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0aGlzIHdpbGwgYmVjb21lIGEgY29uZGl0aW9uIGxhdGVyIG9uIGZvciBub3cgaXRzIG5vdCBzdXBwb3J0ZWQhLCBjb25kaXRpb25zIHdpbGwgYmUgdXNlZCBldmV5cndoZXJlJylcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9IYXMgdG8gYmVjb21lIGEgY29uZGl0aW9uXG5cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgKVxuICAgICAgICB7XG4gICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCApIHtcbiAgICAgICAgICAgIGlmKCB2YWwuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApICkgLy9tb3JlIGNoZWNrc1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgXG4gICAgICAgIHtcblxuICAgICAgICAgIGlmKCB1dGlsLmlzT2JqKCBtZXRob2QgKSApXG4gICAgICAgICAge1xuXG4gICAgICAgICAgICBtYXJrID0gdmFsXG5cbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndW50ZXN0ZWQgLS0gYWRkIGFzIG1hcmsnKVxuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApIHtcbiAgICAgICAgICAgICAgaWYoIHJlbW92ZSApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuXG5cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiggdmFsID09PSAncmVtb3ZlJyApXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy92YWwsIHN0YW1wLCBmYWxzZSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsXG4gICAgICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIGZ1bmN0aW9uKCBudmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsICkge1xuICAgICAgICAgICAgICBpZiggcmVtb3ZlICkgLy9tb3JlIGNoZWNrc1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vVE9ETzogaW4gcmVkbyB0aGlzIHdpbGwgYmUgZG9uZSBkaWZmZXJlbnRseSAoZXZlbnQgdHlwZXMgYXJlIHNwZWNpYWwgZG9uZSlcbiAgICAgICAgICBlbHNlIGlmKCB2YWwgPT09ICdsb2FkZWQnICkge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGFkZGVkICkgLy93ZXJrdCBuaWV0ITtcbiAgICAgICAgICAgICAgLy9fX2Zyb21tZXRob2RcblxuICAgICAgICAgICAgICBpZiggdGhpcy4kbG9hZGVkIHx8IHRoaXMuZnJvbS4kbG9hZGVkICkgLy9tb3JlIGNoZWNrc1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIHZhbCA9PT0gJ2FkZGVkJyApXG4gICAgICAgICAge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGFkZGVkICkgLy93ZXJrdCBuaWV0ITtcbiAgICAgICAgICAgICAgaWYoIGFkZGVkICkgLy9tb3JlIGNoZWNrc1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIHZhbCA9PT0gJ3NlbGYnIClcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIGZ1bmN0aW9uKCBudmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsICkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggYWRkZWQgKSAvL3dlcmt0IG5pZXQhO1xuXG4gICAgICAgICAgICAgIC8vVE9ETzogcHV0IG9uIGluIGEgZGlmZmVyZW50IGZpbGVcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1NIT1VMRCBETyBTRUxGIScsIGFyZ3VtZW50cywgZnJvbSApIC8vem8gd3JvbmchXG5cbiAgICAgICAgICAgICAgaWYoIHRoaXMuX3ZhbCA9PT0gbnZhbCBcbiAgICAgICAgICAgICAgfHwgIXZhbCAmJiB0aGlzLl91cGRhdGVPcmlnaW49PT10aGlzIC8vcHJldHR5IHNsb3cgY2hlY2sgLCBpdHMgdGhlcmUgdG8gY2hlY2sgd2hlbiBzb21lb25lIGNhbGwgLnVwZGF0ZSBmb3IgZXhhbXBsZVxuICAgICAgICAgICAgICApIFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIGZ1bmN0aW9uKCBudmFsICkge1xuICAgICAgICAgICAgICBpZiggbnZhbCA9PT0gdmFsIHx8IHRoaXMudmFsID09PSB2YWwgfHwgdGhpcy5fdmFsID09PSB2YWwgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICAvKipcbiAgICogcmVtb3ZlTGlzdGVuZXJcbiAgICogaWYgbm8gdmFsIHJlbW92ZXMgYWxsIGxpc3RlbmVyc1xuICAgKiBtYXJrIGNoZWNrcyBpbiBhcnJheSBvbiBwb3NpdGlvbiAxIGZvciB1bmlxdWVuZXNzXG4gICAqIHJlbW92ZSBpcyB1c2VkIGluIGNvbWJpbmF0aW9uIHdpdGggbWFya1xuICAgKiBAbWV0aG9kXG4gICAqL1xuICAncmVtb3ZlTGlzdGVuZXInLCBmdW5jdGlvbih2YWwsIG1hcmssIHJlbW92ZSwgbm9icmVhaykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmVMaXN0ZW5lciEnLCB0aGlzLl9wYXRoLCB0aGlzLl9saXN0ZW5lcnMgJiYgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aFxuICAgIC8vICAgLCAnXFxubWFyazpcXG4nLCBtYXJrICYmIG1hcmsucmF3XG4gICAgLy8gICAsICdcXG52YWw6XFxuJywgdmFsICYmIHZhbC5uYW1lXG4gICAgLy8gICAsICdcXG52YWw6XFxuJywgdmFsXG4gICAgLy8gKVxuICAgIHZhciBfbCA9IHRoaXMuX2xpc3RlbmVycyxcbiAgICAgIGk7XG4gICAgaWYgKF9sKSB7XG4gICAgICBmb3IgKGkgPSBfbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAvL21heWJlIGNoZWNraW5nIG1hcmsgYWxsIHRoZSB0aW1lIGlzIHRvbyBzbG93P1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBfbFtpXVxuICAgICAgICBpZiAoXG4gICAgICAgICAgKCFtYXJrICYmICF2YWwpXG4gICAgICAgICAgfHwgKHZhbCAmJiBsaXN0ZW5lciA9PT0gdmFsKSAvL2ZhbHNlIHZvb3IgbWFya1xuICAgICAgICAgIHx8IChtYXJrIT09ZmFsc2UgJiYgKChsaXN0ZW5lciBpbnN0YW5jZW9mIEFycmF5KSAmJiAoKG1hcmsgJiYgbGlzdGVuZXJbMV0gPT09IG1hcmsgJiYgKCF2YWx8fGxpc3RlbmVyWzBdPT09dmFsKSkgfHwgdmFsICYmIGxpc3RlbmVyWzFdID09PSB2YWwpKVxuICAgICAgICAgICAgJiYgKCFyZW1vdmVcbiAgICAgICAgICAgICAgfHwgKHJlbW92ZSA9PT0gdHJ1ZSAgLy9kaXQgbW9ldCBsYXRlciB3ZWcgaXMgZGFuIGFsbGVlbiBlZW4gZnVuY3RpZSBpcyBudSBvdmVyYm9kaWcgKGNoZWNrIGJvdmVuKVxuICAgICAgICAgICAgICAgID8gbGlzdGVuZXJbMF0gPT09IHZhbFxuICAgICAgICAgICAgICAgIDogcmVtb3ZlLmNhbGwodGhpcywgbGlzdGVuZXIsIG1hcmspKSkpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtYXJrLl9saXN0ZW5zPycsICEhKG1hcmsgJiYgbWFyay5fbGlzdGVucylcbiAgICAgICAgICAvLyAgICAgLCAnXFxuaXMgdk9iamVjdD8nLCBsaXN0ZW5lciBpbnN0YW5jZW9mIHZPYmplY3RcbiAgICAgICAgICAvLyAgICAgLCAnXFxuaXMgbWFya2VkPycsIGxpc3RlbmVyIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAvLyAgIClcbiAgICAgICAgICB2YXIgZm9jdXMgPSBtYXJrXG4gICAgICAgICAgICA/IG1hcmtcbiAgICAgICAgICAgIDogbGlzdGVuZXIgaW5zdGFuY2VvZiB2T2JqZWN0XG4gICAgICAgICAgICAgID8gbGlzdGVuZXJcbiAgICAgICAgICAgICAgOiBsaXN0ZW5lciBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgICAgICAgPyBsaXN0ZW5lclsxXVxuICAgICAgICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgICB2YXIgbGlzdGVucyA9IGZvY3VzICYmIGZvY3VzLl9saXN0ZW5zXG4gICAgICAgICAgaWYobGlzdGVucyl7XG4gICAgICAgICAgICBmb3IodmFyIGogPSBsaXN0ZW5zLmxlbmd0aC0xIDsgaiA+PSAwIDsgai0tKXtcbiAgICAgICAgICAgICAgaWYobGlzdGVuc1tqXSA9PT0gdGhpcyl7XG4gICAgICAgICAgICAgICAgbGlzdGVucy5zcGxpY2UoaiwgMSlcbiAgICAgICAgICAgICAgICBpZihsaXN0ZW5zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgIGZvY3VzLl9saXN0ZW5zID0gbnVsbFxuICAgICAgICAgICAgICAgIGlmKGZvY3VzLl9fdCA9PT0gNCAmJiBsaXN0ZW5lci5fdmFsID09PSB0aGlzKVxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuX3ZhbCA9IHZvaWQgMFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX2wuc3BsaWNlKGksIDEpXG4gICAgICAgICAgaWYgKF9sLmxlbmd0aCA9PT0gMCkgdGhpcy5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICAgICAgICBpZiAodmFsICYmICFub2JyZWFrKSBicmVha1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vVE9ETzogdGhpcyBoYXMgdG8gYmUgcmVmYWN0b3JlZCBBU0FQISBkbyB3aGVuIG5ldyBkZXNpZ24gcGhhc2UgZm9yIHZvYmplY3QrYmFzZSBpcyBnb2luZyBkb3duXG4gICAgICBpZiggdGhpcy5fbGlzdGVuTWFwICYmIHZhbCApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2ltIGhlcmUhJywgdmFsKVxuICAgICAgICB2YXIgcGl2XG4gICAgICAgIGZvcih2YXIgaSA9IDAsIF9sZW4gPSB0aGlzLl9saXN0ZW5NYXAubGVuZ3RoOyBpIDwgX2xlbjsgaSsrICkge1xuICAgICAgICAgIGlmKCB0aGlzLl9saXN0ZW5NYXBbaV1bMF0gPT09IHZhbCApIHtcbiAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaGV5IGl0cyB0aGUgbGlzdGVubWFwIScsIHZhbClcbiAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCB0aGlzLl9saXN0ZW5NYXBbaV1bMV0gKVxuICAgICAgICAgICAgIHBpdiA9IGlcbiAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYoIHBpdiAhPT0gdm9pZCAwICkge1xuICAgICAgICAgIHRoaXMuX2xpc3Rlbk1hcC5zcGxpY2UocGl2LCAxKVxuICAgICAgICAgIGlmKHRoaXMuX2xpc3Rlbk1hcC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3Rlbk1hcCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB9XG4gIH0pOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBWT2JqZWN0ID0gcmVxdWlyZSgnLi8nKSxcbiAgViA9IHJlcXVpcmUoJy4uLycpXG4gIF9jID0gdXRpbC5jaGVja0FycmF5XG5cbi8qKlxuICogR2V0cy9zZXRzIFZPYmplY3Qgb3JpZ2luXG4gKiBJbiBhIGNoYWluIG9mIFYuT2JqZWN0cyBlLmcuIHgudmFsID0geSwgeS52YWwgPSB6IC0tLT4geC5mcm9tIHJldHVybnMgejtcbiAqIEBtZXRob2QgZnJvbVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmogW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7T2JqZWN0fSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG52YXIgX2NvcmVTZXQgPSBWT2JqZWN0LnNldCxcbiAgX2Zyb20gPSB0aGlzLmZyb20gPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdmFsID0gb2JqLFxuICAgICAgbGFzdDtcblxuICAgIHdoaWxlICh2YWwgaW5zdGFuY2VvZiBWT2JqZWN0KSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh2YWwpXG4gICAgICBpZih2YWwuX2ZpbHRlcikge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdJUyBTRUxFQ0lUT04nLCB2YWwpXG4gICAgICB9XG4gICAgICBsYXN0ID0gdmFsO1xuICAgICAgdmFsID0gdmFsLl92YWw7XG4gICAgfVxuICAgIHJldHVybiBsYXN0ICE9PSBvYmogPyBsYXN0IDogZmFsc2U7XG4gIH0sXG4gIF9sYXN0TEZyb20gPSBmdW5jdGlvbihvYmopIHtcbiAgICB3aGlsZSAob2JqICYmIG9iai5fX3QgPT09IDQpIHtcbiAgICAgIGlmIChvYmouX2xmcm9tKSB7XG4gICAgICAgIHJldHVybiBvYmouX2xmcm9tO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqID0gb2JqLl92YWw7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBwYXRoXG4gICAqIEBtZXRob2QgX3VwZGF0ZVBhdGhcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICB0aWxsIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgIFJldHVybnMgcGF0aFxuICAgKi9cbiAgX3VwZGF0ZVBhdGggPSBmdW5jdGlvbih0aWxsLCBzdGFydCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLFxuICAgICAgbGZyb20sXG4gICAgICBwYXRoID0gW107IC8vcmVkdWNlIGFtb3VudCBvZiBuZXcgYXJyYXlzXG4gICAgd2hpbGUgKHBhcmVudCAmJiAocGFyZW50Ll9uYW1lICE9PSB2b2lkIDAgfHwgc3RhcnQpKSB7XG4gICAgICBsZnJvbSA9IHBhcmVudC5fbGZyb20gfHwgX2xhc3RMRnJvbShwYXJlbnQpXG4gICAgICBpZiAobGZyb20pIHtcbiAgICAgICAgdmFyIGEgPSBfdXBkYXRlUGF0aC5jYWxsKGxmcm9tKSxcbiAgICAgICAgICBjID0gcGFyZW50LmZyb20uX25hbWU7XG4gICAgICAgIHV0aWwuYWRkKGEsIHBhdGgpO1xuICAgICAgICBwYXRoID0gYTtcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICBjID0gYS5pbmRleE9mKGMpO1xuICAgICAgICAgIGEuc3BsaWNlKGMsIGEubGVuZ3RoIC0gYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnQgIT09IHRpbGwpIHtcbiAgICAgICAgcGF0aC5wdXNoKHBhcmVudC5fbmFtZSk7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLT4nLHBhdGgpXG4gICAgcmV0dXJuIHRpbGwgPyBwYXRoLnJldmVyc2UoKSA6IHBhdGg7XG4gIH1cblxudXRpbC5kZWZpbmUoVk9iamVjdCxcbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGxpbmtlZCBjb250YWluZXJzLCB1c2VzIHNsaWNlIG9uIGFycmF5c1xuICAgKiBSZW1vdmVzIGFsbCBfbGlzdGVuZXJzXG4gICAqIEBtZXRob2QgZGVzdHJveVxuICAgKi9cbiAgICd0b1N0cmluZycsIGZ1bmN0aW9uKCBjb21wcmVzc2VkICkge1xuICAgICAgcmV0dXJuIGNvbXByZXNzZWQgXG4gICAgICAgICAgICAgPyBKU09OLnN0cmluZ2lmeSggdGhpcy5yYXcgKSBcbiAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KCB0aGlzLnJhdywgZmFsc2UsIDIgKVxuICAgfSxcbiAgICdyZWZlcmVuY2VMZXZlbCcsIGZ1bmN0aW9uKGxpbmtlZCkge1xuICAgICAgdmFyIGxpbmsgPSB0aGlzXG4gICAgICB2YXIgY250ID0gMFxuXG4gICAgICAvLyBjb25zb2xlLmxvZyhsaW5rLCBsaW5rLl9fdClcblxuICAgICAgd2hpbGUobGluayAmJiBsaW5rLl9fdCkge1xuICAgICAgICBpZihsaW5rPT09bGlua2VkKSB7XG4gICAgICAgICAgcmV0dXJuIGNudFxuICAgICAgICB9XG4gICAgICAgIGxpbmsgPSBsaW5rLl92YWxcbiAgICAgICAgY250KytcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgfSxcbiAgJ2Rlc3Ryb3knLCBmdW5jdGlvbihuZXN0ZWQsIGJsLCBub3QsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSkge1xuICAgIGlmKCFzdGFtcClcbiAgICAgIHN0YW1wID0gdGhpcy5zdGFtcCgpXG5cbiAgICB0aGlzLl9yZW1vdmVkID0gdHJ1ZVxuICAgIHRoaXMuZGVzdHJveVJlZmVyZW5jZXMobmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpXG4gICAgdGhpcy5yZW1vdmUobmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpXG4gIH0sXG4gICdkZXN0cm95UmVmZXJlbmNlcycsIGZ1bmN0aW9uKG5lc3RlZCwgYmwsIG5vdCwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKSB7XG4gICAgaWYoIXN0YW1wKVxuICAgICAgc3RhbXAgPSB0aGlzLnN0YW1wKClcblxuICAgIHZhciBfbCA9IHRoaXMuX2xpc3RlbmVyc1xuICAgICAgLCBwYXJlbnRcbiAgICAgIC8vICwgaXRlbVxuICAgIGlmIChfbCkge1xuICAgICAgZm9yICh2YXIgaSA9IF9sLmxlbmd0aCwgcmVmOyByZWYgPSBfbFstLWldOykge1xuICAgICAgICAvLyBpZihsaXN0ZW5lciBpbnN0YW5jZW9mIEFycmF5KXtcbiAgICAgICAgLy8gICBpZihsaXN0ZW5lcilcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyByZWYgPSAgaW5zdGFuY2VvZiBBcnJheSA/IF9sW2ldWzFdIDogX2xbaV07XG4gICAgICAgIGlmIChyZWYgaW5zdGFuY2VvZiBWT2JqZWN0KSB7XG4gICAgICAgICAgcGFyZW50ID0gcmVmLl9wYXJlbnQ7XG4gICAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQuX190ID09PSAxKSB7XG4gICAgICAgICAgICBwYXJlbnQuc3BsaWNlKHJlZi5fbmFtZSwgMSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlZi5yZW1vdmUobmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFBlcmZvcm1zIHBhc3NlZCBmdW5jdGlvbiBvbiBlYWNoIGl0ZW0uXG4gICAqIFNraXBzIGl0ZW1zIGluIHRoZSBibGFja2xpc3QuXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICBmbiAgIGZ1bmN0aW9uIHRvIHBlcmZvcm0gb24gZWFjaFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgIGRlZXAgSWYgdHJ1ZSwgcmVwZWF0cyBlYWNobWV0aG9kIG9uIG5lc3RlZCBmaWVsZHNcbiAgICogQHBhcmFtICB7QXJndW1lbnRzfSBhcmcgIEFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBmdW5jdGlvblxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2VhY2gnLCBmdW5jdGlvbihmbiwgZGVlcCwgYXJnKSB7XG4gICAgLy90cnkgdG8gbWFrZSB0aGlzIGEgbG90IHNob3J0ZXJcbiAgICB2YXIgaSwgaXRlbTtcbiAgICBpZiAoYXJnICE9PSB2b2lkIDApIHtcbiAgICAgIGFyZyA9IHV0aWwuYXJnKGFyZ3VtZW50cywgMik7XG4gICAgICBmb3IgKGkgaW4gdGhpcykge1xuICAgICAgICBpZiAoIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgICBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICBpZiAoZm4uYXBwbHkoaXRlbSwgYXJnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWVwICYmIChpdGVtLl9fdCAhPT0gNCB8fCBpdGVtLl9jb250YWluZWQpKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5lYWNoLmFwcGx5KGl0ZW0sIGFyZykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghX2ModGhpcy5fYmxhY2tsaXN0LCBpKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgIGlmIChmbi5jYWxsKGl0ZW0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZXAgJiYgKGl0ZW0uX190ICE9PSA0IHx8IGl0ZW0uX2NvbnRhaW5lZCkpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmVhY2goZm4sIGRlZXAsIGFyZykpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVhbCBwYXRoXG4gICAqIEBhdHRyaWJ1dGUgX3BhdGhcbiAgICovXG4gICAgJ19wYXRoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXNcbiAgICAgICAgICAsIHBhdGggPSBbXVxuXG4gICAgICAgIHdoaWxlIChwYXJlbnQgJiYgcGFyZW50Ll9uYW1lICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBwYXRoLnB1c2gocGFyZW50Ll9uYW1lKTtcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwYXRoLnJldmVyc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgICdfY2FjaGVkUGF0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fY2FjaGVkUGF0aCB8fCAodGhpcy5fX2NhY2hlZFBhdGggPSB0aGlzLl9wYXRoLmpvaW4oJy4nKSlcbiAgICAgIH1cbiAgICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdXBkYXRlIHBhdGhcbiAgICogQGF0dHJpYnV0ZSB1cGRhdGVQYXRoXG4gICAqL1xuICAndXBkYXRlUGF0aCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGEgPSBfdXBkYXRlUGF0aC5jYWxsKHRoaXMsIHRoaXMsIHRydWUpLFxuICAgICAgICBuYW1lID0gdGhpcy5fbmFtZTtcbiAgICAgIG5hbWUgIT09IHZvaWQgMCAmJiBhLnVuc2hpZnQobmFtZSk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXlzIG9mIGFuIG9iamVjdFxuICAgKiBAYXR0cmlidXRlIGtleXNcbiAgICovXG4gICdrZXlzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaSwgYXJyID0gW107XG4gICAgICBmb3IgKGkgaW4gdGhpcykge1xuICAgICAgICBpZiAoIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgICBhcnIucHVzaChpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIEFuY2VzdG9yXG4gICAqIGFsc28gcmV0dXJuIHRydWUgd2hlbiBvYmplY3QgaXMgb2JqZWN0IHRvIGJlIGNvbXBhcmVkIHRvXG4gICAqIEBhdHRyaWJ1dGUga2V5c1xuICAgKi9cbiAgLy90Ll9kID09PSBmcm9tLl9wYXJlbnQgfHwgdC5fZCA9PT0gZnJvbVxuICAnX2FuY2VzdG9yJywgZnVuY3Rpb24ob2JqKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ0FOQ0VTVE9SJy5yZWQuaW52ZXJzZSwgb2JqLCB0aGlzKVxuICAgIHZhciBwID0gdGhpc1xuICAgIHdoaWxlIChwKSB7XG4gICAgICBpZiAob2JqID09PSBwKSByZXR1cm4gdHJ1ZVxuICAgICAgcCA9IHAuX3BhcmVudFxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEdldCBhIGZpZWxkIGF0IGZpcnN0IG9jY3VyZW5jZSBpbiB0aGUgcGFyZW50IGNoYWluXG4gICAqIEBtZXRob2QgY2hlY2tQYXJlbnRcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgZmllbGQgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBnZXQgICBXaGVuIHRydWUgcmV0dXJucyBmb3VuZCBpbnN0ZWFkIG9mIGN1cnJlbnRcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2NoZWNrUGFyZW50JywgdXRpbC5jaGVja1BhcmVudEZhY3RvcnkoJ19wYXJlbnQnKSxcbiAgLyoqXG4gICAqIFJldHVybnMgYSBub3JtYWwgb2JqZWN0LCBhbmQga2VlcHMgbGlua3MgdG8gVi5PYmplY3RzXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7Kn0gICAgICBbdmFsXSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2NvbnZlcnQnLCBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgb2JqID0ge30sIGwgPSAwXG4gICAgaWYgKCF2YWwgfHwgdmFsLnZhbCkgb2JqLnZhbCA9IHRoaXMuX3ZhbFxuICAgIGlmICh0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgb2JqID0gW11cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsKytcbiAgICAgICAgb2JqW2ldID0gdGhpc1tpXS5jb252ZXJ0KClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgaWYgKCF2YWwgfHwgdmFsW2ldIT09dm9pZCAwKSB7XG4gICAgICAgICAgbCsrXG4gICAgICAgICAgb2JqW2ldID0gdGhpcy5jb252ZXJ0KClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKHZhbCkge1xuICAgICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgICAgaWYgKG9ialtpXSA9PT0gdm9pZCAwKSBvYmpbaV0gPSB2b2lkIDBcbiAgICAgICAgbCsrXG4gICAgICB9XG4gICAgfVxuICAgIGlmICghbCAmJiAoIXZhbCB8fCB2YWwudmFsKSkgb2JqID0gb2JqLnZhbFxuICAgIHJldHVybiBvYmpcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgYSBub3JtYWwgb2JqZWN0XG4gICAqIEBhdHRyaWJ1dGUgcmF3XG4gICAqL1xuICAncmF3Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgIHR5cGUgPSBzZWxmLl9maWx0ZXIgPyAyIDogc2VsZi5fX3QsXG4gICAgICAgIG9iaiwgaSwgbDtcbiAgICAgIGlmICh0eXBlID09PSA0KSB7XG4gICAgICAgIHJldHVybiBzZWxmLl92YWwgJiYgc2VsZi5fdmFsLnJhdztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICByZXR1cm4gc2VsZi52YWw7IC8vd2hlbiB0aGUgdHlwZSBpcyBtaXhlZCBhbHdheXMgdXNlcyB2YWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlID09PSAxKSB7XG4gICAgICAgICAgb2JqID0gW107XG4gICAgICAgICAgZm9yIChpID0gLTEsIGwgPSBzZWxmLmxlbmd0aCAtIDE7IGkgPCBsOyBzZWxmWysraV0gJiYgb2JqLnB1c2goc2VsZltpXS5yYXcpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICBmb3IgKGkgaW4gc2VsZikge1xuICAgICAgICAgICAgaWYgKCFfYyhzZWxmLl9ibGFja2xpc3QsIGkpICYmIHNlbGZbaV0pIHtcbiAgICAgICAgICAgICAgb2JqW2ldID0gc2VsZltpXS5yYXc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogR2V0cy9zZXRzIG9iamVjdCBvcmlnaW5cbiAgICogSW4gYSBjaGFpbiBvZiBWLk9iamVjdHMgZS5nLiB4LnZhbCA9IHksIHkudmFsID0geiAtLS0+IHguZnJvbSByZXR1cm5zIHo7XG4gICAqIEBhdHRyaWJ1dGUgZnJvbVxuICAgKi9cbiAgJ2Zyb20nLCB7XG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBmb3VuZCA9IF9mcm9tKHRoaXMpXG4gICAgICBfY29yZVNldC5jYWxsKGZvdW5kIHx8IHRoaXMsIHZhbClcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2Zyb20odGhpcykgfHwgdGhpc1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIE1lcmdlIGFueSBvYmplY3QgaW50byBhbm90aGVyIG9iamVjdFxuICAgKiBTaGFsbG93IGZvciBhIHNoYWxsb3cgbWVyZ2VcbiAgICogQG1ldGhvZCBtZXJnZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IHNoYWxsb3cgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7TnVtYmVyfSAgc3RhbXAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBub3VwZGF0ZSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdtZXJnZScsIGZ1bmN0aW9uIG1lcmdlKCBvYmosIHNoYWxsb3csIHN0YW1wLCBub3VwZGF0ZSwgYmxvY2ssIHNvcnRlZCwgZGVmZXJVcGRhdGVzICkge1xuXG4gICAgLy8gY29uc29sZS5sb2coJ01FUkdFLS0tLT4nLCBvYmogKVxuXG4gICAgdmFyIG1lcmdlQXJyYXkgPSB0aGlzLl9tZXJnZUFycmF5XG4gICAgICAsIHJcbiAgICAgICwgaVxuICAgICAgLCBzdG9wXG4gICAgICAsIHJ0XG4gICAgICAsIGNvYmpcbiAgICAgICwgdG9ialxuICAgICAgLCB0b3BMZXZlbFxuXG4gICAgaWYoIWRlZmVyVXBkYXRlcykge1xuICAgICAgLy8gY29uc29sZS5sb2coJ05PIGRlZmVyVXBkYXRlcycueWVsbG93LmludmVyc2UpXG4gICAgICB0b3BMZXZlbCA9IHRydWVcbiAgICAgIGRlZmVyVXBkYXRlcyA9IFtdXG4gICAgfVxuICAgIC8vRklYTUU6IG1ha2UgaXQgYmV0dGVyIGxvbmcgbmFtZXMgZXRjLCBjb2RlIGZvcm1hdHRpbmdcblxuICAgIGlmICggIXN0YW1wICkgc3RhbXAgPSB0aGlzLnN0YW1wKClcblxuICAgIGlmICggdGhpcy5fX3QgPT09IDEgKSB7XG4gICAgICBpZiAobWVyZ2VBcnJheSkge1xuICAgICAgICBtZXJnZUFycmF5KCBvYmosIHN0YW1wLCBub3VwZGF0ZSApIC8vaGllciBtb2V0IG9vayBmZiBkZWZlclVwZGF0ZXNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gb2JqKSB7XG4gICAgICAgICAgY29iaiA9IG9ialtqXVxuICAgICAgICAgIHRvYmogPSB0aGlzW2pdXG4gICAgICAgICAgaWYgKChqID0gTnVtYmVyKGopKSA+IC0xKSB7XG4gICAgICAgICAgICByID0gdHJ1ZVxuICAgICAgICAgICAgaWYgKHRvYmopIHtcbiAgICAgICAgICAgICAgdG9iai5tZXJnZShjb2JqLCBmYWxzZSwgc3RhbXAsIHRydWUsIGJsb2NrLCBzb3J0ZWQsIGRlZmVyVXBkYXRlcyApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaiA+IHRoaXMubGVuZ3RoIC0gMSkgdGhpcy5sZW5ndGggPSBqICsgMVxuICAgICAgICAgICAgICB0aGlzLnNldChqLCBjb2JqLCBmYWxzZSwgc3RhbXAsIHRydWUsIHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgc3RvcCA9IHRydWVcbiAgICAgICAgY29iaiA9IG9ialtpXVxuICAgICAgICB0b2JqID0gdGhpc1tpXVxuICAgICAgICBpZiAoaSAhPT0gJ3ZhbCcgJiYgIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgICBpZiAoIXNoYWxsb3cgJiYgdG9iaiAmJiB1dGlsLmlzT2JqKGNvYmopKSB7IC8vY29iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAodHlwZW9mIGNvYmogIT09ICdmdW5jdGlvbicpICYmIGNvYmouX190ICE9PSAzKVxuICAgICAgICAgICAgaWYgKGNvYmouY2xlYXIpIHtcbiAgICAgICAgICAgICAgX2NvcmVTZXQuY2FsbCh0b2JqLCBjb2JqLCBzdGFtcCwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgICAgIHIgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJy0tLS0gbWVyZ2UgL3cgdXBkYXRlIHRoYXRzIG1vcyBkZWYgd3JvbmchJywgaSwgZGVmZXJVcGRhdGVzKVxuICAgICAgICAgICAgICAvL2RlZmVyVXBkYXRlc1xuXG4gICAgICAgICAgICAgIHJ0ID0gdG9iai5tZXJnZShjb2JqLCBmYWxzZSwgc3RhbXAsIHRydWUsIGJsb2NrLCBzb3J0ZWQsIGRlZmVyVXBkYXRlcyApXG4gICAgICAgICAgICAgIGlmIChyICE9PSB0cnVlKSByID0gcnRcblxuICAgICAgICAgICAgICBpZiAoIXJ0KSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcwMDAwJylcbiAgICAgICAgICAgICAgICBvYmpbaV0gPSB2b2lkIDBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIGlmICh0b2JqICYmIHRvYmouX3ZhbCA9PT0gY29iaikgeyAvL2NoYW5nZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIDAgYW5kIGZhbHNlLCBub3cgYWxzbyBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIDEgYW5kICcxJ1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tIDIgdXBkYXRlIHRoYXRzIG1vcyBkZWYgd3JvbmchJywgaSlcblxuICAgICAgICAgICAgICBpZiAociAhPT0gdHJ1ZSkgciA9IGZhbHNlXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/Pz8/JylcbiAgICAgICAgICAgICAgb2JqW2ldID0gdm9pZCAwXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLSAzIHVwZGF0ZSB0aGF0cyBtb3MgZGVmIHdyb25nIScsIGkpXG4gICAgICAgICAgICAgIGlmKGNvYmo9PT1udWxsICYmIHRoaXNbaV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldLnJlbW92ZSggZmFsc2UsIGZhbHNlLCBmYWxzZSwgdm9pZCAwLCBzdGFtcCApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyE/Jy5ib2xkLCBpLCB0aGlzW2ldKVxuICAgICAgICAgICAgICAgIC8vbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb21cbiAgICAgICAgICAgICAgICB0aGlzLnNldCggaSwgY29iaiwgZmFsc2UsIHN0YW1wLCB0cnVlIClcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnIXh4eHg/JywgaSlcbiAgICAgICAgICAgICAgICBpZih0aGlzW2ldICYmIHRoaXNbaV0uX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3B1c2ggcHVzaCcuZ3JlZW4sICBKU09OLnN0cmluZ2lmeShvYmopIClcbiAgICAgICAgICAgICAgICAgIGRlZmVyVXBkYXRlcy5wdXNoKCBbdGhpc1tpXSwgY29ial0gKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL2FkZCBkaXQgbmFhciBsaXN0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFyKSByID0gcnQ7XG5cbiAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKHIsIHJ0KVxuXG4gICAgICAgICAgICAgIGlmICghcnQpIFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy9UT0RPOiBURU1QIEZJWCBET05UIEtOT1cgSUYgVEhJUyBXT1JLUyFcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnPz8/Pz8/PzIyMjIyJylcbiAgICAgICAgICAgICAgICAvLyBvYmpbaV0gPSB2b2lkIDBcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ2NhbnQgYmUgcmlnaHQhJylcbiAgICAgICAgICAgICAgICAvL1NVUEVSIENBUkVGVUxMIFdJVEggVEhJUyBSIFRISU5HISEhISFcbiAgICAgICAgICAgICAgICByID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAob2JqLnZhbCkge1xuICAgICAgICBydCA9IF9jb3JlU2V0LmNhbGwodGhpcywgb2JqLnZhbCwgc3RhbXAsIGZhbHNlLCB0cnVlKVxuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICByID0gcnRcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJ0KSB7XG4gICAgICAgICAgb2JqLnZhbCA9IHZvaWQgMFxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdG9wKSB7XG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgIHIgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgciA9IChyICE9PSBmYWxzZSkgfHwgclxuICAgIH1cblxuICAgIGlmIChyKSB7XG4gICAgICBpZiAoIWJsb2NrKSB7XG4gICAgICAgIC8vIGFsZXJ0KG5vdXBkYXRlKVxuICAgICAgICBpZiAobm91cGRhdGUpIHtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCchIT8/Pz8/Pz8/Pz8/IE5PVVBEQVRFJy5ibHVlLCBKU09OLnN0cmluZ2lmeShvYmopKVxuXG4gICAgICAgICAgaWYodG9wTGV2ZWwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdVUERBVEU+PycubWFnZW50YS5pbnZlcnNlLCBvYmosIEpTT04uc3RyaW5naWZ5KCBvYmogKSwgbm91cGRhdGUsIHN0YW1wKVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKG9iaiwgc3RhbXApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3VwZGF0ZShvYmosIHN0YW1wKVxuICAgICAgICAgICAgZGVmZXJVcGRhdGVzLnB1c2goWyB0aGlzLCBvYmogXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJzJVUERBVEU+PycuY3lhbi5pbnZlcnNlLCB0b3BMZXZlbCwgZGVmZXJVcGRhdGVzLCBvYmosIG5vdXBkYXRlLCBzdGFtcClcblxuICAgICAgICAgIHRoaXMuX3VwZGF0ZSggb2JqLCBzdGFtcCApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICBcblxuICAgIGlmKHRvcExldmVsICYmIGRlZmVyVXBkYXRlcykge1xuICAgICAgLy8gY29uc29sZS5sb2coICdkZWZlcmVkIHVwZGFjZScsIHRvcExldmVsLCBkZWZlclVwZGF0ZXMpXG4gICAgICBmb3IodmFyIGRmIGluIGRlZmVyVXBkYXRlcykge1xuICAgICAgICBpZiggZGVmZXJVcGRhdGVzW2RmXVswXSAmJiBkZWZlclVwZGF0ZXNbZGZdWzBdLl9fdXBkYXRlICkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdERUZFUkVEISEhIScuY3lhbi5pbnZlcnNlLCBkZiwgZGVmZXJVcGRhdGVzW2RmXVsxXSwgc3RhbXAgKVxuICAgICAgICAgIGRlZmVyVXBkYXRlc1tkZl1bMF0uX191cGRhdGUoIGRlZmVyVXBkYXRlc1tkZl1bMV0sIHN0YW1wIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gclxuICB9LFxuICAvKipcbiAgICogQ29waWVzIGFuIG9iamVjdCBhbmQgcmV0dXJucyBhIG5ldyBvbmUsIGNhbiBhbHNvIHBhc3MgYSBtZXJnZSBvYmplY3RcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBvYmogICAgICAgT2JqZWN0IHRvIGNvcHlcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgW3NoYWxsb3ddIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSAgW2xpc3RdICAgIFRha2VzIGFueSBvYmplY3Qgd2l0aCAubGVuZ3RoXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIFtwYXJlbnRdICBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnY2xvbmUnLCBmdW5jdGlvbihvYmosIHNoYWxsb3csIGxpc3QsIHBhcmVudCkgeyAvL3N1cHBvcnQgc2hhbGxvdyE7IGNoZWNrIG9iaiBjb3B5IG9ubHkgd2hhdCBpcyBuZXNzZWNhcnkgYWRkZWQgbWFrZXNob3J0ICwgbWFkZSBwYXJlbnQgc2hvcnRlclxuICAgIHZhciBjb3B5ID0gbmV3IHRoaXMuX2NsYXNzKCksXG4gICAgICBfdmFsID0gdGhpcy5fdmFsLFxuICAgICAgaTtcbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBjb3B5Ll9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIGNvcHkuX190ID0gdGhpcy5fX3Q7XG4gICAgaWYgKHRoaXMuX190ID09PSAxKSB7XG4gICAgICBjb3B5Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobGlzdCkge1xuICAgICAgLy9saXN0XG4gICAgICBmb3IgKHZhciBqID0gbGlzdC5sZW5ndGggLSAxLCBpdGVtOyBqID49IDA7IGotLSkge1xuICAgICAgICBpdGVtID0gbGlzdFtqXTtcblxuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEFycmF5ICYmIHRoaXNbaXRlbVswXV0pIHtcbiAgICAgICAgICBpZihpdGVtWzFdID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb3B5W2l0ZW1bMF1dID0gdXRpbC5jbG9uZSh0aGlzW2l0ZW1bMF1dLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29weVtpdGVtWzBdXSA9IGl0ZW1bMV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbaXRlbV0pIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpdGVtKVxuICAgICAgICAgIGNvcHlbaXRlbV0gPSB0aGlzW2l0ZW1dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfdmFsICYmIChfdmFsIGluc3RhbmNlb2YgVk9iamVjdCAmJiBfdmFsLl9jb250YWluZWQpKSB7XG4gICAgICBjb3B5LnZhbCA9IF92YWwuY2xvbmUoY29weSwgZmFsc2UsIGxpc3QsIGNvcHkpO1xuICAgICAgY29weS5fdmFsLl9jb250YWluZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBWT2JqZWN0LnNldC5jYWxsKGNvcHksIF92YWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGZvciAoaSBpbiB0aGlzKSB7XG4gICAgICBpZiAoIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coaSlcbiAgICAgICAgaWYgKCFzaGFsbG93KSB7XG4gICAgICAgICAgaWYgKHRoaXNbaV0gaW5zdGFuY2VvZiBWT2JqZWN0KSB7XG4gICAgICAgICAgICAvL2Z1bmN0aW9uKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApXG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLT4xJywgaSwgdGhpc1tpXS5jbG9uZSh2b2lkIDAsIGZhbHNlLCBsaXN0LCBjb3B5KSlcbiAgICAgICAgICAgIC8vc3RhbXAgdm9pZCAwXG4gICAgICAgICAgICBjb3B5LnNldChpLCB0aGlzW2ldLmNsb25lKHZvaWQgMCwgZmFsc2UsIGxpc3QsIGNvcHkpLCB0cnVlLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0+MicsIGksIHV0aWwuY2xvbmUodGhpc1tpXSkpXG5cbiAgICAgICAgICAgIGNvcHlbaV0gPSB1dGlsLmNsb25lKHRoaXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2Z1bmN0aW9uKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApXG4gICAgICAgICAgY29weS5zZXQoaSwgdGhpc1tpXSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob2JqICE9PSB2b2lkIDApIHtcbiAgICAgIGlmICh1dGlsLmlzT2JqKG9iaikpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ01FUkdFLS0tLS0+Jywgb2JqLCBzaGFsbG93KVxuICAgICAgICBjb3B5Lm1lcmdlKG9iaiwgc2hhbGxvdyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBWT2JqZWN0LnNldC5jYWxsKGNvcHksIG9iaiwgZmFsc2UsIGZhbHNlLCB0cnVlKVxuICAgICAgfVxuICAgIH1cbiAgICBjb3B5Ll9fdCA9IHRoaXMuX190O1xuICAgIHJldHVybiBjb3B5O1xuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBvYmplY3Qgb24gdGhlIGVuZCBvZiBhIGRlZmluZWQgcGF0aFxuICAgKiBAbWV0aG9kIHBhdGhcbiAgICogQHBhcmFtICB7QXJyYXl9ICAgICBwYXRoICAgICAgICAgICBBcnJheSBvZiBmaWVsZHMgaW4gcGF0aFxuICAgKiBAcGFyYW0gIHsqfSAgICAgICAgIFt2YWxdICAgICAgICAgIFdoZW4gZGVmaW5lZCwgdmFsIHdpbGwgYmUgc2V0IG9uIGVuZHBvaW50IG9mIHBhdGggaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgIFtvdmVyd3JpdGVdICAgIElmIHRydWUsIHZhbCBXSUxMIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZSBvbiBlbmRwb2ludCBvZiBwYXRoIHdoZW4gYWxyZWFkeSBkZWZpbmVkXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgW3dyaXRlSGFuZGxlcl0gQ2FsbGJhY2sgb24gd3JpdGVcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgb24gdGhlIGVuZCBvZiBhIGRlZmluZWQgcGF0aFxuICAgKi9cbiAgJ3BhdGgnLCBmdW5jdGlvbihwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYpIHtcbiAgICBpZighKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHBhdGggPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIHV0aWwucGF0aCh0aGlzLCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYpO1xuICB9LFxuICAvKipcbiAgICogR2V0cyBvYmplY3QgZnJvbSBzcGVjaWZpZWQgcGF0aC4gV2hlbiBwYXRoIGlzIGEgc3RyaW5nIGNoZWNrcyBmb3IgJ2RvdG5vdGF0aW9uJy5cbiAgICogQG1ldGhvZCBnZXRcbiAgICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBwYXRoIERlZmluZXMgZmllbGQge3N0cmluZ30gb3IgcGF0aCB7YXJyYXl8J2RvdC1ub3RhdGlvbid9XG4gICAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgICBvYmpbcGF0aF18bmVzdGVkIG9iamVjdC92YWx1ZVxuICAgKi9cbiAgJ2dldCcsIGZ1bmN0aW9uKHBhdGgsIHNlbGYpIHsgLy9nZXQgZG9lcyBub3QgbmVlZCBhbiBhcnJheSBhcyBwYXRoXG4gICAgcmV0dXJuIHV0aWwuZ2V0KHRoaXMsIHBhdGgsIHNlbGYpO1xuICB9LFxuXG4gIC8vKHZhbCwgc3RhbXAsIGZyb20sIG5vdXBkYXRlLCBhZGQpXG4gIC8vICckc2V0JywgZnVuY3Rpb24oIHZhbCwgc3RhbXAsIGZyb20sIHVwZGF0ZSApIHsgLy9nZXQgZG9lcyBub3QgbmVlZCBhbiBhcnJheSBhcyBwYXRoXG5cbiAgLy8gICByZXR1cm4gVk9iamVjdC5zZXQuY2FsbCggdGhpcywgdmFsLCBzdGFtcCwgZnJvbSwgIXVwZGF0ZSApXG4gICAgXG4gIC8vICAgICAnX3NldCcsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgbm91cGRhdGUsIGFkZGVkLCBvbGR2YWwpIHtcbiAgLy8gICBpZiAoIW5vdXBkYXRlKSB7XG4gIC8vICAgICAodmFsLCBzdGFtcCwgZnJvbSwgbm91cGRhdGUsIGFkZClcbiAgLy8gICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuX3BhdGgsIHZhbClcbiAgLy8gICAgIHRoaXMuX3VwZGF0ZSh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpO1xuICAvLyAgIH1cbiAgICBcblxuICAvLyB9LFxuICAvKipcbiAgICogQ2hlY2sgaWYgb2JqIGlzIGVtcHR5IGV4Y2x1ZGUgZmllbGQgbmFtZXMgcGFzc2VkIHRvIGxpc3RcbiAgICogQG1ldGhvZCBlbXB0eVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlL2ZhbHNlXG4gICAqL1xuICAnZW1wdHknLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB1dGlsLmVtcHR5KHRoaXMsIHRoaXMuX2JsYWNrbGlzdCk7XG4gICAgfVxuICB9LFxuICAnJGVtcHR5JywgZnVuY3Rpb24oIGV4Y2x1ZGVzLCB1cGRhdGUgKSB7XG4gICAgICAvL2dldCBkb2VzIG5vdCBuZWVkIGFuIGFycmF5IGFzIHBhdGhcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgIHRoaXMuZWFjaCggZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgaWYoIFxuICAgICAgICAgICAgIWV4Y2x1ZGVzIFxuICAgICAgICAgICAgICB8fCB0eXBlb2YgZXhjbHVkZXMgPT09ICdzdHJpbmcnICBcbiAgICAgICAgICAgICAgICAgPyBrZXkgIT09IGV4Y2x1ZGVzIFxuICAgICAgICAgICAgICAgICA6ICF1dGlsLmNoZWNrQXJyYXkoIGV4Y2x1ZGVzLCBrZXkgKSBcbiAgICAgICAgICApXG4gICAgICAgIHtcbiAgICAgICAgICBpZiggdGhpcy5yZW1vdmUgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZSggZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlIClcbiAgICAgICAgICB9IFxuICAgICAgICAgIGVsc2UgXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCAnJGVtcHR5IG5vbi12T2JqZWN0IG9iamVjdC51dGlsIHJlbW92ZScsIHRoaXMsIGtleSApXG4gICAgICAgICAgICBfdGhpc1trZXldID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICBcbiAgICAgIGlmKCB0aGlzLmNsZWFyQ2FjaGUgKSB0aGlzLmNsZWFyQ2FjaGUoKVxuXG4gICAgICBpZiggdXBkYXRlIClcbiAgICAgIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCdlbXB0eScpXG4gICAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBWLk9iamVjdCBmcm9tIHdoaWNoIHRoZSBjdXJyZW50IHVwZGF0ZSBvcmlnaW5hdGVkLlxuICAgKiBAbWV0aG9kIF91cGRhdGVPcmlnaW5cbiAgICogQHJldHVybiB7Vi5PYmplY3R9IG9yaWdpbiBvZiB0aGUgdXBkYXRlXG4gICAqL1xuICAnX3VwZGF0ZU9yaWdpbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmsgPSB0aGlzO1xuICAgICAgLy8gY29uc29sZS5lcnJvcignZ2V0IFVQREFURSBPUklHSU4nLCB0aGlzLl9wYXRoLCB0aGlzLl9sZnJvbSlcbiAgICAgIHdoaWxlIChtYXJrLl9sZnJvbSkge1xuXG4gICAgICAgIC8vaWYgVi5DbG91ZERhdGFcbiAgICAgICAvLyBjb25zb2xlLmVycm9yKCAnX3VwZGF0ZSB0aGF0IG9yaWdpbiEnLCBtYXJrLl9wYXRoIClcbiAgICAgICAgbWFyayA9IG1hcmsuX2xmcm9tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcms7XG4gICAgfVxuICB9LFxuICAnX29yaWdpbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG1hcmsgPSB0aGlzO1xuICAgICAgd2hpbGUgKG1hcmsgJiYgbWFyay5fX3QgPT09IDQpIHtcbiAgICAgICAgbWFyayA9IG1hcmsuX3ZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXJrO1xuICAgIH1cbiAgfVxuKVxuXG5cbi8vYWRkIGZpbmRcblxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8nKVxuICAsIGFqYXhcbiAgLCBQQUNLQUdFID0gJy9wYWNrYWdlLmpzb24nXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uKCBjYWxsYmFjaywgcGFyYW1zLCBwYWNrYWdlRmlsZSwgbm9SZXBsYWNlICkge1xuXG4gIHBhY2thZ2VGaWxlID0gcGFja2FnZUZpbGUgfHwgKCB1dGlsLmlzTm9kZSA/IHt9IDogd2luZG93LnBhY2thZ2UgKVxuXG4gIHZhciBvYmogPSB7fVxuICAgICwgcmVxID0gbW9kdWxlLmV4cG9ydHNcbiAgICAsIGNiID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24oIHBja2cgKSB7XG5cbiAgICAgIG9iaiA9IHBja2cudmlnb3VyXG4gICAgICByZXEucGFyc2UoIG9iaiwgcGFja2FnZUZpbGUsIHJlcS5fY2hlY2tzIClcblxuICAgICAgaWYoIW5vUmVwbGFjZSkgbW9kdWxlLmV4cG9ydHMgPSBvYmpcbiAgICAgIGNhbGxiYWNrKG9iailcbiAgICB9XG5cbiAgLy9kZWZhdWx0IG9wdGlvbiBhZGQgbW9yZSFcbiAgaWYoIXBhcmFtcykge1xuICAgIGV4cG9ydHMub3B0aW9ucy52YWwob2JqLCBjYiwgZmFsc2UsIHBhY2thZ2VGaWxlIClcbiAgfSBlbHNlIGlmKGV4cG9ydHMub3B0aW9uc1twYXJhbXNdKSB7XG4gICAgZXhwb3J0cy5vcHRpb25zW3BhcmFtc10ob2JqLCBjYiwgZmFsc2UsIHBhY2thZ2VGaWxlIClcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLm9wdGlvbnMudmFsKG9iaiwgY2IsIHBhcmFtcywgcGFja2FnZUZpbGUgKVxuICB9XG4gIHJldHVybiBvYmpcbn1cblxuaWYodXRpbC5pc05vZGUpIHtcbiAgZXhwb3J0cy5vcHRpb25zID0ge1xuICAgIHZhbDpmdW5jdGlvbiggb2JqLCBjYWxsYmFjaywgcGFyYW1zLCBwY2tnICkge1xuICAgICAgY2FsbGJhY2soIHBja2cgKVxuICAgIH1cbiAgfVxufSBlbHNlIHtcbiAgYWpheCA9IHJlcXVpcmUoICcuLi8uLi9icm93c2VyL25ldHdvcmsvYWpheCcgKVxuICBleHBvcnRzLm9wdGlvbnMgPSB7XG4gICAgdmFsOmZ1bmN0aW9uKG9iaiwgY2FsbGJhY2ssIHBhcmFtcykge1xuICAgICAgaWYoICF3aW5kb3cucGFja2FnZSApIHtcbiAgICAgICAgdmFyIGRvbWFpbiA9ICF3aW5kb3cuY29yZG92YSAmJiBTdHJpbmcod2luZG93LmxvY2F0aW9uKVxuICAgICAgICAgICAgLm1hdGNoKC9odHRwcz86XFwvXFwvKFteXFwvXSspLylcblxuICAgICAgICBpZihkb21haW4pIGRvbWFpbiA9IGRvbWFpblswXVxuICAgICAgICAgXG4gICAgICAgIGFqYXgoe1xuICAgICAgICAgIHVybDpwYXJhbXMgJiYgcGFyYW1zLnVybCA/IHBhcmFtcy51cmwgOiBkb21haW4rUEFDS0FHRSxcbiAgICAgICAgICBmYWxsYmFjazogW1xuICAgICAgICAgICAgICB7IHVybDogUEFDS0FHRSB9IC8vZm9yIHRlc3RpbmdcbiAgICAgICAgICAgICwgcGFyYW1zICYmIHBhcmFtcy5mYWxsYmFjayA/IHBhcmFtcy5mYWxsYmFjayA6IHsgdXJsOiBfX2Rpcm5hbWUrUEFDS0FHRSB9XG4gICAgICAgICAgICAsIHsgdXJsOiAnLi4vJytQQUNLQUdFIH1cbiAgICAgICAgICAgICwgeyB1cmw6ICcuLi8uLi8nK1BBQ0tBR0UgfVxuICAgICAgICAgICAgLCB7IHVybDogJy4uLy4uLy4uLycrUEFDS0FHRSB9XG4gICAgICAgICAgXSxcbiAgICAgICAgICBjb21wbGV0ZTpmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB3aW5kb3cucGFja2FnZSA9IGRhdGFcbiAgICAgICAgICAgIGlmKGNhbGxiYWNrKSBjYWxsYmFjayhkYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZihjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayh3aW5kb3cucGFja2FnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5pbmplY3QgPSBmdW5jdGlvbigpIHtcbiAgZXhwb3J0cy5fY2hlY2tzID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICByZXR1cm4gZXhwb3J0c1xufVxuXG5leHBvcnRzLmxvb3AgPSBmdW5jdGlvbihvYmosIG9wdGlvbiwgcGNrZ3ZhbCwgbWVyZ2UsIGZuLCBwYXJhbXMgKSB7XG4gIGlmKGZuKSB7XG4gICAgdmFyIHZhbCA9IG9wdGlvbihvYmoscGNrZ3ZhbCxtZXJnZSwgcGFyYW1zKVxuICAgIGlmKHZhbCkgeyB1dGlsLm1lcmdlKG9iaix2YWwpIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IodmFyIGggaW4gb2JqW29wdGlvbl0pIHtcbiAgICAgIGlmKChwY2tndmFsPT09aCkpIHtcbiAgICAgICAgdXRpbC5tZXJnZShvYmosbWVyZ2VbaF0pXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiggb2JqLCBwY2tnLCBvcHRpb25zLCBwYXJhbXMgKSB7XG4gaWYoIShvcHRpb25zIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgb3B0aW9ucyA9IFtvcHRpb25zXVxuIH1cblxuIGZvcih2YXIgaSBpbiBvcHRpb25zKSB7XG4gICAgZm9yKHZhciBjaGVjayBpbiBvcHRpb25zW2ldKSB7XG4gICAgICB2YXIgcGNrZ3ZhbCA9IHV0aWwuZ2V0KHBja2csY2hlY2spXG4gICAgICAgICwgb3B0aW9uID0gb3B0aW9uc1tpXVtjaGVja11cblxuICAgICAgZXhwb3J0cy5sb29wKG9iaiwgb3B0aW9uLCBwY2tndmFsLCBvYmpbb3B0aW9uc1tpXVtjaGVja11dLCB0eXBlb2Ygb3B0aW9uID09PSAnZnVuY3Rpb24nLHBhcmFtcylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9ialxufVxuIiwidmFyIHVhID0gcmVxdWlyZSgnLi4vLi4vYnJvd3Nlci91YScpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLycpXG4gICwgRGF0YSA9IHJlcXVpcmUoJy4uLy4uL2RhdGEnKS5pbmplY3QocmVxdWlyZSgnLi4vLi4vZGF0YS9zZWxlY3Rpb24nKSlcbi8qXG5zZWxlY3Rpb24hXG5cbiovXG5ibGEgPSBleHBvcnRzXG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihvYmosIHBja2d2YWwsIG1lcmdlLCBwYXJhbXMpIHtcbiAgdmFyIF91YSA9IHVhXG5cbiAgaWYocGFyYW1zICYmIHBhcmFtcy51YSkge1xuICAgIF91YSA9IHVhLnBhcnNlKHBhcmFtcy51YS50b0xvd2VyQ2FzZSgpLHt9KVxuICB9XG5cbiAgLy8gY29uc29sZS5sb2coJ0hFUkUhJyxvYmoscGNrZ3ZhbCxtZXJnZSlcbiAgdmFyIGNvbmRcbiAgICAsIHVhY2xvbmUgPSBuZXcgRGF0YSh7YmxhOnV0aWwuY2xvbmUoX3VhKX0pXG5cbiAgaWYob2JqLnVhKSB7XG4gICAgZm9yKHZhciBpIGluIG9iai51YSkge1xuICAgICAgaWYoX3VhLnBsYXRmb3JtPT09aXx8X3VhLmRldmljZT09PWl8fF91YS5icm93c2VyPT09aSkge1xuICAgICAgICByZXR1cm4gb2JqLnVhW2ldXG4gICAgICB9IGVsc2UgaWYob2JqLnVhW2ldLmNvbmRpdGlvbikge1xuICAgICAgICBpZighY29uZCkge1xuICAgICAgICAgIGNvbmQgPSBuZXcgRGF0YSh1YWNsb25lLCBvYmoudWFbaV0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uZC5maWx0ZXIgPSBvYmoudWFbaV1cbiAgICAgICAgfVxuICAgICAgICBpZihjb25kLmxlbmd0aCkge1xuICAgICAgICAgIGRlbGV0ZSBvYmoudWFbaV0uY29uZGl0aW9uXG4gICAgICAgICAgY29uZC5yZW1vdmUoKVxuICAgICAgICAgIHJldHVybiBvYmoudWFbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLy9ibGFibGFcblxuICAvLyBjb25zb2xlLmxvZygnU1VCT0JKPz8/JyxvYmopXG5cblxuICBkZWxldGUgb2JqLnN1YnNPYmpcblxuICBpZihjb25kKSBjb25kLnJlbW92ZSgpXG59XG5cbiIsInZhciBkZWJ1ZyA9IGV4cG9ydHNcblxuREVCVUckID0gZGVidWdcblxuLypcbiAgY29uc29sZS5sb2coJ3V0aWwvdGVzdCBcXG5cXG5pZiB5b3Ugd2FudCB0byBjaGVjayBtZW1vcnkgdXNhZ2Ugc3RhcnQgY2hyb21lIHVzaW5nOiBcXG5cXG4gb3BlbiAtYSBHb29nbGVcXFxcIENocm9tZSAtLWFyZ3MgLS1lbmFibGUtbWVtb3J5LWluZm8gXFxuJylcbiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLycpXG4gICwgaXNOb2RlID0gdXRpbC5pc05vZGUgLy9oYXMgdG8gYmVjb21lIHBhcnQgb2YgdXRpbFxuICAsIFYgPSByZXF1aXJlKCcuLi8uLi8nKVxuICAsIGxvZyA9IGRlYnVnLmxvZyA9IHJlcXVpcmUoJy4vbG9nJylcbiAgLCBkZWJ1Z2xvZyA9IGxvZy5sb2dnZXIoJ0RFQlVHJCcsICdyYWluYm93JylcblxuZGVidWcucGVyZiA9IGRlYnVnLnBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmlmKCFpc05vZGUpIHtcbiAgZGVidWcuY2FzZXMgPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL2Nhc2VzLycpXG4gIGV4cG9ydHMuYm9keSA9IGRvY3VtZW50LmJvZHkuYmFzZVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdkb21haW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vZGVidWdnZXIgLS0tIGNhbiBnbyBhd2F5IHdpdGggYSB0cmFuc2Zvcm1cbiAgICAgIHJldHVybiBTdHJpbmcod2luZG93LmxvY2F0aW9uKVxuICAgICAgICAubWF0Y2goL2h0dHBzPzpcXC9cXC8oW15cXC9dKykvKVsxXVxuICAgICAgICAucmVwbGFjZSgvOi4rLywgJycpXG4gICAgfVxuICB9KVxuXG59IGVsc2Uge1xuICB2YXIgREVCVUcgPSBwcm9jZXNzLmVudi5ERUJVR1xuICBpZihERUJVRyl7XG4gICAgdmFyIGxldmVscyA9IERFQlVHLnNwbGl0KCcsJylcbiAgICBmb3IodmFyIGwgaW4gbGV2ZWxzKXtcbiAgICAgIHZhciB0d28gPSBsZXZlbHNbbF0uc3BsaXQoJzonKVxuICAgICAgREVCVUckLmxldmVsW3R3b1swXV0gPSB0d29bMV0gPyBOdW1iZXIodHdvWzFdKSA6IDNcbiAgICB9XG4gIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuZXhwb3J0cy5pbnQgPSBmdW5jdGlvbihyYW5kLCBmbikge1xuICBmdW5jdGlvbiBmdW5jKCkge1xuICAgIHJhbmQgPSByYW5kfHwxMDAwXG4gICAgcmV0dXJuIH5+KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSpyYW5kKSlcbiAgfVxuICByZXR1cm4gZm4gPyBmdW5jKCkgOiBmdW5jXG59XG5cbmV4cG9ydHMudGV4dCA9IGZ1bmN0aW9uIChsZW5ndGgsIGZuLCBzdHIsIG5vbGluZXMsIHN0cmljdCkge1xuICBpZiAoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy50ZXh0KFxuICAgICAgICBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBsZW5ndGgpICsgMSwgZmFsc2UsIHN0ciwgbm9saW5lcywgc3RyaWN0XG4gICAgICApXG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHZhciBzID0gWycuJywgJy4nLCAnLicsICc7JywgJywnXVxuICAgICAgLCBiID0gWydhYicsICdhYmxlJywgJ3pvJywgJ3gnLCAnbGF4JywgJ2J1cicsICdyZW0nLCAnbHVyJywgJ2Z1cicsICdqdXInLCAnbGV4JywgJ3JleCcsICd3dXJkJyxcbiAgICAgICAgJ3NodXInLCAnYnVybicsICdoZXBzJywgJ2EnLCAnaScsICd5JywgJ3UnLCAnZScsICdwJywgJ2wnLCAnc3BsdXJmJ11cbiAgICAgICwgb3V0cHV0ID0gJydcbiAgICAgICwgbm9zcGFjZSA9IDBcblxuICAgIGlmIChzdHIpIGIgPSBzdHJcblxuICAgIHN0ciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBiW01hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIChiLmxlbmd0aCAtIDEpKV1cbiAgICB9XG4gICAgaWYgKCFsZW5ndGgpIGxlbmd0aCA9IH5+IChNYXRoLnJhbmRvbSgpICogMTAxKVxuICAgIGZvciAodmFyIGkgPSAwLCBnOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICggIXN0cmljdCAmJiAoIW91dHB1dFtvdXRwdXQubGVuZ3RoIC0gMV1cbiAgICAgICAgfHwgb3V0cHV0W291dHB1dC5sZW5ndGggLSAyXSA9PT0gJy4nXG4gICAgICAgIHx8IG91dHB1dFtvdXRwdXQubGVuZ3RoIC0gMl0gPT09ICdcXG4nKVxuICAgICAgKSB7XG4gICAgICAgIGcgPSBzdHIoKVxuICAgICAgICBvdXRwdXQgKz0gZ1swXS50b1VwcGVyQ2FzZSgpICsgZy5zbGljZSgxKVxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIG91dHB1dCArPSBzdHIoKVxuICAgICAgfVxuICAgICAgbm9zcGFjZSsrXG4gICAgICBpZiAoIXN0cmljdCAmJiB+fihNYXRoLnJhbmRvbSgpICogKG5vc3BhY2UgLyAyKSkpIHtcbiAgICAgICAgdmFyIGJyID0gZmFsc2VcbiAgICAgICAgICAsIHZcbiAgICAgICAgaWYgKCFub2xpbmVzICYmIH5+KE1hdGgucmFuZG9tKCkgKiAyMSkgPiAxNykge1xuICAgICAgICAgIHYgPSBzW35+KE1hdGgucmFuZG9tKCkgKiAocy5sZW5ndGggLSAxKSldXG4gICAgICAgICAgb3V0cHV0ICs9IHZcbiAgICAgICAgICBpZiAodiA9PT0gJy4nICYmIH5+KE1hdGgucmFuZG9tKCkgKiAxMSkgPiA2KSB7XG4gICAgICAgICAgICBiciA9IHRydWVcbiAgICAgICAgICAgIG91dHB1dCArPSAnXFxuJ1xuICAgICAgICAgICAgaWYgKH5+KE1hdGgucmFuZG9tKCkgKiAxMSkgPiA3KSBvdXRwdXQgKz0gJ1xcbic7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYnIpIG91dHB1dCArPSAnICdcbiAgICAgICAgbm9zcGFjZSA9IDBcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dFxuICB9XG59XG5cbmV4cG9ydHMuZGF0YSA9IGZ1bmN0aW9uIChwb3B1bGF0ZSwgbGV2ZWwsIG9iaiwgY250LCBwcmV2KSB7XG4gIGlmICghb2JqKSBvYmogPSB7fVxuICBpZiAoIWNudCkgY250ID0gMFxuICBpZiAoIWxldmVsKSBsZXZlbCA9IDBcbiAgZm9yICh2YXIgaSBpbiBwb3B1bGF0ZSkge1xuICAgIGlmICgocG9wdWxhdGVbaV0gaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAmJiBwb3B1bGF0ZVtpXS5sZW5ndGggJiYgcG9wdWxhdGVbaV0udmFsXG4gICAgKSB7XG4gICAgICBpZiAocG9wdWxhdGUgJiYgcG9wdWxhdGVbaV0pIHtcbiAgICAgICAgb2JqW2ldID0gW11cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb3B1bGF0ZVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIG9ialtpXVtqXSA9IHR5cGVvZiBwb3B1bGF0ZVtpXS52YWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgID8gcG9wdWxhdGVbaV0udmFsKClcbiAgICAgICAgICAgIDogZXhwb3J0cy5kYXRhKHBvcHVsYXRlW2ldLnZhbCwgKGxldmVsICsgMSksIGZhbHNlLCBqICsgMSwgb2JqKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKChwb3B1bGF0ZVtpXSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICYmICh0eXBlb2YgcG9wdWxhdGVbaV0gIT09ICdmdW5jdGlvbicpXG4gICAgKSB7XG4gICAgICBvYmpbaV0gPSBleHBvcnRzLmRhdGEocG9wdWxhdGVbaV0sIChsZXZlbCArIDEpLCBvYmpbaV0sIGZhbHNlLCBjbnQsIG9iailcbiAgICB9XG4gICAgZWxzZSBpZiAocG9wdWxhdGUgJiYgcG9wdWxhdGVbaV0pIHtcbiAgICAgIG9ialtpXSA9ICh0eXBlb2YgcG9wdWxhdGVbaV0gPT09ICdmdW5jdGlvbicpXG4gICAgICA/IHBvcHVsYXRlW2ldLmNhbGwob2JqLCBjbnQsIHByZXYpXG4gICAgICA6IHBvcHVsYXRlW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqO1xufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmRlYnVnLmRvd25sb2FkID0gZnVuY3Rpb24oZmlsZW5hbWUsIHRleHQpIHtcbiAgdmFyIHBvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgcG9tLnNldEF0dHJpYnV0ZSgnaHJlZicsICdkYXRhOnRleHQvcGxhaW47Y2hhcnNldD11dGYtOCwnICsgZW5jb2RlVVJJQ29tcG9uZW50KHRleHQpKTtcbiAgcG9tLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBmaWxlbmFtZSk7XG4gIHBvbS5jbGljaygpO1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZGVidWcucmVtb3RlID0gZnVuY3Rpb24oaWQpIHtcbiAgdmFyIGZpbGVyZWYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICBmaWxlcmVmLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2phdmFzY3JpcHRcIilcbiAgZmlsZXJlZi5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgJ2h0dHA6Ly9qc2NvbnNvbGUuY29tL3JlbW90ZS5qcz8nK2lkKVxuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF0uYXBwZW5kQ2hpbGQoZmlsZXJlZilcbn1cblxuZGVidWcuZmluZFNjcmlwdCA9IGZ1bmN0aW9uKG5vZGUsbmFtZSxzdHJpY3QpIHtcblxuICB2YXIgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXNcbiAgICAsIGV4dGVuc2lvbiA9IG5hbWUubWF0Y2goL1xcLihbYS16QS1aMC05XXsxLDMwfSkkLylbMV1cbiAgICAsIHJlZ0V4cCA9ICFzdHJpY3QgJiYgbmV3IFJlZ0V4cChuYW1lKyckJylcbiAgICAsIGZpZWxkID0gZXh0ZW5zaW9uID09PSAnanMnID8gJ3NyYycgOiAnaHJlZidcblxuICBmb3IodmFyIGkgaW4gY2hpbGRyZW4pIHtcblxuICAgIGlmKHN0cmljdCA/IGNoaWxkcmVuW2ldW2ZpZWxkXT09PW5hbWUgOiByZWdFeHAudGVzdChjaGlsZHJlbltpXVtmaWVsZF0pKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9XG5cbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCdub3Rmb3VuZCcsIG5hbWUpXG59XG5cbmZ1bmN0aW9uIHByb21wdHkgKG1zZywgdmFsdWUsIGNiKSB7XG4gICAgdmFyIGRpYWxvZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICAgICAgLCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIilcbiAgICAgICAgLCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKVxuICAgICAgICAsIG9rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKVxuICAgICAgICAsIGNhbmNlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIilcbiAgICBwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG1zZykpXG4gICAgaW5wdXQudHlwZSA9IFwidGV4dFwiXG4gICAgaW5wdXQudmFsdWUgPSB2YWx1ZVxuICAgIGlucHV0LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCJcbiAgICBvay5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIk9LXCIpKVxuICAgIGNhbmNlbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIkNhbmNlbFwiKSlcbiAgICBvay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGlkZURpYWxvZygpXG4gICAgICAgIGNiKGlucHV0LnZhbHVlKVxuICAgIH0pXG4gICAgY2FuY2VsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRlRGlhbG9nKClcbiAgICAgICAgY2IobnVsbClcbiAgICB9KVxuICAgIGRpYWxvZy5hcHBlbmRDaGlsZChwKVxuICAgIGRpYWxvZy5hcHBlbmRDaGlsZChpbnB1dClcbiAgICBkaWFsb2cuYXBwZW5kQ2hpbGQob2spXG4gICAgZGlhbG9nLmFwcGVuZENoaWxkKGNhbmNlbClcbiAgICBkaWFsb2cuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCJcbiAgICBkaWFsb2cuc3R5bGUudG9wID0gMjUgKyBcInB4XCJcbiAgICBkaWFsb2cuc3R5bGUubGVmdCA9IDUwICsgXCJweFwiXG4gICAgZGlhbG9nLnN0eWxlLnpJbmRleCA9IDEwMDBcbiAgICBkaWFsb2cuc3R5bGUuZm9udFNpemUgPSAgMjQgKyAncHgnXG4gICAgZGlhbG9nLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwid2hpdGVcIlxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZGlhbG9nKVxuICAgIGZ1bmN0aW9uIGhpZGVEaWFsb2coKSB7XG4gICAgICAgIGRpYWxvZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRpYWxvZylcbiAgICB9XG59XG5cbmRlYnVnLm5hdGl2ZSA9IGZ1bmN0aW9uKGRlZiwgcGFyc2UsIGNiLCBmaWxlKSB7XG4gIGlmKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV2JykpIHtcbiAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgZWxlbS5pZCA9ICdkZXYnXG4gICAgZWxlbS5zdHlsZS56SW5kZXggPSA5OTk5OTk5XG4gICAgZWxlbS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICBlbGVtLnN0eWxlLmxlZnQgPSAnMnB4J1xuICAgIGVsZW0uc3R5bGUudG9wID0gJzgwcHgnXG4gICAgZWxlbS5zdHlsZS5wYWRkaW5nID0gJzE1cHgnXG4gICAgZWxlbS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSg1MCw1MCw1MCwwLjgpJ1xuICAgIGVsZW0uc3R5bGUuYm9yZGVyUmFkaXVzID0gJzUwJSdcbiAgICBlbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbigpIHtcbiAgICAgIHByb21wdHkoJ0lQJywgbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2RldmlwJykgfHwgZGVmIHx8ICdodHRwOi8vMTAuMC4xLjI6ODA4MCcsIGZ1bmN0aW9uIChpcCkge1xuICAgICAgICBpZiAoaXApIHtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnZGV2aXAnLGlwKVxuICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBhbGVydCgneCcpXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2RldmlwJylcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWxlbSlcbiAgfVxuXG4gIGlmKCFmaWxlKSB7XG4gICAgZmlsZSA9ICdidWlsZCdcbiAgfVxuXG4gIGlmKCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGV2aXAnKSApIHtcbiAgICBERUJVRyQucmVtb3RlUmVzb3VyY2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2RldmlwJykrJy9idW5kbGUuY3NzJyxmaWxlKycuY3NzJyxmYWxzZSlcbiAgICBpZihERUJVRyQucmVtb3RlUmVzb3VyY2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2RldmlwJykrJy9idW5kbGUuanMnLGZpbGUrJy5qcycsZmFsc2UpKSB7XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGV2Jykuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMCwyNTUsMCwwLjgpJ1xuICAgICAgaWYoY2IpIGNiKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkZXZpcCcpKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IFxuICB9XG59XG5cbi8vaGllciByZW1vdGVyZXNvdXJjZSBnZWJydWlrZW5cbmRlYnVnLnJlbW90ZVJlc291cmNlID0gZnVuY3Rpb24oc3JjLCByZXBsYWNlLCBzdHJpY3QpIHtcbiAgY29uc29sZS5sb2coJ3JlbW90ZSByZXNvdXJjZScsc3JjKVxuICB2YXIgc3RyaWN0ID0gc3RyaWN0ICE9PSB2b2lkIDAgPyBzdHJpY3QgOiB0cnVlXG4gICAgLCBleHRlbnNpb24gPSBzcmMubWF0Y2goL1xcLihbYS16QS1aMC05XXsxLDMwfSkkLylbMV1cbiAgICAsIGZpbGVyZWYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGV4dGVuc2lvbj09PSdqcycgPyAnc2NyaXB0JyA6ICdsaW5rJylcbiAgICAsIGhlYWQgPSAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdXG4gICAgLCBib2R5ID0gZG9jdW1lbnQuYm9keVxuICAgICwgZm91bmRcbiAgICAsIGZpbGVTcmNcblxuICBpZighcmVwbGFjZSkge1xuICAgIHN0cmljdCA9IGZhbHNlXG4gICAgcmVwbGFjZSA9IHNyYy5tYXRjaChleHRlbnNpb249PT0nanMnXG4gICAgICA/IC8oXFwvKShbYS16QS1aMC05LV8rJF0pezAsMzB9XFwuanMkL1xuICAgICAgOiAvKFxcLykoW2EtekEtWjAtOS1fKyRdKXswLDMwfVxcLmNzcyQvXG4gICAgKVswXS5zbGljZSgxKVxuXG5cbiAgfVxuXG4gIGZpbGVTcmMgPSBzcmMrJz8nKyB+fihNYXRoLnJhbmRvbSgpKjk5OTk5OTkpXG5cbiAgaWYoZXh0ZW5zaW9uPT09J2pzJykge1xuICAgIGZpbGVyZWYuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvamF2YXNjcmlwdFwiKVxuICAgIGZpbGVyZWYuc2V0QXR0cmlidXRlKFwic3JjXCIsIGZpbGVTcmMpXG4gIH0gZWxzZSB7XG4gICAgZmlsZXJlZi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dC9jc3NcIilcbiAgICBmaWxlcmVmLnNldEF0dHJpYnV0ZShcInJlbFwiLCBcInN0eWxlc2hlZXRcIilcbiAgICBmaWxlcmVmLnNldEF0dHJpYnV0ZShcImhyZWZcIiwgZmlsZVNyYylcbiAgICBmaWxlcmVmLnNldEF0dHJpYnV0ZShcImlkXCIsIGZpbGVTcmMpXG4gIH1cblxuICBmb3VuZCA9IGRlYnVnLmZpbmRTY3JpcHQoaGVhZCxyZXBsYWNlLHN0cmljdClcblxuICBpZighZm91bmQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGJvZHksIGZvdW5kLCAnIUAhQCMhQCNKUycpXG5cbiAgICBmb3VuZCA9IGRlYnVnLmZpbmRTY3JpcHQoYm9keSxyZXBsYWNlLHN0cmljdClcbiAgfVxuICBpZihmb3VuZCkge1xuXG4gICAgY29uc29sZS5sb2coJ3JlbW90ZSByZXNvdXJjZSBmb3VuZDonLGZvdW5kLCBmb3VuZC5zcmMgLCBmaWxlU3JjLCBzcmMpXG5cbiAgICB2YXIgcGFyZW50ID0gZm91bmQucGFyZW50Tm9kZVxuICAgIGlmKFN0cmluZyhmb3VuZC5zcmMpLmluZGV4T2Yoc3JjKT4tMSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKGZvdW5kKVxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChmaWxlcmVmKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cbiIsInZhciBkZWJ1ZyA9IHJlcXVpcmUoJy4vJykgXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLycpIFxuICAsIGlzTm9kZSA9IHV0aWwuaXNOb2RlIC8vaGFzIHRvIGJlY29tZSBwYXJ0IG9mIHV0aWxcbiAgLCBWID0gcmVxdWlyZSgnLi4vLi4vJylcbiAgLCByZXBsXG4gICwgY29sb3JzXG4gICwgb3JpZ0NvbnNvbGUgPSBjb25zb2xlXG4gICwgY29sb3JzID0ge1xuICAgICAgZ3JlZW46JyM1NmRiNjgnLFxuICAgICAgcmVkOicjZmYwMDAwJyxcbiAgICAgIGdyZXk6JyNjY2MnLFxuICAgICAgeWVsbG93OicjZTBlNjdjJyxcbiAgICAgIGN5YW46JyMwMGZmZmYnLFxuICAgICAgbWFnZW50YTonI2ZmMDBmZicsXG4gICAgICBibHVlOicjMTExMWZmJyxcbiAgICAgIHdoaXRlOicjZmZmJ1xuICAgIH1cbiAgLCBzdHlsZXMgPSB7XG4gICAgICBib2xkOidmb250LXdlaWdodDpib2xkO2ZvbnQtc2l6ZToxNnB4O2xpbmUtaGVpZ2h0OjE1cHgnLFxuICAgICAgdW5kZXJsaW5lOidib3JkZXItYm90dG9tOjFweCBzb2xpZCcsXG4gICAgICBpdGFsaWM6J2ZvbnQtc3R5bGU6aXRhbGljJyxcbiAgICAgIGludmVyc2U6ZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgaWYoY29sb3IpIHtcbiAgICAgICAgICByZXR1cm4gY29sb3IrJztiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7cGFkZGluZzo1cHg7bGluZS1oZWlnaHQ6MjBweCdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gJ2NvbG9yOicrY29sb3JzLndoaXRlKyc7YmFja2dyb3VuZC1jb2xvcjojMzMzO3BhZGRpbmc6NXB4O2xpbmUtaGVpZ2h0OjIwcHgnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbmRlYnVnLmxldmVsID0gXG57IERFQlVHJDogSW5maW5pdHlcbiwgdGVzdDoyXG59XG5cblxuXG4vKlxuYm9sZFxuaXRhbGljXG51bmRlcmxpbmVcbmludmVyc2VcbnllbGxvd1xuY3lhblxud2hpdGVcbm1hZ2VudGFcbmdyZWVuXG5yZWRcbmdyZXlcbmJsdWVcbnJhaW5ib3dcbnplYnJhXG5yYW5kb21cbiovXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBsb2dPYmplY3RcbiAgLCBwYXJzZU9iamVjdFxuICAsIExPR1xuICAsIElORk9cbiAgLCBFUlJPUlxuICAsIERFVEFJTFxuXG5pZiAoIWlzTm9kZSkgeyBcblxuICBMT0cgPSAnOidcbiAgSU5GTyA9ICc6OidcbiAgRVJST1IgPSAnRVJSRVghJ1xuICBERVRBSUwgPSAnOjo6J1xuXG4gIC8vIGNvbnNvbGUgPSB7fVxuICBmdW5jdGlvbiBsb2dsaW5rKGkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhpLCBhcmd1bWVudHMpXG4gICAgICAvLyBjb25zb2xlLmxvZyhuZXcgRXJyb3IoKS5zdGFjaylcblxuICAgICAgb3JpZ0NvbnNvbGVbaV0uYXBwbHkob3JpZ0NvbnNvbGUsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICAvLyBmb3IodmFyIGkgaW4gb3JpZ0NvbnNvbGUpIHtcbiAgLy8gICBpZihpICE9PSAnbG9nJykgY29uc29sZVtpXSA9IGxvZ2xpbmsoaSlcbiAgLy8gfVxuXG4gIHZhciBDb2xvciA9IGZ1bmN0aW9uKHZhbCxjb2RlLHMpIHtcbiAgICB0aGlzLmNvbG9yID0gIChzID8gY29kZSA6ICdjb2xvcjogJytjb2RlKSsnOydcbiAgICB0aGlzLnZhbCA9IG5ldyBTdHJpbmcoJyVjJyt2YWwpXG4gIH1cbiAgXG4gIC8vIGNvbnNvbGUubG9nID0gZnVuY3Rpb24oKSB7XG5cbiAgLy8gICB2YXIgbmV4dCA9IGZhbHNlXG5cbiAgLy8gICBmb3IodmFyIGk9MCwgYXJnLCByYXJncz1bXSwgYXJncyA9IGFyZ3VtZW50cyxsZW4gPSBhcmdzLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgLy8gICAgIGFyZyA9IGFyZ3NbaV1cbiAgLy8gICAgIGlmKGFyZyBpbnN0YW5jZW9mIENvbG9yKSB7XG4gIC8vICAgICAgIGlmKHJhcmdzLmxlbmd0aCl7XG4gIC8vICAgICAgICAgbmV4dCA9IHV0aWwuYXJnKGFyZ3MsIGkpXG4gIC8vICAgICAgICAgYnJlYWtcbiAgLy8gICAgICAgfWVsc2V7XG4gIC8vICAgICAgICAgcmFyZ3MucHVzaChhcmcudmFsLnZhbHVlT2YoKSwgYXJnLmNvbG9yKVxuICAvLyAgICAgICB9XG4gIC8vICAgICAgIC8vIGxvZ2dlcihhcmcudmFsLnZhbHVlT2YoKSwgYXJnLmNvbG9yKVxuICAvLyAgICAgfSBlbHNlIHtcbiAgLy8gICAgICAgcmFyZ3MucHVzaChhcmcpXG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyAgIC8vIGxvZ2dlcignbm93IGxvZycsIHJhcmdzKVxuICAvLyAgIGlmKHJhcmdzLmxlbmd0aCkgbG9nZ2VyLmFwcGx5KG9yaWdDb25zb2xlLHJhcmdzKVxuICAvLyAgIC8vIGxvZ2dlcignbmV4dCcsIG5leHQpXG4gIC8vICAgaWYobmV4dC5sZW5ndGgpIGNvbnNvbGUubG9nLmFwcGx5KG51bGwsbmV4dClcblxuICAvLyB9XG5cbiAgZnVuY3Rpb24gY29sb3IoaSwgQ2xhc3MsIHN0eWxlKSB7XG4gICAgdXRpbC5kZWZpbmUoQ2xhc3MgfHwgU3RyaW5nLGkse1xuICAgICAgZ2V0OmZ1bmN0aW9uKCkge1xuICAgICAgICBpZihDbGFzcykge1xuICAgICAgICAgIGlmKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5jb2xvciA9IHN0eWxlKHRoaXMuY29sb3IpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IrPShzdHlsZXx8KCdjb2xvcjonK2NvbG9yc1tpXSkpKyc7J1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzID0gY29sb3JzW2ldXG4gICAgICAgICAgaWYoc3R5bGUpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBzdHlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzID0gc3R5bGUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcz1zdHlsZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMscyxzdHlsZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyBmdW5jdGlvbiBsb2dnZXIoKSB7XG5cblxuICAvLyAgIG9yaWdDb25zb2xlLmxvZy5hcHBseShvcmlnQ29uc29sZSxhcmd1bWVudHMpXG5cblxuICAvLyB9XG5cbiAgLy8gZm9yKHZhciBpIGluIGNvbG9ycykgeyBjb2xvcihpKSB9XG4gIC8vIGZvcih2YXIgaSBpbiBzdHlsZXMpIHsgY29sb3IoaSwgZmFsc2UsIHN0eWxlc1tpXSkgfSAgXG4gIC8vIGZvcih2YXIgaSBpbiBjb2xvcnMpIHsgY29sb3IoaSwgQ29sb3IpIH1cbiAgLy8gZm9yKHZhciBpIGluIHN0eWxlcykgeyBjb2xvcihpLCBDb2xvciwgc3R5bGVzW2ldKSB9ICBcblxuICBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSByZXR1cm4gb2JqXG4gICAgdmFyIHN0ciA9ICcnXG4gICAgZm9yKHZhciBpIGluIG9iaikge1xuICAgICAgc3RyICs9IGkgKyAnIDogJyArICh0eXBlb2Ygb2JqW2ldID09PSAnc3RyaW5nJyBcbiAgICAgICAgPyAgb2JqW2ldIFxuICAgICAgICA6IEpTT04uc3RyaW5naWZ5KG9ialtpXSxmYWxzZSwyKSkgXG4gICAgICArICdcXG4nXG4gICAgfVxuICAgIHJldHVybiBzdHIuaW52ZXJzZS5ncmVlblxuICB9XG4gIFxuICBsb2dPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBjb25zb2xlLmxvZyhwYXJzZU9iamVjdChvYmopKVxuICB9XG4gIFxufSBlbHNlIHtcbiAgcmVwbCA9IHJlcXVpcmUoJ3JlcGwnKVxuICBjb2xvcnMgPSByZXF1aXJlKCdjb2xvcnMnKVxuXG4gIExPRyA9ICdsb2cgICcuZ3JleVxuICBJTkZPID0gJ2luZm8gJy5ncmVlblxuICBFUlJPUiA9ICdlcnJvcicucmVkXG4gIERFVEFJTCA9ICctLS0tLScuZ3JleVxuXG4gIGRlYnVnLnJlcGwgPSBmdW5jdGlvbigpIHtcbiAgICByZXBsLnN0YXJ0KCc+JylcbiAgICByZXR1cm4gZGVidWdcbiAgfVxuICBpZihyZXBsLmNvbnRleHQpIHJlcGwuY29udGV4dC5ERUJVRyQgPSBERUJVRyRcblxuICBjb25zb2xlLmdyb3VwID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coJ1xcbl9fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX18nLmdyZXkpXG4gIH0gICAgICBcbiAgY29uc29sZS5ncm91cEVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdfX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXFxuJy5ncmV5KVxuICB9XG4gIHZhciBuX3V0aWwgPSByZXF1aXJlKCd1dGlsJylcbiAgcGFyc2VPYmplY3QgPSBmdW5jdGlvbihvYmope1xuICAgIHJldHVybiBuX3V0aWwuaW5zcGVjdChvYmose2NvbG9yczp0cnVlLCBkZXB0aDogNTB9KVxuICB9XG4gIGxvZ09iamVjdCA9IGZ1bmN0aW9uKG9iail7XG4gICAgY29uc29sZS5sb2cocGFyc2VPYmplY3Qob2JqKSlcbiAgfVxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG51dGlsLmRlZmluZShPYmplY3QsJ0RFQlVHJGxvZycsIGZ1bmN0aW9uKG1zZyxzKSB7XG4gIGlmKGNvbnNvbGUuZ3JvdXApIGNvbnNvbGUuZ3JvdXAoKVxuICBpZih0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIG1zZyA9IG1zZ1xuICB9IGVsc2Uge1xuICAgIG1zZyA9IGZhbHNlXG4gIH1cbiAgdmFyIGggPSAnSlNPTiAnKyhtc2d8fCcgbm9ybWFsJylcbiAgZGVidWcubG9nLmhlYWRlcihoKVxuICBpZihkZWJ1Zy5sZXZlbC50ZXN0PjEpIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHRoaXMsZmFsc2UsMikpXG4gIGlmKHMpIHtcbiAgICBjb25zb2xlLmxvZygnXFxuJylcbiAgICBkZWJ1Zy5sb2cuZm4uYXBwbHkodGhpcyx1dGlsLmFyZyhhcmd1bWVudHMsMSkpIFxuICB9XG4gIC8vIGRlYnVnLmxvZy5lbmQoaClcbiAgaWYoY29uc29sZS5ncm91cCkgY29uc29sZS5ncm91cEVuZCgpXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLGZhbHNlLDIpXG59KVxuXG5pZighaXNOb2RlICYmIGxvY2FsU3RvcmFnZSkge1xuICB1dGlsLmRlZmluZShsb2NhbFN0b3JhZ2UsJ0RFQlVHJGxvZycsIGZ1bmN0aW9uKG1zZyxzKSB7XG4gICAgaWYoY29uc29sZS5ncm91cCkgY29uc29sZS5ncm91cCgpXG4gICAgaWYodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1zZyA9IG1zZ1xuICAgIH0gZWxzZSB7XG4gICAgICBtc2cgPSBmYWxzZVxuICAgIH1cbiAgICB2YXIgaCA9ICdsb2NhbFN0b3JhZ2UgJysobXNnfHwnIG5vcm1hbCcpXG4gICAgZGVidWcubG9nLmhlYWRlcihoKVxuXG4gICAgdmFyIG9iaiA9IHt9XG4gICAgZm9yKHZhciBpIGluIHRoaXMpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGksIHRoaXMpXG4gICAgICAgdHJ5IHsgb2JqW2ldID1KU09OLnBhcnNlKHRoaXNbaV0pIH0gY2F0Y2goZSl7XG4gICAgICAgIG9ialtpXSA9IHRoaXNbaV1cbiAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coKVxuXG4gICAgaWYoZGVidWcubGV2ZWwudGVzdD4xKSBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShvYmosZmFsc2UsMikpXG4gICAgaWYocykge1xuICAgICAgY29uc29sZS5sb2coJ1xcbicpXG4gICAgICBkZWJ1Zy5sb2cuZm4uYXBwbHkodGhpcyx1dGlsLmFyZyhhcmd1bWVudHMsMSkpIFxuICAgIH1cbiAgICAvLyBkZWJ1Zy5sb2cuZW5kKGgpXG4gICAgaWYoY29uc29sZS5ncm91cCkgY29uc29sZS5ncm91cEVuZCgpXG4gICAgcmV0dXJuIG9ialxuICB9KVxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgbG9nID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0ge1xuICBzdGFjazogZmFsc2UsXG4gIGk6ZnVuY3Rpb24obnIpIHtcbiAgICBuciA9IHRoaXMuaW5kZW50XG4gICAgdmFyIHN0ciA9ICcnXG4gICAgZm9yKHZhciBpIGluIG5yKSB7XG4gICAgICBzdHIrPScgICdcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICB9LFxuICBwYXJzZTogcGFyc2VPYmplY3QsXG4gIG9iamVjdDogbG9nT2JqZWN0LFxuICBkZWZhdWx0OiBmdW5jdGlvbihsYWJlbCwgbGV2ZWwpe1xuICAgIGlmKGxhYmVsIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgZm9yKHZhciBsIGluIGxhYmVsKVxuICAgICAgICBzZXREZWZhdWx0KGwsIGxhYmVsW2xdKVxuICAgIGVsc2VcbiAgICAgIHNldERlZmF1bHQobGFiZWwsIGxldmVsKVxuICB9LFxuICBsb2dnZXI6ZnVuY3Rpb24obGFiZWwsIGNvbG9yLCBsZXZlbCl7XG4gICAgbG9nLmRlZmF1bHQobGFiZWwsIGxldmVsIHx8IDEpXG4gICAgXG4gICAgZnVuY3Rpb24gbG9nZ2VyKCl7XG4gICAgICB2YXIgbGV2ZWwgPSBkZWJ1Zy5sZXZlbC5nbG9iYWwgIT09IHVuZGVmaW5lZCA/IGRlYnVnLmxldmVsLmdsb2JhbCA6IGRlYnVnLmxldmVsW2xhYmVsXVxuICAgICAgaWYobGV2ZWwgPiAyKSB7XG4vLyAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KG51bGwsIFtsYWJlbFtjb2xvcl0uYm9sZCwgTE9HXS5jb25jYXQodXRpbC5hcmcoYXJndW1lbnRzKSkpXG4gICAgICAgIGlmKGxvZy5zdGFjaykgY29uc29sZS5sb2coc21hbGxTdGFjayhsb2cuc3RhY2spLmdyZXkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbG9nZ2VyLmluZm8gPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGxldmVsID0gZGVidWcubGV2ZWwuZ2xvYmFsICE9PSB1bmRlZmluZWQgPyBkZWJ1Zy5sZXZlbC5nbG9iYWwgOiBkZWJ1Zy5sZXZlbFtsYWJlbF1cbiAgICAgIGlmKGxldmVsID4gMSkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShudWxsLCBbbGFiZWxbY29sb3JdLmJvbGQsIElORk9dLmNvbmNhdCh1dGlsLmFyZyhhcmd1bWVudHMpKSlcbiAgICAgICAgaWYobG9nLnN0YWNrKSBjb25zb2xlLmxvZyhzbWFsbFN0YWNrKGxvZy5zdGFjaykuZ3JleSlcbiAgICAgIH1cbiAgICAgICAgXG4gICAgfVxuICAgIGxvZ2dlci5lcnJvciA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbGV2ZWwgPSBkZWJ1Zy5sZXZlbC5nbG9iYWwgIT09IHVuZGVmaW5lZCA/IGRlYnVnLmxldmVsLmdsb2JhbCA6IGRlYnVnLmxldmVsW2xhYmVsXVxuICAgICAgaWYobGV2ZWwgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KG51bGwsIFtsYWJlbFtjb2xvcl0uYm9sZCwgRVJST1JdLmNvbmNhdCh1dGlsLmFyZyhhcmd1bWVudHMpKSlcbiAgICAgICAgaWYobG9nLnN0YWNrKSBjb25zb2xlLmxvZyhzbWFsbFN0YWNrKGxvZy5zdGFjaykuZ3JleSlcbiAgICAgIH1cbiAgICB9XG4gICAgbG9nZ2VyLmRldGFpbCA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbGV2ZWwgPSBkZWJ1Zy5sZXZlbC5nbG9iYWwgIT09IHVuZGVmaW5lZCA/IGRlYnVnLmxldmVsLmdsb2JhbCA6IGRlYnVnLmxldmVsW2xhYmVsXVxuICAgICAgaWYobGV2ZWwgPiAzKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KG51bGwsIFtsYWJlbFtjb2xvcl0uYm9sZCwgREVUQUlMXS5jb25jYXQodXRpbC5hcmcoYXJndW1lbnRzKSkpXG4gICAgICAgIGlmKGxvZy5zdGFjaykgY29uc29sZS5sb2coc21hbGxTdGFjayhsb2cuc3RhY2spLmdyZXkpXG4gICAgICB9ICAgICAgXG4gICAgfVxuICAgIGxvZ2dlci5wYXJzZSA9IHBhcnNlT2JqZWN0XG4gICAgcmV0dXJuIGxvZ2dlclxuICB9LFxuICBsYWJlbDogZnVuY3Rpb24obGFiZWwsIHN0eWxlLCBsb2cpe1xuICAgICAgaWYoaXNOb2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KG51bGwsIGxvZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KCBudWxsXG4gICAgICAgICAgLCBbJyVjICcrbGFiZWwrJyAnLCBzdHlsZV0uY29uY2F0KGxvZylcbiAgICAgICAgKVxuICAgICAgfVxuICB9LFxuICBoZWFkZXI6ZnVuY3Rpb24obXNnKSB7XG4gICAgdGhpcy5fbGggPSBtc2dcbiAgICBjb25zb2xlLmxvZyhtc2cuaW52ZXJzZSlcbiAgfSxcbiAgaGVhZGVyMjpmdW5jdGlvbihtc2cpIHtcbiAgICB0aGlzLl9saCA9IG1zZ1xuICAgIGNvbnNvbGUubG9nKG1zZy5ncmV5LmludmVyc2UpXG4gIH0sXG4gIGVuZDpmdW5jdGlvbihtc2cpIHtcbiAgICBjb25zb2xlLmxvZygoJ2VuZCBbJyttc2crJ10nKS5ncmV5LmludmVyc2UpXG4gIH0sXG4gIGxldmVsOmZ1bmN0aW9uKGxldmVsLGZpZWxkKSB7XG4gICAgaWYobGV2ZWwgPj0gZGVidWcubGV2ZWwudGVzdCBcbiAgICAgIHx8ICBkZWJ1Zy5sZXZlbFtsZXZlbF0gXG4gICAgICB8fCBmaWVsZCAmJiBkZWJ1Zy5sZXZlbFtsZXZlbF0+PWZpZWxkICkgXG4gICAgICBjb25zb2xlLmxvZy5hcHBseSh0aGlzLHV0aWwuYXJnKGFyZ3VtZW50cywxKSlcbiAgfSxcbiAgZm46ZnVuY3Rpb24oYXJnKSB7XG4gICAgZGVidWcubG9nLmluZGVudCsrXG4gICAgaWYodHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXJnLmNhbGwodGhpcyx1dGlsLmFyZyhhcmd1bWVudHMsMSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUubG9nKGFyZ3VtZW50cylcbi8vICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KHRoaXMsYXJndW1lbnRzKVxuICAgIH1cbiAgICBkZWJ1Zy5sb2cuaW5kZW50LS1cbiAgfSxcbiAgaW5kZW50OjBcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIHNtYWxsU3RhY2sobGluZXMpe1xuICBpZighbGluZXMpIGxpbmVzID0gMVxuICB2YXIgc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjay5zcGxpdCgnXFxuJylcbiAgICAsIGwgPSAzXG4gICAgLCByZXN1bHQgPSBbXVxuICAgICwgZW5kXG5cbiAgd2hpbGUobGluZXMtLSl7XG4gICAgbGluZSA9IHN0YWNrW2wrK11cbiAgICBlbmQgPSBsaW5lW2xpbmUubGVuZ3RoLTFdID09PSAnKScgPyBsaW5lLmxlbmd0aC0xIDogbGluZS5sZW5ndGhcbiAgICByZXN1bHQucHVzaChsaW5lLnNsaWNlKGxpbmUuaW5kZXhPZignLycpLCBlbmQpKVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCdcXG4nKS5ncmV5XG4gIFxufVxuXG5mdW5jdGlvbiBzZXREZWZhdWx0KGxhYmVsLCBsZXZlbCl7XG4gIGlmKGRlYnVnLmxldmVsW2xhYmVsXSA9PT0gdm9pZCAwKSBkZWJ1Zy5sZXZlbFtsYWJlbF0gPSBsZXZlbFxufVxuXG5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuLy8gICBjb25zb2xlLmxvZygnbG9nIGxldmVsczpcXG4nLCBsb2cucGFyc2UoZGVidWcubGV2ZWwpKVxufSwwKVxuXG4vL0xvY2Fsc3RvcmFnZVxuXG4vKlxudmFyIGxvY2FsU3RvcmFnZVNwYWNlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGFsbFN0cmluZ3MgPSAnJztcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gd2luZG93LmxvY2FsU3RvcmFnZSl7XG4gICAgICAgICAgICBpZih3aW5kb3cubG9jYWxTdG9yYWdlLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIGFsbFN0cmluZ3MgKz0gd2luZG93LmxvY2FsU3RvcmFnZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxTdHJpbmdzID8gMyArICgoYWxsU3RyaW5ncy5sZW5ndGgqMTYpLyg4KjEwMjQpKSArICcgS0InIDogJ0VtcHR5ICgwIEtCKSc7XG4gICAgfTtcblxuKi9cblxudXRpbC5kZWZpbmUoZGVidWcsJ2xvY2FsU3RvcmFnZVNpemUnLCB7XG4gIGdldDpmdW5jdGlvbigpIHtcbiAgdmFyIHRvdGFsID0gMFxuICBmb3IodmFyIHggaW4gbG9jYWxTdG9yYWdlKSB7XG4gICAgdmFyIGtieXRlcyA9ICgoKHgubGVuZ3RoK2xvY2FsU3RvcmFnZVt4XS5sZW5ndGgpKS8oMTAyNCkpXG4gICAgdG90YWwrPWtieXRlc1xuICAgIC8vIGNvbnNvbGUubG9nKCh4K1wiOlwiK2tieXRlcy50b0ZpeGVkKDEwKStcIiBLQlwiKS5ncmV5KVxuICB9XG4gIGNvbnNvbGUubG9nKCdMT0NBTCBTVE9SQUdFIFNJWkUgVE9UQUwnLmludmVyc2UuZ3JlZW4sICh0b3RhbC8xMDI0KS50b0ZpeGVkKDUpKycgTUInKVxuICByZXR1cm4gdG90YWwqMTAyNFxufVxufSlcblxudXRpbC5kZWZpbmUoZGVidWcsJ2xvY2FsU3RvcmFnZUtleXNTaXplJywge1xuICBnZXQ6ZnVuY3Rpb24oKSB7XG4gIHZhciB0b3RhbCA9IDBcbiAgZm9yKHZhciB4IGluIGxvY2FsU3RvcmFnZSkge1xuICAgIHZhciBrYnl0ZXMgPSAoKCh4Lmxlbmd0aCkpLygxMDI0KSlcbiAgICB0b3RhbCs9a2J5dGVzXG4gICAgLy8gY29uc29sZS5sb2coKHgrXCI6XCIra2J5dGVzLnRvRml4ZWQoMTApK1wiIEtCXCIpLmdyZXkpXG4gIH1cbiAgY29uc29sZS5sb2coJ0xPQ0FMIFNUT1JBR0UgS0VZIFNJWkUgVE9UQUwnLmludmVyc2UuZ3JlZW4sICh0b3RhbC8xMDI0KS50b0ZpeGVkKDUpKycgTUInKVxuICByZXR1cm4gdG90YWwqMTAyNFxufVxufSlcblxuXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLycpIFxuICAsIGRlYnVnID0gcmVxdWlyZSgnLi8nKSBcbiAgLCBpc05vZGUgPSB1dGlsLmlzTm9kZSAvL2hhcyB0byBiZWNvbWUgcGFydCBvZiB1dGlsXG4gICwgb3NcblxuaWYgKGlzTm9kZSkgeyBcbiAgb3MgPSByZXF1aXJlKCdvcycpXG59IGVsc2Uge1xuICBjb25zb2xlLmxvZygnREVCVUcgXFxuXFxuaWYgeW91IHdhbnQgdG8gY2hlY2sgbWVtb3J5IHVzYWdlIHN0YXJ0IGNocm9tZSB1c2luZzogXFxuXFxuIG9wZW4gLWEgR29vZ2xlXFxcXCBDaHJvbWUgLS1hcmdzIC0tZW5hYmxlLW1lbW9yeS1pbmZvIC0tanMtZmxhZ3M9XCItLWV4cG9zZS1nY1wiXFxuJy5ncmV5KVxufVxuXG5mdW5jdGlvbiBfdGVzdChtZXRob2QsIG5hbWUsIGNvbXBsZXRlLCBjYWxsLCBhcmdzLCBub2xvZykge1xuICB2YXIgc3RhcnQgPSBleHBvcnRzLm5vdygpXG4gICAgLCBtZW1vcnlzdGFydCA9IGV4cG9ydHMubWVtb3J5KClcbiAgICAsIG1lbW9yeWVuZFxuICAgICwgbWVtXG4gICAgLCB0aW1lXG4gICAgLCBlbmRcbiAgICAsIHN1YiBcbiAgaWYgKCFuYW1lKSBuYW1lID0gJ1RFU1QgUEVSRk9STUFOQ0UnXG4gIGlmIChjYWxsKSB7XG4gICAgc3ViID0gbWV0aG9kLmFwcGx5KGNhbGwsIGFyZ3MpXG4gIH0gXG4gIGVsc2Uge1xuICAgIHN1YiA9IG1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKVxuICB9XG4gIGVuZCA9IGV4cG9ydHMubm93KClcbiAgbWVtb3J5ZW5kID0gZXhwb3J0cy5tZW1vcnkoKVxuICBtZW0gPSAobWVtb3J5ZW5kIC0gbWVtb3J5c3RhcnQpXG4gIHRpbWUgPSBlbmQgLSBzdGFydCAtIChzdWIgfHwgMClcbiAgaWYgKGNvbXBsZXRlKSB7XG4gICAgY29tcGxldGUoKCh0aW1lKSAvIDEwMDApLCAobWVtb3J5ZW5kIC0gbWVtb3J5c3RhcnQpKVxuICB9IFxuICBlbHNlIGlmICghbm9sb2cpIHtcbiAgICBpZihkZWJ1Zy5sZXZlbC50ZXN0PjApIHtcbiAgICAgIGNvbnNvbGUubG9nKCBcbiAgICAgICAgbmFtZS5pbnZlcnNlICwgJ1xcbnBhcnNlIHRpbWU6ICcgXG4gICAgICAgICsgKChlbmQgLSBzdGFydCkgLyAxMDAwKSBcbiAgICAgICAgKyAnIHNlYycgKyAobWVtID8gJ1xcbm1lbW9yeSB1c2VkIChhcHByb3hpbWF0ZSk6ICcgXG4gICAgICAgICsgbWVtICsgJyBieXRlcycgOiAnJylcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpbWVcbn1cblxuXG5cbnZhciBvbGRDaGVjayA9IFtdXG5kZWJ1Zy5jb3VudE5ld0xpc3RlbmVycyA9IGZ1bmN0aW9uKCBvYmosIGFtb3VudCApIHtcbiAgXG4gIGFtb3VudCA9IHt2YWw6MH1cblxuICB2YXIgY2hlY2tub3cgPSBbXVxuXG4gIGRlYnVnLmNvdW50TGlzdGVuZXJzKCBvYmosIGFtb3VudCwgY2hlY2tub3cgKSBcblxuICB2YXIgbmV3bGlzdG5lcnMgPSBbXVxuXG4gIGZvciggdmFyIGkgaW4gY2hlY2tub3cgKSB7XG5cbiAgICBpZiggdXRpbC5jaGVja0FycmF5KCBvbGRDaGVjaywgY2hlY2tub3dbaV0gKSA9PT0gZmFsc2UgKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhjaGVja25vd1tpXSlcbiAgICAgIC8vIGlmKCB0eXBlb2YgY2hlY2tub3dbaV0gPT09ICdvYmplY3QnIHx8IHR5cGVvZiBjaGVja25vd1tpXSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2xldHMgcHVzaCcpXG4gICAgICAgIC8vIGlmKCF1dGlsLmVtcHR5KGNoZWNrbm93W2ldKSkge1xuICAgICAgICBuZXdsaXN0bmVycy5wdXNoKCBjaGVja25vd1tpXSApXG4gICAgICAgIC8vIH1cbiAgICAgIC8vIH1cbiAgICB9XG4gIH1cblxuICBvbGRDaGVjayA9IGNoZWNrbm93XG5cbiAgcmV0dXJuIHtcbiAgICBhbW91bnQ6IGFtb3VudC52YWxcbiAgLCBuZXdjaGVja3M6IG5ld2xpc3RuZXJzXG4gIH1cblxufVxuXG5cbmRlYnVnLmNvdW50TGlzdGVuZXJzID0gZnVuY3Rpb24ob2JqLCBhbW91bnQsIGNoZWNrZWQpIHtcbiAgdmFyIGFtb3VudCBcbiAgICAsIGNoZWNrZWQgXG5cbiAgaWYoIWNoZWNrZWQpIHtcbiAgICBjaGVja2VkID0gW11cbiAgfVxuXG4gIGlmKHV0aWwuY2hlY2tBcnJheShjaGVja2VkLCBvYmopIT09ZmFsc2UgfHwgIW9iaikge1xuICAgIHJldHVybiBhbW91bnQudmFsXG4gIH1cbiAgY2hlY2tlZC5wdXNoKG9iailcblxuICBpZighYW1vdW50KSBhbW91bnQgPSB7dmFsOjB9XG4gIGlmKG9iai5fbGlzdGVuZXJzKSB7XG4gICAgYW1vdW50LnZhbCs9b2JqLl9saXN0ZW5lcnMubGVuZ3RoXG4gIH1cblxuICBpZighb2JqLmVhY2gpIHtcblxuICAgIGlmKG9iaiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgZm9yKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZihvYmpbaV0gJiYgKCBvYmpbaV0uX190IHx8IG9ialtpXS5fZnJvbSB8fCBvYmouX2Zyb20gJiYgaSA9PT0nY2xvdWQnKSApIGRlYnVnLmNvdW50TGlzdGVuZXJzKG9ialtpXSxhbW91bnQsY2hlY2tlZClcbiAgICAgIH1cbiAgICB9XG5cbiAgfSBlbHNlIHtcblxuICAgIG9iai5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIGRlYnVnLmNvdW50TGlzdGVuZXJzKHRoaXMsYW1vdW50LGNoZWNrZWQpXG4gICAgfSlcblxuICB9XG5cbiAgcmV0dXJuIGFtb3VudC52YWxcbn1cblxuZGVidWcuY291bnRTdWJzID0gZnVuY3Rpb24ob2JqLCBhbW91bnQsIGtleSkge1xuICB2YXIgYW1vdW50IFxuICBpZighYW1vdW50KSBhbW91bnQgPSB7dmFsOjB9XG4gIGlmKG9iai5fc3Vicykge1xuICAgIGNvbnNvbGUubG9nKCchISEhIVNVQicsIG9iai5fcGF0aCwgb2JqLl9zdWJzKVxuICAgIGFtb3VudC52YWwrPW9iai5fc3Vicy5sZW5ndGhcbiAgfVxuICAgIFxuICBpZighb2JqLmVhY2gpIHtcbiAgICBjb25zb2xlLmxvZygnbm8gRUFDSCEnLCBrZXkpXG4gIH1cbiAgLy8gY29uc29sZS5sb2cob2JqLCBvYmouX3N1YnMpXG4gIG9iai5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICBkZWJ1Zy5jb3VudFN1YnModGhpcyxhbW91bnQsaSlcbiAgfSlcbiAgcmV0dXJuIGFtb3VudC52YWxcbn1cblxuZnVuY3Rpb24gX2RvbmUocGFyYW1zLCB0aW1lLCBtZW0pIHtcbiAgaWYgKHBhcmFtcy5jb21wbGV0ZSkge1xuICAgIHBhcmFtcy5jb21wbGV0ZSh0aW1lLCBtZW0sIHBhcmFtcywgZXhwb3J0cy5hdmVyYWdlKHRpbWUpWzBdLCBleHBvcnRzLmF2ZXJhZ2UodGltZSlbMV0pXG4gIH0gZWxzZSB7XG4gICAgaWYoZGVidWcubGV2ZWwudGVzdD4wKSB7XG4gICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgcGFyYW1zLm5hbWUuaW52ZXJzZSBcbiAgICAgICAgLCAnIG49JyArIHBhcmFtcy5sb29wIFxuICAgICAgICArICdcXG5wYXJzZSB0aW1lOicgXG4gICAgICAgICsgKHBhcmFtcy5leHRlbnNpdmUgXG4gICAgICAgICAgPyAoJyBcXG5cXG4nICsgdGltZS5qb2luKCcgc2VjXFxuJykgKyAnIHNlY1xcblxcbicpIFxuICAgICAgICAgIDogJycpIFxuICAgICAgICArICdhdmVyYWdlOiAnICsgZXhwb3J0cy5hdmVyYWdlKHRpbWUpWzFdIFxuICAgICAgICArICcgc2VjXFxudG90YWw6ICcgXG4gICAgICAgICsgZXhwb3J0cy5hdmVyYWdlKHRpbWUpWzBdICsgJyBzZWMnKVxuICAgIH1cbiAgICAvLysobWVtLmxlbmd0aD4wID8gJ1xcbm1lbW9yeSB1c2VkIChhcHByb3hpbWF0ZSk6ICcrbWVtKycga2InIDogJycpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJhbXMsIGZuKSB7XG4gIGlmIChmbiAmJiB0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBfdGVzdChmbiwgcGFyYW1zKVxuICB9IFxuICBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIF90ZXN0KHBhcmFtcylcbiAgfSBcbiAgZWxzZSBpZiAocGFyYW1zIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgaWYoIXBhcmFtcy5uYW1lKSBwYXJhbXMubmFtZSA9ICdwZXJmb3JtYW5jZSB0ZXN0J1xuXG4gICAgaWYgKHBhcmFtcy5sb29wKSB7XG4gICAgICAvL3Rlc3RpbmcgbWVtb3J5IGluIGxvb3AgaXMgaGFyZCBzaW5jZSB0aGUgZ2MgYWxtb3N0IG5ldmVyIG1ha2VzIGl0IGJlZm9yZSBuZXh0IGl0ZXJhdGlvbjtcbiAgICAgIHZhciB0aW1lID0gW11cbiAgICAgICAgLCBtZW0gPSBbXVxuICAgICAgICAsIGNhbGxiYWNrID0gZnVuY3Rpb24gKF90aW1lLCBtZW1vcnkpIHtcbiAgICAgICAgICB0aW1lLnB1c2goX3RpbWUpXG4gICAgICAgICAgaWYgKG1lbW9yeSkgbWVtLnB1c2gobWVtb3J5KVxuICAgICAgICB9XG5cbiAgICAgIGlmKHBhcmFtcy5pbnRlcnZhbCkge1xuICAgICAgICB2YXIgY250ID0gMFxuICAgICAgICAgICwgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgY250KytcbiAgICAgICAgICAgICAgaWYoY250PT09cGFyYW1zLmxvb3AtMSkge1xuICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKVxuICAgICAgICAgICAgICAgICBfZG9uZShwYXJhbXMsIHRpbWUsIG1lbSkgXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3Rlc3QocGFyYW1zLm1ldGhvZCwgZmFsc2UsIGNhbGxiYWNrKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LHBhcmFtcy5pbnRlcnZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBwYXJhbXMubG9vcDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgIF90ZXN0KHBhcmFtcy5tZXRob2QsIGZhbHNlLCBjYWxsYmFjaylcbiAgICAgICAgfVxuICAgICAgICBfZG9uZShwYXJhbXMsIHRpbWUsIG1lbSkgXG4gICAgICB9IFxuICAgICAgcmV0dXJuIGV4cG9ydHMuYXZlcmFnZSh0aW1lKVxuICAgIH0gXG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gX3Rlc3QocGFyYW1zLm1ldGhvZFxuICAgICAgICAsIHBhcmFtcy5uYW1lXG4gICAgICAgICwgcGFyYW1zLmNvbXBsZXRlXG4gICAgICAgICwgcGFyYW1zLmNhbGxcbiAgICAgICAgLCBwYXJhbXMuYXJnc1xuICAgICAgICAsIHBhcmFtcy5ub2xvZylcbiAgICB9XG4gIH1cbn1cblxuaWYoZGVidWcubG9nKSBkZWJ1Zy5sb2cuZGVmYXVsdCgndGVzdCcsIDQpXG5cbmV4cG9ydHMubm93ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNOb2RlXG4gICAgPyBwcm9jZXNzLmhydGltZSgpWzBdICogMTAwMCArIHByb2Nlc3MuaHJ0aW1lKClbMV0gKiAwLjAwMDAwMSBcbiAgICA6ICh3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyBcbiAgICAgID8gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpIFxuICAgICAgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSlcbn1cblxuZXhwb3J0cy5tZW1vcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc05vZGUgXG4gICAgPyBwcm9jZXNzLm1lbW9yeVVzYWdlKCkuaGVhcFVzZWQgXG4gICAgOiAod2luZG93ICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2UubWVtb3J5IFxuICAgICAgPyB3aW5kb3cucGVyZm9ybWFuY2UubWVtb3J5LnVzZWRKU0hlYXBTaXplICogMC4wMDA5NzY1NjIgXG4gICAgICA6IDApXG59XG5cbmV4cG9ydHMuYXZlcmFnZSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICB2YXIgbnVtYmVyID0gMFxuICBmb3IgKHZhciBpID0gYXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBudW1iZXIgKz0gYXJyYXlbaV1cbiAgfVxuICByZXR1cm4gW251bWJlciwgbnVtYmVyIC8gYXJyYXkubGVuZ3RoXVxufVxuIiwidmFyIGcgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHdpbmRvd1xuICAgICAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgPyBnbG9iYWxcbiAgICAgICAgICA6IGZhbHNlXG4gICwgaGFzTFMgPSB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJ1xuICAsIGhhc1BSID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG5cbnZhciBHID0gbW9kdWxlLmV4cG9ydHMgPSBcbiAgeyBzZXNzaW9uOiBmdW5jdGlvbihrZXksIHZhbCl7XG4gICAgICByZXR1cm4gZ2V0U2V0KGcsIGtleSwgdmFsKVxuICAgIH1cbiAgLCBlbnY6IGZ1bmN0aW9uKGtleSwgdmFsKXtcbiAgICAgIGlmKGhhc0xTKVxuICAgICAgICByZXR1cm4gZ2V0U2V0KGxvY2FsU3RvcmFnZSwga2V5LCB2YWwsICdnZXRJdGVtJywgJ3NldEl0ZW0nKVxuICAgICAgZWxzZSBpZihoYXNQUilcbiAgICAgICAgcmV0dXJuIGdldFNldChwcm9jZXNzLmVudiwga2V5LCB2YWwpXG4gICAgfVxuICB9XG5cbmZ1bmN0aW9uIGdldFNldCh0aGluZywga2V5LCB2YWwsIGdldHRlciwgc2V0dGVyKXtcbiAgaWYoIXRoaW5nKVxuICAgIHJldHVyblxuXG4gIGlmKHZhbCA9PT0gdm9pZCAwKXtcbiAgICBpZihnZXR0ZXIpXG4gICAgICByZXR1cm4gdGhpbmdbZ2V0dGVyXShrZXkpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaW5nW2tleV1cbiAgfWVsc2V7XG4gICAgaWYoc2V0dGVyKXtcbiAgICAgIHRoaW5nW3NldHRlcl0oa2V5LCB2YWwpXG4gICAgICByZXR1cm4gdmFsXG4gICAgfWVsc2V7XG4gICAgICByZXR1cm4gdGhpbmdba2V5XSA9IHZhbFxuICAgIH1cbiAgfVxufSIsIi8vY2hlY2sgdGhpcyBmb3IgbW9yZSBjb21wcmVzc2lvbiBodHRwOi8vd3d3Lmh0bWxnb29kaWVzLmNvbS9odG1sNS9jbGllbnQvb3B0aW1pemluZy13ZWJzb2NrZXRzLWJhbmR3aWR0aC5odG1sI2ZiaWQ9NlFaeDhuYXB1MjBcblxuLypcbnZhciBjcmNUYWJsZVxuICAsIGNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGNyY1RhYmxlID0gW11cbiAgICAgIGZvciAodmFyIGMsIG4gPSAwLCBrOyBuIDwgMjU2OyBjID0gKytuKSB7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCA4OyBrKyssIGMgPSAoKGMgJiAxKSA/ICgoMHhFREI4ODMyMCkgXiAoYyA+Pj4gMSkpIDogKGMgPj4+IDEpKSk7XG4gICAgICAgIGNyY1RhYmxlW25dID0gY1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyY1RhYmxlXG4gICAgfVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gIGZvciAodmFyIHRhYiA9IGNyY1RhYmxlIHx8IGNyZWF0ZSgpLCBjcmMgPSAtMSwgaSA9IDAsIGwgPSBzdHIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0YWJbKGNyYyBeIHN0ci5jaGFyQ29kZUF0KGkpKSAmIDB4RkZdXG4gIH1cbiAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlKCgoY3JjIF4gKC0xKSkgPj4+IDApKVxufVxuXG5cbiovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGtleSwgc2VlZCkge1xuICB2YXIgcmVtYWluZGVyLCBieXRlcywgaDEsIGgxYiwgYzEsIGMxYiwgYzIsIGMyYiwgazEsIGk7XG4gIHNlZWQgPSAxXG5cbiAgcmVtYWluZGVyID0ga2V5Lmxlbmd0aCAmIDM7IC8vIGtleS5sZW5ndGggJSA0XG4gIGJ5dGVzID0ga2V5Lmxlbmd0aCAtIHJlbWFpbmRlcjtcbiAgaDEgPSBzZWVkO1xuICBjMSA9IDB4Y2M5ZTJkNTE7XG4gIGMyID0gMHgxYjg3MzU5MztcbiAgaSA9IDA7XG4gIFxuICB3aGlsZSAoaSA8IGJ5dGVzKSB7XG4gICAgICBrMSA9IFxuICAgICAgICAoKGtleS5jaGFyQ29kZUF0KGkpICYgMHhmZikpIHxcbiAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgOCkgfFxuICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAxNikgfFxuICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAyNCk7XG4gICAgKytpO1xuICAgIFxuICAgIGsxID0gKCgoKGsxICYgMHhmZmZmKSAqIGMxKSArICgoKChrMSA+Pj4gMTYpICogYzEpICYgMHhmZmZmKSA8PCAxNikpKSAmIDB4ZmZmZmZmZmY7XG4gICAgazEgPSAoazEgPDwgMTUpIHwgKGsxID4+PiAxNyk7XG4gICAgazEgPSAoKCgoazEgJiAweGZmZmYpICogYzIpICsgKCgoKGsxID4+PiAxNikgKiBjMikgJiAweGZmZmYpIDw8IDE2KSkpICYgMHhmZmZmZmZmZjtcblxuICAgIGgxIF49IGsxO1xuICAgICAgICBoMSA9IChoMSA8PCAxMykgfCAoaDEgPj4+IDE5KTtcbiAgICBoMWIgPSAoKCgoaDEgJiAweGZmZmYpICogNSkgKyAoKCgoaDEgPj4+IDE2KSAqIDUpICYgMHhmZmZmKSA8PCAxNikpKSAmIDB4ZmZmZmZmZmY7XG4gICAgaDEgPSAoKChoMWIgJiAweGZmZmYpICsgMHg2YjY0KSArICgoKChoMWIgPj4+IDE2KSArIDB4ZTY1NCkgJiAweGZmZmYpIDw8IDE2KSk7XG4gIH1cbiAgXG4gIGsxID0gMDtcbiAgXG4gIHN3aXRjaCAocmVtYWluZGVyKSB7XG4gICAgY2FzZSAzOiBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG4gICAgY2FzZSAyOiBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSArIDEpICYgMHhmZikgPDwgODtcbiAgICBjYXNlIDE6IGsxIF49IChrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmYpO1xuICAgIFxuICAgIGsxID0gKCgoazEgJiAweGZmZmYpICogYzEpICsgKCgoKGsxID4+PiAxNikgKiBjMSkgJiAweGZmZmYpIDw8IDE2KSkgJiAweGZmZmZmZmZmO1xuICAgIGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpO1xuICAgIGsxID0gKCgoazEgJiAweGZmZmYpICogYzIpICsgKCgoKGsxID4+PiAxNikgKiBjMikgJiAweGZmZmYpIDw8IDE2KSkgJiAweGZmZmZmZmZmO1xuICAgIGgxIF49IGsxO1xuICB9XG4gIFxuICBoMSBePSBrZXkubGVuZ3RoO1xuXG4gIGgxIF49IGgxID4+PiAxNjtcbiAgaDEgPSAoKChoMSAmIDB4ZmZmZikgKiAweDg1ZWJjYTZiKSArICgoKChoMSA+Pj4gMTYpICogMHg4NWViY2E2YikgJiAweGZmZmYpIDw8IDE2KSkgJiAweGZmZmZmZmZmO1xuICBoMSBePSBoMSA+Pj4gMTM7XG4gIGgxID0gKCgoKGgxICYgMHhmZmZmKSAqIDB4YzJiMmFlMzUpICsgKCgoKGgxID4+PiAxNikgKiAweGMyYjJhZTM1KSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICBoMSBePSBoMSA+Pj4gMTY7XG5cbiAgcmV0dXJuIChoMSA+Pj4gMCkudG9TdHJpbmcoMzYpXG59XG5cbi8vIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCBzdHIgKVxuLy8ge1xuLy8gICB2YXIgRk5WMV8zMkFfSU5JVCA9IDB4ODExYzlkYzU7XG4vLyAgIHZhciBodmFsID0gRk5WMV8zMkFfSU5JVDtcbi8vICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpIClcbi8vICAge1xuLy8gICAgIGh2YWwgXj0gc3RyLmNoYXJDb2RlQXQoaSk7XG4vLyAgICAgaHZhbCArPSAoaHZhbCA8PCAxKSArIChodmFsIDw8IDQpICsgKGh2YWwgPDwgNykgKyAoaHZhbCA8PCA4KSArIChodmFsIDw8IDI0KTtcbi8vICAgfVxuLy8gICByZXR1cm4gaHZhbCA+Pj4gMDtcbi8vIH1cblxuLyoqXG4gKiBFbmNvZGUgdG8gYmFzZSA2MiAodXJsIHNhdmUpXG4qL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBjIChhLCBiKSB7XG4gIGIgPSBiIHx8IFwiXCJcbiAgcmV0dXJuIH5+IGEgXG4gICAgICAgPyBjKGEgLyA2MiwgU3RyaW5nLmZyb21DaGFyQ29kZSgoKGEgJT0gNjIpID4gOSBcbiAgICAgICAgICA/IGEgPiAzNSA/IDI5IDogODcgXG4gICAgICAgICAgOiA0OCkgKyBhKSArIGIpIFxuICAgICAgIDogYlxufVxuXG4vKipcbiAqIGRlY29kZSBiYXNlIDYyXG4qL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICBmb3IgKGIgPSBjID0gMDsgZCA9IGEuY2hhckNvZGVBdChjKyspOyBiID0gYiAqIDYyICsgZCAtIFsgLCA0OCwgMjksIDg3XVtkID4+IDVdKTtcbiAgcmV0dXJuIGJcbn1cblxuXG4vLyBleHBvcnRzLmRlY29kZTY0XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlkKHByZSwgbGV2ZWwpe1xuICB2YXIgciA9IHJuZCgpXG4gIGlmKGxldmVsKSBcbiAgICB3aGlsZShsZXZlbC0tKXtcbiAgICAgIHIgKz0gcm5kKClcbiAgICB9XG4gIHJldHVybiBwcmUgPyBwcmUgKyByIDogclxufVxuXG5mdW5jdGlvbiBybmQoKXtcbiAgcmV0dXJuIE51bWJlcihTdHJpbmcoTWF0aC5yYW5kb20oKSkuc2xpY2UoMikpLnRvU3RyaW5nKDM2KVxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnJlcXVpcmUoJy4vb2JqZWN0JykgLy90aGVzZSB0aGluZ3MgYWRkIGV4dHJhIG1ldGhvZHMgdG8gdXRpbCBmb3IgcmVhZGFiaWxpdHkgaW4gYSBzZXBlcmF0ZSBtb2R1bGVcbnJlcXVpcmUoJy4vcHJvcCcpXG5cblxuZXhwb3J0cy5pc05vZGUgPSAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpID8gdHJ1ZSA6IGZhbHNlXG5cbi8qKlxuICogQWRkIGlzIHNpbWlsYXIgdG8gLnB1c2ggaXQgcmV0dXJucyB0aGUgYXJyYXkgaW5zdGVhZCBvZiBsZW5ndGhcbiAqIENhbiBiZSBleHRlbmRlZCB0byBzdXBwb3J0IG1vcmUgdHlwZXMgZS5nLiBhZGQgYW4gb2JqZWN0IHRvIGFub3RoZXJcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0gIHtBcnJheX0gIG9iaiBUYXJnZXRcbiAqIEBwYXJhbSAge09iamVjdH0gYWRkIE9iamVjdCB0byBhZGRcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24gKG9iaiwgYWRkKSB7XG4gIGlmIChhZGQpIG9iai5wdXNoLmFwcGx5KG9iaiwgYWRkKTtcbiAgcmV0dXJuIG9ialxufVxuXG4vKipcbiAqIEZpbmRzIGl0ZW1zIGluIGFuIGFycmF5XG4gKiBAbWV0aG9kIGNoZWNrQXJyYXlcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gICAgICAgICAgICAgICAgIGxpc3QgIERlZmluZXMgdGhlIGxpc3Qgd2hlcmUgeW91IHdhbnQgdG8gc2VhcmNoIHRocm91Z2gsIG9ubHkgdXNlcyAubGVuZ3RoIGZpZWxkXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgICAgICB2YWwgICBEZWZpbmVzIHRoZSB2YWx1ZSB5b3Ugd2FudCB0byBzZWFyY2ggZm9yXG4gKiBAcGFyYW0gIHtCb29sZWFufFN0cmluZ3xOdW1iZXJ9ICAgICAgICBbaW5kZXhdIFdoZW4gaW5kZXggaXMgdHJ1ZSByZXR1cm4gdGhlIGluZGV4IGluc3RlYWQgb2YgdHJ1ZSBvciBmYWxzZSwgd2hlbiBpbmRleCBhbmQgaW5kZXggIT09IHRydWUgaW5kZXggaXMgdXNlZCBhcyBhIGZpZWxkIGluIG9iamVjdHMgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgICAgICBbZmllbGRdIFdoZW4gZmllbGQgcmV0dXJuIGZpZWxkIGluc3RlYWQgb2YgaW5kZXggb3IgdHJ1ZVxuICogQHJldHVybiB7Kn1cbiAqL1xuZXhwb3J0cy5jaGVja0FycmF5ID0gZnVuY3Rpb24gKGxpc3QsIHZhbCwgaW5kZXgsIGZpZWxkKSB7XG4gIHZhciBhcnIgPSBpbmRleCBpbnN0YW5jZW9mIEFycmF5XG4gIGlmKCFsaXN0KSByZXR1cm4gZmFsc2VcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aCwgdDsgaSA8IGw7IGkrKykge1xuICAgIHQgPSBsaXN0W2ldXG4gICAgaWYgKGluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIGlmIChpbmRleCA9PT0gdHJ1ZSkge1xuICAgICAgICBpZiAodCA9PT0gdmFsKSByZXR1cm4gaVxuICAgICAgfSBlbHNlIGlmIChhcnIgPyBleHBvcnRzLnBhdGgodCxpbmRleCk9PT12YWwgOiB0W2luZGV4XSA9PT0gdmFsKSByZXR1cm4gZmllbGQgPyB0IDogaVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodCA9PT0gdmFsKSByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBQYXNzIGFyZ3VtZW50cyAoYXJndW1lbnRzKSBhbmQgcmV0dXJuIGEgbmV3IGFycmF5LCB3aGVuIGluZGV4IHJldHVybiBhIG5ldyBhcnJheSBzbGljZWQgZnJvbSBpbmRleFxuICogQG1ldGhvZCBhcmdcbiAqIEBwYXJhbSAge0FyZ3VtZW50c30gYXJncyAgICAgICAgQXJndW1lbnRzXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIFtpbmRleCA9IDBdIFdoZW4gaW5kZXggcmV0dXJuIGEgbmV3IGFycmF5IHNsaWNlZCBmcm9tIGluZGV4XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuZXhwb3J0cy5hcmcgPSBmdW5jdGlvbiAoYXJncywgaW5kZXgpIHtcbiAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsICFpbmRleCA/IDAgOiBpbmRleClcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBvYmogaXMgZW1wdHkgZXhjbHVkZSBmaWVsZCBuYW1lcyBwYXNzZWQgdG8gbGlzdFxuICogQG1ldGhvZCBlbXB0eVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBvYmogIE9iamVjdFxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSBsaXN0IFRha2VzIGFueSBvYmplY3Qgd2l0aCAubGVuZ3RoXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgVHJ1ZS9mYWxzZVxuICovXG5leHBvcnRzLmVtcHR5ID0gZnVuY3Rpb24gKG9iaiwgbGlzdCkge1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmICghbGlzdCB8fCAhdGhpcy5jaGVja0FycmF5KGxpc3QsIGkpKSByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnRzLmluamVjdCA9IHJlcXVpcmUoJy4vaW5qZWN0JylcbiIsIlxudmFyIFYgPSByZXF1aXJlKCcuLi8nKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLycpXG5cbnZhciAkVEVTVFxuaWYoIXV0aWwuaXNOb2RlKSB7XG4gICRURVNUID0gd2luZG93LiRURVNUXG59XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbihleHRlbmQpIHtcblxuICB2YXIgYXJncyA9IGFyZ3VtZW50c1xuXG4gIGlmKGFyZ3NbMF0mJmFyZ3NbMF0uJFRFU1QpIHtcbiAgICAgJFRFU1QgPSB3aW5kb3cuJFRFU1QgPSB0cnVlXG4gIH1cblxuICBpZiggKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nKSB8fCAoVi5CYXNlICYmICh0aGlzIGluc3RhbmNlb2YgVi5CYXNlKSkgfHwgdHlwZW9mIHRoaXMgPT09ICdvYmplY3QnKSB7XG4gICAgaWYoKFYuQmFzZSBcbiAgICAgICAgJiYgKHRoaXM9PT1WLkJhc2UgXG4gICAgICAgIHx8ICh0aGlzLnByb3RvdHlwZSBpbnN0YW5jZW9mIFYuQmFzZSlcbiAgICAgICAgfHwgKHRoaXMgaW5zdGFuY2VvZiBWLkJhc2UpKVxuICAgICAgKSkgeyBcbiAgICAgIGFyZ3MgPSB1dGlsLmFyZyhhcmdzKVxuICAgICAgYXJncy51bnNoaWZ0KHRoaXMpXG4gICAgICBleHRlbmQgPSB0aGlzXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbmplY3QuYXBwbHkodGhpcyxhcmdzKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGkgPSAxOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgbWFrZUV4dGVuZChleHRlbmQsIGFyZ3NbaV0pXG4gIH1cbiAgcmV0dXJuIGV4dGVuZFxufVxuXG5mdW5jdGlvbiBtYWtlRXh0ZW5kKGV4dGVuZCwgbW9kdWxlKSB7XG4gIGlmKCRURVNUKSBjb25zb2xlLmxvZygnOScsIG1vZHVsZSwgZXh0ZW5kKVxuICBpZihtb2R1bGUuZXh0ZW5kKSB7XG4gICAgaWYoJFRFU1QpIGNvbnNvbGUubG9nKCc5LjEnLCBleHRlbmQpXG4gICAgIG1vZHVsZS5leHRlbmQoZXh0ZW5kKVxuICB9IGVsc2UgaWYobW9kdWxlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgYXJyID0gbW9kdWxlLmNvbmNhdCgpXG4gICAgICAsIG1vZCA9IGFyclswXVxuICAgIGFyclswXSA9IGV4dGVuZFxuICAgICBpZigkVEVTVCkgY29uc29sZS5sb2coJzkuMicpXG4gICAgbW9kLmV4dGVuZC5hcHBseShtb2QsYXJyKVxuICB9IFxufSBcblxuZnVuY3Rpb24gaW5qZWN0KCkge1xuICBpZigkVEVTVCkgY29uc29sZS5sb2coJzUnKVxuICAvL2RvIHNwZWNpYWwgc3R1ZmYgdm9vciBibGFja2xpc3RcbiAgLy8gQ3VzdG9tLnByb3RvdHlwZSA9IG5ldyB0aGlzKCkgLy9saWdodGVyXG4gIHZhciBDdXN0b21cbiAgICAsIGV4dGVuZFJlc2lkdWUgPSBbXVxuICAgICwgQXNwZWN0cyA9IFt0aGlzXVxuXG4gIGZvciAodmFyIGkgPSAwLCBBc3BlY3QsIGFyZ3MgPSBhcmd1bWVudHMsIGxlbiA9IGFyZ3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBcbiAgICBBc3BlY3QgPSBhcmdzW2ldXG5cbiAgICBpZih0eXBlb2YgQXNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZighQ3VzdG9tKSB7XG4gICAgICAgIEN1c3RvbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBBc3BlY3RzLmxlbmd0aDsgaiA8IGxlbjsgIGorKykge1xuICAgICAgICAgICAgQXNwZWN0c1tqXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluaGVyaXRzKCBDdXN0b20sIHRoaXMgKVxuICAgICAgfVxuICAgICAgQXNwZWN0cy5wdXNoKEFzcGVjdClcbiAgICAgIGZvciAodmFyIG1ldGhvZCQgaW4gQXNwZWN0LnByb3RvdHlwZSkgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoQXNwZWN0LnByb3RvdHlwZSwgbWV0aG9kJCkpIHtcbiAgICAgICAgaWYgKG1ldGhvZCQgPT09ICdjb25zdHJ1Y3RvcicpIGNvbnRpbnVlXG4gICAgICAgIEN1c3RvbS5wcm90b3R5cGVbbWV0aG9kJF0gPSBBc3BlY3QucHJvdG90eXBlW21ldGhvZCRdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKCRURVNUKSBjb25zb2xlLmxvZygnNicpXG4gICAgICBpZihDdXN0b20pIHtcbiAgICAgICAgICAgICAgaWYoJFRFU1QpIGNvbnNvbGUubG9nKCc3JylcblxuICAgICAgIG1ha2VFeHRlbmQoQ3VzdG9tICwgQXNwZWN0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYoJFRFU1QpIGNvbnNvbGUubG9nKCc4JylcbiAgICAgICAgZXh0ZW5kUmVzaWR1ZS5wdXNoKEFzcGVjdClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZighQ3VzdG9tKSBDdXN0b20gPSB0aGlzXG4gIFxuICBmb3IodmFyIGogaW4gZXh0ZW5kUmVzaWR1ZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCc4LicraiwgZXh0ZW5kUmVzaWR1ZVtqXSwgQ3VzdG9tKVxuICAgIG1ha2VFeHRlbmQoQ3VzdG9tLGV4dGVuZFJlc2lkdWVbal0pXG4gIH1cblxuICByZXR1cm4gQ3VzdG9tXG59XG5cbmZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGVcbiAgICAoIHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAsIHsgY29uc3RydWN0b3I6IFxuICAgICAgICB7IHZhbHVlOiBjdG9yXG4gICAgICAgICwgZW51bWVyYWJsZTogZmFsc2VcbiAgICAgICAgLCB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxufVxuXG4vKlxuIERpdCBtb2V0IHdvcmRlbiBnZWFkZCB2b29yIFYuT2JqZWN0c1xuLypcbiAgb2JqZWN0Lm5ldyA9IGZ1bmN0aW9uKHBhcmFtcywgY29uc3RydWN0b3IpIHtcbiAgdmFyIHZPYmogPSBmdW5jdGlvbih2YWwsIGhvb2ssIHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudCkgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gICAgICBpZiAoaG9vayAmJiB0aGlzLl9ob29rKSB0aGlzLl9ob29rKHZhbCwgaG9vaylcbiAgICAgIGlmICh0aGlzLl9vbkNvbnN0cnVjdCkgdGhpcy5fb25Db25zdHJ1Y3QodmFsLCBob29rKVxuICAgICAgaWYgKHZhbCAhPT0gdm9pZCAwKSB0aGlzLnZhbCA9IHZhbFxuICAgICAgLy8gY29uc29sZS5sb2coY29uc3RydWN0b3IpXG4gICAgICBpZihjb25zdHJ1Y3RvcikgY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpICBcbiAgICB9LFxuICAgIHByb3RvID0gdk9iai5wcm90b3R5cGUgPSBuZXcgdGhpcygpXG4gIHZPYmoubmV3ID0gb2JqZWN0Lm5ld1xuICB1dGlsLmRlZmluZSh2T2JqLCAnX2JsYWNrbGlzdCcsIHByb3RvLl9ibGFja2xpc3QuY29uY2F0KCkpXG4gIF9wYXJhbXMuY2FsbCh2T2JqLCBwYXJhbXMsIFsnbWl4ZWQnLCAnbWVyZ2UnXSlcbiAgdXRpbC5kZWZpbmUodk9iaiwgJ19jbGFzcycsIHZPYmopXG4gIHJldHVybiB2T2JqXG59XG5cbnZlZWwgZGluZ2VuIHdlcmtlbiBhbHMgZXh0ZW5zaW9uIG5pZXQgYWxzIGxvc3NlIGNsYXNzIC0tIFxuXG4qL1xuXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHJlcXVpcmUoJy4vJylcbiAgLCB2aWdvdXIgPSByZXF1aXJlKCcuLi8nKSAvL29ubHkgaGVyZSB0byBiZSBhYmxlIHRvIHVzZSB1dGlsIHdpdGhvdXQgdmlnb3VyLk9iamVjdCBtYXliZSByZWZhY3RvciB0aGlzIGF3YXk/XG4gICwgRE9UID0gJy4nXG5cbi8qKlxuICogbG9va3VwXG4gKiBwb2x5ZmlsbCBpZiBfX2xvb2t1cFNldHRlcl9fIGRvZXMgbm90IGV4aXN0O1xuICovXG5leHBvcnRzLmxvb2t1cCA9IE9iamVjdC5fX2xvb2t1cFNldHRlcl9fIHx8IGZ1bmN0aW9uIChpKSB7XG4gIHZhciB0ID0gdGhpc1xuICAgICwgYVxuICB3aGlsZSAodCkge1xuICAgIGEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIGkpXG4gICAgaWYgKGEgJiYgYS5zZXQpIHJldHVybiB0cnVlXG4gICAgdCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFVzZWQgdG8gc2V0IGEgdmFsIHRvIGFuIGZpZWxkIG9uIGEgb2JqZWN0LCB3aGV0aGVyIGl0IGlzIGEgdmlnb3VyLk9iamVjdCBvciBhIHJlZ3VsYXIgb2JqZWN0XG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAgIERlZmluZXMgdGFyZ2V0IE9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkIFRhcmdldCBmaWVsZFxuICogQHBhcmFtIHsqfSAgICAgIHZhbCAgIFZhbHVlIHRvIHNldFxuICogQHRvZG8gICAgICAgICAgICAgICAgIE1vdmUgdGhpcyBmdW5jdGlvbiB0byBhIGRpZmZlcmVudCBtb2R1bGUgKGUuZy4gJ2NvbnZlbmllbmNlJyBtb2R1bGUpXG4gKi9cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24gKG9iaiwgZmllbGQsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlKSB7XG4gIHJldHVybiAodmlnb3VyLk9iamVjdCAmJiAob2JqIGluc3RhbmNlb2Ygdmlnb3VyLk9iamVjdCkpXG4gICAgPyBvYmouc2V0KGZpZWxkLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSlcbiAgICA6IChvYmpbZmllbGRdID0gdmFsKVxufVxuXG5cbi8qKlxuICogUmV0dXJucyBvYmplY3Qgb24gdGhlIGVuZCBvZiBhIGRlZmluZWQgcGF0aFxuICogQG1ldGhvZCBwYXRoXG4gKiBAZXhhbXBsZVxuICogLy8gcmV0dXJucyBvYmouYS5iLmNcbiAqIHZhciBvYmogPSB7IGE6IHsgYjogeyBjOiAxIH19fVxuICogVi51dGlsLm9iamVjdC5wYXRoKG9iaixbJ2EnLCdiJywnYyddKVxuICogQHBhcmFtICB7T2JqZWN0fSAgICBvYmogICAgICAgICAgICBPYmplY3QgdG8gc2VhcmNoXG4gKiBAcGFyYW0gIHtBcnJheX0gICAgIHBhdGggICAgICAgICAgIEFycmF5IG9mIGZpZWxkcyBpbiBwYXRoXG4gKiBAcGFyYW0gIHsqfSAgICAgICAgIFt2YWxdICAgICAgICAgIFdoZW4gZGVmaW5lZCwgdmFsIHdpbGwgYmUgc2V0IG9uIGVuZHBvaW50IG9mIHBhdGggaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICogQHBhcmFtICB7Qm9vbGVhbn0gICBbb3ZlcndyaXRlXSAgICBJZiB0cnVlLCB2YWwgV0lMTCBvdmVyd3JpdGUgZXhpc3RpbmcgdmFsdWUgb24gZW5kcG9pbnQgb2YgcGF0aCB3aGVuIGFscmVhZHkgZGVmaW5lZFxuICogQHBhcmFtICB7RnVuY3Rpb259ICBbd3JpdGVIYW5kbGVyXSBDYWxsYmFjayBvbiB3cml0ZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICBbbm91cGRhdGVdICAgICBXaGVuIHRydWUsIHVwZGF0ZXMgd2lsbCBiZSBza2lwcGVkIG9uIHdyaXRlXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIFtpID0gMF0gICAgICAgIFN0YXJ0aW5nIHBvaW50IGZvciBzZWFyY2hpbmcgdGhyb3VnaCBwYXRoXG4gKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBvbiB0aGUgZW5kIG9mIGEgZGVmaW5lZCBwYXRoXG4gKi9cblxuZXhwb3J0cy5wYXRoID0gZnVuY3Rpb24gKCBvYmosIHBhdGgsIHZhbCwgb3ZlcndyaXRlLCB3cml0ZUhhbmRsZXIsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgc2VsZiwgdWlkLCBpICkge1xuICBpZiAoIWkpIGkgPSAwXG5cbiAgdmFyIGZpZWxkID0gcGF0aFtpXVxuICAgICwgcmVzdWx0XG4gICAgLCBjXG4gICAgLCB0YXJnZXQgPSAoIXNlbGYgJiYgb2JqICYmIG9iai5fX3QgPT09IDQpID8gb2JqLmZyb21bZmllbGRdIDogb2JqICYmIG9ialtmaWVsZF1cbiAgICAsIGwgPSBpIDwgcGF0aC5sZW5ndGggLSAxXG5cbiAgLy8gaWYoZmllbGQgPT09IHZvaWQgMCkge1xuICAvLyAgIHRocm93IG5ldyBFcnJvcigncGF0aCBtdXN0IG5vdCBjb250YWluIHVuZGVmaW5lZCcpXG4gIC8vIH1cblxuICBpZiAobCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIE9iamVjdCkpIHRhcmdldCA9IHZvaWQgMFxuXG4gIGlmICgodmFsICE9PSB2b2lkIDApICYmICh0YXJnZXQgPT09IHZvaWQgMCB8fCAoIWwgJiYgb3ZlcndyaXRlKSkpIHtcbiAgICBjID0gdHJ1ZVxuICAgIGV4cG9ydHMuc2V0KG9iaiwgZmllbGQsIGwgPyB7fSA6IHZhbCwgbCA/IGZhbHNlIDogdm9iaiwgc3RhbXAsIG5vdXBkYXRlKVxuICAgIHRhcmdldCA9IG9ialtmaWVsZF1cbiAgfVxuXG4gIGlmIChsKSB7XG4gICAgcmVzdWx0ID0gdGFyZ2V0XG4gICAgICA/IHRoaXMucGF0aCh0YXJnZXQsIHBhdGgsIHZhbCwgb3ZlcndyaXRlLCB3cml0ZUhhbmRsZXIsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgc2VsZiwgdWlkLCArK2kpXG4gICAgICA6IHRhcmdldFxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICghc2VsZiAmJiB0YXJnZXQgJiYgdGFyZ2V0Ll9fdCA9PT0gNCkgPyB0YXJnZXQuZnJvbSA6IHRhcmdldDtcbiAgICBpZiAoYyAmJiB3cml0ZUhhbmRsZXIpIHdyaXRlSGFuZGxlcihyZXN1bHQpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQWRkcyBwYXRoIHVzaW5nICdkb3Qtbm90YXRpb24nXG4gKiBAbWV0aG9kIGRvdEZpZWxkXG4gKiBAZXhhbXBsZVxuICogLy8gcmV0dXJucyBibHVyOntkOnthOntzOnt9fX19XG4gKiB2YXIgYmx1ciA9IHt9O1xuICogVi51dGlsLm9iamVjdC5kb3RGaWVsZChibHVyLCdkLmEucycpO1xuICogQHBhcmFtICB7T2JqZWN0fSBvYmogICBPYmplY3Qgd2hlcmUgZmllbGQgd2lsbCBiZSBhZGRlZFxuICogQHBhcmFtICB7U3RyaW5nfSBmaWVsZCBTdHJpbmcgdXNpbmcgJ2RvdC1ub3RhdGlvbidcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgUmV0dXJucyBmaWVsZFxuICovXG5leHBvcnRzLmRvdEZpZWxkID0gZnVuY3Rpb24gKG9iaiwgZmllbGQpIHtcbiAgaWYgKH5maWVsZC5pbmRleE9mKERPVCkpIHtcbiAgICB2YXIgcGF0aCA9IGZpZWxkLnNwbGl0KERPVClcbiAgICAgICwgZmlyc3QgPSBwYXRoLnNoaWZ0KClcbiAgICAgICwgdmFsID0ge31cbiAgICB0aGlzLnBhdGgodmFsLCBwYXRoLCBvYmpbZmllbGRdKVxuICAgIGRlbGV0ZSBvYmpbZmllbGRdXG4gICAgb2JqW2ZpcnN0XSA9IHZhbFxuICAgIGZpZWxkID0gZmlyc3RcbiAgfVxuICByZXR1cm4gZmllbGRcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGxpc3RzIGNvbnRhaW4gaWRlbnRpY2FsIGNvbnRlbnRcbiAqIEBtZXRob2QgY29tcGFyZUFycmF5c1xuICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSBhICAgICAgICAgVGFrZXMgYW55IG9iamVjdCB3aXRoIC5sZW5ndGhcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gYiAgICAgICAgIFRha2VzIGFueSBvYmplY3RcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAga2V5cyAgICAgIHVzZSBPYmplY3Qua2V5cyBmb3IgYlxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICBUcnVlL2ZhbHNlXG4gKiBAdG9kbyAgICAgICAgICAgICAgICAgIE1heWJlIGNoYW5nZSB0aXRsZSA9PiBjb21wYXJlTGlzdHNcbiAqL1xuZXhwb3J0cy5jb21wYXJlQXJyYXlzID0gZnVuY3Rpb24oYSwgYiwga2V5cykge1xuICB2YXIgYmwgPSBrZXlzID8gT2JqZWN0LmtleXMoYikubGVuZ3RoIDogYi5sZW5ndGhcbiAgaWYgKGEubGVuZ3RoICE9PSBibCkgcmV0dXJuIGZhbHNlXG4gIGZvciAodmFyIGkgPSBhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGFbaV0gIT0gYltpXSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBHZXRzIG9iamVjdCBmcm9tIHNwZWNpZmllZCBwYXRoLiBXaGVuIHBhdGggaXMgYSBzdHJpbmcgY2hlY2tzIGZvciAnZG90bm90YXRpb24nLlxuICogQG1ldGhvZCBnZXRcbiAqIEBleGFtcGxlXG4gKiAvLyByZXR1cm5zICdmb28nXG4gKiB2YXIgYSA9IHtiOntjOidmb28nfX1cbiAqIFYudXRpbC5vYmplY3QuZ2V0KGEsJ2IuYycpXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIG9iaiAgRGVmaW5lcyBvYmplY3Qgb3IgVi5WYWx1ZVxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSBwYXRoIERlZmluZXMgZmllbGQge3N0cmluZ30gb3IgcGF0aCB7YXJyYXl8J2RvdC1ub3RhdGlvbid9XG4gKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgb2JqW3BhdGhdfG5lc3RlZCBvYmplY3QvdmFsdWVcbiAqL1xuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBzZWxmKSB7XG4gIC8vVE9ETzogbWFrZSBvbmUgaW50ZXJmYWNlIGZvciBnZXRcblxuICBpZiAoIW9iaiB8fCAhcGF0aCkgcmV0dXJuXG4gIGlmICghc2VsZiAmJiBvYmouX190ID09PSA0ICYmICFvYmouX2ZpbHRlcikgb2JqID0gb2JqLmZyb21cbiAgaWYgKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIGlmICh+cGF0aC5pbmRleE9mKERPVCkpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KERPVClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICghc2VsZiAmJiBvYmpbcGF0aF0gJiYgb2JqW3BhdGhdLmZyb20pIHx8IG9ialtwYXRoXVxuICAgIH1cbiAgfVxuICAvL3NlbGYgaXMgdG9vIGZhciBhd2F5IGluIHRoZSBhcmd1bWVudHNcbiAgcmV0dXJuIHRoaXMucGF0aChvYmosIHBhdGgsIHZvaWQgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBzZWxmKVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgYW4gb2JqZWN0IGFuZCBub3QgYSBmdW5jdGlvbiAsIFYuT2JqZWN0IG9yIFYuQmFzZVxuICogQG1ldGhvZCBpc09ialxuICogQHBhcmFtICB7T2JqZWN0fSAgb2JqIE9iamVjdCB0byBpbnNwZWN0XG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgVHJ1ZS9GYWxzZVxuICovXG5leHBvcnRzLmlzT2JqID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gKG9iaiBpbnN0YW5jZW9mIE9iamVjdFxuICAgICYmIHR5cGVvZiBvYmogIT09ICdmdW5jdGlvbidcbiAgICAmJiAoIXZpZ291ci5PYmplY3QgfHwgIShvYmogaW5zdGFuY2VvZiB2aWdvdXIuT2JqZWN0KSlcbiAgICAmJiAoIXZpZ291ci5CYXNlIHx8ICEob2JqIGluc3RhbmNlb2Ygdmlnb3VyLkJhc2UpKSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZSAsIHRha2VzIGN1c3RvbSBvYmplY3RzIGludG8gYWNjb3VudCAobmV3IG9iai5jb25zdHJ1Y3RvcigpKVxuICogQG1ldGhvZCBjbG9uZVxuICogQHBhcmFtICB7T2JqZWN0fSBvYmogT2JqZWN0IHRvIGNsb25lXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBSZXR1cm5zIGNsb25lXG4gKi9cbmV4cG9ydHMuY2xvbmUgPSBmdW5jdGlvbiAob2JqLCBleGNsdWRlLCBzaGFsbG93KSB7XG4gIGlmICh0aGlzLmlzT2JqKG9iaikpIHtcbiAgICB2YXIgY29weSA9IG5ldyBvYmouY29uc3RydWN0b3IoKVxuICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICBpZighZXhjbHVkZSB8fCAhZXhjbHVkZVtpXSlcbiAgICAgICAgY29weVtpXSA9ICFzaGFsbG93XG4gICAgICAgICAgPyB0aGlzLmNsb25lKG9ialtpXSwgZXhjbHVkZSlcbiAgICAgICAgICA6IG9ialtpXVxuICAgIH1cbiAgICByZXR1cm4gY29weVxuICB9XG4gIHJldHVybiBvYmpcbn07XG5cbi8qKlxuICogTWVyZ2VzIG9iamVjdCBiIGludG8gb2JqZWN0IGEgYW5kIHJldHVybnMgb2JqZWN0IGFcbiAqIEBtZXRob2QgbWVyZ2VcbiAqIEBwYXJhbSAge09iamVjdH0gYSBPYmplY3QgYVxuICogQHBhcmFtICB7T2JqZWN0fSBiIE9iamVjdCBiXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgT2JqZWN0IGFcbiAqL1xuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uIChhLCBiLCBub3JlZnMsIG92ZXJ3cml0ZSkge1xuICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICB2YXIgYWlzb2JqID0gdXRpbC5pc09iaihhW2ldKVxuICAgICAgLCBiaXNvYmogPSB1dGlsLmlzT2JqKGJbaV0pXG5cbiAgICBpZiAoYWlzb2JqICYmIGJpc29iaikge1xuICAgICAgdXRpbC5tZXJnZShhW2ldLCBiW2ldLCBub3JlZnMsIG92ZXJ3cml0ZSlcbiAgICB9IGVsc2UgaWYoIW5vcmVmcyB8fCAhYmlzb2JqKXtcbiAgICAgIGlmKCBvdmVyd3JpdGUgPT09IHZvaWQgMFxuICAgICAgIHx8ICEoaSBpbiBhKVxuICAgICAgIHx8IHR5cGVvZiBvdmVyd3JpdGUgPT09ICdmdW5jdGlvbicgJiYgb3ZlcndyaXRlKGFbaV0sIGJbaV0pXG4gICAgICAgICl7XG4gICAgICAgIGFbaV0gPSBiW2ldXG4gICAgICB9XG5cbiAgICB9ZWxzZXtcbiAgICAgIGFbaV0gPSBiW2ldIGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9XG4gICAgICB1dGlsLm1lcmdlKGFbaV0sIGJbaV0sIG5vcmVmcywgb3ZlcndyaXRlKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYVxufVxuXG4vLyBleHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbihhLCBiLCBiRnJvbSwgaikge1xuLy8gICB2YXIgc2FtZSA9IHRydWU7XG4vLyAgIGlmKGIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbi8vICAgICBmb3IodmFyIGkgaW4gYikge1xuLy8gICAgICAgaWYoYVtpXSE9PXZvaWQgMCkge1xuLy8gICAgICAgICBpZihleHBvcnRzLnJlc29sdmUoYVtpXSxiW2ldLGJGcm9tID8gYkZyb21baV0gOiBiW2ldLGkpKSB7XG4vLyAgICAgICAgICAgaWYoYkZyb20pIHtcbi8vICAgICAgICAgICAgIGRlbGV0ZSBiRnJvbVtpXVxuLy8gICAgICAgICAgIH1cbi8vICAgICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgICBzYW1lID0gZmFsc2Vcbi8vICAgICAgICAgfVxuLy8gICAgICAgfSBlbHNlIHtcbi8vICAgICAgICAgc2FtZSA9IGZhbHNlXG4vLyAgICAgICB9XG4vLyAgICAgfVxuLy8gICAgIGlmKHNhbWUpIHtcbi8vICAgICAgIGlmKCEoYkZyb20mJmohPT12b2lkIDApKSByZXR1cm4gdHJ1ZVxuLy8gICAgICAgZGVsZXRlIGJGcm9tW2pdXG4vLyAgICAgfVxuLy8gICAgIHJldHVybiBzYW1lO1xuLy8gICB9IGVsc2Uge1xuLy8gICAgIGlmKGE9PWIpIHtcbi8vICAgICAgIGlmKGJGcm9tJiZqIT09dm9pZCAwKSB7XG4vLyAgICAgICAgIGRlbGV0ZSBiRnJvbVtqXVxuLy8gICAgICAgfVxuLy8gICAgICAgcmV0dXJuIHRydWVcbi8vICAgICB9XG4vLyAgIH1cbi8vIH1cblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oYSwgYiwgYkZyb20sIGopIHtcbiAgLy8gY29uc29sZS5sb2coJ2xvbHJlc29sdmVcXG4nLGJGcm9tKVxuICB2YXIgc2FtZSA9IHRydWU7XG4gIGlmKGIgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBmb3IodmFyIGkgaW4gYikge1xuICAgICAgaWYoYVtpXSE9PXZvaWQgMCkge1xuICAgICAgICBpZihleHBvcnRzLnJlc29sdmUoYVtpXSxiW2ldLChiRnJvbSE9PXZvaWQgMCAmJiBiRnJvbSE9PW51bGwpID8gYkZyb21baV0gOiBiW2ldLGkpKSB7XG4gICAgICAgICAgaWYoYkZyb20hPT12b2lkIDAgJiYgYkZyb20hPT1udWxsKSB7XG4gICAgICAgICAgICBpZihiRnJvbVtpXT09PW51bGwpIHtcbiAgICAgICAgICAgICAgc2FtZSA9IGZhbHNlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkZWxldGUgYkZyb21baV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2FtZSA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNhbWUgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBpZihzYW1lKSB7XG4gICAgICBpZighKGJGcm9tJiZqIT09dm9pZCAwKSkgcmV0dXJuIHRydWVcbiAgICAgIGRlbGV0ZSBiRnJvbVtqXVxuICAgIH1cbiAgICByZXR1cm4gc2FtZTtcbiAgfSBlbHNlIHtcbiAgICBpZihhPT1iKSB7XG4gICAgICBpZihiRnJvbSYmaiE9PXZvaWQgMCkge1xuICAgICAgICBkZWxldGUgYkZyb21bal1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkcyB2YWx1ZSB0byBhcnJheSBpZiBpdCBpcyBub3QgY29udGFpbmVkIGluIGFycmF5LCBleGVjdXRlcyBoYW5kbGVyIG9uIGVuY291bnRlcmluZyB2YWwgaW4gYXJyYXlcbiAqIEBtZXRob2QgaW5jbHVkZVxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSAgIG9iaiAgICAgICBUYWtlcyBhbnkgb2JqZWN0IHdpdGggLmxlbmd0aFxuICogQHBhcmFtICB7Kn0gICAgICAgICAgICAgIHZhbCAgICAgICBWYWx1ZSB0byBhZGRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICBbaGFuZGxlcl0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlbmNvdW50ZXJpbmcgdmFsIGluIGFycmF5XG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgYXJyICAgICAgIEluY2x1ZGUgZWxlbWVudHMgb2YgdmFsIHNlcGFyYXRlbHkgcmF0aGVyIHRoYW4gaW5jbHVkaW5nIHZhbCBpdHNlbGZcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgVHJ1ZS9mYWxzZVxuICovXG5leHBvcnRzLmluY2x1ZGUgPSBmdW5jdGlvbiAob2JqLCB2YWwsIGhhbmRsZXIsIGFycikge1xuXG4gIGlmKGFyciAmJiB2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciByZXQgPSBmYWxzZVxuICAgIGZvcih2YXIgaSA9IDAgLCBsZW4gPSB2YWwubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJldCA9IGV4cG9ydHMuaW5jbHVkZShvYmosIHZhbFtpXSwgaGFuZGxlcilcbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgdmFyIGkgPSAwXG4gICAgLCBsID0gb2JqLmxlbmd0aFxuICAgICwgZmllbGRcbiAgICAsIGNoZWNrXG5cbiAgaWYgKG9iai5fX3QgPT09IDEpIHtcbiAgICBmb3IgKDtpIDwgbDsgaSsrKSB7XG4gICAgICBmaWVsZCA9IGNoZWNrID0gb2JqW2ldXG4gICAgICBpZiAoY2hlY2suX190ID09PSA0KSBjaGVjayA9IGNoZWNrLmZyb21cbiAgICAgIGlmIChjaGVjayA9PT0gdmFsIHx8IGNoZWNrLnZhbCA9PT0gdmFsKSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSBoYW5kbGVyKGZpZWxkKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgb2JqLnB1c2godmFsKVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBmb3IgKDtpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAob2JqW2ldID09PSB2YWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIG9iai5wdXNoKHZhbClcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmV4cG9ydHMuY2hhbmdlVHlwZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG4gIHZhciByZXN1bHRcbiAgaWYob2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXN1bHQgPSB7fVxuICAgIGZvcih2YXIgaT0wLGxlbj1vYmoubGVuZ3RoO2k8bGVuO2krKykge1xuICAgICAgcmVzdWx0W2ldPW9ialtpXVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSBbXVxuICAgIGZvcih2YXIgaSBpbiBvYmopIHtcbiAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEVuc3VyZXMgYSB2YWx1ZSBpcyBub3Qgb3IgY29udGFpbnMgbm8gVi5PYmplY3RzLCBvbmx5IHRoZWlyIFwicmF3XCIgdmVyc2lvbnNcbiAqIFRoaXMgbmVlZHMgdG8gYmUgdW5pZmllZCB3aXRoIGNvbnZlcnQsIG9yIGF0IGxlYXN0IGdldCBhIGJldHRlciBuYW1lLlxuICogQG1ldGhvZCByYXdcbiAqIEBwYXJhbSAgeyp9ICAgdmFsICAgdGhlIHZhbHVlIHRvIGJlIHByb2Nlc3NlZFxuICogQHJldHVybiB7Kn0gICAgICAgICB0aGUgcHJvY2Vzc2VkIHZhbHVlXG4gKi9cbmV4cG9ydHMucmF3ID0gZnVuY3Rpb24oIHZhbCwgcnBhcmFtcyApIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiB2aWdvdXIuT2JqZWN0KSB7XG4gICAgICByZXR1cm4gdmFsLnJhd1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0XG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgcmVzdWx0ID0gW11cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5yYXcodmFsW2ldLCBycGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSB7fVxuICAgICAgICBmb3IgKHZhciBmIGluIHZhbCkge1xuICAgICAgICAgIHJlc3VsdFtmXSA9IHRoaXMucmF3KHZhbFtmXSwgcnBhcmFtcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsXG4gIH1cbn1cblxuLy9hZGQgbGV2ZWwgYW5kIHN0b3BzIGZvciBjZXJ0YWluIGJyYW5jaGVzXG5leHBvcnRzLndhbGsgPSBmdW5jdGlvbihvYmosIGZuICkge1xuICBmb3IodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYob2JqW2ldIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBpZighZm4oaSwgb2JqW2ldLCBvYmosIHRydWUpKSB7XG4gICAgICAgIGlmKGV4cG9ydHMud2FsayhvYmpbaV0sIGZuKSkgcmV0dXJuIHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGZuKGksIG9ialtpXSwgb2JqKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmNoZWNrUGFyZW50RmFjdG9yeSA9IGZ1bmN0aW9uKCBwYXJlbnRGaWVsZCApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGZpZWxkLCBnZXQsIGxpbmtzLCBtYXRjaCkge1xuICAgIGlmKGdldCYmZ2V0IT09dHJ1ZSkge1xuICAgICAgbWF0Y2ggPSBnZXRcbiAgICAgIGdldCA9IGZhbHNlXG4gICAgfVxuICAgIHZhciBmaWVsZHMgPSBmaWVsZCBpbnN0YW5jZW9mIHZpZ291ci5PYmplY3QgPyBmYWxzZSA6IGZpZWxkLFxuICAgICAgY3VyciA9IHRoaXMsXG4gICAgICBmb3VuZDtcbiAgICB3aGlsZSAoY3Vycikge1xuICAgICAgZm91bmQgPSBmaWVsZHMgPT09IGZhbHNlID8gY3VyciA9PT0gZmllbGQgOiBleHBvcnRzLmdldChjdXJyLCBmaWVsZHMsICFsaW5rcyk7XG4gICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgaWYobWF0Y2gpIHtcbiAgICAgICAgICBpZihtYXRjaCA9PT0gZm91bmQgfHwgKGZvdW5kIGluc3RhbmNlb2Ygdmlnb3VyLk9iamVjdCkgJiYgZm91bmQudmFsID09PSBtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuICFnZXQgJiYgZmllbGRzID8gY3VyciA6IGZvdW5kO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gIWdldCAmJiBmaWVsZHMgPyBjdXJyIDogZm91bmQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1cnIgPSBjdXJyW3BhcmVudEZpZWxkXTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5kaXNqb2luID0gZnVuY3Rpb24gZGlzam9pbihhLCBiLCBjaGVjaykge1xuICAvLyBjb25zb2xlLmxvZygnZGlzam9pbiEnKVxuICB2YXIgZm5jaGVjayA9IHR5cGVvZiBjaGVjayA9PT0gJ2Z1bmN0aW9uJ1xuICBcbiAgYSA9IGdldEVuZHBvaW50KGEpXG4gIGIgPSBnZXRFbmRwb2ludChiKVxuXG4gIGEuZWFjaChmdW5jdGlvbigpe1xuICAgIHZhciBpdGVtX2EgPSB0aGlzXG4gICAgdmFyIGl0ZW1fYV9mcm9tID0gaXRlbV9hLmZyb21cbiAgICB2YXIgcmVtb3ZlXG4gICAgYi5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgaXRlbV9iID0gdGhpc1xuICAgICAgdmFyIGl0ZW1fYl9mcm9tID0gaXRlbV9iLmZyb21cbiAgICAgIFxuICAgICAgXG4gICAgICBpZihmbmNoZWNrKXtcbiAgICAgICAgcmVtb3ZlID0gY2hlY2soaXRlbV9hX2Zyb20sIGl0ZW1fYl9mcm9tKVxuICAgICAgfSBlbHNlIGlmKGNoZWNrID09PSB0cnVlKXtcbiAgICAgICAgcmVtb3ZlID0gaXRlbV9hX2Zyb20gPT09IGl0ZW1fYl9mcm9tXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnY29tcGFyZSBhJywgaXRlbV9hX2Zyb20ucmF3LCAndG8gYicsIGl0ZW1fYl9mcm9tLnJhdylcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZpZWxkJywgY2hlY2spXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdhOicsIGl0ZW1fYV9mcm9tW2NoZWNrXS52YWwpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdiOicsIGl0ZW1fYl9mcm9tW2NoZWNrXS52YWwpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzYW1lOicsIGl0ZW1fYV9mcm9tW2NoZWNrXS52YWwgPT09IGl0ZW1fYl9mcm9tW2NoZWNrXS52YWwpXG5cbiAgICAgICAgcmVtb3ZlID0gaXRlbV9hX2Zyb21bY2hlY2tdICYmIGl0ZW1fYl9mcm9tW2NoZWNrXSAmJlxuICAgICAgICAgIGl0ZW1fYV9mcm9tW2NoZWNrXS52YWwgPT09IGl0ZW1fYl9mcm9tW2NoZWNrXS52YWxcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVcbiAgICB9KVxuICAgIGlmKHJlbW92ZSl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnWUVTIENIRUNLIFJFTU9WRScpXG4gICAgICAvLyBUT0RPOiBcbiAgICAgIGl0ZW1fYS5yZW1vdmUoKVxuICAgIH1cbiAgfSlcblxufVxuXG5mdW5jdGlvbiBnZXRFbmRwb2ludChvYmope1xuICB3aGlsZShvYmogJiYgb2JqLl9fdCA9PT0gNCAmJiAhb2JqLl9maWx0ZXIpe1xuICAgIG9iaiA9IG9iai5fdmFsXG4gIH1cbiAgcmV0dXJuIG9ialxufVxuIiwiLy9wcm9jZXNzZXNcbnZhciB2T2JqZWN0ID0gcmVxdWlyZSgnLi4vb2JqZWN0JylcblxuLy8gY29uc29sZS5sb2coJ2luaXQgcHJvY2VzcyEnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHt9XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHJlcXVpcmUoJy4vJylcbiAgLCBWID0gcmVxdWlyZSgnLi4vJylcbi8qKlxuICogU2V0c3RvcmVzIGFyZSB1c2VkIHRvIGF2b2lkIHVwZGF0ZXMgdHJvdWdob3V0IHByb3RvdHlwZSBjaGFpbnMgZm9yIGNoYW5nZXMgb2YgZmllbGRzIG9uIG9iamVjdHNcbiAqIEl0IHVzZXMgdHdvIGZpZWxkc1xuICogICAuX18gdG8gaW5kaWNhdGUgb3duIHZhbHVlcyBmb3IgcGllY2VzIG9mIGFuIG9iamVjdCBpbmhlcml0ZWQgdHJvdWdoIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAqICAgLl8gaXMgdGhlIHJlZmVuY2UgYmFjayB0byB0aGUgb2JqZWN0cyBhcyBzdGUgaW4gdGhlIHByb3RvdHlwZVxuICogQGNvbnN0cnVjdG9yIHNldHN0b3JlXG4gKi9cbmV4cG9ydHMuc2V0c3RvcmUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCAhdGhpcy5fXyApIHRoaXMuX18gPSB7fVxufVxuXG4vL1RPRE86IHJlY29uc3RydWN0IHZhbHVlIHVzaW5nIHBpZWNlcyBvZiBvYmplY3RzIGluIF9fXG5cbmV4cG9ydHMuZ2V0U3RvcmUgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgcmV0dXJuIHRoaXMuX18gXG4gICAgICAgICAgPyAoIHRoaXMuX19bbmFtZV0gIT09IHZvaWQgMCBcbiAgICAgICAgICAgID8gdGhpcy5fX1tuYW1lXSBcbiAgICAgICAgICAgIDogdGhpcy5fW25hbWVdXG4gICAgICAgICAgICApIFxuICAgICAgICAgIDogdGhpcy5fICYmIHRoaXMuX1tuYW1lXVxufVxuXG5mdW5jdGlvbiBleHRlbnNpb25zKCBleHRlbmQsIGZuLCBiYXNlLCBhcmdzLCBleHRlbmRlZCApIHtcbiAgICBcbiAgaWYod2luZG93LiRURVNUKSB7XG4gICAgY29uc29sZS5sb2coMTIsIGV4dGVuZClcbiAgfVxuXG4gIGlmKCAhZXh0ZW5kLmV4dGVuc2lvbnMgKSBcbiAge1xuICAgIGlmKGJhc2UpIHtcbiAgICAgIGV4dGVuZC5leHRlbnNpb25zID0gW11cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5sb2coZXh0ZW5kKVxuICAgICAgaWYoVi5PYmplY3QgJiYgZXh0ZW5kIGluc3RhbmNlb2YgVi5PYmplY3QgKSB7XG4gICAgICAgIHV0aWwuZGVmaW5lKCBleHRlbmQsICdleHRlbnNpb25zJyxbXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZ2VicnVpayBkZXplIGV4dGVuc2lvbiBzdHlsb1xuICAgICAgICB1dGlsLmRlZmluZSggZXh0ZW5kLCAnZXh0ZW5zaW9ucycse3ZhbDpbXSwgc2V0Q2xhc3M6dHJ1ZX0gKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCAnRVhURU5EJy5yZWQsIGV4dGVuZC5leHRlbnNpb25zLCBiYXNlLCBmbiwgdGhpcywgZXh0ZW5kZWQgKVxuXG4gIGlmKCB1dGlsLmNoZWNrQXJyYXkoIGV4dGVuZC5leHRlbnNpb25zLCB0aGlzICk9PT1mYWxzZSApIFxuICB7XG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ0VYVEVORCAtMicucmVkLCB0aGlzIClcblxuICAgIGlmKCAhZXh0ZW5kZWQgKSBleHRlbmQuZXh0ZW5zaW9ucyA9IFsgdGhpcyBdLmNvbmNhdCggZXh0ZW5kLmV4dGVuc2lvbnMgKSBcblxuICAgICAgLy8gY29uc29sZS5sb2coICdFWFRFTkQgLTMnLnJlZCwgZXh0ZW5kLmV4dGVuc2lvbnMgKVxuICAgICAgLy9zb21ldGhpbiB3ZWlyZCFcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnRVhURU5EIC0zJy5yZWQsIHRoaXMsIGV4dGVuZCwgZXh0ZW5kLmV4dGVuc2lvbnMubGVuZ3RoIClcblxuICAgIHZhciBteUFyZ3MgPSB1dGlsLmFyZyggYXJncyApXG4gICAgaWYoIGJhc2UgJiYgIWV4dGVuZGVkICkge1xuICAgICAgbXlBcmdzWzBdID0gYmFzZVxuICAgIH1cbiAgICBpZih3aW5kb3cuJFRFU1QpIGNvbnNvbGUuZXJyb3IoJz8/eHh4PycsIG15QXJncywgZm4sIHRoaXMpXG4gICAgdmFyIHJldCA9IGZuLmFwcGx5KCB0aGlzLCBteUFyZ3MgKSAvL3RoaXMgaXMgdGhlIGFwcCwgZXh0ZW5kIGlzIHRoZSBleHRlbnNpb24gXG4gICAgaWYod2luZG93LiRURVNULCByZXQpXG4gICAgcmV0dXJuIHJldFxuICB9IGVsc2Uge1xuICAgIGlmKHdpbmRvdy4kVEVTVCkgY29uc29sZS5lcnJvcignPz8/JylcbiAgfVxuXG59XG5cbmV4cG9ydHMuZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cblxuICB2YXIgZXh0ZW5kQXJyYXkgPSB1dGlsLmFyZyggYXJndW1lbnRzIClcblxuICByZXR1cm4gZnVuY3Rpb24oZXh0ZW5kKSB7XG5cbiAgICBpZih3aW5kb3cuJFRFU1QpIGNvbnNvbGUubG9nKCcxMCAtLS0+JywgZXh0ZW5kKVxuXG4gICAgdmFyIGJhc2VcbiAgICAgICwgcHJvdG9cblxuICAgIGlmKCB0eXBlb2YgZXh0ZW5kID09PSAnZnVuY3Rpb24nICkgXG4gICAge1xuICAgICAgaWYoIFYuQmFzZSAmJiAoIGV4dGVuZC5wcm90b3R5cGUgaW5zdGFuY2VvZiBWLkJhc2UgKSApIHtcbiAgICAgICAgYmFzZSA9IGV4dGVuZC5iYXNlXG4gICAgICAgIHByb3RvID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdG8gPSBleHRlbmQucHJvdG90eXBlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCBWLkJhc2UgJiYgKCBleHRlbmQgaW5zdGFuY2VvZiBWLkJhc2UgKSApIFxuICAgIHtcbiAgICAgIHByb3RvID0gZXh0ZW5kXG4gICAgfVxuXG4gICAgZm9yXG4gICAgKCBcbiAgICAgIHZhciBmblxuICAgICAgICAsIHJldFxuICAgICAgICAsIGFyZ3MgPSB1dGlsLmFyZyggYXJndW1lbnRzIClcbiAgICAgICAgLCBleHRlbmRBcnJcbiAgICAgICAgLCB4QXJnXG4gICAgICAgICwgaSA9IDBcbiAgICAgICAgLCBsZW4gPSBleHRlbmRBcnJheS5sZW5ndGhcbiAgICAgICAgOyBpIDwgbGVuXG4gICAgICAgIDsgaSArKyBcbiAgICApIFxuICAgIHsgICAgXG4gICAgICBpZihleHRlbmRBcnJheVtpXSBpbnN0YW5jZW9mIEFycmF5KSBcbiAgICAgIHtcbiAgICAgICAgZXh0ZW5kQXJyID0gZXh0ZW5kQXJyYXlbaV1bMF1cbiAgICAgICAgeEFyZyA9IHV0aWwuYXJnKGV4dGVuZEFycmF5W2ldLDEpXG4gICAgICAgIHhBcmcudW5zaGlmdChleHRlbmQpXG4gICAgICB9IGVsc2UgXG4gICAgICB7XG4gICAgICAgIHhBcmcgPSBhcmdzXG4gICAgICAgIGV4dGVuZEFyciA9IGV4dGVuZEFycmF5W2ldXG4gICAgICB9XG5cbiAgICAgIGlmKHdpbmRvdy4kVEVTVCkge1xuICAgICAgICBjb25zb2xlLmxvZygnMTEnLCAgZXh0ZW5kQXJyLmV4dGVuZCA/ICBleHRlbmRBcnIgOiB0aGlzLCBiYXNlIHx8IHByb3RvICApXG4gICAgICB9XG5cbiAgICAgIHJldCA9IGV4dGVuc2lvbnMuY2FsbCBcbiAgICAgICggZXh0ZW5kQXJyLmV4dGVuZCA/ICBleHRlbmRBcnIgOiB0aGlzIFxuICAgICAgLCBiYXNlIHx8IHByb3RvIHx8IGV4dGVuZFxuICAgICAgLCBleHRlbmRBcnIuZXh0ZW5kIHx8ICBleHRlbmRBcnJcbiAgICAgICwgYmFzZVxuICAgICAgLCB4QXJnXG4gICAgICAsIGV4dGVuZEFyci5leHRlbmQgPyB0cnVlIDogZmFsc2UgXG4gICAgICApIFxuICAgICAgfHwgZXh0ZW5kXG5cbiAgICB9XG4gICAgcmV0dXJuIHJldFxuICB9XG5cbn1cblxuLyoqXG4gKiBBZGQgaXMgdXNlZCBhcyBhIHNob3J0Y3V0IG1ldGhvZCBmb3IgT2JqZWN0LmRlZmluZVByb3BlcnR5IGFuZCBleHRlbmRzIHNldHN0b3JlIGZ1bmN0aW9uYWxpdHkgdG8gbm9ybWFsIHByb3RvdHlwZXNcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICAgIG9iaiAgV2hlbiBvYmogaXMgYSBjb25zdHJ1Y3RvciBpdCBzZWxlY3RzIG9iai5wcm90b3R5cGUsIHdoZW4gb2JqIGlzIGEgbm9ybWFsIG9iamVjdCB0aGlzIGlzIHVzZWQgaW5zdGVhZFxuICogQHBhcmFtICB7U3RyaW5nfEFycmF5fSAgICBuYW1lIFdoZW4gbmFtZSBpcyBhIHN0cmluZyBpdCBhZGRzIHRoZSBuYW1lIGZvciB0aGUgb2JqZWN0LCB3aGVuIG5hbWUgaXMgYSBhcnJheSBkbyB0aGUgc2FtZSBzZXR0aW5nIGZvciBlYWNoIG5hbWVcbiAqIEBwYXJhbSAge09iamVjdHxGdW5jdGlvbn0gdmFsICBXaGVuIHZhbCBpcyBhbiBvYmplY3QgLCB1c2UgdGhpcyBvYmplY3QgZm9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB3aXRoIGRlZmF1bHQgZm9yIGVudW1tZXJhYmxlOmZhbHNlLCB3aGVuIG9iamVjdCBpcyBlbXB0eSBhZGRzIHt2YWx1ZTp7fSxlbm51bWVyYWJsZTpmYWxzZX0sIHdoZW4gdmFsIGlzIGEgZnVuY3Rpb24gaXQgYXV0b21hdGljYWxseSB3cmFwcyBhIHByb3BlcnR5IGRlZmluaXRpb24gb2JqZWN0IHdpdGgge3ZhbHVlOiB2YWwgLCBlbnVtbWVyYWJsZTpmYWxzZX0sIHdoZW4gdmFsIGlzIG5vdCBhIGZ1bmN0aW9uIGFuZCBub3QgYW4gb2JqZWN0IChib29sZWFuLCBzdHJpbmcsIG51bWJlcikgYWRkcyBzcGVjaWFsIHNldHN0b3JlIHZhbHVlXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgIFtzZXRdICBBZGRzIGN1c3RvbSBzZXR0ZXJzIHRvIGEgc2V0c3RvcmUgb2JqZWN0LCB3aGVuIHNldCBpcyBhIHN0cmluZyB0aGUgYWRkIGZ1bmN0aW9ucyBpbnRlcnByZXRzIHRoZSBhcmd1bWVudHMgYXMgbmFtZSA6IHByb3BlcnR5IGRlZmluaXRpb24gcGFpcnNcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgW2dldF0gIEFkZHMgY3VzdG9tIGdldHRlcnMgdG8gYSBzZXRzdG9yZSBvYmplY3RcbiAqIEBcbiAqL1xuZXhwb3J0cy5kZWZpbmUgPSBmdW5jdGlvbiAob2JqLCBuYW1lLCB2YWwsIHNldCwgZ2V0LCBpZCkge1xuICBpZiAodHlwZW9mIHNldCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgX2FyZ3MgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gICAgZm9yICh2YXIgaSA9IDEsIGwgPSBfYXJncy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICAgIGV4cG9ydHMuZGVmaW5lKG9iaiwgX2FyZ3NbaV0sIF9hcmdzW2kgKyAxXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5hbWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBuYW1lLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBleHBvcnRzLmRlZmluZShvYmosIG5hbWVbaV0sIHZhbClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgfHwgdmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgdmFsID0ge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXZhbCB8fCAoICEodmFsIGluc3RhbmNlb2YgT2JqZWN0KSB8fCB2YWwuc2V0Q2xhc3MgICkpIHtcblxuICAgICAgICBpZiggdmFsICYmIHZhbC5zZXRDbGFzcyApIHtcbiAgICAgICAgICB2YWwgPSB2YWwudmFsXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvdG8gPSBvYmoucHJvdG90eXBlIHx8IG9ialxuXG5cbiAgICAgICAgLy9cblxuICAgICAgICAvL1RPRE86IG5vdCBhIGdvb2Qgc29sdXRpb24gLS0gaGFzIHRvIHJlZGVmaW5lIGNvbnN0YW50bHkgKCB0b28gaGVhdnkgKVxuICAgICAgICAvLyBpZiggcHJvdG8gIT09IG9iai5wcm90b3R5cGUgJiYgcHJvdG8uXyApIHtcbiAgICAgICAgLy8gICAgLy9UT0RPOiB0aGlzIGNhbiBnbyBjb21wbGV0ZWx5IHdyb25nIHdoZW4geW91IGV4cGVjdCBpbmhlcml0YW5jZSBub3QgdG8gYnJlYWsgd2hlbiBtYWtpbmcgYSBuZXcgY2xhc3MhXG4gICAgICAgIC8vICAgIGlmKCBwcm90by5jb25zdHJ1Y3Rvci5wcm90b3R5cGUuXyA9PT0gcHJvdG8uXyApIHtcbiAgICAgICAgLy8gICAgICAgdmFyIG9sZCA9IHByb3RvLl9cbiAgICAgICAgLy8gICAgICAgcHJvdG8uXyA9IHt9XG4gICAgICAgIC8vICAgICAgIGZvcih2YXIga2V5IGluIG9sZCkge1xuICAgICAgICAvLyAgICAgICAgIHByb3RvLl9ba2V5XSA9IG9sZFtrZXldXG4gICAgICAgIC8vICAgICAgIH1cbiAgICAgICAgLy8gICAgfVxuICAgICAgICAvLyB9XG4gICAgICAgIFxuICAgICAgICAvL21heWJlIG1ha2UgaW50byBhIG1ldGhvZFxuICAgICAgICBpZiggaWQpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnREVGSU5FISBETyBJVCcucmVkLmludmVyc2UsIG5hbWUsIGlkLCBwcm90bylcbiAgICAgICAgICBpZiAoIXByb3RvLl9fKSBwcm90by5fXyA9IHt9XG4gICAgICAgICAgcHJvdG8uX19bbmFtZV0gPSB2YWxcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIXByb3RvLl8pIHByb3RvLl8gPSB7fVxuICAgICAgICAgIHByb3RvLl9bbmFtZV0gPSB2YWxcbiAgICAgICAgfVxuXG5cblxuICAgICAgXG5cbiAgICAgICAgLy9pZiBwcm90byBpcyBub3QgYSBwcm90b3R5cGUgKGhvdyB0byBjaGVjaz8pIHRoZW4gdXNlIF9fIHBlcmhhcHM/XG5cbiAgICAgICAgLy9tb2V0IGhpZXIgbmlldCBhbHRpamQgemUgZWlndWggd29yZGVuIGdlbWFha3Q/XG5cbiAgICAgICAvL2RlZmF1bHQgZGl0IGlzIGVpZ2VubGlqayBoZXQgZW5pZ2UgZGF0IG1pcyBnYWF0XG5cbiAgICAgICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICBleHBvcnRzLnNldHN0b3JlLmNhbGwodGhpcylcbiAgICAgICAgICAgICAgLy9UT0RPOiBmaXggY2xvc3VyZSBmb3IgdmFsXG4gICAgICAgICAgICAgIGlmICh2YWwgfHwgdmFsID09PSAwIHx8IHZhbCA9PT0gZmFsc2UpIHRoaXMuX19bbmFtZV0gPSB2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAsIHdzZXQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgdmFsID0gc2V0LmNhbGwodGhpcywgdmFsKTtcbiAgICAgICAgICAgICAgc2V0dGVyLmNhbGwodGhpcywgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAsIGdldHRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5nZXRTdG9yZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICwgd2dldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgcHJvcCA9IGdldHRlci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0LmNhbGwodGhpcywgcHJvcCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgdmFsID0ge1xuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQ6IGdldCA/IHdnZXQgOiBnZXR0ZXIsXG4gICAgICAgICAgc2V0OiBzZXQgPyB3c2V0IDogc2V0dGVyXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmICghdmFsLmVudW1lcmFibGUpIHtcbiAgICAgICAgaWYgKHV0aWwuZW1wdHkodmFsKSkgdmFsLnZhbHVlID0ge31cbiAgICAgICAgdmFsLmNvbmZpZ3VyYWJsZSA9IHRydWVcbiAgICAgICAgdmFsLmVudW1lcmFibGUgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLnByb3RvdHlwZSB8fCBvYmosIG5hbWUsIHZhbClcblxuICAgICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iai5wcm90b3R5cGUgfHwgb2JqLCBuYW1lLCB2YWwpXG4gICAgICAvL21heWViIGRvIGJvdGg/XG4gICAgfVxuICB9XG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGJhc2UgPSByZXF1aXJlKCcuLi9iYXNlJylcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoJy4vJylcbiAgLCBvYmplY3RTZXQgPSByZXF1aXJlKCcuLi9vYmplY3QnKS5zZXRcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gIC8vICwgcmFmID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9hbmltYXRpb24vcmFmJylcblxuZXhwb3J0cy5jbG9uZWxpc3QgPSBbXG4gIFsgJ19iYXNlJywgZmFsc2UgXSwgJ19jYWxsZXInLCAnX3Byb3AnLCAnX25hbWUnLCAnX3NraXAnXG5dXG5cbmZ1bmN0aW9uIHJlc29sdmVMaXN0ZW5lciggbGlzdGVuZXIsIHZhbCwgcHJvcCwgaW5zdGFuY2UgKSB7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGlmICggbGlzdGVuZXIuX2JpbmQgPT09IGluc3RhbmNlICYmIGxpc3RlbmVyLl9fdCA9PT0gNCApIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdiaW5kIHJlc29sdmUnLnJlZC5ib2xkLCB2YWwgKVxuICAgICAgbGlzdGVuZXIudmFsID0gdmFsXG4gICAgfVxuICAgIGVsc2UgaWYgKCFsaXN0ZW5lci5fYmluZCApIHsgXG5cbiAgICAgIGlmKCBsaXN0ZW5lci5fX3QgPT09IDQgJiYgbGlzdGVuZXIuX3ZhbCA9PT0gcHJvcCApXG4gICAgICB7XG4gICAgICAgIC8vIGxpc3RlbmVyLnZhbCA9IFxuICAgICAgICBsaXN0ZW5lci52YWwgPSB2YWxcbiAgICAgICAgY29uc29sZS5sb2coJy0tLS0tLS0tLS0nLCBsaXN0ZW5lci5fX3QgKVxuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndWx0aW1hdGUgdWdseSEnKVxuICAgICAgICB2YWwuYWRkTGlzdGVuZXIobGlzdGVuZXIpIC8vZGl0IGZpeGVkICBcbiAgICAgIH1cblxuICAgICAgLy9UT0RPOiBpbXBsZW1lbnQgdGhpcyBsYXRlclxuICAgICAgLy8gaWYoIGxpc3RlbmVyIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4gICAgICAvLyAgIHZhciBtYXJrID0gbGlzdGVuZXJbMV1cbiAgICAgIC8vICAgaWYoIG1hcmsgKSB7XG4gICAgICAvLyAgICAgaWYoIG1hcmsgPT09IHByb3AuX2Jhc2UgfHwgbWFyayA9PT0gaW5zdGFuY2UgfHwgaW5zdGFuY2UgaW5zdGFuY2VvZiBtYXJrLl9jbGFzcyApIHtcbiAgICAgIC8vICAgICAgIC8vVE9ETzogcHJvcGFibHkgbmVlZCB0byBjaGVjayBmb3IgaW5oZXJpdGFuY2UgKCBtYXJrIGluc3RhbmNlIG9mIHByb3AuX2Jhc2UpXG4gICAgICAvLyAgICAgICAvLyBjb25zb2xlLmxvZygnbWFyayByZXNvbHZlJy5ncmVlbi5pbnZlcnNlLCBsaXN0ZW5lcilcbiAgICAgIC8vICAgICAgIC8vIHZhbC5hZGRMaXN0ZW5lcihbIGxpc3RlbmVyWzBdICwgaW5zdGFuY2UgXSwgdHJ1ZSlcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgXG4gICAgICAvLyB2YWwuYWRkTGlzdGVuZXIoX2xpc3RlbmVyc1tpXSlcbiAgICB9XG4gIH1cbn1cblxuLy8gZnVuY3Rpb24gcmVzb2x2ZUxpc3RlbmVyKCApIHtcblxuLy8gfVxuXG4vKipcbiAqIFYudmFsdWUuYmFzZS50eXBlXG4gKiBEZWZpbmVzIHRoZSBiYXNlIHR5cGUgdXNlZCBpbiBWLlZhbHVlXG4gKiBAdHlwZVxuICovXG5leHBvcnRzLnR5cGUgPSB7XG4gIHR5cGU6IFZhbHVlLFxuICAvKipcbiAgICogRGVmaW5lcyB3aGF0IHRoaXMgdHlwZSB3aWxsIGRvIG9uIGNyZWF0aW9uLlxuICAgKiBAbWV0aG9kIGNyZWF0ZVxuICAgKiBAcGFyYW0gIHsqfSB2YWwgICAgICAgICAgICAgIFZhbHVlXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gIFtwcm9wXSAgICAgW2Rlc2NyaXB0aW9uXSAvL1dPUkRUIE5JRVQgR0VCUlVJS1RcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgW3NldHRpbmdzXSBTZXR0aW5nb2JqZWN0XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IFtub3VwZGF0ZV0gV2hlbiB0cnVlLCBkb2Vzbid0IHVwZGF0ZSB0aGUgVi5WYWx1ZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgIFJldHVybnMgdGhlIFYuVmFsdWVcbiAgICovXG4gIGNyZWF0ZTogZnVuY3Rpb24odmFsLCBwcm9wLCBzZXR0aW5ncywgbm91cGRhdGUpIHtcbiAgICB2YXIgdiA9IG5ldyBWYWx1ZSgpXG4gICAgdi5fYmFzZSA9IHRoaXNcbiAgICB2Ll9jYWxsZXIgPSB2Ll9iYXNlXG4gICAgdi5fcHJvcCA9IHNldHRpbmdzXG4gICAgLy8gY29uc29sZS5sb2coJ3NldCcpXG4gICAgb2JqZWN0U2V0LmNhbGwodiwgdmFsLCBmYWxzZSwgZmFsc2UsIHRydWUpXG4gICAgLy8gY29uc29sZS5sb2coJ2RvbmUgc2V0dGluZycpXG4gICAgaWYgKHRoaXMuX2NsYXNzKSB0aGlzLl9jbGFzcy5wcm90b3R5cGUuX1tzZXR0aW5ncy5uYW1lXSA9IHZcbiAgICBpZiAoc2V0dGluZ3Muc2V0KSB7XG4gICAgICBpZiAoIXNldHRpbmdzLl92c2V0KSB7XG4gICAgICAgIHNldHRpbmdzLl92c2V0ID0gZnVuY3Rpb24oc3RhbXAsIGZyb20sIHJlbW92ZSwgY3ZhbCkge1xuICAgICAgICAgIC8vIHZhciB0ID0gdGhpc1xuICAgICAgICAgIC8vIHQuX19zID0gdHJ1ZVxuICAgICAgICAgIC8vIGlmKCF0Ll9zKSB7XG4gICAgICAgICAgICAvLyByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdJTSBIRVJFPycpXG4gICAgICAgICAgICAgIC8vIHQuX19zID0gbnVsbFxuICAgICAgICAgICAgICBzZXR0aW5ncy5zZXQuY2FsbChcbiAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsZXJcbiAgICAgICAgICAgICAgICB8fCB0aGlzLl9iYXNlXG4gICAgICAgICAgICAgICAgfHwgdGhpcywgdGhpcywgc3RhbXAsIGZyb20sIHJlbW92ZSwgY3ZhbFxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICAvLyB9KVxuICAgICAgICAgIC8vIH1cblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW5vdXBkYXRlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdVUERBVEUgY3JlYXRpb24nKVxuICAgICAgICB2Ll91cGRhdGUodmFsKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdlxuICB9LFxuICAvKipcbiAgICogRGVmaW5lcyB3aGF0IHRoaXMgdHlwZSB3aWxsIGRvIG9uIHNldC5cbiAgICogQG1ldGhvZCBzZXRcbiAgICogQHBhcmFtICB7Kn0gICAgICB2YWwgICAgICBWYWx1ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3AgICAgIFByb3BlcnRpZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzZXR0aW5ncyBTZXR0aW5nc29iamVjdFxuICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgIFJldHVybnMgdmFsdWVcbiAgICovXG4gIHNldDogZnVuY3Rpb24odmFsLCBwcm9wLCBzZXR0aW5ncykge1xuXG4gICAgaWYoIXByb3ApIHJldHVyblxuICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgRlVOIScpXG4gICAgcHJvcC5fY2FsbGVyID0gdGhpc1xuICAgIC8vZGV6ZSBiaW5kIHpvdSBhbGxlZW4gbW9ldGVuIHdlcmtlbiB2b29yIGFscyBqZSBpZXRzIG9wIGhldCBleGFjdCBnb2VkZSBtb21tZW50IGNoYW5nZWQhXG5cbiAgICBwcm9wLl9iaW5kID0gZmFsc2VcbiAgICBpZiAodGhpcyAhPT0gcHJvcC5fYmFzZSkge1xuICAgICAgdmFyIF9saXN0ZW5lcnMgPSBwcm9wLl9saXN0ZW5lcnNcbiAgICAgICAgLCBfYiA9IHByb3AuX2Jhc2VcbiAgICAgICAgLCBpXG4gICAgICAgICwgX3RoaXMgPSB0aGlzXG5cbiAgICAgIHV0aWwuc2V0c3RvcmUuY2FsbCh0aGlzKVxuICAgICAgZXhwb3J0cy5jbG9uZWxpc3RbMF1bMV0gPSB0aGlzIC8vYmVldGplIGRpcnR5Li4uXG5cbiAgICAgIC8vY2xvbmUgaXMgYWx3YXlzIHVzZWQgdG8gZ2V0IHJpZCBvZiBmbGFnc1xuICAgICAgaWYgKHZhbCAhPT0gdm9pZCAwICYmICF2YWwuY2xlYXIpIHtcbiAgICAgICAgdmFsID0gcHJvcC5jbG9uZSh2YWwsIGZhbHNlLCBleHBvcnRzLmNsb25lbGlzdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmKHByb3AuX2ZsYWcpIHtcbiAgICAgICAgLy8gICB2YWx1ZS5mbGFnc1twcm9wLl9mbGFnWzBdXS5yZW1vdmUgJiYgdmFsdWUuZmxhZ3NbcHJvcC5fZmxhZ1swXV0ucmVtb3ZlLmNhbGwodGhpcyxwcm9wLl9mbGFnKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vbGlzdGVuZXIgb24gbmVzdGVkIGNoaWxkIG9uIHBhcmVudFxuXG4gICAgICAgICAvLy0tLT4gIG5ldyB3aWR0aCBmb3IgdGhpcyBvbmVcbiAgICAgICAgIC8vIC0tLT4gIGhleSBhIGxpc3RlbmVyIG9uIG1lIC93IGEgYmluZCBvbiBteSBpbnN0YW5jZSFcbiAgICAgICAgIC8vICAtLS0tPiBhZGQgbGlzdGVuZXIgdG8gbWUgKGxpc3RlbmVyIG9uIGNsYXNzIHByb3ApXG4gICAgICAgICAvLyAgIC0tLS0tPiBoZXkgbGV0cyByZXNldCB0aGlzIGxpdHRsZSBndXlzIHdpZHRoXG4gICAgICAgICAvLyAgICAtLS0tLS0+ICBsZXRzIGFkZCBMaXN0ZW5lclxuICAgICAgICAgLy8gICAgIC0tLS0tLS0tPiAgZG91YmxlIGxpc3RlbmVycyBvbiB0aGlzIG9uZVxuICAgICAgICB2YXIgdiA9IG5ldyBWYWx1ZSgpXG4gICAgICAgIHYuX2Jhc2UgPSB0aGlzXG4gICAgICAgIHYuX3Byb3AgPSBzZXR0aW5nc1xuICAgICAgICB2Ll9jYWxsZXIgPSB0aGlzXG5cbiAgICAgICAgLy8gY2xlYW4gRkxBR1MgZnJvbSBub2RlIVxuICAgICAgICBpZih2YWwpIGRlbGV0ZSB2YWwuY2xlYXJcbiAgICAgICAgdi52YWwgPSB2YWxcbiAgICAgICAgdmFsID0gdlxuICAgICAgfVxuXG4gICAgICB0aGlzLl9fW3NldHRpbmdzLm5hbWVdID0gdmFsXG5cbiAgICAgIGlmKCB0aGlzLl9jbGFzcyApIHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fW3NldHRpbmdzLm5hbWVdID0gdmFsXG5cbiAgICAgIC8vIGZvciBlYWNoIGZpZWxkIChvbmx5IDEgbGV2ZWwgZGVlcCBmb3Igbm93KVxuICAgICAgcHJvcC5lYWNoXG4gICAgICAoIFxuICAgICAgICBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVzb2x2ZScsIHByb3AuX3Byb3AubmFtZSwga2V5KVxuICAgICAgICAgICBpZiggdGhpcy5fbGlzdGVuZXJzICkge1xuICAgICAgICAgICAgZm9yIChpID0gIHRoaXMuX2xpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICByZXNvbHZlTGlzdGVuZXIoIHRoaXMuX2xpc3RlbmVyc1tpXSwgdmFsW2tleV0sIHByb3AsIF90aGlzIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vVE9ETzogY2hlY2sgaWYgdGhpcyBpcyBuZXNzZWNhcnlcbiAgICAgICAgICAgIGlmKHZhbFtrZXldLnZhbCAhPT0gdGhpcy52YWwpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbFtrZXldKSBcbiAgICAgICAgICAgICAgLy8gdmFsW2tleV0uX3VwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG5cbiAgICAgIGlmKCBfbGlzdGVuZXJzICkge1xuXG4gICAgICAgIGZvciAoaSA9IF9saXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICByZXNvbHZlTGlzdGVuZXIoIF9saXN0ZW5lcnNbaV0sIHZhbCwgcHJvcCwgX3RoaXMgKVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdmFsID0gbnVsbFxuICAgICAgLy8gY29uc29sZS5sb2coJ1VQREFDRSAtLS0tJy55ZWxsb3cpXG4gICAgICB0aGlzW3NldHRpbmdzLm5hbWVdLl91cGRhdGUodmFsKVxuICAgIH1cblxuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgLyoqXG4gICBEZWZpbmVzIHdoYXQgdGhpcyB0eXBlIHdpbGwgZG8gb24gZ2V0LlxuICAgKiBAbWV0aG9kIGdldFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHByb3AgICAgIFByb3BlcnRpZXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSBzZXR0aW5ncyBTZXR0aW5nb2JqZWN0XG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAqL1xuICBnZXQ6IGZ1bmN0aW9uKHByb3AsIHNldHRpbmdzKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ0dFVFRJTkchJywgcHJvcCwgc2V0dGluZ3MubmFtZSlcbiAgICBpZiAocHJvcCkgcHJvcC5fY2FsbGVyID0gdGhpc1xuICAgIGlmIChzZXR0aW5ncy5nZXQpIHJldHVybiBzZXR0aW5ncy5nZXQuY2FsbCh0aGlzLCBwcm9wKVxuICAgIHJldHVybiBwcm9wXG4gIH1cbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZmxhZ3MgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksXG4gIG9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpLFxuICBvd25Nb2RlbCA9IGZ1bmN0aW9uKGJhc2UpIHtcbiAgICBpZiAoIWJhc2UuX18gfHwgIWJhc2UuX18ubW9kZWwpIHsgLy9tYXliZSBhIHV0aWxpdHk/IHVzZSBpdCBhdCBkaWZmZXJlbnQgc3BvdHMgbGlrZSBzZXR0aW5nc1xuICAgICAgYmFzZS5tb2RlbCA9IHt9O1xuICAgICAgaWYgKCFiYXNlLl8ubW9kZWwpIHtcbiAgICAgICAgYmFzZS5fZExpc3RlbigpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFzZS5tb2RlbDtcbiAgfTtcbi8qKlxuICogZGF0YVxuICogZGF0YSBhZGRzIGEgcmVmZXJlbmNlIHRvIHRoZSBkYXRhIHByb3BlcnR5IG9mIHRoZSBjdXJyZW50IGJhc2UgY2xhc3M7XG4gKiBpZiB0aGVyZSBpcyBub3QgX2Jhc2UubW9kZWwgdXNlIGRhdGEuYmFzZS5leHRlbmQoYmFzZUNsYXNzKTtcbiAqIEBmbGFnXG4gKi9cbmZsYWdzLmRhdGEgPSB7XG4gIHVzZVZhbDp0cnVlLCAvLyhyZXNldD8/PylcbiAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCkge1xuXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNoZWNrUGFyZW50KCdfcHJvcC5uYW1lJyksXG4gICAgICBuYW1lID0gY3VycmVudC5fcHJvcC5uYW1lLFxuICAgICAgYmFzZSA9IGN1cnJlbnQuX2Jhc2UsXG4gICAgICBtb2RlbCA9IG93bk1vZGVsKGJhc2UpO1xuICAgIGlmIChtb2RlbC5mbGFncyAmJiBtb2RlbC5mbGFnc1tuYW1lXSkge1xuICAgICAgaWYgKCEobW9kZWwuZmxhZ3NbbmFtZV0gaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgbW9kZWwuZmxhZ3NbbmFtZV0gPSBbbW9kZWwuZmxhZ3NbbmFtZV1dO1xuICAgICAgfVxuICAgICAgaWYgKCF1dGlsLmNoZWNrQXJyYXkobW9kZWwuZmxhZ3NbbmFtZV0sIHRoaXMpKSB7XG4gICAgICAgIG1vZGVsLmZsYWdzW25hbWVdLnB1c2godGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYmFzZS5tb2RlbC5mbGFncykge1xuICAgICAgICBiYXNlLm1vZGVsLmZsYWdzID0ge307XG4gICAgICB9XG4gICAgICBiYXNlLm1vZGVsLmZsYWdzW25hbWVdID0gdGhpcztcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygnTEVaWiBTRVQgSVQhJywgdmFsLCBzdGFtcCwgcmVzZXQsIGN1cnJlbnQpXG5cbiAgICB2YXIgZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kO1xuICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcztcbiAgICAgICAgd2hpbGUgKGRhdGEgPT09IHZvaWQgMCAmJiBwYXJlbnQpIHtcblxuICAgICAgICAgIC8vIGlmKHBhcmVudC5tb2RlbCAmJiAoIXBhcmVudC5tb2RlbC5pbmhlcml0IHx8IHBhcmVudC5tb2RlbC5pbmhlcml0LnZhbCE9PWZhbHNlKSkge1xuICAgICAgICAgIC8vICAgcmV0dXJuIGRhdGFcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdzZXQgaXQgL3cgcGFyZW50IScsIHRoaXMubmFtZSwgcGFyZW50Lm5hbWUpXG5cbiAgICAgICAgICBpZiAocGFyZW50Ll9kKSB7XG5cbiAgICAgICAgICAgIGlmKHBhcmVudC5tb2RlbCAmJiBwYXJlbnQubW9kZWwuZmllbGQgJiYgcGFyZW50Lm1vZGVsLmZpZWxkLnZhbCAhPT0gcGFyZW50Lm1vZGVsUGFyc2VkKSB7XG4gICAgICAgICAgICAgIHBhcmVudC5fZCA9IHBhcmVudC5fZFtwYXJlbnQubW9kZWwuZmllbGQudmFsXSB8fCBwYXJlbnQuX2QuZnJvbVtwYXJlbnQubW9kZWwuZmllbGQudmFsXVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdoZXQgaGV5IGl0cyBwYXJlbnQgbW9kZWwnLCBwYXJlbnQubW9kZWwuZmllbGQudmFsKVxuICAgICAgICAgICAgICAvLyBwYXJlbnQubW9kZWwgPSB7fVxuICAgICAgICAgICAgICBwYXJlbnQubW9kZWxQYXJzZWQgPSBwYXJlbnQubW9kZWwuZmllbGQudmFsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGlmKHBhcilcblxuICAgICAgICAgICAgaWYodGhpcy5tb2RlbCYmdGhpcy5tb2RlbC5maWVsZCAmJiB0aGlzLm1vZGVsUGFyc2VkICE9PSB0aGlzLm1vZGVsLmZpZWxkLnZhbCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdoZXkgaGV5IGhleSEgaSBnb3QgYSBtb2RlbCBteXNlbGYhJywgdGhpcy5tb2RlbC5maWVsZC52YWwsIHBhcmVudC5fZC5rZXlzLCBwYXJlbnQuX2QpXG5cbiAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RTZXQocGFyZW50Ll9kW3RoaXMubW9kZWwuZmllbGQudmFsXSB8fCBwYXJlbnQuX2QuZnJvbVt0aGlzLm1vZGVsLmZpZWxkLnZhbF0sIHRydWUpO1xuICAgICAgICAgICAgICAvLyB0aGlzLm1vZGVsID0ge31cbiAgICAgICAgICAgICAgdGhpcy5tb2RlbFBhcnNlZCA9IHRoaXMubW9kZWwuZmllbGQudmFsXG4gICAgICAgICAgICAgIC8vIHRoaXMubW9kZWwucGFyc2VkID0gdGhpcy5tb2RlbC5maWVsZC52YWxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kU2V0KHBhcmVudC5fZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLy8gaWYocGFyZW50Lm1vZGVsICYmIHBhcmVudC5tb2RlbC5maWVsZCkge1xuICAgICAgICAgICAgLy8gICBjb25zb2xlLmVycm9yKCdpdCBpcyBhIGZpZWxkIScsIHBhcmVudC5tb2RlbC5maWVsZC52YWwpXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5iYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICB2YXIgdiA9IHZhbC52YWwgfHwgdmFsO1xuICAgICAgdGhpcy5fdmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0RGF0YS5jYWxsKHRoaXMpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLT4nLHYsZGF0YSlcbiAgICAgICAgcmV0dXJuIGRhdGEgJiYgdi5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgfTtcbiAgICAgIHZhbCA9IHZhbC5saXN0ZW4gfHwgdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhID0gZ2V0RGF0YS5jYWxsKHRoaXMpLFxuICAgICAgICAgIHJldDtcbiAgICAgICAgZGF0YSA9IHZhbCA9PT0gdHJ1ZSA/IGRhdGEgOiB1dGlsLmdldChkYXRhLCB2YWwpO1xuICAgICAgICBpZiAoZGF0YSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmV0ID0gZGF0YS5fX3QgJiYgIWRhdGEuX2ZpbHRlciAmJiBkYXRhLnZhbDtcbiAgICAgICAgICBpZiAoIXJldCAmJiByZXQgIT09IDAgJiYgcmV0ICE9PSAnJykgeyAvL3dlaXJkXG4gICAgICAgICAgICByZXQgPSBkYXRhO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYoIXRoaXMuX2ZsYWcpIHRoaXMuX2ZsYWcgPSB7fVxuXG4gICAgLy8gdGhpcy5fX2x2YWwgPSBmYWxzZVxuICAgIC8vIGN1cnJlbnQuX2NhbGxlci5zZXRTZXR0aW5nKHtcbiAgICAvLyAgIG5hbWU6IG5hbWUsXG4gICAgLy8gICBwYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgIC8vICAgICBjb25zb2xlLmxvZygnIUAjIUAjIUAjJylcbiAgICAvLyAgICAgdGhpcy51cGRhdGVEYXRhKClcbiAgICAvLyAgIH1cbiAgICAvLyB9KTtcblxuICAgIHRoaXMuX2ZsYWcuZGF0YSA9IFsnZGF0YScsIHRoaXMuX3ZhbCwgdmFsLCBuYW1lXTtcbiAgfSxcbiAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wLm5hbWUnKSxcbiAgICAgIG1vZGVsID0gb3duTW9kZWwoY3VycmVudC5fYmFzZSksXG4gICAgICB0ID0gdGhpcztcbiAgICBpZiAobW9kZWwgJiYgbW9kZWwuZmxhZ3MpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gbW9kZWwuZmxhZ3MpIHtcbiAgICAgICAgaWYgKGkgPT09IGN1cnJlbnQuX3Byb3AubmFtZSkge1xuICAgICAgICAgIHZhciBpdGVtID0gbW9kZWwuZmxhZ3NbaV07XG4gICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBvYmplY3QgfHwgaXRlbS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG1vZGVsLmZsYWdzW2ldID0gbnVsbDtcbiAgICAgICAgICAgIGRlbGV0ZSBtb2RlbC5mbGFnc1tpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZWwuZmxhZ3NbaV0uc3BsaWNlKHV0aWwuY2hlY2tBcnJheShpdGVtLCB0KSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3VwZGF0ZSgpIC8vcGFzIGhpZXJtZWUgb3AhXG4gICAgLy8gdmFyIHQgPSB0aGlzXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vZGV6ZSBwYXMgdWl0dm9lcmVuIG5hZGF0IGFsbGUga2xhYXIgaXMhIGRpdCBpcyBkaXJ0eSFcbiAgICAgIHQuX3VwZGF0ZSgpXG4gICAgfSwwKVxuICB9XG59OyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB2YWx1ZSA9IHJlcXVpcmUoJy4uLycpLFxuICAgIGJhc2UgPSByZXF1aXJlKCcuLi9iYXNlJyksXG4gICAgZmxhZ3MgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QvZmxhZ3MnKTtcbiAgICBcbiAgICBiYXNlLmNsb25lbGlzdC5wdXNoKFsnX2ZsYWcnLCB0cnVlXSk7IC8vdHJ1ZSBjbG9uZSFcbiAgICBmbGFncy5leHRlbmQodmFsdWUpO1xuICAgIG1vZHVsZS5leHBvcnRzID0gdmFsdWUuZmxhZ3M7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGZsYWdzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpXG4gICwgdmFsdWUgPSByZXF1aXJlKCcuLi8nKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCB2T2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JylcblxuXG4vL3RvZG8gYWRkIGVsZW1lbnQgc2lnbmF0dXJlIGluIGZyb20gc28gaXQgY2FuIHRyYXZlbCB0cm91Z2ggdXBkYXRlcyAtLS0gaWYgcGFyZW50IChuZWVkIGxlc3MgZnVua3kgdGhpbmdzKVxuXG4vKipcbiAqIHBhcmVudFxuICogcGFyZW50IG1ha2VzIGl0IHBvc3NpYmxlIHRvIGFkZCBsaXN0ZW5lcnMgdG8gcGFyZW50IHByb3BlcnRpZXNcbiAqIHVzaW5nIG11bHRpcGxlIHBhcmVudCBwcm9wZXJ0aWVzIGluIG9uZSBwcm9wZXJ0eSBpcyBzdGlsbCB2ZXJ5IHdyb25nXG4gKiBAZmxhZ1xuICovXG52YWx1ZS5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfcGFyZW50U3RvcmUnKVxuXG5mdW5jdGlvbiBiYXNlUmVzZXQoYmFzZSxuYW1lKSB7XG4gIGlmKGJhc2UgJiYgYmFzZS5ub2RlKSB7XG4gICAgaWYobmFtZT09PSd4JyB8fCBuYW1lID09PSd5JykgYmFzZS5jbGVhbkNvb3JkaW5hdGVzKG5hbWUpXG4gICAgaWYoYmFzZVtuYW1lXSkge1xuICAgICAgYmFzZVtuYW1lXS5fcHJvcC5fdnNldC5jYWxsKGJhc2VbbmFtZV0pXG4gICAgfVxuICB9XG59XG5cblxuLy8gd2luZG93LnBjaGVjayA9IDBcblxuLy8gd2luZG93LnBwcm9wcyA9IHt9XG5cbi8vYmFzZSx2c2V0LHQsdHlwZSxtcGFyZW50LGZiYXNlLCB2LCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIHRydWUsIGZpcnN0U2tpcFxuZnVuY3Rpb24gY2hlY2tlcih2c2V0LCB0LCB0eXBlLCBtcGFyZW50LCBmYmFzZSwgdiwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBmaXJzdCwgZmlyc3RTa2lwLCBwKSB7XG4gIGlmKHAmJih0aGlzLnBhcmVudCBpbnN0YW5jZW9mIG1wYXJlbnQpIHx8ICAoIXAgJiYgdGhpcy5wYXJlbnQ9PT1tcGFyZW50KSB8fCBmaXJzdFNraXAgKSB7XG5cbiAgICAvLyBwY2hlY2srK1xuXG4gICAgdmFyIHNcbiAgICAgICwgYmFzZSA9IHRoaXMuX2Zyb20uYmFzZS5ub2RlICYmIHRoaXMuX2Zyb20uYmFzZVxuICAgICAgLCBuYW1lID0gdC5fcHJvcC5uYW1lXG5cbiAgICAvLyBpZighd2luZG93LnBwcm9wc1tuYW1lXSkgd2luZG93LnBwcm9wc1tuYW1lXSA9IDBcblxuICAgIC8vIHdpbmRvdy5wcHJvcHNbbmFtZV0rK1xuXG5cbiAgICB0Ll9jYWxsZXIgPSB0aGlzXG5cbiAgICAvL2dhdXJkIHZvb3IgY2hhbmdlcyAtLSBpZiBubyBjaGFuZ2UgLS0gZG8gbm90aGluZ1xuICAgIHZzZXQuY2FsbCh0LCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCB2YWwpXG5cbiAgICBpZihiYXNlJiZiYXNlW25hbWVdJiZiYXNlW25hbWUrJ19fcCddIT09c3RhbXApIHtcbiAgICAgIHQuX2NhbGxlciA9IGJhc2VcbiAgICAgIHQuX2NhbGxlcltuYW1lKydfX3AnXSA9IHN0YW1wXG4gICAgICB2c2V0LmNhbGwodCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgdmFsKVxuICAgICAgdC5fY2FsbGVyID0gdGhpc1xuICAgICAgcz10cnVlXG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2codGhpcy5ub2RlKVxuICAgIGZvcih2YXIgaSBpbiB0Ll9saXN0ZW5lcnMpIHtcbiAgICAgIGlmKHQuX2xpc3RlbmVyc1tpXS5wb3AgJiYgdC5fbGlzdGVuZXJzW2ldWzJdPT09J3BhcmVudCcpIHtcbiAgICAgICAgaWYodC5fbGlzdGVuZXJzW2ldWzFdLl9sc3RhbXA9PT1zdGFtcCkge1xuICAgICAgICAgIHQuX2xpc3RlbmVyc1tpXVsxXS5fbHN0YW1wPW51bGxcbiAgICAgICAgfVxuICAgICAgICB0Ll9saXN0ZW5lcnNbaV1bMF0uY2FsbCh0Ll9saXN0ZW5lcnNbaV1bMV0sIHR5cGUsIHRoaXMsIGJhc2UsIHYsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL3Jlc2V0IHRoaXMuX2Zyb20uYmFzZVt0Ll9wcm9wLm5hbWVdPT09dFxuICAgIGlmKHMpIGJhc2VSZXNldChiYXNlLCBuYW1lKVxuXG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSGFuZGxlcih0eXBlLG1wYXJlbnQsZmJhc2UsdiwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLGZpcnN0U2tpcCxpbmhlcml0KSB7XG5cbiAgdmFyIHQgPSB0aGlzXG5cbiAgdGhpcy5fcGFyZW50U3RvcmVbMF0gPSBtcGFyZW50XG5cbiAgdGhpcy5fdXBkYXRlKHZhbCwgZnJvbSA/IHRoaXMuc3RhbXAoKSA6IHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIGZhbHNlLCBmYWxzZSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIHZzZXQgPSAgdGhpcy5jaGVja1BhcmVudCgnX3Byb3AuX3ZzZXQnLCB0cnVlKVxuICAgICAgLCBiYXNlID0gdGhpcy5jaGVja1BhcmVudCgnX2Jhc2UnLCB0cnVlKVxuICAgICAgLCBjb21wbGV4UGFyZW50ID0gdHJ1ZVxuICAgICAgLCBwXG5cbiAgICBpZiggKG1wYXJlbnQ9PT1iYXNlLnBhcmVudCAmJiBmcm9tKSAgKSB7XG4gICAgICBwID0gdHJ1ZVxuICAgIH1cblxuICAgIGNoZWNrZXIuY2FsbChiYXNlLHZzZXQsdCx0eXBlLG1wYXJlbnQsZmJhc2UsIHYsIHZhbCwgc3RhbXAsIGZhbHNlLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIHRydWUsIGZpcnN0U2tpcClcblxuICAgIGJhc2UuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkge1xuICAgICBjaGVja2VyLmNhbGwodGhpcywgdnNldCwgdCx0eXBlLCBtcGFyZW50LGZiYXNlLCB2LCB2YWwsIHN0YW1wLCBmYWxzZSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBmYWxzZSwgcClcbiAgICB9LCB0Ll9wcm9wLm5hbWUpXG5cbiAgICB2T2JqZWN0LnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodGhpcywgdmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgZnVuY3Rpb24obCkge1xuICAgICAgcmV0dXJuIGxbMl09PT0ncGFyZW50J1xuICAgIH0pXG5cbiAgICBpZighaW5oZXJpdCAmJiB2Ll9jYWxsZXIgJiYgbXBhcmVudCE9PXYuX2NhbGxlcikge1xuICAgICAgdXBkYXRlSGFuZGxlci5jYWxsKHRoaXMsdHlwZSx2Ll9jYWxsZXIsZmJhc2UsIHYsIHZhbCwgc3RhbXAsIGZhbHNlLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsZmlyc3RTa2lwLHRydWUpXG4gICAgfVxuXG4gIH0pXG59XG5cbmZ1bmN0aW9uIF9wYXJlbnQocGFyZW50LCBub3VwZGF0ZSwgcHJvcCwgZmxhZywgcmVzZXQpIHtcblxuICAvLyBjb25zb2xlLmxvZygnX3BhcmVudCBjYWxsJy5jeWFuLmludmVyc2UsIGZsYWcpXG5cbiAgdmFyIF9scGFyZW50ID0gcHJvcC5fcGFyZW50U3RvcmVbMF1cbiAgICAsIHBuYW1lID0gZmxhZ1syXSAgIC8vZmxhZ3MucGFyZW50LnZhbFxuICAgICwgcHByb3AgPSBwYXJlbnRbcG5hbWVdXG4gICAgLCBmYmFzZSA9IHRoaXMuX2Zyb20uYmFzZVxuICAgICwgbmV3UFxuICAgICwgYmFzZVNldFxuXG4gIGlmICghcHByb3ApIHJldHVyblxuXG4gIC8vIGNvbnNvbGUubG9nKCdBREQgTElTVEVORVIgVE8gUEFSRU5UJylcblxuICBwcHJvcC5hZGRMaXN0ZW5lcihcbiAgICBbIHVwZGF0ZUhhbmRsZXJcbiAgICAsIHByb3BcbiAgICAsICdwYXJlbnQnXG4gICAgLCBwYXJlbnRcbiAgICAsIHRoaXMgLy9mYmFzZVxuICBdLCBmdW5jdGlvbihsLGxpc3RlbmVycyxpbmRleCkge1xuXG4gICAgaWYobFszXSE9PXBhcmVudCAmJiAgX2xwYXJlbnQhPT1wYXJlbnQgJiYgbFs0XSE9PWZiYXNlKSB7XG4gICAgICBwcm9wLl9wYXJlbnRTdG9yZVswXSA9IHBhcmVudFxuICAgICAgbFs0XSA9IGZiYXNlXG4gICAgICBuZXdQID0gdHJ1ZSAvL2hvZSBkZXplIHNtYXJ0IGFmdmFuZ2VuP1xuICAgIH1cbiAgfSwgZmFsc2UsIHRydWUpXG5cbiAgLy8gaWYocmVzZXQpIHtcbiAgLy8gICBmb3IodmFyIGkgaW4gcHByb3AuX2xpc3RlbmVycykge1xuICAvLyAgICAgaWYocHByb3AuX2xpc3RlbmVyc1tpXS5wb3AgJiYgcHByb3AuX2xpc3RlbmVyc1tpXVsxXT09PWZiYXNlW3Byb3AuX3Byb3AubmFtZV0pIHtcbiAgLy8gICAgICAgaWYocHByb3AhPT1wYXJlbnQuX2Zyb20uYmFzZVtwbmFtZV0pIHtcbiAgLy8gICAgICAgICBwcHJvcC5fbGlzdGVuZXJzLnNwbGljZShpLDEpXG4gIC8vICAgICAgICAgYnJlYWs7XG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vIH1cblxuICBpZiAobmV3UCB8fCAoIV9scGFyZW50IHx8IChfbHBhcmVudCAhPT0gcGFyZW50ICYmIF9scGFyZW50W3BuYW1lXSAhPT0gcHByb3ApICkgKSB7XG4gICAgcHJvcC5fcGFyZW50U3RvcmVbMF0gPSBwYXJlbnRcbiAgICBpZiAoIW5vdXBkYXRlKSB7XG4gICAgICBwcm9wLl9jYWxsZXIgPSAoYmFzZVNldCA9IGZiYXNlLm5vZGUgJiYgZmJhc2UgfHwgcHJvcC5fYmFzZSlcbiAgICAgIHByb3AuX3Byb3AuX3ZzZXQuY2FsbChwcm9wLCBwcm9wKVxuICAgICAgcHJvcC5fY2FsbGVyID0gdGhpc1xuICAgICAgdXBkYXRlSGFuZGxlci5jYWxsKHByb3AsJ3BhcmVudCcscGFyZW50LGZiYXNlLHBwcm9wLGZhbHNlLHZPYmplY3Quc3RhbXAoKSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSx0cnVlLHRydWUpXG4gICAgICBiYXNlUmVzZXQoYmFzZVNldCxwcm9wLl9wcm9wLm5hbWUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9pbml0KHZhbCwgZmxhZywgcmVzZXQpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50XG4gIC8vIGNvbnNvbGUubG9nKCd0cnkgcGFyZW50JywgZmxhZywgcGFyZW50KVxuICBpZiAocGFyZW50KSBfcGFyZW50LmNhbGwodGhpcywgcGFyZW50LCB0cnVlLCB2YWwsIGZsYWcsIHJlc2V0KVxufVxuXG5mdW5jdGlvbiBfdmFsKHZhbCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnQgfHwgdmFsLmNoZWNrUGFyZW50KCdfcGFyZW50U3RvcmUuMCcsIHRydWUpXG4gIC8vZmxhZ3MucGFyZW50LnZhbFxuICBpZihwYXJlbnQgJiYgIXZhbC5fZmxhZy5wYXJlbnQpIHtcbiAgICBjb25zb2xlLmVycm9yKCdOTyBQQVJFTlQgRkxBRyEnKVxuICAgIHJldHVyblxuICB9XG4gIC8vIGNvbnNvbGUubG9nKCctLS0tPicsdmFsLl9mbGFnLnBhcmVudFsyXSlcbiAgaWYgKHBhcmVudCApIHJldHVybiBwYXJlbnRbdmFsLl9mbGFnLnBhcmVudFsyXV0udmFsXG59XG5cbmZsYWdzLnBhcmVudCA9XG57IHJlc2V0OiB0cnVlXG4sIHVzZVZhbDogdHJ1ZVxuLCBzZXQ6IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIHJlc2V0KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNoZWNrUGFyZW50KCdfcHJvcC5uYW1lJyksXG4gICAgICBuYW1lID0gY3VycmVudC5fcHJvcC5uYW1lXG4gICAgLy9mbGFncy5wYXJlbnQudmFsXG4gICAgaWYoIXRoaXMuX2ZsYWcpIHRoaXMuX2ZsYWcgPSB7fVxuXG4gICAgICAvL292ZXJ3cml0aW5nIHByZXZpb3VzIHBhcmVudFxuICAgICAgLy9cbiAgICAvLyBjb25zb2xlLmxvZygnU0VUIFBBUkVOVC0tLS0+JylcbiAgICB0aGlzLl9mbGFnLnBhcmVudCA9IFsncGFyZW50JywgX3ZhbCwgdmFsLCB0aGlzXVxuICAgIGlmICghY3VycmVudC5fcGFyZW50U3RvcmUpIGN1cnJlbnQuX3BhcmVudFN0b3JlID0gW2ZhbHNlXVxuXG4gICAgLy8gY29uc29sZS5sb2coJ0dPVFMgUEFSRU5UU1RPUkUhJywgcmVzZXQsIGN1cnJlbnQuX3BhcmVudFN0b3JlLCB0aGlzLl9mbGFnLnBhcmVudClcblxuICAgIGN1cnJlbnQuX3BhcmVudFN0b3JlLnB1c2godGhpcylcbiAgICAvL3NldFBhcmVudCBzZXR0aW5nc1xuICAgIC8vIGNvbnNvbGUubG9nKCctLS0+IENSRUFURSBTRVRUSU5HJy55ZWxsb3cuaW52ZXJzZSlcbiAgICBjdXJyZW50Ll9jYWxsZXIuc2V0U2V0dGluZyh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcGFyZW50OiBmdW5jdGlvbihwYXJlbnQpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tPiBTRVQgU0VUVElORycueWVsbG93LmludmVyc2UpXG5cbiAgICAgICAgZm9yICh2YXIgc3RvcmUgPSB0aGlzW25hbWVdLl9wYXJlbnRTdG9yZSwgaSA9IHN0b3JlID8gc3RvcmUubGVuZ3RoIC0gMSA6IDA7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICBpZihzdG9yZVtpXS5fZmxhZy5wYXJlbnQpIHtcbiAgICAgICAgICAgIF9wYXJlbnQuY2FsbCh0aGlzLCBwYXJlbnQsIGZhbHNlLCB0aGlzW25hbWVdLCBzdG9yZVtpXS5fZmxhZy5wYXJlbnQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJzIgTk8gUEFSRU5UIEZMQUchJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICAvL3RyeSB0byBtaW5pbWl6ZSB2YWwgY2FsdWxhdGlvbnNcbiAgICB0aGlzLl92YWwgPSBfdmFsXG4gICAgdGhpcy5fc2tpcCA9IHRydWVcbiAgICAvL29uSW5pdCAoaWYgaXQgYWxyZWFkeSBoYXMgc29tZSBwYXJlbnRzKVxuICAgIF9pbml0LmNhbGwoY3VycmVudC5fYmFzZSwgY3VycmVudCwgdGhpcy5fZmxhZy5wYXJlbnQsIHJlc2V0KVxuICAgIC8vcmVBdHRhY2ggbGlzdGVuZXJzIGZvciBpbnN0YW5jZXNcbiAgICBjdXJyZW50Ll9iYXNlLmVhY2hJbnN0YW5jZShfaW5pdCwgbmFtZSwgY3VycmVudCwgdGhpcy5fZmxhZy5wYXJlbnQpXG4gIH1cbiwgcmVtb3ZlOiBmdW5jdGlvbihmbGFnKSB7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnUkVNT1ZFIFBBUkVOVCcuY3lhbi5pbnZlcnNlKVxuXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNoZWNrUGFyZW50KCdfcHJvcC5uYW1lJyksXG4gICAgICBiYXNlID0gY3VycmVudC5fYmFzZSxcbiAgICAgIGxpc3RlbnMgPSBjdXJyZW50Ll9saXN0ZW5zLFxuICAgICAgbmFtZSA9IGN1cnJlbnQuX3Byb3AubmFtZSxcbiAgICAgIHZhbCA9IGZsYWdbMl0sICAvL2ZsYWdzLnBhcmVudC52YWxcbiAgICAgIHBhcmVudFN0b3JlID0gY3VycmVudC5fcGFyZW50U3RvcmUsXG4gICAgICByZW1vdmVsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnRbdmFsXSkge1xuICAgICAgICAgIGlmIChsaXN0ZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmNoZWNrQXJyYXkobGlzdGVucywgcGFyZW50W3ZhbF0pKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgTElTVEVORVIhJywgcGFyZW50W3ZhbF0sIGxpc3RlbnMubGVuZ3RoLCBwYXJlbnRbdmFsXS5fbGlzdGVuZXJzLmxlbmd0aCwgcGFyZW50W3ZhbF0uX2xpc3RlbmVycyAsIGN1cnJlbnQpXG5cblxuICAgICAgICAgICAgICAvL21vcmUgc3BlY2lmaWMgb25seSByZW1vdmUgaWYgdmFsIG1hdGNoZXMgLS0tIHN0b3JlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgIHBhcmVudFt2YWxdLnJlbW92ZUxpc3RlbmVyKCBmYWxzZSwgY3VycmVudCApXG5cbiAgICAgICAgICAgICAgLy9tYXJrID0gZmFsc2VcblxuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgTElTVEVORVIhIC0tIHJlc3VsdCAtLSBubyB1cGRhdGU/JywgbGlzdGVucy5sZW5ndGgpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIHRoaXMuX3ZhbCA9IDBcblxuICAgIGlmIChsaXN0ZW5zICYmICFyZW1vdmVsaXN0ZW5lci5jYWxsKGJhc2UpKSB7XG4gICAgICBiYXNlLmVhY2hJbnN0YW5jZShyZW1vdmVsaXN0ZW5lciwgbmFtZSlcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygnUEFSRU5UU1RPUkUnLCBwYXJlbnRTdG9yZSwgY3VycmVudClcbiAgICBwYXJlbnRTdG9yZS5zcGxpY2UodXRpbC5jaGVja0FycmF5KHBhcmVudFN0b3JlLCB0aGlzLCB0cnVlKSwgMSlcblxuICAgIGlmIChwYXJlbnRTdG9yZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+IFJFTU9WRSBTRVRUSU5HJy55ZWxsb3cuaW52ZXJzZSwgcGFyZW50U3RvcmUpXG4gICAgICBiYXNlLnJlbW92ZVNldHRpbmcobmFtZSwgJ3BhcmVudCcpIC8vZmYgY29yaWdlcmVuIHZvb3IgYW5kZXJlIHBhcmVudCBzZXR0aW5ncyEhISBvcCBhbmRlcmUgZmllbGRzXG4gICAgICAvL2RpdCBtYWFrdCBoZXQgaGVsZW1hYWwga2Fwb3QhXG4gICAgICAvLyBjb25zb2xlLndhcm4oJ1JFTU9WRSBQQVJFTlRTVE9SRSEnKVxuICAgICAgY3VycmVudC5fcGFyZW50U3RvcmUgPSBudWxsXG4gICAgfVxuICB9XG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG4vL1RPRE86IGZsYWdzIG9uIHRoZSBiYXNpcyBvZiBwYXRoICggc2ltaWxhaXIgdG8gY2FzZXMgKVxuXG4vL1RPRE86IG1ha2UgVmFsdWUgZmxhZ3MgbW9yZSBpbmplY3RhYmxlXG52YXIgZmxhZ3MgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoICcuLycgKVxuICAsIHByb2Nlc3NlcyA9IHJlcXVpcmUoICcuLi8uLi91dGlsL3Byb2Nlc3MnIClcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoICcuLi8nIClcbiAgLCB1dGlsID0gcmVxdWlyZSggJy4uLy4uL3V0aWwnIClcbiAgLCBhamF4ID0gcmVxdWlyZSgnLi4vLi4vYnJvd3Nlci9uZXR3b3JrL2FqYXgnKVxuICAsIHZPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKVxuXG4vL1RPRE86IG1heWJlIGFkZCBwcm9taXNlXG5cbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24oIGZsYWcsIHNldHRpbmdzLCBDb25zdHJ1Y3RvciwgZXh0ZW5kZmxhZ3MgKSB7XG5cbiAgaWYoICFleHRlbmRmbGFncyApIGV4dGVuZGZsYWdzID0gZmxhZ3NcbiAgaWYoICFDb25zdHJ1Y3RvciApIENvbnN0cnVjdG9yID0gVmFsdWVcblxuICB2YXIgdGVtcFN0b3JlID0gJ19fdGVtcCcrZmxhZysnX18nXG4gICAgLCBpblByb2dyZXNzID0gICdfX2lucHJvZ3Jlc3MnK2ZsYWcrJ19fJ1xuICAgICwgb3JpZ1VwZGF0ZSA9IENvbnN0cnVjdG9yLnByb3RvdHlwZS5fdXBkYXRlXG4gICAgLCBvbmNlID0gc2V0dGluZ3MgJiYgc2V0dGluZ3Mub25jZVxuICAgICwgZGVmZXJNZXRob2QgPSBzZXR0aW5ncyAmJiBzZXR0aW5ncy5kZWZlck1ldGhvZFxuICAgICwgb3JpZ1NldFxuICAgICwgb3JpZ1JlbW92ZVxuICAgICwgZGVmZXJmbGFnID0gXG4gICAgICB7IHJlc2V0OiB0cnVlXG4gICAgICAsIHNldDogZnVuY3Rpb24oIHZhbCwgc3RhbXAsIHJlc2V0ICkge1xuICAgICAgICAgIGlmKCAhdGhpcy5fZmxhZyApIHRoaXMuX2ZsYWcgPSB7fVxuICAgICAgICAgIHRoaXMuX2ZsYWdbZmxhZ10gPSBbIGZsYWcsIGZhbHNlLCB2YWwsIHRoaXMgXVxuICAgICAgICB9XG4gICAgICAsIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIGRlZmVyID0gdGhpcy5fZmxhZyAmJiB0aGlzLl9mbGFnW2ZsYWddXG4gICAgICAgICAgICAsIHZvYmpcblxuICAgICAgICAgIGlmKCBkZWZlciAmJiBkZWZlclsxXSApXG4gICAgICAgICAge1xuXG4gICAgICAgICAgICAvLyBpZiggZGVmZXJNZXRob2QgKSBcbiAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgLy8gdm9iaiA9IGRlZmVyTWV0aG9kLmNhbGwoIF90aGlzLCBhcnIsIGRlZmVyWzJdLCBfdGhpc1t0ZW1wU3RvcmVdLCBvcmlnVXBkYXRlLCBDb25zdHJ1Y3RvciApXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvLyBpZigpIHtcbiAgICAgICAgICAgICAgdm9iaiA9IHR5cGVvZiBkZWZlclsyXSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICA/IHByb2Nlc3Nlc1tkZWZlclsyXV1cbiAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBkZWZlclsyXSAhPT0gJ2Z1bmN0aW9uJyAmJiBkZWZlclsyXVxuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBpZiggdm9iaiAmJiB2b2JqLnJlbW92ZUxpc3RlbmVyIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdm9iai5yZW1vdmVMaXN0ZW5lciggZGVmZXJbMV0gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiggdm9iaiAmJiB2b2JqICE9PSB0cnVlIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgdm9iaiQgaW4gdm9iaiApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2b2JqLnJlbW92ZUxpc3RlbmVyKCB2b2JqW3ZvYmokXSApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2hcbiAgKCB0ZW1wU3RvcmVcbiAgLCBpblByb2dyZXNzXG4gICwgJ19oaXN0b3J5J1xuICAvLyAsICdfaW5pdGlhbGlzZWQnXG4gIClcblxuICBpZiggZGVmZXJNZXRob2QgKSB7XG4gICAgc2V0dGluZ3MuZGVmZXJNZXRob2QgPSBudWxsXG4gIH1cblxuICAgaWYoIG9uY2UgKSB7XG4gICAgc2V0dGluZ3Mub25jZSA9IG51bGxcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCBvbmNlIClcbiAgfVxuXG4gIGlmKCBzZXR0aW5ncyApIHtcbiAgICBmb3IoIHZhciBrZXkgaW4gc2V0dGluZ3MgKVxuICAgIHtcbiAgICAgIGlmKCBrZXkgPT09ICdzZXQnIClcbiAgICAgIHtcbiAgICAgICAgb3JpZ1NldCA9IGRlZmVyZmxhZy5zZXRcbiAgICAgICAgZGVmZXJmbGFnLnNldCA9IGZ1bmN0aW9uKCB2YWwsIHN0YW1wLCByZXNldCApIHtcbiAgICAgICAgICBzZXR0aW5ncy5zZXQuY2FsbCggdGhpcywgb3JpZ1NldCwgYXJndW1lbnRzIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBpZigga2V5ID09PSAncmVtb3ZlJyApXG4gICAgICB7XG4gICAgICAgIG9yaWdSZW1vdmUgPSBkZWZlcmZsYWcucmVtb3ZlXG4gICAgICAgIGRlZmVyZmxhZy5yZW1vdmUgPSBmdW5jdGlvbiggdmFsLCBzdGFtcCwgcmVzZXQgKSB7XG4gICAgICAgICAgc2V0dGluZ3MucmVtb3ZlLmNhbGwoIHRoaXMsIG9yaWdSZW1vdmUsIGFyZ3VtZW50cyApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgXG4gICAgICB7XG4gICAgICAgIGRlZmVyZmxhZ1trZXldID0gc2V0dGluZ3Nba2V5XVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4dGVuZGZsYWdzW2ZsYWddID0gZGVmZXJmbGFnXG5cbiAgLy9leHRlbmQgdXBkYXRlXG4gIHV0aWwuZGVmaW5lXG4gICggQ29uc3RydWN0b3JcbiAgLCAnX3VwZGF0ZSdcbiAgLCBmdW5jdGlvbiggdmFsLCBzdGFtcCApIHtcblxuXG5cbiAgICAgIGlmKCAoIHRoaXMuX2ZsYWcgJiYgdGhpcy5fZmxhZ1tmbGFnXSApICYmICggIW9uY2UgfHwgIXRoaXNbb25jZV0gKSApIC8vJiYgIXRoaXMuX2luaXRpYWxpc2VkIFxuICAgICAge1xuXG4gICAgICAgIC8vIHRoaXMuY2xlYXJDYWNoZSgpXG5cbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignX3VwZGFjZScsIHZhbCwgdGhpcy5fcGF0aClcblxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCAnJEVFRUVFMScsIHRoaXMuX3BhdGgpXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5fcGF0aCwgdmFsLCBzdGFtcClcbiAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgICAgICwgZGVmZXIgPSBfdGhpcy5fZmxhZyAmJiBfdGhpcy5fZmxhZ1tmbGFnXVxuICAgICAgICAgICwgdGVtcGRlZmVyID0gX3RoaXNbdGVtcFN0b3JlXVxuICAgICAgICAgICwgYWRkXG4gICAgICAgICAgLCBhcnJcbiAgICAgICAgICAsIHZvYmpcbiAgICAgICAgICAsIHJlY3VyXG4gICAgICAgICAgLCBmblxuXG4gICAgICAgIGlmKCAhdGVtcGRlZmVyIClcbiAgICAgICAge1xuICAgICAgICAgIF90aGlzW3RlbXBTdG9yZV0gPSB0ZW1wZGVmZXIgPSBbXVxuICAgICAgICAgIGFkZCA9IHRydWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL1RPRE86IGZpeCBjYWNoaW5nIHN0YW1wLCBtb3N0IGVmZmljaWVudCBidXQgbWF5IGJyZWFrIHRoaW5ncyAvdyBpbnN0YW5jZXMgZXRjXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3N0YW1wIGNhaGNpbmcnLCB0aGlzLl9wYXRoKVxuXG4gICAgICAgICAgaWYoIHN0YW1wICYmIHRlbXBkZWZlclswXVsxXSAhPT0gc3RhbXAgKVxuICAgICAgICAgIHtcblxuICAgICAgICAgICAgLy8gdGVtcGRlZmVyLnB1c2godXRpbC5hcmcoIGFyZ3VtZW50cyApKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3N0YW1wIGNhaGNpbmcgcGFzcycgLCB0aGlzLl9wYXRoLCB0ZW1wZGVmZXIpXG4gICAgICAgICAgICAvLyB0ZW1wZGVmZXJbMF1bMF0gPSB2YWxcbiAgICAgICAgICAgIC8vIHRlbXBkZWZlclswXVsxXSA9IHN0YW1wXG4gICAgICAgICAgICB2YXIgYXJnID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgICAgICAgICAgZm9yKHZhciBpIGluIGFyZykge1xuICAgICAgICAgICAgICB0ZW1wZGVmZXJbMF1baV0gPSBhcmdbaV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cblxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdfdXBkYWNlIDMnLCB2YWwsIHRoaXMuX3BhdGgpXG5cbiAgICAgICAgIC8vIGlmKHRoaXMuX25hbWUgPT09ICckdGVzdCcpIGNvbnNvbGUubG9nKCdzdG9wIGl0cycpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBhcnIgPSB1dGlsLmFyZyggYXJndW1lbnRzIClcblxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdfdXBkYWNlIDInLCB2YWwsIHRoaXMuX3BhdGgpXG5cbiAgICAgICAgdGVtcGRlZmVyLnB1c2goIGFyciApXG5cbiAgICAgICAgaWYoIGFkZCApXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBpZih0aGlzLl9uYW1lID09PSAnJHRlc3QnKSBjb25zb2xlLmVycm9yKCdkbyBpdCAxJylcblxuICAgICAgICAgIGlmKCBkZWZlck1ldGhvZCApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZvYmogPSBkZWZlck1ldGhvZC5jYWxsKCBfdGhpcywgYXJyLCBkZWZlclsyXSwgdGVtcFN0b3JlLCBvcmlnVXBkYXRlLCBDb25zdHJ1Y3RvciwgaW5Qcm9ncmVzcyApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgXG4gICAgICAgICAge1xuICAgICAgICAgICAgdm9iaiA9IHR5cGVvZiBkZWZlclsyXSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgID8gcHJvY2Vzc2VzW2RlZmVyWzJdXVxuICAgICAgICAgICAgICAgOiBkZWZlclsyXVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCB2b2JqIClcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2hleWhvMiEhISEhJywgdmFsLHRoaXMuX3BhdGgpXG5cbiAgICAgICAgICBcbiAgICAgICAgICAgIC8vVE9ETzogcmVwbGFjZSB3aXRoIGEgc3RhbmRhcmQgZnVuY3Rpb24sIGxvc2UgdGhlIGV4dHJhIGNsb3N1cmUhXG4gICAgICAgICAgICByZWN1ciA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgIGlmKCBvbmNlICkgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBfdGhpc1tvbmNlXSA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL2RpdCBvb2sga3VubmVuIG1lZWdldmVuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignTEVUUyBUUlknKVxuXG4gICAgICAgICAgICAgIC8vVE9ETzogdXNpbmcgYSBjbG9zdXJlIGhlcmUgbWF5IG5vdCBiZSBuZXNzZWNhcnkgYW55bW9yZSwgdXNlIGFub3RoZXIgaWRlbnRpZmllclxuICAgICAgICAgICAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRlbXBkZWZlci5sZW5ndGg7IGkrKyApIHsgLy9sZW5ndGggbmVlZHMgdG8gdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gX3RoaXMuX2NhbGxlciA9IHRlbXBkZWZlcltpXS5zcGxpY2UoIHRlbXBkZWZlcltpXS5sZW5ndGgtMSwgMSApXG4gICAgICAgICAgICAgICAgLy8gdGVtcGRlZmVyW2ldWzFdID0gdGhpcy5zdGFtcCgpXG4gICAgICAgICAgICAgICAgLy8gdHJ5e1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignTEVUUyBUUlkgZ28gZ28gZ28nLHZhbCwgaSwgdGVtcGRlZmVyW2ldKVxuICAgICAgICAgICAgICAgICAgLy8gdmFyIHN0YW1weCA9IHRlbXBkZWZlcltpXVsxXVxuICAgICAgICAgICAgICAgICAgICAvLyAsIHZhbHggPSB0ZW1wZGVmZXJbaV1bMF1cblxuICAgICAgICAgICAgICAgICAgb3JpZ1VwZGF0ZS5hcHBseSggX3RoaXMsIHRlbXBkZWZlcltpXSApICBcblxuICAgICAgICAgICAgICAgICAgLy8gaWYoICh0ZW1wZGVmZXJbaV1bMV0gJiYgdGVtcGRlZmVyW2ldWzFdIT09c3RhbXB4KSB8fCAodGVtcGRlZmVyW2ldWzBdICYmIHRlbXBkZWZlcltpXVswXSE9PXZhbHgpICkge1xuICAgICAgICAgICAgICAgICAgLy8gICBjb25zb2xlLndhcm4oJ2RlZmVyIG5ldyB1cGRhdGUgd2l0aGluIHRoZSBsb29wIG5vdyBpdCBmaXJlcyEgLS0gYmUgY2FyZWZ1bGwgbWF5IGJyZWFrJylcbiAgICAgICAgICAgICAgICAgIC8vICAgdmFyIHJlZiA9IHRlbXBkZWZlcltpXVxuICAgICAgICAgICAgICAgICAgLy8gICAvLyBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgICAvLyAgICAgX3RoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgICAgICAgICAvLyAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcbiAgICAgICAgICAgICAgICAgIC8vICAgICBfdGhpc1tpblByb2dyZXNzXSA9IG51bGxcbiAgICAgICAgICAgICAgICAgIC8vICAgICBfdGhpcy5jbGVhclJlZmVyZW5jZXNDYWNoZSgpXG4gICAgICAgICAgICAgICAgICAvLyAgICAgLy8gY29uc29sZS5sb2coJz8/Pz8/JyxyZWYpXG4gICAgICAgICAgICAgICAgICAvLyAgICAgX3RoaXMuX3VwZGF0ZS5hcHBseSggX3RoaXMsIHJlZiApIFxuICAgICAgICAgICAgICAgICAgLy8gICAvLyB9ICwxMDApIFxuICAgICAgICAgICAgICAgICAgLy8gICAvLyBhbGVydCgnbmV3IHVwZGF0ZSBzZXQgd2l0aGluIGxvb3AhJylcblxuICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIC8vIH1jYXRjaChlKXtjb25zb2xlLmVycm9yKCdXQScsIGUpfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy9saXN0ZW5lciBnZXRzIHJlbW92ZWQgYnV0IG9yZGVyIGlzIGRpZmZlcmVudFxuICAgICAgICAgICAgICBpZiggdGhpcy5yZW1vdmVMaXN0ZW5lciApIHRoaXMucmVtb3ZlTGlzdGVuZXIoIHJlY3VyIClcblxuICAgICAgICAgICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdHlwZW9mIHZvYmogPT09ICdmdW5jdGlvbicgKVxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgIGlmKCAhX3RoaXNbaW5Qcm9ncmVzc10gKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmbiA9IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgIGlmKCB2YWwhPT10cnVlICYmIF90aGlzW2luUHJvZ3Jlc3NdICkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpc1tpblByb2dyZXNzXSgpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBfdGhpc1tpblByb2dyZXNzXSA9IG51bGxcbiAgICAgICAgICAgICAgICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXNbaW5Qcm9ncmVzc10gPSByZWN1clxuXG4gICAgICAgICAgICAgICAgaWYoIHZvYmouY2FsbCggdGhpcywgZm4gLCBhcnIsIHRlbXBkZWZlciApID09PSB0cnVlIClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuICAgICAgICAgICAgICAgICAgX3RoaXNbaW5Qcm9ncmVzc10gPSBudWxsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2VcbiAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZyggJz8nIClcbiAgICAgICAgICAgICAgICAvLyAgIC8vVE9ETzogY2hlY2sgaWYgdGhpcyBpcyB0aGUgYmVzdCB3YXksICh1cGRhdGluZyByZWN1ciwgb3IgbWF5ZWIganVzdCB1c2UgdGhlIHNhbWUgcmVjdXIpXG4gICAgICAgICAgICAgICAgLy8gICBfdGhpcy5fZGVmZXJpbnByb2dyZXNzID0gcmVjdXJcbiAgICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKCB2b2JqID09PSB0cnVlIClcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICBpZiggdGhpcy52YWwgfHwgdGhpcy52YWwgPT09IDAgKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3JpZ1VwZGF0ZS5hcHBseSggX3RoaXMsIGFyciApXG4gICAgICAgICAgICAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcbiAgICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdubyB2YWx1ZSEgZnJvbSBkZWZlciB0eXBlOicsIGZsYWcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoICF2b2JqLmFkZExpc3RlbmVyIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZm9yKCB2YXIgdm9iaiQgaW4gdm9iaiApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2b2JqW3ZvYmokXS5hZGRMaXN0ZW5lciggcmVjdXIgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgdm9iai5hZGRMaXN0ZW5lciggcmVjdXIgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZlclsxXSA9IHJlY3VyXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coIGZsYWcsIG9uY2UsICdzaG91bGQgZG8gb3JpZyB1cGRhdGUgYml0Y2hlcyEnLCBhcmd1bWVudHMsIHRoaXMgKVxuICAgICAgICBvcmlnVXBkYXRlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgfVxuXG4gICAgfVxuICApXG5cbn0gXG5cbi8vVE9ETzogaW5qZWN0YWJsZVxuLy9UT0RPOl90ZW1wZGVmZXIgaG9lZnQgbmlldCBhbHRpamQgbWFhayBjcmVhdGUgLS0gdXBkYXRlIHR5cGUgZmxhZ1xuLy9hbHdheXMgdXBkYXRlIG1ldGhvZFxuLy8gZXhwb3J0cy5jcmVhdGUoICdmb3JjZScsIFxuLy8geyBkZWZlck1ldGhvZDogZnVuY3Rpb24oIGFyZ3MsIHZvYmosIHRlbXBTdG9yZSwgdXBkYXRlICkge1xuLy8gICAgIHZhciBfdGhpcyA9IHRoaXNcbi8vICAgICAvL2RpdCB6aXQgbmF0dXVybGlqayBkaWVwZXIhXG4vLyAgICAgX3RoaXMuX3NraXAgPSB0cnVlIC8vbWF5YmUgY2hlY2sgaWYgaXQgcmx5IGdldHMgcmVzZXQ/XG4vLyAgICAgX3RoaXMuX2lnbm9yZVZhbHVlID0gdHJ1ZVxuLy8gICAgIF90aGlzLmNsZWFyQ2FjaGUoKVxuLy8gICAgIF90aGlzWyB0ZW1wU3RvcmUgXSA9IG51bGxcbi8vICAgICB1cGRhdGUuYXBwbHkoIF90aGlzLCBhcmdzIClcbi8vICAgfSAgXG4vLyB9KVxuLy9kZXplIG1vZXQgbm9nIHdhdCBkaWVwZXJcblxuLy8gZXhwb3J0cy5jcmVhdGUoICdoaXN0b3J5JywgXG4vLyB7IGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUsIENvbnN0cnVjdG9yICkge1xuLy8gICAgIC8vdm9iaiBvcHRpb24gdm9vciBmbGFnXG4vLyAgICAgaWYoIXRoaXMuX2hpc3RvcnkpIHRoaXMuX2hpc3RvcnkgPSBbXVxuXG4vLyAgICAgdGhpcy5faGlzdG9yeS51bnNoaWZ0KCBhcmdzIClcbi8vICAgICB0aGlzW3RlbXBTdG9yZV0gPSBudWxsIC8vdG90YWwgY29udHJvbCEgKG9sZCBpbmNsdWRpbmcgYXJndW1lbnRzKVxuXG4vLyAgICAgLy9hbGxyaWdodCB0aGF0IHdvcmtzIHRoaXMuY2xlYXJDYWNoZSgpIC8vY2FjaGUgZGluZ2VuIGFkZGVuXG4vLyAgICAgdXBkYXRlLmFwcGx5KCB0aGlzLCBhcmdzIClcbi8vICAgfVxuLy8gfSlcblxuLy8gZXhwb3J0cy5jcmVhdGUoICckdHlwZScsIFxuLy8geyBkZWZlck1ldGhvZDogZnVuY3Rpb24oIGFyZ3MsIHZvYmosIHRlbXBTdG9yZSwgdXBkYXRlICkge1xuLy8gICAgIHZhciBfdGhpcyA9IHRoaXNcbi8vICAgICAgICwgaGF2ZVRvVXBkYXRlXG5cbi8vICAgICAvL2FycmF5cyBldGNcbi8vICAgICBfdGhpcy5jbGVhckNhY2hlKClcblxuLy8gICAgIGlmKCB2b2JqID09PSB0cnVlIClcbi8vICAgICB7XG4vLyAgICAgICBpZiggX3RoaXMudmFsICkgaGF2ZVRvVXBkYXRlID0gdHJ1ZVxuLy8gICAgIH1cbi8vICAgICBlbHNlIGlmKCB2b2JqID09PSAnc3RyaW5nJyApXG4vLyAgICAge1xuLy8gICAgICAgaWYoIHR5cGVvZiBfdGhpcy52YWwgPT09ICdzdHJpbmcnICkgaGF2ZVRvVXBkYXRlID0gdHJ1ZVxuLy8gICAgIH1cbi8vICAgICBlbHNlIGlmKCB2b2JqID09PSAnbnVtYmVyJyApXG4vLyAgICAge1xuLy8gICAgICAgaWYoIHR5cGVvZiBfdGhpcy52YWwgPT09ICdudW1iZXInICkgaGF2ZVRvVXBkYXRlID0gdHJ1ZVxuLy8gICAgIH1cbi8vICAgICBlbHNlIGlmKCB0eXBlb2Ygdm9iaiA9PT0gJ2Z1bmN0aW9uJyApXG4vLyAgICAge1xuLy8gICAgICAgaWYoIHZvYmouYXBwbHkoIF90aGlzLCBhcmdzICkgKSBoYXZlVG9VcGRhdGUgPSB0cnVlXG4vLyAgICAgfVxuXG4vLyAgICAgaWYoIGhhdmVUb1VwZGF0ZSApIHtcbi8vICAgICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4vLyAgICAgICB1cGRhdGUuYXBwbHkoIF90aGlzLCBhcmdzIClcbi8vICAgICB9XG4vLyAgIH0gIFxuLy8gfSlcblxuZXhwb3J0cy5jcmVhdGUoICckYnViYmxlJywgeyBcbiAgZGVmZXJNZXRob2Q6IGZ1bmN0aW9uKCBhcmdzLCB2b2JqLCB0ZW1wU3RvcmUsIHVwZGF0ZSApIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgdmFyIGRvVXBkYXRlXG4gICAgdmFyIHJlZmVyZW5jZXNcbiAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuXG4gICAgaWYoIHZvYmogKSB7XG4gICAgICBpZihyZWZlcmVuY2VzID0gdm9iai5yZWZlcmVuY2VzKSB7XG4gICAgICAgIGlmKHJlZmVyZW5jZXMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBpZihyZWZlcmVuY2VzLiRsdGUgXG4gICAgICAgICAgICAmJiBfdGhpcy5yZWZlcmVuY2VMZXZlbChfdGhpcy5fdXBkYXRlT3JpZ2luKSA8PSByZWZlcmVuY2VzLiRsdGUgXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBkb1VwZGF0ZSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZihyZWZlcmVuY2VzID4gLTEpIHtcbiAgICAgICAgICAvL2Fsc28gbWF4aW11bSBmb3IgZXhhbXBsZVxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoX3RoaXMuX3BhdGgsIF90aGlzLnJlZmVyZW5jZUxldmVsKF90aGlzLl91cGRhdGVPcmlnaW4pLCAndU9yaWdpblBhdGgnLCBfdGhpcy5fdXBkYXRlT3JpZ2luLl9wYXRoLCAnLl92YWwnLF90aGlzLl92YWwuX3BhdGgsICAnY2xvdWQnLCAhIV90aGlzLl92YWwuY2xvdWQpXG4gICAgICAgICAgaWYoIF90aGlzLnJlZmVyZW5jZUxldmVsKF90aGlzLl91cGRhdGVPcmlnaW4pID09PSByZWZlcmVuY2VzICkge1xuICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgfSBcbiAgICAgICAgfSBcbiAgICAgICAgLy8gZWxzZSBpZihyZWZlcmVuY2VzID09PSB0cnVlKSB7XG4gICAgICAgIC8vICAgLy9vbmx5IGlmIHJlZmZlcmVuY2VcbiAgICAgICAgLy8gICBpZihfdGhpcy5yZWZlcmVuY2VMZXZlbChfdGhpcy5fdXBkYXRlT3JpZ2luKSE9PWZhbHNlKSB7XG4gICAgICAgIC8vICAgICBkb1VwZGF0ZSA9IHRydWVcbiAgICAgICAgLy8gICB9IFxuICAgICAgICBcbiAgICAgICAgLy8gfVxuXG4gICAgICB9IGVsc2UgaWYoIHZvYmogJiYgdm9iai5zZWxmID09PSB0cnVlICl7XG5cbiAgICAgICAgICBpZiggYXJnc1syXSA9PT0gdm9pZCAwIHx8IHRoaXMuX3ZhbCA9PT0gYXJnc1swXSB8fCAhYXJnc1swXSAmJiB0aGlzLl91cGRhdGVPcmlnaW49PT10aGlzKSB7XG4gICAgICAgICAgICBkb1VwZGF0ZSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGRvVXBkYXRlKSB7ICBcbiAgICAgICAgICB1cGRhdGUuYXBwbHkoX3RoaXMsIGFyZ3MpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMuY2xlYXJSZWZlcmVuY2VzQ2FjaGUoKVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZS5hcHBseShfdGhpcywgYXJncylcbiAgICAgIH1cblxuICAgXG4gIH0gIFxufSlcblxuZXhwb3J0cy5jcmVhdGUoICdkZWZlcicgKVxuXG4vL1RPRE86IHZPYmogZmxhZyAoIGFjY2Vzc2FibGUgdHJvdWdoIG9iamVjdFtmbGFnXSApXG5cblZhbHVlLm9wZXJhdG9ycy5yZXNwb25zZURhdGEgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIG9wZXJhdG9yPT09ZmFsc2UgPyB2YWwgOiBvcGVyYXRvclxufVxuXG4vL3ZvYmogcGFyc2VyIVxuXG5leHBvcnRzLmNyZWF0ZSggJ2FqYXgnLCBcbnsgcmVtb3ZlOiBmdW5jdGlvbiggcmVtb3ZlLCBhcmdzICkge1xuICAgIC8vVE9ETzogYWpheCBjYWxsIHN0b3BcbiAgICByZW1vdmUuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICB9XG4sIHNldDpmdW5jdGlvbiggc2V0LCBhcmdzKSB7XG4vLyAgICAgY29uc29sZS5sb2coJ3NldCBhamF4IGRlZmVyJylcbiAgICBpZiggISB0aGlzLmxvYWRpbmcgKSB7XG4gICAgICAvL25hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tXG4gICAgICB0aGlzLnNldCggJ2xvYWRpbmcnLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlIClcbiAgICB9XG4gICAgc2V0LmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgfVxuLCBkZWZlck1ldGhvZDogZnVuY3Rpb24oIGFyZ3MsIHZvYmosIHRlbXBTdG9yZSwgdXBkYXRlLCBDb25zdHJ1Y3RvciApIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzICBcblxuICAgIHJldHVybiB2b2JqICYmIGZ1bmN0aW9uKCB1cGRhdGUsIGFyZ3MgKSB7XG5cbiAgICAgIHZhciBvcmlndSA9IHVwZGF0ZVxuXG4gICAgICB1cGRhdGUgPSBmdW5jdGlvbiggdHlwZSwga2lsbCApIHtcbiAgICAgICAgX3RoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAgIF90aGlzLl9za2lwID0gdHJ1ZVxuICAgICAgICBfdGhpcy5faWdub3JlVmFsdWUgPSB0cnVlXG4gICAgICAgIGlmKCB0eXBlICkge1xuICAgICAgICAgIGFyZ3NbMF0gPSB0eXBlXG4gICAgICAgICAgaWYoISAoIF90aGlzLl92YWwgaW5zdGFuY2VvZiB2T2JqZWN0ICkgKSB7XG4gICAgICAgICAgICBfdGhpcy52YWwgPSB0eXBlXG4gICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgICAgICBpZiggX3RoaXMubG9hZGluZyApIF90aGlzLmxvYWRpbmcudmFsID0gZmFsc2VcbiAgICAgICAgb3JpZ3UoIGtpbGwgKVxuICAgICAgICBfdGhpcy5faWdub3JlVmFsdWUgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlb2Ygdm9iaiA9PT0gJ29iamVjdCcgKVxuICAgICAge1xuICAgICAgICB2YXIgcGFyYW1zID0gdm9ialxuICAgICAgICB2b2JqID0ge31cbiAgICAgICAgZm9yKCB2YXIga2V5IGluIHBhcmFtcyApIHtcbiAgICAgICAgICBpZigga2V5ID09PSAnZGVmZXInICkge1xuICAgICAgICAgICAgdm9ialtrZXldID0gcGFyYW1zW2tleV1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYoIXZvYmpba2V5XSkge1xuICAgICAgICAgICAgICBpZigga2V5ICE9PSAnY29tcGxldGUnICYmIGtleSAhPT0gJ2Vycm9yJyAmJiB0eXBlb2YgcGFyYW1zW2tleV0gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgICAgICAgdm9ialsga2V5IF0gPSBwYXJhbXNbIGtleSBdLmNhbGwoIF90aGlzLCB2b2JqLCBhcmdzWzBdLCBhcmdzIClcbiAgICAgICAgICAgICAgICBpZiggIXZvYmpba2V5XSApIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZvYmpba2V5XSA9IHBhcmFtc1trZXldXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiggdm9ialtrZXldIGluc3RhbmNlb2Ygdk9iamVjdCApIHtcbiAgICAgICAgICAgICAgICB2b2JqW2tleV0gPSB2b2JqW2tleV0udmFsIC8vY3VzdG9tIGdldCBvciByYXdcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGVvZiB2b2JqID09PSAnZnVuY3Rpb24nICkgXG4gICAgICB7XG4gICAgICAgIHZvYmogPSB2b2JqLmNhbGwoIF90aGlzLCB2b2JqLCBhcmdzWzBdLCBhcmdzIClcbiAgICAgICAgaWYoIXZvYmopIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlb2Ygdm9iaiA9PT0gJ3N0cmluZycgKSBcbiAgICAgIHtcbiAgICAgICAgdm9iaiA9IHsgdXJsOiB2b2JqIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHZvYmoudXJsIGluc3RhbmNlb2Ygdk9iamVjdCApIHtcbiAgICAgICAgdm9iai51cmwgPSB2b2JqLnVybC52YWxcbiAgICAgIH1cblxuICAgICAgaWYoICF2b2JqIHx8ICEoIHZvYmoudXJsIHx8IHZvYmouYXBpICkgKSBcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbXBsZXRlID0gdm9iai5jb21wbGV0ZVxuICAgICAgICAsIGVycm9yID0gdm9iai5lcnJvclxuXG4gICAgICB2b2JqLmNvbXBsZXRlID0gZnVuY3Rpb24oIGRhdGEgKSB7XG4gICAgICAgIGlmKCB2b2JqLmRlZmVyICkgXG4gICAgICAgIHtcbiAgICAgICAgICB2b2JqLmRlZmVyLmNhbGwoIF90aGlzLCB1cGRhdGUsIGFyZ3MsIG51bGwsIGRhdGEsIHZvYmogKVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIGlmKCFfdGhpcy5yZXNwb25zZURhdGEpIHtcbiAgICAgICAgICAgIF90aGlzLnNldCggJ3Jlc3BvbnNlRGF0YScsIGRhdGEgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlRGF0YS5tZXJnZSggZGF0YSApXG4gICAgICAgICAgfVxuICAgICAgICAgIDtjb21wbGV0ZSAmJiBjb21wbGV0ZSggZGF0YSApXG4gICAgICAgICAgdXBkYXRlKCAnc3VjY2VzcycgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZvYmouZXJyb3IgPSBmdW5jdGlvbiggZXJyICkge1xuICAgICAgICBpZiggdm9iai5kZWZlciApIFxuICAgICAgICB7XG4gICAgICAgICAgdm9iai5kZWZlci5jYWxsKCBfdGhpcywgdXBkYXRlLCBhcmdzLCBlcnIsIHZvYmogKVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIGlmKCBfdGhpcy5yZXNwb25zZURhdGEgKVxuICAgICAgICAgIHsgXG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZURhdGEuZWFjaCggZnVuY3Rpb24oIGtleSApIHtcbiAgICAgICAgICAgICAgaWYoICFDb25zdHJ1Y3Rvci5vcGVyYXRvcnNba2V5XSAmJiAhQ29uc3RydWN0b3IuZmxhZ3Nba2V5XSApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLnNldCggJ3Jlc3BvbnNlRGF0YScgLCB2b2lkIDAgKVxuICAgICAgICAgIGlmKCBlcnJvciApIGVycm9yKCBkYXRhIClcbiAgICAgICAgICB1cGRhdGUoICdlcnJvcicgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCBfdGhpcy5sb2FkaW5nICkge1xuICAgICAgICAvL1RPRE86Y29ycmVjdCByZXNwb25zZXMgbWFuYWdlbWV0IC0tIHByZXR0eSBlYXN5IHRvZG9cbiAgICAgICAgX3RoaXMubG9hZGluZy52YWwgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIGFqYXgoIHZvYmogKSAvL1RPRE86IGxldCBpdCByZXR1cm4gYSBwcm9taXNlXG4gICAgfSAgXG4gIH1cbn0pXG5cbi8vdGVtcCBhcmdzIFxuXG4vL1RPRE86IGRpdCBsYXRlciB2ZXJ2YW5nZW4gbWV0IGxvY2FsIGZsYWdzIChhcGkpXG4vL1RPRE86IHVuaWZ5IGFqYXggaGllcm1lZSB2b29yIG9uY3NpdGVudCBlcnJvciBoYW5kZWxpbmcgLS0gb2YgZXh0ZW5zaW9uIG9wIGFqYXhcbmV4cG9ydHMuY3JlYXRlKCAnYXBpRGVmZXInLCBcbnsgcmVtb3ZlOiBmdW5jdGlvbiggcmVtb3ZlLCBhcmdzICkge1xuICAgIC8vVE9ETzogYWpheCBjYWxsIHN0b3BcbiAgICByZW1vdmUuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICB9XG4sIHNldDpmdW5jdGlvbiggc2V0LCBhcmdzKSB7XG4gICAgaWYoISB0aGlzLmxvYWRpbmcgKSB7XG4gICAgICB0aGlzLnNldCggJ2xvYWRpbmcnLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlIClcbiAgICB9XG4gICAgc2V0LmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgfVxuLCBkZWZlck1ldGhvZDogZnVuY3Rpb24oIGFyZ3MsIHZvYmosIHRlbXBTdG9yZSwgdXBkYXRlLCBDb25zdHJ1Y3RvciwgaW5Qcm9ncmVzcyApIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzICBcbiAgIFxuICAgIHJldHVybiB2b2JqICYmIGZ1bmN0aW9uKCB1cGRhdGUsIGFyZ3MgKSB7XG5cbiAgICAgIGlmKCAhYXJnc1swXSB8fCBhcmdzWzBdLmFwaURlZmVyICkgcmV0dXJuIHRydWVcblxuICAgICAgdmFyIHdyYXBwZWRVcGRhdGUgPSBmdW5jdGlvbiggdmFsLCBraWxsICkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0RPIERPIERPJywgdmFsLCBfdGhpcywgdGVtcFN0b3JlLCBfdGhpc1t0ZW1wU3RvcmVdKVxuXG4gICAgICAgIC8vIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4gICAgICAgICAgIFxuICAgICAgICAvLyBfdGhpc1tpblByb2dyZXNzXSA9IG51bGxcblxuXG4gICAgICAgIF90aGlzLmxvYWRpbmcudmFsID0gZmFsc2VcbiAgICAgICAgaWYoIHZhbCAmJiB2YWwhPT10cnVlICkgXG4gICAgICAgIHtcbiAgICAgICAgICBfdGhpcy52YWwgPSBhcmdzWzBdID0gdmFsXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHVwZGF0ZSggdmFsICkgLy92YWwgLS0gdmFsXG4gICAgICAgICAgfSBjYXRjaCggZXJyICkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvciggJ0RFRVBFUiBFUlJPUiBJTiBBUEkgREVGRVIgLCBTT01FVEhJTkcgV1JPTkcgL3cgdGhpcyBBUEknLCB2YWwgKVxuICAgICAgICAgICAgLy9iZXN0IGV4YW1wbGUgaXMgZmFjZWJvb2sgbG9naW4gdHJ1ZSBhbmQgZ29uZSBidXQgb25seSB3ZWggdGhlIC5sb2FkaW5nIGlzIHRoZXJlXG4gICAgICAgICAgICAvL21vc3QgYmUgYSB2ZXJ5IGRlZXAgaXNzdWVzIGkgZ2V1c3MuLi4gaGFyZCB0byByZWNyZWF0ZSBcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSBlcnJcblxuICAgICAgICAgICAgLy90aGlzIGlzIHdyb25nIG1pc3NlcyBfdGhpcyBjYWxsIGFuZCBvdGhlciBhcmdzXG4gICAgICAgICAgICB1cGRhdGUoICdlcnJvcicgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgIF90aGlzLl92YWwgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgXG4gICAgICAgIHtcbiAgICAgICAgICAvL3RoaXMgaXMgd3JvbmcgbWlzc2VzIF90aGlzIGNhbGwgYW5kIG90aGVyIGFyZ3NcbiAgICAgICAgICB1cGRhdGUoIHZhbCApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgX3RoaXMubG9hZGluZy52YWwgPSB0cnVlXG4gICAgICB2YXIgYXBpID0gX3RoaXMuY2hlY2tQYXJlbnQoICdhcGknLCB0cnVlIClcblxuICAgICAgaWYoIGFwaSAmJiBhcGkudmFsICE9PSB0cnVlICkgXG4gICAgICB7XG5cbiAgICAgICAgYXBpLm9uY2UoZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgICAgICBpZiggdmFsID09PSAnZXJyb3InICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgX3RoaXMuY2xlYXJDYWNoZSgpIC8vaGllciBmZiBlZW4gZnVuY3RpZSB2b29yIG1ha2VuIVxuICAgICAgICAgICAgX3RoaXMudmFsID0gYXJnc1swXSA9ICdlcnJvcidcbiAgICAgICAgICAgIF90aGlzLnR5cGUgPSB0aGlzLnR5cGUgfHwgJ2FwaSdcbiAgICAgICAgICAgIF90aGlzLmxvYWRpbmcudmFsID0gZmFsc2VcbiAgICAgICAgICAgIHdyYXBwZWRVcGRhdGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCB2YWwgPT09IHRydWUgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZvYmouY2FsbCggX3RoaXMsIHdyYXBwZWRVcGRhdGUsIGFyZ3MgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgYXBpLnZhbCA9IHRydWVcbiAgICAgIH0gXG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgIHZvYmouY2FsbCggX3RoaXMsIHdyYXBwZWRVcGRhdGUsIGFyZ3MgKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSlcblxuZXhwb3J0cy5jcmVhdGUoICdpbml0JywgXG57IHNldDogZnVuY3Rpb24oIHNldCwgYXJncyApIHtcbiAgICBpZiggIXRoaXMuaW5pdGlhbGlzZWQgKVxuICAgIHtcbiAgICAgIHNldC5hcHBseSggdGhpcywgYXJncyApIC8vbmlldCBub2RpZyFcbiAgICB9XG4gIH1cbiwgcmVtb3ZlOiBmdW5jdGlvbiggcmVtb3ZlLCBhcmdzICkge1xuICAgIHJlbW92ZS5hcHBseSggdGhpcywgYXJncyApXG4gICAgdGhpcy5pbml0aWFsaXNlZCA9IG51bGxcbiAgfVxuLCBvbmNlOiAnaW5pdGlhbGlzZWQnXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBmbGFncyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKTtcblxuLyoqXG4gKiBzZWxmXG4gKiBAZmxhZ1xuICovXG5mbGFncy5zZWxmID0ge1xuICByZXNldDogdHJ1ZSxcbiAgdXNlVmFsOnRydWUsXG4gIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wLm5hbWUnKVxuICAgIGlmIChjdXJyZW50Ll9iYXNlICYmIGN1cnJlbnQuX2Jhc2VbdmFsXSkge1xuICAgICAgY3VycmVudC5fYmFzZVt2YWxdLmFkZExpc3RlbmVyKHRoaXMpXG4gICAgICB0aGlzLl92YWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdmFsXSAmJiB0aGlzW3ZhbF0udmFsXG4gICAgICB9XG4gICAgICBpZighdGhpcy5fZmxhZykgIHRoaXMuX2ZsYWcgPSB7fVxuICAgICAgdGhpcy5fZmxhZy5zZWxmID0gWydzZWxmJywgdGhpcy5fdmFsLCB2YWwsIHRoaXNdXG4gICAgfVxuICB9XG59O1xuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgZmxhZ3MgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJylcbi8qKlxuICogbGlzdGVuXG4gKiBhZGRzIGxpc3RlbmVycyB0byBhIFYuVmFsdWVcbiAqIEBwcm9wZXJ0eVxuICoqL1xuZmxhZ3MubGlzdGVuID0ge1xuICByZXNldDp0cnVlLFxuICBzZXQ6IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIHJlc2V0KSB7XG4gICAgaWYoIXZhbClcbiAgICB7XG4gICAgICBjb25zb2xlLmVycm9yKCdubyB2YWwgaW4gZmxhZ3MgbGlzdGVuIScpXG4vLyAgICAgICBkZWJ1Z2dlclxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmKCF0aGlzLl9mbGFnKSB0aGlzLl9mbGFnID0ge31cbiAgICAvL2V2ZW50dWVlbCBtZXJnZW4hXG4gICAgICBcbiAgICAvLyBjb25zb2xlLmxvZygnbGlzdGVuJy5jeWFuLmludmVyc2UsIHJlc2V0LCB2YWwpXG4gICAgLy9pZiByZXNldCBtYWtlIHN1cmUgaXRzIHJlc2V0dGVkIGNvcnJlY3RseSFcbiAgICB0aGlzLl9mbGFnLmxpc3RlbiA9IFsnbGlzdGVuJywgZmFsc2UsIHZhbCwgdGhpcyBdIFxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZm9yICh2YXIgaSA9IHZhbC5sZW5ndGggLSAxOyBpID49IDA7IHZhbFtpLS1dLmFkZExpc3RlbmVyKHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy9va1xuICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgLy8gdmFsLmFkZExpc3RlbmVyKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gICBjb25zb2xlLmxvZygnVFJPVUdIIExJU1RFTiEhISEnLm1hZ2VudGEuaW52ZXJzZSwgdmFsLl9wYXRoKVxuICAgICAgLy8gICAvLyBfdGhpcy5fdXBkYXRlLmFwcGx5KF90aGlzLCBhcmd1bWVudHMpXG4gICAgICAvLyB9KSBcbiAgICAgIHZhbC5hZGRMaXN0ZW5lcih0aGlzKSAvL2RpdCBtb2V0IGJldGVyIChyZW1vdmUgbGlzdGVuZXIgaWYgcG9zc2libGUpXG4gICAgfVxuICB9LFxuICByZW1vdmU6ZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5fZmxhZyYmdGhpcy5fZmxhZy5saXN0ZW4pIHtcbiAgICAgIHZhciB2YWwgPSB0aGlzLl9mbGFnLmxpc3RlblsyXVxuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSB2YWwubGVuZ3RoIC0gMTsgaSA+PSAwOyB2YWxbaS0tXS5yZW1vdmVMaXN0ZW5lcih0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwucmVtb3ZlTGlzdGVuZXIodGhpcykgLy9kaXQgbW9ldCBiZXRlciAocmVtb3ZlIGxpc3RlbmVyIGlmIHBvc3NpYmxlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIG9iamVjdCA9IHJlcXVpcmUoICcuLi9vYmplY3QnIClcbiAgLCB1dGlsID0gcmVxdWlyZSggJy4uL3V0aWwnIClcbiAgLCB2aWdvdXIgPSByZXF1aXJlKCAnLi4vJyApXG5cbi8qKlxuICogdmlnb3VyLlZhbHVlXG4gKiB2IHZhbHVlcyBhcmUgb3B0aW1pemVkIGZvciB1c2UgaW4gY29tYmluYXRpb24gL3cgaW5zdGFuY2VzIG9mIHZpZ291ckJhc2UsIGhhdmUgb3BlcmF0b3JzIGFuZCBzdXBwb3J0IG1ldGhvZCB2YWx1ZXNcbiAqIEBDbGFzc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB2aWdvdXIuVmFsdWUgPSBvYmplY3QubmV3KFxueyBtaXhlZDogdHJ1ZVxuLCBtZXJnZTogdHJ1ZVxufSlcblxuLy9wYXJlbnQgcHJvYmxlbXNcblxudmFyIF9nZXRPcGVyYXRvciA9IGZ1bmN0aW9uKCB2YWwsIGZvcmNlLCBpLCB0LCBiaW5kLCBvcGVyYXRvcnMgKSB7XG4gIHZhciBmID0gdFtpXS5fZ2V0KGJpbmQsIGZvcmNlLCB2YWwpO1xuICBpZiAoZiAhPT0gdm9pZCAwICYmIGYgIT09IG51bGwpIHtcbiAgICB2YWwgPSBvcGVyYXRvcnNbaV0odmFsIHx8ICgodHlwZW9mIGYgPT09ICdzdHJpbmcnKSA/ICcnIDogMCksIGYpO1xuICB9XG4gIHJldHVybiB2YWw7XG59O1xuXG5leHBvcnRzLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ19sc3RhbXAnLCAnX2NsZWFyQ2FjaGUnLCAnX2x2YWwnLCAnX19sdmFsJywnX19fbHZhbCcsICdfYmFzZScsICdfY2FsbGVyJywgJ19iaW5kJywgJ19wcm9wJywgJ19pbnN0YW5jZXMnLCAnX3NraXAnLCAnX292ZXJ3cml0ZScpXG4vL19jYWxsZXIgc3RhbXAgZm9yIGdldCBmb3IgbHZhbHMgKGxhc3QgdmFsdWVzKVxudXRpbC5kZWZpbmUoZXhwb3J0cyxcbiAgJ2NsZWFyQ2FjaGUnLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9fX2x2YWwgPSBudWxsXG4gICAgdGhpcy5fX2x2YWwgPSBudWxsXG4gICAgdGhpcy5fbHZhbCA9IG51bGwgXG4gIH0sXG4gICdjbGVhclJlZmVyZW5jZXNDYWNoZScsIGZ1bmN0aW9uKCkge1xuICAgIGZyb20gPSB0aGlzLl92YWxcbiAgICB3aGlsZShmcm9tKSB7XG4gICAgICBpZihmcm9tLmNsZWFyQ2FjaGUpIGZyb20uY2xlYXJDYWNoZSgpXG4gICAgICBpZihmcm9tICYmIGZyb20uX3ZhbCkge1xuICAgICAgICBmcm9tID0gZnJvbS5fdmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcm9tID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ2lnbm9yZUNhY2hlJywgeyBnZXQ6ZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdCA9IHRoaXNcbiAgICAgIHdoaWxlKHQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2hvZSB6aXQgaGV0Pz8nLHQgKVxuICAgICAgICBpZiggdC5fcHJvcCAmJiB0Ll9wcm9wLmNhY2hlID09PSBmYWxzZSApIHJldHVybiB0cnVlXG4gICAgICAgIHQgPSB0Ll9wYXJlbnRcbiAgICAgIH0gXG4gICAgfSBcbiAgfSxcbiAgLyoqXG4gICAqIFVzZWQgdG8gZ2V0IC52YWwgd2hpY2ggY2FsY3VsYXRlcyBhIGNvbnN0cnVjdGVkIHZhbHVlXG4gICAqIF9iaW5kIGlzIHZlcnkgaW1wb3J0YW50IGJpbmRzIGxpc3RlbmVycyB0byBzcGVjaWZpYyBpbnN0YW5jZXNcbiAgICogQG1ldGhvZCBfZ2V0XG4gICAqIEBwYXJhbSAge1t0eXBlXX0gYmluZCAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGZvcmNlIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAgJ19nZXQnLCBmdW5jdGlvbihiaW5kLCBmb3JjZSwgY3VycmVudFZhbCkge1xuXG4gICAgaWYodGhpcy5fY2xlYXJDYWNoZSkge1xuICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygnX2dldCcsdGhpcy5fbmFtZSwgdGhpcy5fdmFsLHRoaXMpO1xuICAgIGlmICh0aGlzLl9vdmVyd3JpdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vdmVyd3JpdGU7XG4gICAgfVxuICAgIGlmICghdGhpcy5fbHZhbCAmJiB0aGlzLl9sdmFsICE9PSAwIHx8IGZvcmNlKSB7XG4gICAgICB2YXIgdmFsID0gdGhpcy5fdmFsLFxuICAgICAgICBub2x2YWwsXG4gICAgICAgIG9wZXJhdG9ycyA9IHRoaXMub3BlcmF0b3JzO1xuXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2Ygb2JqZWN0KSB7XG4gICAgICAgIHZhbCA9IHZhbC5fZ2V0KHRoaXMuX2JpbmQgfHwgYmluZCwgZm9yY2UsIGN1cnJlbnRWYWwpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1JJR0hUIEhFUkUnLCBjdXJyZW50VmFsKVxuICAgICAgICB2YXIgYSA9IHRoaXM7XG4gICAgICAgIGlmICghYmluZCkge1xuICAgICAgICAgIHdoaWxlIChhLl9wYXJlbnQgJiYgIWEuX2NhbGxlcikge1xuICAgICAgICAgICAgYSA9IGEuX3BhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gdmFsLmNhbGwoYmluZCB8fCBhLl9jYWxsZXIgfHwgYS5fYmFzZSB8fCB0aGlzLCB0aGlzLCBjdXJyZW50VmFsKTsgLy9pZiBjdXJyZW50dmFsIGVsc2Ugc29tZXRoaW5nIGVsc2U7XG4gICAgICAgIG5vbHZhbCA9IHRydWU7XG4gICAgICAgIC8vZm9yIGZ1bmN0aW9ucyB5b3UgbmVlZCB0byBjbGVhciBfbHZhbCBzaW5jZSB5b3UgbmV2ZXIga25vdyBpZiB0aGVyZSBpcyBzb21ldGhpbmcgaW4gdGhlIGZ1bmN0aW9uIHVwZGF0ZWRcbiAgICAgIH1cbiAgICAgIGlmIChvcGVyYXRvcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX190ID09PSAxICYmIG9wZXJhdG9yc1t0aGlzLl9uYW1lXSkgeyBcbiAgICAgICAgICAvL29wZXJhdG9yIGlzIGFuIGFycmF5XG4gICAgICAgICAgdmFsID0gMDsgLy9zdHJpbmdcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XG4gICAgICAgICAgICBpZiAodGhpc1tqXSkge1xuICAgICAgICAgICAgICB2aiA9IHRoaXNbal0uX2dldChiaW5kLCBmYWxzZSwgKGN1cnJlbnRWYWwgfHwgMCkgKyB2YWwpO1xuICAgICAgICAgICAgICBpZiAoIXZqKSB7XG4gICAgICAgICAgICAgICAgdmogPSAwOyAvL3N0cmluZ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdmogPT09ICdzdHJpbmcnICYmIHZhbCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHZhbCA9ICcnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhbCArPSB2ajsgLy9vbmx5IGFkZCBubyBvcGVyYXRvciBzdHVmZlxuICAgICAgICAgICAgICBpZiAoIXRoaXNbal0uX2x2YWwpIHtcbiAgICAgICAgICAgICAgICBub2x2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vYWxzbyBhZGQgYmVmb3JlXG4gICAgICAgICAgdmFyIG9yZGVyZWQ7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAgICAgICBpZiAob3BlcmF0b3JzW2ldKSB7XG4gICAgICAgICAgICAgIGlmICghb3BlcmF0b3JzW2ldLm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiB0aGlzW2ldLl9sc3RhbXAgIT09IHRoaXMuX2xzdGFtcCAmJiB0aGlzW2ldLl9fdCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWwgPSBfZ2V0T3BlcmF0b3IodmFsLCBmb3JjZSwgaSwgdGhpcywgYmluZCwgb3BlcmF0b3JzKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vbHZhbCAmJiAhdGhpc1tpXS5fbHZhbCkge1xuICAgICAgICAgICAgICAgICAgbm9sdmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG9yZGVyZWQpIHtcbiAgICAgICAgICAgICAgICAgIGlmICghb3JkZXJlZC5wb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgb3JkZXJlZCA9IFtvcmRlcmVkXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBvID0gb3BlcmF0b3JzW2ldLm9yZGVyLFxuICAgICAgICAgICAgICAgICAgICBvbCA9IG9yZGVyZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGggPSAwOyBoICE9PSB0cnVlICYmIGggPD0gb2w7IGgrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaCA9PT0gb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobyA8IG9wZXJhdG9yc1tvcmRlcmVkW2hdXS5vcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGEgPSBvcmRlcmVkW2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZFtvbF0gPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKGEpO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGggPT09IG9sICYmIG8gPiBvcGVyYXRvcnNbb3JkZXJlZFtoXV0ub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgICAgaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgb3JkZXJlZCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vc2hvcnRlclxuICAgICAgICAgIGlmIChvcmRlcmVkKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhvcmRlcmVkKTtcbiAgICAgICAgICAgIHZhciB4O1xuICAgICAgICAgICAgaSA9IG9yZGVyZWQucG9wID8gKHggPSAxKSAmJiBvcmRlcmVkWzBdIDogb3JkZXJlZDtcbiAgICAgICAgICAgIHdoaWxlIChpICYmIHRoaXNbaV0pIHtcbiAgICAgICAgICAgICAgaWYgKCFmb3JjZSAmJiB0aGlzW2ldLl9sc3RhbXAgIT09IHRoaXMuX2xzdGFtcCAmJiB0aGlzW2ldLl9fdCA9PT0gMSkgZm9yY2UgPSB0cnVlXG4gICAgICAgICAgICAgIHZhbCA9IF9nZXRPcGVyYXRvcih2YWwsIGZvcmNlLCBpLCB0aGlzLCBiaW5kLCBvcGVyYXRvcnMpO1xuICAgICAgICAgICAgICBpZiAoIW5vbHZhbCAmJiAhdGhpc1tpXS5fbHZhbCkgbm9sdmFsID0gdHJ1ZVxuICAgICAgICAgICAgICBpID0gb3JkZXJlZFt4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFub2x2YWwgJiYgIWZvcmNlKSB7XG4gICAgICAgIHRoaXMuX2x2YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuX19sdmFsID0gdmFsO1xuICAgICAgfSBlbHNlIGlmICghKHRoaXMuX2Jhc2UgJiYgdGhpcy5fYmFzZS5pbnN0YW5jZXMpKSB7XG4gICAgICAgIHRoaXMuX19sdmFsID0gdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX19sdmFsO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEZpcmVzIGFsbCBsaXN0ZW5lcnNcbiAgICogQG1ldGhvZCB1cGRhdGVcbiAgICogQHBhcmFtICB7W3R5cGVdfSBpbnN0YW5jZSAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gbm9pbnN0YW5jZXMgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YW1wICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBmcm9tICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gcmVtb3ZlICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGFkZGVkICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAndXBkYXRlJyxcbiAgZnVuY3Rpb24oaW5zdGFuY2UsIG5vaW5zdGFuY2VzLCBpbnN0YW5jZXNVcGRhdGVzLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCkge1xuICAgIC8vaXMgdGhpcyByZWFsbHkgbmVzc2VjYXJ5P1xuICAgIHRoaXMuX3VwZGF0ZS5jYWxsKCB0aGlzLCB2b2lkIDAsIHN0YW1wIHx8IHRoaXMuc3RhbXAoKSwgZnJvbSwgcmVtb3ZlLCBmYWxzZSwgZmFsc2UsIG5vaW5zdGFuY2VzLCBpbnN0YW5jZSwgaW5zdGFuY2VzVXBkYXRlcyAgKTsgLy90aGlzLnZhbFxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogRXh0ZW5kcyB2aWdvdXJPYmplY3QuX3VwZGF0ZVxuICAgKiBBZGRzIGxvYWRzIG9mIHN0dWZmIHRvIG9wdGltaXplIHVwZGF0ZXMgZm9yIGNhbGN1bGF0aW9uc1xuICAgKiBAbWV0aG9kIF91cGRhdGVcbiAgICogQHBhcmFtICB7W3R5cGVdfSB2YWwgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhbXAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGZyb20gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSByZW1vdmUgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gYWRkZWQgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vaW5zdGFuY2VzIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBpbnN0YW5jZSAgICBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ191cGRhdGUnLFxuICBmdW5jdGlvbiggdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBub2luc3RhbmNlcywgaW5zdGFuY2UsIGluc3RhbmNlc1VwZGF0ZXMgKSB7XG5cbiAgICB2YXIgdCA9IHRoaXMsXG4gICAgICBiYXNlID0gdC5fYmFzZTtcblxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBleHBvcnRzICYmICF0Ll9iaW5kKSBcbiAgICB7XG4gICAgICBpZiAodmFsLl9jYWxsZXIpIHtcbiAgICAgICAgdC5fYmluZCA9IHZhbC5fY2FsbGVyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICggKCF0Ll9sc3RhbXApIHx8IHQuX2xzdGFtcCAhPT0gc3RhbXAgICkge1xuXG4gICAgLy8gdmFyIG9wZXJhdG9ycyA9IHQub3BlcmF0b3JzXG4gICAgLy8gdmFyIGx2YWwgXG4gICAgLy8gdmFyIGNhbGNWYWxcbiAgICAvLyB2YXIgcGFzc1ZhbHVlQ2FjaGUgXG5cbiAgICAvLyBpZiggIXQuaWdub3JlQ2FjaGUgKSB7XG4gICAgLy8gICAvL1RPRE86IHRoaXMgaXMgYSB0ZW1wb3JhcnkgZml4IG5lZWRzIHRvIGJlIGZhc3RlclxuICAgIC8vICAgLy9tYWtlIHRoaXMgYSBtZXRob2RcbiAgICAvLyAgIGZ1bmN0aW9uIGNsZWFudXAodCkge1xuICAgIC8vICAgXHR0Ll9sdmFsID0gdm9pZCAwXG4gICAgLy8gICBcdHQuX19sdmFsID0gdm9pZCAwIFxuICAgIC8vICAgXHRpZih0Ll92YWwgaW5zdGFuY2VvZiBvYmplY3QgKSB7XG4gICAgLy8gICBcdFx0Ly9UT0RPOiBpZiBzdHVmZiBkb2VzbnQgdXBkYXRlIHVuY29tbWVudCB0aGlzIGxpbmVcbiAgICAvLyAgIFx0XHQvLyBjbGVhbnVwKHQuX3ZhbClcbiAgICAvLyAgIFx0fVxuICBcdCAvLyAgICBmb3IodmFyICRmaWVsZCBpbiB0KSB7XG4gIFx0IC8vICAgIFx0aWYob3BlcmF0b3JzWyRmaWVsZF0pIHtcbiAgXHQgLy8gICAgXHRcdGNsZWFudXAodFskZmllbGRdKVxuICBcdCAvLyAgICBcdH0gZWxzZSBpZigkZmllbGQgPiAtMSkge1xuICBcdCAvLyAgICBcdFx0Y2xlYW51cCh0WyRmaWVsZF0pXG4gIFx0IC8vICAgIFx0fVxuICBcdCAvLyAgICB9XG4gICAgLy8gXHR9XG4gICAgLy8gICBjbGVhbnVwKHQpXG5cbiAgICAvLyAgIGx2YWwgPSB0Ll9fX2x2YWxcbiAgICAvLyAgIGNhbGNWYWwgPSB0LnZhbFxuICAgIC8vICAgcGFzc1ZhbHVlQ2FjaGUgPSBsdmFsID09PSB2b2lkIDAgfHwgbHZhbCAhPT0gY2FsY1ZhbFxuICAgIC8vICAgdC5fX19sdmFsID0gY2FsY1ZhbFxuXG4gICAgLy8gfSBlbHNlIHtcblxuICAgICAgLy8gdC5jbGVhckNhY2hlKClcbiAgICAgIC8vIHBhc3NWYWx1ZUNhY2hlID0gdHJ1ZVxuICAgIC8vIH1cblxuICAgICAvLyBpZiAoICBwYXNzVmFsdWVDYWNoZSB8fCAoIGJhc2UgJiYgYmFzZS5pbnN0YW5jZXMgKSB8fCB0Ll9za2lwICkgeyAvL3Bhc3MgdGhpcyBjYWxjdWxhdGlvbiB0byB2c2V0IGVsc2UgaXRzIHRvbyBoZWF2eTtcblxuICAgIHQuX2x2YWwgPSBmYWxzZSAgXG4gICAgLy8gdC5fc2tpcCA9IHRydWVcbiAgICBpZihiYXNlICYmIGJhc2UuaW5zdGFuY2VzIHx8IHQuX3NraXAgfHwgdC5fX2x2YWwgPT09IHZvaWQgMCB8fCB0Ll9fX2x2YWwgIT09IHQudmFsICkge1xuXG4gICAgICAvLyBpZih3aW5kb3cuc211dCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnd3RmIGlzIGhhcHBlbmluZyEhISEnLCB0Ll9wYXRoLCB0LCB0Ll91cGRhdGVPcmlnaW4sIGFyZ3VtZW50cylcbiAgICAgIC8vIH1cblxuICAgICAgICB2YXIgcHJvcCA9IHQuX3Byb3AsXG4gICAgICAgICAgcGFyZW50ID0gdC5fcGFyZW50LFxuICAgICAgICAgIHZzZXQgPSBwcm9wICYmIHByb3AuX3ZzZXQ7XG5cbiAgICAgICAgdmFyIG9wZXJhdG9ycyA9IHQub3BlcmF0b3JzXG4gIFxuICAgICAgICAvL21ha2UgdGhpcyBiZXR0ZXJcbiAgICAgICAgaWYgKCEoZnJvbSAmJiByZW1vdmUpICYmIG9wZXJhdG9ycyAmJiAob3BlcmF0b3JzW3QuX25hbWVdIHx8IChwYXJlbnQgJiYgcGFyZW50Ll9fdCA9PT0gMSAmJiBvcGVyYXRvcnNbcGFyZW50Ll9uYW1lXSAmJiAoIWZyb20gfHwgdC5fbmFtZSA9PSBwYXJlbnQubGVuZ3RoIC0gMSkpKSkge1xuICAgICAgICAgIC8vd29ya3MgZm9yIGFycmF5cyBzaW5jZSBhcnJheXMgYXJlIGFsd2F5cyByZXBsYWNlZCBvbiB1cGRhdGUgLCB1cGRhdGluZyBhbiBpbmRpdmlkdWFsIGl0ZW0gdXNpbmcgLnNldCB3aWxsIG5vdCByZXN1bHQgaW4gYW4gdXBkYXRlIGF0IHRoaXMgcG9udCB3aGljaCBoYXMgdG8gYmUgcmVzb2x2ZWRcbiAgICAgICAgICB2YXIgX29wID0gdGhpcy5fcGFyZW50O1xuICAgICAgICAgIHdoaWxlIChvcGVyYXRvcnNbX29wLl9uYW1lXSkge1xuICAgICAgICAgICAgX29wLl9sdmFsID0gZmFsc2U7IC8vaWYgbm8gY2hhbmdlIHRvIGx2YWwgY2FuIGdvIHdyb25nLi4uXG4gICAgICAgICAgICBfb3AgPSBfb3AuX3BhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9vcCkge1xuICAgICAgICAgIFx0Ly90aGlzIGdlYXRseSBpbmNyZWFzZXMgdXBkYXRlcyBtYXkgYmUgaW1wb3J0YW50IGZvciBhbmltYXRpb24gYnV0IG5vdCBuZXNzZWNhcnkgZm9yIGFueXRoaW5nIGVsc2UhXG4gICAgICAgICAgICBfb3AuX3VwZGF0ZSh2YWwsIHN0YW1wLCB0aGlzLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIG5vaW5zdGFuY2VzLCBpbnN0YW5jZSwgaW5zdGFuY2VzVXBkYXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlc1VwZGF0ZXMpIHtcbiAgICAgICAgICBpbnN0YW5jZXNVcGRhdGVzLmNhbGwodCwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBub2luc3RhbmNlcywgaW5zdGFuY2UsIGluc3RhbmNlc1VwZGF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgYmFzZSA9IGluc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodnNldCkge1xuICAgICAgICAgICAgdC5fY2FsbGVyID0gYmFzZTtcbiAgICAgICAgICAgIHZzZXQuY2FsbCh0LCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCB2YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYmFzZSAmJiB2c2V0ICYmIGJhc2UuaW5zdGFuY2VzICYmICFub2luc3RhbmNlcyAmJiBwcm9wLnVwZGF0ZWluc3RhbmNlcyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGJhc2UuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkgeyAvL2xvb2sgZm9yIGN1cnJlbnQgY2FsbGVyIGluc3RhbmNlIHBlcmhhcHM/XG4gICAgICAgICAgICAgIHQuX2NhbGxlciA9IHRoaXM7XG4gICAgICAgICAgICAgIHZzZXQuY2FsbCh0LCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCB2YWwpO1xuICAgICAgICAgICAgfSwgcHJvcC5uYW1lLCB0KTtcbiAgICAgICAgICAgIHQuX2NhbGxlciA9IGJhc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZm9ybSBnb25lIGxldHMgc2VlIVxuICAgICAgICAgIC8vZnJvbSBzZWxmIGRvb3JnZXZlbiBpbiBjaGFpbiA9PS0tIGlmICEgbm90IGZyb20gZnJvbSAtLS0+ICwgZXh0cmEgYXJnXG4gICAgICAgICAgb2JqZWN0LnByb3RvdHlwZS5fdXBkYXRlLmNhbGwodCwgdmFsLCBzdGFtcCwgZnJvbSB8fCB0LCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpXG4gICAgICAgIH1cblxuICAgICAgICAvL3BhcyBvcCBtZXQgZGV6ZSFcbiAgICAgICAgdC5fbHN0YW1wID0gc3RhbXA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gaWYod2luZG93LnNtdXQpIGNvbnNvbGUubG9nKCdjYXRjaCBpdCEnLCBhcmd1bWVudHMpXG4gICAgfVxuXG5cbiAgICB9XG4gIH0pXG5cbi8vcmVxdWlyaW5nIG9wZXJhdG9ycyBkb2VzIG5vdCBhdXRvbWF0aWNseSByZXF1aXJlIHZpZ291clZhbHVlLCBtYXkgYmUgaGFuZHk/XG51dGlsLmRlZmluZShleHBvcnRzLCAnb3BlcmF0b3JzJywge1xuICB2YWx1ZTogZXhwb3J0cy5vcGVyYXRvcnMgPSByZXF1aXJlKCcuL29wZXJhdG9ycycpXG59KVxuXG5cblxuIiwidmFyIFZhbHVlID0gcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlJyksXG4gIHV0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbCcpLFxuICBWT2JqZWN0ID0gcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdCcpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoXG4gIGZ1bmN0aW9uKFRhcmdldCl7XG4gICAgaWYoIFRhcmdldC5wcm90b3R5cGUgaW5zdGFuY2VvZiBWT2JqZWN0IHx8IFRhcmdldCA9PT0gVk9iamVjdCkge1xuICAgICAgLy8gVE9ETzogZml4IHRoaXMgdG8gYWZmZWN0IGFsbCBWT2JqZWN0IGJsYWNrbGlzdHMuLi5cbiAgICAgIFRhcmdldC5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfJGxlbmd0aCcpXG5cbiAgICAgIHV0aWwuZGVmaW5lKCBUYXJnZXQsXG4gICAgICAgICckbGVuZ3RoJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogLi4uc28gd2UgZG9udCBoYXZlIHRvIGRvIGJsYWNrbGlzdCBjaGVjazpcbiAgICAgICAgICAgIHV0aWwuaW5jbHVkZSh0aGlzLl9ibGFja2xpc3QsICdfJGxlbmd0aCcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fJGxlbmd0aCB8fCAodGhpcy5fJGxlbmd0aCA9IG1ha2VMZW5ndGgodGhpcykpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGV4dGVuZCBcIiRsZW5ndGhcIiBvbiBub24gVk9iamVjdCBDbGFzcycpXG4gICAgfVxuICB9XG4pXG5cbmZ1bmN0aW9uIG1ha2VMZW5ndGgoaW5zdGFuY2UpIHtcbiAgdmFyICRsZW5ndGggPSBuZXcgVmFsdWUoe1xuICAgIHZhbDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBnZXRMZW5ndGgoaW5zdGFuY2UpXG4gICAgfVxuICB9KVxuXG4gIGluc3RhbmNlLm9uKGZ1bmN0aW9uKHZhbCl7XG5cbiAgICAvLyB2YXIgaWRlbnRpZmllciA9IGluc3RhbmNlLl9wYXRoLmxlbmd0aCBcbiAgICAvLyAgID8gaW5zdGFuY2UuX3BhdGhcbiAgICAvLyAgIDogaW5zdGFuY2UuX3Byb3AgJiYgaW5zdGFuY2UuX3Byb3AubmFtZVxuICAgIC8vIGNvbnNvbGUubG9nKCdVUERBVEUgT04nLCBpZGVudGlmaWVyLCAnU0hJTkUgREFUIExFTkdUSD8hJywgJGxlbmd0aC52YWxcbiAgICAvLyApXG4gICAgLy8gVE9ETzogb25seSB1cGRhdGUgaWYgYWRkZWQgb3IgcmVtb3ZlZFxuICAgICRsZW5ndGguX3VwZGF0ZS5hcHBseSgkbGVuZ3RoLCBhcmd1bWVudHMpXG4gIH0pXG5cbiAgcmV0dXJuICRsZW5ndGhcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoIChjdXJyZW50KSB7XG4gIGlmKCFjdXJyZW50KXtcbiAgICByZXR1cm4gMFxuICB9IGlmIChjdXJyZW50Ll9maWx0ZXIpIHtcbiAgICByZXR1cm4gY3VycmVudC5sZW5ndGhcbiAgfSBlbHNlIGlmIChjdXJyZW50Ll9fdCA9PT0gNCkge1xuICAgIHJldHVybiBnZXRMZW5ndGgoY3VycmVudC5fdmFsKVxuICB9IGVsc2UgaWYgKGN1cnJlbnQuX190IDwgMykge1xuICAgIHJldHVybiBjdXJyZW50LmtleXMubGVuZ3RoXG4gIH0gZWxzZSBpZiAodHlwZW9mIGN1cnJlbnQuX3ZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gY3VycmVudC5fdmFsLmxlbmd0aFxuICB9IGVsc2Uge1xuICAgIHJldHVybiAwXG4gIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxuICAvKlxuICAgIEV4dGVuc2lvbiBmb3IgQmFzZSBjbGFzc2VzIHRvIGNyZWF0ZSBhbiBpbmhlcml0YWJsZSBvbiAtIHZhbHVlXG4gICovXG5cbnZhciBWYWx1ZSA9IHJlcXVpcmUoJy4vJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgQmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kXG4oIGZ1bmN0aW9uKGJhc2UpXG4gIHtcbiAgICBpZiggYmFzZSBpbnN0YW5jZW9mIEJhc2UgKVxuICAgIHtcblxuICAgICAgYmFzZS5leHRlbmRcbiAgICAgIChcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6J29uJyxcbiAgICAgICAgICBzZXQ6ZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZTpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIC8vcmVtb3ZlXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaW0gYmVpbmcgcmVtb3ZlZCEnKVxuICAgICAgICAgICAgIGlmKHRoaXMub24uJHJlbW92ZSkge1xuICAgICAgICAgICAgICB0aGlzLm9uLiRyZW1vdmUudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5ldzpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIC8vaW5pdFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0lOSVQhLS0tLScsIHRoaXMsIHZhbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgaWYodGhpcy5vbi4kbmV3KSB7XG4gICAgICAgICAgICAgIHRoaXMub24uJG5ldy51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGFyZW50OmZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgLy9pbml0XG4gICAgICAgICAgICBpZih0aGlzLm9uLiRwYXJlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbi4kcGFyZW50LnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW5kZXI6ZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAvL2luaXRcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU5ERVIhLS0tLScsIHRoaXMsIHZhbCwgYXJndW1lbnRzKVxuICAgICAgICAgICAgaWYodGhpcy5vbi4kcmVuZGVyKSB7XG4gICAgICAgICAgICAgIHRoaXMub24uJHJlbmRlci51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgfVxuICAgIGVsc2VcbiAgICB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBleHRlbmQgXCJvblwiIG9uIG5vbiBCYXNlIENsYXNzJylcbiAgICB9XG4gIH1cbilcbiIsIi8qKlxuICogb3BlcmF0b3JzXG4gKiBvcGVyYXRvcnMgY2FuIGJlIHNldCBvbiBWLlZhbHVlLm9wZXJhdG9yc1xuICogZGVmaW5lIG9wZXJhdG9ycyBvbiB0aGlzIG1vZHVsZVxuICogQHByb3BlcnR5XG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgViA9IHJlcXVpcmUoJy4uLycpXG4gIFxuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCArIG9wZXJhdG9yXG59XG5leHBvcnRzLnN1YiA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIC0gb3BlcmF0b3Jcbn1cbmV4cG9ydHMubXVsdGlwbHkgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCAqIG9wZXJhdG9yXG59XG5leHBvcnRzLmRpdmlkZSA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIC8gb3BlcmF0b3Jcbn1cbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgPiBvcGVyYXRvciA/IG9wZXJhdG9yIDogdmFsXG59XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIDwgb3BlcmF0b3IgPyBvcGVyYXRvciA6IHZhbFxufVxuZXhwb3J0cy50cmFuc2Zvcm0gPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIG9wZXJhdG9yID09PSBmYWxzZSA/IHZhbCA6IG9wZXJhdG9yXG59XG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gb3BlcmF0b3IgPyBNYXRoLmFicyh2YWwpIDogdmFsXG59XG5leHBvcnRzLmZsb29yID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgfCAwXG59XG5leHBvcnRzLmNlaWwgPSBmdW5jdGlvbiAoIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiBNYXRoLmNlaWwoIHZhbCApXG59XG5leHBvcnRzLnByZXBlbmQgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIG9wZXJhdG9yICsgdmFsXG59XG5leHBvcnRzLm9yID0gZnVuY3Rpb24gKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIHx8IG9wZXJhdG9yXG59XG5leHBvcnRzLndoZW4gPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIG9wZXJhdG9yICYmIHZhbFxufVxuZXhwb3J0cy4kY29udmVydFR5cGUgPSBmdW5jdGlvbiAoIHZhbCwgb3BlcmF0b3IgKSB7XG4gIC8vY29udmVydFR5cGVcbiAgaWYoIG9wZXJhdG9yID09PSAnYm9vbGVhbicgKVxuICB7IFxuICAgIHJldHVybiB2YWwgPyB0cnVlIDogZmFsc2VcbiAgfSBcbiAgZWxzZSBpZiggb3BlcmF0b3IgPT09ICdudW1iZXInIClcbiAge1xuICAgIC8vZG8gaXNOYW4gc3RhcnQgdXNpbmcgbG9EYXNoIGZvciB0aGlzIGtpbmQgb2Ygc3R1ZmYgKCBhbG1vc3Qgbm90aGluZyApXG4gICAgLy9jb252ZXJ0IGZhbHN5IG9yIE5hTiB2YWx1ZXMgdG8gMFxuICAgIHJldHVybiBOdW1iZXIoIHZhbCApXG4gIH1cbn1cblxuZXhwb3J0cy4kY29udmVydFRpbWUgPSBmdW5jdGlvbiggdGltZSwgZGVjaW1hbHMgKSB7XG4gIHZhciBocnMgPSB+fiAodGltZSAvIDM2MDApXG4gIHZhciBtaW5zID0gfn4gKCh0aW1lICUgMzYwMCkgLyA2MClcbiAgdmFyIHNlY3MgPSAhaXNOYU4ocGFyc2VGbG9hdChkZWNpbWFscykpICYmIGlzRmluaXRlKGRlY2ltYWxzKVxuICAgICAgPyAodGltZSAlIDYwKS50b0ZpeGVkKGRlY2ltYWxzKSA6IH5+KHRpbWUgJSA2MClcblxuICByZXQgPSBcIlwiO1xuICBpZiAoaHJzID4gMCkgcmV0ICs9IFwiXCIgKyBocnMgKyBcIjpcIiArIChtaW5zIDwgMTAgPyBcIjBcIiA6IFwiXCIpO1xuICByZXQgKz0gXCJcIiArIG1pbnMgKyBcIjpcIiArIChzZWNzIDwgMTAgPyBcIjBcIiA6IFwiXCIpO1xuICByZXQgKz0gXCJcIiArIHNlY3M7XG4gIHJldHVybiByZXQgfHwgMDtcbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuXG4vLyBjb25zb2xlLmxvZyggJz8/Pz8nLCB2YWwgKVxuICBcbiAgLy9wYXMgb3AgbWV0IGRpZSAwXG4gIGlmKCAoIXZhbCAmJiB2YWwgIT09IDApIHx8IHZhbC5fdmFsID09PSBmYWxzZSB8fCB2YWwgPT09ICdlcnJvcicgfHwgdmFsID09PSAnc3VjY2VzcycgKVxuICB7XG4gICAgLy9UT0RPOiBBcnJheXMgZm9yIGRlZmF1bHQgb3BlcmF0b3JcbiAgICByZXR1cm4gb3BlcmF0b3JcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbmV4cG9ydHMuZGVmYXVsdC5vcmRlciA9IDEwMDAiLCJtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKSIsInZhciBwa2cgPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKVxuICAsIHBsdWdpbklkID0gcGtnLnBsdWdpbi5pZFxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB7fVxuXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuICBpZiAoIWNiKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cbiAgdHJ5IHtcbiAgICB3aW5kb3cudmlnb3VyTmF0aXZlLmJyaWRnZShwbHVnaW5JZCwgJ2dldCcsIG9wdHMsIGNiKVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2IoZSlcbiAgfVxufVxuXG5leHBvcnRzLnNldCA9IGZ1bmN0aW9uIChvcHRzLCBjYikge1xuICBpZiAoIWNiKSB7XG4gICAgY2IgPSBvcHRzXG4gICAgb3B0cyA9IHt9XG4gIH1cbiAgdHJ5IHtcbiAgICB3aW5kb3cudmlnb3VyTmF0aXZlLmJyaWRnZShwbHVnaW5JZCwgJ3NldCcsIG9wdHMsIGNiKVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2IoZSlcbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzPXtcIm5hbWVcIjpcInZpZ291ci1uYXRpdmUtc3RhdHVzQmFyXCIsXCJ2ZXJzaW9uXCI6XCIyMDE1LzA2LzEzIDE1OjAyOjUzIFVUQyAoMC4wLjEpXCIsXCJhdXRob3JcIjp7XCJuYW1lXCI6XCJTaGF3biBJbmRlclwiLFwiZW1haWxcIjpcInNoYXduQHZpZ291ci5pb1wifSxcInJlcG9zaXRvcnlcIjp7XCJ0eXBlXCI6XCJnaXRcIixcInVybFwiOlwiZ2l0K2h0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIuZ2l0XCIsXCJicmFuY2hcIjpcInByb2R1Y3Rpb25cIn0sXCJlbmdpbmVzXCI6e1wibm9kZVwiOlwiPj0wLjEwLjBcIn0sXCJtYWluXCI6XCJpbmRleC5qc1wiLFwic2NyaXB0c1wiOntcInN0YXJ0XCI6XCJnYXN0b25cIixcInRlc3RcIjpcInRlc3QvdGVzdC5qc1wifSxcImRlc2NyaXB0aW9uXCI6XCJBbGxvd3Mgb25lIHRvIGNvbnRyb2wgdGhlIG5hdGl2ZSBzdGF0dXMgYmFyIGZyb20gYSB3ZWIgYXBwXCIsXCJrZXl3b3Jkc1wiOltcInZpZ291clwiLFwibmF0aXZlXCIsXCJwbHVnaW5cIixcInN0YXR1c0JhclwiXSxcImJ1Z3NcIjp7XCJ1cmxcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIvaXNzdWVzXCJ9LFwiaG9tZXBhZ2VcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXJcIixcImRlcGVuZGVuY2llc1wiOntcImdhc3RvblwiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL3ZpZ291ci1pby9nYXN0b24uZ2l0XCIsXCJ2aWdvdXItbmF0aXZlXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vdmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUuZ2l0XCIsXCJ2aWdvdXItZnNcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLWZzLmdpdFwiLFwidmlnb3VyLWRldi10b29sc1wiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL3ZpZ291ci1pby92aWdvdXItZGV2LXRvb2xzLmdpdFwifSxcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6e30sXCJkZXZEZXBlbmRlbmNpZXNcIjp7XCJucG1cIjpcIl4yLjcuNlwiLFwibnBtbG9nXCI6XCJeMS4yLjBcIn0sXCJwbHVnaW5cIjp7XCJpZFwiOlwic3RhdHVzYmFyXCIsXCJhbmRyb2lkXCI6e1wiY2xhc3NOYW1lXCI6XCJpby52aWdvdXIucGx1Z2luLnN0YXR1c2Jhci5TdGF0dXNCYXJQbHVnaW5cIixcImluc3RhbnRpYXRpb25cIjpcIm5ldyBTdGF0dXNCYXJQbHVnaW4odGhpcywgd2ViVmlldylcIixcImxpYk5hbWVcIjpcInN0YXR1c2Jhci1kZWJ1Zy5hYXJcIn19LFwiZ2l0SGVhZFwiOlwiNTg4ZGU0NzIzY2JkZTY3M2ZiMjJiNGEyOGI3MDQ3MjA0NWQzYzhmZlwiLFwicmVhZG1lXCI6XCIjIHZpZ291ci1uYXRpdmUtc3RhdHVzQmFyXFxuQWxsb3dzIG9uZSB0byBjb250cm9sIHRoZSBuYXRpdmUgc3RhdHVzIGJhciBmcm9tIGEgd2ViIGFwcFxcblxcbiMjSW5zdGFsbFxcbmBucG0gaSB2aWdvdXItbmF0aXZlLXN0YXR1c0JhcmBcXG5cXG4jI1VzYWdlXFxuU2VlIFt0ZXN0L2luZGV4LmpzXSh0ZXN0L2luZGV4LmpzKVxcblxcbiMjQnVpbGRpbmcgYSBzZXQgb2YgbmF0aXZlIGFwcHMgZnJvbSB5b3VyIGNvZGViYXNlXFxuLSBgbnBtIHJ1biBidWlsZGBcXG4tIGBucG0gcnVuIGJ1aWxkIC0tIGlvcyBhbmRyb2lkYFwiLFwicmVhZG1lRmlsZW5hbWVcIjpcIlJFQURNRS5tZFwiLFwiX2lkXCI6XCJ2aWdvdXItbmF0aXZlLXN0YXR1c0JhckAwLjAuMVwiLFwiX3NoYXN1bVwiOlwiODFjYzI1OTEwYmU3ZjE1OTU0MTdjM2I4ZmRmYjgzODJiMTI0N2Y0N1wiLFwiX2Zyb21cIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIuZ2l0XCIsXCJfcmVzb2x2ZWRcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIuZ2l0IzU4OGRlNDcyM2NiZGU2NzNmYjIyYjRhMjhiNzA0NzIwNDVkM2M4ZmZcIixcInNoYVwiOlwiMC4wLjFcIn0iLCJ2YXIgYXBwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxuICAuaW5qZWN0KFxuICAgIHJlcXVpcmUoICd2aWdvdXItanMvYXBwL2NvbnRlbnQnICksXG4gICAgcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdXNlcicgKVxuICApXG5cbnJlcXVpcmUoICcuL3VzZXInIClcbnJlcXVpcmUoICcuL3ZhbHVlcycgKVxucmVxdWlyZSggJy4vcGxheWJhY2snKVxucmVxdWlyZSggJy4vaW5pdCcgKVxuXG53aW5kb3cuYSA9IGFwcFxuIiwidmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgY29uZmlnID0gcmVxdWlyZSggJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycgKVxudmFyIHVzZXIgPSBhcHAudXNlclxuXG4vLyBwcmVsb2FkZXJcbmFwcC5jc3MgPSB7XG4gIGFkZENsYXNzOiAncHJlbG9hZCdcbn1cblxudXNlci5kYXRhLmlzKCAnbG9hZGVkJyApXG4gIC8vZG8gdGhpcyBsYXRlciB3aGVuIGNvbnRlbnQgZ2V0cyBib3VuZFxuICAudGhlbiggZnVuY3Rpb24oKSB7IFxuICAgIGFwcC5yZWFkeS52YWwgPSB0cnVlXG4gICAgLy9hZGQgdGhpcyBsYXRlclxuICAgIC8vIHJldHVybiBhcHAuY29udGVudC5pcyggJ2xvYWRlZCcgKSBcbiAgfSlcbiAgLmRvbmUoIGZ1bmN0aW9uKCkge1xuICAgIGFwcC5jc3MgPSB7XG4gICAgICByZW1vdmVDbGFzczogJ3ByZWxvYWQnXG4gICAgfVxuICB9KVxuXG5cblxuYXBwLmluaXRpYWxpc2VkLm9uY2UodHJ1ZSwgZnVuY3Rpb24oKSB7XG4gIC8vIGNvbnNvbGUubG9nKGRvY3VtZW50LmRvbWFpbi5yZXBsYWNlKC9cXDpcXGRcXGRcXGRcXGQvLCAnOjEwMDAxJykpXG5cbiAgYXBwLmNsb3VkID0gY29uZmlnLmNsb3VkID09PSAnZG9tYWluJyA/IGRvY3VtZW50LmRvbWFpbisgJzoxMDAwMScgIDogY29uZmlnLmNsb3VkXG4vLyA9PT09PT09XG4gIC8vIGlmKHdpbmRvdy5nYXN0b24gJiYgd2luZG93Lmdhc3Rvbi5zZXJ2ZXJBZGRyZXNzLmluZGV4T2YoJ3snKSA9PT0gLTEpIHtcbiAgLy8gICBhcHAuY2xvdWQgPSAnd3M6Ly8nICtcbiAgLy8gICAgIHdpbmRvdy5nYXN0b24uc2VydmVyQWRkcmVzcy5zcGxpdCgnLy8nKVsxXS5zcGxpdCgnOicpWzBdICsgXG4gIC8vICAgICAnOjEwMDAxJ1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIGFwcC5jbG91ZCA9ICd3czovLycgKyBjb25maWcuY2xvdWRcbiAgLy8gfVxuICBcbi8vID4+Pj4+Pj4gZGV2XG4gIHVzZXIudG9rZW4udmFsID0gJ2Z1dHVyZWxhbmQnXG59KVxuXG4vKiAgIFxuJ3dzOi8vJyBcbiAgKyB3aW5kb3cuZ2FzdG9uLnNlcnZlckFkZHJlc3Muc3BsaXQoJy8vJylbMV0uc3BsaXQoJzonKVswXVxuICArICc6MTAwMDEnLy9cbiovXG4iLCJ2YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBWYWx1ZSA9IHJlcXVpcmUoICd2aWdvdXItanMvdmFsdWUnIClcbnZhciBjYXNlcyA9IGFwcC5jYXNlc1xudmFyIHVzZXIgPSBhcHAudXNlclxuXG5hcHAuaXNQbGF5aW5nLnZhbCA9IHtcbiAgdmFsOiBmYWxzZSxcbiAgJGlzUmVjZWl2ZXI6dXNlci5yZWNlaXZlci5wbGF5aW5nXG59XG5cbmFwcC52b2x1bWUgPSB7XG4gIHZhbDoxLFxuICAkaXNSZWNlaXZlcjogdXNlci5yZWNlaXZlci52b2x1bWVcbn1cblxuY2FzZXMuJGlzUGxheWluZyA9IGFwcC5pc1BsYXlpbmdcblxuaWYoY2FzZXMuJGlzUGhvbmUpIHtcbiAgYXBwLnBvcHVwLm9uKGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmKHZhbCkge1xuICAgICAgaWYoYXBwLmlzUGxheWluZy52YWw9PT10cnVlKSB7XG4gICAgICAgIGFwcC5pc1BsYXlpbmcuZnJvbS52YWwgPSBmYWxzZVxuICAgICAgICBhcHAucG9wdXAuaXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsID09PSBmYWxzZVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhcHAuaXNQbGF5aW5nLmZyb20udmFsID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuY2FzZXMuJGlzRnVsbHNjcmVlbiA9IG5ldyBWYWx1ZSgge1xuICB2YWw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcHAuc3RhdGUudmFsID09PSAncGxheWVyJ1xuICB9LFxuICBsaXN0ZW46IGFwcC5zdGF0ZVxufSApXG5cbi8vIGNhc2VzLiRpc0xvYWRpbmdWaWRlbyA9IG5ldyBWYWx1ZSgge1xuLy8gICB2YWw6IGZhbHNlLFxuLy8gICBkZWZlcjogZnVuY3Rpb24oIHVwZGF0ZSApIHtcbi8vICAgICB2YXIgX3RoaXMgPSB0aGlzXG4vLyAgICAgaWYgKCB0aGlzLl90aW1lciApIHtcbi8vICAgICAgIGNsZWFyVGltZW91dCggdGhpcy5fdGltZXIgKVxuLy8gICAgICAgdGhpcy5fdGltZXIgPSBudWxsXG4vLyAgICAgfVxuLy8gICAgIGlmICggdGhpcy5fdmFsICkge1xuLy8gICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgX3RoaXMudmFsID0gZmFsc2Vcbi8vICAgICAgICAgX3RoaXMuX3RpbWVyID0gbnVsbFxuLy8gICAgICAgfSwgMjAwMCApXG4vLyAgICAgfVxuLy8gICAgIHVwZGF0ZSgpXG4vLyAgIH1cbi8vIH0gKVxuXG4vLyBhcHAuaXNQbGF5aW5nLm9uKCBmdW5jdGlvbiggdmFsICkge1xuLy8gICBpZiAoIGNhc2VzLiRpc0xvZ2dlZEluLnZhbCApIHtcbi8vICAgICBpZiAoIHZhbCA9PT0gdHJ1ZSApIHtcbi8vICAgICAgIC8vIFRPRE86IHRoaXMgY3Jhc2hlcyBub3csIHNvIGkgY29tbWVudGVkIGl0IG91dFxuLy8gICAgICAgLy8gdmFyIG1lZGlhID0gYXBwLnVzZXIubmF2aWdhdGlvbi5tZWRpYS5mcm9tXG4vLyAgICAgICAvLyBpZiAoIG1lZGlhLl9wYXJlbnQuX25hbWUgIT09ICdjaGFubmVscycgKSB7XG4vLyAgICAgICAvLyAgIHZhciBlcGkgPSBhcHAudXNlci51c2FnZS5mcm9tLmdldCggbWVkaWEuX2NvbnRlbnRQYXRoICksXG4vLyAgICAgICAvLyAgICAgc2hvdyA9IGVwaS5fcGFyZW50Ll9wYXJlbnQuX3BhcmVudC5fcGFyZW50XG5cbi8vICAgICAgIC8vICAgaWYgKCBzaG93ICkge1xuLy8gICAgICAgLy8gICAgIHNob3cuc2V0KCAnbWVkaWEnLCBtZWRpYSApXG4vLyAgICAgICAvLyAgIH1cbi8vICAgICAgIC8vIH1cbi8vICAgICB9XG4vLyAgIH1cbi8vIH0pXG4iLCJ2YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgdXNlciA9IGFwcC51c2VyLmluamVjdChcbiAgcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91c2VyL3Rva2VuJyksXG4gIHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdXNlci91c2FnZScpLFxuICByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VzZXIvbmF2aWdhdGlvbicpLFxuICByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VzZXIvbXVsdGlzY3JlZW4nKVxuKVxuXG51c2VyLnNldCh7XG4gIHNlYXJjaDogZmFsc2UsXG4gIGZvY3VzX3JvdzogJ3Nwb3RsaWdodCcsXG4gIC8vIGZvY3VzX2NoYW5uZWxzOjAsXG4gIGZvY3VzX2FjdG9yOjAsXG4gIGZvY3VzX2NoYW5uZWxzOjAsXG4gIGZvY3VzX3Nwb3RsaWdodDowLFxuICBmb2N1c193YXRjaGluZzowLFxuICBmb2N1c19yZWNvbW1lbmRlZDowLFxuICBmb2N1c19yZWxlYXNlczowLFxuICByZWNlbnRTZWFyY2hlczoge30sXG4gIHBvcHVwOjAsXG4gIHRyYWlsZXJNdXRlZDp0cnVlXG4gIC8vIHVybDogcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvdXJsJyApXG59KVxuXG5hcHAucG9wdXAudmFsID0gdXNlci5wb3B1cFxuXG52YXIgVmFsdWUgPSByZXF1aXJlKCd2aWdvdXItanMvdmFsdWUnKVxuXG5hcHAuZGV2aWNlTWVzc2FnZSA9IG5ldyBWYWx1ZSh7XG4gIHZhbDogdXNlci5yZWNlaXZlckNsaWVudCxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiggYywgY3YgKXtcbiAgICB2YXIgdGl0bGUgPSBjdiAmJiBjdi5mcm9tICYmIGN2LmZyb20udGl0bGUgJiYgY3YuZnJvbS50aXRsZS52YWxcbiAgICAvLyBjb25zb2xlLmVycm9yKCdkZXZpY2VNZXNzYWdlISAnLCB0aXRsZSlcbiAgICByZXR1cm4gdGl0bGUgPyAnQ29ubmVjdGVkIHRvICcgKyB0aXRsZSA6ICdOb3QgQ29ubmVjdGVkJ1xuICB9XG59KVxuIiwidmFyIGFwcCA9IHJlcXVpcmUoJy4vJylcbnZhciB1YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL3VhJylcbnZhciB1c2VyID0gYXBwLnVzZXJcbnZhciBjYXNlcyA9IGFwcC5jYXNlc1xudmFyIFZhbHVlID0gcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlJylcbiAgLy8gVE9ETzogYmFzZSB0aGlzIG9uIGRldmljZSByb2xlXG4vLyBhcHAuc3RhdGUudmFsID0ge1xuLy8gICBkZWZhdWx0OiAnZmlyc3QnXG4vLyB9XG5cbmFwcC5zdGF0ZS52YWwgPSBjYXNlcy4kaXNQaG9uZSA/ICdmaXJzdCcgOiAnc2Vjb25kJ1xuXG5hcHAuY3VycmVudCA9IG5ldyBWYWx1ZSh7XG4gIHZhbDogdXNlci5uYXZpZ2F0aW9uLmxhc3QsXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24odiwgbGFzdCkge1xuICAgIHZhciBrZXkgPSBsYXN0LmtleSAmJiBsYXN0LmtleS52YWxcbiAgICByZXR1cm4ga2V5ID09PSAncGFnZScgPyB1c2VyLm5hdmlnYXRpb24ucGFnZS52YWwgOiBrZXlcbiAgfSxcbiAgbGlzdGVuOiBbXG4gICAgdXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQsXG4gICAgdXNlci5uYXZpZ2F0aW9uLnBhZ2VcbiAgXVxufSlcblxuYXBwLnByZXZpb3VzID0gbmV3IFZhbHVlKHtcbiAgdmFsOmFwcC5jdXJyZW50LFxuICBkZWZlcjpmdW5jdGlvbih1cGRhdGUsYXJncyl7XG4gICAgdmFyIHZhbCA9IHRoaXMuX3ZhbC52YWxcbiAgICBpZih0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWwgIT09IHRoaXMuY3VycmVudCl7XG4gICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnRcbiAgICAgIHRoaXMuY3VycmVudCA9IHZhbFxuICAgIH1cbiAgICB1cGRhdGUoKVxuICB9LFxuICB0cmFuc2Zvcm06ZnVuY3Rpb24odmFsKXtcbiAgICByZXR1cm4gdmFsLl9wYXJlbnQucHJldiB8fCAwXG4gIH1cbn0pXG5cbmFwcC5zZWNvbmRQb3B1cCA9IG5ldyBWYWx1ZShmYWxzZSlcblxuYXBwLmhpZGVTdGF0dXNiYXIgPSBuZXcgVmFsdWUoe1xuICB2YWw6IGZhbHNlLFxuICB0cmFuc2Zvcm06IGFwcC5pc1BsYXlpbmdcbn0pXG5cbmNhc2VzLiRoYXNSZWNlaXZlci5vbihmdW5jdGlvbigpIHtcbiAgYXBwLmNzcyA9IHRoaXMudmFsID8ge1xuICAgIGFkZENsYXNzOiAnaGFzUmVjZWl2ZXInXG4gIH0gOiB7XG4gICAgcmVtb3ZlQ2xhc3M6ICdoYXNSZWNlaXZlcidcbiAgfVxufSlcblxuY2FzZXMuJGlzSUZFID0gdWEuZGV2aWNlID09PSAnSUZFJ1xuXG5pZighY2FzZXMuJGlzUGhvbmUpe1xuICBjYXNlcy4kaXNSZWNlaXZlci5vbihmdW5jdGlvbigpe1xuICAgIGFwcC5zdGF0ZS52YWwgPSB0aGlzLnZhbCA/ICdzZWNvbmQnIDogJ2luYWN0aXZlJ1xuICB9KVxufSIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBBY3RvcnMgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9hY3RvcnMnKVxudmFyIERlc2NyaXB0aW9uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvZGVzY3JpcHRpb24nKVxudmFyIFByb2dyZXNzID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2JhcicpLkJhclxudmFyIFRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvdGl0bGUnKVxudmFyIFBvbGwgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9wb2xsJylcbnZhciBTdGF0aXN0aWNzID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3RhdGlzdGljcycpXG52YXIgVHJpdmlhID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvdHJpdmlhJylcbnZhciBDb250ZW50ID0gcmVxdWlyZSgnLi4vY29udGVudCcpXG52YXIgQmFyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvYmFyJylcbnZhciBUd2VldHMgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC90d2VldHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDb250ZW50KHtcbiAgJ2hvbGRlci5wYWdlJzoge1xuICAgIGNvbnRhaW5lcjp7XG4gICAgICAnbW9kZWwuZmllbGQnOidndWlkZS4wJyxcbiAgICAgIHRpdGxlYmFyOm5ldyBCYXIoe1xuICAgICAgICBjc3M6ICd1aS1iYXInLFxuICAgICAgICBhY2NlbnQ6IHt9LFxuICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgdGl0bGU6bmV3IFRpdGxlKCksXG4gICAgICAgICAgdGltZWZpbGxlcjoge1xuICAgICAgICAgICAgJ2xlZnQudGV4dC5kYXRhJzonc3RhcnQtdGltZScsXG4gICAgICAgICAgICAnbWlkZGxlLmZpbGxlcic6IG5ldyBQcm9ncmVzcyh7XG4gICAgICAgICAgICAgICdzZWVrLncnOiAnNzUlJ1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAncmlnaHQudGV4dC5kYXRhJzonZW5kLXRpbWUnICBcbiAgICAgICAgICB9ICBcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBkZXNjcmlwdGlvbjpuZXcgRGVzY3JpcHRpb24oe1xuICAgICAgICBkaXNwbGF5OntcbiAgICAgICAgICBkYXRhOidkZXNjcmlwdGlvbicsXG4gICAgICAgICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgICAgICAgcmV0dXJuIGN2ID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBhY3RvcnM6bmV3IEFjdG9ycygpLFxuICAgICAgcG9sbDpuZXcgUG9sbCgpLFxuICAgICAgc3RhdGlzdGljczpuZXcgU3RhdGlzdGljcygpLFxuICAgICAgdHJpdmlhOm5ldyBUcml2aWEoKSxcbiAgICAgIHR3ZWV0czpuZXcgVHdlZXRzKCksXG4gICAgfSxcbiAgICBjb2xsZWN0aW9uOntcbiAgICAgIGRhdGE6J2d1aWRlJyxcbiAgICAgIGVsZW1lbnQ6bmV3IEJhcih7XG4gICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICB0aXRsZTpuZXcgVGl0bGUoKSxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICAnbGVmdC50ZXh0Jzp7XG4gICAgICAgICAgICAgIGRhdGE6J3N0YXJ0LXRpbWUnLFxuICAgICAgICAgICAgICBhZGQ6W1xuICAgICAgICAgICAgICAgICcgLSAnLFxuICAgICAgICAgICAgICAgIHtkYXRhOidlbmQtdGltZSd9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9ICBcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIFBsYXllciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvYWN0aXZlL3BsYXllcicpXG52YXIgVG9wYmFyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9hY3RpdmUvdG9wYmFyJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ2NvbnRlbnQtaXRlbScsXG4gIHg6IHtcbiAgICB0cmFuc2xhdGU6IHRydWVcbiAgfSxcbiAgc2Nyb2xsYmFyOiAneScsXG4gIGhvbGRlcjoge1xuICAgIHk6IHtcbiAgICAgIHZhbDogMCxcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICB0aW1lOiAxOCxcbiAgICAgICAgZWFzaW5nOiAnb3V0Q3ViaWMnLFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgICAgIGlmICh0aGlzLnkudmFsID09PSAtdGhpcy5wbGF5ZXIuaC52YWwgLSAxKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzU3dpcGVkdXAudmFsKSB7XG4gICAgICAgICAgICAgIF90aGlzLnN3aXBldXAuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfdGhpcy50aW1lb3V0eSkge1xuICAgICAgICAgICAgICBfdGhpcy50aW1lb3V0eSA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzU3dpcGVkdXAudmFsKSB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5zd2lwZXVwLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVvdXR5ID0gZmFsc2VcbiAgICAgICAgICAgICAgICBfdGhpcy55LnZhbCA9IF90aGlzLmlzU3dpcGVkdXAudmFsID8gLV90aGlzLnBsYXllci5oLnZhbCArIDMwIDogMFxuICAgICAgICAgICAgICB9LCAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgcGxheWVyOiBuZXcgUGxheWVyKCksXG4gICAgc3dpcGV1cDoge1xuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgbmVzdGVkOiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB3OiBhcHAudyxcbiAgICAgICAgaDogYXBwLmgsXG4gICAgICAgIG1zZzp7XG4gICAgICAgICAgaWNvbjpuZXcgSWNvbih7XG4gICAgICAgICAgICBpY29uOidwdWxsYmFjaydcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB0ZXh0OiAnUmVzdW1lIEhlcmUnXG4gICAgICAgIH0sXG4gICAgICAgICdldmVudHMuY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhcHAudXNlci5yZWNlaXZlci5tZWRpYS4kdXNlck9yaWdpbiA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIHZhbDogYXBwLmgsXG4gICAgICAgIG11bHRpcGx5OiAtMVxuICAgICAgfSxcbiAgICAgIGg6IGFwcC5oXG4gICAgfSxcbiAgICBleHRlbmQ6IHtcbiAgICAgIGlzU3dpcGVkdXA6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAoIXRoaXMucmVuZGVyZWQgJiYgdmFsICYmIHZhbC52YWwpIHtcbiAgICAgICAgICB0aGlzLnN3aXBldXAuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICB0aGlzLnkgPSAtdGhpcy5wbGF5ZXIuaC52YWwgKyAzMFxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3dpcGV1cC5kaXNwbGF5LnZhbCA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgIHRoaXMueSA9IC10aGlzLnBsYXllci5oLnZhbCAtIDFcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnkgPSB2YWwudmFsID09PSB0cnVlID8gLXRoaXMucGxheWVyLmgudmFsIC0gMSA6IDBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlY2VpdmVyTWVkaWE6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMucGFyZW50LmRhdGFcbiAgICAgICAgaWYoZGF0YSl7XG4gICAgICAgICAgdmFyIHN3aXBldXAgPSB0aGlzLmlzU3dpcGVkdXAgPSB2YWwuZnJvbSA9PT0gZGF0YS5mcm9tXG4gICAgICAgICAgaWYgKHN3aXBldXApIHtcbiAgICAgICAgICAgIHRoaXMucGxheWVyLnBsYXlpbmcuZnJvbSA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0aW1lID0gZGF0YS5mcm9tLmdldCgndGltZScpXG4gICAgICAgICAgICBpZiAodGltZS52YWwgPCAwKSB7XG4gICAgICAgICAgICAgIGRhdGEuZnJvbS5nZXQoJ3RpbWUnKS52YWwgPSBNYXRoLmFicyh0aW1lLnZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzIiwicmVxdWlyZSggJy4vc3R5bGUubGVzcycgKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIF9mb2N1c2VkID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvdXRpbCcpLmZvY3VzZWRcbnZhciBMaXN0ID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QnKVxuXG52YXIgTGlzdEhvbGRlciA9IG5ldyBFbGVtZW50KCB7XG4gICdoZWFkZXIudGV4dCc6e2RhdGE6J3RpdGxlJ30sXG4gICdldmVudHMuZG93bic6IGZ1bmN0aW9uKCBlICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICB2YXIgaG9sZGVyID0gdGhpcy5wYXJlbnRcbiAgICB2YXIgZVkgPSBlLnlcbiAgICB2YXIgZVggPSBlLnhcbiAgICB2YXIgaWQgPSAncGFzc0NoZWNrJ1xuXG4gICAgdGhpcy5hZGRFdmVudCggJ21vdmUnLCBmdW5jdGlvbiggZSApIHtcbiAgICAgIHZhciBkWSA9IGUueSAtIGVZXG4gICAgICB2YXIgZFggPSBlLnggLSBlWFxuICAgICAgaWYgKCBNYXRoLmFicyggZFggKSA+IE1hdGguYWJzKCBkWSApICkge1xuICAgICAgICBob2xkZXIuJGZvY3VzLiR1c2VyT3JpZ2luID0gX3RoaXMubmFtZVxuICAgICAgfVxuICAgICAgX3RoaXMucmVtb3ZlRXZlbnQoIGZhbHNlLCBpZCApXG4gICAgfSwgaWQgKVxuXG4gICAgdGhpcy5hZGRFdmVudCggJ3VwJywgZnVuY3Rpb24oIGUgKSB7XG4gICAgICBfdGhpcy5yZW1vdmVFdmVudCggZmFsc2UsIGlkIClcbiAgICB9LCBpZCApXG4gIH1cbn0gKS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KCB7XG4gIGNzczogJ2ZpcnN0LWRpc2NvdmVyJyxcbiAgc3BvdGxpZ2h0OiBuZXcgTGlzdEhvbGRlcigge1xuICAgIGhlYWRlcjpmYWxzZSxcbiAgICBsaXN0OiBuZXcgTGlzdC5TcG90bGlnaHQoeydtb2RlbC5maWVsZCc6J3Nwb3RsaWdodCd9KSxcbiAgICBkb3RzOiBuZXcgTGlzdC5Eb3RzKClcbiAgfSApLFxuICBjaGFubmVsczogbmV3IExpc3RIb2xkZXIoe1xuICAgIG1vZGVsOntmaWVsZDonY2hhbm5lbHMnfSxcbiAgICBsaXN0OiBuZXcgTGlzdC5DaGFubmVsKClcbiAgfSApLFxuICB3YXRjaGluZzogbmV3IExpc3RIb2xkZXIoIHtcbiAgICBtb2RlbDp7ZmllbGQ6J3dhdGNoaW5nJ30sXG4gICAgbGlzdDogbmV3IExpc3QuV2F0Y2hpbmcoKVxuICB9ICksXG4gIHJlbGVhc2VzOiBuZXcgTGlzdEhvbGRlcigge1xuICAgIG1vZGVsOntmaWVsZDoncmVsZWFzZXMnfSxcbiAgICBsaXN0OiBuZXcgTGlzdC5Qb3N0ZXIoKVxuICB9ICksXG4gIHJlY29tbWVuZGVkOiBuZXcgTGlzdEhvbGRlcigge1xuICAgIG1vZGVsOntmaWVsZDoncmVjb21tZW5kZWQnfSxcbiAgICBsaXN0OiBuZXcgTGlzdC5Qb3N0ZXIoKVxuICB9ICksXG4gIGV4dGVuZDp7XG4gICAgJGZvY3VzOiBmdW5jdGlvbiggdmFsICkge1xuICAgICAgdmFyIGNoaWxkID0gdHlwZW9mIHZhbC52YWwgPT09ICdzdHJpbmcnXG4gICAgICAgID8gdGhpc1t2YWwudmFsXVxuICAgICAgICA6IHRoaXMuY2hpbGRyZW5bIHZhbC52YWwgfHwgMCBdXG4gICAgICBfZm9jdXNlZCggdGhpcywgY2hpbGQgKVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsYmFyOiAneScsXG4gICdldmVudHMuc2Nyb2xsJzogZnVuY3Rpb24oIGUgKSB7XG4gICAgaWYoZXhwb3J0cy5pZ25vcmVTY3JvbGwpIHJldHVyblxuICAgIHZhciBub2RlID0gdGhpcy5ub2RlXG4gICAgdmFyIGZyYWN0aW9uID0gKGV4cG9ydHMuc2Nyb2xsVG9wID0gbm9kZS5zY3JvbGxUb3ApIC8gKCBub2RlLnNjcm9sbEhlaWdodCAtIG5vZGUub2Zmc2V0SGVpZ2h0IClcbiAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKCBmcmFjdGlvbiAqICggdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxICkgKVxuICAgIHZhciBuYW1lID0gdGhpcy5jaGlsZHJlbltpbmRleF0ubmFtZVxuICAgIHRoaXMuJGZvY3VzLiR1c2VyT3JpZ2luID0gbmFtZVxuICB9LFxuICBzZXRTZXR0aW5nOiB7XG4gICAgbmFtZTogJ3ByZXBWYWx1ZXMnLFxuICAgIHBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXG4gICAgICB2YXIgY2hpbGRcbiAgICAgIHZhciBmaWVsZFxuICAgICAgdmFyIGxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aFxuICAgICAgdmFyIGkgPSBsZW5ndGggLSAxXG4gICAgICB2YXIgb2JqXG5cbiAgICAgIGZvciAoIDsgaSA+PSAwOyBpLS0gKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV1cbiAgICAgICAgZmllbGQgPSAnZm9jdXNfJyArIGNoaWxkcmVuW2ldLm5hbWVcbiAgICAgICAgaWYgKCAhYXBwLnVzZXJbIGZpZWxkIF0gKXtcbiAgICAgICAgICBvYmogPSB7fVxuICAgICAgICAgIG9ialsgZmllbGQgXSA9IDBcbiAgICAgICAgICBhcHAudXNlci5zZXQoIG9iaiApXG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQubGlzdC4kZm9jdXMgPSBhcHAudXNlclsgZmllbGQgXVxuICAgICAgICBpZihjaGlsZC5kb3RzKSBjaGlsZC5kb3RzLmNvbnRhaW5lci4kZm9jdXMgPSBhcHAudXNlclsgZmllbGQgXVxuICAgICAgfVxuXG4gICAgICBpZihleHBvcnRzLnNjcm9sbFRvcCl7XG4gICAgICAgIGV4cG9ydHMuaWdub3JlU2Nyb2xsID0gdHJ1ZVxuICAgICAgICB0aGlzLm5vZGUuc2Nyb2xsVG9wID0gZXhwb3J0cy5zY3JvbGxUb3BcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgICAgICAgIGV4cG9ydHMuaWdub3JlU2Nyb2xsID0gZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH1lbHNle1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAgIGV4cG9ydHMuaWdub3JlU2Nyb2xsID0gdHJ1ZVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZXhwb3J0cy5pZ25vcmVTY3JvbGwgPSBmYWxzZVxuICAgICAgICAgIHZhciBub2RlID0gX3RoaXMubm9kZVxuICAgICAgICAgIGlmKG5vZGUpe1xuICAgICAgICAgICAgdmFyIGZvY3VzID0gX3RoaXMuJGZvY3VzLnZhbFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoX3RoaXNbZm9jdXNdKVxuICAgICAgICAgICAgbm9kZS5zY3JvbGxUb3AgPSBpbmRleC8obGVuZ3RoIC0gMSkgKiAoIG5vZGUuc2Nyb2xsSGVpZ2h0IC0gbm9kZS5vZmZzZXRIZWlnaHQgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgIH1cbiAgfVxufSApLkNsYXNzXG5cbmZ1bmN0aW9uIGdldEluZGV4KCBfdGhpcyApe1xuICBpZiAoX3RoaXMuX2luZGV4ID09PSB2b2lkIDApIHtcbiAgICB2YXIgc2libGluZ3MgPSBfdGhpcy5wYXJlbnQuY2hpbGRyZW5cbiAgICBmb3IgKHZhciBpID0gc2libGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHNpYmxpbmdzW2ldLl9pbmRleCA9IGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF90aGlzLl9pbmRleFxufVxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIE1vdmllID0gcmVxdWlyZSgnLi4vbW92aWUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBNb3ZpZSh7XG4gICdob2xkZXIucGFnZSc6IHtcbiAgICAnYWN0b3JzLmJvZHkuY29sbGVjdGlvbi5kYXRhJzonc2hvdy5hY3RvcnMnLFxuICAgICdyZWNvbW1lbmRhdGlvbnMuYm9keS5jb2xsZWN0aW9uLmRhdGEnOidzaG93LnJlY29tbWVuZGF0aW9ucydcbiAgfVxufSkuQ2xhc3NcblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNSwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xucmVxdWlyZSggJy4vc3R5bGUubGVzcycgKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIGNhc2VzID0gYXBwLmNhc2VzXG52YXIgVG9wYmFyID0gcmVxdWlyZSgnLi90b3BiYXInKVxudmFyIE1lbnUgPSByZXF1aXJlKCcuL21lbnUnKVxudmFyIFJlbW90ZSA9IHJlcXVpcmUoJy4vcmVtb3RlJylcbnZhciBQb3B1cFxudmFyIEZpcnN0XG5cbi8vYXBwIGFsbGVlbiBtYWFyIHpvIHJlcXVpcmVuIHpvZGF0IGplIGVyYmlqIGthbiB2YXJzIG1vZXRlbiBhbHRpamQgbWVnZWdldmIgd2lyZGVuXG4vL2FwcCBrYW4gamUgdXNlbiB2b29yIGRpbmdlbiBhbHMgYXBwLncsIGFwcC5oIG9mIGRlZmF1bHQgY2FzZXNcblxuaWYgKCBjYXNlcy4kaXNQaG9uZSApIHtcblxuICB2YXIgU3dpdGNoZXIgPSByZXF1aXJlKCAnLi9zd2l0Y2hlcicgKVxuXG4gIEZpcnN0ID0gbmV3IEVsZW1lbnQoe1xuICAgIC8vIHc6YXBwLncsXG4gICAgeTp7dmFsOjAsdHJhbnNsYXRlOnRydWV9LFxuICAgIC8vIGg6YXBwLmgsXG4gICAgY3NzOiAnZmlyc3Qtc3RhdGUnLFxuICAgIG1lbnU6IG5ldyBNZW51KHtcbiAgICAgIG1lbnU6IGFwcC5tZW51XG4gICAgfSksXG4gICAgb246IHtcbiAgICAgIC8vcmVwbGFjZSBvbiB3aXRoIGV4dGVuZGVkIHZhcnMgKG5pY2VyKSBtYXliZSBtYWtlIGEgdHlwZSBmb3IgdGhpcyAodmFsdWUgdGhhdCBhbHNvIHRyaWVzIHRvIGdldCBwYXJlbnQgaWYgaXRzIG5vIGZ1bGwpXG4gICAgICAvL3ZhbHVlIHRoYXQgaGFzIGEgZnVuY3Rpb24gb24gaXQgdGhhdHMganVzdCB0aGUgZGVmZXI/XG4gICAgICBwb3B1cDp7XG4gICAgICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgdmFyIGNhbGxlciA9IHRoaXMuX3BhcmVudC5fY2FsbGVyXG4gICAgICAgICAgaWYodHlwZW9mIHRoaXMudmFsID09PSAnc3RyaW5nJyB8fCB0aGlzLmZyb20uX2NvbnRlbnRUeXBlID09PSAnYWN0b3JzJykge1xuICAgICAgICAgICAgaWYoIWNhbGxlci5wb3B1cCkge1xuICAgICAgICAgICAgICBQb3B1cCA9IFBvcHVwIHx8IHJlcXVpcmUoJy4vcG9wdXAnKVxuICAgICAgICAgICAgICBjYWxsZXIuc2V0KHtcbiAgICAgICAgICAgICAgICBwb3B1cDogbmV3IFBvcHVwKHtcbiAgICAgICAgICAgICAgICAgIHBvcHVwOnRoaXMuX3ZhbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWNvbmRQb3B1cDp7XG4gICAgICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuICAgICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgdmFyIGNhbGxlciA9IHRoaXMuX3BhcmVudC5fY2FsbGVyXG4gICAgICAgICAgaWYodHlwZW9mIHRoaXMudmFsID09PSAnc3RyaW5nJyB8fCB0aGlzLmZyb20uX2NvbnRlbnRUeXBlID09PSAnYWN0b3JzJykge1xuICAgICAgICAgICAgaWYoIWNhbGxlci52b2x1bWUpIHtcbiAgICAgICAgICAgICAgUG9wdXAgPSBQb3B1cCB8fCByZXF1aXJlKCcuL3BvcHVwJylcbiAgICAgICAgICAgICAgY2FsbGVyLnNldCh7XG4gICAgICAgICAgICAgICAgdm9sdW1lOiBuZXcgUG9wdXAoe1xuICAgICAgICAgICAgICAgICAgcG9wdXA6dGhpcy5fdmFsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaG9sZGVyOiB7XG4gICAgICBjc3M6e1xuICAgICAgICB2YWw6IGFwcC5tZW51LCBcbiAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih2YWwsIGN2KSB7XG4gICAgICAgICAgcmV0dXJuIGN2ID8gJ29wZW4nIDogJydcblxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeDp7IFxuICAgICAgICB2YWw6IGFwcC5tZW51LFxuICAgICAgICBtdWx0aXBseTozMjUsXG4gICAgICAgIGFuaW1hdGlvbjp7IHRpbWU6IDEyLCBlYXNpbmc6J291dEN1YmljJyB9IFxuICAgICAgfSxcbiAgICAgIHRvcGJhcjogbmV3IFRvcGJhcigpLFxuICAgICAgLy8gdzoge1xuICAgICAgLy8gICBwYXJlbnQ6ICd3J1xuICAgICAgLy8gfSxcbiAgICAgIC8vIGg6e1xuICAgICAgLy8gICBwYXJlbnQ6ICdoJ1xuICAgICAgLy8gfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBkb3duOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZihhcHAubWVudS52YWwpIHtcbiAgICAgICAgICAgIGUucHJldmVudCA9IHRydWVcbiAgICAgICAgICAgIGFwcC5tZW51LnZhbCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3dpdGNoZXI6IG5ldyBTd2l0Y2hlcih7XG4gICAgICAgIC8vIHc6YXBwLncsXG4gICAgICAgIC8vIGg6eyB2YWw6YXBwLmgsc3ViOlRvcGJhci5iYXNlLmggfVxuICAgICAgfSksXG4gICAgICBtaW5pcGxheWVyOiBuZXcgUmVtb3RlKHtcbiAgICAgICAgXG4gICAgICB9KSBcbiAgICB9XG4gIH0pLkNsYXNzXG5cbn0gZWxzZSB7XG5cbiAgRmlyc3QgPSBuZXcgRWxlbWVudCh7XG4gICAgdGV4dDogJ29vcHMgbm90IHBob25lIGluIGZpcnN0c2NyZWVuJ1xuICB9KS5DbGFzc1xuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmlyc3QiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vc2hhcmVkL2ljb24nKVxuXG52YXIgTWVudUl0ZW0gPSBuZXcgRWxlbWVudCh7XG5cdGljb246IG5ldyBJY29uKHtpY29uOidzZWFyY2gnfSksXG5cdGNzczonbWVudS1pdGVtJyxcblx0dGl0bGU6e31cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcblx0dzphcHAudyxcblx0aDphcHAuaCxcblx0bG9nbzoge30sXG5cdGNzczonbWVudScsXG5cdGV4dGVuZDoge1xuXHRcdG1lbnU6ZnVuY3Rpb24oKXt9LFxuXHRcdG5hdmlnYXRpb246ZnVuY3Rpb24oKXt9XG5cdH0sXG5cdC8vIHNjcm9sbGJhcjoneScsXG5cdGFwcGVuZDogW1xuXHRcdE1lbnVJdGVtLFxuXHRcdHsgJ3RpdGxlLnRleHQnOidzZWFyY2gnLFxuXHRcdFx0J2ljb24uaWNvbic6ICdzZWFyY2hNZW51Jyxcblx0XHRcdCdldmVudHMuY2xpY2snOmZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudC5uYXZpZ2F0aW9uLmZyb20ucGFnZS4kdXNlck9yaWdpbiA9ICdzZWFyY2gnXG5cdFx0XHRcdHRoaXMucGFyZW50Lm1lbnUuZnJvbS52YWwgPSBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0eyAndGl0bGUudGV4dCc6J2Rpc2NvdmVyJyxcblx0XHRcdCdpY29uLmljb24nOiAnZGlzY292ZXInLFxuXHRcdCAnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQubmF2aWdhdGlvbi5mcm9tLnBhZ2UuJHVzZXJPcmlnaW4gPSAnZGlzY292ZXInXG5cdFx0XHRcdHRoaXMucGFyZW50Lm1lbnUuZnJvbS52YWwgPSBmYWxzZVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J3RpdGxlLnRleHQnOidvbiBkZW1hbmQnLFxuXHRcdFx0J2ljb24uaWNvbic6ICdzaG93cycsXG5cdFx0XHRjc3M6J21lbnUtaXRlbSBpbmFjdGl2ZSdcblx0XHR9LFxuXHRcdHtcblx0XHRcdCd0aXRsZS50ZXh0JzonbGl2ZSB0dicsXG5cdFx0XHQnaWNvbi5pY29uJzogJ3R2Jyxcblx0XHQgIGNzczonbWVudS1pdGVtIGluYWN0aXZlJ1xuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J3RpdGxlLnRleHQnOidndWlkZScsXG5cdFx0XHQnaWNvbi5pY29uJzogJ2VwZycsXG5cdFx0XHRjc3M6J21lbnUtaXRlbSBpbmFjdGl2ZSdcblx0XHR9XG5cdF0sXG5cdGZvb3Rlcjoge1xuXHRcdHByb2ZpbGU6e30sXG5cdFx0dGl0bGU6IHtcblx0XHRcdHRleHQ6J0tldmluIFRhZ3VlJ1xuXHRcdH0sXG5cdFx0c2V0dGluZ3M6IG5ldyBJY29uKHtcblx0XHRcdGljb246J3NldHRpbmdzJ1xuXHRcdH0pXG5cdH1cbn0pLnNldCh7XG5cdG5hdmlnYXRpb246e1xuXHRcdGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuXHRcdFx0aWYodGhpcy5mcm9tLnBhZ2UpIHtcblx0XHRcdFx0Zm9yKHZhciBpIGluIHRoaXMuX2NhbGxlci5jaGlsZHJlbikge1xuXHRcdFx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NhbGxlci5jaGlsZHJlbltpXVxuXHRcdFx0XHRcdHZhciB0aXRsZSA9IGNoaWxkLnRpdGxlICYmICBjaGlsZC50aXRsZS50ZXh0LnZhbFxuXHRcdFx0XHRcdHZhciBwYWdlID0gdGhpcy5mcm9tLnBhZ2UudmFsXG5cblx0XHRcdFx0XHRpZiggdGl0bGUgJiYgdGl0bGU9PT1wYWdlICYmIHRoaXMuX2ZvY3VzZWQhPT1jaGlsZCkge1xuXHRcdFx0XHRcdFx0aWYodGhpcy5fZm9jdXNlZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9mb2N1c2VkLmNzcyA9J21lbnUtaXRlbSdcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0dGhpcy5fZm9jdXNlZCA9IHRoaXMuX2NhbGxlci5jaGlsZHJlbltpXVxuXHRcdFx0XHRcdFx0dGhpcy5fZm9jdXNlZC5jc3MgPSAnbWVudS1pdGVtIGZvY3VzZWQnIFxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGUoKVxuXHRcdH1cblx0fVxufSkuQ2xhc3NcblxuXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgVGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC90aXRsZScpXG52YXIgU3VidGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdWJ0aXRsZScpXG52YXIgRGVzY3JpcHRpb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9kZXNjcmlwdGlvbicpXG52YXIgQmFyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvYmFyJylcbnZhciBBY3RvcnMgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9hY3RvcnMnKVxudmFyIFJlY29tbWVuZGF0aW9ucyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3JlY29tbWVuZGF0aW9ucycpXG52YXIgQ29udGVudCA9IHJlcXVpcmUoJy4uL2NvbnRlbnQnKVxudmFyIE1wYWEgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9tcGFhJylcbnZhciBSYXRpbmcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9yYXRpbmcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDb250ZW50KHtcbiAgJ2hvbGRlci5wYWdlJzoge1xuICAgIHRpdGxlYmFyOm5ldyBCYXIoe1xuICAgICAgbGVmdDp7XG4gICAgICAgIHRpdGxlOm5ldyBUaXRsZSgpLFxuICAgICAgICBzdWJ0aXRsZTpuZXcgU3VidGl0bGUoKVxuICAgICAgfSxcbiAgICAgIHJpZ2h0OntcbiAgICAgICAgbXBhYTpuZXcgTXBhYSgpLFxuICAgICAgICByYXRpbmc6bmV3IFJhdGluZygpXG4gICAgICB9XG4gICAgfSksXG4gICAgZGVzY3JpcHRpb246IG5ldyBEZXNjcmlwdGlvbigpLFxuICAgIGFjdG9yczpuZXcgQWN0b3JzKCksXG4gICAgcmVjb21tZW5kYXRpb25zOm5ldyBSZWNvbW1lbmRhdGlvbnMoKVxuICB9XG59KS5DbGFzcyIsIi8vIGZ1bGxzY3JlZW4uanNcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHBsYXllciA9IHRoaXNcbiAgdmFyIGhvbGRlciA9IHBsYXllci5wYXJlbnRcbiAgdmFyIHRvcGJhciA9IGhvbGRlci5jaGVja1BhcmVudCgndG9wYmFyJyx0cnVlKVxuICB2YXIgc3dpdGNoZXJIb2xkZXIgPSBob2xkZXIuY2hlY2tQYXJlbnQoJ3N3aXRjaGVyJywgdHJ1ZSlcbiAgaWYocGxheWVyLmlzRnVsbHNjcmVlbikge1xuICAgIHBsYXllci5zZXQocGxheWVyLnJldmVydEZ1bGxzY3JlZW4pXG4gICAgc3dpdGNoZXJIb2xkZXIuaCA9IHsgdmFsOiBhcHAuaCwgc3ViOiB0b3BiYXIuaC52YWwgfVxuICAgIGhvbGRlci5zZXQoe1xuICAgICAgcGFnZToge1xuICAgICAgICBkaXNwbGF5OidibG9jaydcbiAgICAgIH0sXG4gICAgICBzd2lwZXVwOiB7XG4gICAgICAgIGRpc3BsYXk6e3RyYW5zZm9ybTpudWxsfVxuICAgICAgfVxuICAgIH0pXG4gICAgdG9wYmFyLmRpc3BsYXkgPSAndGFibGUnXG4gICAgcGxheWVyLmlzRnVsbHNjcmVlbiA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICBwbGF5ZXIucmV2ZXJ0RnVsbHNjcmVlbiA9IHBsYXllci5yZXZlcnRGdWxsc2NyZWVuIFxuICAgICAgfHwgKHtcbiAgICAgICAgdzonMTAwJScsXG4gICAgICAgIGg6cGxheWVyLmgudmFsLFxuICAgICAgICByb3RhdGU6MCxcbiAgICAgICAgeDp7dmFsOjAsdHJhbnNsYXRlOnRydWV9XG4gICAgICB9KSBcbiAgICBwbGF5ZXIuc2V0KHtcbiAgICAgIHJvdGF0ZTo5MCxcbiAgICAgIHc6YXBwLmgsXG4gICAgICBoOmFwcC53LFxuICAgICAgeDp7IHZhbDogYXBwLncsIHRyYW5zbGF0ZTogdHJ1ZX0sXG4gICAgfSlcbiAgICBzd2l0Y2hlckhvbGRlci5oID0geyB2YWw6IGFwcC5oLCBzdWI6IDAgfVxuXG4gICAgaG9sZGVyLnNldCh7XG4gICAgICBwYWdlOiB7XG4gICAgICAgIGRpc3BsYXk6J25vbmUnXG4gICAgICB9LFxuICAgICAgc3dpcGV1cDoge1xuICAgICAgICBkaXNwbGF5Ont0cmFuc2Zvcm06J25vbmUnfVxuICAgICAgfVxuICAgIH0pXG4gICAgdG9wYmFyLmRpc3BsYXkgPSAnbm9uZSdcbiAgICBwbGF5ZXIuaXNGdWxsc2NyZWVuID0gdHJ1ZVxuXG5cbiAgICAvLyBwbGF5ZXIubm9kZS5zdHlsZS56SW5kZXggPSAxMFxuICB9XG59XG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBWaWRlbyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8nKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBTZWVrYmFyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2JhcicpXG52YXIgZnVsbHNjcmVlbiA9IHJlcXVpcmUoJy4vZnVsbHNjcmVlbicpXG52YXIgcG9zdHBvbmUgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG52YXIgQVNTRVRTID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvY29uZmlnJykucG9pbnRlcnMuYXNzZXRzXG52YXIgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG52YXIgTG9hZGVyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvbG9hZGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczonZmlyc3QtcGxheWVyJyxcbiAgdmlkZW86IG5ldyBWaWRlbyh7XG4gICAgcGxheWVyOiByZXF1aXJlKCAndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlby9odG1sNScgKSxcbiAgICBzcmM6IHsgZGF0YTogJ3ZpZGVvJywgcHJlcGVuZDogQVNTRVRTIH0sXG4gICAgZHVyYXRpb246IHsgZGF0YTogJ2R1cmF0aW9uJyB9LFxuICAgIHZvbHVtZTogMSxcbiAgICB0aW1lOiB7IGRhdGE6ICd0aW1lJyB9LFxuICAgIGV2ZW50czp7XG4gICAgICBzdGFsbGVkOmZ1bmN0aW9uKCkge1xuICAgICAgICBpZiggdGhpcy5yZW5kZXJlZCApIHRoaXMucGFyZW50LnByZWxvYWQodHJ1ZSlcbiAgICAgIH0sXG4gICAgICBwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5yZW5kZXJlZCAmJiB0aGlzLmdldEJ1ZmZlcigpPDAuMDAxKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQucHJlbG9hZCh0cnVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FucGxheTpmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQucHJlbG9hZChmYWxzZSlcbiAgICAgIH0sXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24ocCwgYikge1xuICAgICAgICBpZih0aGlzLnByZXYgJiYgcCA+IHRoaXMucHJldiApIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5wcmVsb2FkKGZhbHNlKVxuICAgICAgICB9IFxuICAgICAgICB0aGlzLnByZXYgPSBwXG4gICAgICAgIHRoaXMuZGF0YS5mcm9tLnNldCgndGltZScsIC1NYXRoLmFicyhwKSlcbiAgICAgIH1cbiAgICB9XG4gIH0pLFxuICBoOjIxMCxcbiAgb3ZlcmxheToge1xuICAgIG1pZGRsZToge1xuICAgICAgbGVmdDogeyBwbGF5OiB7XG4gICAgICAgICAgaWNvbjogbmV3IEljb24oeyBcbiAgICAgICAgICAgIGljb246IHtcbiAgICAgICAgICAgICAgdmFsOiAncGxheScsXG4gICAgICAgICAgICAgICRpc1BsYXlpbmc6ICdwYXVzZSdcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgfSksXG4gICAgICAgICAgc3VidGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgdmFsOiAnUGxheScsXG4gICAgICAgICAgICAgICRpc1BsYXlpbmc6ICdQYXVzZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgZG93bjogZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgIGlmKHRoaXMuY2hlY2tQYXJlbnQoJ292ZXJsYXknLHRydWUpLm9wYWNpdHkudmFsID4gMC41KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYXlpbmcgPSB0aGlzLmNoZWNrUGFyZW50KCdvdmVybGF5JykucGxheWluZy5mcm9tXG4gICAgICAgICAgICAgICAgcGxheWluZy52YWwgPSAhcGxheWluZy52YWxcbiAgICAgICAgICAgICAgICBlLnByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtaWRkbGU6IHsgXG4gICAgICAgIGxpbmU6IHt9LFxuICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgdmFsOiAnbm9uZScsXG4gICAgICAgICAgJGhhc1JlY2VpdmVyOiAndGFibGUtY2VsbCcsXG4gICAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbigpe31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7IFxuICAgICAgICBzd2lwZXVwOiB7XG4gICAgICAgICAgaWNvbjogbmV3IEljb24oeyBpY29uOiAnc3dpcGV1cCcgfSksXG4gICAgICAgICAgc3VidGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6ICdQbGF5IG9uICdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgZG93bjogZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgIHZhciBwbGF5ZXIgPSB0aGlzLmNoZWNrUGFyZW50KCdvdmVybGF5JylcbiAgICAgICAgICAgICAgaWYocGxheWVyLmlzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgICAgIGZ1bGxzY3JlZW4uY2FsbChwbGF5ZXIpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYocGxheWVyLm92ZXJsYXkub3BhY2l0eS52YWwgPiAwLjUpIHtcbiAgICAgICAgICAgICAgICBhcHAudXNlci5yZWNlaXZlci5wbGF5aW5nLiR1c2VyT3JpZ2luID0gdHJ1ZVxuICAgICAgICAgICAgICAgIGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLiR1c2VyT3JpZ2luID0gdGhpcy5jaGVja1BhcmVudCgnZGF0YScsdHJ1ZSkuZnJvbVxuICAgICAgICAgICAgICAgIGUucHJldmVudCA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgIHZhbDogJ25vbmUnLFxuICAgICAgICAgICRoYXNSZWNlaXZlcjogJ3RhYmxlLWNlbGwnLFxuICAgICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oKXt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgbGVmdDogeyBcbiAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgICBkYXRhOmZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGRhdGEuX2NvbnRlbnRUeXBlPT09J2NoYW5uZWxzJyA/ICdub25lJyA6ICd0YWJsZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRpbWU6eyBcbiAgICAgICAgICAgIGhvbGRlcjogeyBcbiAgICAgICAgICAgICAgdGV4dDp7IFxuICAgICAgICAgICAgICAgIGRhdGE6J3RpbWUnLCBcbiAgICAgICAgICAgICAgICBtdWx0aXBseTogeyBkYXRhOidkdXJhdGlvbicgfSwgXG4gICAgICAgICAgICAgICAgYWJzOnRydWUsIFxuICAgICAgICAgICAgICAgICRjb252ZXJ0VGltZTp0cnVlIFxuICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfSBcbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvbGRlciA6e1xuICAgICAgICAgICAgc2Vla2JhcjogbmV3IFNlZWtiYXIoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZHVyYXRpb246eyB0ZXh0OnsgZGF0YTonZHVyYXRpb24nLCAkY29udmVydFRpbWU6dHJ1ZSB9IH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7IFxuICAgICAgICBmdWxsc2NyZWVuOiBuZXcgSWNvbih7XG4gICAgICAgICAgaWNvbjonZnVsbHNjcmVlbicsXG4gICAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgICBjbGljazpmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHBsYXllciA9IHRoaXMucGFyZW50LnBhcmVudC5wYXJlbnQucGFyZW50XG4gICAgICAgICAgICAgIGZ1bGxzY3JlZW4uY2FsbChwbGF5ZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSBcbiAgICAgIH1cbiAgICB9LFxuICAgIG9wYWNpdHk6IHtcbiAgICAgIHZhbDoxLCBhbmltYXRpb246e1xuICAgICAgICB0aW1lOjE4LFxuICAgICAgICBlYXNpbmc6J291dEN1YmljJ1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVmaW5lOiB7XG4gICAgcHJlbG9hZDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgb3ZlcmxheSA9IHRoaXMub3ZlcmxheVxuICAgICAgaWYoIW92ZXJsYXkgfHwgdGhpcy52aWRlby5kYXRhLmZyb20uX2NvbnRlbnRUeXBlPT09J2NoYW5uZWxzJykgcmV0dXJuXG4gICAgICBpZih2YWw9PT10cnVlICYmIHRoaXMucmVuZGVyZWQpIHtcbiAgICAgICB0aGlzLnByZWxvYWRpbmcgPSB0cnVlXG4gICAgICAgb3ZlcmxheS5ib3R0b20ubGVmdC50YWJsZS5ob2xkZXIuc2Vla2Jhci5jc3MgPSAndWktc2Vla2JhciBsb2FkaW5nJ1xuICAgICAgIG92ZXJsYXkub3BhY2l0eSA9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG92ZXJsYXkuYm90dG9tLmxlZnQudGFibGUuaG9sZGVyLnNlZWtiYXIuY3NzID0gJ3VpLXNlZWtiYXInXG4gICAgICAgIGlmKHRoaXMudmlkZW8uJHBsYXlpbmcudmFsPT09dHJ1ZSAmJiB0aGlzLnByZWxvYWRpbmcpIHtcbiAgICAgICAgICBvdmVybGF5Lm9wYWNpdHkgPSAwXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVsb2FkaW5nID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGZhZGVPdXQ6cG9zdHBvbmUoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3ZlcmxheSA9IHRoaXMub3ZlcmxheVxuICAgICAgaWYoIW92ZXJsYXkpIHJldHVyblxuICAgICAgaWYodGhpcy5wbGF5aW5nICYmIHRoaXMucGxheWluZy52YWw9PT10cnVlICYmICF0aGlzLnByZWxvYWRpbmcpIHtcbiAgICAgICAgb3ZlcmxheS5vcGFjaXR5ID0gMFxuICAgICAgfVxuICAgIH0sMzAwMClcbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgdmFyIG92ZXJsYXkgPSB0aGlzLm92ZXJsYXlcbiAgICAgIGlmKCFvdmVybGF5KSByZXR1cm5cbiAgICAgIGlmKG92ZXJsYXkub3BhY2l0eS52YWw9PT0wIHx8IGUudGVtcFByZXZlbnQpIHtcbiAgICAgICAgb3ZlcmxheS5vcGFjaXR5ID0gMSBcbiAgICAgICAgaWYodGhpcy5wbGF5aW5nLnZhbD09PXRydWUpIHtcbiAgICAgICAgICB0aGlzLmZhZGVPdXQoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYodGhpcy5wbGF5aW5nLnZhbD09PXRydWUgJiYgIWUudGVtcFByZXZlbnQpIHtcbiAgICAgICAgb3ZlcmxheS5vcGFjaXR5ID0gMFxuICAgICAgfVxuICAgIH0sXG4gICAgbW92ZTpmdW5jdGlvbigpIHtcbiAgICAgIGlmKHRoaXMucGxheWluZy52YWw9PT10cnVlKSB7XG4gICAgICAgIHRoaXMuZmFkZU91dCgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBleHRlbmQ6e1xuICAgIHBsYXlpbmc6IHtcbiAgICAgIHNldDpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy52aWRlby4kcGxheWluZyA9IHZhbFxuICAgICAgICBpZih2YWwudmFsPT09dHJ1ZSkge1xuICAgICAgICAgIHRoaXMub3ZlcmxheS5vcGFjaXR5ID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3ZlcmxheS5vcGFjaXR5ID0gMVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVtb3ZlOmZ1bmN0aW9uKCkge1xuICAgICAgICBhcHAuaXNQbGF5aW5nLmZyb20gPSBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVjZWl2ZXI6IGZ1bmN0aW9uKHZhbCwgc3RhbXApIHtcbiAgICAgIGlmKGNhc2VzLiRoYXNSZWNlaXZlci52YWwpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyQ2xpZW50ID0gdmFsLmZyb21cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFBhZ2UgPSByZXF1aXJlKCcuLi9wYWdlLmpzJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIExpc3QgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0JylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIFBvc3RlciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QvaXRlbScpLlBvc3RlclxudmFyIFRyaXZpYSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3RyaXZpYScpXG52YXIgRGVzY3JpcHRpb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9kZXNjcmlwdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBQYWdlKHtcbiAgdzogYXBwLncsXG4gIGg6IHtcbiAgICB2YWw6IGFwcC5oLFxuICAgIHN1YjogNjBcbiAgfSxcbiAgc2Nyb2xsYmFyOiAneScsXG4gIGNhcm91c2VsOiB7XG4gICAgY29udGFpbmVyOiBuZXcgTGlzdC5DYXJvdXNlbCh7XG4gICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgIGRhdGE6ICdpbWcuY292ZXInLFxuICAgICAgICBlbGVtZW50OiBuZXcgRWxlbWVudCh7XG4gICAgICAgICAgY3NzOiAnZm9jdXMtaXRlbScsXG4gICAgICAgICAgaW1nOiBuZXcgSW1nKHtcbiAgICAgICAgICAgIG92ZXJsYXk6IHt9LFxuICAgICAgICAgICAgJ2JhY2tncm91bmQuZGF0YSc6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgICRmb2N1czoge1xuICAgICAgICBkYXRhOiAnZm9jdXMnXG4gICAgICB9XG4gICAgfSksXG4gICAgZG90czogbmV3IExpc3QuRG90cyh7XG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgY29sbGVjdGlvbjoge1xuICAgICAgICAgIGRhdGE6ICdpbWcuY292ZXInLFxuICAgICAgICAgIGVsZW1lbnQ6IG5ldyBFbGVtZW50KClcbiAgICAgICAgfSxcbiAgICAgICAgJGZvY3VzOiB7XG4gICAgICAgICAgZGF0YTogJ2ZvY3VzJyxcbiAgICAgICAgICBkZWZhdWx0OjBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgICdtb2RlbC5zdWJzY3JpcHRpb24nOiB7XG4gICAgICBpbWc6IHtcbiAgICAgICAgY292ZXI6IHtcbiAgICAgICAgICAkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJpbzogbmV3IERlc2NyaXB0aW9uKHtcbiAgICAnaGVhZGVyLnRleHQnOiAnYmlvJyxcbiAgICAnYm9keS50ZXh0LmRhdGEnOiAnYmlvJ1xuICB9KSxcbiAgZmFtb3VzOiB7XG4gICAgJ2hlYWRlci50ZXh0JzogJ0ZhbW91cyBGb3InLFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGRhdGE6ICdjYXRhbG9nJyxcbiAgICAgIGVsZW1lbnQ6IG5ldyBQb3N0ZXIoe1xuICAgICAgICAnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gZmFsc2VcbiAgICAgICAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEuZnJvbVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgbW9kZWw6IHtcbiAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgIHRpdGxlOnRydWUgXG4gICAgICAvL2RvbnQga25vdyB3aHkgdGhpcyB3b3JrcyAtLSBidXQgaXQgZG9lc1xuICAgIH1cbiAgfSxcbiAgdHJpdmlhOiBuZXcgVHJpdmlhKHtcbiAgICBtb2RlbDoge1xuICAgICAgZmllbGQ6ICd0cml2aWEnXG4gICAgfVxuICB9KSxcbiAgZm9vdGVyOnt9LFxuICBvbjoge1xuICAgICRwYXJlbnQ6IHtcbiAgICAgIGRlZmVyOiBmdW5jdGlvbih1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9jYWxsZXIucGFyZW50LnBhcmVudC50b3BiYXIubWlkZGxlLnRleHQgPSB0aGlzLl9wYXJlbnQuX2NhbGxlci5kYXRhLmdldCgndGl0bGUnKVxuICAgICAgICB1cGRhdGUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGNhc2VzID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJyApXG52YXIgdWEgPSByZXF1aXJlKCAndmlnb3VyLWpzL2Jyb3dzZXIvdWEnIClcblxudmFyIHJhZiA9IHJlcXVpcmUoICd2aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vcmFmJyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBJY29uID0gcmVxdWlyZSggJy4uLy4uLy4uL3NoYXJlZC9pY29uJyApXG5cbnZhciBEZXZpY2UgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ2RldmljZScsXG4gIGljb246IG5ldyBJY29uKHsgaWNvbjogeyBcbiAgICBkYXRhOiAnZGV2aWNlJ1xuICB9IH0pLFxuICBpbmZvOiB7XG4gICAgdGl0bGU6IHsgdGV4dDogeyBkYXRhOiAndGl0bGUnfSB9LFxuICAgIHN1YnRpdGxlOiB7IHRleHQ6IHsgZGF0YTogJ2luZm8nIH0gfVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCgge1xuICBjc3M6ICdhY3RpdmUgZGV2aWNlcycsXG4gIG15RGV2aWNlOiBuZXcgRGV2aWNlKHtcbiAgICBtb2RlbDogeyBpbmhlcml0OiBmYWxzZSB9LFxuICAgIG9uOiB7XG4gICAgICAkbmV3OiB7ZGVmZXI6IGZ1bmN0aW9uKHVwZGF0ZSl7XG4gICAgICAgIHRoaXMuX3BhcmVudC5fY2FsbGVyLmRhdGEgPSBhcHAuY2xvdWQuY2xpZW50XG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9fVxuICAgIH0sXG4gICAgaW5mbzoge1xuICAgICAgdGl0bGU6IHsgdGV4dDogJ1RoaXMgRGV2aWNlJyB9LFxuICAgICAgc3VidGl0bGU6IHsgdGV4dDogeyBkYXRhOiAndGl0bGUnIH0gfVxuICAgIH1cbiAgfSksXG4gIGxpc3RUaXRsZTogeyB0ZXh0OiAnQXZhaWxhYmxlIERldmljZXMnIH0sXG4gIG1pZGRsZToge1xuICAgIGRpc3BsYXk6IHtcbiAgICAgIHZhbDogJ2Jsb2NrJyxcbiAgICAgICRoYXNEZXZpY2VzOiAnbm9uZSdcbiAgICB9LFxuICAgIHRleHQ6ICdObyBEZXZpY2VzIEF2YWlsYWJsZSdcbiAgfSxcbiAgbGlzdDoge1xuICAgIGRpc3BsYXk6IHtcbiAgICAgIHZhbDogJ25vbmUnLFxuICAgICAgJGhhc0RldmljZXM6ICdibG9jaydcbiAgICB9LFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGVsZW1lbnQ6IG5ldyBEZXZpY2UoIHtcbiAgICAgICAgY3NzOiAnZGV2aWNlJyxcbiAgICAgICAgbW9kZWw6IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICAgIGlmKCBkYXRhICYmIGRhdGEuZnJvbSAmJiBkYXRhLmZyb20uZGV2aWNlICYmIFxuICAgICAgICAgICAgICAvKHBob25lKS8udGVzdChcbiAgICAgICAgICAgICAgICBkYXRhLmZyb20uZGV2aWNlLnZhbCBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAwLjVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB1c2VyID0gYXBwLnVzZXIvL3RoaXMuY2hlY2tQYXJlbnQoICdvbi51c2VyJywgdHJ1ZSApLl92YWxcbiAgICAgICAgICAgIHZhciBjbGllbnQgPSB0aGlzLmRhdGEuZnJvbVxuICAgICAgICAgICAgaWYoIC8odHYpfCh0YWJsZXQpfChJRkUpLy50ZXN0KCBcbiAgICAgICAgICAgICAgICAgIGNsaWVudC5kZXZpY2UudmFsIFxuICAgICAgICAgICAgICAgICkgXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB1c2VyLnNldFJlY2VpdmVyKCBjbGllbnQgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSApLFxuICAgICAgZGF0YTogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgb246IHtcbiAgICAkcmVuZGVyOiB7XG4gICAgICBkZWZlcjogZnVuY3Rpb24odXBkYXRlKSB7XG4gICAgICAgIC8vIGZmIGJpbmRlbiBub2dcbiAgICAgICAgdmFyIGNhbGxlciA9IHRoaXMuX3BhcmVudC5fY2FsbGVyXG4gICAgICAgIGNhbGxlci5vbi5kZXZpY2VzLl92YWwuX3VwZGF0ZSgpXG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICAkcGFyZW50OntcbiAgICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2NhbGxlci5wYXJlbnQucGFyZW50LnRvcGJhci5taWRkbGUudGV4dCA9ICdkZXZpY2VzJ1xuICAgICAgICB1cGRhdGUoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZGV2aWNlczoge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKCB1cGRhdGUgKSB7XG4gICAgICAgIHZhciBjYWxsZXIgPSB0aGlzLl9wYXJlbnQuX2NhbGxlclxuICAgICAgICBjYWxsZXIub24ucmVjZWl2ZXIuX3VwZGF0ZSgpXG4gICAgICAgIGNhbGxlci5kYXRhID0gdGhpcy5mcm9tXG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICByZWNlaXZlcjoge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKCB1cGRhdGUgKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIHJhZlxuICAgICAgICByYWYoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICggX3RoaXMuX3BhcmVudCApIHtcbiAgICAgICAgICAgIHZhciBjYWxsZXIgPSBfdGhpcy5fcGFyZW50Ll9jYWxsZXJcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9ICBfdGhpcy5mcm9tXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGVsZW0gPSBjYWxsZXIubGlzdC5maW5kKCAnX2QuZnJvbScsIHJlY2VpdmVyLmZyb20gKVxuICAgICAgICAgICAgaWYgKCBlbGVtICkge1xuICAgICAgICAgICAgICBpZiAoIF90aGlzLmZvY3VzICYmIF90aGlzLmZvY3VzLl9ub2RlICkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZvY3VzLmNzcyA9IHtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiAnZm9jdXNlZCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMuZm9jdXMgPSBlbGVtXG4gICAgICAgICAgICAgIGVsZW0uY3NzID0ge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzOiAnZm9jdXNlZCdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggX3RoaXMuZm9jdXMgKSB7XG4gICAgICAgICAgICAgIGlmICggX3RoaXMuZm9jdXMgJiYgX3RoaXMuZm9jdXMuX25vZGUgKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZm9jdXMuY3NzID0ge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6ICdmb2N1c2VkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5mb2N1cyA9IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9IClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gKS5DbGFzc1xuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vc2hhcmVkL2ljb24nKVxuXG52YXIgUG9wdXAgPSByZXF1aXJlKCcuLi8uLi9zaGFyZWQvcG9wdXAnKVxuXG52YXIgQWN0b3JcbnZhciBWb2x1bWVcbnZhciBEZXZpY2VzXG52YXIgUmVtb3RlXG5cbi8vYmFzaXMgb2YgcG9wdXAgaXMgc2hhcmVkIChhbHNvIHVzZWQgZm9yIHJlbW90ZT8gb3IgaXMgcmVtb3RlIGEgcG9wdXAgdGhpbmc/KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgUG9wdXAoe1xuICBwb3B1cDp7XG4gICAgLy8gbWlzYzpmdW5jdGlvbih1cGRhdGUpIHtcbiAgICAvLyAgdmFyIHZhbCA9IHRoaXMudmFsXG4gICAgLy8gIC8vZGl0IGlzIGdlZGVlbGQgLS0gem91IG9vayB2YW51aXQgYXBwIGt1bm5lbiBldmVudHVlZWxcbiAgICAvLyB9LFxuICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSxhcmdzKSB7XG5cbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICBcbiAgICAgIHZhciB2YWwgPSB0aGlzLnZhbFxuICAgICAgdmFyIGVsZW1lbnRcbiAgICAgIHZhciBzd2l0Y2hlciA9IHRoaXMuX2NhbGxlciAmJiB0aGlzLl9jYWxsZXIuc3dpdGNoZXJcbiAgICAgIHZhciBwYXJhbXMgPSB7fVxuICAgICAgdmFyIHRvcGJhclBhcmFtc1xuXG4gICAgICBpZighc3dpdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgaWYodmFsID09PSBmYWxzZSkge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd3dGYgaXMgaGFwcGVuaW4/Pz8/JylcbiAgICAgICAgdGhpcy5fY2FsbGVyLnkgPSBhcHAuaC52YWxcbiAgICAgIH0gZWxzZSBpZih0aGlzLmZyb20uX2NvbnRlbnRUeXBlID09PSAnYWN0b3JzJykgeyAvL2xpc3RlbiB0byBtaXNjIGRpZmZlcmVudCFcbiAgICAgICAgLy93b3JkIGlmIHRoaXMuX2NvbnRlbnRUeXBlID09PSAnYWN0b3InIC8vIGRvZSBkaXQgLS0gcG9wdXAudmFsIHdvcmQgb3AgZ2VsaXN0ZW5kIGluIGFwcFxuICAgICAgICBlbGVtZW50ID0gQWN0b3IgPSBBY3RvciB8fCByZXF1aXJlKCcuL2FjdG9yJylcbiAgICAgICAgcGFyYW1zID0geyBcbiAgICAgICAgICAvLyBjYXJvdXNlbDp7XG4gICAgICAgICAgLy8gICBjb250YWluZXI6e1xuICAgICAgICAgIC8vICAgICAkZm9jdXM6IHRoaXMuZnJvbS5nZXQoJ2ZvY3VzJywyKVxuICAgICAgICAgIC8vICAgfSxcbiAgICAgICAgICAvLyAgIGRvdHM6e1xuICAgICAgICAgIC8vICAgICBjb250YWluZXI6e1xuICAgICAgICAgIC8vICAgICAgICRmb2N1czogdGhpcy5mcm9tLmdldCgnZm9jdXMnLDIpXG4gICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyB9LFxuICAgICAgICAgIGRhdGE6IHRoaXMuZnJvbVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYodmFsID09PSAndm9sdW1lJykgeyAvL2xpc3RlbiB0byBtaXNjIGRpZmZlcmVudCFcbiAgICAgICAgZWxlbWVudCA9IFZvbHVtZSA9IFZvbHVtZSB8fCByZXF1aXJlKCcuL3ZvbHVtZScpXG4gICAgICB9IGVsc2UgaWYodmFsID09PSAnZGV2aWNlcycpIHsgLy9saXN0ZW4gdG8gbWlzYyBkaWZmZXJlbnQhXG4gICAgICAgIC8vIHRvcGJhci5taWRkbGUudGV4dC52YWwgPSBhcHAuZGV2aWNlTWVzc2FnZVxuICAgICAgICBlbGVtZW50ID0gRGV2aWNlcyA9IERldmljZXMgfHwgcmVxdWlyZSgnLi9kZXZpY2VzJylcblxuICAgICAgICB2YXIgdXNlciA9IGFwcC51c2VyXG5cbiAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBkZXZpY2VzOiB1c2VyLmRldmljZXMsXG4gICAgICAgICAgICByZWNlaXZlcjogdXNlci5yZWNlaXZlckNsaWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKHZhbCA9PT0gJ3JlbW90ZScpIHsgLy9saXN0ZW4gdG8gbWlzYyBkaWZmZXJlbnQhXG4gICAgICAgIGVsZW1lbnQgPSBSZW1vdGUgPSBSZW1vdGUgfHwgcmVxdWlyZSgnLi9yZW1vdGUnKVxuICAgICAgICB0b3BiYXJQYXJhbXMgPSB7XG4gICAgICAgICAgLy8gbGVmdDp7XG4gICAgICAgICAgLy8gICBpY29uOiduYXZEb3duJ1xuICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgbWlkZGxlOntcbiAgICAgICAgICAgIHRleHQ6e2RhdGE6J3RpdGxlJ30sXG4gICAgICAgICAgICBkYXRhOmFwcC51c2VyLnJlY2VpdmVyLm1lZGlhXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJpZ2h0OntcbiAgICAgICAgICAvLyAgIGRpc3BsYXk6J25vbmUnXG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICB9IFxuXG4gICAgICBpZihlbGVtZW50KSB7XG4gICAgICAgIHN3aXRjaGVyLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAkcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZih0b3BiYXJQYXJhbXMpe1xuICAgICAgICBzd2l0Y2hlci5wYXJlbnQudG9wYmFyLnNldCh0b3BiYXJQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSgpXG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG5cbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcblxuLy9tYXliZSBhZGQgc2Nyb2xsLCBvbmx5IHdoZW4gbGlzdCBpcyB0b28gbGFyZ2Vcbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICAvLyBjc3M6J3BvcHVwLXBhZ2UnXG4vLyB4Ont0cmFuc2xhdGU6dHJ1ZX1cbi8vICwgc2Nyb2xsYmFyOid5J1xufSkuQ2xhc3MiLCJ2YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi8uLi9zaGFyZWQvaWNvbicpXG52YXIgTGlzdCA9IHJlcXVpcmUoJy4uLy4uLy4uL3NoYXJlZC9saXN0JylcbnZhciBvZmZzZXQgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvb2Zmc2V0JylcblxudmFyIHRodW1iID0gbmV3IExpc3QuSXRlbS5JbmZvKHtcblx0Y3NzOidjYXJvdXNlbC1pdGVtJyxcblx0c2NhbGU6e1xuXHRcdHBhcmVudDoneCcsXG5cdFx0dHJhbnNmb3JtOmZ1bmN0aW9uKCl7XG5cdFx0XHR2YXIgcmVjdCA9IHRoaXMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXHRcdFx0dmFyIGxlZnQgPSByZWN0LmxlZnRcblx0XHRcdHZhciByaWdodCA9IHJlY3QucmlnaHRcblx0XHRcdHZhciBtaWRkbGUgPSBhcHAudy52YWwvMlxuXHRcdFx0dmFyIHdpZHRoID0gcmVjdC53aWR0aFxuXHRcdFx0dmFyIHZhbCA9IE1hdGgubWF4KDEgLSBNYXRoLmFicygobGVmdCArIHdpZHRoLzIpIC0gbWlkZGxlKS8xMDAwLDAuOClcblx0XHRcdHRoaXMuY3NzID0gbGVmdCA8PSBtaWRkbGUgJiYgcmlnaHQgPj0gbWlkZGxlXG5cdFx0XHRcdD9cdCdjYXJvdXNlbC1pdGVtIGZyb250J1xuXHRcdFx0XHQ6ICdjYXJvdXNlbC1pdGVtJ1xuXHRcdFx0cmV0dXJuIHZhbFxuXHRcdH1cblx0fSxcbiAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKSB7XG4gIFx0YXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gZmFsc2VcbiAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEuZnJvbVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG5cdHc6YXBwLncsXG5cdGg6MjQwLFxuXHRleHRlbmQ6IHtcblx0XHRtZWRpYTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR2YXIgX3RoaXMgPSB0aGlzXG5cdFx0XHR2YXIgc2xpZGVyID0gdGhpcy5zbGlkZXJcblx0XHRcdHZhciBjaGlsZHJlbiA9IHNsaWRlci5jaGlsZHJlblxuXG5cdFx0XHRmb3IodmFyIGkgaW4gY2hpbGRyZW4pIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV1cblx0XHRcdFx0aWYoY2hpbGQuZGF0YSA9PT0gdmFsLmZyb20gJiYgdGhpcy5mb2N1c2VkICE9PSBjaGlsZCkge1xuXHRcdFx0XHRcdGlmKCFzbGlkZXIuX2NoZWNrICYmIGNoaWxkcmVuLmxlbmd0aCA+IDEpe1xuXHRcdFx0XHRcdFx0c2xpZGVyLnguX3AgPSB0cnVlXG5cdFx0XHRcdFx0XHRzbGlkZXIuJGZvY3VzID0gaVxuXHRcdFx0XHRcdFx0c2xpZGVyLnguX3AgPSBudWxsXG5cdFx0XHRcdFx0XHRzbGlkZXIuX2NoZWNrID0gdHJ1ZVxuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0c2xpZGVyLiRmb2N1cyA9IGlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYoIXRoaXMubGlzdGVuRm9jdXMpIHtcblx0XHRcdFx0XHRcdHRoaXMubGlzdGVuRm9jdXMgPSB0cnVlXG5cdFx0XHRcdFx0XHRzbGlkZXIuJGZvY3VzLm9uKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgZm9jdXMgPSBzbGlkZXIuY2hpbGRyZW5bdGhpcy52YWxdLmRhdGFcblx0XHRcdFx0XHRcdFx0aWYodmFsLmZyb20hPT1mb2N1cyAmJiBmb2N1cykge1xuXHRcdFx0XHRcdFx0XHRcdGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLiR1c2VyT3JpZ2luID0gZm9jdXNcblxuXHRcdFx0XHRcdFx0XHRcdGZvY3VzLmdldCgndGltZScpLmlzKCdsb2FkZWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLmZyb209PT1mb2N1cykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnZhbCA9IE1hdGguYWJzKHRoaXMudmFsKVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyB9XG5cdFx0fVxuXHR9LFxuXHRzbGlkZXI6IG5ldyBMaXN0LkNhcm91c2VsKHtcblx0XHR4Ont2YWw6MjgwLTMwKzJ9LFxuXHRcdGNvbGxlY3Rpb246IHtcblx0XHRcdGRhdGE6dHJ1ZSxcblx0XHRcdGZpbHRlcjp0cnVlLFxuXHRcdFx0ZWxlbWVudDp0aHVtYlxuXHRcdH0sXG5cdFx0bW9kZWw6e1xuXHRcdFx0Y29tcGxldGU6ZnVuY3Rpb24oKXtcblx0XHRcdFx0aWYodGhpcy5jaGlsZHJlblsxXSAmJiB0aGlzLnBhcmVudC5tZWRpYSl7IC8vIGZvcmNlIGFuIHVwZGF0ZSB3aGVuIGNoaWxkcmVuIGFyZSByZWFkeVxuXHRcdFx0XHRcdHRoaXMueC5fcCA9IHRydWVcblx0XHRcdFx0XHR0aGlzLnBhcmVudC5tZWRpYS51cGRhdGUoKVxuXHRcdFx0XHRcdHRoaXMubW9kZWwgPSBmYWxzZVxuXHRcdFx0XHRcdHRoaXMueC5fcCA9IG51bGxcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSlcbn0pLkNsYXNzXG5cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBQYWdlID0gcmVxdWlyZSggJy4uL3BhZ2UuanMnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIFNlZWtiYXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zZWVrYmFyJylcblxudmFyIENhcm91c2VsID0gcmVxdWlyZSgnLi9jYXJvdXNlbCcpXG5cbnZhciBEZXNjcmlwdGlvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2Rlc2NyaXB0aW9uJylcblxudmFyIEd1aWRlID0gbmV3IEVsZW1lbnQoe1xuXHQnaGVhZGVyLnRleHQnOiAnVXAgTmV4dCcsXG5cdGl0ZW1zOiB7XG5cdFx0Y29sbGVjdGlvbjoge1xuXHRcdFx0ZGF0YTonZ3VpZGUnLFxuXHRcdFx0ZWxlbWVudDogbmV3IEVsZW1lbnQoe1xuXHRcdFx0XHRjc3M6J2JvZHknLFxuXHRcdFx0XHR0aXRsZTogeyB0ZXh0OiB7IGRhdGE6J3RpdGxlJyB9IH0sXG5cdFx0XHRcdHN1YnRpdGxlOiB7XG5cdFx0XHRcdFx0dGV4dDoge1xuXHRcdFx0XHRcdFx0ZGF0YTonc3RhcnQtdGltZScsXG5cdFx0XHRcdFx0XHRhZGQ6WyAnIC0gJywgeyBkYXRhOidlbmQtdGltZScgfSBdXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1cblx0fVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IFBhZ2Uoe1xuXHRjc3M6J3JlbW90ZScsXG5cdC8vIHRleHQ6e3ZhbDoncmVtb3RlaXQhJ30sXG5cdGNhcm91c2VsOiBuZXcgQ2Fyb3VzZWwoKSxcblx0aW5mbzoge1xuXG5cdH0sXG5cdGNvbnRyb2xzOiB7XG5cdFx0dGl0bGU6IHsgdGV4dDp7IGRhdGE6J2d1aWRlLjAudGl0bGUnLCBkZWZhdWx0OntkYXRhOid0aXRsZSd9IH19LFxuXHRcdHNlZWtiYXI6IG5ldyBTZWVrYmFyKHtcblx0XHRcdC8vIGJ1dHRvbjogeyB5OnsgdmFsOi04LHRyYW5zbGF0ZTp0cnVlIH0gfVxuXHRcdH0pLFxuXHRcdGJ1dHRvbnM6IHtcblx0XHRcdGxlZnQ6IG5ldyBJY29uKHtcblx0XHRcdFx0aWNvbjoncmV3aW5kJ1xuXHRcdFx0fSksXG5cdFx0XHRwbGF5OiBuZXcgSWNvbih7XG5cdFx0XHRcdGV4dGVuZDoge1xuXHRcdFx0XHRcdHBsYXlpbmc6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRcdFx0dGhpcy5pY29uID0gdmFsLnZhbCA9PT0gdHJ1ZSA/ICdwYXVzZScgOiAncGxheSdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGljb246J3BsYXknLFxuXHRcdFx0XHQnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLnBsYXlpbmcuJHVzZXJPcmlnaW4gPSAhdGhpcy5wbGF5aW5nLnZhbFxuXHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHRcdHJpZ2h0OiBuZXcgSWNvbih7XG5cdFx0XHRcdGljb246J2Zhc3Rmb3J3YXJkJ1xuXHRcdFx0fSksXG5cdFx0XHR2b2x1bWU6IG5ldyBJY29uKHtcblx0XHRcdFx0aWNvbjondm9sdW1lJyxcblx0XHRcdFx0J2V2ZW50cy5jbGljayc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGFwcC5zZWNvbmRQb3B1cC52YWwgPSAndm9sdW1lJ1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1cblx0fSxcblx0ZXh0ZW5kOiB7XG5cdFx0cmVjZWl2ZXJNZWRpYTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR2YXIgaW5mbyA9IHRoaXMuaW5mb1xuXHRcdFx0dmFyIGZyb20gPSB2YWwuZnJvbVxuXHRcdFx0dGhpcy5jb250cm9scy5kYXRhID0gdmFsLmZyb21cblx0XHRcdC8vYnVnIGZpeFxuXHRcdFx0dmFyIHNlZWsgPSB0aGlzLmNvbnRyb2xzLnNlZWtiYXIuc2Vla1xuXHRcdFx0c2Vlay53LnVwZGF0ZShzZWVrKVxuXG5cdFx0XHRpZihmcm9tLl9jb250ZW50VHlwZT09PSdjaGFubmVscycpIHtcblx0XHRcdFx0aWYoaW5mby5ndWlkZSYmaW5mby5ndWlkZS5kYXRhICE9PSBmcm9tKSB7XG5cdFx0XHRcdFx0aW5mby5lbXB0eSgpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWluZm8uZ3VpZGUpIHtcblx0XHRcdFx0XHRpbmZvLmVtcHR5KClcblx0XHRcdFx0XHRpbmZvLnNldCh7XG5cdFx0XHRcdFx0XHRndWlkZTogbmV3IEd1aWRlKHtkYXRhOmZyb219KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0dGhpcy5jYXJvdXNlbC5kYXRhID0gYXBwLmNvbnRlbnQuZ2V0KCdjaGFubmVscycpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jYXJvdXNlbC5tZWRpYSA9IGZyb21cblxuXHRcdFx0fSBlbHNlIGlmKCBmcm9tLl9jb250ZW50VHlwZSAhPT0gJ3JlY2VpdmVyJykge1xuXHRcdFx0XHRpZihpbmZvLmRlc2NyaXB0aW9uICYmIGluZm8uZGVzY3JpcHRpb24uZGF0YSAhPT0gZnJvbSkge1xuXHRcdFx0XHRcdGluZm8uZW1wdHkoKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFpbmZvLmRlc2NyaXB0aW9uKSB7XG5cdFx0XHRcdFx0aW5mby5lbXB0eSgpXG5cdFx0XHRcdFx0aW5mby5zZXQoe1xuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb246IG5ldyBEZXNjcmlwdGlvbih7ZGF0YTpmcm9tfSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGlmKGZyb20uX2NvbnRlbnRUeXBlPT09J21vdmllcycpIHtcblx0XHRcdFx0XHRcdHRoaXMuY2Fyb3VzZWwuZGF0YSA9IGFwcC5jb250ZW50LmdldCgnbW92aWVzJylcblx0XHRcdFx0XHRcdC8vZm9jdXMgZ2FhdCB3ZWlyZCFcblx0XHRcdFx0XHR9IGVsc2UgaWYoZnJvbS5fY29udGVudFR5cGUgPT09ICdlcGlzb2RlcycpIHtcblx0XHRcdFx0XHRcdC8vY29udGVudCB0eXBlIHdvcmQgZXBpc29kZSAtLS1cblx0XHRcdFx0XHRcdC8vaGFyZGVyIHRvIGRvXG5cdFx0XHRcdFx0XHR0aGlzLmNhcm91c2VsLmRhdGEgPSBmcm9tLl9wYXJlbnRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jYXJvdXNlbC5tZWRpYSA9IGZyb21cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdG9uOiB7XG5cdFx0JHBhcmVudDp7IGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuXHRcdFx0dGhpcy5fcGFyZW50Ll9jYWxsZXIucGFyZW50LnBhcmVudC50b3BiYXIubWlkZGxlLnRleHQgPSAncmVtb3RlJ1xuXHRcdFx0Ly9kaXJ0eSBsb2NhdGlvbiBidXQgZmluZSBmb3Igbm93XG5cdFx0XHRhcHAucG9wdXAub25jZShmdW5jdGlvbigpe1xuXHRcdFx0XHRpZihcdHRoaXMudmFsPT09ZmFsc2UgXG5cdFx0XHRcdCAmJiBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuZnJvbSAhPT0gYXBwLnVzZXIucmVjZWl2ZXIubWVkaWEuZnJvbSApIHtcblx0XHRcdFx0XHRhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSBhcHAudXNlci5yZWNlaXZlci5tZWRpYS5mcm9tXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cblx0XHRcdHVwZGF0ZSgpXG5cdFx0fX0sXG5cdFx0JG5ldzp7ZGVmZXI6ZnVuY3Rpb24odXBkYXRlKSB7XG5cdFx0XHR0aGlzLl9wYXJlbnQuX2NhbGxlci5yZWNlaXZlck1lZGlhID0gYXBwLnVzZXIucmVjZWl2ZXIubWVkaWFcblx0XHRcdHRoaXMuX3BhcmVudC5fY2FsbGVyLmNvbnRyb2xzLmJ1dHRvbnMucGxheS5wbGF5aW5nID0gYXBwLnVzZXIucmVjZWl2ZXIucGxheWluZ1xuXHRcdFx0dXBkYXRlKClcblx0XHR9fVxuXHR9XG59KS5DbGFzc1xuXG5cbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgUGFnZSA9IHJlcXVpcmUoICcuLi9wYWdlLmpzJyApXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3NoYXJlZC9pY29uJylcbnZhciBvZmZzZXQgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvb2Zmc2V0JylcblxucmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IFBhZ2Uoe1xuXHR3OmFwcC53LFxuXHRjc3M6J3ZvbHVtZScsXG5cdHRvcDoge1xuXHRcdHRpdGxlOiB7IHRleHQ6ICcxMDAlJyB9LFxuXHRcdHZvbHVtZTogbmV3IEljb24oe1xuXHRcdFx0aWNvbjondm9sdW1lJywgXG5cdFx0XHQnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50LnBhcmVudC52b2x1bWUuJHVzZXJPcmlnaW4gPSAxXG5cdFx0XHR9XG5cdFx0fSlcblx0fSxcblx0ZXh0ZW5kOiB7XG5cdFx0dm9sdW1lOmZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0aWYoIXRoaXMuX3ZvbHNldCAmJiB2YWwuZnJvbSE9PXZhbCkge1xuXHRcdFx0XHR0aGlzLl92b2xzZXQgPSB0cnVlXG5cdFx0XHRcdHRoaXMuc2xpZGVyLmJsb2NrLnkgPSB2YWxcblx0XHRcdFx0dGhpcy5zbGlkZXIuYmxvY2subWlkZGxlLnRleHQgPSB2YWxcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdG9uOiB7XG5cdFx0JG5ldzp7IFxuXHRcdFx0ZGVmZXI6ZnVuY3Rpb24odXBkYXRlKSB7XG5cdFx0XHRcdHZhciBjYWxsZXIgPSB0aGlzLl9wYXJlbnQuX2NhbGxlclxuXHRcdFx0XHRpZighY2FsbGVyLnZvbHVtZSkge1xuXHRcdFx0XHRcdGNhbGxlci52b2x1bWUgPSBhcHAudXNlci5yZWNlaXZlci52b2x1bWVcblx0XHRcdFx0fVxuXHRcdFx0XHR1cGRhdGUoKVxuXHRcdFx0fSBcblx0XHR9LFxuXHRcdCRwYXJlbnQ6e1xuXHRcdFx0ZGVmZXI6ZnVuY3Rpb24odXBkYXRlKSB7XG5cdFx0XHRcdHRoaXMuX3BhcmVudC5fY2FsbGVyLnBhcmVudC5wYXJlbnQudG9wYmFyLm1pZGRsZS50ZXh0LnZhbCA9ICd2b2x1bWUnXG5cdFx0XHRcdHVwZGF0ZSgpXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRzbGlkZXI6IHtcblx0XHR3OiBhcHAudyxcblx0XHRoOnt2YWw6YXBwLmgsc3ViOjM1MH0sXG5cdFx0eDp7bWF4OjAsbWluOjB9LFxuXHRcdGJsb2NrOiB7XG5cdFx0XHR5OnsgXG5cdFx0XHRcdHRyYW5zZm9ybTogZnVuY3Rpb24odixjdikge1xuXHRcdFx0XHRcdGN2ID0gY3Y+LTEgPyBjdiA6IDFcblx0XHRcdFx0XHRyZXR1cm4gKHRoaXMucGFyZW50ICYmICh0aGlzLnBhcmVudC5oLnZhbC0zMCktNjApKiggMS1jdiApKzMwXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRldmVudHM6IHtcblx0XHRcdFx0ZHJhZzpmdW5jdGlvbihlKSB7XG5cblx0XHRcdFx0XHRpZiggIXRoaXMuX29mZnNldCApIHtcblx0XHRcdFx0XHRcdHRoaXMuX29mZnNldCA9IG9mZnNldC55KHRoaXMucGFyZW50KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2RyYWdzdGFydFxuXHRcdFx0XHRcdGlmKCF0aGlzLl9kcmFnaW5mb3MpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2RyYWdpbmZvcyA9IGUueS1vZmZzZXQueSh0aGlzKSt0aGlzLl9vZmZzZXRcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFxuXHRcdFx0XHRcdHZhciBjYWxjID0gMSAtICggZS55IC0gdGhpcy5fZHJhZ2luZm9zICkgLyAodGhpcy5wYXJlbnQuaC52YWwtMzApXG5cdFx0XHRcdFx0aWYoY2FsYz4xKSBjYWxjID0gMVxuXHRcdFx0XHRcdGlmKGNhbGM8MCkgY2FsYyA9IDBcblx0XHRcdFx0XHR0aGlzLnBhcmVudC5wYXJlbnQudm9sdW1lLiR1c2VyT3JpZ2luID0gY2FsY1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR1cDpmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLl9kcmFnaW5mb3MgPSBmYWxzZVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bGVmdDogbmV3IEljb24oe1xuXHRcdFx0XHRpY29uOiAnbWVudSdcblx0XHRcdH0pLFxuXHRcdFx0bWlkZGxlOiB7XG5cdFx0XHRcdHRleHQ6IHsgXG5cdFx0XHRcdFx0dHJhbnNmb3JtOiBmdW5jdGlvbihjLCBjdikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoY3YqMTAwKSsnJSdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyaWdodDogbmV3IEljb24oe1xuXHRcdFx0XHRpY29uOiAnbWVudVJpZ2h0J1xuXHRcdFx0fSksXG5cdFx0XHQvLyB3Ont2YWw6YXBwLncsc3ViOjMwfSxcblx0XHRcdGg6NjBcblx0XHR9XG5cdH0sXG5cdG11dGU6IHtcblx0XHRtdXRlZDogbmV3IEljb24oe2ljb246J211dGVkJ30pLFxuXHRcdCdldmVudHMuY2xpY2snOmZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5wYXJlbnQudm9sdW1lLiR1c2VyT3JpZ2luID0gMFxuXHRcdH1cblx0fVxufSkuQ2xhc3NcblxuXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi9zaGFyZWQvaWNvbicpXG52YXIgU3VidGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdWJ0aXRsZScpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcblx0Y3NzOidtaW5pLXJlbW90ZScsXG5cdHk6e3ZhbDowLGFuaW1hdGlvbjp7IHRpbWU6MTAsIGVhc2luZzonb3V0Q3ViaWMnfX0sXG5cdGV4dGVuZDoge1xuXHRcdHBsYXlpbmc6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0dGhpcy5yaWdodC5pY29uID0gdmFsLnZhbCA9PT0gdHJ1ZSA/ICdwYXVzZScgOiAncGxheSdcblx0XHR9LFxuXHRcdG1lZGlhOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHZhciB0eXBlID0gdmFsLmZyb20uX2NvbnRlbnRUeXBlXG5cdFx0XHRpZiggdHlwZSA9PT0gJ21vdmllcycgfHwgdHlwZSA9PT0gJ2NoYW5uZWxzJyB8fCB0eXBlID09PSAnc2VyaWVzJyB8fCB0eXBlID09PSAnZXBpc29kZXMnICkge1xuXHRcdFx0XHR2YXIgX3RoaXMgPSB0aGlzXG5cdFx0XHRcdC8vIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFx0X3RoaXMucGFyZW50LnN3aXRjaGVyLmggPSB7IGFkZDotNTAgfVxuXHRcdFx0XHQvLyB9LDUwMClcblxuXHRcdFx0XHR0aGlzLnkgPSAwXG5cdFx0XHRcdGlmKHRoaXMuZGF0YSE9PXZhbC5mcm9tKSB7XG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gdmFsLmZyb21cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdGhpcy5wYXJlbnQuc3dpdGNoZXIuaCA9IHsgYWRkOjAgfVxuXHRcdFx0XHR0aGlzLnkgPSA1MFxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0bGVmdDoge1xuXHRcdGJhY2tncm91bmQ6IHtcblx0XHRcdHZhbDpjb25maWcucG9pbnRlcnMuYXNzZXRzLFxuXHRcdFx0YWRkOiB7IGRhdGE6ICdpbWcudGh1bWInIH1cblx0XHR9XG5cdH0sXG5cdG1pZGRsZToge1xuXHRcdHRpdGxlOiB7XG5cdFx0XHR0ZXh0OntkYXRhOid0aXRsZSd9XG5cdFx0fSxcblx0XHRpbmZvOm5ldyBTdWJ0aXRsZSgpXG5cdH0sXG5cdHJpZ2h0OiBuZXcgSWNvbih7XG5cdFx0aWNvbjoncGxheScsXG5cdFx0J2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuXHRcdFx0ZS5wcmV2ZW50ID0gdHJ1ZVxuXHRcdFx0dGhpcy5wYXJlbnQucGxheWluZy4kdXNlck9yaWdpbiA9ICF0aGlzLnBhcmVudC5wbGF5aW5nLnZhbFxuXHRcdH1cblx0XHQvL2hpZXIgZmYgZGllIGxpc3RlbmluZ1xuXHR9KSxcblx0J2V2ZW50cy5jbGljayc6IGZ1bmN0aW9uKGUpIHtcblx0XHRhcHAucG9wdXAuJHVzZXJPcmlnaW4gPSAncmVtb3RlJ1xuXHR9XG59KS5DbGFzc1xuXG5cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIHBvc3Rwb25lID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxudmFyIHRpbWVzdGFtcCA9IHJlcXVpcmUoJ21vbm90b25pYy10aW1lc3RhbXAnKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgVG9wYmFyID0gcmVxdWlyZSgnLi4vdG9wYmFyJylcbnZhciBzZWFyY2ggPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zZWFyY2gnKVxuXG4vL1RPRE86IHVzZSBkYXRhIGJvdW5kIHRvIGRpc3BsYXkgaW5zdGVhZCBvZiB0aGUgYmlnIGlmIHN0YXRlbWVudFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J2ZpcnN0LXNlYXJjaCcsXG4gIGV4dGVuZDoge1xuICAgIHNlYXJjaDogZnVuY3Rpb24oKXt9XG4gIH0sXG4gIGRlZmluZToge1xuICAgIGFkZFJlY2VudFNlYXJjaDogcG9zdHBvbmUoZnVuY3Rpb24oc3JjaCkge1xuICAgICAgaWYoIXRoaXMubm9kZSkgcmV0dXJuXG4gICAgICBpZighdGhpcy5wYWdlIHx8ICF0aGlzLnBhZ2UucmVjZW50LmRhdGEpIHJldHVyblxuICAgICAgdmFyIGtleXMgPSB0aGlzLnBhZ2UucmVjZW50LmhvbGRlci5kYXRhLmtleXNcbiAgICAgIHZhciByZWNlbnRzID0gdGhpcy5wYWdlLnJlY2VudC5ob2xkZXIuZGF0YS4kdXNlck9yaWdpblxuICAgICAgaWYoa2V5cy5sZW5ndGg+NSkge1xuICAgICAgICByZWNlbnRzW2tleXNbMF1dLnJlbW92ZSgpXG4gICAgICB9XG4gICAgICB2YXIgZm91bmRcbiAgICAgIGlmKHJlY2VudHMpIHtcbiAgICAgICAgcmVjZW50cy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKHRoaXMudGl0bGUudmFsID09PSBzcmNoKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWVcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYoIWZvdW5kKSB7XG4gICAgICAgIHJlY2VudHMuc2V0KHRpbWVzdGFtcCgpLHt0aXRsZTpzcmNofSlcbiAgICAgIH1cbiAgICB9LDEwMDApXG4gIH0sXG4gIHBhZ2U6bmV3IHNlYXJjaC5SZXN1bHRMaXN0KHtcbiAgICBzY3JvbGxiYXI6J3knLFxuICAgIGFwcGVuZDp7XG4gICAgICB2YWw6W1xuICAgICAgICBuZXcgRWxlbWVudCh7XG4gICAgICAgICAgbmFtZTonbm9SZXN1bHRzJyxcbiAgICAgICAgICBkaXNwbGF5Oidub25lJyxcbiAgICAgICAgICBpY29uOiBuZXcgSWNvbih7aWNvbjond3JvbmcnfSksXG4gICAgICAgICAgJ3RpdGxlLnRleHQnOidObyByZXN1bHRzIScsXG4gICAgICAgICAgJ2JvZHkudGV4dCc6J1BsZWFzZSB0cnkgdG8gcmVmaW5lIHlvdXIgcXVlcnknXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgc2VhcmNoLlRvcFJlc3VsdCh7XG4gICAgICAgICAgbmFtZTondG9wcmVzdWx0J1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IEVsZW1lbnQoe1xuICAgICAgICAgIG5hbWU6J3JlY2VudCcsXG4gICAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICAgIGluaGVyaXQ6ZmFsc2UsXG4gICAgICAgICAgICBjb21wbGV0ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYodGhpcy5kYXRhLmtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub1JlY2VudC5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgICAgdGhpcy5ob2xkZXIuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vUmVjZW50LmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgICAgdGhpcy5ob2xkZXIuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBub1JlY2VudDp7XG4gICAgICAgICAgICBpY29uOiBuZXcgSWNvbih7aWNvbjonc2VhcmNoTWVudSd9KSxcbiAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgIHRleHQ6J1N0YXJ0IFNlYXJjaGluZyEnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keToge1xuICAgICAgICAgICAgICB0ZXh0OidGaW5kIHlvdXIgZmF2b3JpdGUgbW92aWVzLCBzaG93cyBhbmQgY2hhbm5lbHMuJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaG9sZGVyOiBuZXcgc2VhcmNoLlJlc3VsdHMoe1xuICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgdGV4dDoncmVjZW50IHNlYXJjaGVzJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IHtcbiAgICAgICAgICAgICAgZGF0YTp0cnVlLFxuICAgICAgICAgICAgICBlbGVtZW50OiBuZXcgc2VhcmNoLlJlc3VsdCh7XG4gICAgICAgICAgICAgICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BhcmVudCgnc2VhcmNoJyx0cnVlKS4kdXNlck9yaWdpbiA9IHRoaXMuZGF0YS50aXRsZS52YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBmaWx0ZXI6IHtcbiAgICAgICAgICAgICAgICBzb3J0OnsgZmllbGQ6J19uYW1lJywgb3JkZXI6J3otYSd9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgXSxcbiAgICAgIGJlZm9yZTonbW92aWVzJ1xuICAgIH1cbiAgfSksXG4gIG92ZXJsYXk6IHtcbiAgICBkaXNwbGF5Oidub25lJ1xuICB9LFxuICBzZWFyY2g6e1xuICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSwgYXJncykge1xuXG4gICAgICBpZighdGhpcy5mcm9tLmNsb3VkKSByZXR1cm4gdHJ1ZVxuXG4gICAgICB2YXIgY2FsbGVyID0gdGhpcy5fY2FsbGVyXG4gICAgICB2YXIgZWxlbSRcblxuICAgICAgdmFyIGxpc3QgPSBbXG4gICAgICAgICAgY2FsbGVyLnBhZ2UubW92aWVzLFxuICAgICAgICAgIGNhbGxlci5wYWdlLnNlcmllcyxcbiAgICAgICAgICBjYWxsZXIucGFnZS5jaGFubmVscyxcbiAgICAgICAgICBjYWxsZXIucGFnZS5hY3RvcnNcbiAgICAgICAgXVxuXG4gICAgICAvLyBpZighY2FsbGVyLnRvcGJhci5maWVsZC5kYXRhKSB7XG4gICAgICAvLyAgIGNhbGxlci50b3BiYXIuZmllbGQuZGF0YSA9IHRoaXMuX3ZhbFxuICAgICAgLy8gfVxuICAgICAgXG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuXG4gICAgICBpZih0aGlzLnZhbCkge1xuICAgICAgICB2YXIgc3JjaCA9IHNlYXJjaC5wYXJzZVNlYXJjaCggdGhpcy52YWwgKVxuICAgICAgICBpZiggc3JjaCE9PWZhbHNlICkge1xuICAgICAgICAgIGNhbGxlci5hZGRSZWNlbnRTZWFyY2goc3JjaClcbiAgICAgICAgICBmb3IodmFyIGkgaW4gbGlzdCkge1xuICAgICAgICAgICAgc2VhcmNoLmZpbHRlckNvbGxlY3Rpb24oIGxpc3RbaV0sIHNyY2ggKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNhbGxlci5wYWdlLnJlY2VudC5kaXNwbGF5ID0gJ25vbmUnXG5cbiAgICAgICAgICBjYWxsZXIuZGF0YS5nZXQoJ21vdmllcycpLmlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5cyAmJiB0aGlzLmtleXMubGVuZ3RoPjIgXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5mcm9tWzBdICYmIHRoaXMuZnJvbVswXS5hY3RvcnNcbiAgICAgICAgICB9LCB0cnVlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYoY2FsbGVyLl9ub2RlKSB7XG4gICAgICAgICAgICAgIGZvcihlbGVtJCBpbiBsaXN0KSB7XG4gICAgICAgICAgICAgICAgbGlzdFtlbGVtJF0uZGlzcGxheSA9IGxpc3RbZWxlbSRdLmZpbHRlci5sZW5ndGggPiAwIFxuICAgICAgICAgICAgICAgICAgPyAnYmxvY2snIFxuICAgICAgICAgICAgICAgICAgOiAnbm9uZScgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gc2VhcmNoLnRvcFJlc3VsdCggbGlzdCApIFxuICAgICAgICAgICAgICBjYWxsZXIucGFnZS50b3ByZXN1bHQuZGF0YSA9IHJlc3VsdCB8fCBmYWxzZVxuICAgICAgICAgICAgICBjYWxsZXIucGFnZS50b3ByZXN1bHQuZGlzcGxheSA9IHJlc3VsdCA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgICAgICAgICAgY2FsbGVyLnBhZ2Uubm9SZXN1bHRzLmRpc3BsYXkgPSByZXN1bHQgPyAnbm9uZScgOiAnYmxvY2snXG4gICAgICAgICAgICAgIC8vaWYgbm8gcmVzdWx0IHRoZW4gLS0tLVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yKGVsZW0kIGluIGxpc3QpIHtcbiAgICAgICAgICAgIGxpc3RbZWxlbSRdLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FsbGVyLnBhZ2UudG9wcmVzdWx0LmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICBjYWxsZXIucGFnZS5ub1Jlc3VsdHMuZGlzcGxheSA9ICdub25lJyBcbiAgICAgICAgICBjYWxsZXIucGFnZS5yZWNlbnQuZGlzcGxheSA9ICdibG9jaycgIFxuICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoZWxlbSQgaW4gbGlzdCkge1xuICAgICAgICAgIGxpc3RbZWxlbSRdLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgfVxuICAgICAgICBjYWxsZXIucGFnZS50b3ByZXN1bHQuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICBjYWxsZXIucGFnZS5ub1Jlc3VsdHMuZGlzcGxheSA9ICdub25lJyBcbiAgICAgICAgY2FsbGVyLnBhZ2UucmVjZW50LmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICB9XG4gICAgICB1cGRhdGUoKVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTUsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cblxucmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3NoYXJlZC9pY29uJylcbnZhciBNZW51ID0gcmVxdWlyZSgnLi4vbWVudScpXG52YXIgRGlzY292ZXJcbnZhciBTZWFyY2hcbnZhciBDaGFubmVsXG52YXIgRXBpc29kZVxudmFyIE1vdmllXG52YXIgY2FzZXMgPSBhcHAuY2FzZXNcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IFN3aXRjaGVyKHtcbiAgY3NzOiAnZmlyc3Qtc3dpdGNoZXInLFxuICAnZXh0ZW5kLm5hdmlnYXRpb24nOiBmdW5jdGlvbigpIHt9LFxuICBvblRyYW5zaXRpb246ICdzbGlkZScsXG4gIGxvYWRlcjogbmV3IEVsZW1lbnQoe1xuICAgIGNzczogJ2ZpcnN0LWxvYWRlcicsXG4gICAgeDoge1xuICAgICAgdHJhbnNsYXRlOiB0cnVlXG4gICAgfSxcbiAgICBsb2FkaWNvbjogbmV3IEljb24oe1xuICAgICAgaWNvbjogJ2Vycm9yJ1xuICAgIH0pXG4gIH0pLFxuICBuYXZpZ2F0aW9uOiB7XG4gICAgZGVmZXI6IGZ1bmN0aW9uKHVwZGF0ZSwgYXJncykge1xuICAgICAgdmFyIG5hdiA9IHRoaXMuZnJvbVxuXG4gICAgICBpZiAoIW5hdiB8fCAhbmF2Lmxhc3QgfHwgIW5hdi5sYXN0LmZyb20ua2V5KSByZXR1cm4gdHJ1ZVxuXG4gICAgICB2YXIgZmllbGQgPSBuYXYubGFzdC5mcm9tLmtleS52YWxcbiAgICAgIHZhciBwYWdlXG4gICAgICB2YXIgZWxlbWVudFxuICAgICAgdmFyIHN3aXRjaGVyID0gdGhpcy5fY2FsbGVyXG4gICAgICB2YXIgcGFyYW1zXG4gICAgICB2YXIgb3B0aW9uc1xuICAgICAgbmF2ID0gbmF2W2ZpZWxkXVxuXG4gICAgICBpZiAoZmllbGQgPT09ICdwYWdlJykge1xuXG4gICAgICAgIHZhciBwYWdlID0gbmF2LnZhbFxuXG4gICAgICAgIGlmIChwYWdlID09PSAnZGlzY292ZXInKSB7XG4gICAgICAgICAgZWxlbWVudCA9IERpc2NvdmVyID0gRGlzY292ZXIgfHwgcmVxdWlyZSgnLi4vZGlzY292ZXInKVxuICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICRmb2N1czogYXBwLnVzZXIuZm9jdXNfcm93LFxuICAgICAgICAgICAgZGF0YTogYXBwLmNvbnRlbnQuZ2V0KCdkaXNjb3ZlcicpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHBhZ2UgPT09ICdzZWFyY2gnKSB7XG4gICAgICAgICAgZWxlbWVudCA9IFNlYXJjaCA9IFNlYXJjaCB8fCByZXF1aXJlKCcuLi9zZWFyY2gnKVxuICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGRhdGE6IGFwcC5jbG91ZC5kYXRhLFxuICAgICAgICAgICAgc2VhcmNoOiBhcHAudXNlci5zZWFyY2gsXG4gICAgICAgICAgICBwYWdlOiB7XG4gICAgICAgICAgICAgIHJlY2VudDoge1xuICAgICAgICAgICAgICAgIGRhdGE6IGFwcC51c2VyLnJlY2VudFNlYXJjaGVzLmZyb21cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKGZpZWxkID09PSAnY29udGVudCcpIHtcbiAgICAgICAgaWYgKCFzd2l0Y2hlci5fc3dFbGVtIHx8IHN3aXRjaGVyLl9zd0VsZW0uZGF0YSAhPT0gbmF2LmZyb20pIHtcblxuICAgICAgICAgIHZhciB0eXBlID0gbmF2Ll9jb250ZW50VHlwZVxuXG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdtb3ZpZXMnKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gTW92aWUgPSBNb3ZpZSB8fCByZXF1aXJlKCcuLi9tb3ZpZScpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnZXBpc29kZXMnKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gRXBpc29kZSA9IEVwaXNvZGUgfHwgcmVxdWlyZSgnLi4vZXBpc29kZScpXG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2hhbm5lbHMnKSB7XG4gICAgICAgICAgICBlbGVtZW50ID0gQ2hhbm5lbCA9IENoYW5uZWwgfHwgcmVxdWlyZSgnLi4vY2hhbm5lbCcpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgIGRhdGE6IG5hdi5mcm9tLFxuICAgICAgICAgICAgaG9sZGVyOiB7XG4gICAgICAgICAgICAgIHBsYXllcjoge1xuICAgICAgICAgICAgICAgIHBsYXlpbmc6IGFwcC5pc1BsYXlpbmcsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZXI6IGFwcC51c2VyLnJlY2VpdmVyXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHJlY2VpdmVyTWVkaWE6IGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgc3dpdGNoZXIudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OiBlbGVtZW50LFxuICAgICAgICAgICRwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICBkaXJlY3Rpb246IGFwcC5tZW51LnZhbCA/IDAgOiBmaWVsZCA9PT0gJ2NvbnRlbnQnID8gMSA6IC0xLFxuICAgICAgICAgICRvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB1cGRhdGUoKVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIHVzZXIgPSBhcHAudXNlclxudmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi9zaGFyZWQvaWNvbicpXG52YXIgVGl0bGUgPSByZXF1aXJlKCcuLi8uLi9zaGFyZWQvdGl0bGUnKVxudmFyIElucHV0ID0gcmVxdWlyZSgnLi9pbnB1dCcpXG5cbnZhciBzZWFyY2hGaWVsZCA9IG5ldyBJbnB1dCh7XG4gIGV2ZW50czoge1xuICAgIGZvY3Vzb3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAvLyB2YXIgb3ZlcmxheSA9IHRoaXMucGFyZW50LnBhcmVudC5vdmVybGF5XG4gICAgICAvLyBvdmVybGF5LmRpc3BsYXkgPSAnbm9uZSdcbiAgICB9LFxuICAgIGZvY3VzOmZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIHRoaXMucGFyZW50LnBhcmVudC5vdmVybGF5LnNldCh7XG4gICAgICAvLyAgIGRpc3BsYXk6J2Jsb2NrJ1xuICAgICAgLy8gfSlcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcblx0Y3NzOid0b3BiYXInLFxuXHRleHRlbmQ6e1xuXHRcdCRjdXJyZW50OmZ1bmN0aW9uKHZhbCl7XG5cdFx0XHR2YXIgY3VycmVudCA9IHZhbC52YWxcblx0XHRcdGlmKGN1cnJlbnQgPT09ICdzZWFyY2gnKXtcblx0XHRcdFx0aWYoIXRoaXMuc2VhcmNoKXtcblx0XHRcdFx0XHR0aGlzLnNldCh7XG5cdFx0XHRcdFx0XHRjc3M6J3RvcGJhciBzZWFyY2hpbmcnLFxuXHRcdFx0XHRcdFx0YWRkOltcblx0XHRcdFx0XHRcdFx0bmV3IHNlYXJjaEZpZWxkKHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lOiAnc2VhcmNoJyxcblx0XHRcdFx0XHRcdFx0XHRkYXRhOmFwcC51c2VyLnNlYXJjaFxuXHRcdFx0XHRcdFx0XHR9KSxcblx0XHRcdFx0XHRcdFx0J21pZGRsZSdcblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9ZWxzZSBpZih0aGlzLnNlYXJjaCl7XG5cdFx0XHRcdHRoaXMuc2VhcmNoLnJlbW92ZSgpXG5cdFx0XHRcdHRoaXMuY3NzID0gJ3RvcGJhcidcblx0XHRcdH1cblxuXHRcdFx0aWYoIGN1cnJlbnQgPT09ICdjb250ZW50JyApe1xuXHRcdFx0XHR0aGlzLm1pZGRsZS5kYXRhID0gdXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuZnJvbVxuXHRcdFx0fWVsc2UgaWYoIGN1cnJlbnQgPT09ICdkaXNjb3ZlcicgKXtcblx0XHRcdFx0dGhpcy5taWRkbGUuZGF0YSA9IHsgdGl0bGU6Y3VycmVudCB9XG5cdFx0XHR9XG5cblx0XHR9XG5cdH0sXG5cdGxlZnQ6IG5ldyBJY29uKHsgXG5cdFx0aWNvbjp7XG5cdFx0XHR2YWw6YXBwLmN1cnJlbnQsXG5cdFx0XHR0cmFuc2Zvcm06ZnVuY3Rpb24odixjdXJyZW50KXtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnQgPT09ICdjb250ZW50JyA/ICdiYWNrJyA6ICdtZW51J1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZXZlbnRzOiB7XG5cdFx0XHRkb3duOmZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0ZS5wcmV2ZW50ID0gdHJ1ZVxuXHRcdFx0XHRpZiggdGhpcy5pY29uLnZhbCA9PT0gJ21lbnUnICl7XG5cdFx0XHRcdFx0YXBwLm1lbnUudmFsID0gIWFwcC5tZW51LnZhbFxuXHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHR1c2VyLm5hdmlnYXRpb24ucGFnZS4kdXNlck9yaWdpbiA9IGFwcC5wcmV2aW91cy52YWwgfHwgJ2Rpc2NvdmVyJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBcblx0fSksXG5cdG1pZGRsZTpuZXcgVGl0bGUuU2hvdygpLFxuXHRyaWdodDogbmV3IEljb24oe1xuXHRcdGljb246J2Nhc3QnLFxuXHRcdCdldmVudHMuY2xpY2snOmZ1bmN0aW9uKCkge1xuXHRcdFx0YXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gJ2RldmljZXMnXG5cdFx0fVxuXHR9KVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLkNsYXNzXG5cbiIsInJlcXVpcmUoJy4vcmVzZXQubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG52YXIgZXZlbnRzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzJylcbnZhciBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwLycpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBub2RlOiAnZm9ybScsXG4gIG5hbWU6ICdzZWFyY2gnLFxuICBjc3M6ICdzZWFyY2gtZmllbGQnLFxuICBtb2RlbDoge1xuICAgIGluaGVyaXQ6IGZhbHNlLFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudGFibGUuY2xlYXIuZGlzcGxheSA9IHRoaXMuZGF0YS52YWwgPyAndGFibGUtY2VsbCcgOiAnbm9uZSdcbiAgICB9XG4gIH0sXG4gIHRhYmxlOiB7XG4gICAgbGVmdGljb246IG5ldyBJY29uKHtcbiAgICAgIGljb246ICdzZWFyY2gnXG4gICAgfSksXG4gICAgaW5wdXRGaWVsZDoge1xuICAgICAgbm9kZTogJ2lucHV0JyxcbiAgICAgIGF0dHI6IHtcbiAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICBuYW1lOiAnc2VhcmNoJyxcbiAgICAgICAgcGxhY2Vob2xkZXI6ICdTZWFyY2gnXG4gICAgICB9LFxuICAgICAgdGV4dDoge1xuICAgICAgICBkYXRhOiB0cnVlXG4gICAgICB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGtleWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgfSxcbiAgICAgICAga2V5dXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBpZiAoZS5rZXlDb2RlICE9PSA5KSB7XG4gICAgICAgICAgICB2YXIgc3JjaCA9IHRoaXMubm9kZS52YWx1ZS5sZW5ndGggPyB0aGlzLm5vZGUudmFsdWUudHJpbSgpIDogJydcbiAgICAgICAgICAgIHRoaXMuZGF0YS4kdXNlck9yaWdpbiA9IHNyY2hcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFyOiBuZXcgSWNvbih7XG4gICAgICBpY29uOiAnY2xvc2VTbWFsbCcsXG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGUucHJldmVudCA9IHRydWVcbiAgICAgICAgICB0aGlzLnBhcmVudC5mcm9tRG93biA9IHRydWVcbiAgICAgICAgICAgIC8vVE9ETzogZmlndXJlIG91dCB3aHkgdGhpcy5wYXJlbnQgZG9lcyBub3QgaGF2ZSBkYXRhIGJvdW5kIHRvIGl0IVxuICAgICAgICAgIHRoaXMucGFyZW50LmlucHV0RmllbGQuZGF0YS4kdXNlck9yaWdpbiA9ICcnXG4gICAgICAgICAgICAvLyBmb2N1c291dC5jYWxsKHRoaXMucGFyZW50LnBhcmVudCxlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgZXZlbnRzOiB7XG4gICAgZm9jdXNpbjogZm9jdXNcbiAgfVxufSkuQ2xhc3NcblxuZnVuY3Rpb24gZm9jdXMoZSkge1xuICBjb25zb2xlLmxvZygnd3RmIHd0ZiB3dGYnLCB0aGlzLnBhcmVudClcbiAgaWYgKHRoaXMuZXZlbnRzLmZvY3VzKSB7XG4gICAgdGhpcy5ldmVudHMuZm9jdXMuX3ZhbC5jYWxsKHRoaXMsIGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZm9jdXNvdXQoZSkge1xuICBpZiAodGhpcy5ldmVudHMuZm9jdXNvdXQpIHtcbiAgICB0aGlzLmV2ZW50cy5mb2N1c291dC5fdmFsLmNhbGwodGhpcywgZSlcbiAgfVxufVxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczonc2Vjb25kLWJpbycsXG4gICdleHRlbmQuJGZvY3VzJzpmdW5jdGlvbih2YWwpe1xuICAgIHZhciBpbmRleCA9IHZhbC52YWxcbiAgICBpZihpbmRleCAhPT0gdGhpcy5faW5kZXgpe1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFcbiAgICAgIGlmKGRhdGEpe1xuICAgICAgICB0aGlzLnN3aXRjaGVyLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgZWxlbWVudDpJbWcsXG4gICAgICAgICAgJHBhcmFtczp7XG4gICAgICAgICAgICBvcGFjaXR5OjAsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kOmRhdGEuZnJvbS5nZXQoWydpbWcnLCdjb3ZlcicsaW5kZXggfHwgMF0sJycpXG4gICAgICAgICAgfSxcbiAgICAgICAgICAkb3B0aW9uczp7XG4gICAgICAgICAgICBmb3JjZTp0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luZGV4ID0gaW5kZXhcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICRmb2N1czp7XG4gICAgZGF0YTonZm9jdXMnXG4gIH0sXG4gIHN3aXRjaGVyOm5ldyBTd2l0Y2hlcih7XG4gICAgb25UcmFuc2l0aW9uOidmYWRlJyxcbiAgICAvLyBhZGQ6bmV3IEltZyh7XG4gICAgLy8gICAnYmFja2dyb3VuZC5kYXRhJzonaW1nLmNvdmVyLjAnXG4gICAgLy8gfSksXG4gIH0pLC8vd2lsbCBzd2l0Y2ggYmV0d2VlbiBpbWFnZXNcbiAgb3ZlcmxheTp7XG4gICAgJ2hlYWRlci50ZXh0LmRhdGEnOid0aXRsZScsXG4gICAgYmlvOntcbiAgICAgICdoZWFkZXIudGV4dCc6J0JpbycsXG4gICAgICAnYm9keS50ZXh0LmRhdGEnOidiaW8nXG4gICAgfVxuICB9LFxuICBtb2RlbDp7XG4gICAgc3Vic2NyaXB0aW9uOntcbiAgICAgIGltZzp7XG4gICAgICAgIGNvdmVyOntcbiAgICAgICAgICAkOnRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBXaWRnZXQgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9pbmFjdGl2ZS93aWRnZXQnKVxudmFyIENvbnRlbnQgPSByZXF1aXJlKCcuLi9jb250ZW50JylcbnZhciBUcmFpbGVyID0gcmVxdWlyZSgnLi4vdHJhaWxlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBDb250ZW50KHtcbiAgY3NzOiAnc2Vjb25kLWNoYW5uZWwnLFxuICBjb250YWluZXI6IHtcbiAgICBsZWZ0OiB7XG4gICAgICB0cmFpbGVyOiBuZXcgVHJhaWxlcih7XG4gICAgICAgICd2aWRlby5zcmMuZGF0YSc6J3ZpZGVvJ1xuICAgICAgfSlcbiAgICB9LFxuICAgIG1pZGRsZTp7XG4gICAgICBndWlkZTogbmV3IFdpZGdldC5HdWlkZSgpXG4gICAgfSxcbiAgICByaWdodDogbmV3IFN3aXRjaGVyKHtcbiAgICAgIG9uVHJhbnNpdGlvbjogZnVuY3Rpb24oY3VycmVudCwgbGFzdCkge1xuICAgICAgICBpZihsYXN0KSBsYXN0LnJlbW92ZSgpXG4gICAgICAgIHRoaXMuYWRkKGN1cnJlbnQpXG4gICAgICB9LFxuICAgICAgbW9kZWw6e1xuICAgICAgICBzdWJzY3JpcHRpb246e1xuICAgICAgICAgIGd1aWRlOntcbiAgICAgICAgICAgIDA6e1xuICAgICAgICAgICAgICBzdGF0aXN0aWNzOntcbiAgICAgICAgICAgICAgICB0aXRsZTp0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbDpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICB2YXIgd2lkZ2V0RGF0YSA9IGRhdGEuZ3VpZGUgJiYgZGF0YS5ndWlkZVswXVxuICAgICAgICAgIGlmKHdpZGdldERhdGEpe1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uID0ge1xuICAgICAgICAgICAgICBlbGVtZW50OiB3aWRnZXREYXRhLnN0YXRpc3RpY3MgPyBXaWRnZXQuU3RhdHMgOiBXaWRnZXQuQWJvdXQsXG4gICAgICAgICAgICAgICRwYXJhbXM6eyBkYXRhOmRhdGEgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gICdleHRlbmQuJGNvbXBsZXRlJzpmdW5jdGlvbih2YWwpe1xuICAgIHZhciBjb21wbGV0ZSA9IHZhbC52YWxcbiAgICBpZihjb21wbGV0ZSA9PT0gdHJ1ZSl7XG4gICAgICB0aGlzLnNldCh7XG4gICAgICAgIGNzczp7cmVtb3ZlQ2xhc3M6J3ByZXZpZXcnfSxcbiAgICAgICAgY29udGFpbmVyOntcbiAgICAgICAgICBsZWZ0OntcbiAgICAgICAgICAgIHR3aXR0ZXI6IG5ldyBXaWRnZXQuVHdpdHRlcih7XG4gICAgICAgICAgICAgIGRhdGE6dGhpcy5kYXRhXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9ZWxzZSBpZihjb21wbGV0ZSA9PT0gZmFsc2Upe1xuICAgICAgdGhpcy5jc3MgPSB7YWRkQ2xhc3M6J3ByZXZpZXcnfVxuICAgIH1cbiAgfVxufSkuQ2xhc3MiLCJ2YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgQ292ZXIgPSByZXF1aXJlKCcuLi9jb3ZlcicpXG52YXIgQ2hhbm5lbFxudmFyIFZvZFxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNvdmVyOiBuZXcgQ292ZXIoKSxcbiAgJ2V4dGVuZC4kYWN0aXZlJzogZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIGFjdGl2ZSA9IHZhbC52YWxcbiAgICBpZiAoYWN0aXZlICE9PSB2b2lkIDApIHtcbiAgICAgIHZhciBiZyA9IHRoaXMuY292ZXIuYmdcbiAgICAgIHZhciBpbmZvID0gdGhpcy5pbmZvXG4gICAgICBpZiAoYWN0aXZlKSB7XG4gICAgICAgIGlmIChiZy5fbG9hZGVkKSBiZy5vcGFjaXR5ID0gZmFsc2VcbiAgICAgICAgYmcuJHdhaXQgPSBmYWxzZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmcuJHdhaXQgPSB0cnVlXG4gICAgICAgIGJnLm9wYWNpdHkgPSAwXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAkYWN0aXZlOiB0cnVlXG59KS5DbGFzc1xuXG5leHBvcnRzLnNlbGVjdCA9IGZ1bmN0aW9uKGRhdGEsIHR5cGUpIHtcbiAgaWYgKCF0eXBlKSB0eXBlID0gZGF0YS5fY29udGVudFR5cGVcblxuICByZXR1cm4gdHlwZSA9PT0gJ2NoYW5uZWxzJyA/IHtcbiAgICBlbGVtZW50OiBDaGFubmVsID0gQ2hhbm5lbCB8fCByZXF1aXJlKCcuLi9jaGFubmVsJyksXG4gICAgJHBhcmFtczoge31cbiAgfSA6IHtcbiAgICBlbGVtZW50OiBWb2QgPSBWb2QgfHwgcmVxdWlyZSgnLi4vdm9kJyksXG4gICAgJHBhcmFtczoge1xuICAgICAgJHBvcHVwOiBhcHAucG9wdXBcbiAgICB9XG4gIH1cbn1cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOidzZWNvbmQtY292ZXInLFxuICBiZzpuZXcgSW1nKHtcbiAgICBvcGFjaXR5OjAsXG4gICAgJHdhaXQ6dHJ1ZSxcbiAgICBiYWNrZ3JvdW5kOntcbiAgICAgIGRhdGE6J2ltZy5jb3Zlci4wJyxcbiAgICAgIGFkZDp7XG4gICAgICAgIGRhdGE6J3Nob3cuaW1nLmNvdmVyLjAnXG4gICAgICB9XG4gICAgfVxuICB9KSxcbiAgb3ZlcmxheTp7fVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBwb3N0cG9uZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy91dGlsJykucG9zdHBvbmVcbnZhciBDb250ZW50ID0gcmVxdWlyZSgnLi4vY29udGVudCcpXG5cbnZhciBfcHJldmlldyA9IHBvc3Rwb25lKGZ1bmN0aW9uKHN3aXRjaGVyLGZvY3VzSW5kZXgpIHsgLy9tb3ZlIHRoaXMgdG8gYXBwIGNvbnRyb2wgc3R1ZmZcbiAgaWYoZm9jdXNJbmRleCAhPT0gdm9pZCAwKXtcbiAgICB2YXIgY2xvdWRkYXRhID0gYXBwLmNsb3VkLmRhdGFcbiAgICB2YXIgZm9jdXNyb3cgPSBhcHAudXNlci5mb2N1c19yb3cudmFsXG4gICAgdmFyIGRhdGEgPSBjbG91ZGRhdGEuZ2V0KFsnZGlzY292ZXInLGZvY3Vzcm93LCdpdGVtcycsZm9jdXNJbmRleF0pXG4gICAgYXBwLnByZXZpZXcudmFsID0gZGF0YVxuICAgIGlmKHN3aXRjaGVyLl9zd0VsZW0pIHN3aXRjaGVyLl9zd0VsZW0uJGFjdGl2ZS52YWwgPSB0cnVlXG4gIH1cbn0sNDAwKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTd2l0Y2hlcih7XG4gIGNzczogJ3NlY29uZC1kaXNjb3ZlcicsXG4gIGV4dGVuZDp7XG4gICAgJGhpZ2hsaWdodDpmdW5jdGlvbih2YWwpe1xuICAgICAgdmFyIGluZGV4ID0gdmFsLnZhbFxuICAgICAgdmFyIGxhc3QgPSB0aGlzLmxhc3RcbiAgICAgIGlmKGluZGV4ICE9PSBmYWxzZSl7XG4gICAgICAgIGlmKCF0aGlzLmZyb21Db250ZW50KXtcbiAgICAgICAgICBpZih0aGlzLl9zd0VsZW0pIHRoaXMuX3N3RWxlbS4kYWN0aXZlID0gZmFsc2VcbiAgICAgICAgICBfcHJldmlldyh0aGlzLGluZGV4KVxuICAgICAgICAgIHRoaXMubGFzdCA9IHZvaWQgMFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0aGlzLmZyb21Db250ZW50ID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJHByZXZpZXc6ZnVuY3Rpb24odmFsKXtcbiAgICAgIHZhbCA9IHZhbC52YWxcbiAgICAgIGlmKHZhbCl7XG4gICAgICAgIHZhciBkYXRhID0gdmFsLmZyb21cbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBDb250ZW50LnNlbGVjdChkYXRhKVxuICAgICAgICB0cmFuc2l0aW9uLiRwYXJhbXMuZGF0YSA9IGRhdGFcbiAgICAgICAgdHJhbnNpdGlvbi4kcGFyYW1zLiRjb21wbGV0ZSA9IGZhbHNlXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25cbiAgICAgIH1cbiAgICB9LFxuICAgICRjb250ZW50OmZ1bmN0aW9uKHZhbCl7XG4gICAgICB2YWwgPSB2YWwudmFsXG4gICAgICBpZih2YWwpe1xuICAgICAgICB2YXIgZGF0YSA9IHZhbC5mcm9tXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gQ29udGVudC5zZWxlY3QoZGF0YSlcbiAgICAgICAgdHJhbnNpdGlvbi4kcGFyYW1zLmRhdGEgPSBkYXRhXG4gICAgICAgIHRyYW5zaXRpb24uJHBhcmFtcy4kY29tcGxldGUgPSB0cnVlXG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25cbiAgICAgICAgdGhpcy5mcm9tQ29udGVudCA9IHRydWVcbiAgICAgICAgYXBwLnByZXZpZXcudmFsID0gZGF0YVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgb25UcmFuc2l0aW9uOidmYWRlJ1xufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbiAgLCBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbiAgLCBEaXNjb3ZlciA9IHJlcXVpcmUoJy4vZGlzY292ZXInKVxuICAsIFNlYXJjaCA9IHJlcXVpcmUoJy4vc2VhcmNoJylcbiAgLCBTdGF0dXNiYXIgPSByZXF1aXJlKCcuL3N0YXR1c2JhcicpXG4gICwgYXBwID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2FwcCcpXG4gICwgTmF2aWdhdGlvbiA9IHJlcXVpcmUoJy4vbmF2aWdhdGlvbicpXG4gICwgUGxheWVyID0gcmVxdWlyZSgnLi9wbGF5ZXInKVxuICAsIENvbnRlbnQgPSByZXF1aXJlKCcuL2NvbnRlbnQnKVxuXG4vL3NlY29uZHNjcmVlbiB0b3BsZXZlbFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3NlY29uZC1zdGF0ZScsXG4gIHk6e3RyYW5zbGF0ZTp0cnVlLHZhbDowfSxcbiAgc3dpdGNoZXI6bmV3IFN3aXRjaGVyKHsgLy8gc3dpdGNoZXMgYmV0d2VlbiBtYWluIGFuZCBzZWFyY2hcbiAgICBvblRyYW5zaXRpb246J2ZhZGUnXG4gIH0pLFxuICBuYXZpZ2F0aW9uOm5ldyBOYXZpZ2F0aW9uKCksXG4gIHN0YXR1c2JhcjpuZXcgU3RhdHVzYmFyKCksXG4gIHNlYXJjaDpuZXcgU2VhcmNoKCksXG4gIGV4dGVuZDp7XG4gICAgJGhpZ2hsaWdodDpmdW5jdGlvbiggdmFsICl7fSxcbiAgICAkcHJldmlldzpmdW5jdGlvbiggdmFsICl7fSxcbiAgICAkcGFnZTpmdW5jdGlvbiggdmFsLCBzdGFtcCApe1xuXG5cbiAgICAgIGlmKHRoaXMuJG1lZGlhLnZhbCB8fCAhc3RhbXApIHJldHVyblxuICAgICAgdmFyIHBhZ2UgPSB2YWwudmFsXG5cbiAgICAgIGFwcC51c2VyLnRyYWlsZXJNdXRlZC4kdXNlck9yaWdpbiA9IHRydWVcbiAgICAgIGFwcC5oaWRlU3RhdHVzYmFyLnZhbCA9IGZhbHNlXG4gICAgICBcbiAgICAgIGlmKCBwYWdlID09PSAnZGlzY292ZXInICl7XG4gICAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgICB5OjAsXG4gICAgICAgICAgc3dpdGNoZXI6e1xuICAgICAgICAgICAgdHJhbnNpdGlvbjp7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6RGlzY292ZXIsXG4gICAgICAgICAgICAgICRwYXJhbXM6e1xuICAgICAgICAgICAgICAgICRwcmV2aWV3OnRoaXMuJHByZXZpZXcuX3ZhbCxcbiAgICAgICAgICAgICAgICAkaGlnaGxpZ2h0OnRoaXMuJGhpZ2hsaWdodC5fdmFsLFxuICAgICAgICAgICAgICAgICRjb250ZW50OmZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdmlnYXRpb246e1xuICAgICAgICAgICAgY29udGFpbmVyOntcbiAgICAgICAgICAgICAgeTowXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfWVsc2UgaWYocGFnZSA9PT0gJ3NlYXJjaCcpe1xuICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgeTogLWFwcC5oLnZhbCArIDgwLFxuICAgICAgICAgIHNlYXJjaDp7XG4gICAgICAgICAgICAkc2VhcmNoOmFwcC51c2VyLnNlYXJjaCxcbiAgICAgICAgICAgICRtdXRlZDphcHAudXNlci50cmFpbGVyTXV0ZWQsXG4gICAgICAgICAgICBkYXRhOmFwcC5jbG91ZC5kYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgfSxcbiAgICAkY29udGVudDpmdW5jdGlvbiggdmFsLHN0YW1wICl7XG5cbiAgICAgIC8vIGlmKHRoaXMuJG1lZGlhLnZhbCB8fCAhc3RhbXApIHJldHVyblxuICAgICAgLy8gdmFyIGRhdGEgPSB2YWwuZnJvbVxuICAgICAgaWYodGhpcy4kbWVkaWEudmFsIHx8ICFzdGFtcCkgcmV0dXJuXG5cbiAgICAgIGFwcC5oaWRlU3RhdHVzYmFyLnZhbCA9IGZhbHNlXG5cbiAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgeTowLFxuICAgICAgICBzd2l0Y2hlcjp7XG4gICAgICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICAgICAgZWxlbWVudDpEaXNjb3ZlcixcbiAgICAgICAgICAgICRwYXJhbXM6e1xuICAgICAgICAgICAgICAkcHJldmlldzpmYWxzZSxcbiAgICAgICAgICAgICAgJGhpZ2hsaWdodDpmYWxzZSxcbiAgICAgICAgICAgICAgJGNvbnRlbnQ6dmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBuYXZpZ2F0aW9uOntcbiAgICAgICAgICBjb250YWluZXI6e1xuICAgICAgICAgICAgeTo0MjBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICAkbWVkaWE6ZnVuY3Rpb24oIHZhbCwgc3RhbXAgKXtcbiAgICAgIGlmKHZhbC52YWwpe1xuICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgeTowLFxuICAgICAgICAgIHN3aXRjaGVyOntcbiAgICAgICAgICAgIHRyYW5zaXRpb246e1xuICAgICAgICAgICAgICBlbGVtZW50OlBsYXllcixcbiAgICAgICAgICAgICAgJHBhcmFtczp7XG4gICAgICAgICAgICAgICAgb3ZlcmxheTp7XG4gICAgICAgICAgICAgICAgICAkdm9sdW1lOmFwcC52b2x1bWUsXG4gICAgICAgICAgICAgICAgICAkdGltZTp2YWwudmFsLmdldCgndGltZScpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwbGF5aW5nOmFwcC5pc1BsYXlpbmcsXG4gICAgICAgICAgICAgICAgZGF0YTp2YWwuJHVzZXJPcmlnaW4sXG4gICAgICAgICAgICAgICAgdmlkZW86IHtcbiAgICAgICAgICAgICAgICAgIHZvbHVtZTogYXBwLnZvbHVtZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF2aWdhdGlvbjp7XG4gICAgICAgICAgICBjb250YWluZXI6e1xuICAgICAgICAgICAgICB5OjQ2MCArIDgwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfWVsc2V7XG4gICAgICAgIGFwcC51c2VyLnVwZGF0ZU5hdmlnYXRpb24oKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0U2V0dGluZzp7XG4gICAgbmFtZTondXBkYXRlTmF2JyxcbiAgICBwYXJlbnQ6ZnVuY3Rpb24oKXtcbiAgICAgIGFwcC51c2VyLnVwZGF0ZU5hdmlnYXRpb24oKVxuICAgIH1cbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgYXBwID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgTGlzdCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0JylcbnZhciBwb3N0cG9uZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy91dGlsJykucG9zdHBvbmVcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG52YXIgUHJvZ3Jlc3MgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9pbmFjdGl2ZS9wcm9ncmVzcycpXG5cbnZhciB5RWxlbWVudCA9IG5ldyBFbGVtZW50KHtcbiAgeToge1xuICAgIHRyYW5zbGF0ZTogdHJ1ZSxcbiAgICB2YWw6NDIwXG4gIH1cbn0pLkNsYXNzXG5cbnZhciB0aXRsZUVsZW1lbnQgPSBuZXcgeUVsZW1lbnQoe1xuICAndGV4dC5kYXRhJzogJ3RpdGxlJ1xufSkuQ2xhc3NcblxudmFyIG1hcCA9IHtcbiAgc3BvdGxpZ2h0OiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGlzdDogTGlzdC5XYXRjaGluZ1xuICB9LFxuICBjaGFubmVsczoge1xuICAgIGluZGV4OiAxLFxuICAgIGxpc3Q6IExpc3QuQ2hhbm5lbFxuICB9LFxuICB3YXRjaGluZzoge1xuICAgIGluZGV4OiAyLFxuICAgIGxpc3Q6IExpc3QuV2F0Y2hpbmdcbiAgfSxcbiAgcmVsZWFzZXM6IHtcbiAgICBpbmRleDogMyxcbiAgICBsaXN0OiBMaXN0LlBvc3RlclxuICB9LFxuICByZWNvbW1lbmRlZDoge1xuICAgIGluZGV4OiA0LFxuICAgIGxpc3Q6IExpc3QuUG9zdGVyXG4gIH1cbn1cblxudmFyIHN3aXRjaEZvY3VzID0gZnVuY3Rpb24oX3RoaXMsIGluZGV4LCBmb2N1c2VkLCB0eXBlKSB7XG4gIHZhciBkaXJlY3Rpb24gPSBpbmRleCA+IF90aGlzLmluZGV4ID8gLTEgOiAxXG4gICAgLy9zd2l0Y2ggdGhlIHRpdGxlXG5cbiAgX3RoaXMuY29udGFpbmVyLnNldCh7XG4gICAgYmFyOiB7XG4gICAgICB0aXRsZToge1xuICAgICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgICAgZWxlbWVudDogdGl0bGVFbGVtZW50LFxuICAgICAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgICAgICRwYXJhbXM6IHtcbiAgICAgICAgICAgIGRhdGE6IGZvY3VzZWRcbiAgICAgICAgICB9LFxuICAgICAgICAgICRvcHRpb25zOiB7XG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFycm93czoge1xuICAgICAgICB1cDoge1xuICAgICAgICAgIG9wYWNpdHk6aW5kZXggPT09IDAgPyAwLjUgOiAxXG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IHtcbiAgICAgICAgICBvcGFjaXR5OmluZGV4ID09PSA0ID8gMC41IDogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIF90aGlzLmluZGV4ID0gaW5kZXhcblxuICBsaXN0Rm9jdXMoX3RoaXMsIGluZGV4LCBmb2N1c2VkLCB0eXBlLCBkaXJlY3Rpb24pXG59XG5cbnZhciBsaXN0Rm9jdXMgPSBwb3N0cG9uZShmdW5jdGlvbihfdGhpcywgaW5kZXgsIGZvY3VzZWQsIHR5cGUsIGRpcmVjdGlvbikge1xuICB2YXIgbGlzdHMgPSBfdGhpcy5jb250YWluZXIubGlzdHNcbiAgdmFyIGZvY3VzSXRlbSA9IGFwcC51c2VyWydmb2N1c18nICsgdHlwZV1cblxuICBpZihsaXN0cyl7XG4gICAgbGlzdHMudHJhbnNpdGlvbiA9IHtcbiAgICAgIGVsZW1lbnQ6IG1hcFt0eXBlXS5saXN0LFxuICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAkcGFyYW1zOiB7XG4gICAgICAgIGRhdGE6IGZvY3VzZWQsXG4gICAgICAgICRmb2N1czogYXBwLmhpZ2hsaWdodC52YWwgPSBmb2N1c0l0ZW1cbiAgICAgIH0sXG4gICAgICAkb3B0aW9uczoge1xuICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufSwgMjAwKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnc2Vjb25kLW5hdmlnYXRpb24nLFxuICBjb250YWluZXI6IG5ldyB5RWxlbWVudCh7XG4gICAgcHJvZ3Jlc3M6IG5ldyBQcm9ncmVzcyh7XG4gICAgICBwZXJjZW50YWdlOntcbiAgICAgICAgdGV4dDp7XG4gICAgICAgICAgdmFsOntcbiAgICAgICAgICAgIHBhcmVudDonb24nLFxuICAgICAgICAgICAgYW5pbWF0aW9uOntcbiAgICAgICAgICAgICAgZWFzaW5nOidvdXRDdWJpYycsXG4gICAgICAgICAgICAgIHRpbWU6MThcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgICAgICAgIHJldHVybiB+fmN2ICsgJyUnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbW9kZWw6e1xuICAgICAgICBjb21wbGV0ZTpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgICB0aGlzLm9uLnVwZGF0ZSh0aGlzKVxuICAgICAgICB9LFxuICAgICAgICBpbmhlcml0OmZhbHNlXG4gICAgICB9LFxuICAgICAgb246e1xuICAgICAgICBkYXRhOid0aW1lJyxcbiAgICAgICAgZGVmZXI6ZnVuY3Rpb24odXBkYXRlKXtcbiAgICAgICAgICBpZih+fnRoaXMuZnJvbS52YWwpe1xuICAgICAgICAgICAgdGhpcy5fY2FsbGVyLm9wYWNpdHkgPSAxXG4gICAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy5fY2FsbGVyLm9wYWNpdHkgPSAwXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbXVsdGlwbHk6MTAwXG4gICAgICB9XG4gICAgfSksXG4gICAgYmFyOiB7XG4gICAgICB0aXRsZTogbmV3IFN3aXRjaGVyKHtcbiAgICAgICAgb25UcmFuc2l0aW9uOiBmdW5jdGlvbihjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgICBfdHJhbnNpdGlvbih0aGlzLCA0MCwgY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGFycm93czoge1xuICAgICAgICB1cDpuZXcgSWNvbih7XG4gICAgICAgICAgaWNvbjondXBOYXYnLFxuICAgICAgICAgIG9wYWNpdHk6MC4xXG4gICAgICAgIH0pLFxuICAgICAgICBkb3duOiBuZXcgSWNvbih7XG4gICAgICAgICAgaWNvbjonZG93bk5hdidcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3RzOiBuZXcgU3dpdGNoZXIoe1xuICAgICAgb25UcmFuc2l0aW9uOiBmdW5jdGlvbihjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgX3RyYW5zaXRpb24odGhpcywgNDAwLCBjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24pXG4gICAgICB9XG4gICAgfSlcbiAgfSksXG4gICdtb2RlbC5zdWJzY3JpcHRpb24uJC4kJzogdHJ1ZSxcbiAgZXh0ZW5kOntcbiAgICAkZm9jdXM6IGZ1bmN0aW9uKHZhbCkgeyAvL3ZhbCA9PT0gJ3Nwb3RsaWdodCcvJ3JlY29tbWVuZGVkJyBldGNcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhXG4gICAgICBpZighZGF0YSkgcmV0dXJuXG4gICAgICBcbiAgICAgIGlmKCFkYXRhLiRsZW5ndGgudmFsKSB7XG4gICAgICAgIGRhdGEuJGxlbmd0aC5vbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIF90aGlzLiRmb2N1cy51cGRhdGUoKVxuICAgICAgICB9KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgdmFyIGZvY3VzZWQgPSBkYXRhW3ZhbC52YWxdXG4gICAgICBpZihmb2N1c2VkKSB7XG4gICAgICAgIHN3aXRjaEZvY3VzKF90aGlzLCBtYXBbdmFsLnZhbF0uaW5kZXgsIGZvY3VzZWQsIHZhbC52YWwpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXRTZXR0aW5nOiB7XG4gICAgbmFtZTogJ3ByZXBWYWx1ZXMnLFxuICAgIHBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICBmb3IodmFyIHR5cGUgaW4gbWFwKSB7XG4gICAgICAgIHZhciBmaWVsZCA9ICdmb2N1c18nICsgdHlwZVxuICAgICAgICBpZighYXBwLnVzZXJbZmllbGRdKSB7XG4gICAgICAgICAgdmFyIG9iaiA9IHt9XG4gICAgICAgICAgb2JqW2ZpZWxkXSA9IDBcbiAgICAgICAgICBhcHAudXNlci5zZXQob2JqKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG5mdW5jdGlvbiBfdHJhbnNpdGlvbihfdGhpcywgZGVsdGEsIGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbikge1xuICBpZihsYXN0KSB7XG4gICAgbGFzdC55ID0gZGVsdGEgKiBkaXJlY3Rpb24gLy8gc2hvdWxkIHN0aWxsIHJlbW92ZVxuICAgIGN1cnJlbnQueSA9IGRlbHRhICogLWRpcmVjdGlvblxuICB9XG4gIF90aGlzLmFkZChjdXJyZW50KVxuICBpZihfdGhpcy5fdGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQoX3RoaXMuX3RpbWVyKVxuICAgIF90aGlzLl90aW1lciA9IG51bGxcbiAgfVxuICBfdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIF90aGlzLl90aW1lciA9IG51bGxcbiAgICBkb2l0KClcbiAgfSwgNTApXG5cbiAgZnVuY3Rpb24gZG9pdCgpe1xuICAgIGlmKCFjdXJyZW50Ll9ibG9ja2VkKSBjdXJyZW50LnkgPSAwXG4gICAgZWxzZSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRvaXQpXG4gIH1cbn1cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxudmFyIFZpZGVvID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlbycpXG52YXIgUHJvZ3Jlc3MgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9pbmFjdGl2ZS9wcm9ncmVzcycpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgcG9zdHBvbmUgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG52YXIgY29uZmlnID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvY29uZmlnJylcbnZhciBTdWJ0aXRsZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3N1YnRpdGxlJylcblxudmFyIGZhZGVJY29uID0gcG9zdHBvbmUoZnVuY3Rpb24oX3RoaXMsIGZvcmNlKSB7XG4gIHZhciBpY29uID0gX3RoaXMuX3N3RWxlbSAmJiBfdGhpcy5fc3dFbGVtLmljb25cbiAgaWYgKGljb24pIHtcbiAgICBpY29uLmNzcyA9ICd1aS1pY29uIGZhZGUtb3V0J1xuICAgIGljb24ub3BhY2l0eSA9IDBcbiAgICBpY29uLnNjYWxlID0gMC41XG4gIH1cbn0sIDc1MClcblxudmFyIGZhZGVPdmVybGF5ID0gcG9zdHBvbmUoZnVuY3Rpb24oX3RoaXMsIGZvcmNlKSB7XG4gIGlmIChhcHAuaXNQbGF5aW5nLnZhbCkgX3RoaXMub3BhY2l0eSA9IDBcblxufSwgMTAwMClcblxudmFyIHVwZGF0ZVBsYXkgPSBwb3N0cG9uZShmdW5jdGlvbihfdGhpcykge1xuICBhcHAuaGlkZVN0YXR1c2Jhci52YWwgPSBmYWxzZVxuICBpZiAoX3RoaXMuJHBsYXlpbmcpIF90aGlzLiRwbGF5aW5nLnVwZGF0ZSgpXG59LCAxMDAwKVxuXG52YXIgT3ZlcmxheSA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAncGxheWVyLW92ZXJsYXknLFxuICBvcGFjaXR5OiAwLFxuICBpY29uOiBuZXcgSWNvbih7XG4gICAgb3BhY2l0eTogMCxcbiAgICBzY2FsZTowLjUsXG4gICAgaWNvbjoge1xuICAgICAgdmFsOiAncGF1c2UnLFxuICAgICAgJGlzUGxheWluZzogJ3BsYXknXG4gICAgfVxuICB9KSxcbiAgaW5mbzoge1xuICAgIHBvc3Rlcjoge1xuICAgICAgaW1nOiBuZXcgSW1nKHtcbiAgICAgICAgYmFja2dyb3VuZDp7XG4gICAgICAgICAgZGF0YTogJ2ltZy5wb3N0ZXInLFxuICAgICAgICAgIGFkZDp7ZGF0YTonc2hvdy5pbWcucG9zdGVyJ30sXG4gICAgICAgICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgICAgICAgY29uc29sZS5sb2coJz4+PicsY3YpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtb2RlbDp7XG4gICAgICAgICAgY29tcGxldGU6ZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuYmFja2dyb3VuZC51cGRhdGUoKVxuICAgICAgICAgICAgdGhpcy5tb2RlbCA9IGZhbHNlIFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHRpdGxlczoge1xuICAgICAgJ25vd3BsYXlpbmcudGV4dCc6ICdOb3cgUGxheWluZycsXG4gICAgICAndGl0bGUudGV4dCc6e1xuICAgICAgICBkYXRhOiAnZ3VpZGUuMC50aXRsZScsXG4gICAgICAgIG9yOntkYXRhOid0aXRsZSd9XG4gICAgICB9LFxuICAgICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKClcbiAgICB9XG4gIH0sXG4gIHJlY29tbWVuZGVkOiB7XG4gICAgJ2hlYWRlci50ZXh0JzogJ1JlY29tbWVuZGVkJyxcbiAgICBvbjp7XG4gICAgICBkYXRhOidyZWNvbW1lbmRhdGlvbnMuMC5pbWcuc3BvdGxpZ2h0JyxcbiAgICAgIGFkZDp7XG4gICAgICAgIGRhdGE6J3Nob3cucmVjb21tZW5kYXRpb25zLjAuaW1nLnNwb3RsaWdodCdcbiAgICAgIH1cbiAgICB9LFxuICAgIHRodW1iOntcbiAgICAgIG9uOntwYXJlbnQ6J29uJ30sXG4gICAgICBpbWc6bmV3IEltZyh7XG4gICAgICAgIGJhY2tncm91bmQ6e1xuICAgICAgICAgIHBhcmVudDonb24nXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICBkaXNwbGF5OntcbiAgICAgIHZhbDonYmxvY2snLFxuICAgICAgd2hlbjp7c2VsZjonb24nfSxcbiAgICAgIG9yOidub25lJ1xuICAgIH0sXG4gICAgbW9kZWw6e1xuICAgICAgY29tcGxldGU6ZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5vbi51cGRhdGUoKVxuICAgICAgICB0aGlzLm1vZGVsID0gZmFsc2UgXG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG52YXIgQmFyT3ZlcmxheSA9IG5ldyBFbGVtZW50KHtcbiAgb3BhY2l0eTowLFxuICBjb250YWluZXI6IHtcbiAgICB0eHQ6IHt9LFxuICAgIHByb2dyZXNzOiBuZXcgUHJvZ3Jlc3Moe1xuICAgICAgZGlzcGxheTpmYWxzZVxuICAgIH0pXG4gIH0sXG4gICdleHRlbmQuJHZhbHVlJzogZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5jb250YWluZXIuc2V0KHsgLy9jaGFuZ2UgdGhpcyBmb3IgZGF0YVxuICAgICAgdHh0OiB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgdGV4dDogdmFsLnZhbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvZ3Jlc3M6IHtcbiAgICAgICAgb246IHZhbC52YWxcbiAgICAgIH1cbiAgICB9KVxuICB9XG59KS5DbGFzc1xuXG52YXIgU2Vla092ZXJsYXkgPSBuZXcgQmFyT3ZlcmxheSh7XG4gIGNzczogJ3NlZWstb3ZlcmxheScsXG4gICdjb250YWluZXIudHh0Jzoge1xuICAgIHRleHQ6ICdTRUVLSU5HICcsXG4gICAgJ3ZhbHVlLnRleHQnOiB7XG4gICAgICBkYXRhOiAndGltZScsXG4gICAgICBtdWx0aXBseToge1xuICAgICAgICBkYXRhOiAnZHVyYXRpb24nXG4gICAgICB9LFxuICAgICAgJGNvbnZlcnRUaW1lOiB0cnVlLCAvL3tkYXRhOidkdXJhdGlvbid9LFxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxudmFyIFZvbHVtZU92ZXJsYXkgPSBuZXcgQmFyT3ZlcmxheSh7XG4gIGNzczogJ3ZvbHVtZS1vdmVybGF5JyxcbiAgJ2NvbnRhaW5lci50eHQnOiB7XG4gICAgdGV4dDogJ1ZPTFVNRSAnLFxuICAgICd2YWx1ZS50ZXh0Jzoge1xuICAgICAgdmFsOiAwLFxuICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih2LCBjdikge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChjdiAqIDEwMCB8fCAwKSArICclJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxudmFyIE92ZXJsYXlTd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcih7XG4gIGV4dGVuZDoge1xuICAgICRwbGF5aW5nOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMub3BhY2l0eSA9IDFcbiAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgZWxlbWVudDogT3ZlcmxheSxcbiAgICAgICAgJHBhcmFtczoge1xuICAgICAgICAgIGRhdGE6IHRoaXMucGFyZW50LmRhdGEsXG4gICAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgY3NzOiAndWktaWNvbiBmYWRlLWluJyxcbiAgICAgICAgICAgIG9wYWNpdHk6ICFleHBvcnRzLmZyb21TcmMgPyAxIDogMCxcbiAgICAgICAgICAgIHNjYWxlOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXBwLmlzUGxheWluZy52YWwpIGZhZGVPdmVybGF5KHRoaXMpXG4gICAgICBmYWRlSWNvbih0aGlzKVxuICAgIH0sXG4gICAgJHRpbWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKGV4cG9ydHMuZnJvbVNyYyB8fCBhcmd1bWVudHNbMl0gPT09IHZvaWQgMCB8fCB2YWwudmFsIDwgMCkgcmV0dXJuXG4gICAgICB0aGlzLm9wYWNpdHkgPSAxXG5cbiAgICAgIGlmKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuX2NvbnRlbnRUeXBlIT09J2NoYW5uZWxzJykge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgZWxlbWVudDogU2Vla092ZXJsYXksXG4gICAgICAgICAgJHBhcmFtczoge1xuICAgICAgICAgICAgJHZhbHVlOiB2YWwudmFsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGFwcC5oaWRlU3RhdHVzYmFyLnZhbCA9IHRydWVcblxuICAgICAgaWYgKGFwcC5pc1BsYXlpbmcudmFsKSB7XG4gICAgICAgIGZhZGVPdmVybGF5KHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVQbGF5KHRoaXMpXG4gICAgICB9XG5cbiAgICB9LFxuICAgICR2b2x1bWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKGFyZ3VtZW50c1syXSA9PT0gdm9pZCAwKSByZXR1cm5cbiAgICAgIHRoaXMub3BhY2l0eSA9IDFcbiAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgZWxlbWVudDogVm9sdW1lT3ZlcmxheSxcbiAgICAgICAgJHBhcmFtczoge1xuICAgICAgICAgICR2YWx1ZTogdmFsLnZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHAuaGlkZVN0YXR1c2Jhci52YWwgPSB0cnVlXG4gICAgICBpZiAoYXBwLmlzUGxheWluZy52YWwpIGZhZGVPdmVybGF5KHRoaXMpXG4gICAgICBlbHNlIHVwZGF0ZVBsYXkodGhpcylcbiAgICB9XG4gIH0sXG4gIG9uVHJhbnNpdGlvbjogZnVuY3Rpb24oY3VycmVudCwgbGFzdCkge1xuICAgIGlmIChsYXN0KSBsYXN0LnJlbW92ZSgpXG4gICAgY3VycmVudC4kdGltZW91dCA9IHtcbiAgICAgIDUwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZChjdXJyZW50KVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnc2Vjb25kLXBsYXllcicsXG4gIHZpZGVvOiBuZXcgVmlkZW8oe1xuICAgIHBsYXllcjogcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlby9odG1sNScpLFxuICAgIGR1cmF0aW9uOiB7XG4gICAgICBkYXRhOiAnZHVyYXRpb24nXG4gICAgfSxcbiAgICB0aW1lOiB7XG4gICAgICBkYXRhOiAndGltZSdcbiAgICB9LFxuICAgIHNyYzoge1xuICAgICAgcHJlcGVuZDogY29uZmlnLnBvaW50ZXJzLmFzc2V0cyxcbiAgICAgIGRhdGE6ICd2aWRlbydcbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy5kYXRhLmZyb20uc2V0KCd0aW1lJywgLU1hdGguYWJzKHApKVxuICAgICAgfSxcbiAgICAgIHNyYzpmdW5jdGlvbigpe1xuICAgICAgICBleHBvcnRzLmZyb21TcmMgPSB0cnVlXG4gICAgICAgIGlmKGV4cG9ydHMudGltZXIpe1xuICAgICAgICAgIGNsZWFyVGltZW91dChleHBvcnRzLnRpbWVyKVxuICAgICAgICAgIGV4cG9ydHMudGltZXIgPSBudWxsXG4gICAgICAgIH1cbiAgICAgICAgZXhwb3J0cy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICBleHBvcnRzLmZyb21TcmMgPSBmYWxzZVxuICAgICAgICAgIGV4cG9ydHMudGltZXIgPSBudWxsXG4gICAgICAgIH0sNTAwKVxuICAgICAgICB0aGlzLnBhcmVudC5vdmVybGF5LiRwbGF5aW5nLnVwZGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9KSxcbiAgb3ZlcmxheTogbmV3IE92ZXJsYXlTd2l0Y2hlcigpLFxuICBleHRlbmQ6IHtcbiAgICBwbGF5aW5nOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMub3ZlcmxheS4kcGxheWluZyA9IHZhbFxuICAgICAgdGhpcy52aWRlby4kcGxheWluZyA9IHZhbFxuICAgIH1cbiAgfVxufSkuQ2xhc3NcbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG5cdGNzczonc2Vjb25kLXByb2dyZXNzJyxcbiAgb246e1xuICAgIGRhdGE6J3RpbWUnLFxuICBcdGFiczp0cnVlLFxuICAgIG11bHRpcGx5OjEwMFxuICB9LFxuICBkaXNwbGF5OntcbiAgICB2YWw6YXBwLnByZXZpZXcsXG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgdmFyIHBvcHVwID0gYXBwLnBvcHVwLnZhbFxuICAgICAgcmV0dXJuIChjdiAmJiBjdi5fY29udGVudFR5cGUgPT09ICdjaGFubmVscycpIHx8IChwb3B1cCAmJiB0eXBlb2YgcG9wdXAgIT09ICdzdHJpbmcnKSA/ICdub25lJyA6ICdibG9jaydcbiAgICB9LFxuICAgIGxpc3RlbjphcHAucG9wdXBcbiAgfSxcbiAgdzp7XG4gICAgc2VsZjonb24nLFxuICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIHJldHVybiBNYXRoLm1heCh+fmN2LDMpICsgJyUnXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIFRyYWlsZXIgPSByZXF1aXJlKCcuLi90cmFpbGVyJylcbnZhciBzZWFyY2ggPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2VhcmNoJylcbnZhciB3aGVuID0gcmVxdWlyZSgncHJvbWlzZScpLmFsbFxudmFyIFN1YnRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3VidGl0bGUnKVxuXG52YXIgTm9SZXN1bHRzID0gbmV3IEVsZW1lbnQoe1xuICBjb250YWluZXI6e1xuICAgICd0aXRsZS50ZXh0JzonTm8gUmVzdWx0cyEnLFxuICAgICdzdWJ0aXRsZS50ZXh0JzonUGxlYXNlIHRyeSB0byByZWZpbmUgeW91ciBxdWVyeSdcbiAgfVxufSkuQ2xhc3NcblxudmFyIFN0YXJ0U2VhcmNoaW5nID0gbmV3IEVsZW1lbnQoe1xuICBjb250YWluZXI6e1xuICAgICd0aXRsZS50ZXh0JzonU3RhcnQgU2VhcmNoaW5nIScsXG4gICAgJ3N1YnRpdGxlLnRleHQnOidGaW5kIHlvdXIgZmF2b3JpdGUgbW92aWVzLCBzaG93cyBhbmQgY2hhbm5lbHMnXG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICdzZWNvbmQtc2VhcmNoJyxcbiAgZXh0ZW5kOntcbiAgICAkc2VhcmNoOmZ1bmN0aW9uKCB2YWwgKXtcbiAgXHQgIHZhciBfdGhpcyA9IHRoaXNcbiAgICBcdHZhciByZXN1bHRzID0gdGhpcy5yZXN1bHRzXG4gICAgXHR2YXIgY2hpbGRyZW4gPSByZXN1bHRzLmxpc3QuY2hpbGRyZW5cbiAgICBcdHZhciBxdWVyeSA9IHNlYXJjaC5wYXJzZVNlYXJjaCggdmFsLnZhbCApXG4gICAgXHR2YXIgY29udGVudCA9IGFwcC5jb250ZW50XG5cbiAgICBcdHRoaXMuc2VhcmNoYm94LnF1ZXJ5LnRleHQgPSBxdWVyeVxuXG4gICAgXHRpZihxdWVyeSAhPT0gZmFsc2Upe1xuICAgIFx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBcdFx0XHRzZWFyY2guZmlsdGVyQ29sbGVjdGlvbiggY2hpbGRyZW5baV0sIHF1ZXJ5IClcbiAgICBcdFx0fVxuICAgIFx0fVxuXG4gICAgICBpZihxdWVyeSl7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWRlZCgpe1xuICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzXG4gICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmZyb21cbiAgICAgICAgICByZXR1cm4ga2V5cyAmJiBrZXlzLmxlbmd0aCA+IDJcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoKXtcbiAgICAgICAgICBmb3IgKHZhciBqID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2pdXG4gICAgICAgICAgICBjaGlsZC5kaXNwbGF5ID0gY2hpbGQuZmlsdGVyLmxlbmd0aCA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvcFJlc3VsdCA9IHNlYXJjaC50b3BSZXN1bHQoIGNoaWxkcmVuIClcbiAgICAgICAgICBpZiggdG9wUmVzdWx0ICl7XG4gICAgICAgICAgICByZXN1bHRzLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICByZXN1bHRzLnRvcHJlc3VsdC5kYXRhID0gdG9wUmVzdWx0XG4gICAgICAgICAgICBpZihfdGhpcy5tZXNzYWdlKXtcbiAgICAgICAgICAgICAgX3RoaXMubWVzc2FnZS5yZW1vdmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgcmVzdWx0cy5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICBfdGhpcy5zZXQoe1xuICAgICAgICAgICAgICBtZXNzYWdlOm5ldyBOb1Jlc3VsdHMoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGVuKFtcbiAgICAgICAgICBjb250ZW50LmdldCgnbW92aWVzJykuaXMobG9hZGVkKSxcbiAgICAgICAgICBjb250ZW50LmdldCgnYWN0b3JzJykuaXMobG9hZGVkKSxcbiAgICAgICAgICBjb250ZW50LmdldCgnc2VyaWVzJykuaXMobG9hZGVkKSxcbiAgICAgICAgICBjb250ZW50LmdldCgnY2hhbm5lbHMnKS5pcyhsb2FkZWQpXG4gICAgICAgIF0pLmRvbmUoZG9uZSlcbiAgICAgIH1lbHNle1xuICAgICAgICByZXN1bHRzLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgIG1lc3NhZ2U6bmV3IFN0YXJ0U2VhcmNoaW5nKClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgIH0sXG4gICAgJG11dGVkOmZ1bmN0aW9uKHZhbCl7XG4gICAgICB0aGlzLnJlc3VsdHMudG9wcmVzdWx0LmJvZHkuY29udGFpbmVyLnRyYWlsZXIuJG11dGVkID0gdmFsLnZhbFxuICAgIH1cbiAgfSxcbiAgc2VhcmNoYm94OntcbiAgXHRzZWFyY2hpY29uOm5ldyBJY29uKHtcbiAgXHRcdGljb246J3NlYXJjaCdcbiAgXHR9KSxcbiAgXHQncXVlcnkudGV4dCc6JydcbiAgfSxcbiAgcmVzdWx0czp7XG4gIFx0bGlzdDpuZXcgc2VhcmNoLlJlc3VsdExpc3QoKSxcbiAgXHR0b3ByZXN1bHQ6e1xuICBcdFx0bW9kZWw6e2luaGVyaXQ6ZmFsc2V9LFxuICBcdFx0aGVhZGVyOntcbiAgXHRcdFx0dGV4dDp7XG4gIFx0XHRcdFx0Ly8gZGF0YTondGl0bGUnLFxuICBcdFx0XHRcdHByZXBlbmQ6J1RvcCBSZXN1bHQnLy8gLSAnXG4gIFx0XHRcdH1cbiAgXHRcdH0sXG4gIFx0XHRib2R5OntcbiAgXHRcdFx0Y29udGFpbmVyOntcbiAgXHRcdFx0XHR0cmFpbGVyOm5ldyBUcmFpbGVyKCksXG4gIFx0XHRcdFx0aW5mbzp7XG4gIFx0XHRcdFx0XHQndGl0bGUudGV4dC5kYXRhJzondGl0bGUnLFxuICAgICAgICAgICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKClcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sXG4gIFx0XHRcdCdkZXNjcmlwdGlvbi50ZXh0LmRhdGEnOidkZXNjcmlwdGlvbidcbiAgXHRcdH1cbiAgXHR9XG4gIH1cbn0pLkNsYXNzXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcC5jYXNlcy4kaXNJRkUgXG4/IG5ldyBFbGVtZW50KHtcbiAgICBjc3M6J3NlY29uZC1zdGF0dXNiYXIgYnJhbmRlZCcsXG4gICAgeTp7XG4gICAgICB0cmFuc2xhdGU6dHJ1ZSxcbiAgICAgIHZhbDo4MCxcbiAgICAgIG11bHRpcGx5OmFwcC5oaWRlU3RhdHVzYmFyXG4gICAgfSxcbiAgICBwYXJ0bmVyOntcbiAgICAgIGxvZ286e31cbiAgICB9LFxuICAgIHdlYXRoZXI6e1xuICAgICAgYWRkOm5ldyBJY29uKHtpY29uOid3ZWF0aGVyJ30pLFxuICAgICAgdGV4dDonUGFydGlhbGx5IENsb3VkZWQnXG4gICAgfSxcbiAgICBldGE6e1xuICAgICAgYWRkOm5ldyBJY29uKHtpY29uOidhaXJwbGFuZSd9KSxcbiAgICAgIHRleHQ6J1RpbWUgdG8gTG9zIEFuZ2VsZXM6IDZocidcbiAgICB9LFxuICAgIGJldHdlZW46e30sXG4gICAgZGlyZWN0djp7XG4gICAgICBsb2dvOnt9XG4gICAgfVxuICB9KS5DbGFzc1xuOiBuZXcgRWxlbWVudCh7XG4gICAgY3NzOidzZWNvbmQtc3RhdHVzYmFyJyxcbiAgICB5OntcbiAgICBcdHRyYW5zbGF0ZTp0cnVlLFxuICAgICAgdmFsOjgwLFxuICAgICAgbXVsdGlwbHk6YXBwLmhpZGVTdGF0dXNiYXJcbiAgICB9LFxuICAgIGRpcmVjdHY6e1xuICAgICAgbG9nbzp7fVxuICAgIH0sXG4gICAgc2VuZGVyOntcbiAgICAgIGljb246bmV3IEljb24oe2ljb246J3Bob25lJ30pLFxuICAgICAgdGl0bGU6e3RleHQ6J2NvbnRyb2xsZWQgYnkgaVBob25lJ31cbiAgICB9XG4gIH0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIFZpZGVvID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlbycpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIEFTU0VUUyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpLnBvaW50ZXJzLmFzc2V0c1xudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgTXV0ZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL211dGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnc2Vjb25kLXRyYWlsZXInLFxuICAnZXh0ZW5kLiRtdXRlZCc6ZnVuY3Rpb24oKXt9LFxuICAkbXV0ZWQ6dHJ1ZSxcbiAgdmlkZW86bmV3IFZpZGVvKHtcbiAgICBwbGF5ZXI6IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8vaHRtbDUnKSxcbiAgICBzcmM6e1xuICAgICAgZGF0YTogJ3RyYWlsZXInLFxuICAgICAgcHJlcGVuZDogQVNTRVRTXG4gICAgfSxcbiAgICBkdXJhdGlvbjogdHJ1ZSxcbiAgICB2b2x1bWU6e1xuICAgICAgcGFyZW50OickbXV0ZWQnLFxuICAgICAgbXVsdGlwbHk6LTEsXG4gICAgICBhZGQ6MVxuICAgIH0sXG4gICAgbG9vcDogdHJ1ZSxcbiAgICBhdXRvcGxheTogdHJ1ZVxuICB9KSxcbiAgbG9nbzpuZXcgSW1nKHtcbiAgICAnYmFja2dyb3VuZC5kYXRhJzonaW1nLmxvZ28nXG4gIH0pLFxuICBtdXRlZDpuZXcgTXV0ZSh7XG4gICAgaWNvbjp7XG4gICAgICBwYXJlbnQ6JyRtdXRlZCdcbiAgICB9XG4gIH0pXG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxudmFyIEl0ZW0gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2l0ZW0nKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgQ29udGVudCA9IHJlcXVpcmUoJy4uL2NvbnRlbnQnKVxudmFyIFN1YnRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3VidGl0bGUnKVxudmFyIFRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvdGl0bGUnKVxudmFyIFN0aWNrZXJzID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3RpY2tlcnMnKVxudmFyIEJpbyA9IHJlcXVpcmUoJy4uL2JpbycpXG5cbnZhciBPdmVydmlldyA9IG5ldyBDb250ZW50KHtcbiAgY3NzOidvdmVydmlldycsXG4gIGNvbnRhaW5lcjp7XG4gICAgdG9wOiB7XG4gICAgICAnbGVmdC5wb3N0ZXInOm5ldyBJdGVtLlBvc3Rlcih7XG4gICAgICAgICdpbWcuYmFja2dyb3VuZCc6e1xuICAgICAgICAgIGFkZDp7XG4gICAgICAgICAgICBkYXRhOidzaG93LmltZy5wb3N0ZXInXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgICByaWdodDoge1xuICAgICAgICB0aXRsZTpuZXcgVGl0bGUoKSxcbiAgICAgICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKCksXG4gICAgICAgIHN0aWNrZXJzOm5ldyBTdGlja2VycygpXG4gICAgICB9XG4gICAgfSxcbiAgICAnZGVzY3JpcHRpb24udGV4dC5kYXRhJzogJ2Rlc2NyaXB0aW9uJyxcbiAgICBzdGFycmluZzoge1xuICAgICAgZGlzcGxheTp7XG4gICAgICAgIHZhbDonYmxvY2snLFxuICAgICAgICB3aGVuOntkYXRhOidhY3RvcnMnfSxcbiAgICAgICAgb3I6J25vbmUnXG4gICAgICB9LFxuICAgICAgJ2hlYWRlci50ZXh0JzogJ1N0YXJyaW5nJyxcbiAgICAgICdhY3RvcnMuY29sbGVjdGlvbic6IHtcbiAgICAgICAgZGF0YTogJ2FjdG9ycycsXG4gICAgICAgIGVsZW1lbnQ6IG5ldyBJdGVtLlBvc3Rlcih7XG4gICAgICAgICAgY3NzOnthZGRDbGFzczonYWN0b3InfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxudmFyIFByZXZpZXcgPSBuZXcgQ29udGVudCh7XG4gIGNzczoncHJldmlldycsXG4gICdjb3Zlci5iZy5iYWNrZ3JvdW5kJzp7XG4gICAgZGF0YTogJ2ltZy5jb3Zlci4xJyxcbiAgICBhZGQ6e1xuICAgICAgZGF0YTonc2hvdy5pbWcuY292ZXIuMidcbiAgICB9XG4gIH0sXG4gICdjb250YWluZXIuaW5mbyc6IHtcbiAgICB0aXRsZTpuZXcgVGl0bGUuU2hvdygpLFxuICAgIHN1YnRpdGxlOm5ldyBTdWJ0aXRsZSh7XG4gICAgICAvLyAnZXBpc29kZXMudGV4dCc6e1xuICAgICAgLy8gICBkYXRhOidlcGlzb2RlTnInXG4gICAgICAvLyB9XG4gICAgfSksXG4gICAgJ2Rlc2NyaXB0aW9uLnRleHQuZGF0YSc6ICdkZXNjcmlwdGlvbicsXG4gICAgc3RpY2tlcnM6bmV3IFN0aWNrZXJzKHtcbiAgICAgIGF1ZGllbmNlOntcbiAgICAgICAgYmFja2dyb3VuZDp7XG4gICAgICAgICAgd2hlbjp7ZGF0YTonZXhjbHVzaXZlJ30sXG4gICAgICAgICAgdmFsOidhc3NldHMvaW1nL2FwcC9hdWRpZW5jZS5wbmcnLFxuICAgICAgICAgIG9yOicgJ1xuICAgICAgICB9LFxuICAgICAgICAnbW9kZWwuY29tcGxldGUnOmZ1bmN0aW9uKCl7XG4gICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kLnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgfVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU3dpdGNoZXIoe1xuICBjc3M6ICdzZWNvbmQtdm9kJyxcbiAgb25UcmFuc2l0aW9uOidmYWRlJyxcbiAgZXh0ZW5kOntcbiAgICAkYWN0aXZlOmZ1bmN0aW9uKHZhbCl7XG4gICAgICBpZih0aGlzLl9zd0VsZW0pIHRoaXMuX3N3RWxlbS4kYWN0aXZlID0gdmFsLnZhbFxuICAgIH0sXG4gICAgJGNvbXBsZXRlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBjb21wbGV0ZSA9IHZhbC52YWxcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhXG4gICAgICB2YXIgaXNFcGlzb2RlID0gZGF0YS5fY29udGVudFR5cGUgPT09ICdlcGlzb2RlcydcblxuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgZGF0YTogZGF0YS5mcm9tLFxuICAgICAgICAkYWN0aXZlOnRoaXMuJGFjdGl2ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29tcGxldGUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0ge1xuICAgICAgICAgIC8vIGVsZW1lbnQ6IGlzRXBpc29kZSA/IEVwaXNvZGVPdmVydmlldyA6IE92ZXJ2aWV3LFxuICAgICAgICAgIGVsZW1lbnQ6IE92ZXJ2aWV3LFxuICAgICAgICAgICRwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbXBsZXRlID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgLy8gZWxlbWVudDogaXNFcGlzb2RlID8gRXBpc29kZVByZXZpZXcgOiBQcmV2aWV3LFxuICAgICAgICAgIGVsZW1lbnQ6IFByZXZpZXcsXG4gICAgICAgICAgJHBhcmFtczogcGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICRwb3B1cDpmdW5jdGlvbih2YWwpe1xuICAgICAgdmFyIGRhdGEgPSB2YWwudmFsXG4gICAgICBpZihkYXRhICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyl7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OkJpbyxcbiAgICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICAgIGRhdGE6ZGF0YS5mcm9tXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYodGhpcy4kY29tcGxldGUpIHRoaXMuJGNvbXBsZXRlLnVwZGF0ZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOmZ1bmN0aW9uKHZhbCl7XG4gICAgICBpZih0aGlzLl9zd0VsZW0gJiYgIXRoaXMuX3N3RWxlbS5zd2l0Y2hlcil7XG4gICAgICAgIHRoaXMuX3N3RWxlbS5kYXRhID0gdmFsLnZhbFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJGFjdGl2ZTp0cnVlXG59KS5DbGFzc1xuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIFZpZGVvID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlbycpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nJylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG52YXIgTXBhYSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL21wYWEnKVxudmFyIFNjb3JlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3RhdGlzdGljcycpLlNjb3JlXG52YXIgU3RpY2tlcnMgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdGlja2VycycpXG5cbmV4cG9ydHMuVHdpdHRlciA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAndHdpdHRlci13aWRnZXQnLFxuICAnaGVhZGVyLnRleHQnOiAnVHdlZXRzJyxcbiAgJ3R3ZWV0cy5jb2xsZWN0aW9uJzoge1xuICAgIGRhdGE6ICdndWlkZS4wLnR3ZWV0cycsXG4gICAgZWxlbWVudDogbmV3IEVsZW1lbnQoe1xuICAgICAgY3NzOiAndHdlZXQnLFxuICAgICAgYmlyZDogbmV3IEljb24oe2ljb246J3R3aXR0ZXInfSksXG4gICAgICAnYXV0aG9yLnRleHQnOntcbiAgICAgICAgZGF0YTogJ2F1dGhvcicsXG4gICAgICAgIHByZXBlbmQ6ICdAJ1xuICAgICAgfSxcbiAgICAgICdib2R5LnRleHQuZGF0YSc6ICdib2R5J1xuICAgIH0pXG4gIH1cbn0pLkNsYXNzXG5cbmV4cG9ydHMuR3VpZGUgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ2d1aWRlLXdpZGdldCcsXG4gICdoZWFkZXIudGV4dCc6ICdHdWlkZScsXG4gICdwcm9ncmFtcy5jb2xsZWN0aW9uJzoge1xuICAgIGRhdGE6ICdndWlkZScsXG4gICAgZWxlbWVudDogbmV3IEVsZW1lbnQoe1xuICAgICAgY3NzOiAncHJvZ3JhbScsXG4gICAgICBsZWZ0OntcbiAgICAgICAgJ3RpdGxlLnRleHQuZGF0YSc6ICd0aXRsZScsXG4gICAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICAgJ3N0YXJ0LnRleHQuZGF0YSc6ICdzdGFydC10aW1lJyxcbiAgICAgICAgICAnZGFzaC50ZXh0JzogJyAtICcsXG4gICAgICAgICAgJ2Jhci5zZWVrJzoge30sXG4gICAgICAgICAgJ2VuZC50ZXh0LmRhdGEnOiAnZW5kLXRpbWUnXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtcGFhOm5ldyBNcGFhKClcbiAgICB9KVxuICB9XG59KS5DbGFzc1xuXG52YXIgUG9sbGVyID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICdwb2xsZXInLFxuICAnbGVmdC5sb2dvJzogbmV3IEltZygpLFxuICByaWdodDoge1xuICAgICd0aXRsZS50ZXh0LmRhdGEnOiAndGl0bGUnLFxuICAgIGJhcjoge1xuICAgICAgJ2V4dGVuZC4kYm9yZGVyVG9wQ29sb3InOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYodmFsLnZhbCkgdGhpcy5ub2RlLnN0eWxlLmJvcmRlclRvcENvbG9yID0gdmFsLnZhbFxuICAgICAgfSxcbiAgICAgICckYm9yZGVyVG9wQ29sb3IuZGF0YSc6ICdjb2xvcicsXG4gICAgICB3OiB7XG4gICAgICAgIGRhdGE6ICd2b3RlcycsXG4gICAgICAgIGRpdmlkZTogMTAwMDAsXG4gICAgICAgIG11bHRpcGx5OiAxMDAsXG4gICAgICAgIGFkZDogJyUnXG4gICAgICB9XG4gICAgfSxcbiAgICAndm90ZXMudGV4dCc6IHtcbiAgICAgIGRhdGE6ICd2b3RlcycsXG4gICAgICBhZGQ6ICcgVk9URVMnXG4gICAgfVxuICB9LFxuICBzZXRTZXR0aW5nOiB7XG4gICAgbmFtZTogJ2JpbmR2b3RlcycsXG4gICAgcGFyZW50OiBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgIHRoaXMucmlnaHQuYmFyLncgPSB7XG4gICAgICAgIGRpdmlkZTogcGFyZW50Lm9uXG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG52YXIgUG9sbCA9IG5ldyBFbGVtZW50KHtcbiAgb246IHsgLy8gc3RvcmUgdGhlIHRvdGFsdm90ZXNcbiAgICBkYXRhOiAncG9sbC4wLnZvdGVzJyxcbiAgICAnYWRkLmRhdGEnOiAncG9sbC4xLnZvdGVzJ1xuICB9LFxuICBhcHBlbmQ6IFtcbiAgICBQb2xsZXIsIHtcbiAgICAgICdtb2RlbC5maWVsZCc6ICdwb2xsLjAnXG4gICAgfSwge1xuICAgICAgJ21vZGVsLmZpZWxkJzogJ3BvbGwuMSdcbiAgICB9XG4gIF1cbn0pLkNsYXNzXG5cbmV4cG9ydHMuU3RhdHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3N0YXRzLXdpZGdldCcsXG4gICdoZWFkZXIudGV4dCc6ICdTdGF0aXN0aWNzJyxcbiAgY29udGFpbmVyOiB7XG4gICAgbW9kZWw6e2ZpZWxkOidndWlkZS4wJ30sXG4gICAgc2NvcmU6IG5ldyBTY29yZSgpLFxuICAgIGluZm86IHtcbiAgICAgICd0aXRsZS50ZXh0JzogJ1dobyB3aWxsIHdpbj8nLFxuICAgICAgJ3N1YnRpdGxlLnRleHQnOiAnVXNlIHBob25lIHRvIHZvdGUnXG4gICAgfSxcbiAgICBwb2xsOiBuZXcgUG9sbCgpXG4gIH1cbn0pLkNsYXNzXG5cbmV4cG9ydHMuQWJvdXQgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ2Fib3V0LXdpZGdldCcsXG4gICdoZWFkZXIudGV4dCc6ICdBYm91dCB0aGUgU2hvdycsXG4gIGNvbnRhaW5lcjoge1xuICAgIGltZzpuZXcgSW1nKHtcbiAgICAgICdiYWNrZ3JvdW5kLmRhdGEnOidpbWcudGh1bWInXG4gICAgfSksXG4gICAgaW5mbzp7XG4gICAgICAnbW9kZWwuZmllbGQnOidndWlkZS4wJyxcbiAgICAgIHRpdGxlczp7XG4gICAgICAgICd0aXRsZS50ZXh0LmRhdGEnOiAndGl0bGUnLFxuICAgICAgICAnc3VidGl0bGUudGV4dC5kYXRhJzogJ3N1YnRpdGxlJ1xuICAgICAgfSxcbiAgICAgIHN0aWNrZXJzOm5ldyBTdGlja2VycygpXG4gICAgfSxcbiAgICAnZGVzY3JpcHRpb24udGV4dC5kYXRhJzonZ3VpZGUuMC5kZXNjcmlwdGlvbidcbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBQb3N0ZXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2l0ZW0nKS5Qb3N0ZXJcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczondWktYWN0b3JzJyxcbiAgZGlzcGxheTp7XG4gICAgdmFsOidibG9jaycsXG4gICAgd2hlbjp7XG4gICAgICBkYXRhOidhY3RvcnMnLFxuICAgICAgb3I6e1xuICAgICAgICBkYXRhOidzaG93LmFjdG9ycydcbiAgICAgIH1cbiAgICB9LFxuICAgIG9yOidub25lJ1xuICB9LFxuICBoZWFkZXI6IHsgdGV4dDogJ1N0YXJyaW5nJyB9LFxuICBib2R5OiB7XG4gICAgc2Nyb2xsYmFyOiAneCcsXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgZGF0YTogJ2FjdG9ycycsXG4gICAgICBlbGVtZW50OiBuZXcgUG9zdGVyKHtcbiAgICAgICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhLmZyb21cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczondWktYmFyJ1xufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcblxudmFyIERlc2NyaXB0aW9uID0gbmV3IEVsZW1lbnQoe1xuXHRjc3M6J3VpLWRlc2NyaXB0aW9uJyxcbiAgaGVhZGVyOiB7IHRleHQ6ICdEZXNjcmlwdGlvbicgfSxcbiAgYm9keToge1xuICAgIHRleHQ6IHsgZGF0YTogJ2Rlc2NyaXB0aW9uJyB9XG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gRGVzY3JpcHRpb25cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcbiAgLCBpY29uID0gbmV3IEVsZW1lbnQoeyBjc3M6J3VpLWljb24nIH0pXG4gICwgbWFwID1cbiAgICB7IGRpc2NvdmVyOidcXHVlNjAwJ1xuICAgICwgc2hvd3M6J1xcdWU2MDEnXG4gICAgLCB0djonXFx1ZTYwMidcbiAgICAsIHNldHRpbmdzOidcXHVlNjAzJ1xuICAgICwgY2FzdDonXFx1ZTYwNCdcbiAgICAsIGRlc2t0b3A6J1xcdWU2MDInXG4gICAgLCBwbGF5OidcXHVlNjA1J1xuICAgICwgcGF1c2U6J1xcdWU2MDYnXG4gICAgLCBmdWxsc2NyZWVuOidcXHVlNjA3J1xuICAgICwgZXhpdGZ1bGxzY3JlZW5BbHQ6J1xcdWU2MDgnXG4gICAgLCBwdWxsYmFjazonXFx1ZTYwOSdcbiAgICAsIHN3aXBldXA6J1xcdWU2MGEnXG4gICAgLCBhbGxDaGFubmVsczonXFx1ZTYwYidcbiAgICAsIGRpc2Nvbm5lY3RlZDonXFx1ZTYwYydcbiAgICAsIG1lbnU6J1xcdWU2MGQnXG4gICAgLCBJRkU6J1xcdWU2MGUnXG4gICAgLCBiYWNrOidcXHVlNjBmJ1xuICAgICwgY2xvc2VTbWFsbDonXFx1ZTYxMCdcbiAgICAsIGNsb3NlOidcXHVlNjExJ1xuICAgICwgd3Jvbmc6J1xcdWU2MTInXG4gICAgLCBjb3JyZWN0OidcXHVlNjEzJ1xuICAgICwgZmFjZWJvb2s6J1xcdWU2MTQnXG4gICAgLCB0d2l0dGVyOidcXHVlNjE1J1xuICAgICwgcGhvbmU6J1xcdWU2MTYnXG4gICAgLCB0YWJsZXQ6J1xcdWU2MTcnXG4gICAgLCB2b2x1bWU6J1xcdWU2MTgnXG4gICAgLCBtdXRlZDonXFx1ZTYxOSdcbiAgICAsIHBhdXNlQWx0OidcXHVlNjFhJ1xuICAgICwgcGxheUFsdDonXFx1ZTYxYidcbiAgICAsIHJld2luZDonXFx1ZTYxYydcbiAgICAsIGZhc3Rmb3J3YXJkOidcXHVlNjFkJ1xuICAgICwgcHJvZmlsZTonXFx1ZTYxZSdcbiAgICAsIGRyb3Bkb3duOidcXHVlNjFmJ1xuICAgICwgcmlnaHROYXY6J1xcdWU2MjAnXG4gICAgLCBsZWZ0TmF2OidcXHVlNjIxJ1xuICAgICwgcmlnaHQ6J1xcdWU2MjInXG4gICAgLCBzZWFyY2g6J1xcdWU2MjMnXG4gICAgLCBub1Jlc3VsdDonXFx1ZTYyNCdcbiAgICAsIHNlYXJjaE1lbnU6J1xcdWU2MjUnXG4gICAgLCBlcGc6J1xcdWU2MjYnXG4gICAgLCB1cE5hdjonXFx1ZTYyNydcbiAgICAsIGRvd25OYXY6J1xcdWU2MjgnXG4gICAgLCBtZW51UmlnaHQ6J1xcdWU2MjknXG4gICAgLCBhaXJwbGFuZTonXFx1ZTYyYSdcbiAgICAsIG11dGVkQWx0OidcXHVlNjJiJ1xuICAgICwgbG9ja2VkOidcXHVlNjJjJ1xuICAgICwgd2VhdGhlcjonXFx1ZTYyZCdcbiAgICAsIGVtcHR5OicgJ1xuICAgIH1cblxuaWNvbi5leHRlbmQoe1xuICBpY29uOiBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgbmFtZSA9IG1hcFt2YWwudmFsXVxuICAgIGlmKG5hbWUpIHtcbiAgICAgIHZhciB2ID0gJzxzcGFuPicgKyBuYW1lICsgJzwvc3Bhbj4nLFxuICAgICAgICB2YWx1ZSA9IHRoaXMubm9kZS5pbm5lckhUTUwsXG4gICAgICAgIGRpdmluZGV4ID0gdmFsdWUuaW5kZXhPZignPGRpdicpXG4gICAgICBpZih+ZGl2aW5kZXgpIHYgKz0gdmFsdWUuc2xpY2UoZGl2aW5kZXgpXG4gICAgICB0aGlzLmh0bWwgPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdpY29uIGVycm9yOiAnLCB2YWwudmFsLCAnIGlzIG5vdCBkZWZpbmVkJylcbiAgICB9XG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGljb24uQ2xhc3NcbmV4cG9ydHMubWFwID0gbWFwXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgQVNTRVRTID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvY29uZmlnJykucG9pbnRlcnMuYXNzZXRzXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBvcGFjaXR5OiAwLFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgZGF0YTonaW1nJyxcbiAgICBwcmVwZW5kOkFTU0VUUyxcbiAgICBsb2FkOiBmdW5jdGlvbih0KSB7XG4gICAgICBpZih0aGlzLiR3YWl0ICYmIHRoaXMuJHdhaXQudmFsKXtcbiAgICAgICAgdGhpcy4kd2FpdC5vbmNlKGZhbHNlLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBmYWxzZVxuICAgICAgfVxuICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZVxuICAgICAgdC5fbG9hZGVkID0gdHJ1ZVxuICAgIH1cbiAgfSxcbiAgJ2V4dGVuZC4kd2FpdCc6ZnVuY3Rpb24oKXt9XG59KS5DbGFzcyIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIExpc3QgPSByZXF1aXJlKCcuLycpXG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IExpc3Qoe1xuICBjb2xsZWN0aW9uOiB7XG4gICAgZGF0YTogJ2l0ZW1zJyxcbiAgICBlbGVtZW50Okl0ZW0uQ2hhbm5lbFxuICB9XG59KS5DbGFzcyIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIF9mb2N1c2VkID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvdXRpbCcpLmZvY3VzZWRcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczonbGlzdC1kb3RzJyxcbiAgY29udGFpbmVyOntcbiAgICBjb2xsZWN0aW9uOntcbiAgICAgIGRhdGE6J3Nwb3RsaWdodC5pdGVtcycsXG4gICAgICBlbGVtZW50Om5ldyBFbGVtZW50KClcbiAgICB9LFxuICAgICdleHRlbmQuJGZvY3VzJzogZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgIC8vIGFsZXJ0KHR5cGVvZiB2YWwudmFsID09PSAnc3RyaW5nJylcbiAgICAgIHZhciBjaGlsZCA9IHR5cGVvZiB2YWwudmFsID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHRoaXNbdmFsLnZhbF1cbiAgICAgICAgOiB0aGlzLmNoaWxkcmVuWyB2YWwudmFsIHx8IDAgXVxuICAgICAgX2ZvY3VzZWQoIHRoaXMsIGNoaWxkIClcbiAgICB9LFxuICAgIG1vZGVsOnsgY29tcGxldGU6ZnVuY3Rpb24oKXtcbiAgICAgIGlmKCB0aGlzLmNoaWxkcmVuWzBdICl7XG4gICAgICAgIGlmKHRoaXMuJGZvY3VzKSB0aGlzLiRmb2N1cy51cGRhdGUoKVxuICAgICAgICB0aGlzLm1vZGVsID0geyBjb21wbGV0ZTpudWxsIH1cbiAgICAgIH1cbiAgICB9fVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoICcuL3N0eWxlLmxlc3MnIClcblxudmFyIGNhc2VzID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJyApXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciB1dGlsID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvdXRpbCcpXG52YXIgX2ZvY3VzZWQgPSB1dGlsLmZvY3VzZWRcbnZhciBfcHJldmVudEFuaW1hdGlvbiA9IHV0aWwucHJldmVudEFuaW1hdGlvblxuXG52YXIgQmFzZSA9IG5ldyBFbGVtZW50KCB7XG4gIGNzczogJ2Jhc2UtbGlzdCcsXG4gIG1vZGVsOiBmdW5jdGlvbigpIHtcblxuICAgIGlmICggdGhpcy5jaGlsZHJlblsgMCBdICkge1xuICAgICAgaWYoICF0aGlzLiRmb2N1cyApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigndGhpcyBsaXN0IG5lZWRzIGEgJGZvY3VzIHZhbHVlIScpXG4gICAgICAgIC8vIHRoaXMuJGZvY3VzID0gMFxuICAgICAgfVxuICAgICAgX3VwZGF0ZVgodGhpcylcbiAgICAgIHRoaXMuJGZvY3VzLnVwZGF0ZSgpXG4gICAgICB0aGlzLm1vZGVsID0gZmFsc2VcbiAgICB9XG4gIH0sXG4gIHNldFNldHRpbmc6IHtcbiAgICBuYW1lOiAndXBkYXRlWCcsXG4gICAgcGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIF91cGRhdGVYKHRoaXMpXG4gICAgfVxuICB9LFxuICAnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudFxuICAgIGlmKHBhcmVudC5wYXJlbnQuJGZvY3VzKSBwYXJlbnQucGFyZW50LiRmb2N1cy5mcm9tID0gcGFyZW50Ll9uYW1lXG4gICAgLy8gY29uc29sZS5lcnJvcigndGhpcyEnLHRoaXMucGFyZW50LnBhcmVudClcbiAgfVxufSApLkNsYXNzXG5cbnZhciBMaXN0ID0gbmV3IEJhc2UoIHtcbiAgJ2V4dGVuZC4kZm9jdXMnOiBmdW5jdGlvbiggdmFsICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICB2YXIgbiA9IHZhbC52YWwgfHwgMFxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudFxuICAgIFxuICAgIF9mb2N1c2VkKCB0aGlzLCB0aGlzLmNoaWxkcmVuWyBuIF0gKVxuICAgIF9ib3VuY2UoIHRoaXMgKVxuXG4gICAgaWYoICFjYXNlcy4kaXNQaG9uZSAmJiBwYXJlbnQgKXtcbiAgICAgIFxuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVcbiAgICAgIHZhciBwYXJlbnRUb3AgPSBwYXJlbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgIGlmKF90aGlzLnJhZklkKSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMucmFmSWQpXG4gICAgICBmdW5jdGlvbiBjaGVjaygpe1xuICAgICAgICB2YXIgdG9wID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgaWYoIXRvcCB8fCB0b3AgPT09IHBhcmVudFRvcCkge1xuICAgICAgICAgIF90aGlzLnggPSB7XG4gICAgICAgICAgICBtdWx0aXBseTogLW5cbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMucmFmSWQgPSBudWxsXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIF90aGlzLnJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjaGVjaylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2soKVxuXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLnggPSB7XG4gICAgICAgIG11bHRpcGx5OiAtblxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgeDoge1xuICAgIHRyYW5zbGF0ZTogdHJ1ZSxcbiAgICB2YWw6MCxcbiAgICBtdWx0aXBseTogMCxcbiAgICBkZWZlcjogX2RlZmVyXG4gIH0sXG4gIHk6e1xuICAgIHRyYW5zbGF0ZTp0cnVlLFxuICAgIHZhbDowXG4gIH0sXG4gICRpc1Bob25lOiB7XG4gICAgeDoge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIHRpbWU6IDI0LFxuICAgICAgICBlYXNpbmc6ICdvdXRDdWJpYydcbiAgICAgIH1cbiAgICB9LFxuICAgICdldmVudHMuZ3JhYic6IHtcbiAgICAgIHg6IHRydWUsXG4gICAgICBwYXNzOiBfcGFzcyxcbiAgICAgIG1vdmU6IF9oaWdobGlnaHQsXG4gICAgICB1cDogX3Bvc2l0aW9uXG4gICAgfVxuICB9XG59ICkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gY2FzZXMuJGlzUGhvbmUgPyBuZXcgQmFzZSgge1xuICAvLyBtb2RlbDpmdW5jdGlvbigpe1xuICAvLyAgIGlmICggdGhpcy5jaGlsZHJlblsgMCBdICkge1xuICAvLyAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcmVudC5fbmFtZVxuICAvLyAgICAgdmFyIHNjcm9sbExlZnQgPSBleHBvcnRzW25hbWVdICYmIGV4cG9ydHNbbmFtZV0uc2Nyb2xsTGVmdFxuICAvLyAgICAgaWYoc2Nyb2xsTGVmdCl7XG4gIC8vICAgICAgIGV4cG9ydHNbbmFtZV0uaWdub3JlU2Nyb2xsID0gdHJ1ZVxuICAvLyAgICAgICB0aGlzLm5vZGUuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnRcbiAgLy8gICAgICAgZXhwb3J0c1tuYW1lXS5pZ25vcmVTY3JvbGwgPSBmYWxzZVxuICAvLyAgICAgfWVsc2V7XG4gIC8vICAgICAgIGlmKCAhdGhpcy4kZm9jdXMgKSB7XG4gIC8vICAgICAgICAgY29uc29sZS5lcnJvcigndGhpcyBsaXN0IG5lZWRzIGEgJGZvY3VzIHZhbHVlIScpXG4gIC8vICAgICAgICAgLy8gdGhpcy4kZm9jdXMgPSAwXG5cbiAgLy8gICAgICAgfVxuICAvLyAgICAgICBfdXBkYXRlWCh0aGlzKVxuICAvLyAgICAgICB0aGlzLiRmb2N1cy51cGRhdGUoKVxuICAvLyAgICAgfVxuICAvLyAgICAgdGhpcy5tb2RlbCA9IGZhbHNlXG4gIC8vICAgfVxuICAvLyB9LFxuICAnZXh0ZW5kLiRmb2N1cyc6IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuICAgIF9mb2N1c2VkKCB0aGlzLCBjaGlsZHJlblsgdmFsLnZhbCB8fCAwIF0gKVxuICAgIGlmICggIXRoaXMubm9kZS5zY3JvbGxMZWZ0ICYmIHZhbC52YWwgKSB7XG4gICAgICB0aGlzLm5vZGUuc2Nyb2xsTGVmdCA9IHZhbC52YWwgKiBfc3RlcCggdGhpcywgY2hpbGRyZW4gKVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsYmFyOiAneCcsXG4gICdldmVudHMuc2Nyb2xsJzogZnVuY3Rpb24oIGUgKSB7XG4gICAgLy8gdmFyIG5hbWUgPSB0aGlzLnBhcmVudC5fbmFtZVxuICAgIC8vIGlmKCFleHBvcnRzW25hbWVdKSBleHBvcnRzW25hbWVdID0ge31cbiAgICAvLyBlbHNlIGlmKGV4cG9ydHNbbmFtZV0uaWdub3JlU2Nyb2xsKSByZXR1cm5cblxuICAgIGlmKCF0aGlzLl9jaGVja2VkKXsgLy9ibG9jayB0aGUgZmlyc3RcbiAgICAgIHRoaXMuX2NoZWNrZWQgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IG5vZGUuc2Nyb2xsTGVmdFxuICAgIHZhciBmcmFjdGlvbiA9IHNjcm9sbExlZnQgLyAoIG5vZGUuc2Nyb2xsV2lkdGggLSBub2RlLm9mZnNldFdpZHRoIClcbiAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKCBmcmFjdGlvbiAqICggX2xlbmd0aCggdGhpcyApIC0gMSApIClcbiAgICAvLyBleHBvcnRzW25hbWVdLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0XG4gICAgX3RoaXMuJGZvY3VzLmZyb20gPSBpbmRleFxuICB9XG59ICkuQ2xhc3MgOiBMaXN0XG5cbmV4cG9ydHMuQ2Fyb3VzZWwgPSBMaXN0XG5leHBvcnRzLlNwb3RsaWdodCA9IHJlcXVpcmUoICcuL3Nwb3RsaWdodCcgKVxuZXhwb3J0cy5DaGFubmVsID0gcmVxdWlyZSggJy4vY2hhbm5lbCcgKVxuZXhwb3J0cy5Qb3N0ZXIgPSByZXF1aXJlKCAnLi9wb3N0ZXInIClcbmV4cG9ydHMuV2F0Y2hpbmcgPSByZXF1aXJlKCAnLi93YXRjaGluZycgKVxuZXhwb3J0cy5Eb3RzID0gcmVxdWlyZSggJy4vZG90cycgKVxuZXhwb3J0cy5JdGVtID0gcmVxdWlyZSggJy4vaXRlbScgKVxuXG52YXIgdHJlc2hvbGQgPSA2MFxudmFyIGZsaWNrID0gMTBcblxuZnVuY3Rpb24gX2JvdW5jZSggbGlzdCApIHtcbiAgaWYgKCBsaXN0LnguX2UgKXtcbiAgICBsaXN0LnggPSB7XG4gICAgICBfZXN1YjogbGlzdC54Ll9lLl92YWxcbiAgICB9XG4gICAgbGlzdC54LnVwZGF0ZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2hpZ2hsaWdodCggZSwgZCl7XG4gIHZhciBsZW5ndGggPSBfbGVuZ3RoKCB0aGlzIClcbiAgdmFyIHN0ZXAgPSBfc3RlcCggdGhpcyApXG4gIHZhciBvbGRwb3MgPSB0aGlzLl9zdGFydFxuICB2YXIgbmV3cG9zID0gb2xkcG9zXG4gIGlmICggZC54IDwgLXRyZXNob2xkICkge1xuICAgIG5ld3BvcyA9IE1hdGgubWF4KCBvbGRwb3MgLSBNYXRoLmNlaWwoICggLWQueCApIC8gc3RlcCApLCAtbGVuZ3RoICsgMSApXG4gIH0gZWxzZSBpZiAoIGQueCA+IHRyZXNob2xkICkge1xuICAgIG5ld3BvcyA9IE1hdGgubWluKCBvbGRwb3MgKyBNYXRoLmNlaWwoIGQueCAvIHN0ZXAgKSwgMCApXG4gIH1cbiAgaWYoLW5ld3BvcyAhPT0gdGhpcy4kZm9jdXMudmFsKSBfc2V0KCB0aGlzLCBuZXdwb3MgKVxufVxuXG5mdW5jdGlvbiBfcGFzcyggZSwgZCApIHtcbiAgaWYoTWF0aC5hYnMoIGQueCApID4gTWF0aC5hYnMoIGQueSApKXtcbiAgICB0aGlzLl9zdGFydCA9IC10aGlzLiRmb2N1cy52YWwgfHwgMFxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Bvc2l0aW9uKCBlLCBkLCBsZCApIHsgLy8gdW5pZnkgd2l0aCBzd2l0Y2hlclxuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXG4gIHZhciBsZW5ndGggPSBfbGVuZ3RoKCB0aGlzIClcbiAgdmFyIG9sZHBvcyA9IHRoaXMuX3N0YXJ0IHx8IDBcbiAgdmFyIG5ld3Bvc1xuICB2YXIgc3RlcCA9IF9zdGVwKCB0aGlzLCBjaGlsZHJlbiApXG5cbiAgaWYgKCBNYXRoLmFicyggbGQueCApID4gZmxpY2sgKSB7XG4gICAgaWYgKCBsZC54IDwgMCAmJiBkLnggPCB0cmVzaG9sZCApIHtcbiAgICAgIG5ld3BvcyA9IE1hdGgubWF4KCBvbGRwb3MgLSBNYXRoLmNlaWwoICggLWQueCApIC8gc3RlcCApLCAtbGVuZ3RoICsgMSApXG4gICAgfSBlbHNlIGlmICggbGQueCA+IDAgJiYgZC54ID4gLXRyZXNob2xkICkge1xuICAgICAgbmV3cG9zID0gTWF0aC5taW4oIG9sZHBvcyArIE1hdGguY2VpbCggZC54IC8gc3RlcCApLCAwIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCBkLnggPCAtdHJlc2hvbGQgKSB7XG4gICAgICBuZXdwb3MgPSBNYXRoLm1heCggb2xkcG9zIC0gTWF0aC5jZWlsKCAoIC1kLnggKSAvIHN0ZXAgKSwgLWxlbmd0aCArIDEgKVxuICAgIH0gZWxzZSBpZiAoIGQueCA+IHRyZXNob2xkICkge1xuICAgICAgbmV3cG9zID0gTWF0aC5taW4oIG9sZHBvcyArIE1hdGguY2VpbCggZC54IC8gc3RlcCApLCAwIClcbiAgICB9XG4gIH1cblxuICBpZiAoIG5ld3BvcyAhPT0gdm9pZCAwICYmIC1uZXdwb3MgIT09IHRoaXMuJGZvY3VzLnZhbCApIF9zZXQoIHRoaXMsIG5ld3BvcyApXG4gIFxuICBfYm91bmNlKCB0aGlzIClcbn1cblxuZnVuY3Rpb24gX3N0ZXAoIGxpc3QsIGNoaWxkcmVuLCBjb3JyZWN0ZWQgKSB7IC8vIHRoaXMgY2FuIGJlIGNsZWFuZXJcbiAgdmFyIG5vZGVcblxuICBpZiAoICFjaGlsZHJlbiApIGNoaWxkcmVuID0gbGlzdC5jaGlsZHJlblxuICBpZiAoIGNoaWxkcmVuWyAwIF0gKSB7XG4gICAgaWYgKCAhbGlzdC5fc3RlcCApIHtcbiAgICAgIG5vZGUgPSBsaXN0Lm5vZGVcbiAgICAgIGxpc3QuX3N0ZXAgPSBub2RlLnNjcm9sbFdpZHRoIC8gX2xlbmd0aCggbGlzdCApIC8vIFxuICAgIH1cbiAgICBpZiAoIGNvcnJlY3RlZCApIHtcbiAgICAgIG5vZGUgPSBsaXN0Lm5vZGVcbiAgICAgIHJldHVybiAoIG5vZGUuc2Nyb2xsV2lkdGggLSBub2RlLm9mZnNldFdpZHRoICkgLyAoIF9sZW5ndGgoIGxpc3QgKSAtIDEgKVxuICAgIH1cbiAgICByZXR1cm4gbGlzdC5fc3RlcFxuICB9XG59XG5cbmZ1bmN0aW9uIF9sZW5ndGgoIF90aGlzICl7XG4gIHJldHVybiBfdGhpcy5jaGlsZHJlbi5sZW5ndGggLy9fdGhpcy5fbGVuZ3RoIHx8ICggX3RoaXMuX2xlbmd0aCA9IF90aGlzLmNoaWxkcmVuLmxlbmd0aCApXG59XG5cbmZ1bmN0aW9uIF9kZWZlciggdXBkYXRlLCBhcmdzICkge1xuICB2YXIgbGlzdCA9IHRoaXMuX2NhbGxlclxuICB2YXIgc3RlcCA9IF9zdGVwKCBsaXN0LCBudWxsLCB0cnVlIClcbiAgaWYgKCBzdGVwICkge1xuICAgIGlmKCF0aGlzLl92YWwpIHRoaXMudmFsID0gc3RlcFxuICAgIHRoaXMuX2ZsYWcgPSBudWxsXG4gIH1cbiAgdXBkYXRlKClcbn1cblxuZnVuY3Rpb24gX3VwZGF0ZVgoIF90aGlzICl7XG4gIGlmKCBfdGhpcy54ICl7XG4gICAgX3ByZXZlbnRBbmltYXRpb24oX3RoaXMsZnVuY3Rpb24oKXtcbiAgICAgIF90aGlzLnguX3AgPSB0cnVlXG4gICAgICBfdGhpcy54LnVwZGF0ZSgpXG4gICAgICBfdGhpcy54Ll9wID0gbnVsbFxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gX3NldCggX3RoaXMsIG5ld3BvcyApe1xuICB2YXIgZmllbGQgPSBfdGhpcy4kZm9jdXMuX2ZsYWcgJiYgX3RoaXMuJGZvY3VzLl9mbGFnLmRhdGFbMl1cbiAgdmFyIGRhdGEgPSBfdGhpcy5kYXRhXG4gIGlmKCBmaWVsZCAmJiBkYXRhICl7XG4gICAgZGF0YS5mcm9tLnNldChmaWVsZCwtbmV3cG9zKVxuICB9ZWxzZSBfdGhpcy4kZm9jdXMuZnJvbSA9IC1uZXdwb3Ncbn0iLCJ2YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgVGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC90aXRsZScpXG52YXIgU3VidGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdWJ0aXRsZScpXG52YXIgYmxvY2tlZCA9ICdibG9ja2VkJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGltZzogbmV3IEltZygpLFxuICAnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvY3VzID0gdGhpcy5wYXJlbnQuJGZvY3VzXG4gICAgaWYgKGZvY3VzKSBmb2N1cy5mcm9tID0gdGhpcy4kaW5kZXhcbiAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEuZnJvbVxuICB9LFxuICBleHRlbmQ6IFt7XG4gICAgICBuYW1lOiAnJGluZGV4JyxcbiAgICAgIHR5cGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgc2libGluZ3MgPSB0aGlzLnBhcmVudC5jaGlsZHJlblxuICAgICAgICAgIGZvciAodmFyIGkgPSBzaWJsaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgc2libGluZ3NbaV0uX2luZGV4ID0gaVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXhcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAkYmxvY2tlZDogX2Jsb2NrZWRcbiAgICB9XSxcbiAgJyRibG9ja2VkLmRhdGEnOmJsb2NrZWRcbn0pLkNsYXNzXG5cbmV4cG9ydHMuSW5mbyA9IG5ldyBleHBvcnRzKHtcbiAgY3NzOiAnaW5mby1pdGVtJyxcbiAgJ2ltZy5iYWNrZ3JvdW5kLmRhdGEnOiAnaW1nLnRodW1iJyxcbiAgaW5mbzoge1xuICAgIHRpdGxlOiBuZXcgVGl0bGUuU2hvdygpLFxuICAgIHN1YnRpdGxlOiBuZXcgU3VidGl0bGUoKVxuICB9XG59KS5DbGFzc1xuXG5leHBvcnRzLlBvc3RlciA9IG5ldyBleHBvcnRzKHtcbiAgY3NzOiAncG9zdGVyLWl0ZW0nLFxuICAnaW1nLmJhY2tncm91bmQuZGF0YSc6ICdpbWcucG9zdGVyJyxcbn0pLkNsYXNzXG5cbmV4cG9ydHMuQ2hhbm5lbCA9IG5ldyBleHBvcnRzLkluZm8oe1xuICAnbG9nbyc6IG5ldyBJbWcoe1xuICAgICdiYWNrZ3JvdW5kLmRhdGEnOiAnaW1nLmxvZ28nXG4gIH0pLFxuICAnaW5mby50aXRsZS50ZXh0LmRhdGEnOiAnZ3VpZGUuMC50aXRsZSdcbn0pLkNsYXNzXG5cbmV4cG9ydHMuQ2Fyb3VzZWwgPSBuZXcgSW1nKHtcbiAgY3NzOiAnc3BvdGxpZ2h0LWl0ZW0nLFxuICAnZXh0ZW5kLiRibG9ja2VkJzogX2Jsb2NrZWQsXG4gICdldmVudHMuY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEuZnJvbVxuICB9LFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgZGF0YTogJ2ltZy5zcG90bGlnaHQnXG4gIH0sXG4gICckYmxvY2tlZC5kYXRhJzpibG9ja2VkXG59KS5DbGFzc1xuXG5mdW5jdGlvbiBfYmxvY2tlZCh2YWwpe1xuICBpZih2YWwudmFsKXtcbiAgICB0aGlzLmFkZEV2ZW50KCdjbGljaycsZnVuY3Rpb24oKXtcbiAgICAgIC8vIG5ldyBBdWRpbygnaHR0cDovL3d3dy5ub2lzZWFkZGljdHMuY29tL3NhbXBsZXNfMXc3MmI4MjAvMzczOS5tcDMnKS5wbGF5KClcbiAgICAgIGFsZXJ0KCdUaGlzIGl0ZW0gaXMgbm90IGF2YWlsYWJsZScpXG4gICAgfSxibG9ja2VkKVxuICAgIHRoaXMuY3NzID0geyBhZGRDbGFzczpibG9ja2VkIH1cbiAgICB0aGlzLnNldCh7XG4gICAgICBsb2NrOm5ldyBJY29uKHtpY29uOidsb2NrZWQnfSlcbiAgICB9KVxuICB9ZWxzZXtcbiAgICBpZih0aGlzLmxvY2spe1xuICAgICAgdGhpcy5yZW1vdmVFdmVudChmYWxzZSwgYmxvY2tlZClcbiAgICAgIHRoaXMuY3NzID0geyByZW1vdmVDbGFzczpibG9ja2VkIH1cbiAgICAgIHRoaXMubG9jay5yZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgTGlzdCA9IHJlcXVpcmUoJy4vJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBJdGVtID0gcmVxdWlyZSgnLi9pdGVtJylcblxuTGlzdC5Qb3N0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgTGlzdCh7XG4gIGNvbGxlY3Rpb246IHtcbiAgICBkYXRhOiAnaXRlbXMnLFxuICAgIGVsZW1lbnQ6bmV3IEl0ZW0uUG9zdGVyKClcbiAgfVxufSkuQ2xhc3NcblxuLy8gZXhwb3J0cy5lbGVtZW50ID0gZWxlbWVudCIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIExpc3QgPSByZXF1aXJlKCcuLycpXG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IExpc3QuQ2Fyb3VzZWwoIHtcbiAgY29sbGVjdGlvbjoge1xuICAgIGRhdGE6ICdpdGVtcycsXG4gICAgZWxlbWVudDpJdGVtLkNhcm91c2VsXG4gIH1cbn0gKS5DbGFzcyIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIExpc3QgPSByZXF1aXJlKCcuLycpXG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IExpc3Qoe1xuICBjb2xsZWN0aW9uOiB7XG4gICAgZGF0YTogJ2l0ZW1zJyxcbiAgICBlbGVtZW50Om5ldyBJdGVtLkluZm8oe1xuICAgICAgYmFyOntcbiAgICAgICAgdzp7XG4gICAgICAgICAgZGF0YTondGltZScsXG4gICAgICAgICAgbXVsdGlwbHk6MTAwLFxuICAgICAgICAgIGFiczp0cnVlLFxuICAgICAgICAgIGFkZDonJSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFNwcml0ZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3ByaXRlJylcbiAgLCBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU3ByaXRlKFxueyBjc3M6J3VpLWxvYWRlcidcbiwgdzozMFxuLCBoOjMwXG4sIHBhcmFtczp7IGNvbHM6MSwgcm93czoyNiB9IC8vIG9uY2U6dHJ1ZSB9XG59KS5DbGFzc1xuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgYmFja2dyb3VuZDp7XG4gICAgZGF0YTonbXBhYScsXG4gICAgYWRkOntkYXRhOidzaG93Lm1wYWEnfSxcbiAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odiwgbXBhYSl7XG4gICAgICBpZiggbXBhYSApIHJldHVybiAnYXNzZXRzL2ltZy9hcHAvbXBhYV8nICsgbXBhYS50b0xvd2VyQ2FzZSgpICsgJy5wbmcnXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBJY29uKHtcbiAgY3NzOid1aS1pY29uIHNoYXJlZC1tdXRlJyxcbiAgaWNvbjp7XG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgcmV0dXJuIGN2ID8gJ211dGVkQWx0JyA6ICd2b2x1bWUnXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgQmFyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2JhcicpLkJhclxuXG52YXIgVm90ZVJvdyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAndWktdm90ZXJvdycsXG4gIGxlZnQ6IHtcbiAgICBsb2dvOiB7IFxuICAgICAgYmFja2dyb3VuZDogeyBcbiAgICAgICAgZGF0YTogJ2ltZycsXG4gICAgICAgIHByZXBlbmQ6IGNvbmZpZy5wb2ludGVycy5hc3NldHNcbiAgICAgIH0sXG4gICAgICAnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5kYXRhLnZvdGVzLnZhbCArPSAxXG4gICAgICB9XG4gICAgfVxuICB9LFxuICByaWdodDoge1xuICAgIGNvdW50OiB7XG4gICAgICBtb2RlbDpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgaWYoZGF0YS5fcGFyZW50KXtcbiAgICAgICAgICB0aGlzLm1vZGVsID0gZmFsc2VcbiAgICAgICAgICB0aGlzLnZvdGVmaWxsZXIuZGF0YSA9IGRhdGEuX3BhcmVudFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGVhbTogeyB0ZXh0OiB7IGRhdGE6ICd0aXRsZScgfSB9LFxuICAgICAgdm90ZXM6IHsgdGV4dDogeyBkYXRhOiAndm90ZXMnICxhZGQ6ICcgVk9URVMnIH0gfSxcbiAgICAgIHZvdGVmaWxsZXI6IG5ldyBCYXIoe1xuICAgICAgICBzZWVrOiB7XG4gICAgICAgICAgdzp7XG4gICAgICAgICAgICBkYXRhOnRydWUsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCBjLCBjdiApe1xuICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnBhcmVudC5wYXJlbnRcbiAgICAgICAgICAgICAgdmFyIG15dm90ZXMgPSBjb3VudC5kYXRhICYmIGNvdW50LmRhdGEudm90ZXMgJiYgY291bnQuZGF0YS52b3Rlcy52YWxcbiAgICAgICAgICAgICAgaWYobXl2b3Rlcykge1xuICAgICAgICAgICAgICAgIHZhciB2MSA9IGN2WzBdLnZvdGVzLnZhbFxuICAgICAgICAgICAgICAgIHZhciB2MiA9IGN2WzFdLnZvdGVzLnZhbFxuICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IHYxICsgdjJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCBteXZvdGVzIC8gdG90YWwgKSAqIDEwMCArICclJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnZXh0ZW5kLiRiYWNrZ3JvdW5kQ29sb3InOiBmdW5jdGlvbiggdmFsICl7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnBhcmVudC5wYXJlbnRcbiAgICAgICAgICAgIHZhciBteWNvbG9yID0gY291bnQuZGF0YSAmJiBjb3VudC5kYXRhLmNvbG9yICYmIGNvdW50LmRhdGEuY29sb3IudmFsXG4gICAgICAgICAgICBpZihteWNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbXljb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJyRiYWNrZ3JvdW5kQ29sb3IuZGF0YSc6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbnZhciBQb2xsID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICd1aS1wb2xsJyxcbiAgZGlzcGxheTp7XG4gICAgdmFsOidibG9jaycsXG4gICAgd2hlbjp7ZGF0YToncG9sbC4wLnRpdGxlJ30sXG4gICAgb3I6J25vbmUnXG4gIH0sXG4gIGhlYWRlcjogeyB0ZXh0OiB7IGRhdGE6ICdwb2xsLnRpdGxlJyB9IH0sXG4gIGZpcnN0OiBuZXcgVm90ZVJvdyh7XG4gICAgbW9kZWw6IHsgZmllbGQ6ICdwb2xsLjAnIH1cbiAgfSksXG4gIHNlY29uZDogbmV3IFZvdGVSb3coe1xuICAgIG1vZGVsOiB7IGZpZWxkOiAncG9sbC4xJyB9XG4gIH0pXG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxcbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3NoYXJlZC9pY29uJylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJyApXG4gICAgLmluamVjdCggcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXIvdHJhbnNpdGlvbnMnICkgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczoncG9wdXAnLFxuICB0b3BiYXI6e1xuICAgIGxlZnQ6bmV3IEljb24oe2ljb246J2xlZnQnfSksXG4gICAgbWlkZGxlOiB7IHRleHQ6J3BvcHVwJyB9LFxuICAgIHJpZ2h0Om5ldyBJY29uKHtcbiAgICAgIGljb246J2Nsb3NlJyxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjbGljazpmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5wYXJlbnQucG9wdXAuJHVzZXJPcmlnaW4gPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgdzphcHAudyxcbiAgaDphcHAuaCxcbiAgeTpcbiAgeyB2YWw6MCwgXG4gICAgYW5pbWF0aW9uOlxuICAgIHsgdGltZTphcHAuaC52YWwgLyAzMFxuICAgICwgc3RhcnQ6YXBwLmhcbiAgICAsIGVhc2luZzonb3V0Q3ViaWMnXG4gICAgLCBkb25lOmZ1bmN0aW9uKGN2KSB7XG4gICAgICAgIHZhciB0ID0gdGhpc1xuICAgICAgICBpZihjdj49MTAwKSB0LnJlbW92ZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzd2l0Y2hlcjpuZXcgU3dpdGNoZXIoe1xuICAgIG9uVHJhbnNpdGlvbjoge1xuICAgICAgdmFsOidmYWRlJyxcbiAgICAgICRoYXNUb3VjaDogJ3NsaWRlJ1xuICAgIH0sXG4gICAgYmFja0ZhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ3d0ZiBtb2V0IGhpZXIuLi5iYWNrZmFsbGJhY2snKVxuICAgIH1cbiAgfSksXG4gIGV4dGVuZDp7XG4gICAgcG9wdXA6ZnVuY3Rpb24oKXt9XG4gIH1cbn0pLkNsYXNzXG5cblxuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgdGV4dDp7ZGF0YToncmF0aW5nJyxhZGQ6e2RhdGE6J3Nob3cucmF0aW5nJ319XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIFBvc3RlciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QvaXRlbScpLlBvc3RlclxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxuXG52YXIgUmVjb21tZW5kYXRpb25zID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICd1aS1yZWNvbW1lbmRhdGlvbnMnLFxuICBkaXNwbGF5OntcbiAgICB2YWw6J2Jsb2NrJyxcbiAgICB3aGVuOntcbiAgICAgIGRhdGE6J3JlY29tbWVuZGF0aW9ucycsXG4gICAgICBvcjp7XG4gICAgICAgIGRhdGE6J3Nob3cucmVjb21tZW5kYXRpb25zJ1xuICAgICAgfVxuICAgIH0sXG4gICAgb3I6J25vbmUnXG4gIH0sXG4gIGhlYWRlcjogeyB0ZXh0OiAnWW91XFwnbGwgbG92ZSB0aGVzZScgfSxcbiAgYm9keToge1xuICAgIHNjcm9sbGJhcjogJ3gnLFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGRhdGE6ICdyZWNvbW1lbmRhdGlvbnMnLFxuICAgICAgZWxlbWVudDogUG9zdGVyXG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY29tbWVuZGF0aW9uc1xuIiwidmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBkaXNwbGF5ID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2NvbGxlY3Rpb24vZGlzcGxheScpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgU3VidGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdWJ0aXRsZScpXG52YXIgTXV0ZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL211dGUnKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG5cbnZhciBSZXN1bHQgPSBleHBvcnRzLlJlc3VsdCA9IGFwcC5jYXNlcy4kaXNQaG9uZSBcbj8gbmV3IEVsZW1lbnQoe1xuICAgIGNzczonc2VhcmNoLXJlc3VsdCcsXG4gICAgYm9keToge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDp7ZGF0YTondGl0bGUnfSxcbiAgICAgIH0sXG4gICAgICBhcnJvd1JpZ2h0OiBuZXcgSWNvbih7IGljb246J3JpZ2h0JyB9KVxuICAgIH0sXG4gICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuICAgICAgYXBwLnVzZXIubmF2aWdhdGlvbi5jb250ZW50LiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhXG4gICAgIH1cbiAgfSkuQ2xhc3NcbjogbmV3IEVsZW1lbnQoe1xuICAgIGNzczonc2VhcmNoLXJlc3VsdCcsXG4gICAgJ3Bvc3Rlci5jb250YWluZXInOm5ldyBJbWcoe1xuICAgICAgJ2JhY2tncm91bmQuZGF0YSc6J2ltZy5wb3N0ZXInXG4gICAgfSksXG4gICAgYm9keTp7XG4gICAgICAndGl0bGUudGV4dC5kYXRhJzondGl0bGUnLFxuICAgICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKClcbiAgICB9XG4gIH0pLkNsYXNzXG5cbnZhciBSZXN1bHRzID0gZXhwb3J0cy5SZXN1bHRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3NlYXJjaC1yZXN1bHRzJyxcbiAgdGl0bGU6IHtcbiAgICB0ZXh0OidyZWNlbnQgc2VhcmNoZXMnXG4gIH0sXG4gIGNvbGxlY3Rpb246IHtcbiAgICBvcHRpb246ZGlzcGxheSxcbiAgICBlbGVtZW50OlJlc3VsdFxuICB9XG59KS5DbGFzc1xuXG52YXIgVG9wUmVzdWx0ID0gZXhwb3J0cy5Ub3BSZXN1bHQgPSBuZXcgRWxlbWVudCh7XG4gIHRpdGxlOiB7dGV4dDondG9wIHJlc3VsdCd9LFxuICBjc3M6J3NlYXJjaC10b3AtcmVzdWx0JyxcbiAgYm9keToge1xuICAgIHBvc3Rlcjp7XG4gICAgICBpbWc6IHtcbiAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgIHZhbDogY29uZmlnLnBvaW50ZXJzLmFzc2V0cyxcbiAgICAgICAgICBhZGQ6IHsgZGF0YTonaW1nLnBvc3RlcicgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZHJvcDp7fSxcbiAgICAgICAgbXV0ZTpuZXcgTXV0ZSh7XG4gICAgICAgICAgZGlzcGxheTp7XG4gICAgICAgICAgICB2YWw6J25vbmUnLFxuICAgICAgICAgICAgJGhhc1JlY2VpdmVyOidibG9jaydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGljb246e1xuICAgICAgICAgICAgdmFsOmFwcC51c2VyLnRyYWlsZXJNdXRlZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgYXBwLnVzZXIudHJhaWxlck11dGVkLiR1c2VyT3JpZ2luID0gIWFwcC51c2VyLnRyYWlsZXJNdXRlZC52YWxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICB0ZXh0SG9sZGVyOntcbiAgICAgIHRpdGxlOiB7IHRleHQ6eyBkYXRhOid0aXRsZScgfSB9LFxuICAgICAgaW5mbzogeyB0ZXh0OicxMTIgbWludXRlcycgfSxcbiAgICAgIHJhdGluZzoge1xuICAgICAgICB0ZXh0OiB7IGRhdGE6J3JhdGluZyd9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IHsgdGV4dDogeyBkYXRhOiAnZGVzY3JpcHRpb24nfSB9LFxuICAgICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZGF0YSA9ICB0aGlzLnRpdGxlLmRhdGFcbiAgICAgICAgXG4gICAgICAgIC8vX25hbWVcbiAgICAgICAgaWYoZGF0YS5fY29udGVudFR5cGU9PT0nc2VyaWVzJykge1xuICAgICAgICAgIGRhdGEgPSBkYXRhLmdldCgnc2Vhc29ucy4wLmVwaXNvZGVzLjAnKVxuICAgICAgICB9XG5cbiAgICAgICAgYXBwLnVzZXIubmF2aWdhdGlvbi5jb250ZW50LiR1c2VyT3JpZ2luID0gZGF0YVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW9kZWw6IHsgaW5oZXJpdDogZmFsc2UgfVxuICAvLyAnbW9kZWwuZmllbGQnOidtb3ZpZXMuMCcgLy9kZXplIG1vZXQgZHluYW1pY2x5IGNoYW5nZW4gOihcbn0pLkNsYXNzXG5cbmV4cG9ydHMuUmVzdWx0TGlzdCA9IG5ldyBFbGVtZW50KHtcbiAgbW92aWVzOiBuZXcgUmVzdWx0cyh7XG4gICAgdGl0bGU6IHtcbiAgICAgIHRleHQ6J21vdmllcydcbiAgICB9LFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGVsZW1lbnQ6IG5ldyBSZXN1bHQoe1xuICAgICAgICBtb2RlbDoge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICAgICAgdGl0bGU6dHJ1ZSxcbiAgICAgICAgICAgIGFjdG9yczp7XG4gICAgICAgICAgICAgICQ6e1xuICAgICAgICAgICAgICAgIHRpdGxlOnRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBkYXRhOidtb3ZpZXMnXG4gICAgfVxuICB9KSxcbiAgc2VyaWVzOiBuZXcgUmVzdWx0cyh7XG4gICAgdGl0bGU6IHtcbiAgICAgIHRleHQ6J3NlcmllcydcbiAgICB9LFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGRhdGE6J3NlcmllcycsXG4gICAgICBlbGVtZW50OiBuZXcgUmVzdWx0KHtcbiAgICAgICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuICAgICAgICAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEuZ2V0KCdzZWFzb25zLjAuZXBpc29kZXMuMCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KSxcbiAgY2hhbm5lbHM6IG5ldyBSZXN1bHRzKHtcbiAgICB0aXRsZToge1xuICAgICAgdGV4dDonY2hhbm5lbHMnXG4gICAgfSxcbiAgICBjb2xsZWN0aW9uOiB7XG4gICAgICBkYXRhOidjaGFubmVscydcbiAgICB9XG4gIH0pLFxuICBhY3RvcnM6IG5ldyBSZXN1bHRzKHtcbiAgICB0aXRsZToge1xuICAgICAgdGV4dDonYWN0b3JzJ1xuICAgIH0sXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgZGF0YTonYWN0b3JzJyxcbiAgICAgIGVsZW1lbnQ6IG5ldyBSZXN1bHQoe1xuICAgICAgICBtb2RlbDoge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICAgICAgdGl0bGU6dHJ1ZSxcbiAgICAgICAgICAgIGNhdGFsb2c6e1xuICAgICAgICAgICAgICAkOntcbiAgICAgICAgICAgICAgICB0aXRsZTp0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAvL21pc2NcbiAgICAgICAgICAvLyBhbGVydCgnPycpXG4gICAgICAgICAgYXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhLmZyb21cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59KS5DbGFzc1xuXG5leHBvcnRzLmZpbHRlckNvbGxlY3Rpb24gPSBmdW5jdGlvbiggZWxlbWVudCwgc3JjaCwgZmlsdGVyKSB7XG4gIGZpbHRlciA9IGZpbHRlciB8fCB7XG4gICAgY29uZGl0aW9uOiB7XG4gICAgICAkb3I6IFtcbiAgICAgIHsgdGl0bGU6eyAkY29udGFpbnM6c3JjaCB9IH0sXG4gICAgICB7IGNhdGFsb2c6eyAkOiB7IHRpdGxlOiB7ICRjb250YWluczpzcmNoIH0gfSB9IH0sXG4gICAgICB7IGFjdG9yczp7ICQ6IHsgdGl0bGU6IHsgJGNvbnRhaW5zOnNyY2ggfSB9IH0gfVxuICAgICAgXVxuICAgIH1cbiAgfVxuICBpZiggZWxlbWVudC5maWx0ZXIgKSB7XG4gICAgZWxlbWVudC5maWx0ZXIuZmlsdGVyID0gZmlsdGVyXG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5jb2xsZWN0aW9uID0geyBmaWx0ZXI6IGZpbHRlciB9XG4gIH0gICAgXG59XG5cbmV4cG9ydHMudG9wUmVzdWx0ID0gZnVuY3Rpb24oIGxpc3QgKSB7XG4gIGZvcih2YXIgaSBpbiBsaXN0KSB7XG4gICAgaWYoIGxpc3RbaV0uZmlsdGVyICYmIGxpc3RbaV0uZmlsdGVyWzBdICkge1xuICAgICAgcmV0dXJuIGxpc3RbaV0uZmlsdGVyWzBdXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMucGFyc2VTZWFyY2ggPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYodmFsICYmIHZhbC5fX3QgPT09IDIpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuICB2YWwgPSB2YWwgJiYgdmFsLnRyaW0oKSB8fCAnJ1xuICB2YXIgc3RyID0gJyc7XG4gIHJldHVybiB2YWxcbn0iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC8nKSAvLyAgcmVwbGFjZSBhcHAgc3R1ZmYgd2l0aCBwYXJlbnRcbnZhciB1YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL3VhJylcbnZhciBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcbnZhciB2aWRlb1V0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvL3V0aWwnKVxudmFyIEljb24gPSByZXF1aXJlKCcuLi9pY29uJylcbnZhciBfbGltaXRVcGRhdGVzID0gdWEucGxhdGZvcm0gPT09ICdpb3MnIHx8IHVhLnBsYXRmb3JtID09PSAnYW5kcm9pZCdcblxudmFyIEJhciA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOid1aS1zZWVrYmFyJyxcbiAgYmc6e30sXG4gIHNlZWs6e31cbn0pLkNsYXNzXG5cbnZhciBzZWVrYmFyID0gbmV3IEJhcih7XG4gIGNzczp7XG4gICAgZGF0YTondGl0bGUnLFxuICAgIHRyYW5zZm9ybTpmdW5jdGlvbigpe1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLl9jb250ZW50VHlwZVxuICAgICAgcmV0dXJuICd1aS1zZWVrYmFyJyArICggdHlwZSA9PT0gJ2NoYW5uZWxzJyA/ICcgY2hhbm5lbCcgOiAnJylcbiAgICB9XG4gIH0sXG4gICdzZWVrLncnOnsgXG4gICAgZGF0YTondGltZScsXG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgcmV0dXJuIE1hdGguYWJzKGN2KSAqIDEwMCArICclJ1xuICAgIH1cbiAgfSxcbiAgYmc6IHtcbiAgICBsb2FkZXJiYXI6IHt9XG4gIH0sXG4gIGJ1dHRvbjp7IHk6eyB2YWw6LTksdHJhbnNsYXRlOnRydWUgfSB9LFxuICBldmVudHM6e1xuICAgIGRvd246IGZ1bmN0aW9uKGUpIHsgXG4gICAgICBlLnRlbXBQcmV2ZW50ID0gdHJ1ZVxuICAgICAgc2V0VGltZS5jYWxsKHRoaXMsIGUpXG4gICAgfSxcbiAgICBkcmFnOiBzZXRUaW1lLFxuICAgIHVwOmNhc2VzLnRvdWNoXG4gICAgICA/IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgIHZhciBvdmVybGF5T3BhY2l0eSA9IHRoaXMucGFyZW50LnBhcmVudC5wYXJlbnQub3BhY2l0eVxuICAgICAgICAgIGlmKCF0aGlzLl9za2lwVXApIHNldFRpbWUuY2FsbCh0aGlzLCBlKVxuICAgICAgICAgIGVsc2UgdGhpcy5fc2tpcFVwID0gbnVsbFxuICAgICAgICB9XG4gICAgICA6IHNldFRpbWVcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gc2Vla2Jhci5DbGFzc1xuXG5leHBvcnRzLkJhciA9IEJhclxuXG5mdW5jdGlvbiBzZXRUaW1lKGUpIHtcblxuICBpZih0aGlzLnNlZWsuZGF0YS5fY29udGVudFR5cGUgPT09ICdjaGFubmVscycpIHJldHVyblxuICAvLyBjb25zb2xlLmVycm9yKCd4eHh4JylcbiAgdmFyIHJlY3QgPSB0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAsIHhcbiAgICAsIG5yXG5cbiAgaWYodGhpcy5fbGVmdCl7XG4gICAgeCA9IHJlY3QudG9wXG4gICAgbnIgPSAoZS55LXgpL3JlY3QuaGVpZ2h0XG4gIH1lbHNlIGlmKHRoaXMuX3JpZ2h0KXtcbiAgICB4ID0gcmVjdC50b3BcbiAgICBuciA9IChyZWN0LmhlaWdodC0oZS55LXgpKS9yZWN0LmhlaWdodFxuICB9ZWxzZXtcbiAgICB4ID0gcmVjdC5sZWZ0XG4gICAgbnIgPSAoZS54LXgpLyhyZWN0LnJpZ2h0LXgpXG4gIH1cblxuICB2YXIgdmFsID0gbnIgPiAxID8gMSA6IG5yIDwgMCA/IDAgOiBuclxuICBpZiggdmFsICE9PSB0aGlzLl9wcmV2VmFsIClcbiAge1xuICAgIHRoaXMuc2Vlay5kYXRhLmZyb20uc2V0KCd0aW1lJyx2YWwpXG4gICAgdGhpcy5fcHJldlZhbCA9IHZhbFxuICB9XG59IiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgY29uZmlnID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvY29uZmlnJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxuXG52YXIgU2NvcmUgPSBuZXcgRWxlbWVudCh7XG4gIGNzczondWktc2NvcmUnLFxuICB0b3A6IHtcbiAgICBpbmZvOiB7XG4gICAgICAndGl0bGUudGV4dC5kYXRhJzogJ3N0YXRpc3RpY3MudGl0bGUnLFxuICAgICAgJ3N1YnRpdGxlLnRleHQuZGF0YSc6ICdzdGF0aXN0aWNzLmRhdGUnXG4gICAgfSxcbiAgICB0ZWFtczoge1xuICAgICAgbGVmdDogbmV3IEltZyh7XG4gICAgICAgICdiYWNrZ3JvdW5kLmRhdGEnOiAnc3RhdGlzdGljcy5sZWZ0LmltZydcbiAgICAgIH0pLFxuICAgICAgcmlnaHQ6bmV3IEltZyh7XG4gICAgICAgICdiYWNrZ3JvdW5kLmRhdGEnOiAnc3RhdGlzdGljcy5yaWdodC5pbWcnXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgYm9keToge1xuICAgICdsZWZ0LnRleHQuZGF0YSc6ICdzdGF0aXN0aWNzLmxlZnQucG9pbnRzJyxcbiAgICBtaWRkbGVsZWZ0OiB7XG4gICAgICAndGl0bGUudGV4dC5kYXRhJzogJ3N0YXRpc3RpY3MubGVmdC5hY3JvbnltJyxcbiAgICAgICdzdWJ0aXRsZS50ZXh0LmRhdGEnOiAnc3RhdGlzdGljcy5sZWZ0LmlubmluZ3MnXG4gICAgfSxcbiAgICBtaWRkbGVyaWdodDoge1xuICAgICAgJ3RpdGxlLnRleHQuZGF0YSc6ICdzdGF0aXN0aWNzLnJpZ2h0LmFjcm9ueW0nLFxuICAgICAgJ3N1YnRpdGxlLnRleHQuZGF0YSc6ICdzdGF0aXN0aWNzLnJpZ2h0LmlubmluZ3MnXG4gICAgfSxcbiAgICAncmlnaHQudGV4dC5kYXRhJzogJ3N0YXRpc3RpY3MucmlnaHQucG9pbnRzJyxcbiAgfVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICd1aS1zdGF0aXN0aWNzJyxcbiAgZGlzcGxheTp7XG4gICAgZGF0YTonc3RhdGlzdGljcy50aXRsZScsXG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgcmV0dXJuIGN2ID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgIH1cbiAgfSxcbiAgJ2hlYWRlci50ZXh0JzogJ1N0YXRpc3RpY3MnLFxuICBib2R5Om5ldyBTY29yZSgpXG59KS5DbGFzc1xuXG5leHBvcnRzLlNjb3JlID0gU2NvcmUiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgTXBhYSA9IHJlcXVpcmUoJy4uL21wYWEnKVxudmFyIFJhdGluZyA9IHJlcXVpcmUoJy4uL3JhdGluZycpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3VpLXN0aWNrZXJzJyxcbiAgbXBhYTpuZXcgTXBhYSgpLFxuICByYXRpbmc6IG5ldyBSYXRpbmcoKVxufSkuQ2xhc3MiLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICB0ZXh0OiB7XG4gICAgZGF0YTogJ3N1YnRpdGxlJyxcbiAgICBhZGQ6IFtcbiAgICAgICcuJywge1xuICAgICAgICBkYXRhOiAneWVhcicsXG4gICAgICAgIGFkZDogWycgLSAnLCB7XG4gICAgICAgICAgZGF0YTogJ2R1cmF0aW9uJyxcbiAgICAgICAgICBkaXZpZGU6IDYwLFxuICAgICAgICAgIGZsb29yOiB0cnVlLFxuICAgICAgICAgIGFkZDogJyBNaW51dGVzJ1xuICAgICAgICB9XVxuICAgICAgfSxcbiAgICAgICcuJywge1xuICAgICAgICBkYXRhOiAnZ3VpZGUuMC5zdGFydC10aW1lJyxcbiAgICAgICAgYWRkOiBbJyAtICcsIHtcbiAgICAgICAgICBkYXRhOiAnZ3VpZGUuMC5lbmQtdGltZSdcbiAgICAgICAgfV1cbiAgICAgIH1cbiAgICBdLFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odiwgY3YpIHtcbiAgICAgIHZhciBhcnIgPSBjdi5zcGxpdCgnLicpXG4gICAgICB2YXIgbCA9IGFyci5sZW5ndGggLSAxXG4gICAgICB2YXIgc3RyID0gYXJyW2xdXG4gICAgICB3aGlsZSAoc3RyWzFdID09PSAnLScgfHwgKHN0cls1XSA9PT0gJy0nICYmIHN0cls3XSA9PT0gJyAnKSkgeyAvL2RpcnR5IVxuICAgICAgICBzdHIgPSBhcnJbLS1sXVxuICAgICAgfVxuICAgICAgaWYgKHN0cikgcmV0dXJuIHN0clxuXG4gICAgICB2YXIgZnJvbSA9IHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuZnJvbVxuICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgdmFyIGVwaXNvZGUgPSAoZnJvbS5fbmFtZSB8IDApICsgMVxuICAgICAgICB2YXIgc2Vhc29uID0gKGZyb20uX3BhcmVudC5fcGFyZW50Ll9uYW1lIHwgMCkgKyAxXG4gICAgICAgIHJldHVybiAnU2Vhc29uICcgKyBzZWFzb24gKyAnIC0gJyArICdFcGlzb2RlICcgKyBlcGlzb2RlXG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzc1xuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgJ3RleHQuZGVmYXVsdC5kYXRhJzondGl0bGUnXG59KS5DbGFzc1xuXG5leHBvcnRzLlNob3cgPSBuZXcgZXhwb3J0cyh7XG4gICd0ZXh0LmRhdGEnOidzaG93LnRpdGxlJ1xufSkuQ2xhc3NcblxuLy8gZXhwb3J0cy5Qcm9ncmFtID0gbmV3IGV4cG9ydHMoe1xuLy8gICAndGV4dC5kYXRhJzonZ3VpZGUuMC50aXRsZSdcbi8vIH0pLkNsYXNzXG4vLyBleHBvcnRzLlRvcGJhciA9IG5ldyBleHBvcnRzLlNob3coe1xuXG4vLyB9KSIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIEFTU0VUUyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpLnBvaW50ZXJzLmFzc2V0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAndWktdHJpdmlhJyxcbiAgJ2hlYWRlci50ZXh0JzogJ1RyaXZpYScsXG4gIGRpc3BsYXk6e1xuICAgIGRhdGE6J3RyaXZpYS50aXRsZScsXG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgcmV0dXJuIGN2ID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgIH1cbiAgfSxcbiAgYm9keToge1xuICAgIGJhY2tncm91bmQ6IHsgXG4gICAgICBkYXRhOiAnaW1nJyxcbiAgICAgIHByZXBlbmQ6IEFTU0VUU1xuICAgIH0sXG4gICAgJ3RpdGxlLnRleHQuZGF0YSc6ICd0cml2aWEudGl0bGUnLFxuICAgICdzdWJ0aXRsZS50ZXh0LmRhdGEnOiAndHJpdmlhLnN1YnRpdGxlJyxcbiAgICAnZGVzY3JpcHRpb24udGV4dC5kYXRhJzogJ3RyaXZpYS5kZXNjcmlwdGlvbidcbiAgfVxufSkuQ2xhc3NcbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxuXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcblxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxuXG52YXIgdHdlZXQgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3R3ZWV0JyxcbiAgaWNvbjogbmV3IEljb24oe2ljb246J3R3aXR0ZXInfSksXG4gIGZyb206IHsgdGV4dDogeyB2YWw6ICdAJywgYWRkOiB7IGRhdGE6ICdhdXRob3InIH0gfSB9LFxuICBtc2c6IHsgdGV4dDogeyBkYXRhOiAnYm9keScgfSB9LFxuICByZXR3ZWV0OiB7IHRleHQ6ICdSRVRXRUVUJyB9XG59KVxuXG52YXIgVHdlZXRzID0gbmV3IEVsZW1lbnQoe1xuICAgIGNzczogJ3VpLXR3ZWV0cycsXG4gICAgZGlzcGxheTp7XG4gICAgICBkYXRhOid0d2VldHMnLFxuICAgICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgICByZXR1cm4gY3YgPyAnYmxvY2snIDogJ25vbmUnXG4gICAgICB9XG4gICAgfSxcbiAgICBoZWFkZXI6IHsgdGV4dDogJ1R3ZWV0cycgfSxcbiAgICBob2xkZXJ0OiB7IC8vd2VpcmQgbmFtZS4uLi4gaG9sZGVyIGlzIGEgY2xhc3NcbiAgICAgIHNjcm9sbGJhcjogJ3gnLFxuICAgICAgYm9keToge1xuICAgICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgICAgZGF0YTogJ3R3ZWV0cycsXG4gICAgICAgICAgZWxlbWVudDogdHdlZXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gVHdlZXRzXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczondWktd2FsbHBhcGVyJ1xufSkuQ2xhc3NcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTUsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cblxucmVxdWlyZSggJy4vc3R5bGUubGVzcycgKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJyApXG4gICAgLmluamVjdCggcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXIvdHJhbnNpdGlvbnMnICkgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgY2FzZXMgPSBhcHAuY2FzZXNcbnZhciBXYWxscGFwZXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC93YWxscGFwZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgU3dpdGNoZXIoIHtcbiAgY3NzOidhcHAtc3dpdGNoZXInLFxuICBvbjoge1xuICAgIHN0YXRlOiB7IC8vc3RhdGUgbGVra2VyIGV4dGVuZGVkXG4gICAgICBkZWZlcjogZnVuY3Rpb24oIHVwZGF0ZSApIHtcbiAgICAgICAgdmFyIG9uID0gdGhpcy5fcGFyZW50XG4gICAgICAgIHZhciBzd2l0Y2hlciA9IG9uLl9jYWxsZXJcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5mcm9tLnZhbFxuICAgICAgICBcbiAgICAgICAgaWYoIHN0YXRlPT09J3NlY29uZCcgKSB7XG5cbiAgICAgICAgICBzd2l0Y2hlci50cmFuc2l0aW9uID0ge1xuICAgICAgICAgICAgZWxlbWVudDpyZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9pbmFjdGl2ZScpLFxuICAgICAgICAgICAgJHBhcmFtczp7IFxuICAgICAgICAgICAgICAkaGlnaGxpZ2h0Om9uLmhpZ2hsaWdodC5fdmFsLFxuICAgICAgICAgICAgICAkcHJldmlldzpvbi5wcmV2aWV3Ll92YWwsXG4gICAgICAgICAgICAgICRtZWRpYTphcHAudXNlci5yZWNlaXZlci5tZWRpYSxcbiAgICAgICAgICAgICAgJHBhZ2U6b24ubmF2aWdhdGlvbi5fdmFsLnBhZ2UsXG4gICAgICAgICAgICAgICRjb250ZW50Om9uLm5hdmlnYXRpb24uX3ZhbC5jb250ZW50LFxuICAgICAgICAgICAgICBuYXZpZ2F0aW9uOntcbiAgICAgICAgICAgICAgICBkYXRhOmFwcC5jb250ZW50LmdldCgnZGlzY292ZXInKSxcbiAgICAgICAgICAgICAgICAkZm9jdXM6b24uZm9jdXMuX3ZhbCxcbiAgICAgICAgICAgICAgICBjb250YWluZXI6e1xuICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3M6e1xuICAgICAgICAgICAgICAgICAgICBkYXRhOm9uLnByZXZpZXcuX3ZhbFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyAkcHJvZ3Jlc3M6YXBwLnByb2dyZXNzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmKCBzdGF0ZT09PSdmaXJzdCcgKSB7XG5cbiAgICAgICAgICBzd2l0Y2hlci50cmFuc2l0aW9uID0ge1xuICAgICAgICAgICAgZWxlbWVudDpyZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9hY3RpdmUnKSxcbiAgICAgICAgICAgICRwYXJhbXM6e1xuICAgICAgICAgICAgICBtZW51OiB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbjogYXBwLnVzZXIubmF2aWdhdGlvblxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBvbjp7XG4gICAgICAgICAgICAgICAgZm9jdXM6b24uZm9jdXMuX3ZhbCxcbiAgICAgICAgICAgICAgICBwb3B1cDpvbi5wb3B1cC5fdmFsLFxuICAgICAgICAgICAgICAgIHNlY29uZFBvcHVwOm9uLnNlY29uZFBvcHVwLl92YWxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaG9sZGVyOntcbiAgICAgICAgICAgICAgICB0b3BiYXI6e1xuICAgICAgICAgICAgICAgICAgJGN1cnJlbnQ6IGFwcC5jdXJyZW50LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3dpdGNoZXI6e1xuICAgICAgICAgICAgICAgICAgbmF2aWdhdGlvbjogYXBwLnVzZXIubmF2aWdhdGlvblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWluaXBsYXllcjp7XG4gICAgICAgICAgICAgICAgICBtZWRpYTphcHAudXNlci5yZWNlaXZlci5tZWRpYSxcbiAgICAgICAgICAgICAgICAgIHBsYXlpbmc6YXBwLnVzZXIucmVjZWl2ZXIucGxheWluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYoIHN0YXRlID09PSAnaW5hY3RpdmUnKXtcbiAgICAgICAgXG4gICAgICAgICAgc3dpdGNoZXIudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6V2FsbHBhcGVyLFxuICAgICAgICAgICAgJHBhcmFtczp7fVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG9uVHJhbnNpdGlvbjonZmFkZSdcbn0gKS5DbGFzc1xuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNSwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xuZXhwb3J0cy5mb2N1c2VkID0gZnVuY3Rpb24oIGhvbGRlciwgZm9jdXNlZCwgbWV0aG9kICkge1xuICBpZiAoIGZvY3VzZWQgKSB7XG4gICAgXG4gICAgdmFyIHByZXZpb3VzID0gaG9sZGVyLl9mb2N1c2VkXG5cbiAgICBpZiAoIHByZXZpb3VzICE9PSBmb2N1c2VkICkge1xuXG4gICAgICBpZiAoIHByZXZpb3VzICkge1xuICAgICAgICBwcmV2aW91cy5jc3MgPSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3M6ICdmb2N1c2VkJ1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzLiRmb2N1c2VkID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgZm9jdXNlZC5jc3MgPSB7XG4gICAgICAgIGFkZENsYXNzOiAnZm9jdXNlZCdcbiAgICAgIH1cblxuICAgICAgZm9jdXNlZC4kZm9jdXNlZCA9IHRydWVcblxuICAgICAgaWYgKCBtZXRob2QgKSBtZXRob2QoIGZvY3VzZWQsIHByZXZpb3VzIClcblxuICAgICAgaG9sZGVyLl9mb2N1c2VkID0gZm9jdXNlZFxuICAgIH1cblxuICB9XG59XG5cbmV4cG9ydHMucHJldmVudEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBfdGhpcywgbWV0aG9kLCBkb25lICl7XG4gIF90aGlzLl9ibG9ja2VkID0gdHJ1ZVxuICBfdGhpcy5jc3MgPSB7YWRkQ2xhc3M6J2RvbnRBbmltYXRlJ31cbiAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgIG1ldGhvZCgpXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgICAgX3RoaXMuY3NzID0ge3JlbW92ZUNsYXNzOidkb250QW5pbWF0ZSd9XG4gICAgICBfdGhpcy5fYmxvY2tlZCA9IG51bGxcbiAgICAgIGlmKCBkb25lICkgZG9uZSgpXG4gICAgfSlcbiAgfSlcbn0iLCJ2YXIgYXBwID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvYXBwJylcbnZhciB1cmwgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL3VybCcpXG52YXIgdWEgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci91YScpXG52YXIgZGV2aWNlID0gdXJsLnBhcmFtcy5kZXZpY2UgJiYgdXJsLnBhcmFtcy5kZXZpY2UudmFsIHx8IHVhLmRldmljZVxuXG52YXIgY2xpZW50aW5mbyA9IHtcbiAgcGhvbmU6IHtcbiAgICB0aXRsZTogJ0tldmluXFwncyBpUGhvbmUnLFxuICAgIGluZm86ICdpUGhvbmUgNidcbiAgfSxcbiAgdGFibGV0OiB7XG4gICAgdGl0bGU6ICdLZXZpblxcJ3MgaVBhZCcsXG4gICAgaW5mbzogJ2lQYWQgMicsXG4gICAgZGV2aWNlOiAndGFibGV0J1xuICB9LFxuICB0djoge1xuICAgIHRpdGxlOiAnU2hhcnAnLFxuICAgIGluZm86ICc1MlwiIExFRCBUVicsXG4gICAgZGV2aWNlOiAndHYnXG4gIH0sXG4gIElGRToge1xuICAgIHRpdGxlOiAnVW5pdGVkIEFpcmxpbmVzJyxcbiAgICBpbmZvOiAnSW4gRmxpZ2h0IEVudGVydGFpbm1lbnQnLFxuICAgIGRldmljZTogJ0lGRSdcbiAgfSxcbiAgZGVmOiB7XG4gICAgdGl0bGU6IHVhLnBsYXRmb3JtKycgJytkZXZpY2UsXG4gICAgaW5mbzogdWEucGxhdGZvcm0rJyAnK2RldmljZSxcbiAgICBkZXZpY2U6ZGV2aWNlXG4gIH1cbn1cblxuYXBwLmNsb3VkLmNsaWVudC52YWwgPSBjbGllbnRpbmZvW2RldmljZV0gfHwgY2xpZW50aW5mby5kZWYiLCJyZXF1aXJlKCcuL3VhaGFjaycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvYXBwJylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3N3aXRjaGVyJylcbnZhciB1c2VyID0gYXBwLnVzZXJcblxuaWYoYXBwLmNhc2VzLiRpc05hdGl2ZSl7XG4gIHZhciBzdGF0dXNCYXIgPSByZXF1aXJlKCd2aWdvdXItbmF0aXZlLXN0YXR1c0JhcicpXG4gIHN0YXR1c0Jhci5zZXQoe1xuICAgIHN0eWxlOidsaWdodCcsXG4gICAgdmlzaWJpbGl0eTonb3ZlcmxheSdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIGFsZXJ0KFwiZXJyb3Igc2V0dGluZyBzdGF0dXNCYXI6IFwiICtlcnIpXG4gIH0pXG59XG5cbi8vIHN3aXRjaGVyIGJldHdlZW4gZmlyc3Qvc2Vjb25kL3BsYXllclxuXG4vLyBhcHAucmVhZHkub25jZSh0cnVlLGZ1bmN0aW9uKCl7XG5cbnJlcXVpcmUoJy4vY2xpZW50aGFjaycpXG5cbi8vIGFwcC5yZWFkeS5vbmNlKHRydWUsZnVuY3Rpb24oKXtcbi8vIGFsZXJ0KCd4JylcbmFwcC5zZXQoe1xuICBzd2l0Y2hlcjogbmV3IFN3aXRjaGVyKCB7XG4gICAgb246IHtcbiAgICAgIG5hdmlnYXRpb246IHVzZXIubmF2aWdhdGlvbixcbiAgICAgIHBsYXk6IGFwcC5wbGF5aW5nLFxuICAgICAgcmVjZWl2ZXI6IHVzZXIucmVjZWl2ZXIsXG4gICAgICB1c2FnZTogdXNlci51c2FnZSxcbiAgICAgIGNvbnRlbnQ6IGFwcC5jb250ZW50LFxuICAgICAgc2VhcmNoOiB1c2VyLnNlYXJjaCxcbiAgICAgIGZvY3VzOiB1c2VyLmZvY3VzX3JvdyxcbiAgICAgIHByZXZpZXc6IGFwcC5wcmV2aWV3LFxuICAgICAgaGlnaGxpZ2h0OiBhcHAuaGlnaGxpZ2h0LFxuICAgICAgcG9wdXA6YXBwLnBvcHVwLFxuICAgICAgc2Vjb25kUG9wdXA6YXBwLnNlY29uZFBvcHVwLFxuICAgICAgLy9uYXYgd29yZCBkaWZmZXJlbnRcbiAgICAgIC8vIHdhdGNoZWQ6IHVzZXIud2F0Y2hlZC5mcm9tLFxuICAgICAgc3RhdGU6IGFwcC5zdGF0ZSxcbiAgICAgIG92ZXJsYXk6IGFwcC5vdmVybGF5LFxuICAgICAgbG9hZGluZzogYXBwLmxvYWRpbmcsXG4gICAgICBhY3RpdmVDbGllbnQ6IHVzZXIuYWN0aXZlQ2xpZW50LFxuICAgICAgdm9sdW1lOiBhcHAudm9sdW1lXG4gICAgfVxuICB9KVxufSlcblxuLy8gVE9ETzogcmVuYW1lIGFwcC5pbml0aWFsaXplZD9cblxuLy8gYXBwLnBvcHVwLnZhbCA9ICdhY3Rvcidcbi8vIGFwcC5tZW51LnZhbCA9IHRydWVcbi8vIH0pXG5cbmFwcC5pbml0aWFsaXNlZC52YWwgPSB0cnVlXG5cblxuLy8gYXBwLnJlYWR5LmlzKHRydWUsZnVuY3Rpb24oKXtcbi8vICAgYXBwLnNlY29uZFBvcHVwLnZhbCA9ICd2b2x1bWUnXG4vLyB9LHRydWUpIiwidmFyIHVhID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvdWEnKVxudmFyIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKVxuXG5jb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLS0tLSB1YSBoYWNraW5nIHRoYXQhJywgdWEpXG5cblxuaWYodWEuZGV2aWNlID09PSAnZGVza3RvcCcpIHtcbiAgdWEuZGV2aWNlID0gJ3R2J1xuICB1YS5wbGF0Zm9ybSA9ICdmYW5jeSdcbiAgY2FzZXMuJGlzRGVza3RvcCA9IGZhbHNlXG4gIGNhc2VzLiRpc1R2ID0gdHJ1ZVxuICB3aW5kb3cuSU5BQ1RJVkUgPSB0cnVlXG59IGVsc2UgaWYodWEuZGV2aWNlID09PSAnaXBhZCcpIHtcbiAgd2luZG93LklOQUNUSVZFID0gdHJ1ZVxuXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XCJuYW1lXCI6XCJkaXJlY3R2LWZsXCIsXCJ2ZXJzaW9uXCI6XCIyMDE1LzA2LzEzIDE1OjAyOjUyIFVUQyAoMS4wLjUpXCIsXCJkZXNjcmlwdGlvblwiOlwiXCIsXCJtYWluXCI6XCJpbmRleC5qc1wiLFwic2NyaXB0c1wiOntcInN0YXJ0R2FzdG9uXCI6XCIuL25vZGVfbW9kdWxlcy8uYmluL2dhc3RvbiBkZXZcIixcInN0YXJ0XCI6XCJucG0gcnVuIHN0YXJ0R2FzdG9uXCIsXCJ0ZXN0XCI6XCJlY2hvIFxcXCJFcnJvcjogbm8gdGVzdCBzcGVjaWZpZWRcXFwiICYmIGV4aXQgMVwiLFwic3ltbGlua1wiOlwibWtkaXIgLXAgbm9kZV9tb2R1bGVzOyBsbiAtc2YgJChwd2QpICQocHdkKS9ub2RlX21vZHVsZXNcIixcInN0YXJ0SHViXCI6XCIuL25vZGVfbW9kdWxlcy92aWdvdXItaHViL2Jpbi9odWIgLWQgLWMgZGlyZWN0dlwiLFwicHJlc3RhcnRcIjpcIm5wbSBydW4gc3RhcnRIdWIgJlwiLFwiYnVpbGRcIjpcInZOYXRpdmUgYnVpbGRcIixcInJlbGVhc2VcIjpcInBhY2tlciAtciAtYyBwYWNrYWdlLmpzb24sLnBhY2thZ2UuanNvblwifSxcInJlcG9zaXRvcnlcIjp7XCJ0eXBlXCI6XCJnaXRcIixcInVybFwiOlwiaHR0cHM6Ly9naXRodWIuY29tL3ZpZ291ci1pby9kaXJlY3R2LWZsLmdpdFwiLFwiYnJhbmNoXCI6XCJwcm9kdWN0aW9uXCJ9LFwiYXV0aG9yXCI6XCJWaWdvdXJcIixcImJ1Z3NcIjp7XCJ1cmxcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vZGlyZWN0di1mbC9pc3N1ZXNcIn0sXCJob21lcGFnZVwiOlwiaHR0cHM6Ly9naXRodWIuY29tL3ZpZ291ci1pby9kaXJlY3R2LWZsXCIsXCJkZXBlbmRlbmNpZXNcIjp7XCJ0aHJvdWdoMlwiOlwiKlwiLFwibG9kYXNoXCI6XCIzLjIuMFwiLFwibW9ub3RvbmljLXRpbWVzdGFtcFwiOlwiMC4wLjlcIixcInByb21pc2VcIjpcIl43LjAuMVwiLFwidmlnb3VyLWpzXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb206dmlnb3VyLWlvL3ZpZ291ci1qcy5naXQjZGlyZWN0dlwifSxcImRldkRlcGVuZGVuY2llc1wiOntcInZpZ291ci1uYXRpdmVcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbTp2aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS5naXRcIixcInZpZ291ci1uYXRpdmUtc3RhdHVzQmFyXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb206dmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyLmdpdFwiLFwidmlnb3VyLXBhY2tlci1zZXJ2ZXJcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbTp2aWdvdXItaW8vdmlnb3VyLXBhY2tlci1zZXJ2ZXIuZ2l0XCIsXCJ2aWdvdXItaHViXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb206dmlnb3VyLWlvL3ZpZ291ci1odWIuZ2l0I2RpcmVjdHZcIixcImdhc3RvblwiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tOnZpZ291ci1pby9nYXN0b24uZ2l0XCJ9LFwidmlnb3VyXCI6e1wiY2xvdWRcIjpcImh0dHA6Ly81Mi44LjIzLjQ1OjgwXCIsXCJkZXZlbG9wbWVudFwiOntcImJ1dHRvblwiOmZhbHNlfSxcInBvaW50ZXJzXCI6e1wiYXNzZXRzXCI6XCJodHRwOi8vZGV2YXNzZXRzLnZpZ291ci5pby9cIn0sXCJwYWNrZXJcIjp7XCJ3ZWJcIjpcImluZGV4Lmh0bWxcIixcImFzc2V0c1wiOntcImJ1bmRsZS5qc1wiOnRydWUsXCJidW5kbGUuY3NzXCI6dHJ1ZSxcImluZGV4Lmh0bWxcIjp0cnVlLFwiYXNzZXRzXCI6XCIqXCIsXCJmb250cy5jc3NcIjp0cnVlfSxcImdpdFwiOntcIm93bmVyXCI6XCJ2aWdvdXItaW9cIixcInJlcG9cIjpcImRpcmVjdHYtZmxcIn0sXCJtYWlsXCI6e1wiZnJvbUFkZHJlc3NcIjpcInNoYXduQHZpZ291ci5pb1wiLFwidG9cIjpcInNoYXduQHZpZ291ci5pb1wifSxcInNsYWNrXCI6e30sXCJzZXJ2ZXJcIjp7fX0sXCJuYXRpdmVcIjp7XCJwbGF0Zm9ybXNcIjp7XCJpb3NcIjp7XCJwcm9kdWN0TmFtZVwiOlwiRFRWIC0gSW4gRmxpZ2h0XCIsXCJvcmdhbml6YXRpb25OYW1lXCI6XCJWaWdvdXJcIixcIm9yZ2FuaXphdGlvbklkZW50aWZpZXJcIjpcImlvLnZpZ291ci5kaXJlY3R2LWZsXCIsXCJidWlsZE51bWJlclwiOlwiMVwiLFwiYXBwSW5kZXhQYXRoXCI6XCJpbmRleC5odG1sXCIsXCJhcHBVcmxJZGVudGlmaWVyXCI6XCJjb20uZGlyZWN0di1mbC5vcmdcIixcImFwcFVybFNjaGVtZVwiOlwiZGlyZWN0di1mbFwifX19LFwiYnJhbmNoZXNcIjp7XCJtYXN0ZXJcIjp7XCJwb2ludGVyc1wiOntcImltZ1wiOlwiaHR0cDovL2ppbS5sb2NhbC9hc3NldHMvXCIsXCJhc3NldHNcIjpcImh0dHA6Ly9qaW0ubG9jYWwvYXNzZXRzL1wifX0sXCJ5b3V6aS1kZXZcIjp7XCJwb2ludGVyc1wiOntcImltZ1wiOlwiaHR0cDovL2ppbS5sb2NhbC9hc3NldHMvXCIsXCJhc3NldHNcIjpcImh0dHA6Ly9qaW0ubG9jYWwvYXNzZXRzL1wifX0sXCJtYXJjdXMtZGV2XCI6e1wiY2xvdWRcIjpcImh0dHA6Ly9sb2NhbGhvc3Q6MTAwMDFcIixcInVzY2xvdWRcIjpcImh0dHA6Ly81NC4xNzMuMTkyLjU3OjEwMDAxXCJ9LFwic2hhd24tZGV2XCI6e1wiY2xvdWRcIjpcImh0dHA6Ly8xOTIuMTY4LjIuMTg6MTAwMDFcIn0sXCJwcm9kdWN0aW9uXCI6e1wiY2xvdWRcIjpcImh0dHA6Ly81Mi44LjIzLjQ1OjgwXCIsXCJuYXRpdmVcIjp7XCJwbGF0Zm9ybXNcIjp7XCJpb3NcIjp7XCJwcm9kdWN0TmFtZVwiOlwiRFRWIC0gSW4gRmxpZ2h0XCJ9fX19LFwiYWlycGxhbmVcIjp7XCJjbG91ZFwiOlwiaHR0cDovLzUyLjguNDAuMTk1OjgwXCIsXCJuYXRpdmVcIjp7XCJwbGF0Zm9ybXNcIjp7XCJpb3NcIjp7XCJwcm9kdWN0TmFtZVwiOlwiRFRWIERFTU8gLSBJbiBGbGlnaHRcIn19fX0sXCJsaXZpbmdyb29tXCI6e1wiY2xvdWRcIjpcImh0dHA6Ly9kaXJlY3R2LWZsLWRlbW8ubG9jYWw6MTAwMDFcIixcInBvaW50ZXJzXCI6e1wiYXNzZXRzXCI6XCJodHRwOi8vZGlyZWN0di1mbC1kZW1vLmxvY2FsL1wifSxcIm5hdGl2ZVwiOntcInBsYXRmb3Jtc1wiOntcImlvc1wiOntcInByb2R1Y3ROYW1lXCI6XCJEVFYgREVNTyAtIEhvbWVcIn19fX19fSxcImdhc3RvblwiOntcImJyb3dzZXJpZnktdHJhbnNmb3Jtc1wiOlt7XCJwYXRoXCI6XCJ2aWdvdXItanMvdXRpbC9pbmZvcm0tdHJhbnNmb3JtXCIsXCJvcHRpb25zXCI6e1wiZ2xvYmFsXCI6XCJmYWxzZVwifX1dLFwicmVxdWlyZS1wYXRoc1wiOntcImR0dlwiOlwic3JjXCIsXCJzaGFyZWRcIjpcInNyYy9jb21wb25lbnRzL3NoYXJlZFwiLFwiZHR2LWNvbXBvbmVudHNcIjpcInNyYy9jb21wb25lbnRzXCIsXCJkdHYtYWN0aXZlXCI6XCJzcmMvY29tcG9uZW50cy9hY3RpdmVcIixcImR0di1pdGVtXCI6XCJzcmMvY29tcG9uZW50cy9hY3RpdmUvY29udGVudC1pdGVtXCIsXCJkdHYtY2hhbm5lbFwiOlwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2NvbnRlbnQtaXRlbS9jaGFubmVsXCIsXCJkdHYtZXBpc29kZVwiOlwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2NvbnRlbnQtaXRlbS9lcGlzb2RlXCIsXCJkdHYtbW92aWVcIjpcInNyYy9jb21wb25lbnRzL2FjdGl2ZS9jb250ZW50LWl0ZW0vbW92aWVcIn19LFwic2hhXCI6XCIxLjAuNVwifSJdfQ==
