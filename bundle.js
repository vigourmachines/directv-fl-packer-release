require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/shawn/Work/directv-fl/config.js":[function(require,module,exports){
window.name = 'directv-fl'

// window.package = require('package.json')
// console.log('wtf...', window.package)

module.exports = exports = require( 'vigour-js/util/config' )
              .inject
              ( { 'repository.branch': 'branches' }
              , require( 'vigour-js/util/config/ua' )
              )

exports( function( result ) {
  for(var key in result) {
    // console.log('\n', i, result[i])
    exports[key] = result[key] 
  }
  exports.parsed = true

}, false, window.package, true )
},{"vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js","vigour-js/util/config/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/ua.js"}],"/Users/shawn/Work/directv-fl/index.js":[function(require,module,exports){
window.package = require('package.json');
var config = require('/Users/shawn/Work/directv-fl//config')
  , remote

if( config.development && config.development.button )
{
  remote = require( 'vigour-js/util/debug' )
            .native( false, false, function(url) {} , 'bundle' )
}

if( !remote ) 
{
  var cases = require( 'vigour-js/browser/cases' )
    , ua = require( 'vigour-js/browser/ua' )

  // if(ua.device === 'tablet'){
  //   var viewport = document.querySelector("meta[name=viewport]")
  //   viewport.setAttribute('content', 'width=device-width, initial-scale=0.6, maximum-scale=1.0, user-scalable=0');
  // }

  require( './src/main' )
  
}
},{"./src/main":"/Users/shawn/Work/directv-fl/src/main/index.js","/Users/shawn/Work/directv-fl//config":"/Users/shawn/Work/directv-fl/config.js","package.json":"package.json","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/util/debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/domain-browser/index.js":[function(require,module,exports){
/*global define:false require:false */
module.exports = (function(){
	// Import Events
	var events = require('events')

	// Export Domain
	var domain = {}
	domain.createDomain = domain.create = function(){
		var d = new events.EventEmitter()

		function emitError(e) {
			d.emit('error', e)
		}

		d.add = function(emitter){
			emitter.on('error', emitError)
		}
		d.remove = function(emitter){
			emitter.removeListener('error', emitError)
		}
		d.bind = function(fn){
			return function(){
				var args = Array.prototype.slice.call(arguments)
				try {
					fn.apply(null, args)
				}
				catch (err){
					emitError(err)
				}
			}
		}
		d.intercept = function(fn){
			return function(err){
				if ( err ) {
					emitError(err)
				}
				else {
					var args = Array.prototype.slice.call(arguments, 1)
					try {
						fn.apply(null, args)
					}
					catch (err){
						emitError(err)
					}
				}
			}
		}
		d.run = function(fn){
			try {
				fn()
			}
			catch (err) {
				emitError(err)
			}
			return this
		};
		d.dispose = function(){
			this.removeAllListeners()
			return this
		};
		d.enter = d.exit = function(){
			return this
		}
		return d
	};
	return domain
}).call(this)
},{"events":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/events/events.js"}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/os-browserify/browser.js":[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/support/isBufferBrowser.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","inherits":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js":[function(require,module,exports){
// If `Date.now()` is invoked twice quickly, it's possible to get two
// identical time stamps. To avoid generation duplications, subsequent
// calls are manually ordered to force uniqueness.

var _last = 0
var _count = 1
var adjusted = 0
var _adjusted = 0

module.exports =
function timestamp() {
  /**
  Returns NOT an accurate representation of the current time.
  Since js only measures time as ms, if you call `Date.now()`
  twice quickly, it's possible to get two identical time stamps.
  This function guarantees unique but maybe inaccurate results
  on each call.
  **/
  //uncomment this wen
  var time = Date.now()
  //time = ~~ (time / 1000) 
  //^^^uncomment when testing...

  /**
  If time returned is same as in last call, adjust it by
  adding a number based on the counter. 
  Counter is incremented so that next call get's adjusted properly.
  Because floats have restricted precision, 
  may need to step past some values...
  **/
  if (_last === time)  {
    do {
      adjusted = time + ((_count++) / (_count + 999))
    } while (adjusted === _adjusted)
    _adjusted = adjusted
  }
  // If last time was different reset timer back to `1`.
  else {
    _count = 1
    adjusted = time
  }
  _adjusted = adjusted
  _last = time
  return adjusted
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/promise/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./lib')

},{"./lib":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js":[function(require,module,exports){
'use strict';

var asap = require('asap/raw');

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

module.exports = Promise;

function Promise(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('not a function');
  }
  this._32 = 0;
  this._8 = null;
  this._89 = [];
  if (fn === noop) return;
  doResolve(fn, this);
}
Promise._83 = noop;

Promise.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
};
function handle(self, deferred) {
  while (self._32 === 3) {
    self = self._8;
  }
  if (self._32 === 0) {
    self._89.push(deferred);
    return;
  }
  asap(function() {
    var cb = self._32 === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._32 === 1) {
        resolve(deferred.promise, self._8);
      } else {
        reject(deferred.promise, self._8);
      }
      return;
    }
    var ret = tryCallOne(cb, self._8);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}
function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(
      self,
      new TypeError('A promise cannot be resolved with itself.')
    );
  }
  if (
    newValue &&
    (typeof newValue === 'object' || typeof newValue === 'function')
  ) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (
      then === self.then &&
      newValue instanceof Promise
    ) {
      self._32 = 3;
      self._8 = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._32 = 1;
  self._8 = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._32 = 2;
  self._8 = newValue;
  finale(self);
}
function finale(self) {
  for (var i = 0; i < self._89.length; i++) {
    handle(self, self._89[i]);
  }
  self._89 = null;
}

function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return;
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) return;
    done = true;
    reject(promise, reason);
  })
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

},{"asap/raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/done.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this;
  self.then(null, function (err) {
    setTimeout(function () {
      throw err;
    }, 0);
  });
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/es6-extensions.js":[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js');
var asap = require('asap/raw');

module.exports = Promise;

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new Promise(Promise._83);
  p._32 = 1;
  p._8 = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) return value;

  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._32 === 3) {
            val = val._8;
          }
          if (val._32 === 1) return res(i, val._8);
          if (val._32 === 2) reject(val._8);
          val.then(function (val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","asap/raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/finally.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype['finally'] = function (f) {
  return this.then(function (value) {
    return Promise.resolve(f()).then(function () {
      return value;
    });
  }, function (err) {
    return Promise.resolve(f()).then(function () {
      throw err;
    });
  });
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./core.js');
require('./done.js');
require('./finally.js');
require('./es6-extensions.js');
require('./node-extensions.js');

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","./done.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/done.js","./es6-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/es6-extensions.js","./finally.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/finally.js","./node-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/node-extensions.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/node-extensions.js":[function(require,module,exports){
'use strict';

// This file contains then/promise specific extensions that are only useful
// for node.js interop

var Promise = require('./core.js');
var asap = require('asap');

module.exports = Promise;

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity;
  return function () {
    var self = this;
    var args = Array.prototype.slice.call(arguments);
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop();
      }
      args.push(function (err, res) {
        if (err) reject(err);
        else resolve(res);
      })
      var res = fn.apply(self, args);
      if (res &&
        (
          typeof res === 'object' ||
          typeof res === 'function'
        ) &&
        typeof res.then === 'function'
      ) {
        resolve(res);
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var callback =
      typeof args[args.length - 1] === 'function' ? args.pop() : null;
    var ctx = this;
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx);
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      } else {
        asap(function () {
          callback.call(ctx, ex);
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this;

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value);
    });
  }, function (err) {
    asap(function () {
      callback.call(ctx, err);
    });
  });
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-asap.js":[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-raw.js":[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.jss
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js":[function(require,module,exports){
(function (process){
"use strict";

var domain; // The domain module is executed on demand
var hasSetImmediate = typeof setImmediate === "function";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to exit the domain, because domains exist on a stack.
    // To execute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy execute the domain module.
            // Only employed if the user elects to use domains.
            domain = require("domain");
        }
        domain.active = process.domain = null;
    }

    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.nextTick` started throwing recursion errors.
    if (flushing && hasSetImmediate) {
        setImmediate(flush);
    } else {
        process.nextTick(flush);
    }

    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}

}).call(this,require('_process'))

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","domain":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/domain-browser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js":[function(require,module,exports){
var Cloud = require('vigour-js/browser/network/cloud')
    .inject(
      require('vigour-js/browser/network/cloud/datacloud'),
      require('vigour-js/browser/network/cloud/authenticate')
    ),
  Value = require('vigour-js/value'),
  Data = require('vigour-js/data'),
  util = require('vigour-js/util'),
  cases = require('vigour-js/browser/cases'),
  ua = require('vigour-js/browser/ua'),
  raf = require('vigour-js/browser/animation/raf')

// var semver = require('vigour-js/util/semver')

require('vigour-js/value/flags/process') // mustbecome injectable on object ( all these extension should be located seperately )

function setClientInfo (cloud, base) {
  // todo: move client to cloud
  
  var oldclient = cloud.client.from.raw
  var obj = oldclient 
    ? { 
        title: oldclient.title,
        device: oldclient.device,
        info: oldclient.info
      }
    : {}
  filterEmpty(obj)

  var client = cloud.data.get(['clients', cloud.clientid]),
    title, device, castId

  var info = cases.touch 
    ? ua.device + ' ' + 
      ( ua.platform === 'ios' ? 'iOS' : ua.platform ) +
      ( ua.version ? ' ' + ua.version : '' )
    : ua.platform + ' ' + ua.browser + ' ' + ua.version

  if (cases.$isIos) {
    title = ua.device === 'phone' ? 'iphone' : 'ipad'
    device = ua.device
  } else {
    if (ua.platform === 'appletv') {
      title = 'Apple TV'
      device = 'cast'
    } else if (cases.$isChromecast) {
      title = 'Chromecast'
      device = 'cast'
      castId = window.sessionId
    } else {
      device = ua.device
      title = cases.$isDesktop ? ua.platform : ua.platform + ' ' + device
    }
  }

  util.merge( obj, {
    title: title,
    device: device,
    info: info
  }, false, false )

  if (castId) {
    obj.castId = castId || false
  }

  // client.merge(obj, false, false)
  client.val = obj
  cloud.client.val = client

  // DEBUG LOGS: 
  // cloud.client.on(function(val, stamp, from){
  //   // console.log('\n\n\n\nupdate kenker', val, from)
  //   var origin = from || this._updateOrigin
  //   if(val && val.token || (origin && origin._name === 'token')) {
  //     console.error('TOKENSETTOKENSETTOKENSET', val && (val.token || val) )
  //   }
  // })

  // user.clientUserToken = user.client.from.get('userToken') deze is duidelijk fucked up and has to be fixed
}

exports.extend = util.extend( require('./values'), function (base) {
  var _cloud = new Cloud(new Value())
    , _first //= true
  
  cases.$isConnected = new Value( _cloud.connected )

  // todo: move to cloud
  _cloud.client = new Value()

  _cloud.once('welcome', function (id) {
    setClientInfo(_cloud, base)
  })

  // _cloud.on('reconnect',)
  // console.error('>>> adding reconnect listener')
  _cloud.on('reconnect', function() {
    // console.log('>>>> reconnect set up reset client info!', _cloud.client.from.raw)
    var setObj = {}
    _cloud.client.from.each(function(i) {
      if(i !== 'key' && i !== 'type' && i !== 'ip'){
        setObj[i] = this._val
      }
    })
    _cloud.client.from.on('remove', function() {
      if(Object.keys(setObj).length) {
        // console.log('reset dat client info', setObj)
        _cloud.data.clients.set(_cloud.clientid, setObj)
      }
    })
  })

  base.define({
    cloud: {
      get: function () {
        return _cloud
      },
      set: function (val) {
        if (util.isObj(val)) {
          if (val.fastLogin) {
            _cloud.fastLogin.val = true
          }

          if (val.api) {
            _cloud.api.val = val.api
          }

          if (val.url) {
            _cloud.url.val = val.url
          }
        } else {
          _cloud.url.val = val
        }
      }
    }
  })

  var _version = new Data( _cloud.data.get('app'), { subscription: { $:true } } )

  //semvar -- APP VERSION DOES NOT WORK!
  base.versionData = new Value({
    val: _version,
    defer: function(update, args) {
      var doUpdate
      var t
      if(this.from.version) {
        console.log('hey hey hey')
        if( !window.package ) 
        {
          console.error( 'no window package', window.package )
        }
        else 
        {
          var newversion = this.from.version.val
            , oldversion = window.package.version

          if(newversion && oldversion) {
            newversion = newversion.split('.')
            oldversion = oldversion.split('.')
            newversion = Number(newversion[1])
            oldversion = Number((oldversion[1]||0))
            if( newversion > oldversion ) {
              doUpdate = true
              this.clearCache()
              window.package.version = this.from.version.val
            }
          }
        }
      } 
      update( doUpdate ? void 0 : true )
    }
  })

})


function filterEmpty(obj) {
  for(var f in obj) {
    if(obj[f] === void 0) {
      delete obj[f]
    }
  }
}

},{"./values":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/network/cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/index.js","vigour-js/browser/network/cloud/authenticate":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/authenticate.js","vigour-js/browser/network/cloud/datacloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/datacloud.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js":[function(require,module,exports){
var Value = require('../value')
  , CloudData = require( '../browser/network/cloud/data' )
  , util = require('../util')
  , vObj = require('../object')


util.define
( CloudData
, '_contentPath'
, { get: function() {
      var p = this._path
      for(var i in p ) {
        if( p[i] === 'shows' || p[i] === 'channels' ) {
          return p.slice( i )
        }
      }

      console.error('_contentPath used on non-content data', this, p)
      // throw new Error('_contentPath used on non-content data')
      // return this._path.slice( base.instances[0].data.from._path.length )
    }
  }
)

util.define(
  vObj
, '_contentType'
, { get:function() {
      var from = this.from
      if( from.cloud && from._parent ) return from._parent._name
    }
  }
)

exports.extend = util.extend( 
  require('./values')
, require('./cloud')
, function( app ) {
    var content = app.content = new Value({})
    // var get = Value.prototype.get
    util.define(content, 'get', function(){
        if( this._val && this._val.cloud ) { 
          return this._val.get.apply(this._val, arguments) 
        } else { 
          throw new Error( 'app.content , dont have cloud data!') 
        }
      })

    app.region.on(onChange)
    app.language.on(onChange)

    onChange()

    function onChange(){
      var region = app.region.val
        , language = app.language.val

      //TODO:make this configurable in the app
      if(language==='it') {
        language = 'en'
      }

      if(region && language){
        //TODO: make mtvData configurable
        // content.val = app.cloud.data.get(['mtvData', region, language])

        // content.val = app.cloud.data

      }
      content.val = app.cloud.data
    }
    
  }
)

},{"../browser/network/cloud/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","./cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js","./values":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * 
 * could think of something so style requires are parsed optionaly
 * maybe in vigour-js use dynamic script tags and parse those /w gaston if you are using gaston
 * this will make it more usable for others in the future and makes it compatible with pure browserify
 */

require('./style.less')
require('vigour-js/browser/animation/easing')

var Element = require('./ui/element')
  , cases = require('vigour-js/browser/cases')
  , animation = require('vigour-js/browser/animation')
  , events = require('vigour-js/browser/events/advanced')
  , ua = require('vigour-js/browser/ua')
  , raf = require('vigour-js/browser/animation/raf')
  , eventUtils = require('vigour-js/browser/events/util')
  , app
  , _ios = ua.platform==='ios'
  , _windows = ua.platform === 'windows'
  , arr = ['phone','tablet','tv','desktop','ios','android','windows','mac','$hasTouch','slow','chromecast'] //maybe make this configrable
  //ui/cases --
  , i = arr.length - 1

//hier process in requiren en added 'appStart' ofzoiets dergelijks
//add ook process aan base dingen dan word iets pas geadd na een bepaalde process update
//ultra mofo powerfull

cases.$isIosBrowser = _ios && ( 'standalone' in navigator && !navigator.standalone )
cases.$isIosFull = (!cases.$isIosBrowser&&_ios) || ((_ios || _windows) && !!window.cordova) || false
cases.$isRetina = window.devicePixelRatio > 1
cases.$isSlow = (_windows && ua.device === 'phone') || (ua.noRaf&&ua.hasTransition) || _ios && (window.screen.height === (960 / 2)) || ua.device === 'tv'
cases.$isNative = window.cordova ? true : false
cases.$isWindowsMobile = ua.platform === 'windows' && ua.device === 'phone' && !!window.cordova
cases.$isPhoneBrowser = ua.device === 'phone' && !( cases.$isNative || cases.$isIosFull )
//packer case voor web // native

app = module.exports = new Element({
  'x,y':{val:0,clean:true,translate:true}
, node: document.body
, w: window.innerWidth
, h: window.innerHeight
, css: 'app'
})

//if(cases.$isiosFull) {
  // app.y = {add:20}
  // app.h = {sub:20}
//}

var listener = function() {
//   console.log('resize!!','w:',window.innerWidth,'h:',window.innerHeight,'block?:',app.blockResize)
  if(!app.blockResize) {
    // animation.prevent = true
    app.w.val = window.innerWidth
    app.h.val = window.innerHeight
    // animation.prevent = false
  } else {
    app.blockResize = false
  }
}

function defaultCase(str) {
  if(str !== '$hasTouch'){
    var cssStr =  's' + str.charAt(0).toUpperCase() + str.slice(1);
    var caseStr = '$i' + cssStr
    if(cases[caseStr]===void 0) {
      cases[caseStr] = (ua.device === str || ua.platform === str) ? true : false
    }
    app.css = {addClass:cases[caseStr] ? 'i' + cssStr : 'notI'+ cssStr}
  }else{
    app.css = {addClass:cases.$hasTouch ? 'hasTouch' : 'notHasTouch'}
  }
}

// listener = eventUtils.throttle(listener,60)
// listener =
// cases.$isnoCalc = !util.hasCalc()
//case too see if app is running in a browser on ios (limits video capabilities)

if(cases.$istouch) events.document.addEvent('move',function(e) {
  if(!events._maybescroll && !events._setscroll) e.preventDefault()
},'app')

if('orientation' in window) window.addEventListener('orientationchange',listener)
if(!_ios) window.addEventListener('resize',listener)

//adding #<case> in url forces case, multiple hashes ==> multiple cases
//this is for testing purposes , add development indentifier for compiler

//this has to go
if(window.location.hash) {
  var hashCases = window.location.hash.split('#')[1]
    , x = hashCases.split(',')

  for(var j in x) {
    var y = x[j].split('=')
    ua[y[0]] = y[1]
  }
  
}

if(ua.device === 'tv') {
  cases.$isSlow = true
}

for(;i >= 0;) defaultCase(arr[i--])




},{"./style.less":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/style.less","./ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/animation":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js","vigour-js/browser/animation/easing":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/easing.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events/advanced":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/advanced.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Element = require('../../../browser/element')

require('../../../value/flags/parent')
require('../../../value/flags/self')
require('../../../value/flags/process')
require('../../../value/flags/util')
require('../../../browser/events')

module.exports =
  Element
  .inject
  ( require('../../../browser/element/properties/collection')
  , require('../../../browser/element/properties')
  , require('../../../browser/element/properties/scrollbar')
  , require('../../../browser/element/properties/process')
  , require('../../../value/on')
  )


},{"../../../browser/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../browser/element/properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","../../../browser/element/properties/collection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/index.js","../../../browser/element/properties/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/process.js","../../../browser/element/properties/scrollbar":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/scrollbar.js","../../../browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../../value/flags/parent":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/parent.js","../../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","../../../value/flags/self":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js","../../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../../../value/on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/on.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/sprite/index.js":[function(require,module,exports){
var Element = require('../element')
  , util = require('../../../browser/events/util') 
  , sprite = new Element({ 
    'w,h':50,
    x:{translate:true,val:0}
  })

sprite.extend({ name: 'params' //this has to come from ui (element)
  , type: false
  , set: function(val) {
    this._params = val
    this.Class.prototype._params = val //temp?
  }
})

sprite.setSetting({
  name:'spinner',
  render:function() {
    var t = this
      , params = this._params || {}
      , start = params.start || 0
      , speed = params.frames || 3
      , rows = params.rows || 1
      , cols = params.cols || 0 //ignore
      , once = params.once
      , cnt = start
      , steps = (params.steps || (rows*cols-start) || 19)
      , curRow = 0
      , curCol = 0

    if(!t.display || !t.display._base===t) {
      t.display = t.display && t.display.val || 'block'
    }
    t.display.addListener([displayListener,t],true)

    t.node.style.backgroundSize = this.w.val*cols+'px auto'
    //remeber where it was perhaps if re-rendered
    if(t.display.val==='none') return

    t._spinner = util.interval(function() { //test interval for leaks
      t.node.style.backgroundPosition = 
        (-t.w.val*curCol)+'px '+(rows ? (-t.h.val*curRow) : 0)+'px'
      cnt++
      if(cnt === steps) {
        cnt = start
        if(once) {
          // console.error('XXXXX')
          removeRaf.call(t)
          return
        }
      }
      curRow = rows ? ~~(cnt/cols) : 0
      curCol = cnt-(curRow)*cols
    },speed)
  },
  remove:removeRaf
})

function removeRaf() {
     // alert('lets remove this badboy')

  if(this._spinner) {
    this._spinner()
    this._spinner = null
  }
}

function displayListener (val) {
  if(val.val==='none') {
    removeRaf.call(this)
  } else {
    if(!this._spinner) this.setting('render')
  }
}

module.exports = sprite.Class



},{"../../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Base = require('vigour-js/base')
  , Element = require('vigour-js/browser/element')
  , Value = require('vigour-js/value')
  , VObject = require('vigour-js/object')
  , switcher = new Element()
  , cases = require('vigour-js/browser/cases')

function extendFactory( field ){
  return { name:field
  , type:false
  , set:function( fn ){
      if(fn instanceof Function)
      {
        var set = {}
        set['_'+field] = fn
        this.define(set)
      }
      else
      {
        console.error('property ' + field + ' needs to be a function')
      }
    }
  }
}

Value.flags.$params = {
  set:function( val ) {
    this.params = val
  }
}

Value.flags.$options = {
  set:function( val ) {
    this.options = val
  }
}

switcher.extend
( { loader:{}
  , animation:{}
  , delay:{}
  , done:{}
  , force:{}
  , backFallback:
    { cache:false
    // , set:function(){}
    }
  , onTransition:
    { cache:false
    // , set:function(){}
    }
  , transition:
    { cache:false
    , set:function( val ){
        var element = val.element && val.element._val
          , params = val.params
          , options = val.options || {}
          , force = options && options.force
          , children = this.children
          , last = this._swElem || children[0]
          , base = element && element.base
          , childrenLength = children.length
          , current
          , child
          , direction
          , _this = this

        //if there are old loading listeners remove these
        if( this._loading )
        {
          this._loading[1].removeListener( this._loading[0] )
          this._loading = void 0
        }

        // if( _this._timer ){
        //   clearTimeout( _this._timer )
        //   _this._timer = null
        // }

        // console.log('options?!'.green.inverse,options)
        //is it the same , is it not the same whatup!
        if( base && base instanceof Element || element === Element )
        { 
          if( !force && this._swElem && this._swElem instanceof element )
          {
            this._swElem.set( params )
          }
          else
          {

            // if there are still old pages, remove these
            if( childrenLength > 1 )
            {
              for ( i = childrenLength - 1; i >= 0; i-- ) 
              {
                child = children[i]
                if( child !== last ) child.remove()
              }
            }

            direction = this._direction = val.direction && val.direction._val
            if( options && options.loader && !options.loader.$loaded )
            {
              if( !this.loader )
              {
                console.error( 'no loader defined!' )
                return
              }

              var loader = new this.loader._val.Class()

              if( options.loader instanceof VObject ) //TODO: this has gotten VERY dirty > clean this up!
              {
                options.done = function(){
                  if( !current ) current = new element( params )
                  if( loader._remove )
                  {
                    options.done = void 0
                    options.delay = cases.tablet ? 400 : 200 //dit is natuurlijk absurd
                    
                    if( _this._swElem instanceof element )
                    {
                      _this._swElem.set( params )
                    }
                    else
                    {
                      _this.onTransition._val.call( _this, current, _this._swElem , 0, options )
                    }
                    options.delay = void 0
                  }
                }

                var path = options.loader._path
                this._loading = [ function() {
                  // if( _this._timer ){
                  //   clearTimeout( _this._timer )
                  //   _this._timer = null
                  // }
                  loader._remove = true
                  if( current && options.done ) options.done()

                }, options.loader ]

                // console.log('add the listener for',path)
                this._loading[1].is('loaded', this._loading[0] )
                // _this._timer = setTimeout( this._loading[0], 5000 )
              }
              else
              {
                options.done = function(){
                  if( !current ) current = new element( params )

                  options.done = void 0
                  options.delay = 200

                  if( _this._swElem instanceof element )
                  {
                    _this._swElem.set( params )
                  }
                  else
                  {
                    _this.onTransition._val.call( _this, current, _this._swElem , 0, options )
                  }

                  options.delay = void 0
                }
              }

              options.loader = void 0

              this.onTransition._val.call( this, loader, last, direction, options)
            }
            else
            {
              current = new element(params)
              options.done = void 0
              options.delay = void 0
              options.loader = void 0
              
              this.onTransition._val.call( this, current, last , direction, options )
            }

            if( options.animation !== void 0 ) options.animation = void 0
            if( options.delay ) options.delay = void 0

          }
        }
        else if(params)
        {
          console.error('only params defined!', params)
        }
        else if(params)
        {
          console.error('no params and no element defined!')
        }
      }
    }
  }
)

switcher.define
({ back:function(){ //remove back logic from switcher (you can't isolate it! ie when you land on page, what is back?)
      this.backFallback._val.call( this )
		}
  , add:function( element, previous ){
      console.log('add--->',element)
      this._swElem = element

      // try
      // {
        Element.prototype.add.apply( this, arguments )
      // }
      // catch(err)
      // {
      //   console.error('error adding the new element',err,arguments)
      // }
    }
	}
)

switcher.extend
( { name:'on'
  , set:function( val ) {
      // set history variable for all
      // val.each(function(){
      //   var from = this.$userOrigin.val
      //   if(!from) return
      //   if(!from._history) from.set('history',true)
      //   if(!this.__checked)
      //   {
      //     this.on(function(){
      //       var caller = this._parent._caller
            
      //       if(!caller._backStore)
      //       { 
      //         caller._backStore = [ this ]
      //       }
      //       else if(caller._direction === -1)
      //       {
      //         if(caller._backStore[1] !== void 0) caller._backStore.shift()
      //         else caller._backStore = [ this ]
      //       }
      //       else if(caller._direction === 1)
      //       {
      //         caller._backStore.unshift( this )
      //       }
            
      //     })
      //     this.__checked = true
      //   }
      // })
    }
  , remove:function(){ // create refs to original
      if( this._loading )
      {
        this._loading[1].removeListener(this._loading[0])
        this._loading = null
      }
      
      if( this._swTimer ) clearTimeout( this._swTimer )
      if( this._timer ) clearTimeout( this._timer )

      if( this.on.$remove ) this.on.$remove.update()
    }
  , new:function(){
      if( this.on.$new ) this.on.$new.update()
    }
  }
)

module.exports = new switcher.Class().Class
},{"vigour-js/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var app = require('vigour-js/app'),
  cases = require('vigour-js/browser/cases'),
  util = require('vigour-js/util')

exports.extend = util.extend(function(base) {
  base.set({
    onTransition: {
      defer: function(update) { //obscure transform
        if (exports[this._val]) this._val = exports[this._val]
        update()
      }
    }
  })
})

//slide transition
exports.slide = function(current, last, direction, options) {
  if (direction && last) animate(this, current, last, direction, options)
  else basic(this, current, last, direction, options)
}

//fade transition
exports.fade = function(current, last, direction, options) {
  basic(this, current, last, direction, options)
}

//basic transition
function basic(_this, current, last, direction, options) {
  var done = options.done,
    noAnimation = options.animation === false,
    delay = options.delay

  if (last) {
    add(_this, current, last)

    if (noAnimation) {
      remove(_this, last)
      add(_this, current)

      if (done) {
        if (delay) {
          timer(_this, function() {
            if (options.done) options.done()
          }, delay)
        } else done()
      }
    } else if (delay) {
      timer(_this, function() {
        fade(_this, last, options)
      }, delay)
    } else fade(_this, last, options)
  } else add(_this, current, false, done)
}

//animated transition
function animate(_this, current, last, direction, options) {
  var animationTime = 20 // make this configurable
    ,
    appWidth = app.w.val,
    currentStart, forward = direction === 1,
    lastEnd

  if (forward) {
    currentStart = appWidth
    lastEnd = appWidth / -3
  } else {
    currentStart = appWidth / -3
    lastEnd = appWidth
  }

  if (cases.$isWindows) {
    current.x = {
      translate: true,
      val: currentStart
    }

    last.x = {
      translate: true,
      val: 0
    }

    window.requestAnimationFrame(function() {
      current.x = 0
      last.x = lastEnd

      timer(_this, function() {
        remove(_this, last, options.done)
      }, 210)
    })
  } else {
    current.x = {
      animation: {
        start: currentStart,
        time: animationTime,
        delay: 1,
        easing: 'outCubic',
        done: function() {
          remove(_this, last, options.done)
        }
      },
      val: 0
    }

    last.x = {
      animation: {
        time: animationTime,
        delay: 2,
        easing: 'outCubic'
      },
      val: lastEnd
    }
  }

  if (!forward) add(_this, current, last)
  else add(_this, current)

}

function add(_this, toAdd, before, done) {
  if (toAdd) _this.add(toAdd, before)
  if (done) done()
}

function fade(_this, last, options) {
  last.opacity = 0
  last.node.pointerEvents = 'none'
  timer(_this, function() {
    remove(_this, last, options.done)
  }, 200)
}

function remove(_this, toRemove, done) {
  if (toRemove) toRemove.remove()
  if (done) done()
}

function timer(_this, fn, time) {
  if (_this._swTimer) {
    clearTimeout(_this._swTimer)
    _this._swTimer = null
  }
  _this._swTimer = setTimeout(function() {
    fn.call(_this)
    _this._swTimer = null
  }, time)
}

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/id.js":[function(require,module,exports){
var util = require('../../util')

require('../../value/flags/process')

exports.extend = util.extend
( function( base ) {
    // base
    base.extend
    ( 
      { id: function(val) {
          var id = val.val

          if( id && this.cloud ) 
          {
            this.data = this.cloud.data.get([ 'users', id ])
          } 
          else if( !id ) 
          {
            // this.data = void 0
            //TODO: this works buggy in values --- void 0 does not update data, maybe just use false for now
            console.log('base.mockdata')
            this.data = base.mockdata
          }
        }
      , data: {
          //mockdata on start can break everything down
          val: base.mockdata ,
          set:function( val ) {
            var user = this

            // if(!this.first) {
              // this.first = true
            // } else {

            if(user.instances && user.instances.length) {
              // console.error ('-- tmp fix data on base switch to instance[0]' )
              //TODO: this is a hacky solution! fix later
              user = user.instances[0]
            }

            if( val.from.cloud  ) 
            {
              if( user.___c !== val.from ) 
              {
                user.initialised = null
                user.___c = val.from
                for(var key in user.on.user) {
                  user.on.user[key].call( user, key )
                }
                user.initialised = true
              }
            }
            else 
            {
              if( user.___c === false ) return
              user.___c = false
              for(var key in user.on.user) {
                user.on.mock[key].call( user, key )
              }
              user.initialised = null
            }
          }
          // }
        }
      }
    )

})

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js":[function(require,module,exports){
require('../../value/flags/self')
require('../../value/flags/process')
require('../../value/flags/util')
  //TODO: clean these to work /w inject

var util = require('../../util'),
  Value = require('../../value'),
  Base = require('../../base'),
  Data = require('../../data'),
  vObject = require('../../object').inject(
    require('./origin')
  ),
  timestamp = require('monotonic-timestamp'),
  _subscriptions = {},
  MockData = require('./mockdata'),
  mockdata = new MockData({})
  // make mockdata vailable

var _extend = Base.prototype.extend

var user = new Base({
  defaultType: require('./type')
})

user.define({
  subscriptions: {
    get: function () {
      return _subscriptions
    },
    set: function (val) {
      if (val) util.merge(_subscriptions, val)
    }
  },
  mockdata: {
    get: function () {
      return mockdata
    },
    set: function (val) {
      if (val) mockdata.merge(val)
    }
  },
  on: {
    value: {
      mock: {},
      user: {}
    }
  }
, extend: function( settings ) {

    if(settings.mock) {
      this.mockdata = settings.mock
    }

    var ret = _extend.apply(this, arguments)

    if(settings.val !== void 0) {
      this[settings.name] = settings.val
    }

    if( settings.on ) {

      if( typeof settings.on === 'function' ) {
        settings.on.call( this, settings.name ) 
      } else {
        if( this.data && this.data.cloud ) {
          settings.on.user && settings.on.user.call( this, settings.name ) 
        } else {
          settings.on.mock && settings.on.mock.call( this, settings.name ) 
        }
      }    
    }

    return ret
  }
})

// user

exports.extend = util.extend(
  require('../cloud'),
  function (base) {
    var appuser = base.user = new user.Class().inject(
      require('./set'),
      require('./id')
      //inject pas op extend???
    )
    appuser.parent = base
    appuser.cases = base.cases
    appuser.cloud = base.cloud
  }
)
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","../../value/flags/self":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js","../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js","./id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/id.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","./origin":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/origin.js","./set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/set.js","./type":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/type.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js":[function(require,module,exports){
var util = require('../../util')
  , Data = require('../../data')

module.exports = exports = Data.new()  

util.define( exports,
'get', function( val, set, notself ) {
  return this.path
  ( (val instanceof Array) ? val : String(val).split('.')
  , set !== void 0 ? set : {}
  , false
  , false
  , false
  , false
  , true
  , !notself
  )
})


},{"../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/multiscreen/index.js":[function(require,module,exports){
var util = require('vigour-js/util'),
  Value = require('vigour-js/value'),
  cases = require('vigour-js/browser/cases'),
  Data = require('vigour-js/data').inject(
    require('vigour-js/data/selection')    
  ),
  Compound = require('vigour-js/object/compound'),
  events = require('vigour-js/browser/events'),
  ua = require('vigour-js/browser/ua'),
  raf = require('vigour-js/browser/animation/raf')

var VObject = require('vigour-js/object')
VObject.inject(
  require('vigour-js/value/length')
)

var INACTIVE = typeof window !== void 0 && window.INACTIVE

var deviceIsCandidate = /(desktop)|(tv)|(cast)|(tablet)|(airplay)/i
cases.$isCandidate = deviceIsCandidate.test(ua.device)

var deviceIsTvLike = /(tv)|(cast)|(airplay)/i

require('vigour-js/value/flags/process')

exports.extend = util.extend(function (user) {

  var content = user.parent.inject(require('../../content')).content

  content.on('self', function() {
    if( user.token.val ) {
      if(user.receiver.media.val && user.receiver.media.from !== user.receiver.media ) {
        if(user.receiver.media.from!== content.get( user.receiver.media.from._contentPath )) {
          // console.error('lets go change it!', user.receiver.media)
          user.receiver.media.$userOrigin = content.get( user.receiver.media.from._contentPath )
        }
      }
    } 
  })

  // extend basic properties
  user.extend({
    receiver: {
      mock: {
        receiver: {
          volume: 1,
          media: false,
          playing: false
        }
      },
      val: {
        media: {
          $bubble: {
            references:{
              $lte:1
            }
          },
          defer:function(update){
            var playing = this._parent.playing
            if(playing && !this.from.val) playing.from.val = false
            update()
          }
        }
      },
      subscription: {
        receiver: {
          volume: true,
          playing:true,
          media: {
            $: true
          }
        }
      },
      on: {
        mock: setMock_receiver,
        user: setUser_receiver
      }
    },
    clients: {
      subscription: {
        clients: {
          $: {
            $: true
          }
        }
      },
      on: {
        mock: setClients,
        user: setClients
      }
    },
    candidates: { val: {} },
    siblings: { val: {} },
    receiverClient: {
      val: {},
      on: {
        mock: setMock_receiverClient,
        user: setUser_receiverClient
      },
      subscription: {
        receiverClient:{
          $: true  
        }
      }
    },
    activeClient: {
      val: {},
      mock: {
        activeClient: true
      },
      subscription: {
        activeClient:{
          $: true  
        }
      },
      on: {
        mock: setMock_activeClient,
        user: setUser_activeClient
      }
    }
  })
  
  // extend devices (needs siblings)
  user.extend({
    devices: {
      val: new Compound(user.siblings)
    }
  })
  
  // extend case values
  user.extend({
    hasReceiver: {
      val: {
        val: user.receiverClient,
        transform: function(val, cv) {
          var endpoint = user.receiverClient.from
          return (
            endpoint && !endpoint._removed &&
            endpoint.cloud && endpoint._path[0] === 'clients'
          ) || 0
        }
      }
    },
    isReceiver: {      
      val: {
        defer: function(update, args){
          var origin = args[2] || this._updateOrigin
          if(!origin || 
             !(origin._prop || origin._name === 'receiverClient')
            ) {
            // console.log('block update', origin)
            return true
          }
          // console.log('no block')
          var stamp = args[1]
          if(stamp !== 'cleanup') {
            if(user._handleOldIsReceiver) {
              if( user._wasReceiver && 
                  !user.hasReceiver.val &&
                  !user.isActive.val
                ) {
                // console.error('i was receiver for this guy', user.data._val.raw)
                user.setReceiver(user.cloud.client.from)
              }
              user._handleOldIsReceiver = null
            }
            this.clearCache()
            user._wasReceiver = this.val
          }
          update()
        },
        val: user.receiverClient,
        transform: function(val, cv) {
          var endpoint = user.receiverClient.from
          return (
            endpoint && !endpoint._removed &&
            endpoint.cloud && endpoint === user.cloud.client.from
          ) || 0
        }
      }
    },
    hasCandidates: { 
      val: { 
        val: user.candidates.$length,
        $convertType: 'boolean'
      }
    },
    hasDevices: {
      val: { 
        val: user.devices.$length,
        $convertType: 'boolean'
      }
    },
    isActive: {
      val: {
        defer: function(update, args){
          // console.log('----- isActive check dat!')
          var origin = args[2] || this._updateOrigin
          if(!origin || 
             !(origin._prop || origin._name === 'activeClient')
            ) {
            // console.log('no blockit', 
            //   origin._path,
            //   origin,
            //   '\nval:', args[0]
            // )
            update(true)
            // return true
          }
          var stamp = args[1]

          if(stamp) {
            if(stamp !== 'cleanup') {
              if(user._handleOldIsActive) {
                if( user._wasActive && 
                    !( user.activeClient.$userOrigin && 
                       user.activeClient.$userOrigin._val
                     )
                  ) {
                  // console.error('i was activeClient for this guy RESET')
                  user.activeClient.$userOrigin = user.cloud.client._val
                }
                user._handleOldIsActive = null
              }
              this.clearCache()
              user._wasActive = this.val
            }
            
          }
          // console.log('go update!')
          update()
        },
        val: user.activeClient,
        // $bubble: {
        //   references: 2
        // },
        transform: function (c, cv) {
          var endpoint = user.activeClient.from
          return (
            (endpoint && endpoint.val === true) ||
            endpoint === user.cloud.client.from
          ) || 0
        }
      }
    },
    setReceiver: {
      type: false,
      val: function(client) {
        var user = this
        // console.error('setReceiver called lol')
        client = client.from
        if(!client) return

        var casttype = client.cast && client.cast.val

        if(casttype) {
          // console.log('setReceiver! user.cast[casttype]', user.cast[casttype])
          // console.log('setReceiver! user.cast[casttype].setReceiver', user.cast[casttype].setReceiver)
          user.cast[casttype].setReceiver(client)
        } else {
          client.set('token', user.token.val)
          user.receiverClient.$userOrigin = client
        }
      }
    }
  })
  
  // DEBUG:
  // user.activeClient.on(function(){
  //   console.error('activeClient happenin!', this.from && this.from.toString())
  // })
  
  // user.hasReceiver.on(function(){
  //   console.error('lol hasReceiver listener fires! val:', this.val)
  // })
  // user.isReceiver.on(function(){
  //   console.error('lol isReceiver listener fires! val:', this.val)
  // })
  // user.activeClient.on(function(){
  //   console.error('lol activeClient listener fires! val:\n', this.from.toString())
  // })

  // listeners:

  // on activity: make me activeClient
  if(!cases.$isChromecast && !INACTIVE) {
    var activeEvent = cases.$isTv ? 'keydown' : 'down'
    events.document.addEvent(activeEvent, function () {
      if( user.cloud.client._val &&
          !(cases.$isFullscreen && cases.$isFullscreen.val)
        ) {
        user.activeClient.$userOrigin = user.cloud.client.from
      }
    })  
  }
  

  // re-establish old setup after reconnect
  user.cloud.on('welcome', function(){
    if(user.cloud._status > 2){
      user._handleOldIsActive = true
      user._handleOldIsReceiver = true
      user.cloud.data.once(function(){
        // console.log('ok go reset dat old situation')
        user.isActive.update()
        user.isReceiver.update()
      })
    }
  })

  /*
  * when I become active, unset myself as receiver
  * and if not iplogin > select new receiver
  */
  user.isActive.on(true, function() {
    var isReceiver = user.isReceiver.val
    // console.log('isReceiver?!', isReceiver)

    if(user.hasCandidates.val) { //  && !user.iplogin.val
      // console.log('user.hasCandidates.val', user.hasCandidates.val)
      // console.log('isReceiver', 
      //   isReceiver, 
      //   '\nuser.hasReceiver.val', user.hasReceiver.val
      //   )
      if(isReceiver || !user.hasReceiver.val) {
        // console.log('ok select receiver because i became active!')
        var newreceiver = selectReceiver(user, user.candidates)
        if(newreceiver) {
          // wait for my own isactive set
          raf(function(){
            user.setReceiver(newreceiver)
          })
        } else if(isReceiver) {
          user.receiverClient.$userOrigin = null
        }
      }
    } else if(isReceiver){
      user.receiverClient.$userOrigin = null
    }
  })  
  

  // when receiver leaves, I might have to become the new receiver
  if(cases.$isCandidate) {
    user.hasReceiver.on(0, function(val, stamp, from){
      if(stamp === user.cloud.stamp) {
        // console.log('yes update is ok')
        if(!user.isActive.val){
          // wait for all removes to finish
          raf(function(){
            // select receiver
            // console.log('ok select receiver because receiver left!')
            var newreceiver = selectReceiver(user, user.clients)
            // if its me > update user
            if(newreceiver === user.cloud.client.from) {
              user.setReceiver(newreceiver)
            } else {
              // console.log('i am not new receiver! newreceiver is', newreceiver && newreceiver.raw)
            }
          })
        }
      } else {
        // console.log('update not from the cloud')
      }
    })
  }

  // when a tv joins, I might want to grab it
  if(!user.iplogin.val){
    user.candidates.on(function(val, stamp, from, remove, added){
      // console.error('-------- check for tv joiner\n',
      //   'user.hasCandidates.val', user.hasCandidates.val, '\n',
      //   'user.isActive.val', user.isActive.val, '\n',
      //   'user.initialised', user.initialised
      // )
      // console.log(user.candidates.toString())
      if(user.hasCandidates.val && user.isActive.val &&
          user.initialised
        ) {
        grabTV(user)
      } else {
        // console.error('no candidates')
      }
    })
  }

  
  // make cases
  cases.$isActive = user.isActive
  // cases.$hasCandidates = user.hasCandidates
  cases.$hasDevices = user.hasDevices
  cases.$hasReceiver = user.hasReceiver
  cases.$isReceiver = user.isReceiver


})

// clients
function updateClients() {
  this.clients.update()
}

function setClients () {
  var user = this
  var linked = user.data._val

  // clients
  var linkedclients = linked.get('clients')
  // cache old, set new, and remove listener if cached old
  var oldclients = user.clients._val
  user.clients = linkedclients
  linkedclients.addListener([updateClients, user], true)
  if( oldclients ) {
    oldclients.removeListener(updateClients, user)
  }

  // candidates
  // cache previouse value
  var oldcandidates = user.candidates && user.candidates._val
  // make candidates
  var candidates = user.candidates = new Data( linkedclients, {
    condition: { 
      device: {
        $contains: '(desktop)|(tv)|(cast)|(tablet)|(airplay)'
      },
      key: {
        $exists: true,
        $ne: this.cloud.clientid
      }
    }
  })
  // add listener because of reasons
  candidates.on(function(){
    user.candidates.update()
  })
  // clean up dat old selection
  if(oldcandidates) {
    oldcandidates.remove()
  }
  
  // siblings
  // cache previouse value
  var oldsiblings = user.siblings && user.siblings._val
  // make siblings
  var siblings = user.siblings = new Data( linkedclients, {
    condition: {
      key: {
        $exists: true,
        $ne: this.cloud.clientid
      }
    }
  })
  // add listener because of reasons
  siblings.on(function(){
    // console.log('update on candidates > update user.candidates')
    user.siblings.update()
  })
  // clean up dat old selection
  if(oldsiblings) {
    oldsiblings.remove()
  }
}

// activeClient

var acRemoveTarget
var acAddedTarget

function setMock_activeClient () {
  // console.log('---------- setMock_activeClient!')

  var user = this

  if(acRemoveTarget) {
    acRemoveTarget.removeListener(acRemoveCheck, user)
    acRemoveTarget = null
  }
  if(acAddedTarget) {
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
  }

  var linked = user.data._val

  user.activeClient = linked.get('activeClient', {})
  user.activeClient.$userOrigin = user.cloud.client.from

}



function setUser_activeClient () {
  // console.log('---------- setUser_activeClient!')

  var user = this

  // console.log('dat activeClient:', 
  //   user.data._val.activeClient
  //   ? 'yes activeclient\n' + user.data._val.activeClient.toString()
  //   : 'no activeClient in ma new user!!\n' + user.data._val.toString()
  // )

  if(acAddedTarget) {
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
  }
  
  var linked = user.data._val
  var linkedRef = linked.get('activeClient', {})

  if(acRemoveTarget) {
    acRemoveTarget.removeListener(acRemoveCheck, user)
  }
  acRemoveTarget = linkedRef
  acRemoveTarget.addListener([acRemoveCheck, user], true)

  user.activeClient = linkedRef
  
  // console.error('USERSWITCH ACTIVECLIENT')
  if(!INACTIVE){
    if(cases.$isTv) {
      // console.error('IM TV USERSWITCH WAT TO DO')
      // user.activeClient.$userOrigin = user.cloud.client.from
      // TODO: fix this:
      var activeClient = linkedRef.from
      // console.error('activeClient is', activeClient)
      // console.log('i am', user.cloud.client.from.raw)
      if(!(activeClient && activeClient._name !== 'activeClient')) {
        // console.error('set maself active')
        // console.error('SET ME TO DAT activeClient (TV)')
        user.activeClient.$userOrigin = user.cloud.client.from
      }else {
        // console.log('udpate activeClient because do it')
        user.activeClient.update()
      }
    } else if(!cases.$isChromecast) {
      // console.error('SET ME TO DAT activeClient')
      user.activeClient.$userOrigin = user.cloud.client.from
    }
  }
  

  if(user.hasCandidates.val) {
    // console.log('check for tv to grab on setUser_activeClient')
    grabTV(user)
  }

  user.activeClient.update()

}
function acRemoveCheck (firer, val, stamp, from, remove) {
  var user = this
  if(firer._removed) {
    if(acAddedTarget) {
      acAddedTarget.removeListener(acAddedCheck, user)
    }
    acAddedTarget = firer._parent
    acAddedTarget.addListener([acAddedCheck, user], true)
  }
}
function acAddedCheck (firer, val, stamp, from, remove, added) {
  var user = this,
    linkeduser = firer

  if(linkeduser.activeClient){
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
    
    acRemoveTarget = linkeduser.activeClient
    acRemoveTarget.addListener([acRemoveCheck, user], true)

    user.activeClient = linkeduser.activeClient
  }
}

// receiverClient
var rcAddedTarget
var rcRemoveTarget

function setMock_receiverClient () {
  var user = this

  if(rcAddedTarget) {
    rcAddedTarget.removeListener(rcAddedCheck, user)
  }
  if(rcRemoveTarget) {
   rcRemoveTarget.removeListener(rcRemoveCheck, user) 
  }

  var linked = user.data._val
  user.receiverClient = linked.get('receiverClient', false)
}
function setUser_receiverClient () {
  var user = this

  if(rcAddedTarget) {
    rcAddedTarget.removeListener(rcAddedCheck, user)
    rcAddedTarget = null
  }

  var linked = user.data._val
  var linkedRef = linked.get('receiverClient', {})

  if(rcRemoveTarget) {
    rcRemoveTarget.removeListener(rcRemoveCheck, user)
  }
  rcRemoveTarget = linkedRef
  rcRemoveTarget.addListener([rcRemoveCheck, user], true)

  user.receiverClient = linkedRef

  if(cases.$isTv) {
    // set tv to receiver if activeclient and no receiver
    var activeClient = user.activeClient.from
    if( activeClient && activeClient.__t === 2 &&
        activeClient !== user.cloud.client.from &&
        !user.hasReceiver.val
      ) {
      user.setReceiver(user.cloud.client.from)
    }
  } else if (cases.$isChromecast) {
    // always set chromecast to receiver
    user.setReceiver(user.cloud.client.from)
  }

}
function rcRemoveCheck (firer, val, stamp, from, remove) {
  var user = this
  if(firer._removed) {
    if(rcAddedTarget) {
      rcAddedTarget.removeListener(rcAddedCheck, user)
    }
    rcAddedTarget = firer._parent
    rcAddedTarget.addListener([rcAddedCheck, user], true)
  }
}
function rcAddedCheck (firer, val, stamp, from, remove, added) {
  var user = this,
    linkeduser = firer

  if(linkeduser.receiverClient){
    rcAddedTarget.removeListener(rcAddedCheck, user)
    rcAddedTarget = null

    rcRemoveTarget = linkeduser.receiverClient
    rcRemoveTarget.addListener([rcRemoveCheck, user], true)

    user.receiverClient = linkeduser.receiverClient
  }
}
// receiver
function setMock_receiver () {
  var user = this
  linkReceiver(user)
}
function setUser_receiver () {
  var user = this
  linkReceiver(user)
}
function linkReceiver (user) {
  var linked = user.data._val
    , linkedreceiver = linked.get('receiver', {})

  user.receiver = {
    volume: linkedreceiver.get('volume', 1),
    media: linkedreceiver.get('media', false),
    playing: linkedreceiver.get('playing', false)
  }
}

function selectReceiver(user, list) {
  // console.error('\n\n=========================selectReceiver!!!\n\n')
  while(list && list.__t === 4 && !list._filter){
    list = list._val
  }
  if(!list) {
    return console.error('could not determine list to select from')
  }
  var winner
  list.each(function(){
    var client = this._val
    // sanity check
    if(!client || client._removed || !client.device) {
      return console.error('bad client', 
        'path:', client && client._path,
        'client:', client && client.raw || client
      )
    }
    // skip if client is the activeClient
    if(client === user.activeClient.from) {
      return
    }
    var device = client.device.val
    // skip if client is not a candidate
    if(!deviceIsCandidate.test(device)) {
      return
    }

    // skip if client is in use by other user
    if(client.token && client.token.val !== user.token.val) {
      return
    }
    // client is a possible winner
    winner = client
    // stick if client is tv-like
    if(deviceIsTvLike.test(device)) {
      return true
    }
  })
  // console.error('\n\n========================= winner:',winner,user.cloud.clientid,'\n\n')

  return winner
}

function grabTV(user){
  // console.error('============= grabTV!')
  user.candidates._val.each(function(){
    var candidate = this.from
    // console.error('candidate', 
    //   'deviceIsTvLike', deviceIsTvLike.test(candidate.device.val),
    //   '!candidate.token', !(candidate.token && candidate.token.val),
    //   'candidate.token', (candidate.token && candidate.token.val)
    // )
    if(candidate.device.val === 'tv' &&
        !(candidate.token && candidate.token.val)
      ) {
      // console.error('grab dat!')
      candidate.set('token', user.token.val)
      if(!user.hasReceiver.val) {
        user.setReceiver(candidate)
      }
    }
  })
}

// function log(){
//   console.log('--------------------\n\n\n\n')
//   console.log(window.FLAG,':')
//   console.log.apply(console, arguments)
//   console.log('\n\n\n\n--------------------')
// }
// log.start = function(flag){
//   console.log('\n\n\n====================== START',
//     window.FLAG ? window.FLAG : '', flag, '\n\n'
//   )
// }
// log.end = function(flag){
//   console.log('\n\n====================== END',
//     window.FLAG ? window.FLAG : '', flag, '\n\n'
//   )
// }

},{"../../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/object/compound":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/compound.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","vigour-js/value/length":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/navigation.js":[function(require,module,exports){
var util = require('vigour-js/util')
var vObject = require('vigour-js/object')
var MockData = require('./mockdata')

require('vigour-js/value/flags/process')

//nav is taking care of: 
// double updates on the same thing with the same value (syncing in it trough the cloud)
// updating navigation
// mock and user data, subscriptions

//TODO: add view

// content en switch op content pakken
//   page
//   content
// ook bubble: 1 op alle dingen
// function updateNavigation

exports.extend = util.extend
( function( user ) {

  var content = user.parent.inject(require('../content')).content

  content.on('self', function() {
    var nav = user.navigation
    var content = this
    var contentNav = nav.content.from
    var misc = nav.misc.from

    if(contentNav._contentPath) {
      nav.content.$userOrigin.val = content.from.get(contentNav._contentPath) //DIT IN NAVIGATION
    }

    if(misc._contentPath) {
      nav.content.$userOrigin.val = content.from.get(misc._contentPath) //DIT IN NAVIGATION
    }
  })

  user.define({
    updateNavigation: function( key ) {
      if(this.navigation.last && this.navigation.last.$userOrigin) {
        key = key || this.navigation.last.$userOrigin.get('key').val
        if( typeof key === 'string' ) {
          this.navigation[key]._update( this.navigation[key]._val._val , 'l'+Math.floor(Math.random()*9999) )
          return
        }
      }
      this.navigation.page.$userOrigin = 'discover'
    }
  })

  user.extend({
    navigation: {
      mock: {
        navigation: 
        { content: false
        , page: false 
        , misc: false
        , last: { key: 'page', time: 0 }
        }
      },
      subscription: {
        navigation: 
        { content:true
        , page:true
        , misc: true
        , last: 
          { key:true
          , time:true
          }
       }
      },
      val: 
      { page: { defer: deferNavigation }
      , content: { defer: deferNavigation }
      , misc: { defer: deferNavigation }
      },
      on: {
        user: function navigationToUserData( key ) {

          resolveLastListener(this)
          
          this.navigation = {
            last: this.data._val.get( [ key, 'last' ] )
          }
          this.__first = true

          var nav = this.navigation
            , userData = this.data.$userOrigin

          this._lastupdate = function lastUpdateUser( val, stamp, from ) {
                          // console.log('hey this should do the update')

            if( this.key && nav[this.key.val] )  
            {

              // console.log('hey this should do the update!1')

              nav[this.key.val].$userOrigin._update( void 0, 'l'+stamp  )
              nav.update()
            }
          }

          nav.last.from.on(this._lastupdate)

          // console.error('KEY',key)
          // debugger

          this.navigation = 
          { page: userData.get( [ key, 'page' ], 'discover' ) 
          , content: userData.get( [ key, 'content' ] )
          , misc: userData.get( [ key, 'misc' ] )
          }

          if(nav.last.from.key) {
            // debugger
            nav.last.from._update( void 0, vObject.stamp() )
          } else if(!nav.last.from.key) {
            //no page switch to default ( make a default possilbe )
            nav.page.$userOrigin = 'discover'
          }

        },
        mock: function navigationToMockData() {

          resolveLastListener(this)
    
          var nav = this.navigation

           var mock = this.mockdata.navigation
            , set = 
              { page: mock.page
              , content: mock.content
              , misc: mock.misc
              // , last: mock.last 
              }

          this.navigation = { last: mock.last }

          //TODO: this is a temp fix should go back to page you logout from!
          if(this.__first) {
            mock.page.val = 'discover'
          } 
    
          this._lastupdate = function lastUpdateMock( val, stamp, from ) {
            if( nav[this.key.val] ) 
            {
              nav[this.key.val].$userOrigin._update( void 0, 'l'+stamp  )
            }
          }

          nav.last.from.on( this._lastupdate )
          // var nav = hoe kom ik hier aan mn user???
          // console.error('?????',this.token._lval, this.token.val)
          // need to use setter (not nav ref)
          this.navigation = set
        }
      }
    }
  })

  function resolveLastListener( user ) {
    if( user._lastupdate 
        && user.navigation.last 
        && user.navigation.last.from !== user.navigation.last
     ){
      user.navigation.last.from.removeListener(user._lastupdate)
      user._lastupdate = null
     }
  }      

  function deferNavigation( update, args ) {
    if( args[1] && args[1][0] === 'l' && 
      this._name === this._parent.last.from.key.val
    ) {

      this.clearCache()
      //TODO: more specific may be too many updates???
      // console.log('lezz update it', this._parent._path, this._path)

      update()

      // this._parent._update.apply( this._parent, args )


    } 
    else 
    {
      update( true )
    }
  } 

})

},{"../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/origin.js":[function(require,module,exports){
//userOrigin
var util = require('../../util')
  , MockData = require('./mockdata')
  , timestamp = require('monotonic-timestamp')

exports.extend = util.extend( function( vObject ) {

  var _coreSet = vObject.set
    , _fromUser = function( obj ) {
        var val = obj
          , nav
          , last

        while (val && !val._removed && val instanceof vObject) {

          if( val._parent && val._parent._prop && val._parent._prop.name === 'navigation' ) {
            nav = val
          } 

          if( ( val.cloud && val._path[0] === 'users' ) 
              || val instanceof MockData 
            ) {
            return [ val, nav ]
          }
          last = val;
          val = val._val;
        }

        var result = last && !last._removed && last !== obj
          ? last 
          : false

        return [ result, nav ]

      }

  util.define( vObject, 
    '$userOrigin', {
    set: function( val ) {

      var search = _fromUser(this)
        , found = search[0] //|| this
        , nav = search[1]
        , same

      if(!found) {
        var propname = this._prop && this._prop.name

        if(propname) {
          // console.error('>>>>>>>> making and linking', propname)

          var user = this._caller,
            linkeduser = user.data._val

          if(!linkeduser) {
            console.error('????', val)
            debugger
          }

          found = linkeduser.get(propname, {})
          this.val = found
        }
      } else {
        // console.error('FOUND', this._prop && this._prop.name, found._path, found.raw, found)
      }

      if(!found) {

        // console.error('no user but do from')
        // return _coreSet( this.from, val )

        throw new Error('cannot find correct $userOrigin for '+ ( this._name || this._prop && 'propety '+this._prop.name ) )
      }

      _coreSet.call( found , val)

      if(nav && nav._name ) {
        nav._parent.last.from.val = 
        { time: timestamp()
        , key: nav._name
        }
      } 

    },
    get: function() {
      return _fromUser( this )[0] //|| this
    }
  })
})
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , user = require('./')
  , vObj = require('../../object')

exports.extend = util.extend( 
function( base ) {

  function setUser(i) {
    //make these 2 more defualt
    // console.log(i)
    // console.log( 'swtich to user', i, this.data._val )
    this[i] = this.data.$userOrigin.get( i, this[i]._prop.$default )
  }

  function setMock(i) {
    // console.log( 'swtich to mock', i, this.mockdata[i] )
    this[i] = this.mockdata[i]
  }

  base.define({
    _set: function(val, i ) 
    {
      if ( this[i] instanceof vObj ) 
      {
        //TODO: torough testing
        this[i].val = val[i]
      } 
      if (typeof this[i] === 'function') 
      {
        if (val[i] instanceof Array) 
        {
          this[i].apply(this,val[i])
        } else 
        {
          this[i](val[i])
        }
      } 
      else 
      {
        if ( this.isProperty( i, val ) ) {
          // console.warn('this is a property!', i , val )
          this[i] = val[i]
        } else {
          if( this[i] ) 
          {
            // merge? check ook voor cloud bijvoorbeeld
            this[i] = val[i]
          }
          else 
          {
            // console.error('NOW LETS MAKE A BASIC TYPE', i, this)

            var mock = {}

            mock[i] = val[i]

            var subscription = {}
            subscription[i] = true

            // this.mockdata = mock

            this.extend({
              name:i
            , mock: mock
            , $default: val[i]
            , subscription: subscription //maybe do this if not specified
            , on: {
                mock: setMock
              , user: setUser
              }
            })

            //dit beter---- moet namelijk niet val[i] worden maar mockdata (of meteen switchen naar userData)
            
           

          }
        }

        // console.log('hey', i, this[i] )
        
      }
    }
  })

})
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/token.js":[function(require,module,exports){
var util = require('../../util')
  , Value = require('../../value')
  , cases = require('../../browser/cases')

require('../../value/flags/process')

//TODO: url error on start up (set from cloud)
exports.extend = util.extend
( function( base ) {

  base.define({
    updateId: function( res ) {
      this.id = res instanceof Array ? res[ res.length -1 ] : res
      
      //hier ff voor navigation
      //get last?
    }
  , authenticate: function authenticate( _this, request, val, update ) {
      var user = this
        , cloud = user.cloud

      if(cloud.params.fastLogin && typeof localStorage !== "undefined"){
        var userId = localStorage.getItem('userId')
        if(userId){
          request.id = userId
        }
      }
      // console.log('go cloud.authenticate!!')
      cloud.authenticate( request, function( res ) {
        
        if(res.error && typeof localStorage !== "undefined"){
          localStorage.removeItem('userId')
        }
        _this.clearCache()

        if(val !== _this.val){
          // console.error('\n\n\ndid a fast re-login! -- double check')
        }

        if( res.error || !_this.val ){
          _this.val = false
          user.id = false
          update()
          if( res.error ){
            console.error('authenticate error:', res.error)
          }else{
            if(! (user.iplogin && user.iplogin.val) ){
              user.cloud.emit('logout', res )

              if(typeof localStorage !== "undefined" ){
                localStorage.removeItem('userId')
              }
            } 
            // console.error('token is set to false while authenticating (logout! -- need to get a method to break it while in progress)')
          }
        }else{
          // console.log('AUTH SUC6', user, res )
          //dit is ook wrong completely! -- dit alleen doen met een usertoken!!!!
          // anders wachten tot een overtake actie
          if( _this.val !== true ) {
            user.updateId( res )
          }

          if(cloud.params.fastLogin && typeof localStorage !== "undefined"){
            var userId
            if(res instanceof Array)
              userId = res[res.length-1]
            else
              userId = res
            localStorage.setItem('userId', userId)  
          }

          if(user.iplogin && user.iplogin.val) {
            // console.log('TV LOGIN SUCCESS! maybe go make maself dat user')
            // console.log('>>> token', user.token.val)
            
          }
          
          update()
        }
      })
    }
  })
  
  // console.log('????????????? set iplogin', cases.$isTv || cases.$isChromecast)
  // base.iplogin = cases.$isTv || cases.$isChromecast
  
  base.extend(
  { //primary
    iplogin: { val: cases.$isTv || cases.$isChromecast },
    token:{
      // TODO: when IP based connectivity is fixed this is not needed
      subscription: {
        token: true
      },
      val:{
        transform: function( val, cv ) {
          return ( cv instanceof Object ) ? false : cv
        },
        defer:function( update, args, tempdefer ) {

          if(args[0] && args[0].defer) return true

          var token = this
          var user = token._caller

          // console.error('TOKEN SET!xxx', token)

          user.cloud.connected.is(true, function() {
            var oldval = args
              , val = token.val
              , userId = user.id && user.id.val
              , iplogin = user.iplogin && user.iplogin.val

            // if( user.iplogin && user.iplogin.val ){
            //   iplogin = true
            // }
            //DOUBLE CHECK --- this was in there to allways make sure this stuff did not happen...
            // if( user.activeClient && user.activeClient.$userOrigin && user.activeClient.from === user.client.from  ) {
              // console.log('mc dirty lets fix this here! on logout set false to be certain', user.activeClient.$userOrigin )
              // user.activeClient.$userOrigin = false
            // }

            token.clearCache()

            // console.error('token is set!', val)
            // console.log('token is set!', iplogin)

            if( userId && !iplogin ){
              // console.log('LOGOUT ---> EMIT'.red.inverse, userId )
              var _last = user.cloud.logout( userId )
              if(typeof localStorage !== "undefined"){
                localStorage.removeItem('userId')
              }
            }

            if( val ){

              var url = user.cloud.api.get('auth')

              var request = 
              { url: url
              , subs: user.subscriptions
              , token: val
              //TODO: also add tv
              }
              , auth = user.__authenticated__

              if( iplogin ){
                // this is all tv vibes
                if( val === true ) {
                  delete request.token
                }
                request.tv = true

                if( !auth ){
                  // console.log('IPLOGIN FIRST TIME POP DAT AUTHENTICATE')
                  user._authrequest = request
                  user.authenticate( token, request, val, update )
                  user.__authenticated__ = true
                }else{
                  var users = user.cloud.data.get('users')
                    , set

                  // console.error('IPLOGIN USERSWITCH')
                  // find the user I should switch to
                  users.each(function( key ) {

                    // console.log('>> HAVE USER', this)
                    var clouduser = this

                    if(clouduser.token && clouduser.token.val === token.val) {
                      // im switching to this user
                      set = clouduser._name
                      // console.log('switch to this usert!')
                    } else {
                      if(
                        clouduser.receiverClient && 
                        clouduser.receiverClient.from === user.cloud.client.from
                        ){
                        // console.error('this other user has me as receiverClient, better remove')
                        clouduser.receiverClient.$userOrigin = null
                      }
                      if(clouduser.activeClient && 
                        clouduser.activeClient.from === user.cloud.client.from
                        ){
                        // console.error('this other user has me as receiverClient, better remove')
                        clouduser.activeClient.$userOrigin = null
                      }
                    }
                  })
                  if(!set) {
                    user.id = false
                  }else{
                    user.id = set

                  }
                  update() 
                }

              }else{
                user._authrequest = request
                user.authenticate( token, request, val, update )
              }
            }else{
              user.id = false
              update() 
            }
          })
        }
      }
    },
    localStorageToken: {
      val: {
        defer:function(update, args) {
          var user = this._caller
          if(!user._readLocalStorage && typeof this.val === 'string') {
            user._readLocalStorage = this.val
            var token = localStorage.getItem(user._readLocalStorage)
            if(token && token !== 'true') {
              user.token = token
            }
            user.token.on(function() {
              var tokenval = this.val
              if(typeof tokenval === 'string') {
                localStorage.setItem(user._readLocalStorage, tokenval)
              } else {
                localStorage.removeItem(user._readLocalStorage)
              }
            })
            update()
          } else {
            update(true)
          }
        }
      }
    }
  })

  // base.token = false

  base.cases.$isLoggedIn = new Value(
  { val: base.token
  , transform:function(val, cv) {
      if(cv === true) return 0
    }
  })

  var myclient = base.cloud.client

  myclient.on(function(val, stamp, from){
    // console.log('something happened on my cloud client!')
    origin = from || this._updateOrigin
    if(stamp === base.cloud.stamp) {
      var cloudclient = myclient.from
      if(cloudclient.token){
        // console.log('-------- token on user is now', base.token.val, 'set with', cloudclient.token.val)
        base.token.val = base._authrequest.token = cloudclient.token.val

        // console.log('-------- did set token on user')
      }
    }
  })

  base.token._name = 'token'

})




},{"../../browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/type.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , Value = require('../../value')//.new()
  , objectSet = require('../../object').set
  , util = require('../../util')

// Value.inject(require('./listen_fix'))

module.exports = {
  type: Value,
  create: function(val, prop, settings, noupdate) {

    // console.log('create it', val, settings )
    var v = new Value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings) {

      if (!settings._vset) {

        //can also add a thing to set on get by default?

        if(settings.mock) {
          //if not set add some efficiency plz
          this.mockdata = settings.mock
        }

        if(settings.subscription) {
          this.subscriptions = settings.subscription
        }

        if(settings.on) {
          if( typeof settings.on === 'function' ) {
            this.on.mock[settings.name] = settings.on
            this.on.user[settings.name] = settings.on
          } else {
            if(settings.on.mock && !this.on.mock[settings.name]) {
              // console.log(base, base.on)
              this.on.mock[settings.name] = settings.on.mock
            }
            if(settings.on.user && !this.on.user[settings.name]) {
              this.on.user[settings.name] = settings.on.user
            }
          }
        }

        settings._vset = function(stamp, from, remove, cval) {
          
          var base = this._caller
                || this._base
                || this


          //if !base --
          // if(!base.)

          if(settings.set) {
            settings.set.call(
              base, this, stamp, from, remove, cval
            )
          }
        }
      }

      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  set: function(val, prop, settings) {
    // console.error('set it', val )
    this._caller = this
    return val
  },
  get: function(prop, settings) {
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/usage.js":[function(require,module,exports){
var util = require('vigour-js/util')

var vObject = require('vigour-js/object')

var MockData = require('./mockdata')

var cases = require('vigour-js/browser/cases')

var Data = require('vigour-js/data')
      .inject( require('vigour-js/data/selection') )


require('vigour-js/value/flags/process')

exports.extend = util.extend
( function( user ) {

  var content = user.parent.inject(require('../content')).content

  user.extend({
    usage: {
      mock: {
        usage:{}
      },
      subscription: {
        usage: {
          shows: {
            $: {
              media:{
                //dit moet sowieso niet title worden! liever gewoon true of id ofzo
                $:true
              },
              favourite:true,
              timestamp:true
            }
          }
        }
      },
      on: {
        mock:function() {
          this.usage = this.mockdata.usage
        },
        user:function() {
          this.usage = this.data.from.get('usage',{})
        }
      }
    },

    watched:{
      on: {
        //mischien eigen , nieuwe selection maken alvast
        mock: function() {
          if(this.__watched) {
            this.__watched.remove()
            this.__watched = null
          }
          if(this.watched) this.watched.$empty()
          this.watched = {}
        },
        user:function() {
          var user = this
          if(this.__watched) {
            this.__watched.remove()
            this.__watched = null
          }

          var selection = this.__watched = new Data( user.usage.from.get('shows') , {
            condition: { 
              media: {
                title: {
                  $exists: true
                }
              }
            }
          })

          user.watched = {}

          selection.on(function() {
            var sets = {}

            selection.each(function(i) {
              var bla =  content.get(this._path.slice(-2))
              var obj = {}
              
              util.path(obj, bla._path, {
                img:true,
                title:true
              })

             var _cloud =  user.parent.cloud
             _cloud.subscribe(obj)

              user.watched.set(this._name, 
              { show: bla
              , media: this.media.from
              })

              user.watched[this._name].once('remove', function() {
                _cloud.unsubscribe(obj)
              })

              sets[this._name] = true
            })

            user.watched.each(function(name) {
              if(!sets[name]) {
                if(user.watched)
                this.remove()
              }
            })

            sets = false

            user.watched.update()
          })
          selection._update()

        }
      } 
    },

    favourites:{
      on: {
        //mischien eigen , nieuwe selection maken alvast
        mock: function() {
          if(this.__favourites) {
            this.__favourites.remove()
            this.__favourites = null
          }
          if(this.favourites) this.favourites.$empty()
          this.favourites = {}
        },
        user:function() {
          var user = this
          if(user.__favourites) {
            user.__favourites.remove()
            user.__favourites = null
          }
          this.favourites.$empty()
          var selection = user.__favourites = new Data( user.usage.from.get('shows') , {
            condition: { 
              favourite: true
            }
          })

          user.favourites = {}

          selection.on(function() {
            var sets = {}

            selection.each(function(i) {
              var bla =  content.get(this._path.slice(-2))

              user.favourites.set(this._name,bla)
              sets[this._name] = true
            })

            user.favourites.each(function(name) {
              if(!sets[name]  ) {
                this.remove()
              }
            })

            sets = false

            user.favourites.update()
          })
          selection._update()

        }
      } 
    }
  })

  user.extend({
    hasWatched: {
      val: {
        val: user.watched,
        transform: hasTransform
      }
    },
    hasFavourites: {
      val: {
        val: user.favourites,
        transform: hasTransform
      }
    }
  })

  var oldContent = content._val

  content.on('self', function() {
    // console.log('content is changing from', oldContent && oldContent._path, 'to', this._val._path)
    if( user.token.val ) {
      resolveWatchedMedia( user )
      user.favourites._prop.on.user.call(user)
      user.watched._prop.on.user.call(user)
    } else {
      resolveWatchedMedia( user )
      user.favourites._prop.on.mock.call(user)
      user.watched._prop.on.user.call(user)
    }
  })

  cases.$hasFavourites = user.hasFavourites
  cases.$hasWatched = user.hasWatched

})

function resolveWatchedMedia( user ) {
  user.watched.from.each(function() {
    var media = this.media && this.media.from
    if(media) {

      var newPath = user.parent.content.from._path.concat( media._contentPath )       
      var oldPath = media._path

      if( !util.compareArrays( oldPath, newPath ) ) {
        console.log('resolve', oldPath, newPath)
        this.media.val = user.parent.content.get( newPath )
      }
    }
  })
}

function hasTransform( c, cv) {
  var selection = c._parent._val
  if(selection) {
    if(selection.$length.val>0) {
      return true
    }
  }
  return 0
}
  
},{"../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js":[function(require,module,exports){
var util = require('../util')
  , Value = require('../value')
  , url = require('../browser/network/url')
  , ua = require('../browser/ua')

require('../value/flags/process')

//---------------------------------------


//---------------------------------------

exports.extend = util.extend( function( app ) {

  //use cases reference on app
  var cases = app.cases || ( app.cases = require('../browser/cases') )

  app.initialised = new Value( false )

  app.overlay = new Value( false )

  app.focusState = new Value('menu')

  app.region = new Value({ init: app.initialised })
  //browser
  //ua.browser

  app.url = ua.device === 'tv' && ua.platform === 'lg' 
        ?  new Value({defer:function(){}, params:{}, string:''}) 
        :  url 
  //ook pas op app initilised!

  app.ready = new Value()

  app.menu = new Value({ init: app.ready })

  //TODO:network
  //move network api file to here perhaps
  app.network = new Value()

  //TODO: double check this is efficient
  app.loading = new Value({ 
    init: app.ready
  , defer: function( update, args ) {
      //TODO: cached updatePath ?
      var id = this.updatePath.join('.')
      if( args[0]===false && ( (id && id === this.id) || !this.id ) ) {
        this.val = args[0]
        this.id = false
      } else if( args[0] === true ) {
        this.id = id
        this.val = true
      }
      update()
    }
    //add defered later (maybe dont show a loader for less then xxx sec) 
  })

  // '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //add localstorage

  var guessLanguage = app.guessLanguage = function guessLanguage(){
    //TODO: cordova language
    var guess = window.navigator.userLanguage
             || window.navigator.language
             || app.region.val 
    if(guess)
      return guess.slice(0,2).toLowerCase()
  }

 app.language = new Value(  
  { transform: function( val, cv ) {
      if(!cv || typeof cv !== 'string') {
        cv = guessLanguage()
      } 
      return cv ? cv.slice(0,2).toLowerCase() : false
    }
  , init: app.initialised 
  })

  app.fullscreen = new Value({ force: true })

  app.loader = new Value()

  app.volume = new Value(
  { val:1
  , transform:function(v,cv){
      // console.log('volume?',cv,isNaN(cv) ? 1 : cv)
      //TODO: use loDash for isNan
      return isNaN(cv) ? 1 : cv
    }
  })

  app.popup = new Value({ init: app.ready })

  app.preview = new Value({ init: app.ready })

  app.highlight = new Value({ init: app.ready })

  app.state = new Value({ init: app.ready })
  
  app.notification = new Value( 
  { init: app.ready  
  , force: true //TODO: make this better
  })

  app.isPlaying = new Value(
  { init: app.ready
  , val:false
  })

  app.restrictPlayback = new Value()

  //make injectable
  app.wifiOnly = new Value(
    localStorage 
    ? { val: localStorage.getItem('wifiOnly') || false
      , defer:function( update ){
          if(this._val) localStorage.setItem('wifiOnly',true)
          else localStorage.removeItem('wifiOnly')
          update()
        }
      }
    : false
  )

  app.restrictPlayback.val = 
  { val: app.wifiOnly
  , transform:function(v,cv){
      return ( cv && cases.$isNative && api.network.val !== 'wifi' )
        ? true
        : false
    }
  }

  // TODO: move this (setting case value) out of app values
  cases.$storeAvailable = new Value( 
    cases.$isNative && ( cases.$isIos || cases.$isAndroid || cases.$isWindowsMobile ) //&& window.Store
  )

})
},{"../browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../browser/network/url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js","../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('../')
  , util = require('../util')
  , inject = require('../util/inject')
// , raf = require('../browser/animation/raf')


/*
  util.define( extend, 'extensions',{val:[], setClass:true} )
*/

/**
 * Base is used as a class constructor.
 * @constructor V.Base
 * @param  {*} [val] Startvalue for new V.Base
 */
var base = V.Base = module.exports = exports = function(val) {
  this._from = this.constructor
  if (val) this.set(val)
}

exports.settings = require('./settings')

/**
 * Sets properties defined in an object.
 * Define a _set method on a base instance to get custom method per set.
 * @function _set
 * @param  {*} val         Any value
 * @param  {*} [params]    Added parameters
 * @param {Boolean} noset  When true returns a parsed val object but set nothing
 * @return {Object}        return self for chaining
 */
var _set = exports.set = function(val, params, noset) {
  for (var i in val) {
    if (~i.indexOf(',')) {
      for (var arr = i.split(','), multiobj = {}, m = 0, ml = arr.length; m < ml; m++) {
        multiobj[arr[m]] = util.clone(val[i])
      }
      if (!noset) {
        _set.call(this, multiobj, params, noset)
      } else {
        delete val[i]
        for (var n in multiobj) {
          val[n] = multiobj[n]
        }
      }
    } else {
      i = util.dotField(val, i)

      // console.error( 'SET', this, this._set)

      if (this._set && !noset) {
        this._set.call(this, val, i, params)
      } else {
        //TODO: check for property move from element set to here
        // if( V.Object && this.isProperty( i, val ) && this[i] instanceof V.Object )
        // {
        //   console.log('??', i, val, this.isProperty( i, val ) )
        //   this[i].val = val[i]
        // }
        // else
        // {
          this[i] = val[i]
        // }
      }
    }
  }
  return noset ? val : this
};

util.define(base,
  /**
   * When a Base is extended without defining the type this is the default type.
   * @property defaultType
   */
  'isProperty', function( i, val) {
    var t = this
      , result = 

      
    // val[i] instanceof Object  //THIS MAY GO AWAY LATER
           //TODO: check if this is really nesseracy ( void 0 )
           // && 

      //SUPER DANGERGOUS THING

          !( t._[i] === void 0 //--- danger resolve when define _ is fixed
           && !util.lookup.call(t, i) 
           && typeof t[i]!=='function' 
          )

    // console.log( val[i] instanceof Object, t._[i] === void 0, 'val:',t._[i], !util.lookup.call(t, i), typeof t[i]!=='function'  )

    // console.log( 'IS PROPERTY', i, result )

    return result
  },
  'defaultType', false,
  'extensions', false,
  'define', function(val) {
    for(var i in val) {
      util.define( this, i, val[i] )
      util.define( this.Class, i, val[i] )
    }
  },
  /**
   * Extend is used to add properties to base.
   * Settings are similar to standard defineProperty.
   * @method extend
   * @param   {Object}   settings        Define the following fields: name, type, set, new, remove.
   * @param   {String}   settings.name   Define the name of the property
   * @param   {Object}   [settings.type] Define the type of object e.g. V.Value, set type to false if you want to use standard defineProperty
   * @param   {Function} settings.set    Define a function on set
   * @param   {Function} settings.new    Define a function on construct
   * @param   {Function} settings.remove Define a function on remove
   * @return  {[type]}                   [description]
   */
  'extend', function(settings) {

    //TODO: add to instance as well , have a dictionary of extenstions -- get to orginal easyly
    var args = util.arg(arguments)
      , l = args.length
      , i

    if (l > 1) {
      for (i = 0; i < l; this.extend( args[i++] ));
    } else if (!settings.name) {
      for (i in settings) {

        if( typeof settings[i] === 'function' ) 
        {
          this.extend( { name: i, set: settings[i] } )
        }
        else
        {
          settings[i].name = i
          this.extend( settings[i] )
        }

      }
    } else {

      if( settings === true ){
        alert()
      }


      if (!settings.def && settings.def !== 0) settings.def = false;
  
      if (this.Class.prototype._settings) {
        exports.settings.parse.call(this, settings)
        if (settings._settings) exports.settings.create.call(this, settings)
      }
      //1. normal extensions
      if (settings.type === false || ( !settings.type && !this.defaultType ) ) {

        //TODO: test if double define is actually ok!
        // util.define(this, settings.name, settings)

        util.define(this.Class, settings.name, settings)

      } else {
        //2. V.Values
        if (!settings.type) settings.type = this.defaultType
          //a type has fields type, set ,get, create
        var get =  function(prop) {
            //custom get
            return settings.type.get 
              ? settings.type.get.call(this, prop, settings)
              : prop
          }
          , set =  function(val) {

            var prop = this[settings.name]
            if(prop===null) return
            if (prop===settings.def) { //(prop instanceof V.Object)
              //return is hier mischien niet nodig;
              return settings.type.create.call(this, val, prop, settings)
            } else {
              val = settings.type.set.call(this, val, prop, settings)
              if (val!== null) prop.val = val
            }
          }

        //TODO: test if double define is actually ok!
        util.define(
          this,
          settings.name,
          settings.def,
          set,
          get,
          true
        )
        //dit breaked wat shit

        //or on value ? value.prop

        //make extended prototype object perhaps
        // this.Class.prototype['__'+settings.name+'__'] = settings

        util.define(
          this.Class,
          settings.name,
          settings.def,
          set,
          get
        )
      }
    }
  },
  /**
   * Removes this Base. Also removes all listeners added to extensions.
   * Instances true will remove all instances as well.
   * @method remove
   * @param  {[type]} instances  [description]
   * @param  {[type]} fromremove [description]
   * @param  {[type]} params     [description]
   */
  'remove', function(instances, fromremove, params) {

    // this._removing = true

    if(!this._from) return

    this.setting('remove', [params]);

    if (!fromremove) {
      var ins = this._from.base.instances
      if(ins) {
        for (var n = 0, l = ins.length; ins[n] !== this || !ins.splice(n, 1); n++);
      }
    }

    for (var i in this.__) {
      if (this.__[i] instanceof V.Object) {
        //nested, blacklist, not (fields in object), from, stamp, noupdate
//         console.log('---------', i, this.__[i], this.__[i]._path )
        this.__[i].remove(false, false, false, false, false, true);
        this.__[i] = null
      } else {
        this.__[i] = null
      }
    }
    this.__ = null

    if (instances && this.instances) {
      for (j = this.instances.length - 1; j >= 0; this.instances[j--].remove(true, true));
    }

    for (var j in this) {
      // if(this[j] instanceof V.Base) {
      //   this[j].remove()
      // } 
      this[j] = null;
    }

    this._settings = null
    this._ = null
    delete this._settings
    delete this._
    delete this.__
    // delete this._class; may not be nessecary
  },
  /*set on prototype*/
  'set', _set,
  'get', function( path, self ) {
    return util.get( this, path, self )
  },

  'inject', inject,
  /**
   * Passes field parameter only for instances matching a field
   * @method
   * @param  {Function} fn    [description]
   * @param  {String}   field [description]
   * @param  {*}        val   [description]
   * @param  {*}        p     [description]
   * @return {Boolean}        [description]
   */
  'eachInstance', function(fn, field, val, p) {
    var instances = this.instances;
    if (instances) {
      for (var i = 0, l = instances.length, instance; i < l; i++) {
        instance = instances[i];


//problem! has to correct for missing instances!!!
//   console.log(instance, instances)

          

        if (instance && (!field || !instance.__ || !instance.__[field])) {
          if (fn.call(instance, val, p)) {
            return true;
          }
          if (instance.eachInstance(fn, field, val)) {
            return true;
          }
        } else if(!instance) {
          console.error('\n\n\n\ninstance in base gone?', i , instances)
          // debugger
        }
      }
    }
  },
  /**
   * Creates a class from the current Base instance
   * @constructor Class
   * @return {Object}
   */
  'Class', {
    get: function() {
      if (!this._class) {
        this.instances = [];
        this._class = function(val, proto, setting) {
          if (!proto) {
            var from = this._from.base;
            from.instances.push(this);
            if (this.setting) {
              this.setting('new', [from, setting]);
            }
            if (val) {
              this.set(val);
            }
          }
        };
        this._class.base = this;
        this._class.prototype = new this._from(false, true);
        this._class.prototype.__ = null;
        util.setstore.call(this);
        var i, _proto = this._class.prototype._ = {};
        for (i in this.__) {
          _proto[i] = this.__[i];
        }
        for (i in this._) {
          if (_proto[i] === void 0) {
            _proto[i] = this._[i];
          }
        }
        this._class.prototype._from = this._class;
        this._class.inject = inject
      }
      return this._class;
    }
  });
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./settings":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/settings.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/settings.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('./'),
  util = require('../util');

/**
 * Settings are used for special cases e.g. onRemove or onNew instance
 * @property
 */
util.define(base, '_settings');

base.prototype._._settings = {};

/**
 * Set settings on Base
 * @function _set
 * @param  {Object}  set      Object to set
 * @param  {Boolean} [remove]
 * @param  {Boolean} [force]  True/false
 */
var _set = function(set, remove, force) {
  var _s = set._settings //e.g. node , remove and parent
    , t = this
    , __t = t._._settings
    , setting
    , i
    , _t

  util.setstore.call(t)

  if (!t.__._settings) {
    // console.log('create my own settings')
    t.__._settings = {}
    for (var j in __t) {
      t._settings[j] = __t[j]
    }
  }

  _t = t.__._settings

  // console.log('SETTINGS?'.inverse, set, __t)

  for (i in _s) {
    setting = _s[i]
    //efficient memory management only make own if absolutely nessecary
    if ((remove && _t[setting][set.name]) || (!remove && !_t[setting][set.name]) || force) {
      
      if (_t[setting] === __t[setting]) {
        _t[setting] = {}
        for (var n in __t[setting]) {
          _t[setting][n] = __t[setting][n]
        }
      }

      if (remove) {
        this.eachInstance(function() {
          if (this[set.name] !== t[set.name]) {
            if (this._setting !== _t && this._settings[setting] === _t[setting]) {
              // console.log('found that the settings are the same and not the same property make my own');
              // console.log('------ SETTING')
              _set.call(this, _t[setting][set.name], false, true);
            }
          } else {
            if (this._setting !== _t && this._settings[setting] !== _t[setting]) {
              // console.log('------ REMOVE SETTING')

              // console.log(this.name,set.name,'found that the property is the same but settings are not!');
              this.removeSetting(set.name, setting);
            }
          }
        });
        _t[setting][set.name] = null;
        delete _t[setting][set.name]; //delete is kut!;
        if (util.empty(_t[setting])) {
          // console.log('lets put this to true!')
          _t[setting] = true;
        }
      } else {
        // console.log('------ DO SETTING', set, _t, setting, set.name)
        if(_t[setting]===true) {
          _t[setting]={}
        }
        _t[setting][set.name] = set;
        // console.log('RESULT?', setting, _t[setting])
      }
    }
  }

  // console.log('SETTINGS? -- result'.inverse, _t, this._settings===_t, this.BLUXEN)

};

/**
 * Creates a setting
 * @method create
 * @param  {[type]} set [description]
 * @return {[type]}     [description]
 */
exports.create = function(set) {
  set._set = set.set;
  set.set = function(val, prop) {
    _set.call(this, set)
    set._set.apply(this, arguments)
  }
}

/**
 * Extracts settings from settingsobject and stores them in an array.
 * @method parse
 * @param  {Object} settings Settingobject
 * @param  {Object} object   Settingsobject
 */
exports.parse = function(settings, object) {
  if (!object) {
    object = this._settings
  }
  for (var i in object) {
    if (settings[i]) {
      if (!settings._settings) {
        settings._settings = [];
      }
      settings._settings.push(i);
    }
  }
};

/**
 * Adds setting(s) to Base prototype
 * @method add
 * @param  {String[]}    name  Array of settingnames
 * @param  {Prototype}   proto Prototype eg. myBase class
 */
exports.add = function(name, proto) { //start using this sometimes!;
  if (name instanceof Array) {
    for (var i in name) {
      if (proto) {
        this.add(name[i], proto);
      } else {
        this.addSetting(name[i], false);
      }
    }
  } else {
    if (!proto) {
      util.setstore.call(this);
      if (!this.__._settings) {
        this.__._settings = {};
      }
      for (var j in this._._settings) {
        this._settings[j] = this._._settings[j];
      }
      this._settings[name] = true;
    } else {
      proto.prototype._settings[name] = true;
    }
  }
};

/**
 * Add settings to instances of Base
 * settings only work for instances of the added Basesettings
 * @method
 */
util.define(base,
  'addSetting', function(name) {
    exports.add.call(this, name);
    if (this._class) {
      this._class.prototype._._settings = this._settings;
    }
  },
  /**
   * Simple implementation of setting.create
   * @method setSetting
   * @param  {Object} set Settingobject
   */
  'setSetting', function(set) {
    //eerst checken of ie al bestaat anders kan het voorkomen dat het teveel is
    exports.parse.call(this, set);

    // console.log('SET SETTING'.yellow.inverse, set, this._settings )

    //get gebruiken --- object is een check op meerdere fields returns true of false // bij get ook mogelijk om field mee te geven
    _set.call(this, set);

    // console.log('SET SETTING -- result'.yellow.inverse, this._settings )

  },
  /**
   * [description]
   * @method removeSetting
   * @param  {String}       name     Name of the setting to remove
   * @param  {Array|Object} settings Settingobject
   */
  'removeSetting', function(name, settings) {

    // if(!settings) {
    //   //this may all be not nessecary!
    //   for(var i in this._settings) {
    //     for(var j in this._settings[i]) {
    //       if(this._settings[i][j].name===name) {
    //         settings=this._settings[i][j]
    //         break;
    //       }
    //     }
    //   }
    // }

    if (!(settings instanceof Array)) {
      //this may all be not nessecary!
      // if(settings instanceof Object) {
      //   settings = settings._settings
      // } else {
        settings = [settings];
      // }
    }

    for (var i = settings.length - 1, found, _settings = this._settings; i >= 0; i--) {
      if (_settings && _settings[settings[i]] && _settings[settings[i]][name]) {
        found = true;
        break;
      }
    }
    if (found) {
      _set.call(this, {
        name: name,
        _settings: settings
      }, true);
    }
  },

  /**
   * Checks if object has settings and executes them. Arguments are passed to settings.
   * @method setting
   * @param  {String}    name Name of the setting
   * @param  {Arguments} arg  Arguments to pass to settings
   */
  'setting', function(name, arg) { //misschien arg
    var _s = this._settings;
    if (_s && _s[name] && _s[name] !== true) {
      for (var i in _s[name]) {
        _s[name][i][name].apply(this, arg);
      }
    }
  });

/**
 * Base has two default settings
 * new is invoked on construction , remove on removal;
 * @settings
 */
exports.add(['new', 'remove'], base)

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/easing.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var animation = require('./');
animation.easing = exports;
// t: current time, b: beginning value, c: change In value, d: duration
// courtesy of Robert Penner
exports.inCubic = function(t, b, c, d) {
  return c * (t /= d) * t * t + b;
};

exports.outCubic = function(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
};

exports.outBack = function(t, b, c, d, s) {
  var s = 1.70158;
  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
};
},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/frame.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var Value = require('../../value')
  , frame = new Value(1)
  , util = require('../../util')
  , _on = function() {
    // console.group()
    // console.log('\n\n----RAF----'.magenta.bold)
    exports.rafId = window.requestAnimationFrame(_on)
    frame.val++
    // console.groupEnd()
  }

frame.done = new Value(true)

util.define(frame,
  'addListener', function(val, mark, remove) {
    if (!this._listeners){
      this.done.val = false
      _on()
    }
    Value.prototype.addListener.call(this, val, mark, remove)
  }
, 'removeListener', function(val, mark, remove) {
    var t = this
    Value.prototype.removeListener.call(t, val, mark, remove)
    if (!this._listeners) {
      window.cancelAnimationFrame(exports.rafId)
      this.val = 1
      this.done.val = true
    }
  }
)

module.exports = frame
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var element = require('../element').inject(require('../element/properties')) //element added (extend) //call extend on flags (make buffer if already extended)
  , object = require('../../object')
  , util = require('../../util')
  , flags = require('../../value/flags/util')
  , operators = require('../../value/operators')
  , frame = require('./frame')
  , _linear = function(t, b, c, d) {
    return c * t / d + b
  }
//-------------------------------------------------------------------
operators._a = function (val, operator) {
  return operator
}

function preventSet(val) {
  this._p = true
  this.val = val
  this._p = false
}

operators._a.order = 2

flags.animation = {
  set: function (val) {
    
    var thisObject = this
      , _p = thisObject.checkParent('_prop')

    if (val) {

      if (!thisObject._val) thisObject.val = 0

      var name = _p._prop.name
        , element = _p._caller
        , noListener = val.noListener
        , path = thisObject._path
        , id = name.concat(path.join(''))
        , skip = val.skip
        , easing = val.easing 
          && exports.easing[val.easing] 
          || val.easing 
          || _linear
        , time, start, ready

      if(!_p._animListen) _p._animListen = function (val) {
        var tn = this[name]
        if(tn) tn.update(this, true)
        else {
          var FORTESTING = frame._listeners && frame._listeners.length
          console.log('_animListen setting',frame._listeners && frame._listeners.length)
          frame.removeListener(void 0, this)
          console.log('>> _animListen setting',frame._listeners && frame._listeners.length)
          if(FORTESTING && FORTESTING === (frame._listeners && frame._listeners.length))
          {
            console.error('this >>',this)
            // debugger
          }
        }
      }

      element.setSetting({
        name:'animation',
        remove:function() {
          var FORTESTING = frame._listeners && frame._listeners.length
          // console.log('remove setting',frame._listeners && frame._listeners.length)
          

          frame.removeListener( void 0, this)


          if(frame._listeners && FORTESTING && FORTESTING === (frame._listeners && frame._listeners.length))
          {
            for(var i in frame._listeners ) {
              if( frame._listeners[i] instanceof Array ) {
//                 console.log('COMPARE',frame._listeners[i][1]===this, frame._listeners[i][1], 'vs', this )
                if( frame._listeners[i][1]===this, frame._listeners[i][1] ) {
                    // frame._listeners.splice(i,1)
//                     console.error('this >>',this.node)
                    // debugger
                }
              }
            }
          }


        }
      })

      _p.preventSet = preventSet

      _p.set('translate', true)

      thisObject.set('_a', {
        time: val.time || 60,
        val: function(v, cv, b) {
          
          var t = this
            , a
            , prop = _p //t[name] ||
            , pr = t[name]

          if (!t._a) t._a = {}
        
          if (!t._a[id]) {

            start = val.start === void 0 
              ? t.rendered && (thisObject.__lval !== void 0)
                ? thisObject.__lval
                : cv
              : val.start instanceof object 
                ? val.start.val
                : val.start

            t._a[id] = {
              _start: start,
              _end: start,
              _current: start,
              _count: 0
            }

            if (!t.rendered) return start
          }

          if (t.rendered) {
            if(skip) {
              t._a[id]._current = cv
              skip = false
              return cv
            }

            a = t._a[id]
            if (pr._p || exports.prevent) {
              a._frame = 0
//               console.log('remove prevent',frame._listeners && frame._listeners.length)
              frame.removeListener(prop._animListen, this, true)
//               console.log('>> remove prevent',frame._listeners && frame._listeners.length)
              if (pr._p !== 1) {
                a._current = a._end = cv
                if (val.complete) noListener = val.complete.call(t, cv)
                if (val.done) setTimeout( function() { val.done.call(t,cv) }, 0)
                if (val.once) {
                  setTimeout( function() { 
                    if(val.once) val.once.call(t,cv) 
                    val.once = null
                  }, 0)
                }
              }
            } else if (a._frame !== frame.val) {
              if (a._frame || (cv !== void 0 && a._current !== cv)) { //checking a.frame faster than comparing a.current to cv
                if (a._end !== cv) {

                  if (val.init) val.init.call(t, a._current)
                  if(!noListener) {
                    frame.addListener([prop._animListen, this, name]
                      , function (listenArray, listeners) {
                        for(var i in listeners) {
                          if(listeners[i].pop) {
                            if(listeners[i].pop && listeners[i][1]===t && listeners[i][2]===name) {
                              return false
                            }
                          }
                        }
                       return true 
                      }
                    )
                  }
                  a._start = a._current
                  a._end = cv
                  a._count = 0
                  time = ~~v.time.val
                }
                a._frame = frame.val

                if(val.delay){
                  val.delay--
                  return a._start
                }

                var cnt = ++a._count
                a._current = easing.call(t, cnt, a._start, a._end - a._start, time || (time = ~~v.time.val))
                if(val[cnt]) val[cnt].call(this,a._current,cv)
              }
              if (a._count === time) {              
                a._current = cv
                a._frame = 0
                a._count = 0

                if (val.complete) noListener = val.complete.call(t, cv)
                if (val.done) setTimeout( function() { val.done.call(t,cv) }, 0)
                if (val.once) {
                  setTimeout( function() { 
                    if(val.once) val.once.call(t,cv) 
                    val.once = null
                  }, 0)
                }

                if(!noListener)
                {
//                   console.log('remove nolistener',frame._listeners && frame._listeners.length)
                  frame.removeListener(prop._animListen, this, true)
//                   console.log('>> remove nolistener',frame._listeners && frame._listeners.length)
                }
              }
            }
            return a._current
          } 
        }
      })
            
      _p._skip = true
      thisObject._skip = true
      
      if (val.start !== void 0) {
        var caller = this._caller
        if(!caller) caller = this.checkParent('_prop')._caller
        caller.setRender(name, function(parent) {
          this.update(name)
        })
      }
    } 
    else {
      thisObject.remove('_a')
      thisObject._skip = void 0
      _p._skip = void 0
      _remove(_p)
    }

  }
}
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../../value/operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../element/properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","./frame":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/frame.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var ua = require('../ua'),
  RAF = 'equestAnimationFrame',
  CAP = 'R' + RAF,
  util = require('../../util')
  lastFrame = 0;

util.define(ua, 'hasTransition', {
  get:function() {
    if(!ua._hasTransition) {
       var b = document.body || document.documentElement
        , s = b.style
        , p = 'ransition';
      ua._hasTransition = typeof s['t'+p] === 'string' 
        || typeof s[ua.prefix + 'T'+p] === 'string'
    }
    return ua._hasTransition
  }
})
  
RAF = 'r' + RAF;
if (!window[RAF]) { 

  ua.noRaf = true

  //window[ua.prefix + CAP] || 

  window[RAF] = function(callback) {
    return setTimeout(callback, 20);
  };
  window.cancelAnimationFrame = function(id) {
    clearTimeout(id);
  };
}



module.exports = exports = window[RAF]

exports.timer = function( fn, frames, repeat ){
  if( --frames ){
    exports(function(){
      if( repeat ) fn()
      exports.timer( fn, frames, repeat )
    })
  } else {
    exports( fn )
  }
}

exports.repeat = function( fn, frames ){
  exports.timer( fn, frames, true )
}

//check ios 6 paul irish says stuff goes wrong there...
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var cases = require('./'),
  element = require('../element'),
  setFlags = require('../element/set'),
  base = require('../../base'),
  util = require('../../util');

//------------------CASES FOR SET-------------------------------
var _css = function(t, name, invert, remove) {
    if (!invert) {
      if(!t.css) { t.css = '' }
      t.css.set( remove ? 'removeClass' : 'addClass', name ) 
      t.css.update(t)
                  // console.error('\n\n\nset css!!!!!xxx', name, t.node)

      t.eachInstance(function() {
            console.error('\n\n\ninstance! set css!!!!!', name, t.node)

        // if(this.css !== t.css) {
          this.css.set( remove ? 'removeClass' : 'addClass', name ) 
          this.css.update(this)
        // }
      })
    }
  },
  methods = cases.methods;

setFlags.remove = function(i, val, copy, top) {
  //this could become a seperate module since remove may be usefull for different purposes
  if (val && val.__remove__) {
    if (this[i] instanceof base) {
      top[i] = false;
    } else if (util.lookup.call(this, i)) {
      delete val.__remove__;
    } else {
      delete val[i];
      return true;
    }
  }
};

setFlags.cases = methods.reader(function caseReaderBase(name, val, dynamic, invert) {
  var t = this,
    f = function(obj) {
      obj = base.set(obj, false, true);
      for (var i in obj) {
        if (util.isObj(obj[i])) {
          obj[i] = f(obj[i]);
        }
      }
      return obj;
    },
    method,
    parsed,
    set,
    sVal,
    original;
  val = f(val);

  if (dynamic) {
    if (!t._cases) {
      t._cases = {};
    }
    if (val === null) {
      if (t._cases[name].method) {
        // console.error(name, 'case === null , remove it');
        cases[name].removeListener(t._cases[name].method);
      }
      if (cases[name].val) {
        t.css = {
          removeClass: name
        };
         t.eachInstance(function() {
            this.css = {
              removeClass: name
            };
         })
      }
      delete t._cases[name]; //removes case orginal
    } else {
      // console.error('SET CASE',name,t._cases[name]&&t._cases[name].method);
      parsed = methods.original(t, true, val, t._cases, true, name);
      t._cases[name] = {
        val: val,
        orig: parsed[0],
        nested: parsed[1]
      };

      if (!t._cases[name].method) {
        // console.error('this is what i have set for original', t._cases);
        method = t._cases[name].method = function() {

          // console.log('LETS TRY TO RUN METHOD',name,val);

          if (val) {
            set = methods.merge(true, name, val, t._cases); //arg no val;
            sVal = set [0];
            original = set[1];
            delete sVal.val;
            delete original.val;
            if (cases[name].val) {
              _css(t, name, invert);
              t.set(sVal, true);
            } else {
              _css(t, name, invert, true);
              t.set(original, true);
            }
          }
        };
        // console.error('ADD LISTENER TO',name,  t._cases[name]);
        cases[name].addListener(method);
        //remove setting on remove (saves memory)
        t.setSetting({
          name: '_c' + name,
          remove: function() {
            if(this === t ) {
              cases[name].removeListener(method); //if(!this.css === this._from.base.css) 
              this._cases[name].method = null
            }
          }
        });
        // } else {
        // console.log(name, 'already got listeners for case',name);
      }
      if (cases[name].val) {
        _css(t, name, invert);
        t.set(val, true);
      }
    }
  } else {
    _css(t, name, invert);
    t.set(val); //maybe copy args?
  }
  return true;
});
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../element/set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var object = require('../../object'),
  util = require('../../util'),
  element = require('../element'), //element /w extend
  value = require('../../value'),
  flags = require('../../value/flags');

/**
 * cases
 * cases are used to set one or more values when a specific case is true
 * there are 2 types of cases , static and dynamic ,
 * static cases are set at initialization of the application , usefull for things such as device type (phone, desktop, tv)
 * dynamic cases can be changed dynamicly and Objects or Bases that use the case will be changed dynamicly as well
 */

util.define(exports, 'methods', {});
//multiple, recursive and original have to become extensions on V.Object.convert so it's possible to use the same for data and events

var _isObj = util.isObj,
  /*
    _recur
    special merge that adds __remove__ if a field has to be removed
  */
  _recur = function(original, merge, fieldExists) {

    // console.log(original, merge, fieldExists)

    var keys, i, key, originalChild, mergeChild;
    if (fieldExists) {
      keys = {};
      for (key in original) {
        keys[key] = true; //keys can be undefined -- code can become shorter
      }
    }
    for (i in merge) {
      if (!fieldExists || keys[i]) {
        originalChild = original[i];
        mergeChild = merge[i];
        if (originalChild instanceof Object) {
          if (originalChild.__remove__ && (mergeChild && !mergeChild.__remove__)) {
            delete originalChild.__remove__;
          }
          if (!(mergeChild instanceof Object)) {
            merge[i] = {
              val: mergeChild
            };
          }
          _recur(originalChild, mergeChild, fieldExists);
        } else {
          original[i] = mergeChild;
          originalChild = 'burn';
        }
      }
    }
  },
  /*
          _multiple
          merge multiple orginals into a new orginal object also resolve nested cases
      */
  _multiple = function(t, nested, cases, currentObj, currentVal, base, name, path, orig) {

    if (!path) {
      orig = t;
      path = [];
    }
    var j, _case, cvChild;

    if((currentVal instanceof object) && !base) {

      // currentObj.val = t._val
      // console.error('VOBJ', currentObj)


    } else if (currentVal instanceof Object) {
      for (j in currentVal) {
        cvChild = currentVal[j];
        if (exports[j]) {
          _case = exports[j];
          if (_case instanceof object) {
            if (!base || !element.set.lookup.call(orig, path[path.length - 1])) { //element is required in cases.base, make this part extendable
              nested[j] = true;
            }
          }
          if (!_isObj(cvChild)) {
            currentObj.val = t && (t._val !== void 0 ? t._val : void 0);
          } else {
            path.push(j);
            //should be possible to use nested for current nested case;
            _multiple(t, nested, cases, currentObj, cvChild, base, name, path, orig);
          }
          currentObj[j] = null;
        } else {
          if (_isObj(cvChild)) {
            if (!currentObj[j]) {
              currentObj[j] = (t && t[j] && t[j].convert && t[j].convert(cvChild)) || (cvChild instanceof Array ? [] : {});
            }
            path.push(j);
            _multiple(t && t[j], nested, cases, currentObj[j], cvChild, base, name, path, orig);
            if (base && (!t || !t[j])) {
              currentObj[j].__remove__ = true;
            }
          } else {
            if (t && currentObj && !currentObj[j]) {
              if (flags[j]) {
                delete currentObj[j];
                currentObj.val = t._val !== void 0 ? t._val : void 0;
              } else {
                currentObj[j] = j === 'val' 
                  ? (t._val !== void 0 ? t._val : void 0) 
                  : (t[j]!==void 0 && t[j].convert && t[j].convert())
              }
            }
          }
        }
      }
    }
  };

/*
      original
      create a orginal store for a new case
    */
exports.methods.original = function(t, isObj, val, cases, base, name) {



  var obj = isObj ? t.convert(val) : t._val,
    i, cflag, nested = {};

  _multiple(t, nested, cases, obj, val, base, name);

  // for(var i in nested) {
  //   console.error('NESTED:::',i);
  // }
  // console.log(base ? 'BASE:': 'PROPERTY:' , name,'ORIGINAL GENERATION','\nval:',val,'\nobj:',obj,'\nnested:',nested,'\ncases:',cases);

  for (i in cases) {
    if (!nested[i]) {
      cflag = cases[i].orig;
      if (!isObj) {
        if (_isObj(cflag)) {
          if (cflag.val) {
            obj = cflag.val;
          }
        } else {
          obj = cflag;
        }
      } else {
        if (_isObj(cflag)) {
          if (!cases[i].nested[name]) {
            _recur(obj, cflag, name);
          }
        } else if (obj.val) {
          obj.val = cflag;
        }
      }
    }
  }



  return [obj, nested];
};
/*
  merge
  merge dynamic cases (overwrite /w cases that are true and further in the order of cases)
*/
exports.methods.merge = function(isObj, name, val, cases) {
  var original = util.clone(cases[name].orig),
    sVal = val,
    overwrite,
    i,
    merge,
    originalChild;
  for (i in cases) {
    if (i !== name && !cases[name].nested[i]) {
      if (exports[i].val) {
        merge = cases[i].val;
        if (_isObj(original) || _isObj(merge)) {
          if (!_isObj(original)) {
            original = {
              val: original
            };
          }
          if (!_isObj(merge)) {
            merge = {
              val: merge
            };
          }
          _recur(original, merge, true);
          for (i in exports) {
            originalChild = original[i];
            if (originalChild !== null && originalChild !== void 0) {
              delete original[i]; //delete is pretty slow
            }
          }
          if (overwrite) {
            if (isObj) {
              if (sVal === val) {
                sVal = util.clone(sVal);
              }
              merge = util.clone(merge);
              for (i in exports) {
                if (merge[i] !== null && merge[i] !== void 0) {
                  // console.error('REMOVE FIX', i);
                  delete merge[i]; //delete is pretty slow
                }
              }
              _recur(sVal, merge, true);
            } else {
              if (merge.val) {
                sVal = merge.val;
              }
            }
          }
        } else {
          original = merge;
        }
      }
    } else {
      overwrite = true;
    }
  }
  return [sVal, original];
};
/*
  reader
  abstraction for use in cases.object and cases.base
*/
exports.methods.reader = function(fn, dynamic, _static) {
  return function reader(name, val) {
    var invert = (name[0] === '!'),
      vCase = invert ? exports[(name.slice(1))] : exports[name],
      ret;
    if (vCase) {
      if (vCase instanceof object) {
        if (invert && !exports[name]) {
          exports[name] = new value({
            val: function() {
              return !vCase.val;
            },
            listen: vCase
          });
        }
        ret = fn ? fn.call(this, name, val, true, invert) : dynamic;
      } else {
        ret = invert ? !!fn : fn ? fn.call(this, name, val) : _static
      }
    } else if (invert) {
      ret = fn ? fn.call(this, name, val, false, invert) : _static;
    }
    if (vCase === false && fn) {
      ret = true;
    }
    return ret;
  };
};

require('./object');
require('./base');
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","./base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/base.js","./object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/object.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = require('../../value/flags'),
  Cases = require('./'),
  object = require('../../object'),
  util = require('../../util'),
  methods = Cases.methods,
  dynamic = {
    set: function(val, stamp, reset, name) {

      if(!this._flag) this._flag = {}

      var t = this,
          //selection for t._flag easy maken
          
          
        flags = t._flag.case || (t._flag.case = [
          'case',
          t._val,
          false, {},
          dynamic
        ]),
        cases = flags[3],
        isObj = util.isObj(val),
        setVal = (isObj && !val.val) ? false : true;
      if (val === null) {
        if (cases[name]) {
          Cases[name].removeListener(cases[name].method);
        }
        delete cases[name];
      } else {
        flags[5] = true;
        if (!cases[name]) {
          var x = methods.original(t, isObj, val, cases, false, name);
          cases[name] = {
            val: val,
            orig: x[0],
            nested: x[1],
            method: function() {
              var set = methods.merge(isObj, name, val, cases),
              sVal = set[0],
              original = set[1];
              // console.log(name)
              // if(name === '$isActive' )console.error('boeloe boeloe boeloe!!!',sVal,original)

              flags[5] = true; //the closures here are not really nessecary better to avoid
              if (Cases[name].val) {

                if(!sVal) console.warn(name,'wrong in cases!', sVal, Cases, flags)
                if (setVal && sVal) {
                  // if(name === '$isActive' )console.log('yee its true')
                  flags[1] = sVal.val || sVal;
                }
                t.val = sVal;
              } else {
                                  // if(name === '$isActive' )console.log('no way gozee')

                if (setVal) flags[1] = original && original.val || original

                if(name === '$isActive' )console.log('no way gozee 2',original, t)

                t.val = original;
              }
              flags[5] = null;
            }
          };
          Cases[name].addListener(flags[3][name].method);
        }
        if (Cases[name].val) {
          if (setVal) {
            flags[1] = val.val || val;
          }
          object.set.call(t, val, stamp, false, true);
          //not always
          t._ignorefornow = true

        }
        flags[5] = null;
      }
    },
    // reset:function() {
      // console.error('reset')
    // },
    //add reset later
    remove: function(flags, name) {
      // console.log(flags, name)
      var cnt = 0
      for (var i in flags[3]) {
        // if(flags[3])
        cnt++
        if(!this._ignorefornow && !name || i===name) {
          cnt --
          Cases[i].removeListener(flags[3][i].method);
        } else {
          delete this._ignorefornow
        }
      }
      if(cnt) {
        // console.log('CASE OBJECT REMOVAL --- IT IS NOT EMPY')
        return true
      }
    },
    stack: 'case'
  },
  _static = {
    set: function(val, stamp, reset, name) {
      if (val !== null) {
        object.set.call(this, val, stamp, false, true);
      }
    }
  };

flags.dynamic.cases = methods.reader(false, dynamic, _static);
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

/*
  gets and caches values for css classes, also possible to change styles of classes
  return an array of multiple css objects corresponding to the class name
  when you pass field it searches the field trough all the classes selected, always takes first argument
  maybe have to make this for things such as div selectors / nested stuff --- will be cpu intensive!;
*/
var selector = 'cssRules',
  parseclass = function(slctr) {
    slctr = '.' + slctr.replace(/\./g, ' .').toLowerCase();
    for (var robj, select = document.styleSheets, length = select.length, i = 0, selectItem; i < length; i++) {
      selectItem = select[i][selector] || select[i][(selector = 'rules')]; //location of this polyfill can be improved
      if(selectItem) {
        for (var j = 0, l = selectItem.length, item; selectItem, j < l; item = selectItem[j++], item.selectorText === slctr && (robj = item.style));
      }
    }
    return robj;
  },
  c = function(cssClass, cache) {
    var t = exports;
    cache.push(t[cssClass] || (t[cssClass] = parseclass(cssClass)) || {});
    return cssClass;
  };

module.exports = function(slctr, field) {
  if (slctr) {
    var cache = this[slctr];
    if (!cache) {
      cache = [];
      for (var selectarray = slctr.split(' '), i = 0, l = selectarray.length, cssClass; i < l; i++) {
        if ((cssClass = c(selectarray[i], cache).split('.')) instanceof Array) {
          c(cssClass[cssClass.length - 1], cache);
        }
      }
      this[slctr] = cache;
    }
    if (field) {
      if(!(cache instanceof Array))
        return
      for (var ret, i = cache.length - 1; !ret && i >= 0; ret = cache[i--][field]);
      cache = ret;  
    }
    return cache;
  }
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , valueBase = require('../../value/base')
  , vigour = require('../../')
  , util = require('../../util')
  , elementBase = new base()

elementBase.defaultType = valueBase.type

module.exports = exports = vigour.Element = elementBase.Class
exports.base = elementBase

var _doc = typeof document !== 'undefined' ? document : 'no document', //reference to document is faster than using window.document;
  /**
   * Removes children from parent node
   * @method _removeChildren
   */
  _removeChildren = function() {
    for (var c = this._node.childNodes, i = 0, l = c.length; i < l; i++) {
      if (c[i].base) {
        // console.log
        c[i].base.remove(false, false, true);
      }
    }
  };

/**
 * node
 * adds and clones html nodes;
 * @attribute
 */
exports.base.extend({
    name: 'node',
    type: false ,
    /**
     * Defines what happens when node is set
     * @method set
     * @param  {*} val Defines the value of this._node
     */
    set: function(val) {
      //changing node bugs /w conversions
      //iframe selectors dont evaluate to a string
      if (val instanceof Object || !val.length) {
        this._node = val;
      } else {
        this._node = _doc.createElement(val);
      }
      this._node.base = this;
    },
    /**
     * Defines what happens when you get node
     * @method get
     */
    get: function() {
      if (!this._node) {
        this.node = _doc.createElement('div');
      }
      return this._node;
    },
    /**
     * Defines what happens when you create a new node
     * @method new
     * @param  {Object} from    Target
     * @param  {[type]} newnode [description]
     */
    "new": function(from, newnode) {
      if (!newnode) {
        var node = from._node;
        if (node) {
          this._node = node.cloneNode(true); //especialy good to do for memory (also saves 20% on cpu)
          this._node.base = this;
        }
      } else {
        this._node = newnode;
      }
      if (from._node && from._node.hasChildNodes()) {
        var i, c = this._node.childNodes,
          cf = from._node.childNodes,
          l = c.length,
          ci, cfb;
        for (i = 0; i < l; i++) {
          cfb = cf[i].base;
          if (cfb) {
            c[i].base = new cfb.Class(false, false, c[i]);
            //maybe call children new stuff with a custom setting as well?
            if (cfb._name) {
              c[i].base._name = cfb._name;
              this[cfb._name] = c[i].base;
            }
            c[i].base.setting('parent', [this]);
          }
        }
      }
    },
    /**
     * Defines what happens when you remove a node
     * @method remove
     * @param  {*}  [param] If param doesn't remove node from parent
     */
    remove: function(param) {
      _removeChildren.call(this);
      if(this._node) this._node.base = null //little slow optimize later
      if (!param) {
        var _p = this._node.parentNode;
        if (_p) {
          _p.removeChild(this._node);
          if (this._name && _p.base) {
            _p.base[this._name] = null;
          }
        }
      }
    }
  },
  /**
   * Set css class of a div
   * Use addClass or removeClass to add/remove a class
   * @attribute css
   * @param  {Object} val [description]
   * warning: the add operator in css is currently used by .name,
   * and will be replaced when you try to build a string
   * using {val: .... add: ....}
   */
  {
    // __$css: function(val) {
      // this.css
    // }
    css: function(val) {
      var _val = val.val || '';
      val._skip = true; //_skip is an ugly name
      if(val.addClass){
        if (!~_val.indexOf(val.addClass.val)) {
          val._val = ((_val.length > 0 ? _val + ' ' : '') + val.addClass.val);
          if(val.add) val._val = val._val.replace(val.add.val,'')
          val._lval = false;
          val.__lval = false;
          val.___lval = false;
          _val = val.val;
        }
        val.addClass.remove();
      }

      if(val.removeClass){
        if (_val && val._val) {
          val._val = val._val.replace(new RegExp(' ?' + val.removeClass.val), '');
          val._lval = false;
          val.__lval = false;
          val.___lval = false;
          _val = val.val;
        }
        val.removeClass.remove();
      }

      if( _val ) {
        this.node.className = _val.replace('$','')
      } else {
        this.node.className = ''
      }
    }
  },
  /**
   * Makes it possible to reference a child by name
   * Setting on a class does not update names of instances
   * Element[NAME]
   * @attribute name
   */
  {
    name: 'name',
    type: false,
    set: function(val) {
      var _p = this.parent;
      if (this._name) {
        if (_p) {
          _p[this._name] = null;
        }
      }
      this._name = val;
      if (!this._node || val !== this.node.nodeName.toLowerCase()) {
        //name does not inherit, beware!
        // console.log('WHATS THIS?',val);
        // this.css = {addClass:val};
        // this.className = this._name;
        if(!this.css || this.css._val!==val)this.css = { add: ' ' + val }
        //special name field?
      }
      if (_p) {
        _p[val] = this;
      }
    },
    get: function() {
      return this._name;
    }
  },
  /**
   * Returns parent base element
   * @attribute parent
   */
  {
    name: 'parent',
    type: false,
    get: function() {
      if (this._node) {
        var _p = this._node.parentNode || this._p;
        return _p ? _p.base || _p._p : false;
      }
    }
  },
  /**
   * Returns childNodes /w base classes array slow, cache if possible
   * @attribute children
   */
  {
    name: 'children',
    type: false,
    get: function() {
      if(!this._node) return []
      var c = this._node.childNodes,
        l = c.length,
        _c = new Array(l),
        i;
      for (i = 0; i < l; i++) {
        _c[i] = c[i].base || c[i];
      }
      return _c;
    }
  });

var recurRender = function(parent) {

  if (!this.lastindex) this.setting('render', [parent]) //execute render settings

  if (this.renders) {

    // console.error('RENDER ---', this.name, this.renders)

    for (var p
      , c = this.node.childNodes
      , cl
      , arr = this.renders
      , obj
      , i = this.lastindex || 0, l = arr.length; i < l; i++) {
      obj = arr[i]

     if(obj) {
        p = util.checkArray(c, obj, 'base')
        if (p !== false) {
          recurRender.call(obj, this)
        } else if(obj._from) {

          // console.log('CLASS!',obj, obj.name && this[obj.name] && this[obj.name] === cl)

          cl = obj.Class

          if(obj.name && this[obj.name] && this[obj.name] === cl) {
            recurRender.call(this[obj.name], this)
          } else {
           for (var j in c) {
             if (c[j].base && c[j].base instanceof cl) {
               recurRender.call(c[j].base, this)
               break;
             }
            }
          }
        }
      }
      // arr.splice(i,1)
    }
  }

  this.lastindex = l
},

setRender = function() {
  var p, pp;
  if (this.parent) {
    p = this.parent;
    if (p.renders) {
      p.renders.push(this);
    } else {
      p.renders = [this];
      pp = p.parent;
      if (pp && !(pp._settings && pp._settings.render !== true)) {
        setRender.call(p);
      }
    }
  }
},

valRender = function(val) {
  var _settings = (val.__ && val.__._settings || val._._settings)
  if (val._.renders || val.__ && val.__.renders || _settings.render !== true) {
    if (!this.renders) this.renders = []
    if (!(this.__ && this.__.renders)) this.renders = util.clone(this.renders)
    // console.log(this.renders===this.__.renders, this.__.renders, this._.renders)

    // console.log(util.checkArray(this.renders,val._from))
    // console.log('XXXXXX',val)
    // if(util.checkArray(this.renders,val._from._from,'_from._from')===false&&util.checkArray(this.renders,val._from,'_from')===false) {
      this.renders.push(val)
    // }
    // console.log('renders push --- creates leaks!')
  }
}

//define vanuit base (korter!)
util.define(exports,
   'append', function(arr) {

    // alert('APPEND')
    // console.log('APPEND'.inverse,arr)

      var args = arguments

      if(arguments.length>1) {
        arr = util.arg(arguments)
      } //else if(arr )

      var insertbefore
      if(!arr.length && !(arr instanceof exports) && arr.val) {
        insertbefore = arr.before
        arr = arr.val
      }
      var Class = arr[0]
      , i = 0
      , l = arr.length
      if(!arr.length) {
        this.add(arr, insertbefore)
      } else if(typeof Class === 'function') {
        for(var i=1, l = arr.length;i<l;i++) {
          this.add(new Class(arr[i]), insertbefore)
        }
      } else {
        for(;i<l;i++) {
          this.add(arr[i], insertbefore)
        }
      }
  },
  'checkRender', function(val, notRendered) {
    if (val) valRender.call(this, val)
    if (!notRendered) {
      var _renders = (this.__ && this.__.renders || this._.renders)
      if ( ( (_renders  || ((this.__ && this.__._settings)  || this._._settings).render !== true)
          && (!this.lastindex || (_renders && this.lastindex < _renders.length))
        ) && this.rendered) {
        recurRender.call(this, this)
      } else {
        if(this.parent) valRender.call(this.parent, this)
      }
    }
  },
  'checkParent', util.checkParentFactory('parent'),
  'get',function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },
  'find', function(get, match, level) {
    if(level === void 0) level = true
    var children = this.node.childNodes
      , i = 0
      , found
      , child
      , len = children.length
      , passOn = level===true ? true : level-1
    for(;i<len;i++) {
      child = children[i].base
      if(child) {
        if(child.get(get, true)==match) {
          return child
        } else if(level) {
          found = child.find(get, match, passOn)
          if(found) return found
        }
      }
    }
  },
  'setRender', function(name, val) {
    this.setSetting({
      name: name,
      render: val
    });
    setRender.call(this);
    this.eachInstance(function() { //look for current caller instance perhaps?
      setRender.call(this)
    }, name);
  },
  'renders', false,
  /**
   * Add element as child
   * @method
   * @param  {Object}  val  Object to be added
   * @return {Object}       Returns the V.element
   */
  'add', function(val, insertbefore) {
    
    if(insertbefore) {
      if(typeof insertbefore === 'string') insertbefore = this[insertbefore]
      if(insertbefore) {
        this.node.insertBefore(val.node, insertbefore.node || insertbefore)
      } else {
        console.error('cannot find insertbefore')
      }
    } else {
              // console.error(val)

      this.node.appendChild(val.node)
    }

    val.setting('parent', [this]) //execute parent settings
    if (val.name) this[val.name] = val
    //--------------------
    //needs cleaning costs 3% now...
    this.checkRender(val)
    //--------------------
    return this
  },
  /**
   * Removes all children
   * @method empty
   * @param  {Boolean} instances True will remove all instances of children removed
   */
  'empty',
  function(instances) {
    var c = this.node.childNodes
      , i
    this.node.innerHtml = ''
    for (i = c.length - 1; i >= 0; i--) {
      if (c[i].base) c[i].base.remove(instances)
    }
  });

exports.base.addSetting('parent')
exports.base.addSetting('render')
require('./set')
},{"../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js","./set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/display.js":[function(require,module,exports){
var collection = require('./util')

exports.prepare = function(el) {
  if(!el.display) el.display = 'block'
}

exports.newElement = function(data, element, t) {
  var c = collection.children(t)
  for(var i in c) {
    if(c[i]._d && c[i]._d===data) {
      c[i].display = element.display.val
      return true
    }
  }
}
 
exports.rem = function (el, t, hasFilter, noResolve) {
 el.display = 'none'
 return true
}

exports.fragment = function(a,b,exclude,i) {
  //since it never removes excludes should never be applied
  //exclude is normally used to not add things again if they already exist
  if(exclude) exclude[i]=null
}

},{"./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/index.js":[function(require,module,exports){

var collection = require('./util')
  , util = require('../../../../util')

/**
 * collection
 * links arrays or object to elements
 * use filter if you want to convert
 * @attribute
 */

exports.extend = util.extend(
  require('../data'),
  function(base){

    base.extend({
      name:'collection',
      // render:function() {
      //   this.update('collection') 
      // },
      remove:function() {
        if(this._colElem) this._colElem.remove()
      },
      set: function(val, stamp, from, remove, change, added) {

        // console.error('xxxx!@#!!@#!#', this.data && this.data.toString())

        val._skip = true

        var hasFilter = collection.filter(val, this)
          , data = this.filter || val.val
          , options = this._colOptions || val.options 
              && (this._colOptions = val.options.convert())
          , orig =  val.element
          , el = this._colElem 
              || (orig && orig._val) && (this._colElem = new (orig._val.Class || orig._val)())
          , firstRun = !this._colInit
          , slStamp
          , elVal
          , colElem = this._colElem

          // console.log('!!!OPTIONS!', options)

        //dirty block! clean it FAST

        // || !this.rendered 

        if(!(data && el)) return //||!this.rendered
        
        slStamp = orig._slStamp
        elVal = orig._val

        if(slStamp) {
          orig._slStamp = stamp
        } else if(colElem && orig._slStamp !== stamp) {
          if(!(elVal.Class && (colElem instanceof elVal.Class)) 
            && !(!elVal.Class && (colElem instanceof elVal))) {
            el = this._colElem = new (elVal.Class || elVal)()
            orig._slStamp = stamp
          }
        }



        // console.log('ook leuk ff update', val, stamp, from, remove, change, added)
          // console.log('pass!')
          
        if(firstRun) {

          options && options.prepare && options.prepare(el)

          this._colInit = true
          this.node.appendChild(collection.fragment( data, el, this, false, options
            , hasFilter ))

        } else {

          if(from && from._parent === data.from) {
            if(remove) {
              var r = util.checkArray(collection.children(this),from,'_d',true)
              if(r) {
                if(!(options && options.rem && options.rem(r, this, hasFilter))) {
                  r.remove()
                }
              }
            } else if(util.checkArray(collection.children(this),from,'_d')===false) {

              collection.element( from, el, this, true, this.node, options, hasFilter, true )
            } else if(hasFilter && options && options.indexChange) {

                options.indexChange(
                  util.checkArray(collection.children(this),from,'_d',true)
                  , this, hasFilter )
            }
            
          } else {
            
            // console.log('122XXXXX', from, hasFilter, collection.filter(val, this)) //try to fix order by name better

            if(!from) {

              if(remove) {
                collection.clear(this, options)
              } else {

                var c = collection.children(this)
                  , exclude = {}
                  , name
                  , fField
                  , keys
                  , child

                // console.log('XXXXX',hasFilter) //try to fix order by name better
                if(hasFilter===true) {
                  keys = data.keys
                }

                for(var j in c) {
                  child = c[j]
                  name = c[j]._d._name

                  // console.log(c[j], hasFilter, keys, util.checkArray(data,child._d) === false)

                  if(hasFilter && !keys ? util.checkArray(data,child._d) === false : !data[name] || data[name]!==child._d ) {

                    // console.log('CHECK!---',j)

                    if(!(options && options.rem && options.rem(child, this, hasFilter, hasFilter))) {
                      child.remove()
                    }
                  } else {
                    //this is more efficient
                    // if(data[name]!==c[j]._d) c[j].data = data[name] 
                    exclude[name]=true
                    if(hasFilter) {
                      if(options && options.indexChange) {
                        if(child._d._indexCache[hasFilter][0]!==child.i) {
                          options.indexChange(child, this, hasFilter, true)
                        }
                      } else if(hasFilter===true) {
                        if(j!=util.checkArray(keys,name,true)) {
                          delete exclude[name]
                          if(!(options && options.rem && options.rem(c[j], this, hasFilter, hasFilter))) {
                            child.remove()
                          }
                        } 
                      }
                    }
                  }
                }

                this.node.appendChild(
                  collection.fragment(data, el, this, exclude, options, hasFilter)
                )
              }

            }
          }
        }
      }
    })
})
},{"../../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/data.js","./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js":[function(require,module,exports){
var element = require('../')
  , Data = require('../../../../data').inject(require('../../../../data/selection'))
  , util = require('../../../../util')

var r = function() {
  return String(~~(Math.random()*9))+''
}

exports.element = function (data, element, t, update, node, options, hasFilter, resolve) {
  var elem
  if(options && options.newElement) {
    elem = options.newElement.apply(this,arguments)
    if(elem===true) return
  }
  elem = elem || new element.Class()
  
  elem._col = true

//   console.log( '---->', data )

  if (data !== void 0) elem._dSet(data)
  if (node) node.appendChild(elem.node)
  elem.setting('parent', [t])
  ;options&&options.element&&options.element(elem, t, hasFilter, resolve)
  if (update && data !== void 0) elem.updateData()
  t.checkRender(elem, true)
  return elem
}

exports.fragment = function (data, element, t, exclude, options, hasFilter) {
  var frag = document.createDocumentFragment()
    , item = function(i) {
        //if you use the passed i it is a different value for selections
        if(this._name) i = this._name
        if(!(options&&options.fragment&&options.fragment(t,this,exclude,i))
          && (!exclude || !exclude[i]) ) {
          var elem = exports.element( this || null, element, t, false, frag, options
              , hasFilter)
          if(elem) frag.appendChild( elem.node )
          elem.updateData()
        }
      }
  frag._p = t

  if(data.each) {
    data.each(item)
  } else {
    //normal data
    for(var i in data) {
      item.call( data[i] ,i )
    }
  }

  // element.updateData(true)
  return frag
}

exports.children = function (t, options) {
  if(!t) return
  var ch = []
  for(var i in t.node.childNodes) {
    var child = t.node.childNodes[i].base
    if(child && child._col) {
      ch.push(child)
    }
  }
  ;options&&options.children&&options.children(ch)
  return ch
}

exports.clear = function (t, options) {
  t.colInit = null
  var c = exports.children(t)
  for(var i in c) { c[i].remove() }
  ;options&&options.clear&&options.clear(t)
}

exports.filter = function (val,t) {


  var data = val.val


  // console.log('DO I HAVE FULTER!>?',data,  val, t)


  if(val.filter && val.filter.val===true) {
    // console.log('sort by name') moet beter
        // console.log('got it!DATAx!')

    return true
    //different vibes
  }

  if (data && val.filter && !t.filter) {

    // console.log('MAKE NEW STYUFFF')

    var a = val.filter.raw
    //dit is kapot
    data = t.filter = new Data(data, a)

    // console.log('FILTERSSSS!', a, t)
    // debugger

    a._col = true
    
    data.addListener(function (val, stamp, from, remove) {
      t.collection._update(val, stamp, from, remove)
    })
    
    t.setSetting({
      // name: 'collecitonfilter',
      remove: function () {
        t.filter.remove()
        t.filter = null
      }
    })

    // console.log('DATAx!')
    return data._uid
    // return t.filter._uid//data is filter
  } else if(data && data._filter) {
        // console.log('DxxxATAx!')

    return data._uid
  } 
  else if(t.filter) {

    return t.filter._uid
  }

    // console.log('NO DATAX! FILTER', t)

}

// exports.indexChange = function(el, t, hasFilter, noResolve) {
// var oldIndex = el._d._indexCache[hasFilter][1]
//     , newIndex = el._d._indexCache[hasFilter][0]
//     , ch = !noResolve && collection.children(t,exports)
//     , l


//   exports.xy(el)

//   if(noResolve) return

//   l = ch.length
  
  
//   var clone = el.node.cloneNode(true)
//   t.node.removeChild(el)
//   el._node = clone


   
//   // t.h = t.node.scrollHeight
// }
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","../../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../../data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","../../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var data = require('../../../data/base')
  , util = require('../../../util')
  , flags = require('../../../value/flags')

/**
  * extends updateData to take childNodes into account
  * may need to add extra argument for go deep
  * @method
*/
exports.extend = util.extend([ data, {
  updateData: function ( instances, data, fmodel ) {

    // if( instances ) console.error('????----------->>>>>')

    if (this._d) {
      this._subscribed = false
      data = this._d
    }

    var ffmodel = false
    var parsed = false
    if (!fmodel && !this.model && !this._fmodel) ffmodel = true
    //fmodel is first model
    for (var children = this.node.childNodes
      , i = children.length - 1
      , base; i >= 0; i--) {

      base = children[i].base
      
      // if(base && base.model && base.model.field && base.modelParsed !== base.model.field.val && base.instances && instances) {
      //   // console.error('1', base && base.name, base.instances)
      //       if(!data && instances) {
      //         if(!data) {
      //           data = base.checkParent('_d',true) || this.checkParent('_d',true)
      //           // console.log('hey hey hey', data, this._d, base._d, base)
      //         }
      //         console.error('lezzgo instances', data)
      //         // base._d = data = data.get(this.model.field.val) //util.path(data,this.model.field.val.split('.'))
      //         for(var i in base.instances) {
      //           if(!base.instances[i].model.parsed) {
      //             // console.error('?',base.instances[i].model.parsed)
      //             base.instances[i].updateData(false, data)
      //           }
      //         }
      //         // base.modelParsed = 
      //         // base.model = {}
      //         // base.model.parsed = base.model.field.val 
      //         // return
      //       }
      // }

      // if(base && base.model && base.model.field && !base._d) {
        // base._dSet(data, true)
      // }

      if (base
      && (!(base.model && base.model.inherit && base.model.inherit.val===false))
      && (base._d === void 0 || base._dfrom || (base.model && base.model.field) )) {
        var tdata = data

        if (base.model && (data || base.model && base.model.field)) {
          if (ffmodel) base._fmodel = true

          //hier ook ff model parsen!
          if(base.model && base.model.field) {
            tdata = data.get(base.model.field.val)
            base.modelParsed = base.model.field.val
            // console.error(tdata)
          }
            // console.error(tdata._cachedPath)

          base._dSet(tdata, true)
        }

        base.updateData(false, tdata, base._fmodel || fmodel)
      }
    }
  }
}])
},{"../../../data/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/base.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    here some basic html properties are added to V.Element.Nessecary
    for values that you want to be able to bind to V.Objects
    Uses base.extend -- see core.base for more information
  */

var ua = require('../../ua')
var css = require('../../css')
var Value = require('../../../value')
var util = require('../../../util')
var hash = require('../../../util/hash')
var raf = require('../../animation/raf')
var _load = require('../').images = {}
var _transform = ua.prefix + 'Transform'
var _cssTransform = ua.prefix + '-transform'
var postpone = require('vigour-js/browser/events/util').postpone
var body = document.body.style
    //think about doc ready event or fallback if no body
var _translate = body.perspectiveProperty != void 0
                 || body.WebkitPerspective != void 0
                    ? ['translate3d(', ',0px)']
                    : ['translate(', ')']
var _coordinate = function(style) {
      var margin = 'margin' + (style[0].toUpperCase() + style.slice(1));
      return function(val) {
        if(val.clean) {
          _cleanCoordinate.call(this,style,margin)
          val.clean = null
        }
        if (val.translate) {
          this.translate(val)
        } else {
          this.node.style[this.relative ? margin : style] = val.val + 'px'
        }
      }
    }
var _clearTransform = new RegExp(_cssTransform+'(.*?);')
var _clear =
    { x: /(margin-left(.*?);)|(left(.*?);)/g
    , y: /(margin-top(.*?);)|(top(.*?);)/g
    }
var _cleanCoordinate = function( check ) {
      var t = this._t
      , keep = false
      , val = this[check]
      , cssText = this.node.style.cssText.replace( _clear[check], '' )

    if( val && val.translate && val.translate.val===false) val.translate = null

    if(this.node.style[_transform] && !val.translate) {
      if(t) {
        if(!this[check].translate) {
          for(var i = 2 ; i < 6 ; i++) {
            if(t[i])keep=true
          }
        } else {
          keep=true
        }
      }
      if(!keep) cssText = cssText.replace(_clearTransform,'')
    }
    this.node.style.cssText = cssText
  }

var setTimers, removeTimers, _setTimeout

exports.extend = util.extend(function(base) {
  util.define(base.Class,
    'cleanCoordinates', function(coord) {
       if(this._node) {
        if(!coord) {
          _cleanCoordinate.call(this,'x')
          _cleanCoordinate.call(this,'y')
        } else {
          _cleanCoordinate.call(this,coord)
        }
      }
    },
    'translate', function(val) {
    var _x
      , _y
      , _val =  val.val
      , _scale
      , _rotate
      , _rotateY
      , _rotateX
      , _str = ''
      , _name = val && val._prop.name
      , _t = this._t = this._t || []
      , nope = false

    //cirtical performance point hence use of | 0
    if (_name === 'x') {
      _x = _val | 0
      if (_x === _t[0]) nope = true
    } else if (_name === 'y') {
      _y = _val | 0
      if (_y === _t[1]) nope = true
    } else if (_name === 'rotate') {
      _rotate = _val
      if (_rotate === _t[2]) nope = true
    } else if (_name === 'scale') {
      _scale = _val
      if (_scale === _t[3]) nope = true
    } else if (_name === 'rotateY') {
      _rotateY = _val
      if (_rotateY === _t[4]) nope = true
    } else if (_name === 'rotateX') {
      _rotateX = _val
      if (_rotateX === _t[4]) nope = true
    }

    if (!nope) {
      _t[0] =  _x || (this.x.translate && this.x.val | 0) || 0
      _t[1] =  _y || (this.y.translate && this.y.val | 0) || 0
      _t[2] = _rotate || this.rotate.val
      _t[3] = _scale || this.scale.val
      _t[4] = _rotateY || this.rotateY.val
      _t[5] = _rotateX || this.rotateX.val
      if (_t[0] || _t[1]) {
        _str = _str
          .concat(
            _translate[0]
          + _t[0] + 'px,'
          + _t[1] + 'px'
          + _translate[1]
          )
      }
      if (_t[2]) { _str = _str.concat(' rotate(' + _t[2] + 'deg)') }
      if (_t[3]) { _str = _str.concat(' scale(' + _t[3] + ')') }
      if (_t[4]) { _str = _str.concat(' rotateY(' + _t[4] + 'deg)') }
      if (_t[5]) { _str = _str.concat(' rotateX(' + _t[5] + 'deg)') }
      this.node.style[_transform] = _str
    }
    return this
  }, 'update', function() {
    for (var i = 0, _args = util.arg(arguments), l = _args.length, p; i < l; i++ ) {
      if (_args[i] instanceof Array) {
        this.update.apply(this, _args[i]);
      } else {
        p = util.get(this, _args[i]);
        if (p) {
          p.update(this);
        }
      }
    }
    return this;
  });

  var done = postpone(function(val,self,sdir){
    if(self){
      if(val._listeners !== void 0) val.val = self.node[sdir]
      else self[sdir].__lval = void 0
    }
  },20)

  function createScroll(dir){
    var s = 'scroll'
      , sdir = s + dir //scrollLeft or scrollTop

    return {
      name:sdir,
      set:function(val) {
        var v = val.val
          , self = this
        if(v !== void 0) self.node[sdir] = v
        if(!self.__sT){
          self.__sT = true
          self.addEvent(s,function(){
            done(val,self,sdir)
          })
        }

      },
      get:function(val){
        if(val.__lval === void 0) val.val = this.node[sdir]
        return val
      },
      render:function() {
        var self = this
          , val = self[sdir].__lval
        if(val){
          raf(function(){
            self.node[sdir] = val
          })
        }
      }
    }

  }

  base.extend({
    name: 'relative',
    type: false,
    get: function() {
      var s = this.position !== false ? this.position.val : (this.position = {
        css: true,
        val: css(this.css.val, 'position')
      })
      return s !== 'absolute'
    }
  },
  {
    type: false,
    name: 'rendered',
    get: function() {
      var ret = this._rendered || (this.node === document.body),
        parent;
      if (!ret) {
        parent = this.node.parentNode;
        while (!ret && parent) {
          if (parent.base && parent._rendered) {
            ret = true;
          }
          if (parent == document.body) {
            ret = true;
          }
          parent = parent.parentNode;
        }
        if (ret) {
          this._rendered = true;
        }
      }
      return ret;
    }
  },
  createScroll('Left'),
  createScroll('Top'),
  {
    position: function(val) {
      // console.log('?????',val.css.val)
      // if (!val.css) { //check when ignoring this becomes a problem
        this.node.style.position = val.val;
      // }
    },
    // scrollTop:function(val) {
    //   console.error(val.val)
    //   this.node.scrollTop = val.val
    // },
    rotate: function(val) {
      this.translate(val);
    },
    rotateY: function(val) {
      this.translate(val);
    },
    rotateX: function(val) {
      this.translate(val);
    },
    scale: function(val) {
      this.translate(val);
    },
    src: function(val) {
      var v = val.val;
      if (v && v[v.length - 1] !== '/') {
        this.node.src = v;
      }
    },
    attr:function(val) {
      var t = this
      val.each(function(i) {
        t.node.setAttribute(i,this.val)
      })
    },
    backgroundPos: function(val) {
      this.node.style.backgroundPosition = val.val
    },
    backgroundBatch: function(val) {


    },
    background: function(val) { //optional maybe in a seperate module
      var v = val.val
        , t = this
        , style = this.node.style
        , url
        , hashed
        , parentBatch
        , batch

      if(val.gone && val.gone.val) {
        val._skip = true
        style.backgroundImage = ''
      } else if (v && v[v.length - 1] !== '/') {
        url = 'url(' + v + ')'
        if(style.backgroundImage===url) return

        //Value
        if (val.size) style.backgroundSize = val.size.val

        if (val.load) {

          hashed = hash(v)
          parentBatch = this.checkParent('backgroundBatch')
          if(parentBatch) batch = parentBatch.backgroundBatch

          if(!_load[hashed]) {
            this._loaded = null
            //also remove setting

            if(batch) {
              window.cancelAnimationFrame(batch._raf)
              if(!batch.batch) batch.batch = []
              batch.batch.push(hash)
            }

            _load[hashed]=new Value(false)
            var img = document.createElement('img')
            img.onload = function() {

             if(batch) {
               batch.batch.splice(util.checkArray(batch.batch,hashed),1)
               if(batch.batch.length===0) {
                batch.batch = null
                batch._raf = raf(function() {
                  if(parentBatch._node) batch._val.call(parentBatch)
                })
               }
             }

              _load[hashed].val = true
              img.onload = null
              img = null
              _load[hashed].remove(false,false,false,false,false,true)
              _load[hashed] = true
            }
            img.src = v
          }

          if(_load[hashed]!==true) {
             this._loaded = null

            _load[hashed].addListener([function() {
              if(val.load && val.load.val!==true) val.load._val.call(this, t);
            },val._base], true)
          } else {

            this._loaded = true

            if(batch) {
              if((!batch.batch) || batch.batch.length===0) {
                batch.batch = null
                window.cancelAnimationFrame(batch._raf)
                batch._raf = raf(function() {
                   if(parentBatch._node) batch._val.call(parentBatch)
                })
              }
            }

            if(val.load.val!==true) val.load._val.call(this, t);

          }
        }

        style.backgroundImage = url

      }
    },
    padding: function(val) {
      this.node.style.padding = val.val + 'px';
    },
    y: _coordinate('top'),
    x: _coordinate('left'),
    display: function(val) {
      this.node.style.display = val.val;
    },
    w: function(val) {
      // console.log('w');
      var v = val.val
      this.node.style.width = (v > -1 ? (v | 0)  + 'px' : v ) || '100%' 
    },
    h: function(val) {
      // var v = val.val | 0 typo or bug?
      var v = val.val
      this.node.style.height = (v > -1 ? (v | 0)  + 'px' : v ) || '100%'
    },
    opacity: function(val) {
      var v = val.val;
      if(v===false) this.node.style.opacity = null
      else this.node.style.opacity = v > -1 ? v : 1;
    },
    html: function(val) {
      var v = val.val || ''
      if( v.replace )
      {
        //add some injection prevention as option? (no script etc)
        v = v.replace(/\t/g, '    ')
             .replace(/\r\n|\n|\r/g, '<br/>')
             .replace(/  /g, '&nbsp; ')
             .replace(/  /g, ' &nbsp;') // second pass
                                        // handles odd number of spaces, where we
                                        // end up with "&nbsp;" + " " + " "
        this.node.innerHTML = v
      }

    },
    href: function(val) {
      this.node.href = val.val;
    },
    text: function(val) {

      // console.log('SETTING TEXT'.green.inverse. val.val, val)

      var node = this.node
        , nodes = node.childNodes
        , v = val.val || val.val === 0 ? val.val : ''

      if(v instanceof Object) v = ''

      if (/text/.test(node.type)) {
        node.value = v;
        return;
      }

      if (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].nodeType === 3) {
            // console.log('BLABLA'.inverse,v)
            nodes[i].nodeValue = v;
            return;
          }
        }
      }
      node.appendChild(document.createTextNode(v));
    },
    $timeout: function( val ) {
      if(setTimers === void 0){
        setTimers = function() {
          var _this = this
          var timeout = this.$timeout
          if( timeout ) {
            if(_setTimeout === void 0){
              _setTimeout = function( _this, timeout, keys, i ) {
                var time = keys[ i ] - ( keys[ i - 1 ] || 0 )
                var fn = timeout[ keys[ i ] ]._val
                fn.id = setTimeout( function() {
                  fn.id = null
                  if( !fn.done || !_this.done ) {
                    fn.call( _this )
                    fn.done = true
                    _this.done = null
                  }
                  if( keys[ ++i ] ) _setTimeout( _this, timeout, keys, i )
                }, time )
              }

            }

            _setTimeout( _this, timeout, timeout.keys, 0 )
          }
        }
      }
      if( this.rendered ) {
        setTimers.call( this )
      } else {
        this.setSetting( {
          name: 'setTimers',
          render: setTimers
        } )
      }

      this.setSetting( {
        name: 'removeTimers',
        remove: removeTimers || (removeTimers = function() {
          console.error('--------REMOVE',this._node)
          var timers = this.$timeout
          if( timers ) {
            timers.each( function() {
              var fn = this._val
              console.error('---------removing',fn,fn.done)
              if( this.done ) this.done = null
              if( fn.id ) clearTimeout( fn.id )
              if( fn.done ) fn.done = null
            } )
          }
        })
      } )
    }
  });
});
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","../../css":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(function(base) {
  var proto = base.Class.prototype
    , add = proto.add

  util.define
  ( proto
  , 'add'
  ,  function(val) {
       if( !val.process )
       {
          add.apply( this, arguments )
       } else
       {
          val.__tempAdd = util.arg( arguments )
          val.__tempAdd.unshift(this)
       }
     }
  )

  base.extend({
    process: function(val) {
      console.log('xxxx___xxxx')
      if(this.__tempAdd && !this.parent) {
        add.apply(this.__tempAdd[0], this.__tempAdd.slice(1))
        this.__tempAdd = null
      }
    }
  })

})

//process wordt mischien meer een operator?
//soort field eigenlijk
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/scrollbar.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = require('../../events')
  , cases = require('../../cases')
  , ua = require('../../ua')
  , global = false
  , NONE = 'none'
  , _ios = ua.platform==='ios'
  , _android = ua.platform==='android'
  , VISIBLE = 'visible'
  , extend = require('../../../util').extend
  , doc = events.document
  , timer
  , fn

if(cases.$hasTouch){

  function blur (e){
    if(!document.activeElement){
      doc.removeEvent(false,'blur')
    }else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM'){
      document.activeElement.blur()
      doc.removeEvent(false,'blur')
    }
  }

  events.preventDown = 
  { val:
    { down:function(e,method) {
        if(document.activeElement) doc.addEvent('up',blur,'blur')
        else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM' && !events._maybescroll) e.preventDefault()
      }
    }
  }

  events.scrollbar = 
  { val: 
    { down:function(e,method,val) {

        var scrollStart
          , t = this
          , scrollStr
          , xAxis = (val._val === 'x')
          , axis
          , otheraxis
          , move
          , d
          , bottomPrevent
          
        if(xAxis) {
          axis = 'x'
          otheraxis = 'y'
          scrollStr = 'scrollLeft'
          d = t.node.scrollWidth - t.node.offsetWidth
        }else{
          axis = 'y'
          otheraxis = 'x'
          scrollStr = 'scrollTop'
          d = t.node.scrollHeight - t.node.offsetHeight
        }

        scrollStart = t.node[scrollStr] //<======== less efficient but more predictable for compensation

        if(d > 0){
          events[axis] = true
          events._maybescroll = true
          if(!xAxis){
            if (!scrollStart){
              scrollStart = t.node[scrollStr] =  1
            }else if(scrollStart===d) {
              scrollStart = t.node[scrollStr] = d - 1
            }else if(scrollStart > d){
              bottomPrevent = true
            }
          }

          var y = e.y
            , x = e.x
            , moveid = scrollStr + axis
          
          doc.addEvent('move',function(e){
            var dx = Math.abs(x-e.x)
              , dY = y-e.y
              , dy = Math.abs(dY)

            if(xAxis){
              if(dy > dx){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
            }else{
              if(dx > dy){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
              if(bottomPrevent && dY > 0){
                e.preventDefault()
              }
            }

            move = true
            blur(e)
            doc.removeEvent(false,moveid)
          },moveid)

          doc.addEvent('up',function(e) {
            var ms = events._maybescroll, msl, arr

            if(!move){
              var scrll = t.node[scrollStr]
              move = !(scrll === scrollStart) || scrll < 0 || ( scrll > d && !bottomPrevent )
            }

            if(!move && !events[otheraxis] && !events.click.block && ms && ms.length){
              msl = ms.length
              while(msl--) if(!e.prevent){
                arr = ms[msl]
                arr[0].call(arr[1],e)
              }
            }

            if(!events[otheraxis] || move) events._maybescroll = false

            events[axis] = false
            doc.removeEvent(false,scrollStr)

            window.requestAnimationFrame(function(){
              document.body.scrollTop = 0
            })
          },scrollStr)
        }
      }
    }
  }

  fn = function (val) {
      
    var style = this.node.style

    style.overflow = 'scroll'
    style.webkitOverflowScrolling = 'touch'
    style.msTouchAction = 'auto'
    style.touchAction = 'auto'

    if (val.val === 'x') {
      style.msTouchAction = 'pan-x'
      style.touchAction = 'pan-x'
      style.overflowY = 'hidden'
      style.overflowX = 'scroll'
    }else if (val.val === 'y') {
      style.msTouchAction = 'pan-y'
      style.touchAction = 'pan-y'
      style.overflowX = 'hidden'
      style.overflowY = 'scroll'
    }

    this.events = { scrollbar:val.val }
    if(!global) {
      global = true
      doc.events = { preventDown:true }
    }
  }

}else{

  fn = function (val) {
    console.error('nunu hey!')

    var style = this.node.style;
    style.overflow = 'auto';
    style.overflowY = val.val !== 'x' ? 'scroll' : 'hidden';
    style.overflowX = val.val !== 'y' ? 'scroll' : 'hidden';
  }

}

exports.extend = extend(function(base) {
  base.extend({ scrollbar:fn })
})  
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../../events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/util.js":[function(require,module,exports){
var ua = require('../../ua')
  , _prefix = '-'+ua.prefix.toLowerCase()
  , _transform = _prefix + '-transform'

exports.getMatrix = function(node) {
  if(node.style[_transform]) {
    var arr = window.getComputedStyle(node, null)
      .getPropertyValue(_transform).replace('matrix(', '').split(',')
    return arr
  }
}

// exports.hasCalc = function() {
//   var dummy = document.createElement('div')
//     , props = [ _prefix+'-calc', 'calc' ]
//     , i = props.length
//   while(i-1) {
//     dummy.style.cssText = 'width:' + props[i-1] + '(1px);'
//     if (dummy.style.length) return props[i-1]
//     i--
//   }
// }
},{"../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , element = require('./')
  , object = require('../../object')

/**
 * flags
 * add keywords to set objects which are checked using a function in flags
 * simply add fields to the set module
 */
var flags = exports
  /**
   * _flag
   * function that calls flag functions on element.set.flags
   */
  , _flag = function(name, val, copy, top) {
      var f;
      for (var i in flags) {
        f = flags[i].call(this, name, val, copy, top);
        if (f) {
          return f;
        }
      }
    }

util.define(element,
  /**
   * set
   * adds children for non existing attributes
   * _original are original values changed by cases and events
   * instances - add or remove children from instances;
   */
  '_set', function(val, i, instances) {
    //this
    if (!_flag.call(this, i, val[i], instances, val)) {

      if ( !this.isProperty( i, val ) ) {

        if (val[i] instanceof element) {
          var before
          if (this[i]) {
            for(var c=this.node.childNodes,node$=0,len=c.length;node$<len;node$++) {
              if(c[node$]===this[i].node) {
                before = c[(node$+1)]
                break;
              }
            }
            this[i].remove && this[i].remove();
          }
          //replace element if its already there
          // console.error(add, instances, val[i])
          var add = instances ? new val[i].Class : val[i];
          add.name = i;
          this.add(add, before);
          if (instances) {
            this.eachInstance(function() {
              var a = new add.Class();
              a._name = i;
              this.add(a);
            });
          }
        } else {
          
          if( this[i] instanceof object ) 
          {
            //TODO: torough testing
            this[i].val = val[i]
          } 
          else if( val[i] instanceof object ) 
          {
            console.warn('are you sure you want to set using a vObject? maybe require some stuff (e.g. data)')
            this[i] = val[i]
          } 
          else if( this[i] instanceof element ) 
          {
            if( val[i] ) {
              this[i].set(val[i], instances)
            } else if( val[i] === false ){
              if ( instances ) {
                this.eachInstance(function() {
                  if (this[i]) this[i].remove()
                })
              }
              this[i].remove()
              this[i] = null
            }
          } 
          else 
          {
            if(val[i] instanceof Object ) {
              var add = new element().set(val[i], instances)
              add.name = i;
              this.add(add)
              if (instances)
              {
                this.eachInstance( function() {
                  var a = new add.Class()
                  a._name = i
                  this.add(a)
                })
              }
            } else {
              console.warn('"' + i + '" is not an existing property. "' + val[i] + '" is a primitive. Adding as primitive.' )
              this[i] = val[i]
            }

          }
        }
      } else {
        if(typeof this[i] === 'function') {
          if(val[i] instanceof Array) {
            this[i].apply(this,val[i])
          } else {
            this[i](val[i])
          }
        } else {
          this[i] = val[i]
        }
      }
      //dynamic changes to the _original set object pool
      //if (!copy && this._original) {
      //this._original[i] = val[i]; //check if stuff /w classes is nessecary;
      //}
    }
  },
  /**
   * convert
   * for each fields in val convert back to a setObject;
   */
  'convert', function(val) {
    var setObj = {},
      isObj;
    for (var i in val) {
      isObj = util.isObj(val[i])
      if (this[i] instanceof element) {
        setObj[i] = isObj ? this[i].convert(val[i]) : this[i]
      } else if (this[i] instanceof object) {
        setObj[i] = this[i].convert(isObj && val[i])
      } else if (this[i] === void 0 || (util.lookup.call(this, i) && this[i] === false)) {
        setObj[i] = false
      } else {
        setObj[i] = this[i]
      }
    }
    return setObj
  })
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
//duration in a V.Value --> update if nessecary?
var ua = require('../../ua')
  , video = require('./')
  , postpone = require('../../../browser/events/util').postpone
  , _winPhone = ua.platform === 'windows' && ua.device === 'phone'
  , _ios = ua.platform === 'ios'
  , _android = ua.platform === 'android'
  , _ios7 = _ios && navigator.userAgent.split('OS')[1][1] === '7' // TEMP FIX UNTIL WE DO UA
  , _canplay = 'canplay'//_ios7 ? 'canplaythrough' : 'canplay' 

function createListener () {
  var args = arguments
    , l = args.length

  return function(type) {
    for (var i = 0, _this = this; i < l; this.node.addEventListener(args[i++]
      , function(e) { type._val.call(_this,e) }));
  }

}

function _canplayListener () {
  if ( !this._canplay && !_winPhone ) { //later versions (if fixedin 9)
    
    var _this = this
      , node = this.node
    
    this._canplay = true
    
    // if(_ios) node.style.visibility = 'hidden'

    function canPlay() {
      if ( _this.time ) {
        
        if (!_this.time.val) this._firstT = true
          //fixes for phonegap! windowsmobile
        if (_android && ua.browser !== 'chrome') { 
          //and special browser!; check firefox; //identify more browsers that do not need this crap
          var tries = 0
          clearInterval( _this._timeFixInterval )
          _this._timeFixInterval = setInterval(function() {
            _this.updateTime()
            if (tries === 3) {
              _this._canplay = null
              clearInterval(_this._timeFixInterval)
            }
            if (_this.node.duration !== 1) { //android sets duration to 1 as default instead of 0
              tries++
              if (_this.playing) _this.node.play()
            }
          }, 200)
        } else {

          if (_this.time.val) {
            if (_ios7) {
              setTimeout(function() { _this.updateTime() }, 0)
            } else {
              _this.updateTime()
            }
          } else {
            _this._forceTime = true 
          }

          if( _ios && this.playing ){
            var time = _this.time.val * _this.duration.val
            function timeupdate(){
              if(~~node.currentTime >= ~~time){
                node.removeEventListener('timeupdate', timeupdate)
                if(_ios7){
                  function canplaythrough(){
                    node.play()
                    node.style.visibility = 'visible'
                    node.removeEventListener('canplaythrough',canplaythrough)
                  }
                  node.addEventListener('canplaythrough',canplaythrough)
                }else{
                  node.play()
                }
              }
            }

            node.addEventListener('timeupdate', timeupdate)
            node.pause()
          }

          _this._canplay = null

        }
      }

      node.removeEventListener(_canplay, canPlay)
    }

    this._canPlay = canPlay
    node.addEventListener(_canplay, canPlay)
  }
}

function setTime (val) {
  if (this.node.readyState) {
    this.node.currentTime = val
    if (_ios) this._correctTime = val
  } else {
    _canplayListener.call(this)
  }
}


module.exports =  
{ progress: {
    set: function() {
      var _this = this
      this.node.addEventListener('end', (_this._prEnd = function() {
        _this.clearProgress()
      }))
    },
    remove: function() {
      this.node.removeEventListener('canplay',this._canPlay)
      this.node.removeEventListener('end', this._prEnd) //maybe no play and pause!;
    }
  }
, buffer: function(val) {
    var buffered = this.node && this.node.buffered
    if (buffered) {
      var l = buffered.length
        , piv = -1
        , t = this.node.currentTime || 0
        , ls
        , tt
        , i = 0
      
      for (; i < l; i++) {
        ls = buffered.start(i)
        if (ls > piv && ls < t) {
          piv = i
          tt = ls
        } else {
          break
        }
      }
      if (piv > -1) {
        piv = buffered.end(piv)
        return piv < t ? 0 : piv / this.duration.val
      } else {
        return 0
      }
    }
    return 0
  }
, play: function(val) {
    if(this.node && this.node.pause) {
      if (val) {
        this.node.play()
      }
      else {
        this.node.pause()
      }
    }
  }
, time: 
  //tests for android , winphone, firefoxphone (seeking on winphone is not possible anyways)
  { set   //_ios  || _android //ua.device === 'phone' || ua.device === 'tablet'
      // postpone(setTime)
    : setTime
  , get: function(val) {
      var time = this.node && this.node.currentTime
      if (this._correctTime) {
        if (this._correctTime > time - 2 && this._correctTime < time + 2) { //|| this.cnt
          time = this._correctTime
          if (!this.cnt) {
            this.cnt = 3
          } else if (this._cnt < 2) {
            this._correctTime = false
            this._cnt = false
          } else {
            this._correctTime+=0.5 //should be interval of progress updates
            this._cnt--
          }
        } else {
          time = this._correctTime
        }
      }
      return time / this.duration.val || val.val
    }
  }
, duration: function(val) {
    var node = this.node
    return node && node.readyState ? node.duration : val && val.val
  }
, autoplay: function(val) {
    if(this.node) this.node.autoplay = val.val
  }
, loop: function(val) {
    if(this.node) this.node.loop = val.val
  }
, volume: function(val) {
    var volume = val.val
    if(this.node && !isNaN(volume)) this.node.volume = volume
  }

, "new": function() {
    this.addEvent('down',function(e){ e.preventDefault() })
    _canplayListener.call(this)
    if (this.volume) this.volume.update(this)
  }
, events: {
    pause:function(val) {
      var _this = this
      if(_ios && _this.node) { 
       _this.node.addEventListener('pause', function(e) {
         if(!_this.ignoreevents) _this.pause()     
       })
      }
    }
  , progress: video.progress
  , ready: createListener('loadedmetadata')
  , canplay: function(val) {
      var _this = this
      if(_this.node) _this.node.addEventListener(_canplay, function(e) {
        if(_this.node && _this.node.readyState===4) {
          _this._stalled = false
          val._val.call(_this,e)
        }
      })
    }
  , stalled: function(val) {
      var _this = this
        , node = this.node
        , listen = function(e) {
          var time = _this.getTime()
          if(!(_this.getBuffer(time)-time > 0.05)) {
            _this._stalled = true
            val._val.call(_this,e)
          }
        }
      if(node){
        node.addEventListener('stalled', listen )
        node.addEventListener('waiting', listen )
      }
    }
  , play: 
    { play: function() {
        if (this.events.play) this.events.play._val.call(this)
      }
    , set: false
    }
  , end: createListener('ended')
  }
, src: function(val) {
    var src = this.node.src
    if (src !== val || val || !val && src) this.node.src = val.val
  }
}

if (!video.player) video.player = module.exports
},{"../../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var element = require('../')
  .inject
  ( require('../properties')
  )

  , events = require('../../events')
  , util = require('../../../util')
  , postpone = require('../../events/util').postpone
  , base = new element({
      node: 'video'
  })
  
module.exports = exports = base.Class
var video = exports
exports.base = base

base.setSetting(
{ name: '_videoSettings'
, new: function() {
    if (this.player.new) this.player.new.call(this)
  }
, remove:function() {
    if (this.player.remove) this.player.remove.call(this)
  }
, render:function() {
     if (this.player.render) this.player.render.call(this)
  }
})
//proxy adden --> should be an extension on src
base.node.setAttribute('webkit-playsinline', '')

//cloud shorten these 3 functions
function _vidEvents (val) {

  this._readyForEvents = true

//   console.log('\n\n\n\n\nn\n\n\nSET VIDEVENTS')

  var t = this
    , e = (this.player || video.player).events
  val.each(function(i) {
    if (e[i] && e[i].set !== false) (e[i].set || e[i]).call(t, this, i)
  })
  return e
}

function _removeVidEvents (val) {
  var t = this
    , e = (this.player || video.player).events

  val.each(function(i) {
    if (e[i] && e[i].remove) e[i].remove.call(t, this, i)
  })
}

function _playHook (param) {
  var val = this.events
  if (val) {
    var t = this
      , e = (this.player || video.player).events
    val.each(function(i) {
      if (e[i] && e[i].play) e[i].play.call(t, this, i, param)
    })
  }
}

function _progress(val) {

  // console.error('SET progress',this._progress)

  if (!this._progress) {

      // console.error('SET progress for REAL',this._progress)

    //maybe do this with requestAnimationFrame -- danger lies in incosistency with timing
    var params = val
      , interval = params.interval && params.interval.val || 500 
      , fn = params._val
      , t = this
      , pr = (this.player || video.player).progress

    if (pr && pr.set) pr.set.call(t)

    t._progress = setInterval(function() {

      // console.log('before progress call!',t.src.val)
      // if(t.playing&&!t.__paused) {
      //   // t.play()
      //   // no src!
      // }

      var p = Number(t.getTime())
        , b = t.getBuffer(p)
        , d = Number(t.duration.val)

      if(d===1) d=0 //android fix -- maybe remove

      if (p >= 1 && d) {
        t.pause()
        t.playing = false //should this be removed an go to end? 
        //call pause and set time in here?
        t.clearProgress()
      } else {

        if(t._stalled && d) { //just to make sure buffering always dissapaers    
          if(b>0.85 || (t.__lp && t.events.canplay && (p > t.__lp+(1/d)))) { //in seconds
            t._stalled = false
            t.events.canplay._val.call(t)
            t.__lp = null
          } else if( (!t.__lp) && p>-1) {
            t.__lp = p
          } 
        }

        if(!t.ignoreevents) fn.call(t, p, b)
      }
    }, interval)
  }
}

this._progress = _progress

exports.progress = 
{ play: function(i, p, pa) {
    if (pa) {
      _progress.call(this, this.events.progress)
    } else {
      this.clearProgress()
    }
  }
, set: function(val) {
    if (this.playing) _progress.call(this, val)
  }
, remove: function() {
    this.clearProgress()
  }
}

util.define(exports
, 'resumePlay', postpone(function() {
    if(this.node) {
      if(this.$playing.val===true) {
        this.play()
      }
      this.isSeeking = null
      // console.error('RESUME!')
    }
  },1001)
, 'setEvents', function() {
    _vidEvents.call(this, this.events)
  }
, 'play', function(clear, ignore) {

    if (clear) delete this.ignoreevents
    if (!ignore && !this.ignoreevents && this.playing !== true) {
        this.playing = true
        _playHook.call(this, true)
    } else if(this.__paused && this.events.progress) {
      this.playing = true
      _progress.call(this,this.events.progress)
    }
    this.__paused = null
    ;(this.player || video.player).play.call(this, true)
  }
, 'pause', function(ignore) {

    if(ignore) this.ignoreevents = true

    if (!this.ignoreevents && this.playing !== false) {
      this.playing = false
      _playHook.call(this, false)
      if(this.events.pause) {
        this.events.pause._val.call(this)
      }
    } else {
      this.clearProgress()
    }

    this.__paused = true
    ;(this.player || video.player).play.call(this, false)
  }
, 'toggle', function(val) {
    if (this.playing) {
      this.pause()
    } else {
      this.play()
    }
  }
, 'updateTime', function() {
    this._firstT = false
    exports.setTime.call(this, this.time)
  }
, 'getTime', function() {

    // console.error(this.isSeeking)

    return this.isSeeking 
      || (this.rendered && this.player 
      || video.player).time.get.call(this, this.time) 
      || 0
  }
, 'getBuffer', function(val) {
    return (this.rendered && this.player || video.player).buffer.call(this, val || 0)
  }
, 'clearProgress', function() {
    if (this._progress) {
      // console.log('remove that progress')
      clearInterval(this._progress)
      this._progress = null
      var pr = (this.player || video.player).progress
      if (pr && pr.remove) pr.remove.call(this)
    }
  }
)

base.extend(
{ name: 'player'
, type: false
, set: function(val) {
    util.setstore.call(this)
    this.__.player = val
    if (val.element) this.node = val.element
    if (this._class) this._class.prototype._.player = val
  }
, get: function(val) {
    return util.getStore.call(this, 'player') || video.player || {}
  }
}
, 
{ name: 'duration'
, set: function(val) {}
, get: function(val) {
    val._overwrite = (this.player || video.player).duration.call(this, val)
    return val
  }
}
,
{
  name:'$playing'
, set:function( val ) {
    //stamp info
    // if( this.rendered ) //TODO avoid heavy check
    // {
      // console.error('!!!!!!!!!!!set $playing', val.val)
      if( val.val )
      {
        this.play()
      }
      else
      {
        this.pause()
      }
    // }
  }
}
, 
{ name: 'time'
, set: 
  (exports.setTime = function(val) {
    if (!this._ignore) {


      val._overwrite = null
    
      var v = val.val
        , i = false

      if (v !== void 0) {
        if (!this._firstT || this._forceTime === true) { 
          v = Math.abs(v)
          i = true;
          this._firstT = true
          this._forceTime = null
        }

        if (v >= 0) {



          if(this.duration){
            this.isSeeking = v

            // if(playing) this.pause()

            if(this.__lp) this.__lp = null
            ;(this.player || video.player).time.set.call(this, v * this.duration.val)
            if(this.events.seeking && !i)  this.events.seeking._val.call(this,v)

            this.resumePlay()

          }else{
            console.error('can\'t set time, no duration defined!')
          }

          

        }
      }

    }
  })
}
, 
{ autoplay: function(val) {
    (this.player || video.player).autoplay.call(this, val)
  }
, loop: function(val) {
    (this.player || video.player).loop.call(this, val)
  }
, volume: function(val) {
    (this.player || video.player).volume.call(this, val)
  }
, src: function(val) {
    if(val.val!==this.___Src) {
      this.___Src = val.val
      if(this.events.src)  this.events.src._val.call(this,val)
      ;(this.player || video.player).src.call(this, val)
      // console.error('!!!!!!!!!!!set src')

      if(this.$playing.val === true) {
        this.play()
      }

    }
  }
}
, 
{ name: 'events'
, "new": function() {
    //deze functie kunnen instellen
    if(  (this.player && this.player.setEvents !== false)) {
      _vidEvents.call(this, this.events)
    }
  }
, remove: function() {
    if(this.rafId)
    { 
      window.cancelAnimationFrame(this.rafId)
      this.rafId = null
    }
    _removeVidEvents.call(this, this.events)
  }
, set: function(val) {
//   console.log('EVENTS!')
    
    var a = util.arg(arguments)
    
      a[5] = this._readyForEvents 
           ? _vidEvents.call(this, val) 
           : (this.player || video.player).events 

      if(!a[5].seeking) a[5].seeking = {set:false}
      if(!a[5].src) a[5].src = {set:false}
    
    events._set.apply(this, a)
  }
})

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
exports.time = function(time, decimals) {
  var hrs = ~~ (time / 3600),
    mins = ~~ ((time % 3600) / 60),
    secs = decimals ? (time % 60).toFixed(decimals) : ~~(time % 60);
  ret = "";
  if (hrs > 0) ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
  ret += "" + mins + ":" + (secs < 10 ? "0" : "");
  ret += "" + secs;
  return ret || 0;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/advanced.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var events = require('./')
  , operators = require('../../value/operators')
  , doc = events.document

module.exports = events

operators._e = function(val, operator) {
  return val + operator
}

operators._esub = function(val, operator) {
  return val - operator
}

operators._e.order = 3
  
function chooseMove (val, method) {
  return val.move && val.move._val 
    || !method.__t && method !== true && method 
    || method._val;
}

function drag (e, method, val) {
  var t = val.bind ? val.bind._val : this
    , move = chooseMove(val, method)
    , id = 'drag'
  e.preventDefault()
  if (move) doc.addEvent('move', function(e) {
    move.call(t, e, val)
  }, id)

  if (val.down) val.down._val.call(t, e, val)
  
  doc.addEvent('up', function(e) {
    if (val.up) val.up._val.call(t, e, val)
    doc.removeEvent(false, id)
  }, id)
}

function active (e, method, val) {
  var self = this
    , id = 'active'
    , timer = setTimeout(function(){
        self.css = {addClass:val._val}
        timer = null
      },50)

  if(exports._deactivate) exports._deactivate()

  exports._deactivate = function(){
    if(timer) clearTimeout(timer)
    doc.removeEvent(false,id)
    exports._deactivate = null
    window.requestAnimationFrame(function(){
      if(!self) return
      if(!self._stayActive) self.css = {removeClass:val._val}
      else self.css = {addClass:val._val}
    })
  }

  doc.addEvent('move',exports._deactivate,id)
  doc.addEvent('up',exports._deactivate,id)
}

function shallowRaw (vobj) {
  var obj = {}
    , keys = vobj.keys
    , key
    , i = keys.length - 1
  for (; i >= 0; i--) {
    key = keys[i]
    obj[key] = vobj[key]
  }
  return obj
}

function initGrab (t, e, val, name) {
  if (!t[name] || !t[name]._e) t[name] = { _e: 0 }
  if (val[name]._val !== true) t[name].set('_e', shallowRaw(val[name]))
  return e[name] - (t[name]._e.val)
}

function grab (e, method, val, nested) {
  var t = val.bind && !nested ? val.bind.val : this
    , id = ( val.y 
      ? 'y' 
      : val.x 
        ? 'x' 
        : 'xy') 
        + 'Grab' 
        + (nested || '')
  if (t) {
    if (t._node) {
      var move = chooseMove(val, method)
        , startX = e.x
        , startY = e.y
        , ready
        , cX
        , cY
        , oldX
        , oldY
        , newX = startX
        , newY = startY
        , pass
        , upFn = function(e) {
            t.x._p = false
            t.y._p = false
            if (val.up && pass) {
              val.up._val.call(t, e, {
                x: newX - startX,
                y: newY - startY
              },
              { x: newX - oldX
              , y: newY - oldY
              })
            }
            events.click.block = false
            doc.removeEvent(false, id)
          }
      if (!val.x && !val.y){ //this needs revision
        val.x = {_val: true}
        val.y = {_val: true}
      }
      if (val.down) val.down._val.call(t, e, val);
      doc.addEvent('move', function(e) {
        oldX = newX
        oldY = newY
        newX = e.x
        newY = e.y

        events.click.block = true

        if (!ready) {
          pass = val.pass ? val.pass._val.call(t, e, {
            x: newX - startX,
            y: newY - startY
          }) : true
          if(!pass) {
            upFn(e)
            move = false
            doc.removeEvent(false, id)
          } else {
            e.preventDefault()
            if (val.x) {
              cX = initGrab(t, e, val, 'x')
              t.x._p = 1
            }
            if (val.y) {
              cY = initGrab(t, e, val, 'y')
              t.y._p = 1
            }
            if (val.start) val.start._val.call(t, e, val)
            ready = true
          }
        }else{
          e.preventDefault() //for android
          if (cX) t.x = { _e: newX - cX }
          if (cY) t.y = { _e: newY - cY }
          if (move) move.call(t, e, {
              x: newX - startX,
              y: newY - startY
            },val) //check for speed
        }
      }, id)
      doc.addEvent('up', upFn, id)
    } else {
      for (var i = t.length - 1; i >= 0; i--) {
        grab.call(t[i], e, method, val, i + 1)
      }
    }
  }
}
//add the events
events.drag = { val: { down: drag } }
events.grab = { val: { down: grab } }
events.active = { val: { down: active } }
},{"../../value/operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/basic.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = module.exports = require('./')
  , cases = require('../cases')
  , util = require('../../util')
  , ua = require('../ua')

cases.$hasTouch =
( ( 'ontouchstart' in window )
  || window.DocumentTouch
  && document instanceof DocumentTouch
)
|| navigator.msMaxTouchPoints
|| false

function _basic(e, method, val) {
  e.x = e.pageX
  e.y = e.pageY
  method.call(this, e, val)
}

util.define
( events
, '_out'
, { value: [] }
)
//clickout cannot be used to create complex events! it's too custom 
//tried to fix

function keyBoardEvent( name, domEvent, wrapper ) {

  var _name = '_'+name

  util.define( events, _name, { value:[] } )

  var event = 
  {
    create: function( field, from ) {
      var exec = function( e ) {

        //dit gaat heel snel fout hiero
        // console.log('nu ff ook de wrapper callen!', field, from, events[from])
         if( this.rendered ) {

          if( wrapper ) {
            wrapper.call(this, e, this.events[from]._val )
            //this.events[from]._val.call(this, e)
          }
          else if( events[from] && events[from].val) {
            var method = events[from].val
            for(var i in events[from]) {
              if( cases[i]) {
                method = events[from][i]
              }
            }
            method = method[field]
            if( method ) {
              method.call(this, e, this.events[from]._val )
            } 
          } else if( this.events[from] ) {
            this.events[from]._val.call(this, e)
          }

        }
      }
      events.document.addEvent( domEvent, function(e) {

        for ( var arr = events[ _name ], i = arr.length - 1; i >= 0; i-- ) {
          exec.call( arr[i], e )
          
          if( arr[i] ) {
            // console.log( 'do it now!', _name, arr, arr[i], e)
            arr[i].eachInstance( exec, 'events', e )
          }

        }
      }, name )
    },
    add: function( id, field ) {

      field = _name

      this.setSetting(
      { name: field
      , remove: events[ name ].remove
      })

      if ( !util.checkArray( events[ _name ], this ) ) 
      {
        events[ _name ].push(this)
      }

    },
    remove: function() {
      // console.log('WRONGWRONGWRONG!!!!!', _name, events[_name], events)
      //selected moet mischein alleen vanuit Value $focused -- niet op elk item op key up....
      //doe dit smart -- for now zou auto remove kunnen doen als iets er niet meer is?
      var index = util.checkArray( events[ _name ], this, true ) 
      if( ~index ) {

        var noRemove

        // console.log('this:', this )
        // console.log('from base:', this._from.base)
        // console.log('event name:', name)
        // console.log('events:', this.events )
        if(this.events && this._from.base.events) { 
          noRemove = this.events[name] === this._from.base.events[name]
          // console.log('events equals class:', noRemove )
        } else {
          // console.error('no nice events')
        }
        
        if(!noRemove) {
          events[ _name ].splice( index, 1 )
        }
        else {
          console.log(noRemove, 'noRemove evnt, are we sure - fix this asap')
        }
        // debugger
        // this.removeSetting( name ) --- redo this later
      }
    }
  }

  events[ name ] = event

}

events.$makeKeyBoardEvent = keyBoardEvent

keyBoardEvent( 'keyboard', 'keyup' )
keyBoardEvent( 'keyboardDown', 'keydown' )
keyBoardEvent( 'keyboardDown$down', 'keydown' )
keyBoardEvent( 'keyboardDown$click', 'keydown' )

//-----dit ff echt goed fixen!

function basicDown(e, method, val) {
  if( e.which!==1 || events.down.block ) return
   _basic.call(this,e, method, val)
}

events.down =
{ $hasTouch:
  { touchstart: function(e, method, val) {
      if(events.down.block) return
      var targetTouches = e.targetTouches[0] || {}
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
    }
  }
, val: { mousedown: basicDown }
// , tv: 
//   {  // mousedown: basicDown //combineren binnen kort moet voor LG
//      keyboardDown$down: function( e, method, val ) {
//       //this._$focused && 
//       if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) 
//       {
//         method.call(this, e, val)
//       }

//     }
//   }
}

//right-down
events.rdown =
{ $hasTouch:
  { touchstart: function () {
      //2 fingers?
    }
  }
, val:
  { mousedown: function (e, method, val) {
      if(e.which===3) {
        document.oncontextmenu = function() { return false }
        e.preventDefault()
        // e.rdown = true
        _basic.call(this,e,method,val)
        setTimeout(function() { document.oncontextmenu = false }, 0)
      }
    }
  }
}

//move
events.move = {
  $hasTouch:
  { touchmove: function (e, method, val) {
      var targetTouches = e.targetTouches[0]
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
      // document.write(e.targetTouches[0].pageX);
    }
  }
  , val: {
    mousemove: _basic
  }
}

//up
events.up = {
  //keyUp
  $hasTouch: {
    touchend: function(e, method, val) {
      var ct = e.changedTouches
      e.x = ct[0].pageX
      e.y = ct[0].pageY
      method.call(this, e, val)
    }
  }
, val: {
    mouseup: _basic
  }
}

//click
events.click = {
  // tv: {
  //   keyboardDown$click: function(e, method, val ) {

  //     if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) {
  //       method.call(this, e, val)
  //     }

  //   }
  // },
  val: {
    down: function(e, method, val) {

      // console.log('CLICK IT!')

      var t = this
        , name = 'click'
      if(!events.click.block){
        t.addEvent('up', function(e) {
          t.removeEvent('up', name)
          var ms = events._maybescroll
          if(ms){
            if(ms.length) events._maybescroll.unshift([method,t])
            else events._maybescroll = [[method,t]]
          }else if(!events.click.block) method.call(t, e, val)
        }, name);
        setTimeout(function() {
          t.removeEvent('up', name)
        }, 300)
      }
    }
  }
}

events.rclick = {
  val: {
    rdown:events.click.val.down
  }
}

var _outRemove = function() {
    var index = util.checkArray(events._out, this, true)
    if (~index) {
      events._out.splice(index, 1)
      this.removeSetting('_out', _outSetting)

      // debugger

    }
  }
, _outSetting = {
  name: '_out',
  render: function() {
    if (!util.checkArray(events._out, this)) {
      events._out.push(this)
    }
  },
  remove: _outRemove
}

events.out = {
  create: function() {
    this.m = true;
    events.document.addEvent('up', function(e) {

      var base = e.target,
        exec = function() {
          var p = base
            , t
          while (p && !t) {
            if (p.base && this === p.base) {
              t = true;
            } else {
              p = p.parentNode;
            }
          }
          if (!t && this.rendered) this.events.out._val.call(this, e)
        }
      for (var arr = events._out, i = arr.length - 1; i >= 0; i--) {
        exec.call(arr[i])
        if (arr[i]) arr[i].eachInstance(exec, 'events')
      }
    },'out')
  },
  add: function() {
    var t = this
     // events._out.push(this)
    this.setSetting(_outSetting)
  },
  remove:_outRemove
};
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var element = require('../element')
  , cases = require('../cases')
  , util = require('../../util')
  , FieldStore = function () {}

util.define(FieldStore, '_uid', { value: 0 })

exports._r = {} //list of basic (raw) events e.g. 'mousedown'

//remove events if there are no children that use them anymore

exports.document = new element({ node: document })

exports.document.exec = function( event ) {
  if( this.__e[event] )
  {
    var args = util.arg( arguments, 1 )
    for( var i in this.__e[event] )
    {
      this.__e[event][i].apply( this, args )
    }
  }
}

function _create( i, from ) {
  if( exports[i] )
  {
    // console.log('complex', i, from)
    _createComplex( i, from )
  }
  else
  {
    // console.log('_basic', i)

    exports[i] = { _basic: true }
    _createBasic( i )
  }
}

function _createWhile (i, m) {
  return function(e) {
    var parent = e.target
      , base, events
    while (parent) {
      base = parent.base
      if (base) {
        events = base.events
        if (events[i]) {
          if (m) {
            exports[i]._m.call(base, e, events[i])
          } else if (events[i]._val) {
            events[i]._val.call(base, e)
          }
          if (e.prevent) return
        }
        events = base.__e
        if (events && events[i]) {

          for (var j in events[i]) {
            if(j!=='_uid') {
              if (m) {
                exports[i]._m.call(base, e, events[i][j])
              } else {
                // console.log('?what', i, j, base, base._node)
                events[i][j].call(base, e)
              }
              if (e.prevent) return
            }
          }
        }
      }
      parent = parent.parentNode
    }
  }
}

function _createBasic (i, r) {
  var type = i || r

  // console.log('createBasic', type,i)

  exports._r[i] = true
  if(type === 'scroll') {
    document.addEventListener(type, function(e){
      var base = e.target.base
        , events

      if(base) {
        events = base.events
        if(events && events[i]) events[i]._val.call(base, e)
        events = base.__e
        if (events && events[i]) {
          for (var j in events[i]) {
            if(j!=='_uid') events[i][j].call(base, e)
          }
        }
      }
    },true)
  }else document.addEventListener(type, (exports[i].m = _createWhile(i)))
}

function _setComplex ( i, m, r, from ) {
  var met = exports[i]._m = function (e, val) {
    if (e.prevent) return
    m.call(this, e, (val._val || val.val || val), val)
  }
  exports[i].m = _createWhile(i, true)
  exports._r[i] = true
  if (exports[r]) {
    if (!exports[r].m) {
      _create(r, from )
    }
    if (!exports[r]._basic) {
      exports[i].__e = exports[r].__e
      exports[i]._m = function (e, m) {
        exports[r]._m.call(this, e, function(e) {
          met.call(this, e, m)
        })
      }
    } else {
      exports[i].__e = r
    }
  }
  document.addEventListener((exports[r] && exports[r].__e) || r, exports[i].m)
}

var addWrapper = function( add, field, orig ) {
  return function() {
    // console.log( 'ADD WRAP!', field, orig , arguments )
    return add.apply(this, arguments)
  }
}

function _createComplex( field, from ) {

  // console.log('_createComplex' ,field, from )

  if( exports[field].create ) exports[field].create( field, from)
  var m
    , i
    , j
  for ( i in exports[field] ) {
    if (cases[i] === true) m = exports[field][i]
  }
  if ( m || ( m = exports[field].val ) ) {
    for (j in m) //only one
    ;exports[field].__e = j

    if (m[j] === true) 
    {
      exports[field]._basic = true
      _createBasic(field, j)
    } 
    else 
    {
      //basic en non basic ijn niet te combineren -- combineren nog kapot
      // console.log('set complex field', field, m, j,  exports[j]) 
      //!!!tripple check dit!!!
       for( j in m ) 
       { 
        if( exports[j] && exports[j].add 
         && exports[field] && !exports[field].add
        ) 
        {
          exports[field].add = addWrapper( exports[j].add, field, j )
        }
        _setComplex(field, m[j], j, from )
      }
      //!!!danger loop!!!
    }

  }
}

exports._set = function (val, stamp, from, remove, cval, blacklist) {
  var t = this
  val.each(function (i) {
    if (!blacklist || !blacklist[i]) {
      if (this._val === false) {
        if (exports[i]) {
          if (exports[i].remove) exports[i].remove.call(t)
          t.eachInstance(exports[i].remove, val._prop.name)
          this.remove()
        }
      } else {
        
        // console.log('_cre', i, exports[i])

        if (!(exports[i] && exports[i].m)) {
          // console.log('---pass', i)
          _create(i, i)
        }
        //add wrapper?


        // console.log('_set',i, exports[i].add, exports[i])

        if (exports[i].add) exports[i].add.call( t, false, i )
      }
    }
  })
}

element.base.extend(
{ name: 'events'
, set: exports._set
})

util.define(element
, 'addEvent', function(field, fn, id) {
          // console.log('XXXX',field)

    if (!(exports[field] && exports[field].m)) _create(field)
    var events = this.__e || (this.__e = {})
      , f = events[field] || (events[field] = new FieldStore())

    if (!id) {
      f._uid++
      id = f._uid
    }
    f[id] = fn

    // console.log('addEvent!!!', field)

    if (exports[field].add) exports[field].add.call(this, id, field)
    return this
  }
, 'removeEvent', function (field, id, fn) {
    var events = this.__e
      , remove
    if (events) {
      if (field && events[field]) {
        remove = (exports[field] && exports[field].remove)
        if (id) {
          if (events[field][id] && (!fn || events[field][id] === fn)) {
            if (remove) exports[field].remove.call(this, id)
            delete events[field][id]
          }
        } 
        else {
          for (id in events[field]) {
            if (!fn || events[field][id] === fn) {
              if (remove) exports[field].remove.call(this, id)
              delete events[field][id]
            }
          }
        }
        if (util.empty(events[field])) delete events[field]
      } 
      else if (!field) {
        for (field in events) {
          this.removeEvent(field, id, fn)
        }
      }
    }
    if (util.empty(events)) delete this.__e
    return this
  })

require('./basic')

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","./basic":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/basic.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js":[function(require,module,exports){
var matrix = require('../element/properties/util').getMatrix
  , vigour = require('../../')
  , css = require('../css')

exports.left = exports.x = function ( object, arr ) {
  return offset(object,arr,'left','offsetLeft', 4)
}

exports.top = exports.y = function ( object, arr ) {
  return offset(object,arr,'top','offsetTop', 5)
} 

function offset ( object, arr, prop, propL, matrixIndex ) {
  if(!object) return 0
  var start = false
  if(!arr) {
    arr = []
    start = true
  }
  
  if(vigour.Element && object instanceof vigour.Element) object = object.node

  var amount = object[propL]
    , temp = 0
  if(typeof(amount) !== 'number') amount = 0
  if(object.parentNode) exports[prop](object.parentNode, arr)
    if( ( (object.style && object.style.position)
      ||object.__preCss
      ||object.className 
        && (object.__preCss = css(object.className, 'position')||true)) 
      !== 'absolute' ) {
        arr.push(['rel', amount])
    } else {
      var matrixArray = matrix(object)
      arr.push(['abs', matrixArray 
        ? parseInt(matrixArray[matrixIndex],10)+amount //normal amount as well
        : amount ])
    }
  
  if(start) {
    var lastrel
      , abs = 0
      , i
    for(i in arr) {
      if(arr[i][0] == 'abs') {
        abs += arr[i][1]
      } else {
        lastrel = arr[i][1]
      }
    }
    amount = arr[arr.length - 1][0] === 'rel' ? abs+lastrel : abs
  }
  return amount || 0
}

  



},{"../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../css":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js","../element/properties/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js":[function(require,module,exports){
var raf = require('../animation/raf')
  , util = require('../../util')

exports.throttle = function(fn, frames, bind) {
  frames || (frames = 20) //~0.4sec
  var timer
    , arg
    , nobind = !bind
  return function() {
    arg = arguments
    if(nobind) bind = this
    if(!timer) {
      timer = frames
      raf(function repeat() {
        timer--
        if(!timer) {
          fn.apply(bind,arg) 
        } else {
          raf(repeat)
        }
      })
    }
  }
}

//TODO: postpone based on frames
exports.postpone = function(fn, time, bind) {
  time || (time = 200) //no raf!
  var timer
    , arg
    , nobind = !bind
  return function() {
    arg = arguments
    if(nobind) bind = this
    if(timer) clearTimeout(timer)
    timer = setTimeout(function() {
      fn.apply(bind,arg)
    },time)
    return timer
  }
}

//TODO: test for leaks...
exports.interval = function(fn, frames, bind) {
  frames || (frames = 30) //~0.5sec
  var timer
    , clear
    , arg = util.arg(arguments,3)
  if(!timer) {
    timer = frames
    raf(function repeat() {
      timer--
      if(!timer) {
        timer = frames
        fn.apply(bind,arg)
      } 
      if(!clear) raf(repeat)
    })
  }
  return function() {
    clear=true
  }
}

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var _a = 'addEventListener'
  , util = require('../../util')
  , ua = require('../ua')
  , cnt = 0

/**
 * xhr wrapper, adds some nice extras such as multiple requests to a single api call
 * xhr wrapper will include jsonp in a later stage
 * @method extend
 * @param   {String|Array} params.url         Specifiy the url, array fetches multiple url's
 * @param   {String}   [params.api]           Repeat this string for the url that needs to be called
 * @param   {Function} [params.complete]      Specify a callback when an array is passed to url complete is called when all items are complete
 * @param   {Function} [params.error]         On error callback
 * @param   {Function} [params.change]        Function called on xhr.onreadystatechange
 * @param   {Boolean}  [params.async]         If set to false will call an syncronous request (not recommended!)
 * @param   {String}   [params.user]          User parameter
 * @param   {String}   [params.pass]          Password parameter
 * @param   {Boolean}  [params.parse]         If set to false will not try to parse response to JSON
 * @param   {String}   [params.type|.method]  POST or GET, default is get;
 * @param   {String}   [params.contentType]   request content type default id "application/x-www-form-urlencoded"
 * @param   {String}   [params.mime]          defines mime type
 * @param   {Function} [params.progress]      Progress callback
 * @param   {Boolean|String} [params.jsonp]   Use jsonp , if passed as a string determines script+?callback=
 * @param   {Object}   [params.header]        Sets request headers
 * @param   {*}        [params.data]          Pass data to the request, defaults to ? on get;
 */

var iframes
  , ajax = module.exports = function(params, urlset) {
    var _url = params.url;
    if (!urlset && _url instanceof Array) {
      params.m = function() {
        if ((++params.r) === params.n) {
          for (var i = 0, arr = [], l = _url.length; i < l; arr.push(params.d[_url[i++]]));
          params.complete(arr);
        }
      };
      params.r = 0;
      params.d = {};
      for (var i = 0, l = params.n = _url.length; i < l; module.exports(params, _url[i++]));
    } else {
      var data = params.data
        , encode = params.encode
        , url = (params.api || '') + (urlset || _url)
        , headers = params.headers
        , success = params.complete
        , progress = params.progress
        , error = params.error
        , change = params.change
        , mime = params.mime
        , user = params.user
        , pass = params.pass
        , jsonp = params.jsonp
        , parse = params.parse
        , iframe = params.iframe
        , reqdata = null
        , fallback = params.fallback
        , fallbackIndex = params._fallbackIndex
        , method = params.type || params.method || 'GET'
        , contentType = params.contentType || encode === 'json'
          ? 'application/json'
          : 'application/x-www-form-urlencoded'
        , async = (params.async === false) ? false : true
        
      if( jsonp ) 
      {
        ajax.jsonp( url, success, error )  
        //function( url, success, error, context, cbName ) {
      } 
      else 
      {
        // ------------------------------------------------------------ DATA
        var xhr = new XMLHttpRequest()
        if(iframe) {
          cnt++
          var elem
            , msg = {}
            , reqid = cnt

          for(var field in params) {
            if(field!=='error'&&field!=='iframe'&&field!=='complete') {

              msg[field]=params[field]
            }
          }
          var setmsg = function() {
            var elem
            iframes[iframe].onload = null
            var msgcomplete = function(e) {
              // console.error('IFRAME REQ MSG COMPLETE',e.data)
              if(e.data) {
                var d
                try {
                  d = JSON.parse(e.data)
                } catch(e) {
                  if(error) error(e)
                  return
                }
                if(d.id!==reqid) return
                if(d.err) {
                  if(error) {
                    error(d.err)
                  }
                  return
                }
                var resp = d.msg
                if(success) {
                  if (parse !== false) {
                    try {
                      resp = JSON.parse(resp)
                    } catch (e) {}
                  }
                  success(resp,e)
                }
                removeEventListener('message', msgcomplete)
              }
            }
            if(window.addEventListener) {
              addEventListener("message", msgcomplete, false)
              elem = iframes[iframe].contentWindow
              msg = JSON.stringify({
                msg:msg,
                id:reqid
              })
              elem.postMessage(msg, '*')
            }
          }

          if(!iframes) iframes = {}
          if(!iframes[iframe]) {
            elem = iframes[iframe] = document.createElement('iframe')
            elem.src = iframe
            elem.cListeners = [
              setmsg
            ]
            elem.onload = function() {
              for(var h in elem.cListeners) {
                elem.cListeners[h]()
              }
              elem.cListeners = null
            }
            elem.style.visibility='hidden'
            elem.style.width = '0px'
            elem.style.height = '0px'
            elem.style.position = 'absolute'
            document.body.appendChild(elem)
          } else if(iframes[iframe].cListeners) {
            iframes[iframe].cListeners.push(setmsg)
            //elem.cListeners[i]
          } else {
            setmsg()
          }
          return;
        }

        if (data) {

          if (method === 'GET') {
            url += '?' + enCode(data, 'GET', encode)
          } else {
            reqdata = enCode(data, 'POST', encode)
  //           console.log( reqdata )
          }
        }

        // ------------------------------------------------------------ METHOD, URL, ASYNC, USER & PASS
        xhr.open(method, url, async, user, pass)
        // ------------------------------------------------------------ HEADERS
        xhr.setRequestHeader('Content-Type', contentType)
        if (headers) {
          for (var f in headers) {
            xhr.setRequestHeader(f, headers[f]);
          }
        }

        // ------------------------------------------------------------ EVENTS
        if (success) {
          xhr[_a]("load", function(e) {
            var resp = (e.target || e.srcElement).response;
            if (parse !== false) {
              try {
                resp = JSON.parse(resp)
              } catch (e) {}
            }
            if (params.m) {
              params.d[urlset] = resp
              params.m()
            } else {
              success(resp, e)
            }
          }, false)
        }
        if (error) {
          if(!fallbackIndex) params._fallbackIndex = 0
          if(fallback && fallbackIndex!==fallback.length) {
            params._fallbackIndex++
            params = util.merge(params,fallbackIndex)
            ajax(params, urlset)
          } else {
            xhr[_a]("error", error, false)
          }
        }
        if (progress) {
          xhr[_a]("progress", progress, false)
        }
        if (change) {
          xhr.onreadystatechange = change
        }
        // ------------------------------------------------------------ MIME
        if (mime) {
          xhr.overrideMimeType(mime)
        }
        // ------------------------------------------------------------ SEND

        xhr.send(reqdata)
      }
    }
  }

var jsonpStamp = 0

ajax.jsonp = function( url, success, error, context, cbName ) {

  if( !cbName || cbName === true ) cbName = 'callback'

  var name = '_jsonp_' + jsonpStamp++
    , script = document.createElement('script')
  
  if (url.match(/\?/)) 
  { 
    url += '&'+cbName+'='+name
  }
  else 
  {
    url += '?'+cbName+'='+name
  }
  
  script.type = 'text/javascript'
  script.src = url
  
  if(error) {
    script.onerror = function( e ) {
      error( e )
    }
  }

  window[name] = function(data){
    success.call(( context || window ), data)
    document.getElementsByTagName('head')[0].removeChild(script)
    script = null
    delete window[name]
  }
  
  document.getElementsByTagName('head')[0].appendChild(script)

}

var enCode = ajax.encode = function(data, method, encode) {
  var result = ''

  if(encode === 'json'){
    result = JSON.stringify(data)
  } else if(data instanceof Object) {
    if (!util.isNode && (window.FormData && data instanceof FormData) && method !== 'GET') {
      result = data
    } else if (data instanceof Array) {
      result = JSON.stringify(data[f])
      if(encode === 'uri') result = encodeURIComponent(result)
    } else {
      for (var f in data) {
        var val = data[f]
        if(val instanceof Object) val = JSON.stringify(val)
        if(encode === 'uri'){
          f = encodeURIComponent(f)
          val = encodeURIComponent(val)
        }
        result += f + '=' + val + '&'
      }
      result = result.slice(0, -1)

    }
  } else {
    result = (encode === 'uri') ? encodeURIComponent(data) : data
  }
  // console.log('encoded:', result)
  return result
}
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/authenticate.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(extend)

function extend(Cloud) {
  util.define( Cloud
  , 'authenticate', function authenticate(req, cb, re){
      window.authrequest = req
      var cloud = this

      if(typeof req === 'function')
        req = req()

      if(!req)
        return cloud.socket.removeListener('connect', reAuth)

      cloud.emit('authenticate', req, function(res){
        if(res.hop)
          cloud.hop(res.hop)
        else if(cb)
          cb(res)
      })
     
      if(!re){
        cloud.on('connect', reAuth)
      }

      function reAuth(){
        console.error('connect ->>> reAuth?')
        if(cloud._status > 2){
          console.error('reconnect ->>> reAuth!', req)
          cloud.authenticate(req, cb, true)
        }
      }
      cloud._reAuth = reAuth
    }
  , 'logout', function logout(userid){
      var cloud = this

      cloud.emit('logout', userid)

      if(
        cloud.data.users[userid] && 
         cloud.data.users[userid].activeClient 
         && cloud.data.users[userid].activeClient.from._name === cloud.clientid
       ) 
       {
         cloud.data.users[userid].activeClient.remove()
       }

      
      var stamp = cloud.stamp

      if(userid){
        if(cloud.data.users[userid])

        if( 
          cloud.data.users[userid].activeClient 
          && cloud.data.users[userid].activeClient.from._name === cloud.clientid) 
        {
          cloud.data.users[userid].activeClient.from = cloud.data.users[userid].activeClient
        }

        cloud.data.users[userid].remove(void 0, void 0, void 0, void 0, stamp)
        // else
        //   console.error('that user does not exist')
      } else{
        cloud.data.users.each(function(userid){
          this.remove(void 0, void 0, void 0, void 0, stamp)
        })
      }

      cloud.socket.removeListener('connect', cloud._reAuth)
      cloud._reAuth = null

    }
  )
}
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var util = require( '../../../util' )
  , NetworkData = require( '../data' )
    .inject( require( '../../../object/hashpath' ) )
    //TODO: add localstorage --> , !util.isNode && require('../../../object/localstorage')
  , networkDataElement = require( '../data/element' )
  , Data = require( '../../../data' )
  , preventUpdate
  , vObject = require( '../../../object' )
  , monoStamp = require( 'monotonic-timestamp' )
  , CloudData = NetworkData.new
    ( false //put some settings!
    , function CloudData( val, hook, parent, cloud ) {
        var _this = this

        if( cloud )
        {
          _this.cloud = cloud
          _this.addListener(cdListener)

          if(!util.isNode && !!window.cordova) 
          {

            document.addEventListener('pause', function() {
              //TODO: this does not work yet -- make prevent update a usable thing in app logic ( e.g. in device lists or clients )
              _this.preventUpdate = true
            }, false)

            document.addEventListener('resume', function() {
              
              cloud.kickPing()

              if( _this.timeout )
              {
                clearTimeout( _this.timeout )
              }

              _this.timeout = setTimeout( function() {
                if( _this.defered ) 
                {
                  _this.merge( _this.defered.data, false, _this.defered.stamp )
                }
                _this.preventUpdate = null
                _this.defered = null
                _this.timeout = null
              }, 100 )
              // _this.preventUpdate = true //wait for another update and timeout
            }, false)
          }

          cloud.on
          ( 'set'
          , function( data ) {
 
            // console.clear()
            
            // console.group()
            // console.log('\n-----------INCOMING CLOUD-------\n', data )

            // if()

            // console.log(JSON.stringify(data, false, 2).slice(0,200))
            // console.groupCollapsed()
            // console.log(JSON.stringify(data, false, 2))
            // console.groupEnd()
              // console.log('INCOMING!\n', JSON.stringify(data))
              var set = data.s
                , vclock = data.v
                // , stamps = vclock[1]
                , subs = cloud.state.subs.map
                , substamp = vclock[1]

              if( vclock[0] instanceof Array )
              {

                //vclock where is it??????

                for( var i = vclock[0].length; hash = vclock[0][--i]; )
                {
                  updateSub( subs[hash], substamp )
                }

              }
              else
              {
                updateSub( subs[data.v[0]], substamp )
              }

              // substamp = 0

              // for( var s in stamps )
              // {
              //   console.log('burrr', stamps[s])
              //   if( stamps[s] > stamp ) stamp = stamps[s]
              // }

              var stamp = monoStamp()
              cloud.stamp = stamp

              // _this._time

              if( !_this.preventUpdate ) 
              {
                _this.merge( data.s, false, stamp )
              } 
              else
              {
                if(!_this.defered)
                {
                  //pause geen timeout alleen maar uitstellen
                  _this.defered = 
                  { data: data.s
                  , stamp: stamp
                  }
                }
                else 
                {
                  _this.defered.stamp = stamp
                  _this.defered.data = util.merge( _this.defered.data, data.s)
                  // _this.defered.data._update( data.s )

                }
              }

            }
          )

        }
        else if( parent )
        {
          _this.cloud = parent.cloud
        }

      }
    )
  , __update

module.exports = CloudData

function updateSub( cached, vclock ) {
  if( !cached ) return

  return // not implemented

  // var sub = cached.subsobj
  // if( !sub._v ) sub.set( '_v', {} )

  // for( var f in vclock )
  // {
  //   sub._v.set( f, vclock[f] )
  // }

}

function createSub( path, sub, partialSub ) {

  if( path.length )
  {
    util.path( sub, path, partialSub, true )
    return sub
  }
  else
  {
    return partialSub
  }

}

function t4walker( val ) {
//TODO: remove $t:4
  for( var i in val )
  {

    if(val[i] instanceof Object)
    {

      if(val[i] instanceof vObject)
      {
        val[i] = { $path: val[i]._path } // $t: 4 
      }
      else
      {
        t4walker( val[i] )
      }

    }

  }

}

function cdListener( val, stamp, from, remove, added, old ){
  var cloud = this.cloud
  // console.log('OOOO cloudata listenerbur', this._path, val)
  if( stamp === 'localStorage' || stamp===false  )
  {
    // console.log('I WILL NOT UPDATE'.red.inverse)
    // console.log('Cloud from localstorage'.inverse.red)
    return
  }


  if( stamp !== cloud.stamp && val !== void 0 )
  {

    // console.log('>>>>>> shiner')

    // console.log('\n\n\n\n\nupdate cloud', val)



    if( remove && from )
    {
      if( from._removed )
      {
          // console.log('!!!!!!UPDATE CLOUD!!!', from && from._path, val, stamp)

        cloud.set(from._hashpath, [from._path, null, cloud.timeStamp()])
      }

    }
    else if ( from && !this._cloudignore )
    {


      // if( stamp === void 0 ) {
      //   alert('X')
      // }

      // console.log( 'cccccccccccc update!', this._path , from._updateOrigin, from._cachedPath)

      // console.error('_update Origin call from cloud.data') 
      if( from._updateOrigin === from ) //hier gaat iets mis
      {
        if( from.__t === 2 && val instanceof Object ) {
//           console.log(from, val)
          t4walker(val)
        }


        //["users", "U_fe7cc800136b7608", "clients", "V_kuco2zs2qf"]
        var p = from&&from._path
        if(p && p[0] === 'users' && p[p.length-2] && p[p.length-2] === 'clients' ) {
          //TODO: very dirty fix!
          // console.error('break it down!', p, p, val )
          return
        }

        if(p && p[0] === 'users' && p[1] === 'media') {
          throw(new Error('THIS IS WRONG ABORT!---> setting users.media '+p.join('.')))
          // console.error('THIS IS WRONG ABORT!---> setting users.media', p)
          return
        }


        cloud.set
        ( from._hashpath
        , [ from._path
          , from.__t === 4 ? {  $path: val._path } : val //$t: 4,
          , cloud.timeStamp()
          ]
        )

      }

    }

  }

}

CloudData.prototype._blacklist.push('cloud', 'datacloud', '_batchUnsub','_cloudignore', '_lstamp', '$t', '$loaded', '_fromlfrom')

__update = CloudData.prototype.__update

CloudData.inject( require('vigour-js/object/flags') )

CloudData.flags.$path = {
  reset:true,
  set: function(val, stamp, reset) {
    
    if( reset ) {
      throw new Error('cloud data $path flag reset???')
    }
  
    var t = this
    if(stamp !== this.cloud.stamp) {
      throw new Error('set with $path only allowed from the hub')
    }

    var path = util.changeType( val )
    if(path.length){
      // console.log('___________ $path set')
       // val, set, notself, stamp 
       // noupdate
      this._$setVal( this.cloud.data.get( path, {}, void 0, stamp ) ,stamp,false,true)
    }

    if(this.__t!==4) {
      throw new Error('cloud data $path flag __t !== 4')
    }

  }
}


var _set = CloudData.prototype.set

var _$setVal = CloudData.prototype._$setVal

//CloudData add flags

//( name, val, vobj, stamp, noupdate, from )
util.define
( CloudData
, '_$setVal', function( val, stamp ) {
   //setVal

   // console.log('.............', this._path, stamp, stamp && this.cloud.stamp === stamp)
   if(this.cloud.stamp === stamp && !this.$loaded) {
    //TODO: faster to do ! loaded
    var parent = this
    while(parent && !parent.$loaded) {
      parent.$loaded = true
      parent = parent._parent
    }
   }

   _$setVal.apply( this, arguments )
  }
, 'set', function(name, val, vobj, stamp){
  if (stamp !== this.cloud.stamp &&
      this._name === 'clients' &&
      !this[name] && 
      name !== this.cloud.clientid
     ) {
    console.error('\n\nI WANT TO BLOCK THIS YA DURK',
      '\nstamp !== this.cloud.stamp', stamp !== this.cloud.stamp,
      "\nthis._name === 'clients'", this._name === 'clients',
      "\n!this[name]", !this[name],
      "\nname !== this.cloud.clientid", name !== this.cloud.clientid
    )
    debugger
    // return false
  }
  return _set.apply(this, arguments)
}
, 'updateQueue'
, function() {
    // why this???
  }
, 'stamp'
, function(){
    if( !this.cloud ) {
      console.error( 'WAT NO CLOUD?! in this:\n', this )
      return
    }
    return this.cloud.timeStamp()
  }
, '__update'
, function( val, stamp, from, remove, added, oldval ) {

    // if(stamp && this._lstamp === stamp) return


    // console.log(from, '\n', this._lfrom, from, from&&from._lfrom._cachedPath, this._cachedPath, this._lfrom)
    if(from && from._lfrom) {

      this._fromlfrom = from._lfrom
      // console.error(this._fromlfrom)
      // return
    }

    if(this._fromlfrom && this._fromlfrom === (from && from._lfrom) && this._lstamp===stamp) {
      //TODO: this is a memory leak get rid of it circ refs should be resolved from vobj itself
      delete this._fromlfrom
      return
    }

    this._lstamp = stamp

    // if(this._path[0]==='clients') {
    //   console.log('2', this._path, stamp===this.cloud.stamp)
    // }
    // console.log('1 lets __update', this._path, arguments)
    // if( this._ignore  ) {
      // console.log('21 lets __update', this._path, arguments)
      // delete this._ignore
      // return false
    // }
    //most nested update hier addition maken voor process
    // console.log(val, stamp, from)
    //is dit maybe weird???
    return __update.call( this, val, stamp, from, remove, added, oldval )
  }
, '_set'
, function (val, stamp) {
    if( !stamp ) return
    if( this._lstamp > stamp )
    {
      return
    }
    // console.log('lets set it!!!', this._path, arguments)

    return NetworkData.prototype._set.apply( this,arguments )
  }
, 'subscribe'
, function( val, from, parentFixer ) {
              // console.log('start')

    if( from && from.cloud  && from._val === this ) {

        //BUG: dit kan heel veel broken maken!!!!!!!
//         console.log('\n\nHURK!!!!!! DIT IS TEMP MOET NIET EEN EXTRA SUB GEMAAKT WORDEN!' )

        // from = void 0

        //TODO: dit is helemaal wrong GET RID OF IT!!!!
        // return
    }

    // console.log( 'lets do it sub sub'.cyan.inverse, this, val, from, parentFixer )
    // if(from) {
      // console.log('GOT FROM', from , 'SUBSCRIBE')
    // }
     if (!val || typeof val === 'function') { return; }
     // if(val instanceof vObject) {
     //    val = val.from
     // }


     var path = this._path
       , elem = val[1]
       , sub
       , partialSub
       , stringified
       , subsArray
       , exists
       , listeners
       , fromName

      var found = path && util.checkArray( path , 'usage' )
    


    // if( found || found===0) {
            // console.log('lets try to sub', val && val._path, ':', this._path )
      // }
   

    // if(elem) {
    //   console.error(elem, elem._col, elem._dfrom, elem._fmodel)
    // }

    // console.log('SUBSCRIBE', elem._dfrom, elem._fmodel, 'DFROM, FMODEL!')

    // if (elem && !elem._col && (!elem._dfrom || elem._fmodel)) {
    var isElem = (elem && !elem._col && (!elem._dfrom || elem._fmodel))

    if( isElem && !elem.getModel) {
      // console.error('be carefull! cloud data elem does not have getModel')
    } else if( isElem ) {

      // console.error('XXX!')
      //hier dingen vinden voor
      // console.log('!DFROM!')

    //isElem

    //val, from, parentFixer

    // if(val[3] && val[3] instanceof Array) {
    //       console.log( 'YES!!!' )

    // }

          // console.log( '!!!!!!111111', arguments, val[3], from, parentFixer, this, path )

    var fieldignore
    if( val[1]._ignoreFieldInSubscription ) {
      // alert('!'+val[3])
      if(!val[3]) {
        // console.log('FIELDIGNORE'.blue.inverse, val, this, path )
        // debugger

        // if(fi)

        fieldignore = true
      }
    }

    //TODO: has to become val[2]!!!
    //typeof from === 'string' ? from :
      //dit is niet goed!!!!
      fromName = val[3]

    // console.log( '--------22!!!!!!111111', partialSub, val[3], '\n\n?', val[3]._name  )

      //val[3] instanceof Data
      partialSub = elem.getModel( this,  val[3] , fieldignore )
      // console.clear()
    // console.log( '----!!!!!!111111', partialSub )
      // if(partialSub && partialSub.specialFix) {
      //   console.log('LETS DO IT ITI IT', partialSub, partialSub.specialFix, path)
        
      //   // if(partialSub.specialFix instanceof Array ) {

      //   //   console.log( path, partialSub.specialFix, partialSub )
      //   //   if(path[path.length-1] === partialSub.specialFix[0]) {

      //   //     if(partialSub.$ && partialSub.$[partialSub.specialFix[1]]) {
      //   //         console.log('do it!')
      //   //         partialSub = partialSub.$[partialSub.specialFix[1]]
      //   //     }

      //   //   }

      //   // } else 

      //   if(path[path.length-1]===partialSub.specialFix) {
      //     path.pop()
      //   }
        
      //   delete partialSub.specialFix
      // }

      // console.log('LETS DO IT ITI IT'.green.inverse, partialSub)

      // partialSub.DEBUG$log('partial')

    } else if (val instanceof Data && val.__sub) {
    //isData+Subscription
      //dit moet ook gefixed!!!!!!!!!
      partialSub = networkDataElement.parseData(val)

    } else if (val instanceof vObject ) {
    //vObject
      listeners = val._listeners

      // console.log(this._path, 'LISTENER', from )

      if(listeners) {
        for( var listener$=0, len$=listeners.length; listener$<len$; listener$++ ) {
                // console.log('!!!!!!!!!!! listner$333333'.red.inverse, listeners[listener$])
                  // console.log('--------->',this._path, 'LISTENER, ' , listeners[listener$]._path, val)
          this.subscribe( listeners[listener$], val )
        }
      }

      // if(val._parent && !val._parent.cloud) {
        // console.log('parent',val._parent, val._parent._listeners)
      //   listeners = val._parent._listeners

      //   // val._pa
      //   if(listeners) {
      //     for (var listener$=0, len$=listeners.length; listener$<len$; listener$++) {
      //       this.subscribe(listeners[listener$], false, true)
      //     }
      //   }
      // }

      return;
    } else if (val && util.isObj(val) && !(val instanceof Array)) {
      //isNormalSubscription
      // console.log('IS OBJ'.cyan)
      partialSub = val
      val = JSON.stringify(val)
    }

    if (partialSub) {

     //if! empty
     // console.log('2 LETS DO IT ITI IT 2',this , path, 'from:', from, 'sub:', networkDataElement.parseData(from, partialSub, this._subs ) )

     var fromCheck
     if(from) partialSub = networkDataElement.parseData(from, partialSub, this._subs)
      //de check moet nu in from gebeuren
      // console.log('.subscribe cloud.data partialSub are we sure this is from a ref in the cloud'.blue.inverse, partialSub, path) //replace /w from

      if(from && from.cloud && from._val === this) {
        path = from._path //if from is cloud
        // alert('!')
        fromCheck = true
        // console.warn('do nothing prop from cloud', from)
      }

     sub = createSub(path, {}, partialSub)
     stringified = JSON.stringify(sub)

     var substarget =  fromCheck ? from : this

     if(!substarget._subs) substarget._subs = []
     if(elem) elem._subscribed = true
     // console.log('3LETS DO IT ITI IT 3'.red.inverse, networkDataElement.parseData(from, partialSub) )

      subsArray = [ partialSub, elem || val , stringified ]

      if(fromName) {
        subsArray.push(fromName)
      }

      exists = util.checkArray( substarget._subs, stringified, 2)
      //maybe check if val already exists
      // console.log(' TEST TRUE ----- SUBSCRIBE', from, exists, this._subs, stringified, partialSub, sub )
      //TODO: check if not exists subsArray each field
      // console.log('PUSH! SUBS'.green.inverse, subsArray ,stringified, exists )
      var same
      for(var i in substarget._subs ) {

        // console.log(substarget._subs[i], i, substarget._path)
        //compare objects

        if( substarget._subs[i][1] === (elem || val) && substarget._subs[i][2] === stringified ) {
          //distincation!!!!
          // console.log('THE SAME'.cyan.inverse)
          same = true
        }

      }

      if(!same) {
      substarget._subs.push( subsArray )
        //just dont subscribe ---
        if ( exists===false ) {

          // console.log(' TRUE ----- SUBSCRIBE', JSON.stringify(sub,false,2) )
          this.cloud.subscribe(sub, stringified)
        }
        else {
          // console.warn('ALLREADY EXISTS!', sub, stringified)
        }
      }
    }

  }
, 'unsubscribe'
, function( val, from ) {

    //todo: double check if this goes well
    // console.error('1unsubscribe!')

    //doundle remove

    if 
    ( !val
      || val._col
      || (val._filter && val._filter._col)
      || !(!val._dfrom || val._fmodel)
    ) 
    { 
      return 
    }

     var path = this._path
       , stringified
       , subsArray
       , sub
       , exists
       , partialSub
       , index
       , field
       , listeners = val._listeners

    // console.log('unsubscriblex','path:'.blue, path, 'stringified:'.blue,  sub, 'this:'.blue,this, 'val:'.blue, val, 'from:',from )

    if ( util.isObj( val ) && !( val instanceof Array ) ) val = JSON.stringify( val )

    index = this._subs && util.checkArray( this._subs, val, 1 )
    //niet alle 1's weghalen

        // console.log('unsubs??????'.red.inverse, util.clone(this._subs), val, index, this )
        //missing index!


    if ( index!==false && index !== void 0 ) {




      if(val.model && val.model.parsing) {

        // console.log('MODEL unsubs??????'.red.inverse)
        // var removeI

        //block unsubs on model parsing
        if(val.model && val.model.field ) {
          // console.clear()
          // console.log('WARN! unsubs field WARN!'.red.inverse, from, this._subs[index] )

          //reapply if field
          field = this.get(val.model.field.val)
          if(!field._subs) field._subs = []

          // console.log('WARN! unsubs field WARN!'.red.inverse,field===this, field, from, this._subs[index] )


          var __subs = util
            .get( this._subs[index][0], val.model.field.val )

            // console.log( 'subs[0]'.blue,  this._subs[index][0] )

          if( __subs ) {
          this._subs[index][0] = __subs
          // field._subs.push(this._subs[index])
          // console.log('REMOVE SUBS and push'.red.inverse, index,field._subs, __subs, this._subs[index], this._path)
          // debugger
          // this._subs.splice(index, 1)
        } else {
          // console.log('warn'.red)

        }
          // console.log( __subs )


         
          //dit ff beter doen (meerdere _subs)
          //tel counts
          
          //voor deze splice check op index en stringified!

         
        }

        return
      }

      subsArray = this._subs[index]
      stringified = subsArray[2]
      partialSub = subsArray[0]
      // if(from) partialSub = networkDataElement.parseData(from, partialSub)

      // console.log( 'partialSub'.inverse, partialSub )

      sub = createSub(path, {}, partialSub)

      //voor deze splice check op index en stringified!
      //kan dus ook efficienter
      // if( removeI !== void 0 ) {
        // console.log('REMOVE', index)
         // console.log('REMOVE SUBS'.red.inverse, index, this._subs, this._path )
          // debugger
        this._subs.splice(index, 1)

      // }



      exists = util.checkArray(this._subs, stringified, 2)

      if(exists!==false) {
        // console.log('EXISTS????'.cyan.inverse, exists, stringified, this._subs, this._path, this)
      } else {
        // console.log('!EXISTS' , exists, stringified)
      }

      if ( exists === false ) this.cloud.unsubscribe(sub, stringified)
        // this._subsRAF.push([sub, stringified])
        // this._subsRAF = [] search & remove use different identifiers e.g. subs array

    } else if( val._removed ) {

            // console.log('unsubs??22222???? 2222222'.red.inverse)

      // console.error('is this really nessecary? _removed , froce all listeners remove tagets etc')
    } else if(listeners) {

                  // console.log('unsubs??333333333???? 2222222'.red.inverse)

      // console.log('----> this is also pretty different! _listeners')
      for (var listener$=0, len$=listeners.length; listener$<len$; listener$++) {
        if (listeners[listener$] instanceof Array) {
          this.unsubscribe(listeners[listener$][1], val)
        } else if (listeners[listener$].__t) {
          this.unsubscribe(listeners[listener$], val)
        }
      }
      return
    }

  }
)

},{"../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../object/hashpath":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/hashpath.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/index.js","../data/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/element.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js","vigour-js/object/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/datacloud.js":[function(require,module,exports){
module.exports = DataCloud

var timestamp = require('monotonic-timestamp'),
  util = require('../../../util/object'),
  CloudData = require('./data'),
  VObject = require('../../../object'),
  Batch = VObject.new({
    merge: true
  }),
  CloudState = VObject.new({
    merge: true
  }),
  makeHash = require('../../../util/hash'),
  batchtime = 20,
  SUBS = 'subs',
  SETS = 'sets',
  UNSUBS = 'unsubs'

function DataCloud () {
  // window.datacloud = this
  var cloud = this
  cloud._joins = {}
  cloud._status = 1

  cloud.on('connect', function () {
    // console.error('---- cloud connect >> cloud._status++ call _reconnect')
    cloud._status++
    cloud._reconnect()
  })

  // console.log('start making state')
  cloud.state = new CloudState({
        subs: {
          map: {},
          tree: {}
        },
        sets: {
          map: {} /*, list:[]*/
        }
      }
      // , { localstorage: 'VC$' }
    )
    // console.log('done making state', JSON.stringify(cloud.state.raw,false,2))

  if (!cloud.state.sets.list) cloud.state.sets.set('list', [])
    // ^^ set met lege array merged niet

  cloud.batch = {
    maps: {
      sets: {},
      subs: {},
      unsubs: {}
    }
  }

  // console.log('------SET C DATA')

  cloud.data = new CloudData({}, false //{localstorage:'cloudData'}
    , false, this)

  // console.log('------LOG')


  // console.log(JSON.stringify( cloud.data.raw,false,2))
  // ^^ dit kan door weirde shit in localStorage de constructor laten kappen!

  // cloud.on('incoming::pong', this._clearCache)
  // cloud.on('data', this._clearCache)

  cloud._qTimer = setInterval(function _qTimer () {
    cloud._doBatch()
  }, batchtime)


  // cloud.on('welcome', function onWelcome(){

  // })

  cloud.on('subscribed', function (msg) {
    // console.error('>>> Hey Cloud says im subscribed to', msg)
  })

}

DataCloud.prototype.timeSync = function timeSync () {
  // console.log('timeSync!')
  var cloud = this,
    outstamp = Date.now()
  cloud.emit('time', function (cloudstamp) {

    var traveltime = Date.now() - outstamp,
      arrival = outstamp + traveltime / 2,
      offset = cloudstamp - arrival
      // console.log('timestamp in', traveltime, 'offset', offset)
    if (traveltime < cloud._timeTravel) {
      cloud._timeTravel = traveltime
      cloud._timeOffset = offset
    }
    var tries = cloud._timeTries++
      if (traveltime > 75 && tries < 10 || traveltime > 50 && tries < 5 || traveltime > 20 && tries < 2) {
        cloud.timeSync()
      }
  })
}

DataCloud.prototype.outList = function (label) {
  var batch = this.batch
  if (!batch.lists) {
    batch.lists = {}
    return batch.lists[label] = []
  } else if (!batch.lists[label]) {
    return batch.lists[label] = []
  } else {
    return batch.lists[label]
  }
}

DataCloud.prototype._doBatch = function _doBatch () {
  var cloud = this,
    out = cloud.batch.lists

  if (out) {
    // console.log('emit dat batch out!')
    // console.log('EMITTING!',out)
    // if(typeof window !== 'undefined'){
    //   console.log('writing out', JSON.stringify(out).slice(0,50))
    //   console.groupCollapsed()
    //   console.log(JSON.stringify(out,false,2))
    //   console.groupEnd()
    // }
    cloud.emit('batch', out)
      // cloud.write(out)
      // cache sets untill next heartbeat
      // var setslist = out.sets
      // if(setslist) {
      //   var cache = cloud.state.sets
      //     , setsmap = cloud.batch.maps.sets

    //   for(var hash in setsmap) {
    //     var update = setsmap[hash].update
    //     if(update[1] === null)
    //       update[1] = '$$null'
    //     storeSet(hash, update, cache.list, cache.map)
    //   }
    // }
    cloud.batch.lists = null
    cloud.batch.maps = {
      subs: {},
      sets: {},
      unsubs: {}
    }
  }
}

DataCloud.prototype._clearCache = function _clearCache () {
  // if(this.state.sets.list.length){
  //   this.state.sets.remove()
  //   this.state.set('sets', {map:{},list:[]})
  // }
  // could be nicer if we have a good way of clearing arrays
}

DataCloud.prototype.subscribe = function subscribe (subsobj, str) {
  // console.log('subscribe!', str)
  var cloud = this,
    state = cloud.state,
    hash, cached

  if (subsobj.hash && subsobj.subsobj) {
    // console.log('das cached!')
    hash = subsobj.hash
    cached = subsobj
  } else {
    if (!str)
      str = JSON.stringify(subsobj)
    hash = makeHash(str)
    cached = state.subs.map[hash]
  }
  // console.log('hash', hash)


  if (!cached) { // place in tree

    // console.log('set active!')

    state.subs.map.set(hash, {
      hash: hash,
      subsobj: subsobj,
      active: cloud._status,
      cleared: false
    })
    cached = state.subs.map[hash]
    var tree = state.subs.tree
    insertLeaf(tree, cached.subsobj, cached)
  } else if (!cached.active || cached.active._val) {
    // console.warn('subscription already active!', cached, cached.active)
    return
  } else {
    cached.active.val = cloud._status
  }

  var unsubsmap = cloud.batch.maps.unsubs,
    unsubindex = unsubsmap[hash]

  if (unsubindex !== void 0) {
    cloud.cancel(hash, unsubindex, UNSUBS)
    return
  }

  var subslist = cloud.outList(SUBS),
    subsmap = cloud.batch.maps.subs,
    out

  if (!cached.cleared._val) {
    cached.cleared.val = cloud._status
    var depends = cloud.getDeps(state.subs.tree, cached.subsobj, cached, {})
    if (!util.empty(depends)) {
      out = {
        $subsobj: cached.subsobj.raw,
        $depends: depends
      }
    } else {
      out = cached.subsobj.raw
    }
  } else {
    out = cached.subsobj.raw
    cached.cleared.val = cloud._status
  }

  subsmap[hash] = subslist.length
  subslist.push(out)
}

DataCloud.prototype.getDeps = function getDeps (tree, walker, cached, list) {
  walker.each(function (f) {
    var branch = tree[f]
    if (branch) {
      if (branch._subs) {
        branch._subs.each(function (i) {
          var found = this._val
          if (found.subsobj._v && found.hash._val !== cached.hash._val && !found.cleared._val && !list[found.hash._val]) {
            found.cleared.val = cached.cleared._val
            list[found.hash._val] = found.subsobj.raw
          }
        })
      }
      getDeps(branch, walker[f], cached, list)
    }
  })
  return list
}

DataCloud.prototype.unsubscribe = function unsubscribe (subsobj, str) {
  // still do
  var cloud = this
  // console.error('unsubscribe!', subsobj)
  if (subsobj instanceof Array) {
    // console.log('unsub with array', subsobj)
    var tree = cloud.state.subs.tree,
      spot = tree.get(subsobj)

    if (spot) {
      // console.log('OK UNSUBSCRIBE TO THIS CRAP', spot)
      recurUnsub(cloud, spot, str)
    }
  } else {

    var batchmap = cloud.batch.maps.subs,
      hash,
      cached

    if (subsobj.hash) {
      hash = subsobj.hash.val
      cached = subsobj
    } else {
      if (!str) {
        str = JSON.stringify(subsobj)
      }
      hash = makeHash(str)

      var statemap = cloud.state.subs.map

      cached = statemap[hash]
    }

    var index = batchmap[hash]

    if (index !== void 0) {
      cloud.cancel(hash, index, SUBS)

    } else {
      var list = cloud.outList('unsubs')
      cloud.batch.maps.unsubs[hash] = list.length
      list.push(hash)
    }

    cached.active.val = false
  }

}

function recurUnsub (cloud, spot, clear) {
  // console.log('recurUnsub!', spot._path)
  spot.each(function (f) {
    if (this._subs) {
      this._subs.each(function () {
        // console.log('unsub on this!', this.raw, 'clear?', clear)
        if (clear && this.from.subsobj._v) {
          this.from.subsobj._v.remove()
        }
        cloud.unsubscribe(this.from)
      })
    }
    if (f !== '_subs') {
      recurUnsub(cloud, this, clear)
    }
  })
}

DataCloud.prototype.cancel = function cancel (hash, index, label) {
  var batch = this.batch,
    list = batch.lists[label]
  removeIndex(list, index)
  if (!list.length) {
    delete batch.lists[label]
    if (util.empty(batch.lists)) {
      delete batch.lists
    }
  }
  var map = batch.maps[label]
  delete map[hash]
  for (hash in map)
    if (map[hash] > index) {
      map[hash] --
    }
}

DataCloud.prototype.set = function set (hash, update) {

  // console.log('SET CLOUD!')

  if (!update[0].length) {
    // console.error('EMPTY PATH', update)
  }

  var cloud = this,
    list = cloud.outList(SETS),
    map = cloud.batch.maps.sets

  storeSet(hash, update, list, map)
}

function storeSet (hash, update, list, map) {
  // console.log('storeset?!')
  var V = list.__t,
    stored = map[hash]

  if (stored) {
    var val = update[1],
      ts = update[2],
      oldval = stored.update[1]

    if (V) oldval = oldval.raw

    if (val instanceof Object && oldval instanceof Object && !(val.$path) && !(oldval.$path)) {
      if (!V) oldval = util.clone(oldval)
      val = util.merge(oldval, val)
    }

    if (V) {
      stored.update.set(1, val)
      stored.update.set(2, ts)
    } else {
      stored.update[1] = val
      stored.update[2] = ts
    }

    if (!V) {
      var i = stored.i,
        end = list.length - 1
      if (i !== end) {
        moveToEnd(list, i)
        for (var maphash in map) {
          if (map[maphash].i >= i) map[maphash].i--
        }
        stored.i = end
      }
    }
  } else {
    var setobj = {
      update: update,
      i: list.length
    }
    if (V) {
      map.set(hash, setobj)
    } else {
      map[hash] = setobj
    }

    stored = map[hash]
    list.push(stored.update)
  }
}

DataCloud.prototype._reconnect = function _reconnect () {

  // alert('(RE)CONNECT!')
  // console.error('------------- (RE)CONNECT!')

  var cloud = this,
    state = cloud.state,
    subs = state.subs.map

  cloud._timeTries = 0
  cloud._timeTravel = Infinity
  cloud.timeSync()

  // clean data
  cloud.stamp = 'cleanup'
  if (cloud.data.clients) {
    var myclient = cloud.data.clients[cloud.clientid]

    if(myclient) {
      myclient = myclient.raw
      delete myclient.key
      delete myclient.type
      delete myclient.ip
      delete myclient.token
    }

    cloud.data.set('clients', {
      clear: true
    }, void 0, cloud.stamp)

    // TODO: put all cloud.client logic in one place
    if(cloud.clientid && cloud.client) {
      cloud.client.val = cloud.data.clients.get(cloud.clientid, {})
      if(myclient) {
        cloud.client.from.val = myclient
      }
    }
  }

  if (cloud.data.users) {
    cloud.data.users.each(function () {
      // console.log('CLEAN CLOUD: clean usrt!!', this._name)

      this.set('clients', {
        clear: true
      }, void 0, cloud.stamp)

      // CLEAN MAINSCREEN AND ACTIVE CLIENT?!

      // this.mainscreen.set('clientRef', false, void 0, cloud.stamp)
      // this.mainscreen.clientRef.remove(void 0, void 0, void 0, void 0, cloud.stamp)

      // this.activeClient.remove(void 0, void 0, void 0, void 0, cloud.stamp)

    })
  }

  // if(sets.length){
  //   sets.sort(byTs)
  //   for(var i = 0, set ; set = sets[i++];){
  //     if(set[1] === '$$null')
  //       set[1] = null
  //   }
  //   cloud.write({sets:sets})
  //   // would be nicer to insert them into current batch
  // }

  var resubs = []
  subs.each(function (f) {
    // console.log('resub?', f)
    var cached = this,
      active = cached.active,
      cleared = cached.cleared

    if (active._val === 1) {
      active.val = true
      cleared.val = true
    } else if (active._val) {
      // active._val = false

      active.val = false
      // dit wordt niet in ls opgelsagen

      if (cleared._val === 1) {
        cleared.val = true
      } else if (cleared._val) {
        cleared.val = false
      }
      resubs.push(cached)
    } else if (cleared._val) {
      if (cleared._val === 1) {
        cleared.val = true
      } else {
        cleared.val = false
      }
    }

  })
  for (var i = 0, resub; resub = resubs[i]; i++) {
    // console.error('resubscribe!!', resub.subsobj.raw)
    cloud.subscribe(resub)
  }
  // console.error('done resubscribin')

  for (var j in cloud._joins) {
    cloud.join(cloud._joins[j], true)
  }

}

DataCloud.prototype.timeStamp = function () {
  var ts = timestamp()
  if (this._timeOffset) {
    ts += this._timeOffset
  }
  return ts
}

function insertLeaf (tree, subsobj, cached) {
  subsobj.each(function (f) {
    if (f === '*') {
      if (!tree.$) {
        tree.set('$', {})
      }
      subsobj['*'].each(function (s) {
        subsobj['*'][s][1].each(function (ss) {
          insertLeaf(tree.$, subsobj['*'][s][1][ss], cached)
        })
      })
      return
    }
    if (!tree[f]) {
      tree.set(f, {})
    }
    if (subsobj[f].val === true) {
      if (!tree[f]._subs) {
        tree[f].set('_subs', [cached])
      } else {
        tree[f]._subs.push(cached)
      }
    } else {
      insertLeaf(tree[f], subsobj[f], cached)
    }
  })
}

function moveToEnd (arr, i) {
  var tmp = arr[i]
  while (arr[i + 1]) {
    arr[i] = arr[++i]
  }
  arr[i] = tmp
}

function removeIndex (arr, i) {
  while (arr[i + 1]) {
    arr[i] = arr[++i]
  }
  arr.pop()
}

// function byTs (a, b) {
//   return a[2] - b[2]
// }

},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../../util/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js","./data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js":[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var util = require('../../../util'),
  io = util.isNode 
    ? require('socket.io-client') 
    : require('./socket.io.min.js'),
  G = require('../../../util/global'),
  id = require('../../../util/id'),
  urlEncode = require('../ajax').encode,
  VObject = require('../../../object'),
  Value = require('../../../value'),
  Emitter = require('./emitter')

var Cloud = module.exports = function Cloud (url, params) {
  
  if (!params) {
    params = {}
  }

  var cloud = this
  cloud.params = params
  cloud.url = url
  cloud.VID = params.VID = fixVID(params.VID)
    // var HID = params.HID || G.env('HID')
    // if(HID)
    //   cloud.HID = params.HID = HID
  cloud.connected = new Value(false)

  // cloud.connected.addListener(function(){
  //   console.log('connected: state change >', this.val)
  // })

  cloud.api = new Value({
    defer: function (update, args) {
      var type = this.from.__t
      if (type !== 2) {
        throw new Error('cloud.api needs to be an Object')
      }
      update()
    }
  })

  // cloud.api.on(function(){
  //  console.error('lolk cloud.api is set!! on', this.val)
  // })

  if (params.api) {
    cloud.api.val = params.api
  }

  cloud.addDocumentListeners()

  if (url instanceof VObject) {
    var current = url.val
      // console.log('current', current)

    if (current) {
      cloud.init(url, params)
    } else {
      var placeholder = new Emitter()
      placeholder.emit = function () {
        var buffer = cloud.emitbuffer || (cloud.emitbuffer = [])
        buffer.push(arguments)
      }
      placeholder.placeholder = true
      cloud.socket = placeholder
      url.addListener(function (val, p1, p2, p3) {
        // console.log('URL VAL CHANGE', this.val)
        if (this.val) {
          cloud.init(url, params)
        }
      })
    }
  } else {
    // console.log('normal burk just init', url)
    cloud.init(url, params)
  }

}

Cloud.inject = require('../../../util/inject')

Cloud.prototype.addDocumentListeners = function () {
  var cloud = this
  if (!util.isNode && window.cordova) {
    document.addEventListener('resume', function () {
      // console.log('connected: RESUME')
      cloud.connected.val = false
    }, false)
    document.addEventListener('pause', function () {
      // console.log('connected: PAUSE')
      cloud.connected.val = false
    }, false)
  }
}

Cloud.prototype.init = function (url, params) {
  // console.log('CLOUD INIT!')
  var cloud = this,
    socket = cloud.connect(url, params,
      { disconnect: function () {
          log('disconnect')
          cloud.connected.val = false
        },
        connect: function () {
          log('connect')
          cloud.connected.val = true
          socket.io.engine.on('heartbeat', function () {
            cloud.connected.val = true
          })          
        },
        welcome: function (address) {
          log('welcome')
          address = address.split('@')

          var clientid = cloud.clientid = address[0],
            hubid = address[1],
            state = cloud.state

          cloud.hub = params.h = hubid

          cloud.socket.io.uri = fixUrl(cloud.socket.io.uri, params)
        },
        hop: function (newhub) {
          log('hop')
          cloud.hop(newhub)
        },
        err: function (err) {
          log.error(err)
          if (err.type === 'tokenCheck') {
            if (typeof localStorage !== 'undefined') {
              localStorage.removeItem('productionuserToken')
              localStorage.removeItem('userId')
            }
          }
        },
        reconnecting: logger('reconnecting'),
        reconnect_attempt: logger('reconnect_attempt'),
        reconnect: logger('reconnect'),
        reconnect_failed: logger('reconnect_failed')
      }
    )

  var emitbuffer = cloud.emitbuffer
  if (emitbuffer) {
    for (var e in emitbuffer) {
      socket.emit.apply(socket, emitbuffer[e])
    }
    cloud.emitbuffer = null
  }

}

Cloud.prototype.connect = function (url, params, listeners) {

  var cloud = this

  if (!url)
    url = cloud.url
  if (!params)
    params = cloud.params

  if (url instanceof VObject) {
    url = url.val
  }

  url = fixUrl(url, params)

  var oldsocket = cloud.socket

  if (oldsocket && !oldsocket.placeholder) {
    oldsocket.disconnect()
    oldsocket.io.disconnect()
  }

  // console.log('---------- cloud.connect!', url, params)

  var socket = cloud.socket = new io(url, {
    forceNew: true,
    timeout: 5e3
  })

  if (listeners) {
    for (var l in listeners) {
      socket.on(l, listeners[l])
    }
  }

  if (oldsocket) {
    // console.error('------------- transferring old listeners', socket._callbacks)
    passOn(oldsocket, socket)
  }

  // ------- these extentions are only for logging
  // window.cloudmessages = []
  // var _onevent = cloud.socket.onevent
  // cloud.socket.onevent = function (packet) {
  //   window.cloudmessages.push(JSON.stringify(packet.data, false, 2))
  //   console.log('incoming cloud message!', JSON.stringify(packet.data, false, 2))
  //   _onevent.apply(this, arguments)
  // }
  // var _emit = cloud.socket.emit
  // cloud.socket.emit = function (event, data) {
  //   if (typeof data !== 'function') {
  //     console.log('\ncloud.socket.emit:', event, data)
  //     if (event === 'batch') {
  //       if (data.subs) {
  //         for (var s in data.subs) {
  //           if (data.subs[s].mtvData) {
  //             // console.log('\nsubscribin to mtvData!', data.subs[s].mtvData)
  //           }
  //         }
  //       }
  //       if (data.sets) {
  //         for (var s in data.sets) {
  //           // console.error('set:', JSON.stringify(data.sets[s]))
  //         }
  //       }
  //     }
  //   }
  //   _emit.apply(this, arguments)
  // }
  // ------- these extentions are only for logging
  
  return socket

}

Cloud.prototype.hop = function hop (newhub) {

  // console.log('GOT ORDER TO HOP TO', newhub)

  var cloud = this,
    params = cloud.params
    // --------------- dev
  if (newhub.indexOf('@') !== -1)
    cloud.url = 'ws://' + newhub.split('@')[1]
    // --------------- /dev
  cloud.hub = params.h = newhub
  cloud.connect()
}

Cloud.prototype.whenReady = function whenReady (fn) {
  if (this.clientid)
    fn()
  else
    this.once('welcome', fn)
}

Cloud.prototype.kickPing = function kickPing (time) {
  var e = this.socket.io.engine
  e.ping()
  e.onHeartbeat(time || e.pingTimeout)
  e.setPing()
}

Cloud.prototype.disconnect = function disconnect () {
  var socket = this.socket
  if (socket) {
    socket.disconnect()
    socket.io.disconnect()
  }
}

delegateList(Cloud.prototype, 'socket', ['on', 'once', 'emit'])

function delegateList (obj, target, list) {
  for (var i = list.length - 1; i >= 0; i--) {
    delegate(obj, target, list[i])
  }
}

function delegate (obj, target, field) {
  obj[field] = function delegated () {
    var thing = this[target]
    thing[field].apply(thing, arguments)
  }
}

function logit (flag) {
  return function logger () {
    if(window.gaston){
      console.log(':: vigour-cloud ::', flag, arguments)
    }
  }
}

var vflag = ':: vigour-cloud ::'
function log () {
  if(window.gaston){
    var args = util.arg(arguments)
    args.unshift(vflag)
    console.log.apply(console, args)
  }
}
log.error = function (flag, err){
  console.error(vflag, flag, '\n', err)
}
function logger (flag){
  return function logger () {
    var args = util.arg(arguments)
    args.unshift(vflag, flag)
    console.log.apply(console, args)
  }
}

function fixVID (VID) {
  VID = VID || G.session('VID') || id('V_')
  return G.session('VID', VID)
}

function passOn (from, to) {
  for (var e in from._callbacks) {
    var fromlist = from._callbacks[e]
    for (var i = 0, fn; fn = fromlist[i]; i++) {
      // console.log('hand over dat listner', fn.name === 'on' && fn.fn ? 'once' : 'on',e, fn.fn || fn)
      if (fn.name === 'on' && fn.fn) {
        to.once(e, fn.fn)
      } else {
        to.on(e, fn)
      }
    }
  }
  from.off()
}

function fixUrl (url, params) {
  var cutoff = url.indexOf('?')
  if (cutoff > -1) {
    url = url.slice(0, cutoff)
  }
  return url + '?' + urlEncode(params, 'GET', 'uri')
}
},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/global":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/global.js","../../../util/id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js","../../../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js","./emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js","./socket.io.min.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/socket.io.min.js","socket.io-client":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/socket.io.min.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){module.exports=_dereq_("./lib/")},{"./lib/":2}],2:[function(_dereq_,module,exports){var url=_dereq_("./url");var parser=_dereq_("socket.io-parser");var Manager=_dereq_("./manager");var debug=_dereq_("debug")("socket.io-client");module.exports=exports=lookup;var cache=exports.managers={};function lookup(uri,opts){if(typeof uri=="object"){opts=uri;uri=undefined}opts=opts||{};var parsed=url(uri);var source=parsed.source;var id=parsed.id;var io;if(opts.forceNew||opts["force new connection"]||false===opts.multiplex){debug("ignoring socket cache for %s",source);io=Manager(source,opts)}else{if(!cache[id]){debug("new io instance for %s",source);cache[id]=Manager(source,opts)}io=cache[id]}return io.socket(parsed.path)}exports.protocol=parser.protocol;exports.connect=lookup;exports.Manager=_dereq_("./manager");exports.Socket=_dereq_("./socket")},{"./manager":3,"./socket":5,"./url":6,debug:10,"socket.io-parser":46}],3:[function(_dereq_,module,exports){var url=_dereq_("./url");var eio=_dereq_("engine.io-client");var Socket=_dereq_("./socket");var Emitter=_dereq_("component-emitter");var parser=_dereq_("socket.io-parser");var on=_dereq_("./on");var bind=_dereq_("component-bind");var object=_dereq_("object-component");var debug=_dereq_("debug")("socket.io-client:manager");var indexOf=_dereq_("indexof");var Backoff=_dereq_("backo2");module.exports=Manager;function Manager(uri,opts){if(!(this instanceof Manager))return new Manager(uri,opts);if(uri&&"object"==typeof uri){opts=uri;uri=undefined}opts=opts||{};opts.path=opts.path||"/socket.io";this.nsps={};this.subs=[];this.opts=opts;this.reconnection(opts.reconnection!==false);this.reconnectionAttempts(opts.reconnectionAttempts||Infinity);this.reconnectionDelay(opts.reconnectionDelay||1e3);this.reconnectionDelayMax(opts.reconnectionDelayMax||5e3);this.randomizationFactor(opts.randomizationFactor||.5);this.backoff=new Backoff({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()});this.timeout(null==opts.timeout?2e4:opts.timeout);this.readyState="closed";this.uri=uri;this.connected=[];this.encoding=false;this.packetBuffer=[];this.encoder=new parser.Encoder;this.decoder=new parser.Decoder;this.autoConnect=opts.autoConnect!==false;if(this.autoConnect)this.open()}Manager.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var nsp in this.nsps){this.nsps[nsp].emit.apply(this.nsps[nsp],arguments)}};Manager.prototype.updateSocketIds=function(){for(var nsp in this.nsps){this.nsps[nsp].id=this.engine.id}};Emitter(Manager.prototype);Manager.prototype.reconnection=function(v){if(!arguments.length)return this._reconnection;this._reconnection=!!v;return this};Manager.prototype.reconnectionAttempts=function(v){if(!arguments.length)return this._reconnectionAttempts;this._reconnectionAttempts=v;return this};Manager.prototype.reconnectionDelay=function(v){if(!arguments.length)return this._reconnectionDelay;this._reconnectionDelay=v;this.backoff&&this.backoff.setMin(v);return this};Manager.prototype.randomizationFactor=function(v){if(!arguments.length)return this._randomizationFactor;this._randomizationFactor=v;this.backoff&&this.backoff.setJitter(v);return this};Manager.prototype.reconnectionDelayMax=function(v){if(!arguments.length)return this._reconnectionDelayMax;this._reconnectionDelayMax=v;this.backoff&&this.backoff.setMax(v);return this};Manager.prototype.timeout=function(v){if(!arguments.length)return this._timeout;this._timeout=v;return this};Manager.prototype.maybeReconnectOnOpen=function(){if(!this.reconnecting&&this._reconnection&&this.backoff.attempts===0){this.reconnect()}};Manager.prototype.open=Manager.prototype.connect=function(fn){debug("readyState %s",this.readyState);if(~this.readyState.indexOf("open"))return this;debug("opening %s",this.uri);this.engine=eio(this.uri,this.opts);var socket=this.engine;var self=this;this.readyState="opening";this.skipReconnect=false;var openSub=on(socket,"open",function(){self.onopen();fn&&fn()});var errorSub=on(socket,"error",function(data){debug("connect_error");self.cleanup();self.readyState="closed";self.emitAll("connect_error",data);if(fn){var err=new Error("Connection error");err.data=data;fn(err)}else{self.maybeReconnectOnOpen()}});if(false!==this._timeout){var timeout=this._timeout;debug("connect attempt will timeout after %d",timeout);var timer=setTimeout(function(){debug("connect attempt timed out after %d",timeout);openSub.destroy();socket.close();socket.emit("error","timeout");self.emitAll("connect_timeout",timeout)},timeout);this.subs.push({destroy:function(){clearTimeout(timer)}})}this.subs.push(openSub);this.subs.push(errorSub);return this};Manager.prototype.onopen=function(){debug("open");this.cleanup();this.readyState="open";this.emit("open");var socket=this.engine;this.subs.push(on(socket,"data",bind(this,"ondata")));this.subs.push(on(this.decoder,"decoded",bind(this,"ondecoded")));this.subs.push(on(socket,"error",bind(this,"onerror")));this.subs.push(on(socket,"close",bind(this,"onclose")))};Manager.prototype.ondata=function(data){this.decoder.add(data)};Manager.prototype.ondecoded=function(packet){this.emit("packet",packet)};Manager.prototype.onerror=function(err){debug("error",err);this.emitAll("error",err)};Manager.prototype.socket=function(nsp){var socket=this.nsps[nsp];if(!socket){socket=new Socket(this,nsp);this.nsps[nsp]=socket;var self=this;socket.on("connect",function(){socket.id=self.engine.id;if(!~indexOf(self.connected,socket)){self.connected.push(socket)}})}return socket};Manager.prototype.destroy=function(socket){var index=indexOf(this.connected,socket);if(~index)this.connected.splice(index,1);if(this.connected.length)return;this.close()};Manager.prototype.packet=function(packet){debug("writing packet %j",packet);var self=this;if(!self.encoding){self.encoding=true;this.encoder.encode(packet,function(encodedPackets){for(var i=0;i<encodedPackets.length;i++){self.engine.write(encodedPackets[i])}self.encoding=false;self.processPacketQueue()})}else{self.packetBuffer.push(packet)}};Manager.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var pack=this.packetBuffer.shift();this.packet(pack)}};Manager.prototype.cleanup=function(){var sub;while(sub=this.subs.shift())sub.destroy();this.packetBuffer=[];this.encoding=false;this.decoder.destroy()};Manager.prototype.close=Manager.prototype.disconnect=function(){this.skipReconnect=true;this.backoff.reset();this.readyState="closed";this.engine&&this.engine.close()};Manager.prototype.onclose=function(reason){debug("close");this.cleanup();this.backoff.reset();this.readyState="closed";this.emit("close",reason);if(this._reconnection&&!this.skipReconnect){this.reconnect()}};Manager.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var self=this;if(this.backoff.attempts>=this._reconnectionAttempts){debug("reconnect failed");this.backoff.reset();this.emitAll("reconnect_failed");this.reconnecting=false}else{var delay=this.backoff.duration();debug("will wait %dms before reconnect attempt",delay);this.reconnecting=true;var timer=setTimeout(function(){if(self.skipReconnect)return;debug("attempting reconnect");self.emitAll("reconnect_attempt",self.backoff.attempts);self.emitAll("reconnecting",self.backoff.attempts);if(self.skipReconnect)return;self.open(function(err){if(err){debug("reconnect attempt error");self.reconnecting=false;self.reconnect();self.emitAll("reconnect_error",err.data)}else{debug("reconnect success");self.onreconnect()}})},delay);this.subs.push({destroy:function(){clearTimeout(timer)}})}};Manager.prototype.onreconnect=function(){var attempt=this.backoff.attempts;this.reconnecting=false;this.backoff.reset();this.updateSocketIds();this.emitAll("reconnect",attempt)}},{"./on":4,"./socket":5,"./url":6,backo2:7,"component-bind":8,"component-emitter":9,debug:10,"engine.io-client":11,indexof:42,"object-component":43,"socket.io-parser":46}],4:[function(_dereq_,module,exports){module.exports=on;function on(obj,ev,fn){obj.on(ev,fn);return{destroy:function(){obj.removeListener(ev,fn)}}}},{}],5:[function(_dereq_,module,exports){var parser=_dereq_("socket.io-parser");var Emitter=_dereq_("component-emitter");var toArray=_dereq_("to-array");var on=_dereq_("./on");var bind=_dereq_("component-bind");var debug=_dereq_("debug")("socket.io-client:socket");var hasBin=_dereq_("has-binary");module.exports=exports=Socket;var events={connect:1,connect_error:1,connect_timeout:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1};var emit=Emitter.prototype.emit;function Socket(io,nsp){this.io=io;this.nsp=nsp;this.json=this;this.ids=0;this.acks={};if(this.io.autoConnect)this.open();this.receiveBuffer=[];this.sendBuffer=[];this.connected=false;this.disconnected=true}Emitter(Socket.prototype);Socket.prototype.subEvents=function(){if(this.subs)return;var io=this.io;this.subs=[on(io,"open",bind(this,"onopen")),on(io,"packet",bind(this,"onpacket")),on(io,"close",bind(this,"onclose"))]};Socket.prototype.open=Socket.prototype.connect=function(){if(this.connected)return this;this.subEvents();this.io.open();if("open"==this.io.readyState)this.onopen();return this};Socket.prototype.send=function(){var args=toArray(arguments);args.unshift("message");this.emit.apply(this,args);return this};Socket.prototype.emit=function(ev){if(events.hasOwnProperty(ev)){emit.apply(this,arguments);return this}var args=toArray(arguments);var parserType=parser.EVENT;if(hasBin(args)){parserType=parser.BINARY_EVENT}var packet={type:parserType,data:args};if("function"==typeof args[args.length-1]){debug("emitting packet with ack id %d",this.ids);this.acks[this.ids]=args.pop();packet.id=this.ids++}if(this.connected){this.packet(packet)}else{this.sendBuffer.push(packet)}return this};Socket.prototype.packet=function(packet){packet.nsp=this.nsp;this.io.packet(packet)};Socket.prototype.onopen=function(){debug("transport is open - connecting");if("/"!=this.nsp){this.packet({type:parser.CONNECT})}};Socket.prototype.onclose=function(reason){debug("close (%s)",reason);this.connected=false;this.disconnected=true;delete this.id;this.emit("disconnect",reason)};Socket.prototype.onpacket=function(packet){if(packet.nsp!=this.nsp)return;switch(packet.type){case parser.CONNECT:this.onconnect();break;case parser.EVENT:this.onevent(packet);break;case parser.BINARY_EVENT:this.onevent(packet);break;case parser.ACK:this.onack(packet);break;case parser.BINARY_ACK:this.onack(packet);break;case parser.DISCONNECT:this.ondisconnect();break;case parser.ERROR:this.emit("error",packet.data);break}};Socket.prototype.onevent=function(packet){var args=packet.data||[];debug("emitting event %j",args);if(null!=packet.id){debug("attaching ack callback to event");args.push(this.ack(packet.id))}if(this.connected){emit.apply(this,args)}else{this.receiveBuffer.push(args)}};Socket.prototype.ack=function(id){var self=this;var sent=false;return function(){if(sent)return;sent=true;var args=toArray(arguments);debug("sending ack %j",args);var type=hasBin(args)?parser.BINARY_ACK:parser.ACK;self.packet({type:type,id:id,data:args})}};Socket.prototype.onack=function(packet){debug("calling ack %s with %j",packet.id,packet.data);var fn=this.acks[packet.id];fn.apply(this,packet.data);delete this.acks[packet.id]};Socket.prototype.onconnect=function(){this.connected=true;this.disconnected=false;this.emit("connect");this.emitBuffered()};Socket.prototype.emitBuffered=function(){var i;for(i=0;i<this.receiveBuffer.length;i++){emit.apply(this,this.receiveBuffer[i])}this.receiveBuffer=[];for(i=0;i<this.sendBuffer.length;i++){this.packet(this.sendBuffer[i])}this.sendBuffer=[]};Socket.prototype.ondisconnect=function(){debug("server disconnect (%s)",this.nsp);this.destroy();this.onclose("io server disconnect")};Socket.prototype.destroy=function(){if(this.subs){for(var i=0;i<this.subs.length;i++){this.subs[i].destroy()}this.subs=null}this.io.destroy(this)};Socket.prototype.close=Socket.prototype.disconnect=function(){if(this.connected){debug("performing disconnect (%s)",this.nsp);this.packet({type:parser.DISCONNECT})}this.destroy();if(this.connected){this.onclose("io client disconnect")}return this}},{"./on":4,"component-bind":8,"component-emitter":9,debug:10,"has-binary":38,"socket.io-parser":46,"to-array":50}],6:[function(_dereq_,module,exports){(function(global){var parseuri=_dereq_("parseuri");var debug=_dereq_("debug")("socket.io-client:url");module.exports=url;function url(uri,loc){var obj=uri;var loc=loc||global.location;if(null==uri)uri=loc.protocol+"//"+loc.host;if("string"==typeof uri){if("/"==uri.charAt(0)){if("/"==uri.charAt(1)){uri=loc.protocol+uri}else{uri=loc.hostname+uri}}if(!/^(https?|wss?):\/\//.test(uri)){debug("protocol-less url %s",uri);if("undefined"!=typeof loc){uri=loc.protocol+"//"+uri}else{uri="https://"+uri}}debug("parse %s",uri);obj=parseuri(uri)}if(!obj.port){if(/^(http|ws)$/.test(obj.protocol)){obj.port="80"}else if(/^(http|ws)s$/.test(obj.protocol)){obj.port="443"}}obj.path=obj.path||"/";obj.id=obj.protocol+"://"+obj.host+":"+obj.port;obj.href=obj.protocol+"://"+obj.host+(loc&&loc.port==obj.port?"":":"+obj.port);return obj}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{debug:10,parseuri:44}],7:[function(_dereq_,module,exports){module.exports=Backoff;function Backoff(opts){opts=opts||{};this.ms=opts.min||100;this.max=opts.max||1e4;this.factor=opts.factor||2;this.jitter=opts.jitter>0&&opts.jitter<=1?opts.jitter:0;this.attempts=0}Backoff.prototype.duration=function(){var ms=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var rand=Math.random();var deviation=Math.floor(rand*this.jitter*ms);ms=(Math.floor(rand*10)&1)==0?ms-deviation:ms+deviation}return Math.min(ms,this.max)|0};Backoff.prototype.reset=function(){this.attempts=0};Backoff.prototype.setMin=function(min){this.ms=min};Backoff.prototype.setMax=function(max){this.max=max};Backoff.prototype.setJitter=function(jitter){this.jitter=jitter}},{}],8:[function(_dereq_,module,exports){var slice=[].slice;module.exports=function(obj,fn){if("string"==typeof fn)fn=obj[fn];if("function"!=typeof fn)throw new Error("bind() requires a function");var args=slice.call(arguments,2);return function(){return fn.apply(obj,args.concat(slice.call(arguments)))}}},{}],9:[function(_dereq_,module,exports){module.exports=Emitter;function Emitter(obj){if(obj)return mixin(obj)}function mixin(obj){for(var key in Emitter.prototype){obj[key]=Emitter.prototype[key]}return obj}Emitter.prototype.on=Emitter.prototype.addEventListener=function(event,fn){this._callbacks=this._callbacks||{};(this._callbacks[event]=this._callbacks[event]||[]).push(fn);return this};Emitter.prototype.once=function(event,fn){var self=this;this._callbacks=this._callbacks||{};function on(){self.off(event,on);fn.apply(this,arguments)}on.fn=fn;this.on(event,on);return this};Emitter.prototype.off=Emitter.prototype.removeListener=Emitter.prototype.removeAllListeners=Emitter.prototype.removeEventListener=function(event,fn){this._callbacks=this._callbacks||{};if(0==arguments.length){this._callbacks={};return this}var callbacks=this._callbacks[event];if(!callbacks)return this;if(1==arguments.length){delete this._callbacks[event];return this}var cb;for(var i=0;i<callbacks.length;i++){cb=callbacks[i];if(cb===fn||cb.fn===fn){callbacks.splice(i,1);break}}return this};Emitter.prototype.emit=function(event){this._callbacks=this._callbacks||{};var args=[].slice.call(arguments,1),callbacks=this._callbacks[event];if(callbacks){callbacks=callbacks.slice(0);for(var i=0,len=callbacks.length;i<len;++i){callbacks[i].apply(this,args)}}return this};Emitter.prototype.listeners=function(event){this._callbacks=this._callbacks||{};return this._callbacks[event]||[]};Emitter.prototype.hasListeners=function(event){return!!this.listeners(event).length}},{}],10:[function(_dereq_,module,exports){module.exports=debug;function debug(name){if(!debug.enabled(name))return function(){};return function(fmt){fmt=coerce(fmt);var curr=new Date;var ms=curr-(debug[name]||curr);debug[name]=curr;fmt=name+" "+fmt+" +"+debug.humanize(ms);window.console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}}debug.names=[];debug.skips=[];debug.enable=function(name){try{localStorage.debug=name}catch(e){}var split=(name||"").split(/[\s,]+/),len=split.length;for(var i=0;i<len;i++){name=split[i].replace("*",".*?");if(name[0]==="-"){debug.skips.push(new RegExp("^"+name.substr(1)+"$"))}else{debug.names.push(new RegExp("^"+name+"$"))}}};debug.disable=function(){debug.enable("")};debug.humanize=function(ms){var sec=1e3,min=60*1e3,hour=60*min;if(ms>=hour)return(ms/hour).toFixed(1)+"h";if(ms>=min)return(ms/min).toFixed(1)+"m";if(ms>=sec)return(ms/sec|0)+"s";return ms+"ms"};debug.enabled=function(name){for(var i=0,len=debug.skips.length;i<len;i++){if(debug.skips[i].test(name)){return false}}for(var i=0,len=debug.names.length;i<len;i++){if(debug.names[i].test(name)){return true}}return false};function coerce(val){if(val instanceof Error)return val.stack||val.message;return val}try{if(window.localStorage)debug.enable(localStorage.debug)}catch(e){}},{}],11:[function(_dereq_,module,exports){module.exports=_dereq_("./lib/")},{"./lib/":12}],12:[function(_dereq_,module,exports){module.exports=_dereq_("./socket");module.exports.parser=_dereq_("engine.io-parser")},{"./socket":13,"engine.io-parser":25}],13:[function(_dereq_,module,exports){(function(global){var transports=_dereq_("./transports");var Emitter=_dereq_("component-emitter");var debug=_dereq_("debug")("engine.io-client:socket");var index=_dereq_("indexof");var parser=_dereq_("engine.io-parser");var parseuri=_dereq_("parseuri");var parsejson=_dereq_("parsejson");var parseqs=_dereq_("parseqs");module.exports=Socket;function noop(){}function Socket(uri,opts){if(!(this instanceof Socket))return new Socket(uri,opts);opts=opts||{};if(uri&&"object"==typeof uri){opts=uri;uri=null}if(uri){uri=parseuri(uri);opts.host=uri.host;opts.secure=uri.protocol=="https"||uri.protocol=="wss";opts.port=uri.port;if(uri.query)opts.query=uri.query}this.secure=null!=opts.secure?opts.secure:global.location&&"https:"==location.protocol;if(opts.host){var pieces=opts.host.split(":");opts.hostname=pieces.shift();if(pieces.length){opts.port=pieces.pop()}else if(!opts.port){opts.port=this.secure?"443":"80"}}this.agent=opts.agent||false;this.hostname=opts.hostname||(global.location?location.hostname:"localhost");this.port=opts.port||(global.location&&location.port?location.port:this.secure?443:80);this.query=opts.query||{};if("string"==typeof this.query)this.query=parseqs.decode(this.query);this.upgrade=false!==opts.upgrade;this.path=(opts.path||"/engine.io").replace(/\/$/,"")+"/";this.forceJSONP=!!opts.forceJSONP;this.jsonp=false!==opts.jsonp;this.forceBase64=!!opts.forceBase64;this.enablesXDR=!!opts.enablesXDR;this.timestampParam=opts.timestampParam||"t";this.timestampRequests=opts.timestampRequests;this.transports=opts.transports||["polling","websocket"];this.readyState="";this.writeBuffer=[];this.callbackBuffer=[];this.policyPort=opts.policyPort||843;this.rememberUpgrade=opts.rememberUpgrade||false;this.binaryType=null;this.onlyBinaryUpgrades=opts.onlyBinaryUpgrades;this.pfx=opts.pfx||null;this.key=opts.key||null;this.passphrase=opts.passphrase||null;this.cert=opts.cert||null;this.ca=opts.ca||null;this.ciphers=opts.ciphers||null;this.rejectUnauthorized=opts.rejectUnauthorized||null;this.open()}Socket.priorWebsocketSuccess=false;Emitter(Socket.prototype);Socket.protocol=parser.protocol;Socket.Socket=Socket;Socket.Transport=_dereq_("./transport");Socket.transports=_dereq_("./transports");Socket.parser=_dereq_("engine.io-parser");Socket.prototype.createTransport=function(name){debug('creating transport "%s"',name);var query=clone(this.query);query.EIO=parser.protocol;query.transport=name;if(this.id)query.sid=this.id;var transport=new transports[name]({agent:this.agent,hostname:this.hostname,port:this.port,secure:this.secure,path:this.path,query:query,forceJSONP:this.forceJSONP,jsonp:this.jsonp,forceBase64:this.forceBase64,enablesXDR:this.enablesXDR,timestampRequests:this.timestampRequests,timestampParam:this.timestampParam,policyPort:this.policyPort,socket:this,pfx:this.pfx,key:this.key,passphrase:this.passphrase,cert:this.cert,ca:this.ca,ciphers:this.ciphers,rejectUnauthorized:this.rejectUnauthorized});return transport};function clone(obj){var o={};for(var i in obj){if(obj.hasOwnProperty(i)){o[i]=obj[i]}}return o}Socket.prototype.open=function(){var transport;if(this.rememberUpgrade&&Socket.priorWebsocketSuccess&&this.transports.indexOf("websocket")!=-1){transport="websocket"}else if(0==this.transports.length){var self=this;setTimeout(function(){self.emit("error","No transports available")},0);return}else{transport=this.transports[0]}this.readyState="opening";var transport;try{transport=this.createTransport(transport)}catch(e){this.transports.shift();this.open();return}transport.open();this.setTransport(transport)};Socket.prototype.setTransport=function(transport){debug("setting transport %s",transport.name);var self=this;if(this.transport){debug("clearing existing transport %s",this.transport.name);this.transport.removeAllListeners()}this.transport=transport;transport.on("drain",function(){self.onDrain()}).on("packet",function(packet){self.onPacket(packet)}).on("error",function(e){self.onError(e)}).on("close",function(){self.onClose("transport close")})};Socket.prototype.probe=function(name){debug('probing transport "%s"',name);var transport=this.createTransport(name,{probe:1}),failed=false,self=this;Socket.priorWebsocketSuccess=false;function onTransportOpen(){if(self.onlyBinaryUpgrades){var upgradeLosesBinary=!this.supportsBinary&&self.transport.supportsBinary;failed=failed||upgradeLosesBinary}if(failed)return;debug('probe transport "%s" opened',name);transport.send([{type:"ping",data:"probe"}]);transport.once("packet",function(msg){if(failed)return;if("pong"==msg.type&&"probe"==msg.data){debug('probe transport "%s" pong',name);self.upgrading=true;self.emit("upgrading",transport);if(!transport)return;Socket.priorWebsocketSuccess="websocket"==transport.name;debug('pausing current transport "%s"',self.transport.name);self.transport.pause(function(){if(failed)return;if("closed"==self.readyState)return;debug("changing transport and sending upgrade packet");cleanup();self.setTransport(transport);transport.send([{type:"upgrade"}]);self.emit("upgrade",transport);transport=null;self.upgrading=false;self.flush()})}else{debug('probe transport "%s" failed',name);var err=new Error("probe error");err.transport=transport.name;self.emit("upgradeError",err)}})}function freezeTransport(){if(failed)return;failed=true;cleanup();transport.close();transport=null}function onerror(err){var error=new Error("probe error: "+err);error.transport=transport.name;freezeTransport();debug('probe transport "%s" failed because of error: %s',name,err);self.emit("upgradeError",error)}function onTransportClose(){onerror("transport closed")}function onclose(){onerror("socket closed")}function onupgrade(to){if(transport&&to.name!=transport.name){debug('"%s" works - aborting "%s"',to.name,transport.name);freezeTransport()}}function cleanup(){transport.removeListener("open",onTransportOpen);transport.removeListener("error",onerror);transport.removeListener("close",onTransportClose);self.removeListener("close",onclose);self.removeListener("upgrading",onupgrade)}transport.once("open",onTransportOpen);transport.once("error",onerror);transport.once("close",onTransportClose);this.once("close",onclose);this.once("upgrading",onupgrade);transport.open()};Socket.prototype.onOpen=function(){debug("socket open");this.readyState="open";Socket.priorWebsocketSuccess="websocket"==this.transport.name;this.emit("open");this.flush();if("open"==this.readyState&&this.upgrade&&this.transport.pause){debug("starting upgrade probes");for(var i=0,l=this.upgrades.length;i<l;i++){this.probe(this.upgrades[i])}}};Socket.prototype.onPacket=function(packet){if("opening"==this.readyState||"open"==this.readyState){debug('socket receive: type "%s", data "%s"',packet.type,packet.data);this.emit("packet",packet);this.emit("heartbeat");switch(packet.type){case"open":this.onHandshake(parsejson(packet.data));break;case"pong":this.setPing();break;case"error":var err=new Error("server error");err.code=packet.data;this.emit("error",err);break;case"message":this.emit("data",packet.data);this.emit("message",packet.data);break}}else{debug('packet received with socket readyState "%s"',this.readyState)}};Socket.prototype.onHandshake=function(data){this.emit("handshake",data);this.id=data.sid;this.transport.query.sid=data.sid;this.upgrades=this.filterUpgrades(data.upgrades);this.pingInterval=data.pingInterval;this.pingTimeout=data.pingTimeout;this.onOpen();if("closed"==this.readyState)return;this.setPing();this.removeListener("heartbeat",this.onHeartbeat);this.on("heartbeat",this.onHeartbeat)};Socket.prototype.onHeartbeat=function(timeout){clearTimeout(this.pingTimeoutTimer);var self=this;self.pingTimeoutTimer=setTimeout(function(){if("closed"==self.readyState)return;self.onClose("ping timeout")},timeout||self.pingInterval+self.pingTimeout)};Socket.prototype.setPing=function(){var self=this;clearTimeout(self.pingIntervalTimer);self.pingIntervalTimer=setTimeout(function(){debug("writing ping packet - expecting pong within %sms",self.pingTimeout);self.ping();self.onHeartbeat(self.pingTimeout)},self.pingInterval)};Socket.prototype.ping=function(){this.sendPacket("ping")};Socket.prototype.onDrain=function(){for(var i=0;i<this.prevBufferLen;i++){if(this.callbackBuffer[i]){this.callbackBuffer[i]()}}this.writeBuffer.splice(0,this.prevBufferLen);this.callbackBuffer.splice(0,this.prevBufferLen);this.prevBufferLen=0;if(this.writeBuffer.length==0){this.emit("drain")}else{this.flush()}};Socket.prototype.flush=function(){if("closed"!=this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){debug("flushing %d packets in socket",this.writeBuffer.length);this.transport.send(this.writeBuffer);this.prevBufferLen=this.writeBuffer.length;this.emit("flush")}};Socket.prototype.write=Socket.prototype.send=function(msg,fn){this.sendPacket("message",msg,fn);return this};Socket.prototype.sendPacket=function(type,data,fn){if("closing"==this.readyState||"closed"==this.readyState){return}var packet={type:type,data:data};this.emit("packetCreate",packet);this.writeBuffer.push(packet);this.callbackBuffer.push(fn);this.flush()};Socket.prototype.close=function(){if("opening"==this.readyState||"open"==this.readyState){this.readyState="closing";var self=this;function close(){self.onClose("forced close");debug("socket closing - telling transport to close");self.transport.close()}function cleanupAndClose(){self.removeListener("upgrade",cleanupAndClose);self.removeListener("upgradeError",cleanupAndClose);close()}function waitForUpgrade(){self.once("upgrade",cleanupAndClose);self.once("upgradeError",cleanupAndClose)}if(this.writeBuffer.length){this.once("drain",function(){if(this.upgrading){waitForUpgrade()}else{close()}})}else if(this.upgrading){waitForUpgrade()}else{close()}}return this};Socket.prototype.onError=function(err){debug("socket error %j",err);Socket.priorWebsocketSuccess=false;this.emit("error",err);this.onClose("transport error",err)};Socket.prototype.onClose=function(reason,desc){if("opening"==this.readyState||"open"==this.readyState||"closing"==this.readyState){debug('socket close with reason: "%s"',reason);var self=this;clearTimeout(this.pingIntervalTimer);clearTimeout(this.pingTimeoutTimer);setTimeout(function(){self.writeBuffer=[];self.callbackBuffer=[];self.prevBufferLen=0},0);this.transport.removeAllListeners("close");this.transport.close();this.transport.removeAllListeners();this.readyState="closed";this.id=null;this.emit("close",reason,desc)}};Socket.prototype.filterUpgrades=function(upgrades){var filteredUpgrades=[];for(var i=0,j=upgrades.length;i<j;i++){if(~index(this.transports,upgrades[i]))filteredUpgrades.push(upgrades[i])}return filteredUpgrades}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./transport":14,"./transports":15,"component-emitter":9,debug:22,"engine.io-parser":25,indexof:42,parsejson:34,parseqs:35,parseuri:36}],14:[function(_dereq_,module,exports){var parser=_dereq_("engine.io-parser");var Emitter=_dereq_("component-emitter");module.exports=Transport;function Transport(opts){this.path=opts.path;this.hostname=opts.hostname;this.port=opts.port;this.secure=opts.secure;this.query=opts.query;this.timestampParam=opts.timestampParam;this.timestampRequests=opts.timestampRequests;this.readyState="";this.agent=opts.agent||false;this.socket=opts.socket;this.enablesXDR=opts.enablesXDR;this.pfx=opts.pfx;this.key=opts.key;this.passphrase=opts.passphrase;this.cert=opts.cert;this.ca=opts.ca;this.ciphers=opts.ciphers;this.rejectUnauthorized=opts.rejectUnauthorized}Emitter(Transport.prototype);Transport.timestamps=0;Transport.prototype.onError=function(msg,desc){var err=new Error(msg);err.type="TransportError";err.description=desc;this.emit("error",err);return this};Transport.prototype.open=function(){if("closed"==this.readyState||""==this.readyState){this.readyState="opening";this.doOpen()}return this};Transport.prototype.close=function(){if("opening"==this.readyState||"open"==this.readyState){this.doClose();this.onClose()}return this};Transport.prototype.send=function(packets){if("open"==this.readyState){this.write(packets)}else{throw new Error("Transport not open")}};Transport.prototype.onOpen=function(){this.readyState="open";this.writable=true;this.emit("open")};Transport.prototype.onData=function(data){var packet=parser.decodePacket(data,this.socket.binaryType);this.onPacket(packet)};Transport.prototype.onPacket=function(packet){this.emit("packet",packet)};Transport.prototype.onClose=function(){this.readyState="closed";this.emit("close")}},{"component-emitter":9,"engine.io-parser":25}],15:[function(_dereq_,module,exports){(function(global){var XMLHttpRequest=_dereq_("xmlhttprequest");var XHR=_dereq_("./polling-xhr");var JSONP=_dereq_("./polling-jsonp");var websocket=_dereq_("./websocket");exports.polling=polling;exports.websocket=websocket;function polling(opts){var xhr;var xd=false;var xs=false;var jsonp=false!==opts.jsonp;if(global.location){var isSSL="https:"==location.protocol;var port=location.port;if(!port){port=isSSL?443:80}xd=opts.hostname!=location.hostname||port!=opts.port;xs=opts.secure!=isSSL}opts.xdomain=xd;opts.xscheme=xs;xhr=new XMLHttpRequest(opts);if("open"in xhr&&!opts.forceJSONP){return new XHR(opts)}else{if(!jsonp)throw new Error("JSONP disabled");return new JSONP(opts)}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,xmlhttprequest:20}],16:[function(_dereq_,module,exports){(function(global){var Polling=_dereq_("./polling");var inherit=_dereq_("component-inherit");module.exports=JSONPPolling;var rNewline=/\n/g;var rEscapedNewline=/\\n/g;var callbacks;var index=0;function empty(){}function JSONPPolling(opts){Polling.call(this,opts);
this.query=this.query||{};if(!callbacks){if(!global.___eio)global.___eio=[];callbacks=global.___eio}this.index=callbacks.length;var self=this;callbacks.push(function(msg){self.onData(msg)});this.query.j=this.index;if(global.document&&global.addEventListener){global.addEventListener("beforeunload",function(){if(self.script)self.script.onerror=empty},false)}}inherit(JSONPPolling,Polling);JSONPPolling.prototype.supportsBinary=false;JSONPPolling.prototype.doClose=function(){if(this.script){this.script.parentNode.removeChild(this.script);this.script=null}if(this.form){this.form.parentNode.removeChild(this.form);this.form=null;this.iframe=null}Polling.prototype.doClose.call(this)};JSONPPolling.prototype.doPoll=function(){var self=this;var script=document.createElement("script");if(this.script){this.script.parentNode.removeChild(this.script);this.script=null}script.async=true;script.src=this.uri();script.onerror=function(e){self.onError("jsonp poll error",e)};var insertAt=document.getElementsByTagName("script")[0];insertAt.parentNode.insertBefore(script,insertAt);this.script=script;var isUAgecko="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);if(isUAgecko){setTimeout(function(){var iframe=document.createElement("iframe");document.body.appendChild(iframe);document.body.removeChild(iframe)},100)}};JSONPPolling.prototype.doWrite=function(data,fn){var self=this;if(!this.form){var form=document.createElement("form");var area=document.createElement("textarea");var id=this.iframeId="eio_iframe_"+this.index;var iframe;form.className="socketio";form.style.position="absolute";form.style.top="-1000px";form.style.left="-1000px";form.target=id;form.method="POST";form.setAttribute("accept-charset","utf-8");area.name="d";form.appendChild(area);document.body.appendChild(form);this.form=form;this.area=area}this.form.action=this.uri();function complete(){initIframe();fn()}function initIframe(){if(self.iframe){try{self.form.removeChild(self.iframe)}catch(e){self.onError("jsonp polling iframe removal error",e)}}try{var html='<iframe src="javascript:0" name="'+self.iframeId+'">';iframe=document.createElement(html)}catch(e){iframe=document.createElement("iframe");iframe.name=self.iframeId;iframe.src="javascript:0"}iframe.id=self.iframeId;self.form.appendChild(iframe);self.iframe=iframe}initIframe();data=data.replace(rEscapedNewline,"\\\n");this.area.value=data.replace(rNewline,"\\n");try{this.form.submit()}catch(e){}if(this.iframe.attachEvent){this.iframe.onreadystatechange=function(){if(self.iframe.readyState=="complete"){complete()}}}else{this.iframe.onload=complete}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling":18,"component-inherit":21}],17:[function(_dereq_,module,exports){(function(global){var XMLHttpRequest=_dereq_("xmlhttprequest");var Polling=_dereq_("./polling");var Emitter=_dereq_("component-emitter");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:polling-xhr");module.exports=XHR;module.exports.Request=Request;function empty(){}function XHR(opts){Polling.call(this,opts);if(global.location){var isSSL="https:"==location.protocol;var port=location.port;if(!port){port=isSSL?443:80}this.xd=opts.hostname!=global.location.hostname||port!=opts.port;this.xs=opts.secure!=isSSL}}inherit(XHR,Polling);XHR.prototype.supportsBinary=true;XHR.prototype.request=function(opts){opts=opts||{};opts.uri=this.uri();opts.xd=this.xd;opts.xs=this.xs;opts.agent=this.agent||false;opts.supportsBinary=this.supportsBinary;opts.enablesXDR=this.enablesXDR;opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;return new Request(opts)};XHR.prototype.doWrite=function(data,fn){var isBinary=typeof data!=="string"&&data!==undefined;var req=this.request({method:"POST",data:data,isBinary:isBinary});var self=this;req.on("success",fn);req.on("error",function(err){self.onError("xhr post error",err)});this.sendXhr=req};XHR.prototype.doPoll=function(){debug("xhr poll");var req=this.request();var self=this;req.on("data",function(data){self.onData(data)});req.on("error",function(err){self.onError("xhr poll error",err)});this.pollXhr=req};function Request(opts){this.method=opts.method||"GET";this.uri=opts.uri;this.xd=!!opts.xd;this.xs=!!opts.xs;this.async=false!==opts.async;this.data=undefined!=opts.data?opts.data:null;this.agent=opts.agent;this.isBinary=opts.isBinary;this.supportsBinary=opts.supportsBinary;this.enablesXDR=opts.enablesXDR;this.pfx=opts.pfx;this.key=opts.key;this.passphrase=opts.passphrase;this.cert=opts.cert;this.ca=opts.ca;this.ciphers=opts.ciphers;this.rejectUnauthorized=opts.rejectUnauthorized;this.create()}Emitter(Request.prototype);Request.prototype.create=function(){var opts={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;var xhr=this.xhr=new XMLHttpRequest(opts);var self=this;try{debug("xhr open %s: %s",this.method,this.uri);xhr.open(this.method,this.uri,this.async);if(this.supportsBinary){xhr.responseType="arraybuffer"}if("POST"==this.method){try{if(this.isBinary){xhr.setRequestHeader("Content-type","application/octet-stream")}else{xhr.setRequestHeader("Content-type","text/plain;charset=UTF-8")}}catch(e){}}if("withCredentials"in xhr){xhr.withCredentials=true}if(this.hasXDR()){xhr.onload=function(){self.onLoad()};xhr.onerror=function(){self.onError(xhr.responseText)}}else{xhr.onreadystatechange=function(){if(4!=xhr.readyState)return;if(200==xhr.status||1223==xhr.status){self.onLoad()}else{setTimeout(function(){self.onError(xhr.status)},0)}}}debug("xhr data %s",this.data);xhr.send(this.data)}catch(e){setTimeout(function(){self.onError(e)},0);return}if(global.document){this.index=Request.requestsCount++;Request.requests[this.index]=this}};Request.prototype.onSuccess=function(){this.emit("success");this.cleanup()};Request.prototype.onData=function(data){this.emit("data",data);this.onSuccess()};Request.prototype.onError=function(err){this.emit("error",err);this.cleanup(true)};Request.prototype.cleanup=function(fromError){if("undefined"==typeof this.xhr||null===this.xhr){return}if(this.hasXDR()){this.xhr.onload=this.xhr.onerror=empty}else{this.xhr.onreadystatechange=empty}if(fromError){try{this.xhr.abort()}catch(e){}}if(global.document){delete Request.requests[this.index]}this.xhr=null};Request.prototype.onLoad=function(){var data;try{var contentType;try{contentType=this.xhr.getResponseHeader("Content-Type").split(";")[0]}catch(e){}if(contentType==="application/octet-stream"){data=this.xhr.response}else{if(!this.supportsBinary){data=this.xhr.responseText}else{data="ok"}}}catch(e){this.onError(e)}if(null!=data){this.onData(data)}};Request.prototype.hasXDR=function(){return"undefined"!==typeof global.XDomainRequest&&!this.xs&&this.enablesXDR};Request.prototype.abort=function(){this.cleanup()};if(global.document){Request.requestsCount=0;Request.requests={};if(global.attachEvent){global.attachEvent("onunload",unloadHandler)}else if(global.addEventListener){global.addEventListener("beforeunload",unloadHandler,false)}}function unloadHandler(){for(var i in Request.requests){if(Request.requests.hasOwnProperty(i)){Request.requests[i].abort()}}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling":18,"component-emitter":9,"component-inherit":21,debug:22,xmlhttprequest:20}],18:[function(_dereq_,module,exports){var Transport=_dereq_("../transport");var parseqs=_dereq_("parseqs");var parser=_dereq_("engine.io-parser");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:polling");module.exports=Polling;var hasXHR2=function(){var XMLHttpRequest=_dereq_("xmlhttprequest");var xhr=new XMLHttpRequest({xdomain:false});return null!=xhr.responseType}();function Polling(opts){var forceBase64=opts&&opts.forceBase64;if(!hasXHR2||forceBase64){this.supportsBinary=false}Transport.call(this,opts)}inherit(Polling,Transport);Polling.prototype.name="polling";Polling.prototype.doOpen=function(){this.poll()};Polling.prototype.pause=function(onPause){var pending=0;var self=this;this.readyState="pausing";function pause(){debug("paused");self.readyState="paused";onPause()}if(this.polling||!this.writable){var total=0;if(this.polling){debug("we are currently polling - waiting to pause");total++;this.once("pollComplete",function(){debug("pre-pause polling complete");--total||pause()})}if(!this.writable){debug("we are currently writing - waiting to pause");total++;this.once("drain",function(){debug("pre-pause writing complete");--total||pause()})}}else{pause()}};Polling.prototype.poll=function(){debug("polling");this.polling=true;this.doPoll();this.emit("poll")};Polling.prototype.onData=function(data){var self=this;debug("polling got data %s",data);var callback=function(packet,index,total){if("opening"==self.readyState){self.onOpen()}if("close"==packet.type){self.onClose();return false}self.onPacket(packet)};parser.decodePayload(data,this.socket.binaryType,callback);if("closed"!=this.readyState){this.polling=false;this.emit("pollComplete");if("open"==this.readyState){this.poll()}else{debug('ignoring poll - transport state "%s"',this.readyState)}}};Polling.prototype.doClose=function(){var self=this;function close(){debug("writing close packet");self.write([{type:"close"}])}if("open"==this.readyState){debug("transport open - closing");close()}else{debug("transport not open - deferring close");this.once("open",close)}};Polling.prototype.write=function(packets){var self=this;this.writable=false;var callbackfn=function(){self.writable=true;self.emit("drain")};var self=this;parser.encodePayload(packets,this.supportsBinary,function(data){self.doWrite(data,callbackfn)})};Polling.prototype.uri=function(){var query=this.query||{};var schema=this.secure?"https":"http";var port="";if(false!==this.timestampRequests){query[this.timestampParam]=+new Date+"-"+Transport.timestamps++}if(!this.supportsBinary&&!query.sid){query.b64=1}query=parseqs.encode(query);if(this.port&&("https"==schema&&this.port!=443||"http"==schema&&this.port!=80)){port=":"+this.port}if(query.length){query="?"+query}return schema+"://"+this.hostname+port+this.path+query}},{"../transport":14,"component-inherit":21,debug:22,"engine.io-parser":25,parseqs:35,xmlhttprequest:20}],19:[function(_dereq_,module,exports){var Transport=_dereq_("../transport");var parser=_dereq_("engine.io-parser");var parseqs=_dereq_("parseqs");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:websocket");var WebSocket=_dereq_("ws");module.exports=WS;function WS(opts){var forceBase64=opts&&opts.forceBase64;if(forceBase64){this.supportsBinary=false}Transport.call(this,opts)}inherit(WS,Transport);WS.prototype.name="websocket";WS.prototype.supportsBinary=true;WS.prototype.doOpen=function(){if(!this.check()){return}var self=this;var uri=this.uri();var protocols=void 0;var opts={agent:this.agent};opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;this.ws=new WebSocket(uri,protocols,opts);if(this.ws.binaryType===undefined){this.supportsBinary=false}this.ws.binaryType="arraybuffer";this.addEventListeners()};WS.prototype.addEventListeners=function(){var self=this;this.ws.onopen=function(){self.onOpen()};this.ws.onclose=function(){self.onClose()};this.ws.onmessage=function(ev){self.onData(ev.data)};this.ws.onerror=function(e){self.onError("websocket error",e)}};if("undefined"!=typeof navigator&&/iPad|iPhone|iPod/i.test(navigator.userAgent)){WS.prototype.onData=function(data){var self=this;setTimeout(function(){Transport.prototype.onData.call(self,data)},0)}}WS.prototype.write=function(packets){var self=this;this.writable=false;for(var i=0,l=packets.length;i<l;i++){parser.encodePacket(packets[i],this.supportsBinary,function(data){try{self.ws.send(data)}catch(e){debug("websocket closed before onclose event")}})}function ondrain(){self.writable=true;self.emit("drain")}setTimeout(ondrain,0)};WS.prototype.onClose=function(){Transport.prototype.onClose.call(this)};WS.prototype.doClose=function(){if(typeof this.ws!=="undefined"){this.ws.close()}};WS.prototype.uri=function(){var query=this.query||{};var schema=this.secure?"wss":"ws";var port="";if(this.port&&("wss"==schema&&this.port!=443||"ws"==schema&&this.port!=80)){port=":"+this.port}if(this.timestampRequests){query[this.timestampParam]=+new Date}if(!this.supportsBinary){query.b64=1}query=parseqs.encode(query);if(query.length){query="?"+query}return schema+"://"+this.hostname+port+this.path+query};WS.prototype.check=function(){return!!WebSocket&&!("__initialize"in WebSocket&&this.name===WS.prototype.name)}},{"../transport":14,"component-inherit":21,debug:22,"engine.io-parser":25,parseqs:35,ws:37}],20:[function(_dereq_,module,exports){var hasCORS=_dereq_("has-cors");module.exports=function(opts){var xdomain=opts.xdomain;var xscheme=opts.xscheme;var enablesXDR=opts.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!xdomain||hasCORS)){return new XMLHttpRequest}}catch(e){}try{if("undefined"!=typeof XDomainRequest&&!xscheme&&enablesXDR){return new XDomainRequest}}catch(e){}if(!xdomain){try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}}}},{"has-cors":40}],21:[function(_dereq_,module,exports){module.exports=function(a,b){var fn=function(){};fn.prototype=b.prototype;a.prototype=new fn;a.prototype.constructor=a}},{}],22:[function(_dereq_,module,exports){exports=module.exports=_dereq_("./debug");exports.log=log;exports.formatArgs=formatArgs;exports.save=save;exports.load=load;exports.useColors=useColors;exports.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"];function useColors(){return"WebkitAppearance"in document.documentElement.style||window.console&&(console.firebug||console.exception&&console.table)||navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31}exports.formatters.j=function(v){return JSON.stringify(v)};function formatArgs(){var args=arguments;var useColors=this.useColors;args[0]=(useColors?"%c":"")+this.namespace+(useColors?" %c":" ")+args[0]+(useColors?"%c ":" ")+"+"+exports.humanize(this.diff);if(!useColors)return args;var c="color: "+this.color;args=[args[0],c,"color: inherit"].concat(Array.prototype.slice.call(args,1));var index=0;var lastC=0;args[0].replace(/%[a-z%]/g,function(match){if("%"===match)return;index++;if("%c"===match){lastC=index}});args.splice(lastC,0,c);return args}function log(){return"object"==typeof console&&"function"==typeof console.log&&Function.prototype.apply.call(console.log,console,arguments)}function save(namespaces){try{if(null==namespaces){localStorage.removeItem("debug")}else{localStorage.debug=namespaces}}catch(e){}}function load(){var r;try{r=localStorage.debug}catch(e){}return r}exports.enable(load())},{"./debug":23}],23:[function(_dereq_,module,exports){exports=module.exports=debug;exports.coerce=coerce;exports.disable=disable;exports.enable=enable;exports.enabled=enabled;exports.humanize=_dereq_("ms");exports.names=[];exports.skips=[];exports.formatters={};var prevColor=0;var prevTime;function selectColor(){return exports.colors[prevColor++%exports.colors.length]}function debug(namespace){function disabled(){}disabled.enabled=false;function enabled(){var self=enabled;var curr=+new Date;var ms=curr-(prevTime||curr);self.diff=ms;self.prev=prevTime;self.curr=curr;prevTime=curr;if(null==self.useColors)self.useColors=exports.useColors();if(null==self.color&&self.useColors)self.color=selectColor();var args=Array.prototype.slice.call(arguments);args[0]=exports.coerce(args[0]);if("string"!==typeof args[0]){args=["%o"].concat(args)}var index=0;args[0]=args[0].replace(/%([a-z%])/g,function(match,format){if(match==="%")return match;index++;var formatter=exports.formatters[format];if("function"===typeof formatter){var val=args[index];match=formatter.call(self,val);args.splice(index,1);index--}return match});if("function"===typeof exports.formatArgs){args=exports.formatArgs.apply(self,args)}var logFn=enabled.log||exports.log||console.log.bind(console);logFn.apply(self,args)}enabled.enabled=true;var fn=exports.enabled(namespace)?enabled:disabled;fn.namespace=namespace;return fn}function enable(namespaces){exports.save(namespaces);var split=(namespaces||"").split(/[\s,]+/);var len=split.length;for(var i=0;i<len;i++){if(!split[i])continue;namespaces=split[i].replace(/\*/g,".*?");if(namespaces[0]==="-"){exports.skips.push(new RegExp("^"+namespaces.substr(1)+"$"))}else{exports.names.push(new RegExp("^"+namespaces+"$"))}}}function disable(){exports.enable("")}function enabled(name){var i,len;for(i=0,len=exports.skips.length;i<len;i++){if(exports.skips[i].test(name)){return false}}for(i=0,len=exports.names.length;i<len;i++){if(exports.names[i].test(name)){return true}}return false}function coerce(val){if(val instanceof Error)return val.stack||val.message;return val}},{ms:24}],24:[function(_dereq_,module,exports){var s=1e3;var m=s*60;var h=m*60;var d=h*24;var y=d*365.25;module.exports=function(val,options){options=options||{};if("string"==typeof val)return parse(val);return options.long?long(val):short(val)};function parse(str){var match=/^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);if(!match)return;var n=parseFloat(match[1]);var type=(match[2]||"ms").toLowerCase();switch(type){case"years":case"year":case"y":return n*y;case"days":case"day":case"d":return n*d;case"hours":case"hour":case"h":return n*h;case"minutes":case"minute":case"m":return n*m;case"seconds":case"second":case"s":return n*s;case"ms":return n}}function short(ms){if(ms>=d)return Math.round(ms/d)+"d";if(ms>=h)return Math.round(ms/h)+"h";if(ms>=m)return Math.round(ms/m)+"m";if(ms>=s)return Math.round(ms/s)+"s";return ms+"ms"}function long(ms){return plural(ms,d,"day")||plural(ms,h,"hour")||plural(ms,m,"minute")||plural(ms,s,"second")||ms+" ms"}function plural(ms,n,name){if(ms<n)return;if(ms<n*1.5)return Math.floor(ms/n)+" "+name;return Math.ceil(ms/n)+" "+name+"s"}},{}],25:[function(_dereq_,module,exports){(function(global){var keys=_dereq_("./keys");var hasBinary=_dereq_("has-binary");var sliceBuffer=_dereq_("arraybuffer.slice");var base64encoder=_dereq_("base64-arraybuffer");var after=_dereq_("after");var utf8=_dereq_("utf8");var isAndroid=navigator.userAgent.match(/Android/i);var isPhantomJS=/PhantomJS/i.test(navigator.userAgent);var dontSendBlobs=isAndroid||isPhantomJS;exports.protocol=3;var packets=exports.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6};var packetslist=keys(packets);var err={type:"error",data:"parser error"};var Blob=_dereq_("blob");exports.encodePacket=function(packet,supportsBinary,utf8encode,callback){if("function"==typeof supportsBinary){callback=supportsBinary;supportsBinary=false}if("function"==typeof utf8encode){callback=utf8encode;utf8encode=null}var data=packet.data===undefined?undefined:packet.data.buffer||packet.data;if(global.ArrayBuffer&&data instanceof ArrayBuffer){return encodeArrayBuffer(packet,supportsBinary,callback)}else if(Blob&&data instanceof global.Blob){return encodeBlob(packet,supportsBinary,callback)}if(data&&data.base64){return encodeBase64Object(packet,callback)}var encoded=packets[packet.type];if(undefined!==packet.data){encoded+=utf8encode?utf8.encode(String(packet.data)):String(packet.data)}return callback(""+encoded)};function encodeBase64Object(packet,callback){var message="b"+exports.packets[packet.type]+packet.data.data;return callback(message)}function encodeArrayBuffer(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}var data=packet.data;var contentArray=new Uint8Array(data);var resultBuffer=new Uint8Array(1+data.byteLength);resultBuffer[0]=packets[packet.type];for(var i=0;i<contentArray.length;i++){resultBuffer[i+1]=contentArray[i]}return callback(resultBuffer.buffer)}function encodeBlobAsArrayBuffer(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}var fr=new FileReader;fr.onload=function(){packet.data=fr.result;exports.encodePacket(packet,supportsBinary,true,callback)};return fr.readAsArrayBuffer(packet.data)}function encodeBlob(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}if(dontSendBlobs){return encodeBlobAsArrayBuffer(packet,supportsBinary,callback)}var length=new Uint8Array(1);length[0]=packets[packet.type];var blob=new Blob([length.buffer,packet.data]);return callback(blob)}exports.encodeBase64Packet=function(packet,callback){var message="b"+exports.packets[packet.type];if(Blob&&packet.data instanceof Blob){var fr=new FileReader;fr.onload=function(){var b64=fr.result.split(",")[1];callback(message+b64)};return fr.readAsDataURL(packet.data)}var b64data;try{b64data=String.fromCharCode.apply(null,new Uint8Array(packet.data))}catch(e){var typed=new Uint8Array(packet.data);var basic=new Array(typed.length);for(var i=0;i<typed.length;i++){basic[i]=typed[i]}b64data=String.fromCharCode.apply(null,basic)}message+=global.btoa(b64data);return callback(message)};exports.decodePacket=function(data,binaryType,utf8decode){if(typeof data=="string"||data===undefined){if(data.charAt(0)=="b"){return exports.decodeBase64Packet(data.substr(1),binaryType)}if(utf8decode){try{data=utf8.decode(data)}catch(e){return err}}var type=data.charAt(0);if(Number(type)!=type||!packetslist[type]){return err}if(data.length>1){return{type:packetslist[type],data:data.substring(1)}}else{return{type:packetslist[type]}}}var asArray=new Uint8Array(data);var type=asArray[0];var rest=sliceBuffer(data,1);if(Blob&&binaryType==="blob"){rest=new Blob([rest])}return{type:packetslist[type],data:rest}};exports.decodeBase64Packet=function(msg,binaryType){var type=packetslist[msg.charAt(0)];if(!global.ArrayBuffer){return{type:type,data:{base64:true,data:msg.substr(1)}}}var data=base64encoder.decode(msg.substr(1));if(binaryType==="blob"&&Blob){data=new Blob([data])}return{type:type,data:data}};exports.encodePayload=function(packets,supportsBinary,callback){if(typeof supportsBinary=="function"){callback=supportsBinary;supportsBinary=null}var isBinary=hasBinary(packets);if(supportsBinary&&isBinary){if(Blob&&!dontSendBlobs){return exports.encodePayloadAsBlob(packets,callback)}return exports.encodePayloadAsArrayBuffer(packets,callback)}if(!packets.length){return callback("0:")}function setLengthHeader(message){return message.length+":"+message}function encodeOne(packet,doneCallback){exports.encodePacket(packet,!isBinary?false:supportsBinary,true,function(message){doneCallback(null,setLengthHeader(message))})}map(packets,encodeOne,function(err,results){return callback(results.join(""))})};function map(ary,each,done){var result=new Array(ary.length);var next=after(ary.length,done);var eachWithIndex=function(i,el,cb){each(el,function(error,msg){result[i]=msg;cb(error,result)})};for(var i=0;i<ary.length;i++){eachWithIndex(i,ary[i],next)}}exports.decodePayload=function(data,binaryType,callback){if(typeof data!="string"){return exports.decodePayloadAsBinary(data,binaryType,callback)}if(typeof binaryType==="function"){callback=binaryType;binaryType=null}var packet;if(data==""){return callback(err,0,1)}var length="",n,msg;for(var i=0,l=data.length;i<l;i++){var chr=data.charAt(i);if(":"!=chr){length+=chr}else{if(""==length||length!=(n=Number(length))){return callback(err,0,1)}msg=data.substr(i+1,n);if(length!=msg.length){return callback(err,0,1)}if(msg.length){packet=exports.decodePacket(msg,binaryType,true);if(err.type==packet.type&&err.data==packet.data){return callback(err,0,1)}var ret=callback(packet,i+n,l);if(false===ret)return}i+=n;length=""}}if(length!=""){return callback(err,0,1)}};exports.encodePayloadAsArrayBuffer=function(packets,callback){if(!packets.length){return callback(new ArrayBuffer(0))}function encodeOne(packet,doneCallback){exports.encodePacket(packet,true,true,function(data){return doneCallback(null,data)})}map(packets,encodeOne,function(err,encodedPackets){var totalLength=encodedPackets.reduce(function(acc,p){var len;if(typeof p==="string"){len=p.length}else{len=p.byteLength}return acc+len.toString().length+len+2},0);var resultArray=new Uint8Array(totalLength);var bufferIndex=0;encodedPackets.forEach(function(p){var isString=typeof p==="string";var ab=p;if(isString){var view=new Uint8Array(p.length);for(var i=0;i<p.length;i++){view[i]=p.charCodeAt(i)}ab=view.buffer}if(isString){resultArray[bufferIndex++]=0}else{resultArray[bufferIndex++]=1}var lenStr=ab.byteLength.toString();for(var i=0;i<lenStr.length;i++){resultArray[bufferIndex++]=parseInt(lenStr[i])}resultArray[bufferIndex++]=255;var view=new Uint8Array(ab);for(var i=0;i<view.length;i++){resultArray[bufferIndex++]=view[i]}});return callback(resultArray.buffer)})};exports.encodePayloadAsBlob=function(packets,callback){function encodeOne(packet,doneCallback){exports.encodePacket(packet,true,true,function(encoded){var binaryIdentifier=new Uint8Array(1);binaryIdentifier[0]=1;if(typeof encoded==="string"){var view=new Uint8Array(encoded.length);for(var i=0;i<encoded.length;i++){view[i]=encoded.charCodeAt(i)}encoded=view.buffer;binaryIdentifier[0]=0}var len=encoded instanceof ArrayBuffer?encoded.byteLength:encoded.size;var lenStr=len.toString();var lengthAry=new Uint8Array(lenStr.length+1);for(var i=0;i<lenStr.length;i++){lengthAry[i]=parseInt(lenStr[i])}lengthAry[lenStr.length]=255;if(Blob){var blob=new Blob([binaryIdentifier.buffer,lengthAry.buffer,encoded]);doneCallback(null,blob)}})}map(packets,encodeOne,function(err,results){return callback(new Blob(results))})};exports.decodePayloadAsBinary=function(data,binaryType,callback){if(typeof binaryType==="function"){callback=binaryType;binaryType=null}var bufferTail=data;var buffers=[];var numberTooLong=false;while(bufferTail.byteLength>0){var tailArray=new Uint8Array(bufferTail);var isString=tailArray[0]===0;var msgLength="";for(var i=1;;i++){if(tailArray[i]==255)break;if(msgLength.length>310){numberTooLong=true;break}msgLength+=tailArray[i]}if(numberTooLong)return callback(err,0,1);bufferTail=sliceBuffer(bufferTail,2+msgLength.length);msgLength=parseInt(msgLength);var msg=sliceBuffer(bufferTail,0,msgLength);if(isString){try{msg=String.fromCharCode.apply(null,new Uint8Array(msg))}catch(e){var typed=new Uint8Array(msg);msg="";for(var i=0;i<typed.length;i++){msg+=String.fromCharCode(typed[i])}}}buffers.push(msg);bufferTail=sliceBuffer(bufferTail,msgLength)}var total=buffers.length;buffers.forEach(function(buffer,i){callback(exports.decodePacket(buffer,binaryType,true),i,total)})}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./keys":26,after:27,"arraybuffer.slice":28,"base64-arraybuffer":29,blob:30,"has-binary":31,utf8:33}],26:[function(_dereq_,module,exports){module.exports=Object.keys||function keys(obj){var arr=[];var has=Object.prototype.hasOwnProperty;for(var i in obj){if(has.call(obj,i)){arr.push(i)}}return arr}},{}],27:[function(_dereq_,module,exports){module.exports=after;function after(count,callback,err_cb){var bail=false;err_cb=err_cb||noop;proxy.count=count;return count===0?callback():proxy;function proxy(err,result){if(proxy.count<=0){throw new Error("after called too many times")}--proxy.count;if(err){bail=true;callback(err);callback=err_cb}else if(proxy.count===0&&!bail){callback(null,result)}}}function noop(){}},{}],28:[function(_dereq_,module,exports){module.exports=function(arraybuffer,start,end){var bytes=arraybuffer.byteLength;start=start||0;end=end||bytes;if(arraybuffer.slice){return arraybuffer.slice(start,end)}if(start<0){start+=bytes}if(end<0){end+=bytes}if(end>bytes){end=bytes}if(start>=bytes||start>=end||bytes===0){return new ArrayBuffer(0)}var abv=new Uint8Array(arraybuffer);var result=new Uint8Array(end-start);for(var i=start,ii=0;i<end;i++,ii++){result[ii]=abv[i]}return result.buffer}},{}],29:[function(_dereq_,module,exports){(function(chars){"use strict";exports.encode=function(arraybuffer){var bytes=new Uint8Array(arraybuffer),i,len=bytes.length,base64="";for(i=0;i<len;i+=3){base64+=chars[bytes[i]>>2];base64+=chars[(bytes[i]&3)<<4|bytes[i+1]>>4];base64+=chars[(bytes[i+1]&15)<<2|bytes[i+2]>>6];base64+=chars[bytes[i+2]&63]}if(len%3===2){base64=base64.substring(0,base64.length-1)+"="}else if(len%3===1){base64=base64.substring(0,base64.length-2)+"=="}return base64};exports.decode=function(base64){var bufferLength=base64.length*.75,len=base64.length,i,p=0,encoded1,encoded2,encoded3,encoded4;if(base64[base64.length-1]==="="){bufferLength--;if(base64[base64.length-2]==="="){bufferLength--}}var arraybuffer=new ArrayBuffer(bufferLength),bytes=new Uint8Array(arraybuffer);for(i=0;i<len;i+=4){encoded1=chars.indexOf(base64[i]);encoded2=chars.indexOf(base64[i+1]);encoded3=chars.indexOf(base64[i+2]);encoded4=chars.indexOf(base64[i+3]);bytes[p++]=encoded1<<2|encoded2>>4;bytes[p++]=(encoded2&15)<<4|encoded3>>2;bytes[p++]=(encoded3&3)<<6|encoded4&63}return arraybuffer}})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")},{}],30:[function(_dereq_,module,exports){(function(global){var BlobBuilder=global.BlobBuilder||global.WebKitBlobBuilder||global.MSBlobBuilder||global.MozBlobBuilder;var blobSupported=function(){try{var b=new Blob(["hi"]);return b.size==2}catch(e){return false}}();var blobBuilderSupported=BlobBuilder&&BlobBuilder.prototype.append&&BlobBuilder.prototype.getBlob;function BlobBuilderConstructor(ary,options){options=options||{};var bb=new BlobBuilder;for(var i=0;i<ary.length;i++){bb.append(ary[i])}return options.type?bb.getBlob(options.type):bb.getBlob()}module.exports=function(){if(blobSupported){return global.Blob}else if(blobBuilderSupported){return BlobBuilderConstructor}else{return undefined}}()}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],31:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");module.exports=hasBinary;function hasBinary(data){function _hasBinary(obj){if(!obj)return false;if(global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer||global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){return true}if(isArray(obj)){for(var i=0;i<obj.length;i++){if(_hasBinary(obj[i])){return true}}}else if(obj&&"object"==typeof obj){if(obj.toJSON){obj=obj.toJSON()}for(var key in obj){if(obj.hasOwnProperty(key)&&_hasBinary(obj[key])){return true}}}return false}return _hasBinary(data)}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{isarray:32}],32:[function(_dereq_,module,exports){module.exports=Array.isArray||function(arr){return Object.prototype.toString.call(arr)=="[object Array]"}},{}],33:[function(_dereq_,module,exports){(function(global){(function(root){var freeExports=typeof exports=="object"&&exports;var freeModule=typeof module=="object"&&module&&module.exports==freeExports&&module;var freeGlobal=typeof global=="object"&&global;if(freeGlobal.global===freeGlobal||freeGlobal.window===freeGlobal){root=freeGlobal}var stringFromCharCode=String.fromCharCode;function ucs2decode(string){var output=[];var counter=0;var length=string.length;var value;var extra;while(counter<length){value=string.charCodeAt(counter++);if(value>=55296&&value<=56319&&counter<length){extra=string.charCodeAt(counter++);if((extra&64512)==56320){output.push(((value&1023)<<10)+(extra&1023)+65536)}else{output.push(value);counter--}}else{output.push(value)}}return output}function ucs2encode(array){var length=array.length;var index=-1;var value;var output="";while(++index<length){value=array[index];if(value>65535){value-=65536;
output+=stringFromCharCode(value>>>10&1023|55296);value=56320|value&1023}output+=stringFromCharCode(value)}return output}function createByte(codePoint,shift){return stringFromCharCode(codePoint>>shift&63|128)}function encodeCodePoint(codePoint){if((codePoint&4294967168)==0){return stringFromCharCode(codePoint)}var symbol="";if((codePoint&4294965248)==0){symbol=stringFromCharCode(codePoint>>6&31|192)}else if((codePoint&4294901760)==0){symbol=stringFromCharCode(codePoint>>12&15|224);symbol+=createByte(codePoint,6)}else if((codePoint&4292870144)==0){symbol=stringFromCharCode(codePoint>>18&7|240);symbol+=createByte(codePoint,12);symbol+=createByte(codePoint,6)}symbol+=stringFromCharCode(codePoint&63|128);return symbol}function utf8encode(string){var codePoints=ucs2decode(string);var length=codePoints.length;var index=-1;var codePoint;var byteString="";while(++index<length){codePoint=codePoints[index];byteString+=encodeCodePoint(codePoint)}return byteString}function readContinuationByte(){if(byteIndex>=byteCount){throw Error("Invalid byte index")}var continuationByte=byteArray[byteIndex]&255;byteIndex++;if((continuationByte&192)==128){return continuationByte&63}throw Error("Invalid continuation byte")}function decodeSymbol(){var byte1;var byte2;var byte3;var byte4;var codePoint;if(byteIndex>byteCount){throw Error("Invalid byte index")}if(byteIndex==byteCount){return false}byte1=byteArray[byteIndex]&255;byteIndex++;if((byte1&128)==0){return byte1}if((byte1&224)==192){var byte2=readContinuationByte();codePoint=(byte1&31)<<6|byte2;if(codePoint>=128){return codePoint}else{throw Error("Invalid continuation byte")}}if((byte1&240)==224){byte2=readContinuationByte();byte3=readContinuationByte();codePoint=(byte1&15)<<12|byte2<<6|byte3;if(codePoint>=2048){return codePoint}else{throw Error("Invalid continuation byte")}}if((byte1&248)==240){byte2=readContinuationByte();byte3=readContinuationByte();byte4=readContinuationByte();codePoint=(byte1&15)<<18|byte2<<12|byte3<<6|byte4;if(codePoint>=65536&&codePoint<=1114111){return codePoint}}throw Error("Invalid UTF-8 detected")}var byteArray;var byteCount;var byteIndex;function utf8decode(byteString){byteArray=ucs2decode(byteString);byteCount=byteArray.length;byteIndex=0;var codePoints=[];var tmp;while((tmp=decodeSymbol())!==false){codePoints.push(tmp)}return ucs2encode(codePoints)}var utf8={version:"2.0.0",encode:utf8encode,decode:utf8decode};if(typeof define=="function"&&typeof define.amd=="object"&&define.amd){define(function(){return utf8})}else if(freeExports&&!freeExports.nodeType){if(freeModule){freeModule.exports=utf8}else{var object={};var hasOwnProperty=object.hasOwnProperty;for(var key in utf8){hasOwnProperty.call(utf8,key)&&(freeExports[key]=utf8[key])}}}else{root.utf8=utf8}})(this)}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],34:[function(_dereq_,module,exports){(function(global){var rvalidchars=/^[\],:{}\s]*$/;var rvalidescape=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;var rvalidtokens=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;var rvalidbraces=/(?:^|:|,)(?:\s*\[)+/g;var rtrimLeft=/^\s+/;var rtrimRight=/\s+$/;module.exports=function parsejson(data){if("string"!=typeof data||!data){return null}data=data.replace(rtrimLeft,"").replace(rtrimRight,"");if(global.JSON&&JSON.parse){return JSON.parse(data)}if(rvalidchars.test(data.replace(rvalidescape,"@").replace(rvalidtokens,"]").replace(rvalidbraces,""))){return new Function("return "+data)()}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],35:[function(_dereq_,module,exports){exports.encode=function(obj){var str="";for(var i in obj){if(obj.hasOwnProperty(i)){if(str.length)str+="&";str+=encodeURIComponent(i)+"="+encodeURIComponent(obj[i])}}return str};exports.decode=function(qs){var qry={};var pairs=qs.split("&");for(var i=0,l=pairs.length;i<l;i++){var pair=pairs[i].split("=");qry[decodeURIComponent(pair[0])]=decodeURIComponent(pair[1])}return qry}},{}],36:[function(_dereq_,module,exports){var re=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;var parts=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];module.exports=function parseuri(str){var src=str,b=str.indexOf("["),e=str.indexOf("]");if(b!=-1&&e!=-1){str=str.substring(0,b)+str.substring(b,e).replace(/:/g,";")+str.substring(e,str.length)}var m=re.exec(str||""),uri={},i=14;while(i--){uri[parts[i]]=m[i]||""}if(b!=-1&&e!=-1){uri.source=src;uri.host=uri.host.substring(1,uri.host.length-1).replace(/;/g,":");uri.authority=uri.authority.replace("[","").replace("]","").replace(/;/g,":");uri.ipv6uri=true}return uri}},{}],37:[function(_dereq_,module,exports){var global=function(){return this}();var WebSocket=global.WebSocket||global.MozWebSocket;module.exports=WebSocket?ws:null;function ws(uri,protocols,opts){var instance;if(protocols){instance=new WebSocket(uri,protocols)}else{instance=new WebSocket(uri)}return instance}if(WebSocket)ws.prototype=WebSocket.prototype},{}],38:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");module.exports=hasBinary;function hasBinary(data){function _hasBinary(obj){if(!obj)return false;if(global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer||global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){return true}if(isArray(obj)){for(var i=0;i<obj.length;i++){if(_hasBinary(obj[i])){return true}}}else if(obj&&"object"==typeof obj){if(obj.toJSON){obj=obj.toJSON()}for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)&&_hasBinary(obj[key])){return true}}}return false}return _hasBinary(data)}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{isarray:39}],39:[function(_dereq_,module,exports){module.exports=_dereq_(32)},{}],40:[function(_dereq_,module,exports){var global=_dereq_("global");try{module.exports="XMLHttpRequest"in global&&"withCredentials"in new global.XMLHttpRequest}catch(err){module.exports=false}},{global:41}],41:[function(_dereq_,module,exports){module.exports=function(){return this}()},{}],42:[function(_dereq_,module,exports){var indexOf=[].indexOf;module.exports=function(arr,obj){if(indexOf)return arr.indexOf(obj);for(var i=0;i<arr.length;++i){if(arr[i]===obj)return i}return-1}},{}],43:[function(_dereq_,module,exports){var has=Object.prototype.hasOwnProperty;exports.keys=Object.keys||function(obj){var keys=[];for(var key in obj){if(has.call(obj,key)){keys.push(key)}}return keys};exports.values=function(obj){var vals=[];for(var key in obj){if(has.call(obj,key)){vals.push(obj[key])}}return vals};exports.merge=function(a,b){for(var key in b){if(has.call(b,key)){a[key]=b[key]}}return a};exports.length=function(obj){return exports.keys(obj).length};exports.isEmpty=function(obj){return 0==exports.length(obj)}},{}],44:[function(_dereq_,module,exports){var re=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;var parts=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];module.exports=function parseuri(str){var m=re.exec(str||""),uri={},i=14;while(i--){uri[parts[i]]=m[i]||""}return uri}},{}],45:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");var isBuf=_dereq_("./is-buffer");exports.deconstructPacket=function(packet){var buffers=[];var packetData=packet.data;function _deconstructPacket(data){if(!data)return data;if(isBuf(data)){var placeholder={_placeholder:true,num:buffers.length};buffers.push(data);return placeholder}else if(isArray(data)){var newData=new Array(data.length);for(var i=0;i<data.length;i++){newData[i]=_deconstructPacket(data[i])}return newData}else if("object"==typeof data&&!(data instanceof Date)){var newData={};for(var key in data){newData[key]=_deconstructPacket(data[key])}return newData}return data}var pack=packet;pack.data=_deconstructPacket(packetData);pack.attachments=buffers.length;return{packet:pack,buffers:buffers}};exports.reconstructPacket=function(packet,buffers){var curPlaceHolder=0;function _reconstructPacket(data){if(data&&data._placeholder){var buf=buffers[data.num];return buf}else if(isArray(data)){for(var i=0;i<data.length;i++){data[i]=_reconstructPacket(data[i])}return data}else if(data&&"object"==typeof data){for(var key in data){data[key]=_reconstructPacket(data[key])}return data}return data}packet.data=_reconstructPacket(packet.data);packet.attachments=undefined;return packet};exports.removeBlobs=function(data,callback){function _removeBlobs(obj,curKey,containingObject){if(!obj)return obj;if(global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){pendingBlobs++;var fileReader=new FileReader;fileReader.onload=function(){if(containingObject){containingObject[curKey]=this.result}else{bloblessData=this.result}if(!--pendingBlobs){callback(bloblessData)}};fileReader.readAsArrayBuffer(obj)}else if(isArray(obj)){for(var i=0;i<obj.length;i++){_removeBlobs(obj[i],i,obj)}}else if(obj&&"object"==typeof obj&&!isBuf(obj)){for(var key in obj){_removeBlobs(obj[key],key,obj)}}}var pendingBlobs=0;var bloblessData=data;_removeBlobs(bloblessData);if(!pendingBlobs){callback(bloblessData)}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./is-buffer":47,isarray:48}],46:[function(_dereq_,module,exports){var debug=_dereq_("debug")("socket.io-parser");var json=_dereq_("json3");var isArray=_dereq_("isarray");var Emitter=_dereq_("component-emitter");var binary=_dereq_("./binary");var isBuf=_dereq_("./is-buffer");exports.protocol=4;exports.types=["CONNECT","DISCONNECT","EVENT","BINARY_EVENT","ACK","BINARY_ACK","ERROR"];exports.CONNECT=0;exports.DISCONNECT=1;exports.EVENT=2;exports.ACK=3;exports.ERROR=4;exports.BINARY_EVENT=5;exports.BINARY_ACK=6;exports.Encoder=Encoder;exports.Decoder=Decoder;function Encoder(){}Encoder.prototype.encode=function(obj,callback){debug("encoding packet %j",obj);if(exports.BINARY_EVENT==obj.type||exports.BINARY_ACK==obj.type){encodeAsBinary(obj,callback)}else{var encoding=encodeAsString(obj);callback([encoding])}};function encodeAsString(obj){var str="";var nsp=false;str+=obj.type;if(exports.BINARY_EVENT==obj.type||exports.BINARY_ACK==obj.type){str+=obj.attachments;str+="-"}if(obj.nsp&&"/"!=obj.nsp){nsp=true;str+=obj.nsp}if(null!=obj.id){if(nsp){str+=",";nsp=false}str+=obj.id}if(null!=obj.data){if(nsp)str+=",";str+=json.stringify(obj.data)}debug("encoded %j as %s",obj,str);return str}function encodeAsBinary(obj,callback){function writeEncoding(bloblessData){var deconstruction=binary.deconstructPacket(bloblessData);var pack=encodeAsString(deconstruction.packet);var buffers=deconstruction.buffers;buffers.unshift(pack);callback(buffers)}binary.removeBlobs(obj,writeEncoding)}function Decoder(){this.reconstructor=null}Emitter(Decoder.prototype);Decoder.prototype.add=function(obj){var packet;if("string"==typeof obj){packet=decodeString(obj);if(exports.BINARY_EVENT==packet.type||exports.BINARY_ACK==packet.type){this.reconstructor=new BinaryReconstructor(packet);if(this.reconstructor.reconPack.attachments===0){this.emit("decoded",packet)}}else{this.emit("decoded",packet)}}else if(isBuf(obj)||obj.base64){if(!this.reconstructor){throw new Error("got binary data when not reconstructing a packet")}else{packet=this.reconstructor.takeBinaryData(obj);if(packet){this.reconstructor=null;this.emit("decoded",packet)}}}else{throw new Error("Unknown type: "+obj)}};function decodeString(str){var p={};var i=0;p.type=Number(str.charAt(0));if(null==exports.types[p.type])return error();if(exports.BINARY_EVENT==p.type||exports.BINARY_ACK==p.type){var buf="";while(str.charAt(++i)!="-"){buf+=str.charAt(i);if(i+1==str.length)break}if(buf!=Number(buf)||str.charAt(i)!="-"){throw new Error("Illegal attachments")}p.attachments=Number(buf)}if("/"==str.charAt(i+1)){p.nsp="";while(++i){var c=str.charAt(i);if(","==c)break;p.nsp+=c;if(i+1==str.length)break}}else{p.nsp="/"}var next=str.charAt(i+1);if(""!==next&&Number(next)==next){p.id="";while(++i){var c=str.charAt(i);if(null==c||Number(c)!=c){--i;break}p.id+=str.charAt(i);if(i+1==str.length)break}p.id=Number(p.id)}if(str.charAt(++i)){try{p.data=json.parse(str.substr(i))}catch(e){return error()}}debug("decoded %s as %j",str,p);return p}Decoder.prototype.destroy=function(){if(this.reconstructor){this.reconstructor.finishedReconstruction()}};function BinaryReconstructor(packet){this.reconPack=packet;this.buffers=[]}BinaryReconstructor.prototype.takeBinaryData=function(binData){this.buffers.push(binData);if(this.buffers.length==this.reconPack.attachments){var packet=binary.reconstructPacket(this.reconPack,this.buffers);this.finishedReconstruction();return packet}return null};BinaryReconstructor.prototype.finishedReconstruction=function(){this.reconPack=null;this.buffers=[]};function error(data){return{type:exports.ERROR,data:"parser error"}}},{"./binary":45,"./is-buffer":47,"component-emitter":9,debug:10,isarray:48,json3:49}],47:[function(_dereq_,module,exports){(function(global){module.exports=isBuf;function isBuf(obj){return global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],48:[function(_dereq_,module,exports){module.exports=_dereq_(32)},{}],49:[function(_dereq_,module,exports){(function(window){var getClass={}.toString,isProperty,forEach,undef;var isLoader=typeof define==="function"&&define.amd;var nativeJSON=typeof JSON=="object"&&JSON;var JSON3=typeof exports=="object"&&exports&&!exports.nodeType&&exports;if(JSON3&&nativeJSON){JSON3.stringify=nativeJSON.stringify;JSON3.parse=nativeJSON.parse}else{JSON3=window.JSON=nativeJSON||{}}var isExtended=new Date(-0xc782b5b800cec);try{isExtended=isExtended.getUTCFullYear()==-109252&&isExtended.getUTCMonth()===0&&isExtended.getUTCDate()===1&&isExtended.getUTCHours()==10&&isExtended.getUTCMinutes()==37&&isExtended.getUTCSeconds()==6&&isExtended.getUTCMilliseconds()==708}catch(exception){}function has(name){if(has[name]!==undef){return has[name]}var isSupported;if(name=="bug-string-char-index"){isSupported="a"[0]!="a"}else if(name=="json"){isSupported=has("json-stringify")&&has("json-parse")}else{var value,serialized='{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';if(name=="json-stringify"){var stringify=JSON3.stringify,stringifySupported=typeof stringify=="function"&&isExtended;if(stringifySupported){(value=function(){return 1}).toJSON=value;try{stringifySupported=stringify(0)==="0"&&stringify(new Number)==="0"&&stringify(new String)=='""'&&stringify(getClass)===undef&&stringify(undef)===undef&&stringify()===undef&&stringify(value)==="1"&&stringify([value])=="[1]"&&stringify([undef])=="[null]"&&stringify(null)=="null"&&stringify([undef,getClass,null])=="[null,null,null]"&&stringify({a:[value,true,false,null,"\x00\b\n\f\r "]})==serialized&&stringify(null,value)==="1"&&stringify([1,2],null,1)=="[\n 1,\n 2\n]"&&stringify(new Date(-864e13))=='"-271821-04-20T00:00:00.000Z"'&&stringify(new Date(864e13))=='"+275760-09-13T00:00:00.000Z"'&&stringify(new Date(-621987552e5))=='"-000001-01-01T00:00:00.000Z"'&&stringify(new Date(-1))=='"1969-12-31T23:59:59.999Z"'}catch(exception){stringifySupported=false}}isSupported=stringifySupported}if(name=="json-parse"){var parse=JSON3.parse;if(typeof parse=="function"){try{if(parse("0")===0&&!parse(false)){value=parse(serialized);var parseSupported=value["a"].length==5&&value["a"][0]===1;if(parseSupported){try{parseSupported=!parse('"  "')}catch(exception){}if(parseSupported){try{parseSupported=parse("01")!==1}catch(exception){}}if(parseSupported){try{parseSupported=parse("1.")!==1}catch(exception){}}}}}catch(exception){parseSupported=false}}isSupported=parseSupported}}return has[name]=!!isSupported}if(!has("json")){var functionClass="[object Function]";var dateClass="[object Date]";var numberClass="[object Number]";var stringClass="[object String]";var arrayClass="[object Array]";var booleanClass="[object Boolean]";var charIndexBuggy=has("bug-string-char-index");if(!isExtended){var floor=Math.floor;var Months=[0,31,59,90,120,151,181,212,243,273,304,334];var getDay=function(year,month){return Months[month]+365*(year-1970)+floor((year-1969+(month=+(month>1)))/4)-floor((year-1901+month)/100)+floor((year-1601+month)/400)}}if(!(isProperty={}.hasOwnProperty)){isProperty=function(property){var members={},constructor;if((members.__proto__=null,members.__proto__={toString:1},members).toString!=getClass){isProperty=function(property){var original=this.__proto__,result=property in(this.__proto__=null,this);this.__proto__=original;return result}}else{constructor=members.constructor;isProperty=function(property){var parent=(this.constructor||constructor).prototype;return property in this&&!(property in parent&&this[property]===parent[property])}}members=null;return isProperty.call(this,property)}}var PrimitiveTypes={"boolean":1,number:1,string:1,undefined:1};var isHostType=function(object,property){var type=typeof object[property];return type=="object"?!!object[property]:!PrimitiveTypes[type]};forEach=function(object,callback){var size=0,Properties,members,property;(Properties=function(){this.valueOf=0}).prototype.valueOf=0;members=new Properties;for(property in members){if(isProperty.call(members,property)){size++}}Properties=members=null;if(!size){members=["valueOf","toString","toLocaleString","propertyIsEnumerable","isPrototypeOf","hasOwnProperty","constructor"];forEach=function(object,callback){var isFunction=getClass.call(object)==functionClass,property,length;var hasProperty=!isFunction&&typeof object.constructor!="function"&&isHostType(object,"hasOwnProperty")?object.hasOwnProperty:isProperty;for(property in object){if(!(isFunction&&property=="prototype")&&hasProperty.call(object,property)){callback(property)}}for(length=members.length;property=members[--length];hasProperty.call(object,property)&&callback(property));}}else if(size==2){forEach=function(object,callback){var members={},isFunction=getClass.call(object)==functionClass,property;for(property in object){if(!(isFunction&&property=="prototype")&&!isProperty.call(members,property)&&(members[property]=1)&&isProperty.call(object,property)){callback(property)}}}}else{forEach=function(object,callback){var isFunction=getClass.call(object)==functionClass,property,isConstructor;for(property in object){if(!(isFunction&&property=="prototype")&&isProperty.call(object,property)&&!(isConstructor=property==="constructor")){callback(property)}}if(isConstructor||isProperty.call(object,property="constructor")){callback(property)}}}return forEach(object,callback)};if(!has("json-stringify")){var Escapes={92:"\\\\",34:'\\"',8:"\\b",12:"\\f",10:"\\n",13:"\\r",9:"\\t"};var leadingZeroes="000000";var toPaddedString=function(width,value){return(leadingZeroes+(value||0)).slice(-width)};var unicodePrefix="\\u00";var quote=function(value){var result='"',index=0,length=value.length,isLarge=length>10&&charIndexBuggy,symbols;if(isLarge){symbols=value.split("")}for(;index<length;index++){var charCode=value.charCodeAt(index);switch(charCode){case 8:case 9:case 10:case 12:case 13:case 34:case 92:result+=Escapes[charCode];break;default:if(charCode<32){result+=unicodePrefix+toPaddedString(2,charCode.toString(16));break}result+=isLarge?symbols[index]:charIndexBuggy?value.charAt(index):value[index]}}return result+'"'};var serialize=function(property,object,callback,properties,whitespace,indentation,stack){var value,className,year,month,date,time,hours,minutes,seconds,milliseconds,results,element,index,length,prefix,result;try{value=object[property]}catch(exception){}if(typeof value=="object"&&value){className=getClass.call(value);if(className==dateClass&&!isProperty.call(value,"toJSON")){if(value>-1/0&&value<1/0){if(getDay){date=floor(value/864e5);for(year=floor(date/365.2425)+1970-1;getDay(year+1,0)<=date;year++);for(month=floor((date-getDay(year,0))/30.42);getDay(year,month+1)<=date;month++);date=1+date-getDay(year,month);time=(value%864e5+864e5)%864e5;hours=floor(time/36e5)%24;minutes=floor(time/6e4)%60;seconds=floor(time/1e3)%60;milliseconds=time%1e3}else{year=value.getUTCFullYear();month=value.getUTCMonth();date=value.getUTCDate();hours=value.getUTCHours();minutes=value.getUTCMinutes();seconds=value.getUTCSeconds();milliseconds=value.getUTCMilliseconds()}value=(year<=0||year>=1e4?(year<0?"-":"+")+toPaddedString(6,year<0?-year:year):toPaddedString(4,year))+"-"+toPaddedString(2,month+1)+"-"+toPaddedString(2,date)+"T"+toPaddedString(2,hours)+":"+toPaddedString(2,minutes)+":"+toPaddedString(2,seconds)+"."+toPaddedString(3,milliseconds)+"Z"}else{value=null}}else if(typeof value.toJSON=="function"&&(className!=numberClass&&className!=stringClass&&className!=arrayClass||isProperty.call(value,"toJSON"))){value=value.toJSON(property)}}if(callback){value=callback.call(object,property,value)}if(value===null){return"null"}className=getClass.call(value);if(className==booleanClass){return""+value}else if(className==numberClass){return value>-1/0&&value<1/0?""+value:"null"}else if(className==stringClass){return quote(""+value)}if(typeof value=="object"){for(length=stack.length;length--;){if(stack[length]===value){throw TypeError()}}stack.push(value);results=[];prefix=indentation;indentation+=whitespace;if(className==arrayClass){for(index=0,length=value.length;index<length;index++){element=serialize(index,value,callback,properties,whitespace,indentation,stack);results.push(element===undef?"null":element)}result=results.length?whitespace?"[\n"+indentation+results.join(",\n"+indentation)+"\n"+prefix+"]":"["+results.join(",")+"]":"[]"}else{forEach(properties||value,function(property){var element=serialize(property,value,callback,properties,whitespace,indentation,stack);if(element!==undef){results.push(quote(property)+":"+(whitespace?" ":"")+element)}});result=results.length?whitespace?"{\n"+indentation+results.join(",\n"+indentation)+"\n"+prefix+"}":"{"+results.join(",")+"}":"{}"}stack.pop();return result}};JSON3.stringify=function(source,filter,width){var whitespace,callback,properties,className;if(typeof filter=="function"||typeof filter=="object"&&filter){if((className=getClass.call(filter))==functionClass){callback=filter}else if(className==arrayClass){properties={};for(var index=0,length=filter.length,value;index<length;value=filter[index++],(className=getClass.call(value),className==stringClass||className==numberClass)&&(properties[value]=1));}}if(width){if((className=getClass.call(width))==numberClass){if((width-=width%1)>0){for(whitespace="",width>10&&(width=10);whitespace.length<width;whitespace+=" ");}}else if(className==stringClass){whitespace=width.length<=10?width:width.slice(0,10)}}return serialize("",(value={},value[""]=source,value),callback,properties,whitespace,"",[])}}if(!has("json-parse")){var fromCharCode=String.fromCharCode;var Unescapes={92:"\\",34:'"',47:"/",98:"\b",116:"  ",110:"\n",102:"\f",114:"\r"};var Index,Source;var abort=function(){Index=Source=null;throw SyntaxError()};var lex=function(){var source=Source,length=source.length,value,begin,position,isSigned,charCode;while(Index<length){charCode=source.charCodeAt(Index);switch(charCode){case 9:case 10:case 13:case 32:Index++;break;case 123:case 125:case 91:case 93:case 58:case 44:value=charIndexBuggy?source.charAt(Index):source[Index];Index++;return value;case 34:for(value="@",Index++;Index<length;){charCode=source.charCodeAt(Index);if(charCode<32){abort()}else if(charCode==92){charCode=source.charCodeAt(++Index);switch(charCode){case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:value+=Unescapes[charCode];Index++;break;case 117:begin=++Index;for(position=Index+4;Index<position;Index++){charCode=source.charCodeAt(Index);if(!(charCode>=48&&charCode<=57||charCode>=97&&charCode<=102||charCode>=65&&charCode<=70)){abort()}}value+=fromCharCode("0x"+source.slice(begin,Index));break;default:abort()}}else{if(charCode==34){break}charCode=source.charCodeAt(Index);begin=Index;while(charCode>=32&&charCode!=92&&charCode!=34){charCode=source.charCodeAt(++Index)}value+=source.slice(begin,Index)}}if(source.charCodeAt(Index)==34){Index++;return value}abort();default:begin=Index;if(charCode==45){isSigned=true;charCode=source.charCodeAt(++Index)}if(charCode>=48&&charCode<=57){if(charCode==48&&(charCode=source.charCodeAt(Index+1),charCode>=48&&charCode<=57)){abort()}isSigned=false;for(;Index<length&&(charCode=source.charCodeAt(Index),charCode>=48&&charCode<=57);Index++);if(source.charCodeAt(Index)==46){position=++Index;for(;position<length&&(charCode=source.charCodeAt(position),charCode>=48&&charCode<=57);position++);if(position==Index){abort()}Index=position}charCode=source.charCodeAt(Index);if(charCode==101||charCode==69){charCode=source.charCodeAt(++Index);if(charCode==43||charCode==45){Index++}for(position=Index;position<length&&(charCode=source.charCodeAt(position),charCode>=48&&charCode<=57);position++);if(position==Index){abort()}Index=position}return+source.slice(begin,Index)}if(isSigned){abort()}if(source.slice(Index,Index+4)=="true"){Index+=4;return true}else if(source.slice(Index,Index+5)=="false"){Index+=5;return false}else if(source.slice(Index,Index+4)=="null"){Index+=4;return null}abort()}}return"$"};var get=function(value){var results,hasMembers;if(value=="$"){abort()}if(typeof value=="string"){if((charIndexBuggy?value.charAt(0):value[0])=="@"){return value.slice(1)}if(value=="["){results=[];for(;;hasMembers||(hasMembers=true)){value=lex();if(value=="]"){break}if(hasMembers){if(value==","){value=lex();if(value=="]"){abort()}}else{abort()}}if(value==","){abort()}results.push(get(value))}return results}else if(value=="{"){results={};for(;;hasMembers||(hasMembers=true)){value=lex();if(value=="}"){break}if(hasMembers){if(value==","){value=lex();if(value=="}"){abort()}}else{abort()}}if(value==","||typeof value!="string"||(charIndexBuggy?value.charAt(0):value[0])!="@"||lex()!=":"){abort()}results[value.slice(1)]=get(lex())}return results}abort()}return value};var update=function(source,property,callback){var element=walk(source,property,callback);if(element===undef){delete source[property]}else{source[property]=element}};var walk=function(source,property,callback){var value=source[property],length;if(typeof value=="object"&&value){if(getClass.call(value)==arrayClass){for(length=value.length;length--;){update(value,length,callback)}}else{forEach(value,function(property){update(value,property,callback)})}}return callback.call(source,property,value)};JSON3.parse=function(source,callback){var result,value;Index=0;Source=""+source;result=get(lex());if(lex()!="$"){abort()}Index=Source=null;return callback&&getClass.call(callback)==functionClass?walk((value={},value[""]=result,value),"",callback):result}}}if(isLoader){define(function(){return JSON3})}})(this)},{}],50:[function(_dereq_,module,exports){module.exports=toArray;function toArray(list,index){var array=[];index=index||0;for(var i=index||0;i<list.length;i++){array[i-index]=list[i]}return array}},{}]},{},[1])(1)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/element.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')
  , element = require('../../element')
  , utilHash = require('../../../util/hash')
  , vObject = require('../../../object')

/*this file has nothing to do with the networkdata Class
  it only reads out models for elements so you can make a subscription
*/

function sortField( filter, obj ) {
  if( filter.sort && filter.sort.field ) 
  {
    var sort = { $:{} }
    sort.$[filter.sort.field] = true
    util.merge( obj, sort )
  }

  return obj
}

//TODO: has to work in the hub
var disableSelections = true

exports.parseData = function( val, fromtargets, logger ) {


  //important for unSubscribe ???
    // console.log('LETS PARSE DATA!'.cyan.inverse , val, JSON.stringify(fromtargets))
  

  // console.log('LETS PARSE DATA!'.cyan.inverse , val, JSON.stringify(fromtargets))

  if(!val) return
    // console.log('LETS PARSE DATA!2'.cyan.inverse , val, JSON.stringify(fromtargets))

  var subsobj = {}
    , f = val._filter
    , targets = fromtargets || val.__sub

  if (targets) {
    // console.log('targets', targets)
    if (f && !disableSelections) {
      if(!subsobj['*']) subsobj['*']=[]
      subsobj['*'].push([
        util.clone(f, {subsObj:true, fn:true, type:true})
        , sortField(f, fromtargets || { $: targets })
      ])

    // console.log( 'IM DOING SELECTS parseDatelex', subsobj )
    //TEMPFIX!!!!
    for(var i in subsobj['*'][1] ) {
      //wel ff de fields ook doen prob

      subsobj[i] = subsobj['*'][1][i]
    }
    delete subsobj['*']

    } else {
          // console.log( 'targets IM DOING SELECTS parseDatelex', targets )

      subsobj = targets
    }
  } else {
        // console.log('LETS PARSE DATA!4'.cyan.inverse , val, JSON.stringify(fromtargets))

    // console.warn( 'cant\'t find target -- lets do stuff!', val  )
    //TODO:guard voor als het het niet wil -- mischiend door _subs zoeken

    // if(val._path) {
    //   console.log(val._path)
    // }

    //no tragets dont do anything?
  }

  // console.log('RESULT!', JSON.stringify(subsobj))

  return subsobj
}

function setFlag( obj, string, flag, field, val, from, elem ) {



  var nonCloudDataBindings
    , fromKey

    , beTripppin


  if( from ) {
    fromKey = from._name !== void 0 ? from._name : from

    if( from instanceof vObject) {

      //tegenover gestelde bij
      // if(from.__t === 4) {
        // if(from._val && from._val.cloud) {
          //haal juist field weg
        // }
      // } 
      // console.log('FROM!', from._name, from._path )
      fromKey = from._name
    }

    if(from instanceof Array && from[1]) {
      // console.log('be tripping!', from)
      //   fromKey = from[1] && from[1]._name

      // beTripppin = from[0]._name

    }

  }

  var dd = elem && from && ( elem._d || elem.checkParent('data', true) )

  // if(beTripppin) {
  //   console.log(dd, fromKey, beTripppin)
  // }


  if (field === 'collection') {
    var obj2

    if (flag.filter && flag.filter.val!==true && !disableSelections) 
    {
      //dit nog handelen op refs
      obj2 = {}


      //ENABLE FOR SELECTION
      // if (string === true) {

      //   string = '*'
      // } else {

      //   string = string + '.*'
      // }
      var f = flag.filter.raw

        // console.log( 'SET FLAG', arguments )


  // console.log( 'FIELD!:', field , 'FROM:', from,  string.split('.'), string )

      var arr = util.path(obj, string.split('.'), [])

      arr.push( 
        [f, {
          $: sortField(f,obj2)
        }]
      )

      //obj, path, val, overwrite

      //TEMPFIX!!!!
      var temp = util.path( obj, string.split('.'), {}, true )
      for(var i in arr[arr.length-1][1] ) {
        //wel ff de fields ook doen prob

        temp[i] = arr[arr.length-1][1][i]
      }
      arr = temp

          // console.log( 'IM DOING SELECPS COL COL!', arr )


    } else {

      var f = string === true ? '$' : string + '.$'
        , p =  f.split('.')

        , specialFix

      if( dd && dd[ fromKey ] ) 
      {
        nonCloudDataBindings = true
        if( p[0] === fromKey ) 
        {
          p.shift()
          nonCloudDataBindings = false
        }
      }

      if( nonCloudDataBindings ) 
      {
        if(specialFix) {
          obj.specialFix = fromKey
          if(beTripppin) {
            obj.specialFix = [ fromKey, beTripppin ]
          }
          obj2 = util.path(obj, p , {})
          readModel(flag.element._val instanceof element ? flag.element._val : flag.element._val.base, obj2 )
        }
      } 
      else 
      {
        obj2 = util.path(obj, p , {})
        readModel(flag.element._val instanceof element ? flag.element._val : flag.element._val.base, obj2 )
      }

    }

                  // console.log(  'xxxXX1112222XXxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )


  } else {

    if( dd && dd[ fromKey ] ) 
    {
      nonCloudDataBindings = true
    }

    if ( string instanceof Array ) 
    {
      for (var i in string) 
      {
        if( nonCloudDataBindings )
        {
          //TODO: this is a tempfix
          // console.log('NON cloud bindings', string, string[i])
          if( string[i] instanceof Array ) {
            // console.log('!@!@!@')
            string[i] = string[i][0]
          }
          string[i] = string[i].split('.')
          if( string[i][0] === fromKey ) 
          {
            string[i].shift()
            util.path( obj, string[i], true )
          }
        }
        else
        {
          //TODO: this is a tempfix
          // console.log('OBJ:' , obj, 'STRING[i]:', string[i], 'STRING:', string, fromKey)
           if( string[i] instanceof Array ) {
            // console.log('2!@!@!@')
            string[i] = string[i][0]
          }
          util.path(obj, string[i].split('.'), true)
        }
      }
    } 
    else if ( string !== true && typeof string === 'string' ) 
    {
              // console.log(  'xxxXXXXxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )

      if( nonCloudDataBindings )
      {
        // console.log( nonCloudDataBindings , 'NONCLOUD')
          string = string.split('.')
          if( string[0] === fromKey ) 
          {
            string.shift()
              // console.log( 'FIELD!:222222', string )

            if(string.length > 0) util.path( obj, string, true )
          }
          // console.log( nonCloudDataBindings , 'NONCLOUD', string, obj )
      }
      else
      {
        // console.log(  'xxxxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )
        util.path( obj, string.split('.'), true )
      }
    } 
    else 
    {
      // console.log('----> 2'.inverse, string, obj, flag, field)
      // console.error('xxxxxx')
      // obj['__#__'] = true
      // obj = true;
      // console.log('!!!',obj, parent);
      // obj['#'] = true;
    }
    

  }
}

function store( obj, flag, field, val, from, elem ) {

  // console.log('STORE', arguments )

  if (flag instanceof Array) {
    for (var i = 0, l = flag.length; i < l; i++) {
      setFlag(obj, flag[i]._flag.data[2], flag, field, val, from, elem )

    }
  } else {
        // console.log('------>'.red,flag)

    setFlag(obj, flag._flag.data[2], flag, field, val, from, elem )
  }
}

function readModel( elem, obj, val, from , ignorefield) {

  // console.log( 'lets read model'.yellow.inverse, val && val._path || 'no valPath', from && from._path || 'no fromPath' , val, elem, obj, val, from )
    //hier moet het gecombineerd worden met een value waar het aan gebind is!

  if (elem.model && (elem.model.flags||elem.model.subscription||elem.model.field)) {
    
    // if(obj) console.log('XXX121212XXX COLLECTION',  elem.model.field && elem.model.field.val )
    // console.log('SET SORTFIELD! 2.12', JSON.stringify(obj,false,2), elem.model.field && elem.model.field.val)

    var a = obj
      , field
      , doItIgnoreFlags

      //["users", "U_ba3215a1b1038a70", "navigation", "episode"] 
    // console.log( '\n\n\n\n\n-------->', elem.model.field && elem.model.field.val, elem.model.parsing && !elem.model.parsed  )

    if(ignorefield) {
      // console.log('STOP! ignorefield', obj, elem.model.field && elem.model.field.val, from, from && from._path)
      // debugger
    }
    //TODO: compare arrays 
    else if(elem.model.field && elem.model.field.val && !elem.model.parsing && !elem.modelParsed && ( typeof from !== 'string' || elem.model.field.val === from  )  ) {
      field = elem.model.field.val.split('.')
      
      if( elem.model.field.val === from ) {

        // console.log('HERE ITS INTERESTING DO', elem.model.field.val , from )

      } else {
        a = util.path(obj,field,{},true)
        doItIgnoreFlags = true
      }

    } else {
      if(from && elem.model.field && elem.model.field.val !== from) {
        return void 0
      }
    }

    if(elem.model && elem.model.subscription ) {

      var subs = elem.model.subscription.raw
      if(subs === true) {
        if(field) {
          if(field.length>1) {
          a = util.path(obj,field,true,true)
          } else {
            obj[field[0]] = true
            a = true
          }
        }
      } else {
        var sub = elem.model.subscription.raw
        if( typeof sub === 'string' ) {
          var old = sub
          sub = {}
          sub[old] = true
        }
        util.merge(a,sub)
      }
    }

    for (var i in elem.model.flags) {
      store(a, elem.model.flags[i], i, val, from, elem )
    }
    
  }

  if( !elem.model || !elem.model.block || !elem.model.block.val ) {

    for (
      var children = elem.children
      , child
      , child$ = 0
      , children$len = children && children.length
      ; child$ < children$len
      ; child = child$++
    ) {
      child = children[child$]
      if ((!child.model || (!child.model.inherit || child.model.inherit.val!==false))
        && !child._col && !child.data || child._dfrom) { //dit kan beter!
        readModel(child, a || obj, val, from )
      //elem, obj, val, from , ignorefield, field
      }
    }
  }

  if(obj['__#__']) {
    // obj.$ = true
    // util.merge(obj, obj['__#__'])
    delete obj['__#__']
  }

  return elem.model && elem.model.block && elem.model.block.val==='all' ? void 0 : obj
}

util.define(element, 'getModel', function( val, from, ignorefield ) {

  var subscription = readModel( this, {}, val, from, ignorefield )

  // console.error('parsed subscription!', JSON.stringify(subscription, false, 2) )
  //waarom komt ie 3x extra?

  return !util.empty( subscription ) ? subscription : null
})
},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require('../../../object')
  , data = require('../../../data')
  , Value = require('../../../value')
  , util = require('../../../util')
  , vigour = require('../../../')
  , _networkdata = module.exports = exports = vigour.Networkdata = data.new({
      mixed: 4, //mischien niet mixed
      merge: true
    })
  , _sub = 'subscribe'
  , _unsub = 'un' + _sub
  , _listener = 'Listener'
  , _al = 'add' + _listener
  , _rl = 'remove' + _listener
  , _proto = object.prototype
  , _protoAddListener = _proto[_al]
  , _protoRemoveListener = _proto[_rl]
  , _checkSubscription = function( field, val ) {
      var a = this
      while (a && a.__t === 4) {
        if(a.__block) return
        a = a._val
      }
      // console.log(field, a)
      if((a instanceof _networkdata) && a[field]) a[field](val, this)
    }
  , V = require('../../../')

_networkdata.prototype._blacklist.push('_subs','_complete')
//'_' + _sub, '_' + _unsub, we dont use there now
// _subscribe(_sub);
// _subscribe(_unsub);


//TODO: fix mark!!!!!!!!!!! mark:true
util.define(_networkdata,
  'get', function( val, set, notself, stamp ) {
    
    // IM GETTING! ["users", "u_ba3215a1b1038a70", "mtvData", "NL", "nl", "shows"] undefined
    //obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i
    // var bla = (val instanceof Array) ? val : String(val).split('.')
    // console.log('IM GETTING!', bla, val, set, this, this.path)

    //TODO: Always give me the non-from is possible
    // console.warn('Get -- self is now on on defualt should become something different!')
    //obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self,
    //conditional self

    return this.path
      ( (val instanceof Array) ? val : String(val).split('.')
      , set !== void 0 ? set : {}
      , false
      , false
      , false
      , stamp || false //stampy
      , true
      , !notself
      )

  },
  // '_changevobj', function(val,stamp) {
  //   console.error(val,stamp)
  //   return _changevobj.apply(this,arguments)
  // },
  // '_hook', function(val, param) {
  //   for (var i in param) {
  //     this['_' + i] = param[i];
  //   }
  // }, //dont use this now so lets add when used
  _al, function( val ) {
    // console.log('LETS GO!', _sub, val, !!this[_sub])
    if(this[_sub]) this[_sub](val)
    _protoAddListener.apply( this, arguments )
  },
  _rl, function( val, mark ) {
    if (this._listeners && this[_unsub]) {
      // console.log('REMOVE _L'.red.inverse, mark)
      this[_unsub]( mark )
    }
    _protoRemoveListener.apply( this, arguments )
  }
);

//-------DATA---------
util.define(data, 
  _al, function(val) {
    // console.log('0--------->',val)
    if(!this.__block) _checkSubscription.call(this, _sub, val);
    _protoAddListener.apply(this, arguments);
  },
  _rl, function(val, mark) {
     // console.error('2.1 REMOVE _L', mark, val, _unsub)
    if(!this.__block) _checkSubscription.call(this, _unsub, mark);
    _protoRemoveListener.apply(this, arguments);
  }
);

//-------Value---------

// util.define(Value, //test is this impacts performance to much
//   _al, function(val) {
//     // console.log('0--------->',val)
//     if(!this.__block) _checkSubscription.call(this, _sub, val);
//     _protoAddListener.apply(this, arguments);
//   },
//   _rl, function(val, mark) {
//      // console.error('2.1 REMOVE _L', mark, val, _unsub)
//     if(!this.__block) _checkSubscription.call(this, _unsub, mark);
//     _protoRemoveListener.apply(this, arguments);
//   }
// );





},{"../../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js":[function(require,module,exports){
var util = require('../../util')
  , Value = require('../../value')
  , config = require('../../util/config')
  , process = require('../../value/flags/process')
  , raf = require('../../browser/animation/raf')
  , postpone = require('../../browser/events/util').postpone
  , ua = require('../../browser/ua')

Value.prototype._blacklist.push('_last')

module.exports = exports = new Value()
//TODO: .params /w listeners!

config.hashUrl = ua.device === 'tv' && ua.platform === 'lg' ? false :  config.hashUrl

// history.pushState({}, '','' )
// history.go(0)
// history.back()

var pstate = !config.hashUrl //= !window.DEBUG$ && window.history && window.history.pushState
  , cnt = 0
  , timedState
  , state = postpone ( pstate ? function(val) {
      //load current params as well
      //same goes for the other
      //we could add a delay here!
      href = window.location.href

      console.log(val,  val.replace(/ /g, '+').replace(/^#\//, '').toLowerCase())

      window.history.pushState( {}, val, val.replace(/ /g, '+').replace(/^#\//, '').toLowerCase() )
    } : function(val) {
      exports.block = true
      window.location.href = '#/' + val.replace(/ /g, '+').toLowerCase()
      exports.block = false
    } )
  , _set = Value.prototype._set
  , parse = function() {
      if (!pstate) 
      {
        var url = window.location.href.split('#')
        var params = ''
        if( url && url.length === 1 ) {
          params = query( url[0] )
          url[0] = url[0].replace(params, '')
          // window.location = '#/'+params
          // return = 'x'
        }
        // console.log( url, ( url.length > 1 ? url[1].replace(/\+/g, ' ') : ' ' ).slice(1), params )
        // +params
        return ( url.length > 1 ? url[1].replace(/\+/g, ' ') : ' ' ).slice(1)+params
      } else 
      {
        
        var url = window.location.href
        if( url ) {
          params = query( url )
          url = url.replace(params, '')
          // window.location = '#/'+params
          // return = 'x'
        }

        return String(window.location.href)
               .replace(String(window.location.origin) + '/', '')
               .replace(/^#\//, '')
               .replace(/\+/g, ' ')
               || ''
      }
    }
  , query = function( str ) {
      if(!str) str = parse() || ''
      var arr = str.split('?')
        , len = arr.length
      str = len > 1 && arr[ arr.length - 1 ] ? '?'+arr[ arr.length - 1 ] : ''
      return str
    }

exports.parse = parse

//TODO: back btn hijack (event hijack add random param)
//TODO: use raf for updates
exports.val = { 
  string: function() {
    var str = parse()
    return str.replace( query( str ), '' )
  },
  params: {
    val: function() { return query() },
    defer:function( update, args ) {

      this.clearCache() //maybe not?

      var val = this.val
        , params
        , nestedparams
        , c

      if( val && val!==this._last ) {
        this._last = val
        params = val.slice(1).split('&')
        nestedparams = {}
        for( var i in params ) {
          c = params[i].split('=')
          if( c.length>1 ) 
          {
            nestedparams[c[0]] = c[1]
          }
          else
          {
            console.error('url: no [key]=[value] format -- not implemented yet')
          }
        }
        this.val = nestedparams
      }
      raf(function() { update() })
    }
  },
  transform: function( v, cv ) {
    return cv
  },
  defer: function( update, args ) {
    if( args[1] && args[1][0] === 'u' ) 
    {
      this.clearCache()
      raf( function() {
        update()
      })
    } else 
    {
      this.clearCache()
      var a = ( typeof args[0] === 'string'  ? args[0] : args[0] && args[0].val || this.val )
      if(a) 
      {
        exports.blocks = cnt

        state( a + this.params.val )
      }
      return  true
      //TODO: update( true ) blocks all consecutive updates
    }
  }
}

function urlEvent(e) {
  var stamp

  if( !config.hashUrl || exports.blocks!==cnt ) 
  {
    cnt++
    stamp = 'u'+cnt
    exports.clearCache()
    exports.string.clearCache() //maybe not clear on string?
    // exports._update( parse(), 'url' )
    exports.string._update( exports.string.val , stamp )
    exports.params._update( exports.string.val, stamp )
    exports._update( exports.string.val, stamp )
    exports._lstamp = null

  } else {
    cnt++
  }
}

util.define( exports, 'update', function() {
  urlEvent()
})

util.define( exports.string, 'raw', {
  get:function() {
    return this.val.replace( / /g, '+' )
  }
})

if( config.hashUrl )
{
  window.onhashchange = urlEvent
}
else
{
  window.onpopstate = urlEvent
}
//TODO: add popstate


},{"../../browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js":[function(require,module,exports){
/*
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
/*
/*
  useragent sniffing is never used for feature detection, for a multi-screen app you do need information about the device also when running in the browser
  has fields V.ua.platform, device, browser and version. This implementation when compiled, is only 700 bytes
*/
var util = require('../util')
/**
 * test
 * search for regexps in the userAgent
 * fn is a on succes callback
 * check http://www.useragentstring.com/ to test for userAgents
 * @method
 */
, test = exports.test = function( _ua, fn ) {

  for
  ( var tests = util.arg( arguments, 1 )
      , i = tests.length - 1
      , query = tests[i][0]
    ; query !== true && !new RegExp( query ).test( _ua )
    ; query = tests[--i][0]
  )

  ;if( fn.slice || fn.call( this, query, tests[i] ) )
  {
    this[fn] = tests[i][1]
  }

}
, parse = exports.parse = function(_ua, obj) {

  if( !_ua )
  {
    obj = exports
    _ua = typeof navigator !== 'undefined'
        ? navigator.userAgent.toLowerCase()
        : 'no navigator'
  }

  _ua = _ua.toLowerCase()

  if( !obj ) obj = {}

  // _ua = 'webos; linux - large screen'

  var _ff = 'firefox'
    , _android = 'android'
    , _mobile = '.+mobile'
    , _webkit = 'webkit'
    , _ps = 'playstation'
    , _xbox = 'xbox'
    , _linux = 'linux'
    , _castDetect = 'crkey'
    , _chromecast = 'chromecast'
    , _tablet = 'tablet'
    , _windows = 'windows'
    , _phone = 'phone'
    , _iphoneVersion

  test.call
  ( obj
  , _ua
  , function( query, arr ) {

      obj.browser = arr[2] || query

      var _v = _ua.match
      ( new RegExp
        ( '((([\\/ ]version|'
        + arr[0]
        + '(?!.+version))[\/ ])| rv:)([0-9]{1,4}\\.[0-9]{0,2})'
        )
      )

      obj.version = _v ? Number( _v[4] ) : 0
      obj.prefix = arr[1]
      //TODO: add prefix for opera v>12.15;
      //TODO: windows check for ie 11 may be too general;
    }
  , [ true, _webkit ]
  , [ '\\(windows', 'ms', 'ie' ]
  , [ 'safari', _webkit ]
  , [ _ff, 'Moz' ]
  , [ 'opera', 'O' ]
  , [ 'msie', 'ms', 'ie' ]
  , [ 'chrome|crios\/', _webkit, 'chrome' ]
  )

  /**
  * platform detection
  */
  test.call
  ( obj
  , _ua
  , 'platform'
  , [ true, _windows ]
  , [ _linux, _linux ]
  , [ 'lg.{0,3}netcast', 'lg' ] //TODO:propably need to add more!
  , [ _ff + _mobile, _ff ]
  , [ 'mac os x', 'mac' ]
  , [ 'iphone|ipod|ipad', 'ios' ]
  , [ _xbox, _xbox ]
  , [ _ps, _ps ]
  , [ _android, _android ]
  , [ _windows, _windows ]
  , [ _castDetect, _chromecast ]
  , [ 'smart-tv;|;samsung;smarttv', 'samsung' ] //SmartTV2013
  )

  /**
  * device detection
  */
  test.call
  ( obj
  , _ua
  , 'device'
  , [ true, 'desktop' ]
  , [ _windows + '.+touch|ipad|' + _android,  _tablet ]
  , [ 'iphone|(' + _android + _mobile + ')|(' + _ff + _mobile + ')|' + _windows + ' phone|iemobile'
    , _phone
    ]
  , [ _xbox + '|' + _ps, 'console' ]
  , [ 'tv|smarttv|googletv|appletv|hbbtv|pov_tv|netcast.tv|webos.+large', 'tv' ]
  , [ _castDetect, _chromecast ]
  , [ 'amazon-fireos', _tablet ]
  )

  //TODO: amazon firetv and phone
    // alert(window.innerWidth*window.innerHeight +  '  '+ 414 * 736)
  
  //414  736
  var iphone6plus = 414 * 736
  if
  ( obj.platform === _android
    && !util.isNode
    && obj.device === _phone
    && window.innerWidth*window.innerHeight > iphone6plus
    // && ~_ua.indexOf('crosswalk')
  )
  {
    obj.device = 'tablet'
  }

  return obj
}

if( !util.isNode ) 
{ 
  parse()
  //TODO: this is very ugly, try to find a better solution
  if( window.__ua__ ) 
  {
    for( var field in window.__ua__ )
    {
      exports[field] = window.__ua__[field]
    }
  }
}

/**
 * prop
 * re-writes js properties to their css counterpart
 * e.g. webkitTransform --> -webkit-transform
 * now its commented since its not nessecary yet
 * @method
 */
// this.prop = function(str) {
//  return str.replace(this.prefix,'-'+this.prefix+'-').toLowerCase();
// }

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var  data = require('./')
  , base = require('../base')
  , util = require('../util')
  , flags = require('../value/flags/data')
  , vObject = require('../object')

exports.extend = util.extend( function(base, extensions, modelblacklist) {

  // var _blacklist = util.add(['flags', 'ref', 'parse', 'parsing'], modelblacklist),
    var _compare = util.compareArrays,
    methods = {
      _dUpdate: function(obj, val, stamp, from, remove, added, oldval, instances, argx1, argx2 ) {
        // if(window.here) console.log('X',stamp)
        if (this.model) {
          //$ndata
          //TODO: very dirty fix get rid of this!
          if( obj === '$ndata' ){
            val = from
            stamp = remove
            from = added
            remove = oldval
            added = instances
            oldval = argx1
            instances = argx2
            // console.log('!@#!@#!@#!@#@!#!@#!@#!@#'.red.inverse)
          }

          // var non = 0
          //   , cnt = 0
          // for( var i in arguments ) 
          // {
          //   cnt++
          //   if(!arguments[i]) {
          //     non++
          //   }
          //   console.log( arguments[i] )
          // }
          // if(non === cnt) {
          //   alert('no args')
          //   return true
          // }

          if (!this._d && this.parent) {
            var p = this.parent;
            while (!this._d && p) {
              if (p._d) {
                // console.error('SET DATA')
                this._dSet(p._d, true);
              } else {
                p = p.parent;
              }
            }
          }
          var t = this,
            model = t.model,
            f = model.flags,

            // f = model ? model.flags : false be carefull with updates in values that have data

            path = t._d && t._d._path || [],
            name = (from || (from = (t._d && t._d._updateOrigin)) && !(from === t._d && (from = false))) && from.updatePath,
            fromPath = from && from._path,
            method = function(i, field) {

              var select, pass, fr, lfield;
              // if( field._flag[2].__t) {
              //multiple flags!
                // console.log('FLAG'.inverse, name, field._flag)
              // }

              if(!field._flag.data) {
                console.error('NO DATA FLAG', name, field._flag, val, obj, remove, added, oldval)
                return
              }
              field = field._flag.data[2];

               // console.log('DATA UPDATE'.magenta.inverse,
               //      'obj:', obj
               //    , 'val:', val
               //    , 'stamp:', stamp
               //    , 'from:', from
               //    , 'remove:', remove
               //    , 'added:', added
               //    , 'field:', field
               //  )
              // var test = (i==='text' && field === 'real.duration')
              // if(test) console.log(field,i)
              // if(test) pass = true

              if (i === 'collection' && t._colFilter) return
              //if not own colfilter --> handle yourself!;
              // if data has changed change colfilter adn send update
              //be carefull /w changes!; too crude

              if (field === true) {
                // console.log('PASS'.inverse,name)
                pass = true;
              } else if (field.pop) {
                // console.log(name,'???')

                // console.log('--->',field, field.pop)

                field = field.concat();

                for (var j = field.length - 1; j >= 0; j--) {
                  if (!lfield !== void 0) {
                    select = util.get(t._d, field[j]);
                    if (select !== void 0) {
                      lfield = true;
                      // break;
                    }
                  }
                  field[j] = field[j].split('.');
                }
              } else {

                // console.log('DO DO!'.inverse,name, t._d && t._d._updateOrigin)

                // console.log(name, path, select, obj, val, stamp, from, remove, added, oldval, instances)

                field = field.split('.')

                select = util.get(t._d, field)

                if(!select && t._d && t._d.from && field ) {
                  // console.log('NO SELECT'.red.inverse, t._d )
                  select = util.get(t._d.from, field)
                  // if(select) {
                  //   // console.log('FOUND SELECT'.green.inverse, select)
                  // }
                } 

                if(select && from && from.__t === 4) lfield = true //test dit of het alles slow maakt

                // if(test&&select) console.log(select._val)
              }

              if (!pass && from) {

                // console.log('testing....?', name, from, select, lfield)
                // if(test) console.log(name, select, lfield, from);

                fr = true;
                var fromFrom

                if ( from === select || ( fromFrom = from.from ) === select ) {
                  pass = true;
                } else {
                  if (t._d._filter && select && select._ancestor(from)) {
                    pass = true;
                    //field ook voor arrays!;
                  } else if (lfield) {

                    // console.log('got lfield!!!!')

                    for (var n = 0; n < field.length; n++) {
                      if (name && _compare(name, field[n]) || field[n][0] === name[0] && util.get(val, field[n].concat().shift())) 
                      {
                        fr = false;
                        break;
                      } 
                      else if ((_compare(path.concat(field[n]), fromPath) || _compare(field[n], fromPath))) 
                      {
                        fr = false;
                        break;
                      } 
                      else {

                        // console.log('HERE?'.cyan.inverse, '\n\n\n', select.from.raw, 'val:'
                        //   , val, 'field:', field, 'fn', field[n], 'n:', n, 'check field:', val && val[field[n]], 'ref:', val.from)
                        // console.log('coming trugh', select && from._val !== null && val, field[n]
                        //   , select && from._val !== null && val && ( val[field[n]] || val.__t === 4 && val.from[field[n]] ) )
                        //TODO: need to add more gaurding for val.$path check if this is cloud and ref

                        if(select && from._val !== null && val && (val[field[n]] || val.$path || val.__t === 4) && (select._ancestor(from) || select.from._ancestor( fromFrom )  ))  //
                        {
                          // console.log(val, field);
                          pass = true;
                          break;
                        }
                      }
                    }
                  } else {

                    // console.log( '---', select, val, field, from, 'fromPath:' , fromPath )

                    if(val===null) {
                      // if(DEBUG$) t._d.DEBUG$log('data/base ---> ERROR val is null  --->'+t._d._removed )
                    } else if(val === void 0) {
                      // TODO: handle this
                      // console.log('\n\n\n undefined what to do now?', arguments,this)
                      // debugger
                      // pass = true
                      // pass = true
                    } else if (name && _compare(name, field) || field[0] === name && name[0] && util.get(val, field.concat().shift())) {
                      fr = false;
                    } else if (path && (_compare(path.concat(field), fromPath) || _compare(field, fromPath))) {
                      fr = false;
                    } else if (select && (val[field[0]]) && select._ancestor && select._ancestor(from)) {
                      // console.log(val, field);
                      pass = true
                    } else if( t.__checkKeys__ ) {
                      // console.log('lets checkj the keys!')
                      // console.log( field, name, val, path, select, val[field[0]], from, this )
                      for( var key$ in t.__checkKeys__ ) {
                        if( field === t.__checkKeys__[key$] || field[0] === t.__checkKeys__[key$] ) {
                          // console.log('maybe??!!@#!@', i, t.__checkKeys__[key$])
                          pass = true
                        }
                      }

                    }
                    // console.log(val, field[0], from);
                  }
                }
              }
              // pass = true;
              // console.log('PASS>>>>>>>>>?'.magenta.inverse, pass ? 'OK!'.green.inverse : 'NO!'.red.inverse  
              //   , 'val:'.blue, val
              //   , 'obj._path:'.blue, obj && obj._path
              //   , 'field:'.blue, field
              //   , 'fromPath:'.blue, fromPath
              //   , 'from:'.blue, from
              //   , 'select'.blue, select
              //   )

              // if(! pass && )

              // pass = true

              //|| remove 

              if (pass || remove || (instances || remove || select !== void 0) && ( !fr || remove === 1)) {

                // console.log('updating!'.cyan.inverse, i, val, instances, remove, select, fr, from)
                // debugger
                //stamp meegeven????
                // console.log( 'FROM!!!!!'.green.inverse, from )
                // console.l
                t[i]._update(val, false, from, remove, added, oldval, !instances, t);
                return true;
              }
            };
          //----------------------------------------------------
            //add advanced models (like on website)
            //not tested and still pretty broken
           var parser = function() {
            if (this._d) {
              var t = this, a
              //if added or first run
              t.model.val //set _caller
              // if (model.field) console.log('????', this.field, model.field)

              if (model.field) a = util.get(t._d, model.field.val)
              if (model._val) a = model._val.call(t, a || t._d) || a
              if (a && t._d !== a) {
                model.parsing = true
                if(model.field) this.modelParsed = model.field.val
                this._dSet(a)
                model.parsing = false
              }
            }
          }
          parser.call(t)
          if (instances) t.eachInstance(parser, 'model')
          //----------------------------------------------------

          //----------------------------------------------------
          if (f && (instances || t._d)) {
            for (var i in f) {
              if (!f[i].__t) {
                for (var j = 0, l = f[i].length; j < l; j++) {
                  if (method(i, f[i][j])) {
                    break;
                  }
                }
              } else {
                method(i, f[i]);
              }
            }
          }
          //----------------------------------------------------

         if(this.model.complete) this.model.complete._val.call(this,data)

        }
      },
      _dSet: function(val, dfrom) {


        // if(val) {
        //   console.log('_Dset'.cyan.inverse, val._path, dfrom)
        // }
        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        if(this.model._flag && this.model._flag.defer  && !this.__processing) {
          this.__pFlag = [ val, dfrom ]
          return
        }

        //dfrom moet niet nog een subscribe doen! -- als het goed is is zn parent al subscribed

        if (this._d && this._d.__t) this._d.removeListener(true, this)
        this._d = val
        if (dfrom) this._dfrom = true
        this._dListen()



        return val;
      },
      _dListen: function() {

          // console.log('HEEEEEE', this.model)

        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        //hier gaan we s fftjes werken met each

        // this._dfrom = true;
        var _this

        if (this.model && this._d && this._d instanceof vObject) 
        { //this model maybe not nessecary?

          // console.log('----->'.cyan.inverse, this._d )

          this._d.addListener([this._dUpdate, this])

          _this = this
          
          //hier filteren op cloudData --- ook werken vanuit remove!!!
            //never do for cloud data
         
          if( !this._d.cloud )
          {
            this._d.each(
              function() { 
                _this.__checkKeys__ = true

                if(this.__t === 4 ) this.addListener([ _this._dUpdate, _this, '$ndata', this ]) 
              }
            )
          }
          //eventueel .val gebruiken voor Values *awesjume!
          //eventueel hier dingen adden aan model

        } 
        else if( this.model && this._d ) 
        {
          for( var key in this._d ) 
          {
            if(!this.__checkKeys__ || this.__checkKeys__ === true) this.__checkKeys__ = []
            if( this._d[key] instanceof vObject )
            {
              if(!this.__checkKeys__.push) {
                console.error('xxxxxx', this, this.__checkKeys__, key, this._d)
                debugger
              }
              this.__checkKeys__.push( key )
              this._d[key].addListener([ this._dUpdate, this, '$ndata', key ])
            }
          }

        }
      },
      updateData: function(instances) {

        if(this.model._flag && this.model._flag.defer && !this.__processing) {
          // console.log('oo2')
          this.__pFlagU = [ instances ]
          this.model._update()
          return
        }
        // console.log('!DOIT updateData'.cyan.inverse)

        this._dUpdate(this._d, void 0, false, false, false, false, false, instances)
      }
    },
    extend = function(i) {
      base.extend({
        name: i,
        type: false,
        value: (extensions && extensions[i]) ? function() {
          methods[i].apply(this, arguments);
          extensions[i].apply(this, arguments);
        } : methods[i]
      });
    };
  for (var i in methods) {
    extend(i)
  }
  base.extend({
    name: 'model',
    cache: false,
    set: function(val) {

      if(this.__pFlag || this.__pFlagU) {
        /*
        TODO: test defer better!!!
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        */
        this.__processing = true
        this.model.parsing = false
        if(this.__pFlag) {
          this._dSet.apply(this,this.__pFlag)
        }
        //subscribe helemaal fucked met field erbij
        if(this.__pFlagU) {
          this.updateData.apply(this,this.__pFlagU)
        }
        this.__pFlagU = null
        this.__pFlag = null
        this.__processing = null
      }

      if(val.field && val.field.val !== this.modelParsed) {
        var a = this.modelParsed && this.modelParsed.split('.')
          , parent
        this.modelParsed = null
        if(this._d) {
          parent = this._d
          if(a) {
            for(var i = a.length-1; i >=0 ; i--) {
              parent = parent._parent
            }
            if(parent) {
              this._dSet(parent)
              this.updateData(true)
            }
          } else {
            this.updateData(true)
          }
        }
        this.modelParsed = null
      }
    },
    remove: function() {
      if( this._d )
      {
        if ( this._d.__t )  
        {
          this._d.removeListener( void 0, this )

          if( !this._d.cloud )
          {
            var _this = this
            this._d.each(
              function() { 
                // _this.__checkKeys__ = true
                if(this.__t === 4 ) this.removeListener( void 0, _this ) 
              }
            )
          }

        }
        else if( this.__checkKeys__) 
        {
          for( var key$ in this.__checkKeys__ ) 
          {
            if( this._d[this.__checkKeys__[key$]] instanceof vObject )
            {
              this._d[this.__checkKeys__[key$]].removeListener( void 0, this )
            }
          }
        }
      }
    }
    // parent: function(parent) {
    //   if( parent.data && (!parent.parent || parent.parent.data!==parent.data) ) {

    //     console.error('WTF?')

    //     this.data = parent.data
    //   }
    // }
  }, {
    name: 'data',
    type: false,
    set: function(val) {
        // console.log('?',val)
      if( this._d === val ) return

      // if(!this.model) this.model = {} //dit met het nooit setten van fmodel scheel op show al 3/9 subscriptions
      //nu nog shared subs maken -- 'shows' (ook meteen process) en dan word thet als het goed is nog een stuk minder
    
      // this.model = {} //pas op met deze
      // console.log('?2')

      if( this.model._flag && this.model._flag.defer ) {
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        // console.log('!@#!@#!@# OOOO'.red)
        return
      }

      // console.error('!!!!!MODEL -- dit moet zoveel mogelijk gereduced', this.model)

      this.model.parsing = false
      this._dSet(val)

      //subscribe helemaal fucked met field erbij
      this.updateData(true)

    },
    get: function() {
      return this._d
    }
  })
})
},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value/flags/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/data.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/conditions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var data = require('./'),
  cnt = 0,
  handleTest = module.exports = function(test, subsObj) {
    // console.error('handleTest!', test)
    if (test instanceof Object) {
      var keys = Object.keys(test);
      if (keys.length === 1) {
        var key = keys[0]
          , valcheck = handleField(key, test[key], subsObj)
          
        return subsObj._check = function(doc){
          // console.log('TESTING', test, doc && doc.raw)
          // console.log('checking for key', key)
          var val = getValue(doc)
          return valcheck(val)
        }
      } else {
        var list = [],
          key;
        for (var k = 0, l = keys.length; k < l; k++) {
          key = keys[k];
          list.push(handleField(key, test[key], subsObj));
        }
        return subsObj._check = makeAND(list);
      }
    } else {
      return subsObj._check = function(doc) {
        return getValue(doc) === test;
      }
    }
  }

function handleField(key, value, subsObj) {
  // console.warn('handleField [', key, '] value', value)
  var check;
  switch (key) {
    case '$not':
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj);
        check = function(doc) {
          return follow(doc) === false;
        };
      } else {
        check = function(doc) {
          return doc !== value;
        };
      }
      break;
    case '$ne':
      check = function(doc) {
        return doc !== value;
      };
      break;
    case '$and':
      var list = makeList(value, subsObj);
      check = makeAND(list);
      break;
    case '$nand':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc) === false) return true;
        }
        return false;
      };
      break;
    case '$or':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return true;
        }
        return false;
      };
      break;
    case '$nor':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return false;
        }
        return true;
      };
      break;
    case '$every':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (!follow(this)) return !(result = false);
          });
          return result;
        } else {
          return false;
        }
      };
      break;
    case '$nevery':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = false;
          doc.each(function() {
            if (!follow(this)) return result = true;
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$':
    case '$some':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj.$);
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (follow(this)) return found = true;
            });
            return found || false;
          }
          return false;
        };
      } else {
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (this === value) return found = true;
            });
            return found || false;
          }
          return false;
        };
        subsObj.$._check = function(doc) {
          return doc === value;
        };
      }
      break;
    case '$nsome':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (follow(this)) return !(result = false);
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$lt':
      check = function(doc) {
        // console.log('burk lt', doc, value)
        return doc < value;
      };
      break;
    case '$lte':
      check = function(doc) {
        return doc <= value;
      };
      break;
    case '$gt':
      check = function(doc) {
        return doc > value;
      };
      break;
    case '$gte':
      check = function(doc) {
        return doc >= value;
      };
      break;
    case '$contains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return regex.test(doc);
      };
      break;
    case '$ncontains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return !regex.test(doc);
      };
      break;
    case '$containsall':
      break;
    case '$ncontainsall':
      break;
    case '$has':
      check = function(doc) {
        return doc && doc[value] !== void 0;
      };
      break;
    case '$nhas':
      check = function(doc) {
        return !doc || doc[value] === void 0;
      };
      break;
    case '$exists':
      check = function(doc) {
        return (doc !== void 0 && doc !== null) === value;
      };
      break;
    case '$in':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return true;
        }
        return false;
      };
      break;
    case '$nin':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return false;
        }
        return true;
      };
      break;
    case '$regex':
      check = function(doc) {
        return value.test(doc);
      }
      break;
    default:
      if (value instanceof Object) {
        var dsubsObj = subsObj[key];

        if (dsubsObj) {
          // console.log('already made that dsubsObj with key', key);
          // dsubsObj._up = subsObj
        } else {
          subsObj.set(key, {});
          dsubsObj = subsObj[key];
        }
        var follow = handleTest(value, dsubsObj);

        check = function(doc) {
          // console.log('TESTING: check OBJECT', doc && doc.raw || doc, 'for field', key)
          doc = getField(doc, key)

          // console.log('wups', doc && doc.raw || doc)
          return follow(doc);
        };
      } else {
        check = function(doc) {
          doc = getField(doc, key)
          
          // doc = getValue(doc)
          // console.log('TESTING: check VALUE', doc && doc.raw || doc, value, doc === value)
          return doc === value;
        };
        subsObj.set(key, {});
        subsObj[key]._check = check
        // subsObj[key] = {
        //   _up: subsObj,
        //   _check: function(doc) {
        //     return doc === value;
        //   }
        // };
      }

  }
  return subsObj ? subsObj._check = check : check;
}

function makeList(arr, subsObj) {
  var list = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    list.push(handleTest(arr[i], subsObj));
  }
  return list;
}

function makeAND(list, subsObj) {
  return function(doc) {
    var val = getValue(doc);
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i](val) === false) return false;
    }
    return true;
  };
}

function getValue(thing){
  var val = thing && thing.from && thing.from.val
  return val !== void 0 ? val : thing
  
}
function getField(thing, field){
  // console.error('getField field', field, 'from', thing && thing.raw || thing)
  thing = getValue(thing)
  return thing ? getValue(thing[field]) : void 0
}
},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('vigour-js'),
  object = require('vigour-js/object'),
  util = require('vigour-js/util');

module.exports = exports = V.Data = object.new();
exports.prototype._blacklist.push('__sub','__block');
util.define(exports, '_hook', function(val, obj) {
  if (obj.subscription) {
    this.__sub = obj.subscription;
    delete obj.subscription;
  }
  if(obj.block) {
    this.__block = true
    delete obj.block
  }
});


},{"vigour-js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var conditions = require('./conditions')
  , utilHash = require('../util/hash')
  , VObject = require('../object')
  , util = require('../util')

/**
 * Selection
 * Class extention for selection / filtering functionality
 * @Class
 */

exports.SubsObj = VObject.new()
exports.SubsObj.prototype._blacklist.push( '_root'
                                         , '_check'
                                         , '_sort'
                                         , '_uid'
                                         )

exports.extend = util.extend(function(base){

  base.prototype._blacklist.push( '_filter'
                                , '_uid'
                                , '_hash'
                                , '_indexCache'
                                , '_subscnt'
                                )

  var _update = base.prototype._update
    , _hook = base.prototype._hook
    , _remove = base.prototype.remove

  util.define( base
    , 'remove', function() {
        var l
        if(this._filter && (l = this.length)){
          for(var i = 0; i < l; i++)
            delete this[i]
        }
        return _remove.apply(this, arguments)
      }
    , 'filter', {
        get: function() {
          return this._filter
        },
        set: function(val) {
          // console.log('new filter \n from --->', this._filter, '\n to ---->'
          //            , val
          //            )
          this._filter = val //moet ook werken als data nog geen selection is
          this._build(undefined, true)
          _update.call( this, void 0, this.stamp(), void 0, false
                      , false, void 0
                      )
        }
      }
    , '_hook', function(val, filter) {
        if (_hook) {
          _hook.call(this, val, filter)
        }
        if (!util.empty(filter) && val) {
          var selection = this
          selection._subscnt = 0
          selection._filter = filter

          selection._hash = utilHash(val._path + JSON.stringify(
            [ filter.condition
            , filter.range
            , filter.sort
            ])
          )
          //!only nessecary serverside!
          if (!selection._uid) selection._uid = selection._hash
        };
      }
    , '_build', function(val, noupdate) {
        var selection = this
        
        if (!val) val = selection._val
        if(!val) return
        if (selection.length) selection._clear() 

        var list = []
          , itemsHandler = this._itemsHandler
          , filter = selection._filter
          , subsObj = filter.subsObj || new exports.SubsObj({}, selection)
          , stamp = this.stamp()
          , sort, item

        if (val.__t === 4 && !val._filter) {
          val = val.from;
        }

        if (filter.sort) {
          if (typeof filter.sort === 'string') {
            filter.sort = {
              field: filter.sort
            }
          }
          sort = filter.sort
          if (!sort.fn) {
            if (!sort.type) sort.type = 'string'
            sort.fn = sortMakers[sort.type](sort)
          }
          subsObj.path(sort.field.split('.'), {}).set('_sort', true)
        }
        // console.log('building?!')
        if (filter.condition) {
          // console.log('found condition', filter.condition)
          var pcnt = 0
            , rcnt = 0
          var check = filter.check 
                 || ( filter.check = conditions( filter.condition
                                               , subsObj
                                               )
                    )
          filter.subsObj = subsObj
          val.each(function(f) {
            item = this
            if (itemsHandler) itemsHandler(item, subsObj, selection)
            if (check(item)) {
              pcnt++
              list.push(item)
            } else if (selection._has(item) !== void 0) {
              // console.log('-------- > removed from selection by condition:'
              //             , item.raw
              //             )
              unstoreIndex(item, selection)
              if(!noupdate){
                _update.call(selection, item, stamp, selection, item, false, null)
              }
              rcnt++
            } else { 
              rcnt++
            }
          })
          // console.log('ran condition: passed:', pcnt, 'rejects:', rcnt)
        } else {
          val.each(function() {
            if (itemsHandler) itemsHandler(this, subsObj, selection)
            list.push(this)
          })
        }

        filter.subsObj = subsObj

        if (sort && list.length > 1) {
          list.sort(filter.sort.fn)
        }

        var i, item

        var range = filter.range
        if (range) {
          if (!(range instanceof Array)) {
            range = filter.range = [0, filter.range]
          }
          if (list.length) {
            var newlist = list.splice(range[0], range[1])
            for (i = list.length; item = list[--i];) {
              if(selection._has(item) !== void 0){
                unstoreIndex(item, selection)
                // if(!noupdate){
                //   _update.call(selection, item, stamp, selection, item, false
                //               , null
                //               )
                // }
                
              }
            }
            list = newlist
          }
        }

        for (var i = list.length, item; item = list[--i];) {
          selection[i] = item
          var isnew = selection._has(item) === void 0
          storeIndex(item, selection, i)
          // if (isnew) {
          //   if(!noupdate){
          //     console.log('doing update wickeds')
          //     _update.call(selection, item, stamp, selection, false, item, null)  
          //   }
          // }
        }
        selection.length = list.length
      }
    , '_update', function(val, stamp, from, remove, added, oldval) {

        if (this._filter) {
           // if(window.here) console.log('hups _update on selection!')

          var selection = this
            , upath = selection.updatePath

          if (upath[0] !== void 0) {
            var shortpath = upath.length === 1
              , itemremove = shortpath && remove
              , item = itemremove ? selection._lfrom : selection.val[upath[0]]
              , relevant

            if (selection._val._filter) {
              if (selection._val._has(item) === void 0) {
                if (selection._has(item) !== void 0) {
                  selection._checkItem(item, false, val, stamp)
                }
                return
              }
            }
            var hint = itemremove ? false : (shortpath && added) ? void 0 : upath

            if (selection._checkItem(item, hint, val, stamp) === true) {
              return _update.apply(selection, arguments) 
            }
          } else {
            // console.log('hit on selection itself?!')
            if (!from) {
              // console.log('\n>>>>>> hit on selection itself (V.Data)')
              if (remove) {
                if (selection.length) selection._clear()              
              }else{
                selection._build()
              }
            }
            return _update.apply(this, arguments)
          }
        } else {
           // if(window.here) console.log('hups _update on selection!',this)
           // console.log('SELECT', this, arguments, this._path)
          return _update.apply(this, arguments)
        }
      }
    , '_has', function(item) {
        var indexCache = item._indexCache
          , uid = this._uid
          , ic

        if (indexCache && uid && (ic = indexCache[uid])) {
          return ic[0]
        }
      }
    , '_clear', function() {
        var self = this
        self.each(function(f) {
          self[f] = void 0
          delete self[f]
        })
        self.length = 0
      }
    , '_checkItem', function(item, hint, val, stamp) {
        if(!item) { return }
        // console.log('_checkItem!', item.raw, hint)
        var selection = this
          , from = item
          , filter = selection._filter
          , sort = filter.sort
          , range = filter.range
          , ranged = range && !(  range[0] === 0 
                               && range[1] >= selection._val.length 
                               || selection.length < range[1] - range[0]
                               )
          , removed = hint === false || item._removed
          , added, index, isin
          , result = isin = (index = selection._has(item)) !== void 0

        var check = filter.check
          , pass = removed 
                   ? false 
                   : (!ranged && hint === 1) 
                     ? isin 
                     : !check || check(item)

        // console.log('================ checkitem in', selection._path)
        // console.log('itemwex', item._val && item._val.raw)
        // console.log('isin', isin, 'pass', pass, 'result', result)
        // console.log('---------- checked item', pass)
        // console.log('removed?', removed)
        // console.log('ranged? (pass == already in)', (!ranged && hint === 1), isin)
        // console.log('ok time for checking', check)
        // console.log('conditions', filter.condition)
        // console.log('check?', check && check(item))
        // console.log('----------')
        
        if (isin !== pass) {
          if (isin) {
            result = 1
            unstoreIndex(item, selection)
            removed = item
            var mark
            while (mark = selection[++index]) {
              selection[index - 1] = mark
              storeIndex(mark, selection, index - 1)
            }

            var end = index - 1
            selection[end] = null
            delete selection[end]

            var replacement
            if (ranged) {
              if (sort) {
                selection._val.each(function() {
                  if (  selection._has(this) === void 0 
                     && (!selection[end] || sort.fn(this, selection[end]) < 0) 
                     && (!check || check(this))
                     ) {
                    replacement = selection[end] = this
                  }
                })
              } else {
                selection._val.each(function() {
                  if ( selection._has(this) === void 0 
                     && (!check || check(this))
                     ) {
                    return replacement = selection[end] = this
                  }
                })
              }
            }
            if (!replacement) {
              selection.length--
            } else {
              storeIndex(replacement, selection, index - 1)
              added = replacement
            }
          } else {
            var newindex
            if (sort) {
              var sortfn = sort.fn
              if (selection.length) {
                selection.each(function(f) {
                  if (sortfn(item, this) < 0) {
                    return newindex = f
                  }
                })
              }
              if (newindex !== void 0) {
                result = 1
                newindex = Number(newindex)
                storeIndex(item, selection, newindex)
                added = item
                if (ranged) {
                  removed = selection[selection.length - 1]
                  unstoreIndex(removed, selection)
                } else {
                  this.length++
                }
                var index = selection.length - 2
                while (index >= newindex) {
                  storeIndex(selection[index], selection, index + 1)
                  selection[index + 1] = selection[index--]
                }
                selection[newindex] = item
              } else if (!ranged) {
                result = 1
                newindex = selection.length++
                selection[newindex] = item
                storeIndex(item, selection, newindex)
                added = item
              }
            } else if (!ranged) {
              result = 1
              newindex = selection.length++
              selection[newindex] = item
              storeIndex(item, selection, newindex)
              added = item
            }
          }
        } else if (isin && sort) {
                      console.log('???', sort, sort.field, hint)

          // console.log('isin + sort! resort?')
          if (hint && hint.length && sort.field) {
            if (~sort.field.indexOf('.')) {
              var sortpath = sort.field.split('.')
              if (!util.compareArrays(hint.slice(1), sortpath)) {
                return result
              }
            } else {
              if (hint[1] !== sort.field) return result
            }
          }

          console.log('?')

          var newindex
          selection.each(function(f) {
            if (f != index) {
              var s = sort.fn(item, this)
              if (s === -1) {
                if (f == index + 1) return true
                newindex = f < index ? f : f - 1
                return true
              } else if (f >= index + 1 && s === 0) {
                return true
              } else if (f > index) {
                newindex = f
              }
            }
          });
          // console.log('newindex', newindex)
          if (newindex !== void 0) {
            result = 1
            var tmp
            if (index > newindex) {
              while (index > newindex) {
                tmp = selection[index] = selection[--index]
                if (tmp) storeIndex(tmp, selection, index + 1)
              }
            } else {
              while (index < newindex) {
                tmp = selection[index] = selection[++index]
                if (tmp) storeIndex(tmp, selection, index - 1)
              }
            }
            selection[newindex] = item
          }

          var end = selection.length - 1

          if (  ranged 
             && (newindex == end || newindex === void 0 
             && index == end)
             ) {
            var replaced
            selection._val.each(function() {
              if (  selection._has(this) === void 0 
                 && sort.fn(this, item) === -1 
                 && (!check || check(this))
                 ) {
                if (!replaced) replaced = item
                selection[end] = item = this
              }
            })
            storeIndex(item, selection, end)
            if (replaced) {
              unstoreIndex(replaced, selection)
              removed = replaced
              added = item
              result = 1
            }
          } else if (newindex !== void 0) {
            storeIndex(item, selection, Number(newindex))
          }

        }
        if (result === 1) {
          // console.log('update from _checkItem!')
          selection.__update(val, stamp, from, removed, added)
        }
        return result
      }
    )

})

var storeIndex = exports.storeIndex = function(item, selection, index) {
  // console.log('storeIndex! item', item._name, '@', index)
  var indexCache = item._indexCache
    , ic
  if (indexCache) {
    ic = indexCache[selection._uid]
    if (ic) {
      ic[1] = ic[0]
      ic[0] = index
    } else {
      indexCache[selection._uid] = [index]
    }
  } else {
    item._indexCache = {}
    item._indexCache[selection._uid] = [index]
  }
}

var unstoreIndex = exports.unstoreIndex = function(item, selection) {
  var indexCache = item._indexCache
  if (indexCache) {
    var ic = indexCache[selection._uid]
    ic[1] = ic[0]
    ic[0] = void 0
  }
}

var sortMakers = {
  number: function(sort) {
    var field = sort.field
    return function(a, b) {
      var va = a[field] && a[field].val
        , vb = b[field] && b[field].val
      if (va === void 0 || vb === void 0) {
        return va === vb 
               ? 0 
               : va === void 0 
                 ? 1 
                 : -1
      }
      return sort.order 
             ? (va - vb) * -1 
             : va - vb
    }
  },
  string: function(sort) {
    var field = sort.field
    if (~field.indexOf('.')) {
      var path = field.split('.')
      return function(a, b) {
        a = getDotFieldVal(a, path)
        b = getDotFieldVal(b, path)
        if (a === void 0 || b === void 0) {
          return a === b 
                 ? 0 
                 : a === void 0 
                   ? 1 
                   : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    } else {
      return function(a, b) {
        a = getFieldVal(a, field)
        b = getFieldVal(b, field)
        var weakA = a === void 0 || a === null
          , weakB = b === void 0 || b === null
        if (weakA || weakB) {
          return a === b ? 0 : weakA ? 1 : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    }
  }
}

function getFieldVal(obj, field) {
  var v = obj.val
  return v && v[field] && v[field].val
}

function getDotFieldVal(obj, field) {
  var v = obj.path(field)
  return v && v.val
}

function putSort(path) {
  var obj = part = {}
  for (var i = 0, l = path.length; i < l; i++) {
    part = part[path[i]] = {
      _up: part
    }
  }
  part._sort = true
  return obj
}

},{"../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","./conditions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/conditions.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js":[function(require,module,exports){
//V only used as a reference now...

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/colors/colors.js":[function(require,module,exports){
/*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var isHeadless = false;

if (typeof module !== 'undefined') {
  isHeadless = true;
}

if (!isHeadless) {
  var exports = {};
  var module = {};
  var colors = exports;
  exports.mode = "browser";
} else {
  exports.mode = "console";
}

//
// Prototypes the string object to have additional method calls that add terminal colors
//
var addProperty = function (color, func) {
  exports[color] = function (str) {
    return func.apply(str);
  };
  String.prototype.__defineGetter__(color, func);
};

function stylize(str, style) {

  var styles;

  if (exports.mode === 'console') {
    styles = {
      //styles
      'bold'      : ['\x1B[1m',  '\x1B[22m'],
      'italic'    : ['\x1B[3m',  '\x1B[23m'],
      'underline' : ['\x1B[4m',  '\x1B[24m'],
      'inverse'   : ['\x1B[7m',  '\x1B[27m'],
      'strikethrough' : ['\x1B[9m',  '\x1B[29m'],
      //text colors
      //grayscale
      'white'     : ['\x1B[37m', '\x1B[39m'],
      'grey'      : ['\x1B[90m', '\x1B[39m'],
      'black'     : ['\x1B[30m', '\x1B[39m'],
      //colors
      'blue'      : ['\x1B[34m', '\x1B[39m'],
      'cyan'      : ['\x1B[36m', '\x1B[39m'],
      'green'     : ['\x1B[32m', '\x1B[39m'],
      'magenta'   : ['\x1B[35m', '\x1B[39m'],
      'red'       : ['\x1B[31m', '\x1B[39m'],
      'yellow'    : ['\x1B[33m', '\x1B[39m'],
      //background colors
      //grayscale
      'whiteBG'     : ['\x1B[47m', '\x1B[49m'],
      'greyBG'      : ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG'     : ['\x1B[40m', '\x1B[49m'],
      //colors
      'blueBG'      : ['\x1B[44m', '\x1B[49m'],
      'cyanBG'      : ['\x1B[46m', '\x1B[49m'],
      'greenBG'     : ['\x1B[42m', '\x1B[49m'],
      'magentaBG'   : ['\x1B[45m', '\x1B[49m'],
      'redBG'       : ['\x1B[41m', '\x1B[49m'],
      'yellowBG'    : ['\x1B[43m', '\x1B[49m']
    };
  } else if (exports.mode === 'browser') {
    styles = {
      //styles
      'bold'      : ['<b>',  '</b>'],
      'italic'    : ['<i>',  '</i>'],
      'underline' : ['<u>',  '</u>'],
      'inverse'   : ['<span style="background-color:black;color:white;">',  '</span>'],
      'strikethrough' : ['<del>',  '</del>'],
      //text colors
      //grayscale
      'white'     : ['<span style="color:white;">',   '</span>'],
      'grey'      : ['<span style="color:gray;">',    '</span>'],
      'black'     : ['<span style="color:black;">',   '</span>'],
      //colors
      'blue'      : ['<span style="color:blue;">',    '</span>'],
      'cyan'      : ['<span style="color:cyan;">',    '</span>'],
      'green'     : ['<span style="color:green;">',   '</span>'],
      'magenta'   : ['<span style="color:magenta;">', '</span>'],
      'red'       : ['<span style="color:red;">',     '</span>'],
      'yellow'    : ['<span style="color:yellow;">',  '</span>'],
      //background colors
      //grayscale
      'whiteBG'     : ['<span style="background-color:white;">',   '</span>'],
      'greyBG'      : ['<span style="background-color:gray;">',    '</span>'],
      'blackBG'     : ['<span style="background-color:black;">',   '</span>'],
      //colors
      'blueBG'      : ['<span style="background-color:blue;">',    '</span>'],
      'cyanBG'      : ['<span style="background-color:cyan;">',    '</span>'],
      'greenBG'     : ['<span style="background-color:green;">',   '</span>'],
      'magentaBG'   : ['<span style="background-color:magenta;">', '</span>'],
      'redBG'       : ['<span style="background-color:red;">',     '</span>'],
      'yellowBG'    : ['<span style="background-color:yellow;">',  '</span>']
    };
  } else if (exports.mode === 'none') {
    return str + '';
  } else {
    console.log('unsupported mode, try "browser", "console" or "none"');
  }
  return styles[style][0] + str + styles[style][1];
}

function applyTheme(theme) {

  //
  // Remark: This is a list of methods that exist
  // on String that you should not overwrite.
  //
  var stringPrototypeBlacklist = [
    '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
    'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
    'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
  ];

  Object.keys(theme).forEach(function (prop) {
    if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
      console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
    }
    else {
      if (typeof(theme[prop]) === 'string') {
        addProperty(prop, function () {
          return exports[theme[prop]](this);
        });
      }
      else {
        addProperty(prop, function () {
          var ret = this;
          for (var t = 0; t < theme[prop].length; t++) {
            ret = exports[theme[prop][t]](ret);
          }
          return ret;
        });
      }
    }
  });
}


//
// Iterate through all default styles and colors
//
var x = ['bold', 'underline', 'strikethrough', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta', 'greyBG', 'blackBG', 'yellowBG', 'redBG', 'greenBG', 'blueBG', 'whiteBG', 'cyanBG', 'magentaBG'];
x.forEach(function (style) {

  // __defineGetter__ at the least works in more browsers
  // http://robertnyman.com/javascript/javascript-getters-setters.html
  // Object.defineProperty only works in Chrome
  addProperty(style, function () {
    return stylize(this, style);
  });
});

function sequencer(map) {
  return function () {
    if (!isHeadless) {
      return this.replace(/( )/, '$1');
    }
    var exploded = this.split(""), i = 0;
    exploded = exploded.map(map);
    return exploded.join("");
  };
}

var rainbowMap = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
    }
  };
})();

exports.themes = {};

exports.addSequencer = function (name, map) {
  addProperty(name, sequencer(map));
};

exports.addSequencer('rainbow', rainbowMap);
exports.addSequencer('zebra', function (letter, i, exploded) {
  return i % 2 === 0 ? letter : letter.inverse;
});

exports.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      exports.themes[theme] = require(theme);
      applyTheme(exports.themes[theme]);
      return exports.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};


addProperty('stripColors', function () {
  return ("" + this).replace(/\x1B\[\d+m/g, '');
});

// please no
function zalgo(text, options) {
  var soul = {
    "up" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', ''
    ],
    "down" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', ''
    ],
    "mid" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '',
      '', '', '', '',
      '', '', ' '
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] = options["up"] || true;
    options["mid"] = options["mid"] || true;
    options["down"] = options["down"] || true;
    options["size"] = options["size"] || "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.min = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.min = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  return heComes(text);
}


// don't summon zalgo
addProperty('zalgo', function () {
  return zalgo(this);
});

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/index.js":[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/index.js":[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/socket.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/socket.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? '443' : '80';
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    function close() {
      self.onClose('forced close');
      debug('socket closing - telling transport to close');
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener('upgrade', cleanupAndClose);
      self.removeListener('upgradeError', cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once('upgrade', cleanupAndClose);
      self.once('upgradeError', cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","./transports":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","indexof":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js","parsejson":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parsejson/index.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","parseuri":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseuri/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/index.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling-jsonp":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-jsonp.js","./polling-xhr":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-xhr.js","./websocket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/websocket.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-jsonp.js":[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-xhr.js":[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/websocket.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = require('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","ws":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/ws/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js":[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js":[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js":[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/debug.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/debug.js":[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/node_modules/ms/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/node_modules/ms/index.js":[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./keys":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/keys.js","after":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/after/index.js","arraybuffer.slice":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/arraybuffer.slice/index.js","base64-arraybuffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js","blob":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/blob/index.js","has-binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/index.js","utf8":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/utf8/utf8.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/keys.js":[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/after/index.js":[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/arraybuffer.slice/index.js":[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/blob/index.js":[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob(['hi']);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/index.js":[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/utf8/utf8.js":[function(require,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return 'U+' + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = require('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/node_modules/global/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/node_modules/global/index.js":[function(require,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js":[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parsejson/index.js":[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js":[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseuri/index.js":[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/ws/lib/browser.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./lib/core.js')
require('./lib/done.js')
require('./lib/es6-extensions.js')
require('./lib/node-extensions.js')
},{"./lib/core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","./lib/done.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/done.js","./lib/es6-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/es6-extensions.js","./lib/node-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/node-extensions.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js":[function(require,module,exports){
'use strict';

var asap = require('asap')

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}

},{"asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/done.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}
},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/es6-extensions.js":[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Promise.prototype

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/node-extensions.js":[function(require,module,exports){
'use strict';

//This file contains then/promise specific extensions that are only useful for node.js interop

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      var res = fn.apply(self, args)
      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
        resolve(res)
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    var ctx = this
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback.call(ctx, ex)
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value)
    })
  }, function (err) {
    asap(function () {
      callback.call(ctx, err)
    })
  })
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js":[function(require,module,exports){
(function (process){

// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


}).call(this,require('_process'))

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/index.js":[function(require,module,exports){

module.exports = require('./lib/');

},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/manager.js","./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js","./url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/manager.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var object = require('object-component');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = 'closed';
  this.engine && this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js","./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js","./url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js","backo2":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/backo2/index.js","component-bind":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","engine.io-client":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/index.js","indexof":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/indexof/index.js","object-component":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/object-component/index.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js":[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

},{"./on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js","component-bind":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","has-binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/index.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js","to-array":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/to-array/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js":[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","parseuri":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/parseuri/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/backo2/index.js":[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js":[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js":[function(require,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/index.js":[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/node_modules/isarray/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/indexof/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/object-component/index.js":[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/parseuri/index.js":[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/binary.js":[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./is-buffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js","isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/binary.js","./is-buffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js","json3":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/json3/lib/json3.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js":[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/json3/lib/json3.js":[function(require,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/to-array/index.js":[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/array.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  object = require('./');

util.define(object,
  /**
   * V.Object's equivalent to Array.push()
   * @method push
   * @param  {Arguments}  The item(s) to add to the array
   * @return {Number}     The new length of the array
   */
  'push', function() {
    if (this.__t === 1) {
      if (this.length === void 0) {
        this.length = 0;
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        this._push(arguments[i]);
      }
      return this.length;
    }
  },
  '_push', function(val, vobj, stamp, noupdate, from) {
    //ame, val, vobj, stamp, noupdate, from
    this.length++;
    this.set((this.length - 1), val, vobj, stamp, noupdate, from);
    return this[this.length - 1];
  },
  /**
   * V.Object's equivalent to Array.pop()
   * @method pop
   * @return {*}  The removed array item
   */
  'pop', function() {
    if (this.__t === 1) {
      var l = this.length
      if(l !== 0){
        t = this[l - 1];
        this.length--;
        t.remove();
      }
      // return t; //pretty weird since this object always has value null;
    }
  },
  /**
   * V.Object's equivalent to Array.splice()
   * @method splice
   * @param  {Number}    index   An integer that specifies at what position to add/remove items, Use negative values to specify the position from the end of the array
   * @param  {Number}    howmany The number of items to be removed. If set to 0, no items will be removed
   * @param  {Arguments}         The new item(s) to be added to the array
   * @return {Array}             A new array containing the removed items, if any
   */
  'splice', function(index, howmany) { //can become shorter;
    if (index > -1 && this.__t === 1) { //how many and -i are ignored
      for (var i = 0, l = this.length, shift; i < l; i++) {
        if (shift) {
          if (i === l - 1) {
            // this.length--;
            this[i] = null;
          } else {
            this[i] = this[i + 1];
            this[i]._name = i;
          }
        } else {
          if (i === index) {
            if (i === l - 1) {
              this.pop();
            } else {
              shift = true;
              this.length--;
              this[i].remove();
              this[i] = this[i + 1];
              this[i]._name = i;
            }
          }
        }
      }
    }
  },
  /**
   * Adds value to array if it is not contained in array, executes handler on encountering val in array
   * @method include
   * @param  {*}         val       Value to add
   * @param  {Function}  [handler] Function to execute on encountering val in array
   * @return {Boolean}             True/false
   */
  'include', function(val, handler, arr) {
    return util.include(this, val, handler, arr);
  },
  'concat', function(val) { 

    // if(!val) {
    //   return
    // }
    
    var arr = this
    var ll = arr.length;
    for (var i = 0, l = val.length; i < l; i++) {
      arr._push(val[i], false, false, true);
    }
    arr._update(val);
    return arr;
  },
  'moveItem', function(from, to) { var arr = this
    if(to === void 0) to = arr.length - 1
    if(from === to) return
    var mover = arr[from]
    if(!mover) return
    var step = from < to ? 1 : -1
    do {
      arr[from] = null
      arr.set(from, arr[from + step], true)
      from += step
    } while(from !== to)
    arr[to] = null
    arr.set(to, mover, true)
  }
)

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/compound.js":[function(require,module,exports){


var VObject = require('vigour-js/object').inject(
    require('vigour-js/value/length')
  ),
  util = require('vigour-js/util'),
  uid = require('vigour-js/util/id')

var SAMEPATH = 'could not create compound of two Objects with the same path'

// function Compound(val){
//   var compound = this
//   compound.$sources = new SourceList(compound, val)
//   this.__t = 2
// }

// var Data = require('vigour-js/data')

var Compound = VObject.new(void 0, function(val){
  var compound = this
  compound.$sources = new SourceList(compound, val)
  this.__t = 2
  return false
})
util.define(Compound, '_class', VObject)


module.exports = Compound
// Compound.prototype = new VObject()

Compound.prototype._blacklist.push(
  '$sources'
)

util.define( Compound,
  '_absorb', function _absorb(entry) {
    var compound = this
    var source = entry.source
    var prefix = entry.name
    
    var endpoint = source
    while(endpoint && endpoint.__t === 4 && !endpoint._filter) {
      endpoint = endpoint._val
    }
    entry.endpoint = endpoint
    
    if(endpoint) {
      endpoint.each(function absorbEach(){
        compound.set(prefix + '-' +this._name, this)
      })
    }

    compound.each(function cleanOld(){
      var pointer = this
      var pointed = pointer._val

      // skip cleanup check on construction
      if(!compound.$sources) {
        return
      }

      // TODO: find a better way to check if thing is still in an enpoint
      // get the endpoint the item should be in
      var sourcename = pointer._name.split('-')[0]
      var ep = compound.$sources[sourcename].endpoint
      var ok
      ep.each(function okCheck(){
        if(this === pointed) {
          return ok = true
        }
      })
      if(!ok) {
        pointer.remove()
      }
    })
  },
  '_addCompoundListener', function _addCompoundListener(entry) {
    var compound = this
    entry.source.on(function compoundListener(){
      // console.log('change in source, run absorb on', entry, 
      //   '\nval', arguments[0],
      //   '\nstamp', arguments[1]
      // )
      compound._absorb(entry)
    })
  }
)

function SourceList(compound, val) {
  var sourcelist = this
  sourcelist._parent = compound
  if(val){
    if(!(val instanceof Array)) {
      val = [val]
    }
    this.push.apply(this, val)
  }
}

SourceList.prototype.push = function pushSource(){
  var sourcelist = this
  var compound = sourcelist._parent

  // console.log('push dat sources', arguments.length)
  var al = arguments.length
  for(var i = 0, source; source = arguments[i] ; i++){

    var sourcename = uid()

    // console.log('SOURCENAME IS', sourcename)

    var entry = sourcelist[sourcename] = {
      name: sourcename,
      source: source
    }

    compound._absorb(entry)
    compound._addCompoundListener(entry)

  }
}




},{"vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/util/id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js","vigour-js/value/length":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')

/**
 * Flags are special properties where a function is called
 * different from operators since flags may have nothing to do with value calculation
 * extends default set from V.Object
 * @property
 */
/**
 * Adds new flags to V.Object
 * @method extend
 * @param  {Object}   object V.Object to extend flags to
 * @param  {Function} [set]  [description]
 * @return {[type]}          [description]
 */
exports.extend = util.extend(function(object, set) {
  
  //multiple flags 
  
  // abstract flags array away!
  // 
  // flags object --> field
  // 
  // check /w cases
  // check /w parent
  // flag4 is dynamic has stack as option
  
  var _proto = object.prototype
    , _convert = _proto.convert
    , _set = _proto._set
    , _remove = _proto._remove
    , _check = function(name) {
      var f;
      for (var i in object.flags.dynamic) {
        f = object.flags.dynamic[i](name)
        if(f) break
      }
      return f
    }
    , checkIfFlagOverwrite = function(val) {
      for(var i in val) {
        if(object.flags[i] || _check(i)) return true
      }
    }

  if (!set) set = _proto.set

  _proto._blacklist.push('_flag');
  util.define(object,
    /**
     * [description]
     * @method convert
     * @param  {[type]} val [description]
     * @return {[type]}     [description]
     */
    'convert', function(val) {

      //hier ook weer for
      var obj = _convert.call(this, val);

      // console.log('I SHOULD BE CONVERTING!', val, obj, this._flag)





      if (this._flag && (!val || !util.isObj(val) || val.val || checkIfFlagOverwrite(val) )) {

        // console.log('I SHOULD BE CONVERTING! step 2')

        //ff useVal gebruiken

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (!flag[4] || !flag[4].stack) {

            // console.log('CONVERT NEEDS FIX'.red.bold.inverse)

            if (obj === flag[1]) {
              // console.log('2 CONVERT NEEDS FIX'.red.bold.inverse)
              obj = {};
            }
            if (obj.val === flag[1]) {
              // console.log('3 CONVERT NEEDS FIX'.red.bold.inverse)
              delete obj.val;
            }


            obj[flag[0]] = flag[2]
          }
          else {
            //still have to take care of this situation
            // console.error('trying convert a stack-dynamic flag', flag);
          }
        }

        // console.log('CONVERTED ---->',obj)

      }
      return obj;
    },
    /**
      @property __flags__
    */
    '__flags__', {},
    /**
     * [description]
     * @method remove
     * @param  {[type]} from   [description]
     * @param  {[type]} update [description]
     * @param  {[type]} stamp  [description]
     * @return {[type]}        [description]
     */
    '_remove', function(from, update, stamp) {

      if(this._flag) {
        for(var i in this._flag) {
          // console.log(i, this._flag)
          var flag = this._flag[i]
          //for 
          // console.log('_remove')
          if (flag) {
            //dit moet wel ff lukken
            if (object.flags[flag[0]]) {
              object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag);
            } else {
              flag[4].remove.call(this, flag);
            }
          }
        }
        this._flag = null
      }

      _remove.call(this, from, update, stamp);
    },
    /**
     * [description]
     * @method _set
     * @param  {[type]} val      [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} from     [description]
     * @param  {[type]} remove   [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    '_set', function(val, stamp, from, remove, noupdate) {
      // console.log('make _set',this._name,val);
      _set.call(this, val, stamp, from, remove, noupdate)

      //flag moet dus ook meer een copied value worden

      // console.log('_set', this._flag, val)


      if(this._flag) {

        // console.log('overwrite>?----', this._flag, val)

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (flag) {
            var setFl = object.flags[flag[0]] || flag[4]
            //what to do with reset?
            //change fixen bij cases?
            
            // console.log('2 overwrite>?----', flag, this._val, this._val !== flag[1])
            
            if (this._val !== flag[1] && setFl.useVal) {

              // nu ff hier ook nog!

              if (object.flags[flag[0]]) {

                // console.log('remove flag normal',flag, flag[4], i, this)

                object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag)
                //if this empty
                // delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
                // this._update()
              } else if (!flag[5]) {
                // console.log('remove flag /w flag[4] and not flag[5]',flag, flag[4], i)
                flag[4].remove.call(this, flag);
                // if(this.)
                //delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
              }
            } else if (object.flags[flag[0]] && object.flags[flag[0]].reset && flag[3] !== this) {
              // console.error('RESETTING -- ingnore /w a clear!',flag[0]) 
              object.flags[flag[0]].set.call(this, flag[2], stamp, true, this._name)
            }
          }
        }
      }

    },
    /**
     * [description]
     * @method set
     * @param  {[type]} name     [description]
     * @param  {[type]} val      [description]
     * @param  {[type]} vobj     [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    'set', function(name, val, vobj, stamp, noupdate) {
      var fl = object.flags[name] || _check(name)
        , r
        , same

        // console.log(name, val, vobj)

      if (fl) {

        // console.log('set>?----', name, val, this._flag)
       
      if(val===false) {
          //stack -- alle flags name providen!
          var i = fl.stack||name 
            , flag = this._flag && this._flag[i]
          if(flag && fl.remove) {
            var d = fl.remove.call(this, flag, name)
            // console.log('REMOVE FLAG FROM FALSE'.inverse, fl, name, val, stamp, this)
            if(!d) {
              delete this._flag[i]
              if(util.empty(this._flag)) {
                // console.log('flag is empty, delete')
                delete this._flag
              }
            }
          } 
          r = true
          // if(this._flag)
      } else {
       if(this._flag) {
          //check if need to remove! -- only in case
          for(var i in this._flag) {
            var flag = this._flag[i]
            if (flag && fl.remove) {

              if(!fl.stack && name === flag[0]) {
                // console.log('--->',flag[0])
                if(val!==flag[2]) {
                  // console.log('remove flag! ---> overwrite bymyself --->', flag[0],  setFl, 'by:' ,name, fl, val, flag[2])
                  fl.remove.call(this, flag);
                } else {
                  same = true
                }

              } else if (!fl.stack || fl.stack !== flag[0]) {

                //this._flag

                //if val:true 
                //go check if you need to remove mofos

                var setFl = object.flags[flag[0]] || flag[4]

                if(setFl.useVal && fl.useVal) {

                  // console.log('remove flag! -- clearly has some useVal', flag[0],  setFl, 'by:' ,name, fl)

                  setFl.remove.call(this, flag);
                  delete this._flag[i]
                  if(util.empty(this._flag)) {
                    // console.log('flag is empty, delete')
                    delete this._flag
                  }
                }


                // console.log('remove flag!', flag, flag[0], flag[4],  object.flags[flag[0]]  , fl, name) //check if it needs to be removed
                // var fl 
                
                //fl = object.flags[name] || _check(name)
                //
                //hier iets mee doen weer zoeken naar flag set


                //do the special check if value is tight to flag check (for both! fl.value)

                // fl.remove.call(this, flag);
              }
            }
          }
        }

      if(!same) {
          // console.log('SET FLAG'.inverse, name, val, stamp, this)
          fl.set.call(this, val, stamp, false, name);
          r = true //niet altijd waar ofcourse!
          // console.log('---------')
        } else {
          // console.log('FLAG IS SAME'.red.inverse, name, val, stamp, this)
        }
      }
        this[name] && this[name].remove(false, false, false, false, false, true);
      } else {
        r = set.call(this, name, val, vobj, stamp, noupdate);
      }
      return r;
    });
  object.flags = _proto.__flags__;
  util.define(object.flags, 'dynamic', {});
})
},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/hashpath.js":[function(require,module,exports){
var util = require('../util')
  , hash = require('../util/hash')

exports.extend = util.extend(function(base) {
  base.prototype._blacklist.push('__hp')
  util.define( base
  , '_hashpath', {
      get: function() {
        return this.__hp || (this.__hp = hash(this._path.toString()))
      }
    }
  )
})
},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')
  , vigour = require('../')
  , inject = require('../util/inject')
/**
 * V.Objects are used instead of normal objects in vigour listeners are automatically added and removed
 * type: __t : 1 = array , 2 = object , 3 = has field (can never be an array) , 4 = field ref to other V.Object
 * note you can make an object out of a field or field ref the type will be 3 or 4 though!
 * @constructor
 * @param  {*}      [val]    Value
 * @param  {Object} [parent] Parentobject
 */
var object = module.exports = exports = vigour.Object = function(val, hook, parent) {
  if (parent) this._parent = parent
  if (hook && this._hook) this._hook(val, hook)
  if (val !== void 0) this.val = val
}
object.inject = inject
/**
 * Used to set .val
 * @method _set
 * @param  {*}              val                  [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Object|Boolean} [from]               [description]
 * @param  {Boolean}        [noupdate]           When true, no updates
 * @param  {Boolean}        [add]                When true, this is an add
 */
var _set = function(val, stamp, from, noupdate, add) {

  if(val===null) {
    if (!stamp) stamp = this.stamp()
    this.remove(false, false, false, from, stamp, noupdate)
  }

  if (!this.__t || this.__t < 3 || ( val !== this._val || this._ignoreValue ) ) {

    // console.error(this)
    if(!this.stamp) {
      //moet allemaal event emitters worden (on('error'))
      //this._update('error') en anders V.debug.error._update( 'object' )
      console.error( 'ERROR in vigour-js/object,  OBJECT no .stamp', this )
      return
    }

    if (!stamp) stamp = this.stamp()

    var oldval = this._val
      , nestedval
      , noset
      , isSet
      , isArray
      , valIsSet

    if (this._changevobj 
      && ((this.__t < 4 && val instanceof object) 
      || this.__t === 4 && ((!this._mixed||this._mixed===4) || val instanceof Array 
        || (val instanceof Object 
          && (val instanceof object || val.val))))) { //try to make this shorter
         this._changevobj(val, stamp)
         if(this._mixed===4) this._val = null
    }

    if (vigour.Base && (val instanceof vigour.Base)) {
      this.remove(true, true, false, false, stamp)
      this.__t = 5
      this._val = val
    } else if (val instanceof object) {
      if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
        this.remove(true, true, false, void 0, stamp) //check if 2nd param true is absolutely nessecary (else it will be removed)
      }
      this._val = val
      this.__t = 4
      if (this._setvobj) this._setvobj(val)
    } else {

      if (val instanceof Object && typeof val !== 'function') {
        if (val instanceof Array) {
          this._val = void 0
          this.__t = 1
          this.length = val.length
          noset = this.remove(true, true, val, false, stamp)
          for (var i = 0, l = this.length; i < l; i++) {
            if (!this.set(i, val[i], false, stamp, noupdate, true) && noset !== false) {
              noset = true
            } else {
              noset = false
            }
          }
        } else {

          //normal object

          if (val.clear) {
            noset = this.remove(true, true, false, false, stamp)
            delete val.clear
          } else {

            if (this.__t === 1) {
              if (this._mixed !== 1 && this._mixed!==4) {
                this.remove(true, true, false, false, stamp) //ommiting stamp can be a problem
              } else {
                isArray = true
              }
            } else if (!this._merge && (!this._mixed || this.__t === 2)) {
              noset = this.remove(true, true, val, false, stamp)
            }
          }
          if (val.val && util.isObj(val.val)) {
            valIsSet = true
            this._$setVal( new this._class(val.val, false, this), stamp, from, true)
            this._val._contained = true
          } else if (!this._mixed) {
            this._val = void 0 //this messes up property updates!! (youri)
          }

          if (!isArray) this.__t = 2

          for (var j in val) {
            if (!util.checkArray(this._blacklist, j)) {
              if (j === 'val') {
                if(!valIsSet) isSet = this._$setVal( val.val, stamp, from, true )
                nestedval = true;
              } else {
                //do not always ignore updates at this point
                if (!this.set(j, val[j], false, stamp, noupdate, true) && noset !== false) {
                  noset = true
                } else {
                  noset = false //this is the place where set is passed
                }
              }
            }
          }
        }

      } else {
        if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
          this.remove(true, true, false, false, stamp)
          if (this.__t === 1) delete this.length
        }
        if (val === this._val && !this._ignoreValue ) {
          //maybe use stamp for ignoreValue as well?
          if (noset !== false) {
            this.__t = 3
            return false
          }
        } else {
          this._val = val
          this.__t = 3
        }
      }
    }
    if (nestedval) {

      if (this._set && (isSet !== false || noset === false)) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      }
    } else if (this._set) {
      if (!noset) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      } else {
                    // if(window.smut) console.log('!1',arguments)

        return false;
      }
    }
  } else {
                        // if(window.smut) console.log('!1',arguments)

    return false;
  }

},
/**
 * stamp
 * paint the set origin
 * @method
 */
_stamp = 0,
_params = function(params, list) {
  for (var i = list.length - 1, p; i >= 0; i--) {
    if (params && params[list[i]]!==void 0) {
      p = '_' + list[i]
      util.define(this, p, params[list[i]])
    }
  }
}
/**
* Generates unique stamp
* @method stamp
* @return {Number} Returns stamp
*/
exports.stamp = function() {
//if stamp > x reset ?
return _stamp++
}

exports.set = _set

// objectUtils.extend(exports);  
/**
 * Creates a new constructor based on a V.Object
 * Params can be passed
 * Mixed creates mixed types for the new class i.e having a string and properties
 * @method new
 * @param  {Object} params Parametersobject
 * @return {Object}        Returns V.Object
 */
// window.cnt = 0
// setTimeout(function() {
//   window.smut = true
// },2000)

object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      var conresult
      if (constructor) {
        conresult = constructor.apply(this,arguments)
      }
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)

      if(val !== void 0 && conresult !== false) {
        this.val = val
      }
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  vObj.inject = inject //not handeled well yet
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

util.define(object,

// '_set, set , '

 '_$setVal', _set,

/**
 * Items in the blacklist skipped in each function
 * @method _blacklist
 */
'_blacklist', ['_', '__', '__t', '_val', 'length', '_name', '_parent', '_contained', '_removed','extensions', '__cachedPath', '_ignoreValue', '_indexCache'],
/**
 * Replaces default constructor property ,necessary for classes made with V.Object.new
 * @constructor _class
 */
'_class', object,
/**
 * Stamp is a method of VObject so that it can be extended in subclasses
 * @return {*} a unique identifier for a mutation
 */
'stamp', object.stamp,
/**
 * Used to get .val which returns field values i.e. a string
 * @method _get
 * @return {*} Returns value
 */
'_get', function() {
  var self = this
    , type = self.__t
    , val

  if (type < 3) {
    return self
  } else {
    val = self._val
    return (type !== 4) ? val : val && val._get()
  }
},
/**
 * Used to get .val which returns field values i.e. a string
 * Set creates instances of the _class for nested properties
 * @property
 */
'val', {
  set: function(val) {
    // window.cnt++
    // if(window.smut) {
      // console.error(window.cnt, 'whats happening', this._path, this._prop && this._prop.name, this, this._updateOrigin)
    // }
    return this._$setVal(val)
  },
  get: function() {
    return this._get()
  }
},
/**
 * Add a property to a object
 * @method set
 * @param  {String}  name                [description]
 * @param  {*}       val                 [description]
 * @param  {Boolean} [vobj]              [description]
 * @param  {Number}  [stamp = new stamp] [description]
 * @param  {Boolean} [noupdate]          [description]
 * @return {Boolean}                     [description]
 */
'set', function( name, val, vobj, stamp, noupdate, from ) {

  //function( name, val, vobj, stamp, noupdate, from ) 

  // console.log(name, stamp)

  from = from && this
  if (!vobj && (this[name] instanceof object)) {
    if (this._$setVal.call(this[name], val, stamp, from, noupdate) === false && stamp) {
      return false
    }
  } else {
    if (vobj) {
      if(this[name]) this[name].remove()
      this[name] = val
      this[name]._name = name
      this[name]._parent = this
      if(!noupdate) val._update(val, stamp || this.stamp(), from, void 0, true)
    } else {
      this[name] = new this._class(void 0, false, this)
      this[name]._name = name
      this._$setVal.call(this[name], val, stamp, from, noupdate, true)
    }
    if (this.__t === 1 && this._setArrayItem) {
      this._setArrayItem( this[name], val )
    }
  }
  return true
},
/**
 * Removes a V.Object including all nested fields and values
 * @method remove
 * @param  {Boolean}        [nested]             When true remove nested objects
 * @param  {Boolean}        [bl]                 When true doesn't remove blacklisted items
 * @param  {Boolean}        [not]                [description]
 * @param  {Boolean|Object} [from]               [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Boolean}        [noupdate]           [description]
 * @return {Boolean}                             [description]
 */
 //    this.remove(false, false, false, from, stamp, noupdate)

'remove', function(nested, bl, not, from, stamp, noupdate) { //no update first > (extended in selection.js)
  if (!nested) this._removed = true
  var r, i, oldval
  if (!stamp) stamp = this.stamp()
  // console.log('START',stamp,this._name);
  if (!nested) {
    if (this._parent) {
      this._parent[this._name] = null
      delete this._parent[this._name]
    }
    if (this._val !== void 0) {
      if (this._val instanceof object && this._val._contained) {
        this._val.remove(false, false, false, from || this, stamp, noupdate)
      }
      oldval = this._val
      this._val = null
    }
  }
  for (i in this) {
    if ((!not || !not[i]) && !util.checkArray(this._blacklist, i)) {
      if (this[i] instanceof object) {
        r = false
        // console.log('DELETE',stamp,i,this[i]);
        this[i].remove(false, false, false, from || this, stamp, noupdate)
      }
      this[i] = null
      delete this[i] //delete is pretty nasty for performance
    }
  }
  if (!nested) {
    if (this._remove) {
      //r
      this._remove(from, noupdate ? false : from /*||r*/ , stamp, oldval);
      if (!bl) {
        for (var j in this) {
          if (this[j] !== void 0) {
            if (j !== '_parent' && this[j] instanceof object && this[j]._contained) {
              this[j].remove()
            }
            this[j] = null
            delete this[j]
          }
        }
      }
    }
    this._removed = true
  }
  return r
})


//----this has to be initialized after defining the blacklist property;
exports.listen = require('./listen')
require('./array')
require('./util')
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./array":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/array.js","./listen":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/listen.js","./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/listen.js":[function(require,module,exports){
var util = require('../util')
  , vObject = require('./')
  , V = require('../')
  //TODO: this is a temp fix to emulate on next tick
  , raf = require('vigour-js/browser/animation/raf')
  , Promise = require('promise')

function _addListener( obj, fn, mark, original ) {
  //val, mark, skipcheck, ignoreval, orginal
  if( mark ) 
  {
    // console.log('hey got orginal!', original)
    //n( val, mark, skipcheck, ignoreval, original )
    obj.addListener([ fn, mark ], true, false, false, original  )
  } 
  else 
  {
        // console.log('hey got orginal!', original)

    obj.addListener( fn, false, false, false, original )
  }
}

/*
  _update calls listeners on a given Object (listeners include linking fields in other V.Objects)
  V.Object._update can be modified to change update behavior:
    - standard: update Object and it's parents / ancestors recursively.
    - parentOnly: update Object and only its direct parent.
    - just _update: update only the Object.
*/
var _update = exports._update = function(val, stamp, from, remove, added, oldval, test) {

  // if(window.here) console.log('UPDATE!',this._path)

  var _l = this._listeners
    , i
    , listener

  if (_l) {
    for (i = _l.length; listener = _l[--i];) { //order is irrelevant
      if (listener instanceof vObject) {

        // console.log('update?????', listener._path, this._path, from)

        // if (from) {
        listener._lfrom = from || this
          // }

        listener._update(val, stamp, false, remove, added, oldval)

        if (listener) listener._lfrom = null

      } else if (listener[0]) {
        if(!test || !test(listener)) {
          if (listener.length > 2) {
            for (var l = listener.length - 2
              , l2 = arguments.length
              , a = [], j = -1
              , la = l + l2
              ; j < la
              ; a[++j] = j < l
                ? listener[j + 2]
                : j === l ? this : arguments[j - l - 1]
              );

            listener[0].apply(listener[1], a)
          } else {
            listener[0].call(listener[1], this, val, stamp, from, remove, added, oldval)
          }
        }
      } else {
        listener.call(this, val, stamp, from, remove, added, oldval)
      }
    }
  }
}


// util.define(vObject, 
//   '_nodePath_', function() {
//     if(this._caller) {

//       var arr = []
//       var p = this._caller

//       while(p) {
//         arr.push( p._name || p._node && p._node.className )
//         p = p._node && p.parent
//       }
//       arr.reverse()
//       return arr


//     }
//   }

// )


vObject.prototype._blacklist.push('_listeners', '_listens', '_lfrom', '_listenMap');

util.define(vObject,
  /**
   * _set
   * is called when a value is set
   * @method
   */
  '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
    if (!noupdate) {
      // console.log(this._path, val)
      this._update(val, stamp, from, remove, added, oldval);
    }
  },

  'is', function (val, cb, nextTick ) {

    //on removal of promise remove listener

    if(!cb || ( typeof cb !== 'function')) {
      var _this = this
      nextTick = cb
      // console.error('my mofo', nextTick)
      return new Promise(function( resolve, reject ) {
        // console.log('312123123213', val)
        _this.is( val, function() {
          resolve.apply(this, arguments)
        }, nextTick)
      })
    } else {
      // console.error('lezzgo')
      var cbx = nextTick ? function() {
        var args = util.arg(arguments)
          , _this = this
        raf(function() {
          cb.call(_this)
        })
      } : cb
      //TODO: add original if its not 
          // console.error('--------------', val)

      if(val==='loaded') {
        if(this.$loaded || this.from.$loaded) {
          cbx.call(this)
        } else {
          this.once('loaded', cbx)
        }
      } else {
        var ret
        // var ignore
        // console.error('1!@#@#!!@#', ret, val)

        if(this.val == val ) {
          // console.error('2!@#@#!!@#', ret, val)

          return cbx.call(this)
        } else {
          // console.error('!@#xxxxx12121212122112@#!!@#', ret, val)

          ret = (typeof val === 'function') && val.call(this)
          // ignore = true
          // console.error('2222222222!@#@#!!@#', ret, val)
        }
        if(ret) {
          if( ret instanceof Promise ) {
            // console.error('promise')
            return ret
          } else {
            // console.log('????!!!')
            return cbx.call(this)
          }
        } else {
          // console.error('22222!@!@#!@#', val)
          if(typeof val === 'function') {
            this.once(val, cbx)
         } else {
            this.once({
              $val: val
            }, cbx)
         }
        }
      }
      return this
    }
  },
  /**
   * __update
   * calls listeners attached to the Object
   * types -- function or V.Object
   * @method
   */
  '__update', _update,
  /**
   * _update
   * escalates an update up it's structure and calls __update to call listeners
   * types -- function or V.Object
   * @method
   */
  '_update', function(val, stamp, from, remove, added, oldval, test) { //here you can see if its an update from another object (from)
    // console.log('V.Object OG _update', val, stamp, from, remove, added, oldval)
    var curr = this,
    s = true

    while (curr) {
      // var p = curr._path
      // _update ["clients", "V_2pxcewv3g4k"] 
      // console.log('_update', p, val, from || ((!s && this) ? this : void 0, this) )

      //TODO 10 double check this
      curr.__update(val, stamp, from || (s!==true) ? this : false , remove, added, oldval, test)
      curr = from ? false : curr._parent
      s = false
      if (remove) remove = 1
    }
  },
  /**
   * _remove
   * called on remove
   * @method
   */
  '_remove', function(from, update, stamp, oldval) {
    if (update !== false) {
      this._update(null, stamp, from, true, false, oldval);
    }
    this.removeListener();
    var _l = this._listens,
      i, listener;
    if (_l) {
      //optimize later
      //this,this is weird to always use this...
      for (i = _l.length - 1; i >= 0; _l[i--].removeListener(this, void 0, false, true));
    }
  },
  /**
   * _setvobj
   * if a value is set to a V.Object
   * @method
   */
  '_setvobj', function(val) {
    val.addListener(this);
  },
  /**
   * _changevobj
   * if a value is changed from a V.Object
   * @method
   */
  '_changevobj', function(val) {
    if (this.__t === 4) {
      var _l = this._listens,
        _val = this._val,
        i;
      if (_l) {
        for (i = _l.length; i >= 0; _l[--i] && _l[i].removeListener(this, this));
      }
      if (_val instanceof vObject && _val._contained) {
        _val.remove();
      }
    }
  },
  /**
   * addListener
   * adds a listener to an object can be a function or V.Object
   * @method
   */
  'addListener', function( val, mark, skipcheck, ignoreval, original ) {
    var _l = this._listeners || (this._listeners = []),
      target, g;

    if(original) {
      // console.log('ORGINAL!', original)
      if(!this._listenMap) {
        this._listenMap = []
      }
    }

    //more speed voor checkarray
    if (mark) {
      g = util.checkArray(_l, val[1], 1);
      if (g === false
        || !ignoreval && util.checkArray(_l, val[0], 0) === false
        || (mark !== true && mark.call(this, _l[g], _l, g, val) === true)) {
        
        //TODO: fix this ultra dirty stuff
        if( original && val !== orginal ) {
          this._listenMap.push([ orginal, val ])
        }

        _l.push(val);
      } else  {
         return _l[g];
      }
    } else if (!val.__t || !util.checkArray(_l, val)) {

      if( original && val !== original ) {
        this._listenMap.push([ original, val ])
      }

      _l.push(val);
    }
    if (mark || val instanceof vObject) {
      target = mark ? val[1] : val;
      if (target instanceof vObject) {
        _li = target._listens || (target._listens = []);
        if (skipcheck || !util.checkArray(_li, this)) {

          if( original && val !== original ) {
            this._listenMap.push([ original, val ])
          }

          _li.push(this);
        }
      }
    }
  },
   'once', function( val, method, mark ) {

    //val, mark, skipcheck, ignoreval, orginal

    //TODO:unify /w on
    var mval

    var listen = function() {
      
      this.removeListener( mval, mark )
      // this.removeListener( listen )

      mval.apply( this, arguments )
      //original perhaps????
    }

    if( method ) {
      mval = method
      this.on( val, listen, false, mval ) //deze fn moet wel geremoved worden gebeurd nu niet!
    } else {
      mval = val
      this.on( listen, false, false, mval )
    }

    return this

  },
  'on', function( val, method, mark, original ) {
      /**
        * val can be a condition or a comparison or a method
      **/
      if( V.Base && method instanceof V.Base ) 
      {
        mark = method //make exception for values!
        method = null
      }

      if(!original) {
        original = method
      } else {
        // console.log('set original!', original, method )
      }

      if( !method ) 
      {
        _addListener( this, val, mark, original )
      }
      else 
      {
        if( util.isObj( val ) )
        {
          // console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          //Has to become a condition
          if(val.$val) {
            _addListener( this, function( nval ) {
              if( this.val === val.$val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          } else {
            console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          }
          //Has to become a condition


        }
        else if( typeof val === 'function' )
        {
          _addListener( this, function( nval ) {
            if( val.apply( this, arguments ) ) //more checks
            {
              method.apply( this, arguments )
            }
          }, mark, original )
        }
        else 
        {

          if( util.isObj( method ) )
          {

            mark = val

            console.warn('untested -- add as mark')
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )


          }
          else if( val === 'remove' )
          {
            //val, stamp, false, remove, added, oldval
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          //TODO: in redo this will be done differently (event types are special done)
          else if( val === 'loaded' ) {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              //__frommethod

              if( this.$loaded || this.from.$loaded ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'added' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              if( added ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'self' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;

              //TODO: put on in a different file
              // console.log('SHOULD DO SELF!', arguments, from ) //zo wrong!

              if( this._val === nval 
              || !val && this._updateOrigin===this //pretty slow check , its there to check when someone call .update for example
              ) 
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else
          {
            _addListener( this, function( nval ) {
              if( nval === val || this.val === val || this._val === val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
        }
      }
      return this
    },

  /**
   * removeListener
   * if no val removes all listeners
   * mark checks in array on position 1 for uniqueness
   * remove is used in combination with mark
   * @method
   */
  'removeListener', function(val, mark, remove, nobreak) {
    // console.log('removeListener!', this._path, this._listeners && this._listeners.length
    //   , '\nmark:\n', mark && mark.raw
    //   , '\nval:\n', val && val.name
    //   , '\nval:\n', val
    // )
    var _l = this._listeners,
      i;
    if (_l) {
      for (i = _l.length - 1; i >= 0; i--) {
        //maybe checking mark all the time is too slow?
        var listener = _l[i]
        if (
          (!mark && !val)
          || (val && listener === val) //false voor mark
          || (mark!==false && ((listener instanceof Array) && ((mark && listener[1] === mark && (!val||listener[0]===val)) || val && listener[1] === val))
            && (!remove
              || (remove === true  //dit moet later weg is dan alleen een functie is nu overbodig (check boven)
                ? listener[0] === val
                : remove.call(this, listener, mark))))
        ) {
          // console.log('mark._listens?', !!(mark && mark._listens)
          //     , '\nis vObject?', listener instanceof vObject
          //     , '\nis marked?', listener instanceof Array
          //   )
          var focus = mark
            ? mark
            : listener instanceof vObject
              ? listener
              : listener instanceof Array
                ? listener[1]
                : false
          var listens = focus && focus._listens
          if(listens){
            for(var j = listens.length-1 ; j >= 0 ; j--){
              if(listens[j] === this){
                listens.splice(j, 1)
                if(listens.length === 0)
                  focus._listens = null
                if(focus.__t === 4 && listener._val === this)
                  listener._val = void 0
                break
              }
            }
          }
          _l.splice(i, 1)
          if (_l.length === 0) this._listeners = null;
          if (val && !nobreak) break
        }
      }

      //TODO: this has to be refactored ASAP! do when new design phase for vobject+base is going down
      if( this._listenMap && val ) {
        // console.log('im here!', val)
        var piv
        for(var i = 0, _len = this._listenMap.length; i < _len; i++ ) {
          if( this._listenMap[i][0] === val ) {
             // console.log('hey its the listenmap!', val)
             this.removeListener( this._listenMap[i][1] )
             piv = i
             break;
          }
        }
        if( piv !== void 0 ) {
          this._listenMap.splice(piv, 1)
          if(this._listenMap.length === 0) {
            this._listenMap = false
          }
        }
      }

    }
  });
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","promise":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/index.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  VObject = require('./'),
  V = require('../')
  _c = util.checkArray

/**
 * Gets/sets VObject origin
 * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
 * @method from
 * @param  {Object} obj [description]
 * @return {Object}     [description]
 */
var _coreSet = VObject.set,
  _from = this.from = function(obj) {
    var val = obj,
      last;

    while (val instanceof VObject) {
      // console.log(val)
      if(val._filter) {
        // console.error('IS SELECITON', val)
      }
      last = val;
      val = val._val;
    }
    return last !== obj ? last : false;
  },
  _lastLFrom = function(obj) {
    while (obj && obj.__t === 4) {
      if (obj._lfrom) {
        return obj._lfrom;
      } else {
        obj = obj._val;
      }
    }
  },
  /**
   * Returns path
   * @method _updatePath
   * @param  {Object}    till [description]
   * @return {Object}         Returns path
   */
  _updatePath = function(till, start) {
    var parent = this,
      lfrom,
      path = []; //reduce amount of new arrays
    while (parent && (parent._name !== void 0 || start)) {
      lfrom = parent._lfrom || _lastLFrom(parent)
      if (lfrom) {
        var a = _updatePath.call(lfrom),
          c = parent.from._name;
        util.add(a, path);
        path = a;
        if (c) {
          c = a.indexOf(c);
          a.splice(c, a.length - c);
        }
      }
      if (parent !== till) {
        path.push(parent._name);
        parent = parent._parent;
      } else {
        parent = false;
      }
    }
    // console.log('----->',path)
    return till ? path.reverse() : path;
  }

util.define(VObject,
  /**
   * Removes all linked containers, uses slice on arrays
   * Removes all _listeners
   * @method destroy
   */
   'toString', function( compressed ) {
      return compressed 
             ? JSON.stringify( this.raw ) 
             : JSON.stringify( this.raw, false, 2 )
   },
   'referenceLevel', function(linked) {
      var link = this
      var cnt = 0

      // console.log(link, link.__t)

      while(link && link.__t) {
        if(link===linked) {
          return cnt
        }
        link = link._val
        cnt++
      }
      return false
   },
  'destroy', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    this._removed = true
    this.destroyReferences(nested, bl, not, from, stamp, noupdate)
    this.remove(nested, bl, not, from, stamp, noupdate)
  },
  'destroyReferences', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    var _l = this._listeners
      , parent
      // , item
    if (_l) {
      for (var i = _l.length, ref; ref = _l[--i];) {
        // if(listener instanceof Array){
        //   if(listener)
        // }
        // ref =  instanceof Array ? _l[i][1] : _l[i];
        if (ref instanceof VObject) {
          parent = ref._parent;
          if (parent && parent.__t === 1) {
            parent.splice(ref._name, 1);
          } else {
            ref.remove(nested, bl, not, from, stamp, noupdate);
          }
        }
      }
    }
  },
  /**
   * Performs passed function on each item.
   * Skips items in the blacklist.
   * @method
   * @param  {Function}  fn   function to perform on each
   * @param  {Boolean}   deep If true, repeats eachmethod on nested fields
   * @param  {Arguments} arg  Arguments to pass to the function
   * @return {Boolean}        [description]
   */
  'each', function(fn, deep, arg) {
    //try to make this a lot shorter
    var i, item;
    if (arg !== void 0) {
      arg = util.arg(arguments, 2);
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.apply(item, arg)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each.apply(item, arg)) {
              return true;
            }
          }
        }
      }
    } else {
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.call(item, i)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each(fn, deep, arg)) {
              return true;
            }
          }
        }
      }
    }
  },
  /**
   * Returns the real path
   * @attribute _path
   */
    '_path', {
      get: function() {
        var parent = this
          , path = []

        while (parent && parent._name !== void 0) {
          path.push(parent._name);
          parent = parent._parent;
        }

        return path.reverse();
      }
    },
    '_cachedPath', {
      get: function() {
        return this.__cachedPath || (this.__cachedPath = this._path.join('.'))
      }
    },
  /**
   * Returns the update path
   * @attribute updatePath
   */
  'updatePath', {
    get: function() {
      var a = _updatePath.call(this, this, true),
        name = this._name;
      name !== void 0 && a.unshift(name);
      return a;
    }
  },
  /**
   * Returns the keys of an object
   * @attribute keys
   */
  'keys', {
    get: function() {
      var i, arr = [];
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          arr.push(i);
        }
      }
      return arr;
    }
  },
  /**
   * Returns true if object is Ancestor
   * also return true when object is object to be compared to
   * @attribute keys
   */
  //t._d === from._parent || t._d === from
  '_ancestor', function(obj) {
    // console.log('ANCESTOR'.red.inverse, obj, this)
    var p = this
    while (p) {
      if (obj === p) return true
      p = p._parent
    }
  },
  /**
   * Get a field at first occurence in the parent chain
   * @method checkParent
   * @param  {String}  field [description]
   * @param  {Boolean} get   When true returns found instead of current
   * @return {Object}        [description]
   */
  'checkParent', util.checkParentFactory('_parent'),
  /**
   * Returns a normal object, and keeps links to V.Objects
   * @method
   * @param  {*}      [val] [description]
   * @return {Object}       [description]
   */
  'convert', function(val) {
    var obj = {}, l = 0
    if (!val || val.val) obj.val = this._val
    if (this.__t === 1) {
      obj = []
      for (var i = 0; i < this.length; i++) {
        l++
        obj[i] = this[i].convert()
      }
    } else {
      this.each(function(i) {
        if (!val || val[i]!==void 0) {
          l++
          obj[i] = this.convert()
        }
      })
    }
    if (val) {
      for (var i in val) {
        if (obj[i] === void 0) obj[i] = void 0
        l++
      }
    }
    if (!l && (!val || val.val)) obj = obj.val
    return obj
  },
  /**
   * Returns a normal object
   * @attribute raw
   */
  'raw', {
    get: function() {
      var self = this,
        type = self._filter ? 2 : self.__t,
        obj, i, l;
      if (type === 4) {
        return self._val && self._val.raw;
      } else if (type === 3) {
        return self.val; //when the type is mixed always uses val
      } else {
        if (type === 1) {
          obj = [];
          for (i = -1, l = self.length - 1; i < l; self[++i] && obj.push(self[i].raw));
        } else {
          obj = {};
          for (i in self) {
            if (!_c(self._blacklist, i) && self[i]) {
              obj[i] = self[i].raw;
            }
          }
        }
        return obj;
      }
    }
  },
  /**
   * Gets/sets object origin
   * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
   * @attribute from
   */
  'from', {
    set: function(val) {
      var found = _from(this)
      _coreSet.call(found || this, val)
    },
    get: function() {
      return _from(this) || this
    }
  },
  /**
   * Merge any object into another object
   * Shallow for a shallow merge
   * @method merge
   * @param  {Object}  obj      [description]
   * @param  {Boolean} shallow  [description]
   * @param  {Number}  stamp    [description]
   * @param  {Boolean} noupdate [description]
   * @return {Object}           [description]
   */
  'merge', function merge( obj, shallow, stamp, noupdate, block, sorted, deferUpdates ) {

    // console.log('MERGE---->', obj )

    var mergeArray = this._mergeArray
      , r
      , i
      , stop
      , rt
      , cobj
      , tobj
      , topLevel

    if(!deferUpdates) {
      // console.log('NO deferUpdates'.yellow.inverse)
      topLevel = true
      deferUpdates = []
    }
    //FIXME: make it better long names etc, code formatting

    if ( !stamp ) stamp = this.stamp()

    if ( this.__t === 1 ) {
      if (mergeArray) {
        mergeArray( obj, stamp, noupdate ) //hier moet ook ff deferUpdates
      } else {
        for (var j in obj) {
          cobj = obj[j]
          tobj = this[j]
          if ((j = Number(j)) > -1) {
            r = true
            if (tobj) {
              tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
            } else {
              if (j > this.length - 1) this.length = j + 1
              this.set(j, cobj, false, stamp, true, true)
            }
          }
        }
      }
    } else {
      for (i in obj) {
        stop = true
        cobj = obj[i]
        tobj = this[i]
        if (i !== 'val' && !_c(this._blacklist, i)) {
          if (!shallow && tobj && util.isObj(cobj)) { //cobj instanceof Object && (typeof cobj !== 'function') && cobj.__t !== 3)
            if (cobj.clear) {
              _coreSet.call(tobj, cobj, stamp, false, true)
              r = true
            } else {

              // console.error('---- merge /w update thats mos def wrong!', i, deferUpdates)
              //deferUpdates

              rt = tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
              if (r !== true) r = rt

              if (!rt) 
              {
                // console.log('0000')
                obj[i] = void 0
              }
            }
          } else {

            if (tobj && tobj._val === cobj) { //changed to differentiate between 0 and false, now also differentiates between 1 and '1'
                // console.log('---- 2 update thats mos def wrong!', i)

              if (r !== true) r = false
              // console.log('???????')
              obj[i] = void 0
            } else {
              // console.log('---- 3 update thats mos def wrong!', i)
              if(cobj===null && this[i]) {
                this[i].remove( false, false, false, void 0, stamp )
              } else {
                // console.log('!?'.bold, i, this[i])
                //name, val, vobj, stamp, noupdate, from
                this.set( i, cobj, false, stamp, true )
                // console.log('!xxxx?', i)
                if(this[i] && this[i]._listeners) {
                  // console.log('push push'.green,  JSON.stringify(obj) )
                  deferUpdates.push( [this[i], cobj] )
                }
                //add dit naar list
              }
              if (!r) r = rt;

              // console.warn(r, rt)

              if (!rt) 
              {
                //TODO: TEMP FIX DONT KNOW IF THIS WORKS!
                // console.log('???????22222')
                // obj[i] = void 0
                // console.warn('cant be right!')
                //SUPER CAREFULL WITH THIS R THING!!!!!
                r = true
              }
            }
          }
        }
      }
      if (obj.val) {
        rt = _coreSet.call(this, obj.val, stamp, false, true)
        if (!r) {
          r = rt
        }
        if (!rt) {
          obj.val = void 0
        }
      } else if (!stop) {
        if (!r) {
          r = false;
        }
      }
      r = (r !== false) || r
    }

    if (r) {
      if (!block) {
        // alert(noupdate)
        if (noupdate) {

          // console.log('!!??????????? NOUPDATE'.blue, JSON.stringify(obj))

          if(topLevel) {
            // console.log('UPDATE>?'.magenta.inverse, obj, JSON.stringify( obj ), noupdate, stamp)
            this._update(obj, stamp)
          }
          else {
            this.__update(obj, stamp)
            deferUpdates.push([ this, obj ])
          }
        } else {
          
          // console.log('2UPDATE>?'.cyan.inverse, topLevel, deferUpdates, obj, noupdate, stamp)

          this._update( obj, stamp )
        }
      }
    }
   

    if(topLevel && deferUpdates) {
      // console.log( 'defered updace', topLevel, deferUpdates)
      for(var df in deferUpdates) {
        if( deferUpdates[df][0] && deferUpdates[df][0].__update ) {
          // console.log('DEFERED!!!!'.cyan.inverse, df, deferUpdates[df][1], stamp )
          deferUpdates[df][0].__update( deferUpdates[df][1], stamp )
        }
      }
    }
    return r
  },
  /**
   * Copies an object and returns a new one, can also pass a merge object
   * @method
   * @param  {Object}        obj       Object to copy
   * @param  {Boolean}       [shallow] [description]
   * @param  {Array|Object}  [list]    Takes any object with .length
   * @param  {Object}        [parent]  [description]
   * @return {Object}                  [description]
   */
  'clone', function(obj, shallow, list, parent) { //support shallow!; check obj copy only what is nessecary added makeshort , made parent shorter
    var copy = new this._class(),
      _val = this._val,
      i;
    if (parent) {
      copy._parent = parent;
    }
    copy.__t = this.__t;
    if (this.__t === 1) {
      copy.length = this.length;
    }
    if (list) {
      //list
      for (var j = list.length - 1, item; j >= 0; j--) {
        item = list[j];

        if (item instanceof Array && this[item[0]]) {
          if(item[1] === true) {
            copy[item[0]] = util.clone(this[item[0]], false, true)
          } else {
            copy[item[0]] = item[1];
          }
        } else if (this[item]) {
          // console.log(item)
          copy[item] = this[item];
        }
      }
    }
    if (_val && (_val instanceof VObject && _val._contained)) {
      copy.val = _val.clone(copy, false, list, copy);
      copy._val._contained = true;
    } else {
      VObject.set.call(copy, _val, false, false, true);
    }
    for (i in this) {
      if (!_c(this._blacklist, i)) {
        // console.log(i)
        if (!shallow) {
          if (this[i] instanceof VObject) {
            //function( name, val, vobj, stamp, noupdate, from )

            // console.log('----->1', i, this[i].clone(void 0, false, list, copy))
            //stamp void 0
            copy.set(i, this[i].clone(void 0, false, list, copy), true, false, true)
          } else {

            // console.log('----->2', i, util.clone(this[i]))

            copy[i] = util.clone(this[i]);
          }
        } else {
          //function( name, val, vobj, stamp, noupdate, from )
          copy.set(i, this[i], false, false, true);
        }
      }
    }
    if (obj !== void 0) {
      if (util.isObj(obj)) {
        // console.log('MERGE----->', obj, shallow)
        copy.merge(obj, shallow);
      } else {
        VObject.set.call(copy, obj, false, false, true)
      }
    }
    copy.__t = this.__t;
    return copy;
  },
  /**
   * Returns object on the end of a defined path
   * @method path
   * @param  {Array}     path           Array of fields in path
   * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
   * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
   * @param  {Function}  [writeHandler] Callback on write
   * @return {*}                        Object on the end of a defined path
   */
  'path', function(path, val, overwrite, writeHandler, vobj, stamp, noupdate, self) {
    if(!(path instanceof Array)) path = path.split('.');
    return util.path(this, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self);
  },
  /**
   * Gets object from specified path. When path is a string checks for 'dotnotation'.
   * @method get
   * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
   * @return {*}                 obj[path]|nested object/value
   */
  'get', function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },

  //(val, stamp, from, noupdate, add)
  // '$set', function( val, stamp, from, update ) { //get does not need an array as path

  //   return VObject.set.call( this, val, stamp, from, !update )
    
  //     '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //   if (!noupdate) {
  //     (val, stamp, from, noupdate, add)
  //     // console.log(this._path, val)
  //     this._update(val, stamp, from, remove, added, oldval);
  //   }
    

  // },
  /**
   * Check if obj is empty exclude field names passed to list
   * @method empty
   * @return {Boolean} True/false
   */
  'empty', {
    get: function() {
      return util.empty(this, this._blacklist);
    }
  },
  '$empty', function( excludes, update ) {
      //get does not need an array as path
      var _this = this
      this.each( function( key ) {
        if( 
            !excludes 
              || typeof excludes === 'string'  
                 ? key !== excludes 
                 : !util.checkArray( excludes, key ) 
          )
        {
          if( this.remove ) 
          {
            this.remove( false, false, false, false, false, true )
          } 
          else 
          {
            // console.warn( '$empty non-vObject object.util remove', this, key )
            _this[key] = null
          }
        }
      })
    
      if( this.clearCache ) this.clearCache()

      if( update )
      {
        this._update('empty')
      }
  },
  /**
   * Returns the V.Object from which the current update originated.
   * @method _updateOrigin
   * @return {V.Object} origin of the update
   */
  '_updateOrigin', {
    get: function() {
      var mark = this;
      // console.error('get UPDATE ORIGIN', this._path, this._lfrom)
      while (mark._lfrom) {

        //if V.CloudData
       // console.error( '_update that origin!', mark._path )
        mark = mark._lfrom;
      }
      return mark;
    }
  },
  '_origin', {
    get: function() {
      var mark = this;
      while (mark && mark.__t === 4) {
        mark = mark._val;
      }
      return mark;
    }
  }
)


//add find


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js":[function(require,module,exports){
(function (__dirname){
var util = require('../')
  , ajax
  , PACKAGE = '/package.json'

module.exports = exports = function( callback, params, packageFile, noReplace ) {

  packageFile = packageFile || ( util.isNode ? {} : window.package )

  var obj = {}
    , req = module.exports
    , cb = callback && function( pckg ) {

      obj = pckg.vigour
      req.parse( obj, packageFile, req._checks )

      if(!noReplace) module.exports = obj
      callback(obj)
    }

  //default option add more!
  if(!params) {
    exports.options.val(obj, cb, false, packageFile )
  } else if(exports.options[params]) {
    exports.options[params](obj, cb, false, packageFile )
  } else {
    exports.options.val(obj, cb, params, packageFile )
  }
  return obj
}

if(util.isNode) {
  exports.options = {
    val:function( obj, callback, params, pckg ) {
      callback( pckg )
    }
  }
} else {
  ajax = require( '../../browser/network/ajax' )
  exports.options = {
    val:function(obj, callback, params) {
      if( !window.package ) {
        var domain = !window.cordova && String(window.location)
            .match(/https?:\/\/([^\/]+)/)

        if(domain) domain = domain[0]
         
        ajax({
          url:params && params.url ? params.url : domain+PACKAGE,
          fallback: [
              { url: PACKAGE } //for testing
            , params && params.fallback ? params.fallback : { url: __dirname+PACKAGE }
            , { url: '../'+PACKAGE }
            , { url: '../../'+PACKAGE }
            , { url: '../../../'+PACKAGE }
          ],
          complete:function(data) {
            window.package = data
            if(callback) callback(data)
          }
        })
      } else if(callback) {
        callback(window.package)
      }
    }
  }
}

exports.inject = function() {
  exports._checks = util.arg(arguments)
  return exports
}

exports.loop = function(obj, option, pckgval, merge, fn, params ) {
  if(fn) {
    var val = option(obj,pckgval,merge, params)
    if(val) { util.merge(obj,val) }
  } else {
    for(var h in obj[option]) {
      if((pckgval===h)) {
        util.merge(obj,merge[h])
        break
      }
    }
  }
}

exports.parse = function( obj, pckg, options, params ) {
 if(!(options instanceof Array)) {
    options = [options]
 }

 for(var i in options) {
    for(var check in options[i]) {
      var pckgval = util.get(pckg,check)
        , option = options[i][check]

      exports.loop(obj, option, pckgval, obj[options[i][check]], typeof option === 'function',params)
    }
  }
  return obj
}

}).call(this,"/node_modules/vigour-js/util/config")

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../browser/network/ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/ua.js":[function(require,module,exports){
var ua = require('../../browser/ua')
  , util = require('../')
  , Data = require('../../data').inject(require('../../data/selection'))
/*
selection!

*/
bla = exports

exports.parse = function(obj, pckgval, merge, params) {
  var _ua = ua

  if(params && params.ua) {
    _ua = ua.parse(params.ua.toLowerCase(),{})
  }

  // console.log('HERE!',obj,pckgval,merge)
  var cond
    , uaclone = new Data({bla:util.clone(_ua)})

  if(obj.ua) {
    for(var i in obj.ua) {
      if(_ua.platform===i||_ua.device===i||_ua.browser===i) {
        return obj.ua[i]
      } else if(obj.ua[i].condition) {
        if(!cond) {
          cond = new Data(uaclone, obj.ua[i])
        } else {
          cond.filter = obj.ua[i]
        }
        if(cond.length) {
          delete obj.ua[i].condition
          cond.remove()
          return obj.ua[i]
        }
      }
    }
  }


  //blabla

  // console.log('SUBOBJ???',obj)


  delete obj.subsObj

  if(cond) cond.remove()
}


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js":[function(require,module,exports){
(function (process){
var debug = exports

DEBUG$ = debug

/*
  console.log('util/test \n\nif you want to check memory usage start chrome using: \n\n open -a Google\\ Chrome --args --enable-memory-info \n')
*/
var util = require('../')
  , isNode = util.isNode //has to become part of util
  , V = require('../../')
  , log = debug.log = require('./log')
  , debuglog = log.logger('DEBUG$', 'rainbow')

debug.perf = debug.performance = require('./performance')

//------------------------------------------------------------------------------

if(!isNode) {
  debug.cases = require('../../browser/cases/')
  exports.body = document.body.base
  Object.defineProperty(module.exports, 'domain', {
    get: function() {
      //debugger --- can go away with a transform
      return String(window.location)
        .match(/https?:\/\/([^\/]+)/)[1]
        .replace(/:.+/, '')
    }
  })

} else {
  var DEBUG = process.env.DEBUG
  if(DEBUG){
    var levels = DEBUG.split(',')
    for(var l in levels){
      var two = levels[l].split(':')
      DEBUG$.level[two[0]] = two[1] ? Number(two[1]) : 3
    }
  }
}

//------------------------------------------------------------------------------

exports.int = function(rand, fn) {
  function func() {
    rand = rand||1000
    return ~~(Math.floor(Math.random()*rand))
  }
  return fn ? func() : func
}

exports.text = function (length, fn, str, nolines, strict) {
  if (fn) {
    return function() {
      return exports.text(
        Math.round(Math.random() * length) + 1, false, str, nolines, strict
      )
    }
  }
  else {
    var s = ['.', '.', '.', ';', ',']
      , b = ['ab', 'able', 'zo', 'x', 'lax', 'bur', 'rem', 'lur', 'fur', 'jur', 'lex', 'rex', 'wurd',
        'shur', 'burn', 'heps', 'a', 'i', 'y', 'u', 'e', 'p', 'l', 'splurf']
      , output = ''
      , nospace = 0

    if (str) b = str

    str = function () {
      return b[Math.round(Math.random() * (b.length - 1))]
    }
    if (!length) length = ~~ (Math.random() * 101)
    for (var i = 0, g; i < length; i++) {
      if ( !strict && (!output[output.length - 1]
        || output[output.length - 2] === '.'
        || output[output.length - 2] === '\n')
      ) {
        g = str()
        output += g[0].toUpperCase() + g.slice(1)
      }
      else {
        output += str()
      }
      nospace++
      if (!strict && ~~(Math.random() * (nospace / 2))) {
        var br = false
          , v
        if (!nolines && ~~(Math.random() * 21) > 17) {
          v = s[~~(Math.random() * (s.length - 1))]
          output += v
          if (v === '.' && ~~(Math.random() * 11) > 6) {
            br = true
            output += '\n'
            if (~~(Math.random() * 11) > 7) output += '\n';
          }
        }
        if (!br) output += ' '
        nospace = 0
      }
    }
    return output
  }
}

exports.data = function (populate, level, obj, cnt, prev) {
  if (!obj) obj = {}
  if (!cnt) cnt = 0
  if (!level) level = 0
  for (var i in populate) {
    if ((populate[i] instanceof Object)
      && populate[i].length && populate[i].val
    ) {
      if (populate && populate[i]) {
        obj[i] = []
        for (var j = 0; j < populate[i].length; j++) {
          obj[i][j] = typeof populate[i].val === 'function'
            ? populate[i].val()
            : exports.data(populate[i].val, (level + 1), false, j + 1, obj)
        }
      }
    }
    else if ((populate[i] instanceof Object)
      && (typeof populate[i] !== 'function')
    ) {
      obj[i] = exports.data(populate[i], (level + 1), obj[i], false, cnt, obj)
    }
    else if (populate && populate[i]) {
      obj[i] = (typeof populate[i] === 'function')
      ? populate[i].call(obj, cnt, prev)
      : populate[i];
    }
  }
  return obj;
};

//------------------------------------------------------------------------------
debug.download = function(filename, text) {
  var pom = document.createElement('a');
  pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  pom.setAttribute('download', filename);
  pom.click();
}

//------------------------------------------------------------------------------
debug.remote = function(id) {
  var fileref = document.createElement('script')
  fileref.setAttribute("type", "text/javascript")
  fileref.setAttribute("src", 'http://jsconsole.com/remote.js?'+id)
  document.getElementsByTagName("head")[0].appendChild(fileref)
}

debug.findScript = function(node,name,strict) {

  var children = node.childNodes
    , extension = name.match(/\.([a-zA-Z0-9]{1,30})$/)[1]
    , regExp = !strict && new RegExp(name+'$')
    , field = extension === 'js' ? 'src' : 'href'

  for(var i in children) {

    if(strict ? children[i][field]===name : regExp.test(children[i][field])) {
      return children[i]
    }

  }

  // console.log('notfound', name)
}

function prompty (msg, value, cb) {
    var dialog = document.createElement("div")
        , p = document.createElement("p")
        , input = document.createElement("input")
        , ok = document.createElement("button")
        , cancel = document.createElement("button")
    p.appendChild(document.createTextNode(msg))
    input.type = "text"
    input.value = value
    input.style.display = "block"
    ok.appendChild(document.createTextNode("OK"))
    cancel.appendChild(document.createTextNode("Cancel"))
    ok.addEventListener('click', function () {
        hideDialog()
        cb(input.value)
    })
    cancel.addEventListener('click', function () {
        hideDialog()
        cb(null)
    })
    dialog.appendChild(p)
    dialog.appendChild(input)
    dialog.appendChild(ok)
    dialog.appendChild(cancel)
    dialog.style.position = "absolute"
    dialog.style.top = 25 + "px"
    dialog.style.left = 50 + "px"
    dialog.style.zIndex = 1000
    dialog.style.fontSize =  24 + 'px'
    dialog.style.backgroundColor = "white"
    document.body.appendChild(dialog)
    function hideDialog() {
        dialog.parentNode.removeChild(dialog)
    }
}

debug.native = function(def, parse, cb, file) {
  if(!document.getElementById('dev')) {
    var elem = document.createElement('div')
    elem.id = 'dev'
    elem.style.zIndex = 9999999
    elem.style.position = 'absolute'
    elem.style.left = '2px'
    elem.style.top = '80px'
    elem.style.padding = '15px'
    elem.style.backgroundColor = 'rgba(50,50,50,0.8)'
    elem.style.borderRadius = '50%'
    elem.addEventListener('click',function() {
      prompty('IP', localStorage.getItem('devip') || def || 'http://10.0.1.2:8080', function (ip) {
        if (ip) {
          localStorage.setItem('devip',ip)
           window.location.reload()
        } else {
          // alert('x')
          localStorage.removeItem('devip')
          window.location.reload()
        }
      })
    })
    document.body.appendChild(elem)
  }

  if(!file) {
    file = 'build'
  }

  if( localStorage.getItem('devip') ) {
    DEBUG$.remoteResource(localStorage.getItem('devip')+'/bundle.css',file+'.css',false)
    if(DEBUG$.remoteResource(localStorage.getItem('devip')+'/bundle.js',file+'.js',false)) {
      document.getElementById('dev').style.backgroundColor = 'rgba(0,255,0,0.8)'
      if(cb) cb(localStorage.getItem('devip'))
      return true
    } 
  }
}

//hier remoteresource gebruiken
debug.remoteResource = function(src, replace, strict) {
  console.log('remote resource',src)
  var strict = strict !== void 0 ? strict : true
    , extension = src.match(/\.([a-zA-Z0-9]{1,30})$/)[1]
    , fileref = document.createElement(extension==='js' ? 'script' : 'link')
    , head =  document.getElementsByTagName("head")[0]
    , body = document.body
    , found
    , fileSrc

  if(!replace) {
    strict = false
    replace = src.match(extension==='js'
      ? /(\/)([a-zA-Z0-9-_+$]){0,30}\.js$/
      : /(\/)([a-zA-Z0-9-_+$]){0,30}\.css$/
    )[0].slice(1)


  }

  fileSrc = src+'?'+ ~~(Math.random()*9999999)

  if(extension==='js') {
    fileref.setAttribute("type", "text/javascript")
    fileref.setAttribute("src", fileSrc)
  } else {
    fileref.setAttribute("type", "text/css")
    fileref.setAttribute("rel", "stylesheet")
    fileref.setAttribute("href", fileSrc)
    fileref.setAttribute("id", fileSrc)
  }

  found = debug.findScript(head,replace,strict)

  if(!found) {
      console.log(body, found, '!@!@#!@#JS')

    found = debug.findScript(body,replace,strict)
  }
  if(found) {

    console.log('remote resource found:',found, found.src , fileSrc, src)

    var parent = found.parentNode
    if(String(found.src).indexOf(src)>-1) {
      return
    }

    parent.removeChild(found)
    parent.appendChild(fileref)
    return true
  }
}

}).call(this,require('_process'))

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../browser/cases/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","./log":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/log.js","./performance":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/performance.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/log.js":[function(require,module,exports){
var debug = require('./') 
  , util = require('../') 
  , isNode = util.isNode //has to become part of util
  , V = require('../../')
  , repl
  , colors
  , origConsole = console
  , colors = {
      green:'#56db68',
      red:'#ff0000',
      grey:'#ccc',
      yellow:'#e0e67c',
      cyan:'#00ffff',
      magenta:'#ff00ff',
      blue:'#1111ff',
      white:'#fff'
    }
  , styles = {
      bold:'font-weight:bold;font-size:16px;line-height:15px',
      underline:'border-bottom:1px solid',
      italic:'font-style:italic',
      inverse:function(color) {
        if(color) {
          return color+';background-color:#333;padding:5px;line-height:20px'
        } else {
          return 'color:'+colors.white+';background-color:#333;padding:5px;line-height:20px'
        }
      }
    }

debug.level = 
{ DEBUG$: Infinity
, test:2
}



/*
bold
italic
underline
inverse
yellow
cyan
white
magenta
green
red
grey
blue
rainbow
zebra
random
*/

//------------------------------------------------------------------------------

var logObject
  , parseObject
  , LOG
  , INFO
  , ERROR
  , DETAIL

if (!isNode) { 

  LOG = ':'
  INFO = '::'
  ERROR = 'ERREX!'
  DETAIL = ':::'

  // console = {}
  function loglink(i) {
    return function() {
      // console.log(i, arguments)
      // console.log(new Error().stack)

      origConsole[i].apply(origConsole, arguments)
    }
  }

  // for(var i in origConsole) {
  //   if(i !== 'log') console[i] = loglink(i)
  // }

  var Color = function(val,code,s) {
    this.color =  (s ? code : 'color: '+code)+';'
    this.val = new String('%c'+val)
  }
  
  // console.log = function() {

  //   var next = false

  //   for(var i=0, arg, rargs=[], args = arguments,len = args.length;i<len;i++) {
  //     arg = args[i]
  //     if(arg instanceof Color) {
  //       if(rargs.length){
  //         next = util.arg(args, i)
  //         break
  //       }else{
  //         rargs.push(arg.val.valueOf(), arg.color)
  //       }
  //       // logger(arg.val.valueOf(), arg.color)
  //     } else {
  //       rargs.push(arg)
  //     }
  //   }
  //   // logger('now log', rargs)
  //   if(rargs.length) logger.apply(origConsole,rargs)
  //   // logger('next', next)
  //   if(next.length) console.log.apply(null,next)

  // }

  function color(i, Class, style) {
    util.define(Class || String,i,{
      get:function() {
        if(Class) {
          if(typeof style === 'function') {
            this.color = style(this.color)
          } else {
            this.color+=(style||('color:'+colors[i]))+';'
          }
          return this
        } else {
          var s = colors[i]
          if(style) {
            if(typeof style === 'function') {
              s = style()
            } else {
              s=style
            }
          }
          return new Color(this,s,style)
        }
      }
    })
  }

  // function logger() {


  //   origConsole.log.apply(origConsole,arguments)


  // }

  // for(var i in colors) { color(i) }
  // for(var i in styles) { color(i, false, styles[i]) }  
  // for(var i in colors) { color(i, Color) }
  // for(var i in styles) { color(i, Color, styles[i]) }  

  parseObject = function(obj) {
    if(typeof obj === 'string') return obj
    var str = ''
    for(var i in obj) {
      str += i + ' : ' + (typeof obj[i] === 'string' 
        ?  obj[i] 
        : JSON.stringify(obj[i],false,2)) 
      + '\n'
    }
    return str.inverse.green
  }
  
  logObject = function(obj) {
    console.log(parseObject(obj))
  }
  
} else {
  repl = require('repl')
  colors = require('colors')

  LOG = 'log  '.grey
  INFO = 'info '.green
  ERROR = 'error'.red
  DETAIL = '-----'.grey

  debug.repl = function() {
    repl.start('>')
    return debug
  }
  if(repl.context) repl.context.DEBUG$ = DEBUG$

  console.group = function() {
    console.log('\n____________________________________________________'.grey)
  }      
  console.groupEnd = function() {
    console.log('____________________________________________________\n'.grey)
  }
  var n_util = require('util')
  parseObject = function(obj){
    return n_util.inspect(obj,{colors:true, depth: 50})
  }
  logObject = function(obj){
    console.log(parseObject(obj))
  }
}

//------------------------------------------------------------------------------

util.define(Object,'DEBUG$log', function(msg,s) {
  if(console.group) console.group()
  if(typeof msg === 'string') {
    msg = msg
  } else {
    msg = false
  }
  var h = 'JSON '+(msg||' normal')
  debug.log.header(h)
  if(debug.level.test>1) console.log(JSON.stringify(this,false,2))
  if(s) {
    console.log('\n')
    debug.log.fn.apply(this,util.arg(arguments,1)) 
  }
  // debug.log.end(h)
  if(console.group) console.groupEnd()
  return JSON.stringify(this,false,2)
})

if(!isNode && localStorage) {
  util.define(localStorage,'DEBUG$log', function(msg,s) {
    if(console.group) console.group()
    if(typeof msg === 'string') {
      msg = msg
    } else {
      msg = false
    }
    var h = 'localStorage '+(msg||' normal')
    debug.log.header(h)

    var obj = {}
    for(var i in this) {
      // console.log(i, this)
       try { obj[i] =JSON.parse(this[i]) } catch(e){
        obj[i] = this[i]
       }
    }

    // console.log()

    if(debug.level.test>1) console.log(JSON.stringify(obj,false,2))
    if(s) {
      console.log('\n')
      debug.log.fn.apply(this,util.arg(arguments,1)) 
    }
    // debug.log.end(h)
    if(console.group) console.groupEnd()
    return obj
  })
}

//------------------------------------------------------------------------------

var log = module.exports = exports = {
  stack: false,
  i:function(nr) {
    nr = this.indent
    var str = ''
    for(var i in nr) {
      str+='  '
    }
    return str
  },
  parse: parseObject,
  object: logObject,
  default: function(label, level){
    if(label instanceof Object)
      for(var l in label)
        setDefault(l, label[l])
    else
      setDefault(label, level)
  },
  logger:function(label, color, level){
    log.default(label, level || 1)
    
    function logger(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 2) {
//         console.log.apply(null, [label[color].bold, LOG].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
    }

    logger.info = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 1) {
        console.log.apply(null, [label[color].bold, INFO].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
        
    }
    logger.error = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 0) {
        console.log.apply(null, [label[color].bold, ERROR].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
    }
    logger.detail = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 3) {
        console.log.apply(null, [label[color].bold, DETAIL].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }      
    }
    logger.parse = parseObject
    return logger
  },
  label: function(label, style, log){
      if(isNode) {
        console.log.apply(null, log)
      } else {
        console.log.apply( null
          , ['%c '+label+' ', style].concat(log)
        )
      }
  },
  header:function(msg) {
    this._lh = msg
    console.log(msg.inverse)
  },
  header2:function(msg) {
    this._lh = msg
    console.log(msg.grey.inverse)
  },
  end:function(msg) {
    console.log(('end ['+msg+']').grey.inverse)
  },
  level:function(level,field) {
    if(level >= debug.level.test 
      ||  debug.level[level] 
      || field && debug.level[level]>=field ) 
      console.log.apply(this,util.arg(arguments,1))
  },
  fn:function(arg) {
    debug.log.indent++
    if(typeof arg === 'function') {
      arg.call(this,util.arg(arguments,1))
    } else {
      console.log(arguments)
//       console.log.apply(this,arguments)
    }
    debug.log.indent--
  },
  indent:0
}

//------------------------------------------------------------------------------
function smallStack(lines){
  if(!lines) lines = 1
  var stack = new Error().stack.split('\n')
    , l = 3
    , result = []
    , end

  while(lines--){
    line = stack[l++]
    end = line[line.length-1] === ')' ? line.length-1 : line.length
    result.push(line.slice(line.indexOf('/'), end))
  }

  return result.join('\n').grey
  
}

function setDefault(label, level){
  if(debug.level[label] === void 0) debug.level[label] = level
}

setTimeout(function() {
//   console.log('log levels:\n', log.parse(debug.level))
},0)

//Localstorage

/*
var localStorageSpace = function(){
        var allStrings = '';
        for(var key in window.localStorage){
            if(window.localStorage.hasOwnProperty(key)){
                allStrings += window.localStorage[key];
            }
        }
        return allStrings ? 3 + ((allStrings.length*16)/(8*1024)) + ' KB' : 'Empty (0 KB)';
    };

*/

util.define(debug,'localStorageSize', {
  get:function() {
  var total = 0
  for(var x in localStorage) {
    var kbytes = (((x.length+localStorage[x].length))/(1024))
    total+=kbytes
    // console.log((x+":"+kbytes.toFixed(10)+" KB").grey)
  }
  console.log('LOCAL STORAGE SIZE TOTAL'.inverse.green, (total/1024).toFixed(5)+' MB')
  return total*1024
}
})

util.define(debug,'localStorageKeysSize', {
  get:function() {
  var total = 0
  for(var x in localStorage) {
    var kbytes = (((x.length))/(1024))
    total+=kbytes
    // console.log((x+":"+kbytes.toFixed(10)+" KB").grey)
  }
  console.log('LOCAL STORAGE KEY SIZE TOTAL'.inverse.green, (total/1024).toFixed(5)+' MB')
  return total*1024
}
})



},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js","colors":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/colors/colors.js","repl":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js","util":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/performance.js":[function(require,module,exports){
(function (process){
var util = require('../') 
  , debug = require('./') 
  , isNode = util.isNode //has to become part of util
  , os

if (isNode) { 
  os = require('os')
} else {
  console.log('DEBUG \n\nif you want to check memory usage start chrome using: \n\n open -a Google\\ Chrome --args --enable-memory-info --js-flags="--expose-gc"\n'.grey)
}

function _test(method, name, complete, call, args, nolog) {
  var start = exports.now()
    , memorystart = exports.memory()
    , memoryend
    , mem
    , time
    , end
    , sub 
  if (!name) name = 'TEST PERFORMANCE'
  if (call) {
    sub = method.apply(call, args)
  } 
  else {
    sub = method.apply(this, args)
  }
  end = exports.now()
  memoryend = exports.memory()
  mem = (memoryend - memorystart)
  time = end - start - (sub || 0)
  if (complete) {
    complete(((time) / 1000), (memoryend - memorystart))
  } 
  else if (!nolog) {
    if(debug.level.test>0) {
      console.log( 
        name.inverse , '\nparse time: ' 
        + ((end - start) / 1000) 
        + ' sec' + (mem ? '\nmemory used (approximate): ' 
        + mem + ' bytes' : '')
      )
    }
  }
  return time
}



var oldCheck = []
debug.countNewListeners = function( obj, amount ) {
  
  amount = {val:0}

  var checknow = []

  debug.countListeners( obj, amount, checknow ) 

  var newlistners = []

  for( var i in checknow ) {

    if( util.checkArray( oldCheck, checknow[i] ) === false ) {
      // console.log(checknow[i])
      // if( typeof checknow[i] === 'object' || typeof checknow[i] === 'function' ) {
        // console.log('lets push')
        // if(!util.empty(checknow[i])) {
        newlistners.push( checknow[i] )
        // }
      // }
    }
  }

  oldCheck = checknow

  return {
    amount: amount.val
  , newchecks: newlistners
  }

}


debug.countListeners = function(obj, amount, checked) {
  var amount 
    , checked 

  if(!checked) {
    checked = []
  }

  if(util.checkArray(checked, obj)!==false || !obj) {
    return amount.val
  }
  checked.push(obj)

  if(!amount) amount = {val:0}
  if(obj._listeners) {
    amount.val+=obj._listeners.length
  }

  if(!obj.each) {

    if(obj instanceof Object) {
      for(var i in obj) {
        if(obj[i] && ( obj[i].__t || obj[i]._from || obj._from && i ==='cloud') ) debug.countListeners(obj[i],amount,checked)
      }
    }

  } else {

    obj.each(function(i) {
      debug.countListeners(this,amount,checked)
    })

  }

  return amount.val
}

debug.countSubs = function(obj, amount, key) {
  var amount 
  if(!amount) amount = {val:0}
  if(obj._subs) {
    console.log('!!!!!SUB', obj._path, obj._subs)
    amount.val+=obj._subs.length
  }
    
  if(!obj.each) {
    console.log('no EACH!', key)
  }
  // console.log(obj, obj._subs)
  obj.each(function(i) {
    debug.countSubs(this,amount,i)
  })
  return amount.val
}

function _done(params, time, mem) {
  if (params.complete) {
    params.complete(time, mem, params, exports.average(time)[0], exports.average(time)[1])
  } else {
    if(debug.level.test>0) {
      console.log(
        params.name.inverse 
        , ' n=' + params.loop 
        + '\nparse time:' 
        + (params.extensive 
          ? (' \n\n' + time.join(' sec\n') + ' sec\n\n') 
          : '') 
        + 'average: ' + exports.average(time)[1] 
        + ' sec\ntotal: ' 
        + exports.average(time)[0] + ' sec')
    }
    //+(mem.length>0 ? '\nmemory used (approximate): '+mem+' kb' : '');
  }
}

module.exports = exports = function (params, fn) {
  if (fn && typeof params === 'string') {
    return _test(fn, params)
  } 
  else if (typeof params === 'function') {
    return _test(params)
  } 
  else if (params instanceof Object) {
    if(!params.name) params.name = 'performance test'

    if (params.loop) {
      //testing memory in loop is hard since the gc almost never makes it before next iteration;
      var time = []
        , mem = []
        , callback = function (_time, memory) {
          time.push(_time)
          if (memory) mem.push(memory)
        }

      if(params.interval) {
        var cnt = 0
          , interval = setInterval(function() {
              cnt++
              if(cnt===params.loop-1) {
                 clearInterval(interval)
                 _done(params, time, mem) 
              } else {
                _test(params.method, false, callback)
              }
            },params.interval)
      } else {
        for (var i = params.loop; i > 0; i--) {
          _test(params.method, false, callback)
        }
        _done(params, time, mem) 
      } 
      return exports.average(time)
    } 
    else {
      return _test(params.method
        , params.name
        , params.complete
        , params.call
        , params.args
        , params.nolog)
    }
  }
}

if(debug.log) debug.log.default('test', 4)

exports.now = function () {
  return isNode
    ? process.hrtime()[0] * 1000 + process.hrtime()[1] * 0.000001 
    : (window.performance && window.performance.now 
      ? window.performance.now() 
      : new Date().getTime())
}

exports.memory = function () {
  return isNode 
    ? process.memoryUsage().heapUsed 
    : (window && window.performance && window.performance.memory 
      ? window.performance.memory.usedJSHeapSize * 0.000976562 
      : 0)
}

exports.average = function (array) {
  var number = 0
  for (var i = array.length - 1; i >= 0; i--) {
    number += array[i]
  }
  return [number, number / array.length]
}

}).call(this,require('_process'))

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","os":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/os-browserify/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/global.js":[function(require,module,exports){
(function (process,global){
var g = typeof window !== 'undefined'
        ? window
        : typeof global !== 'undefined'
          ? global
          : false
  , hasLS = typeof localStorage !== 'undefined'
  , hasPR = typeof process !== 'undefined'

var G = module.exports = 
  { session: function(key, val){
      return getSet(g, key, val)
    }
  , env: function(key, val){
      if(hasLS)
        return getSet(localStorage, key, val, 'getItem', 'setItem')
      else if(hasPR)
        return getSet(process.env, key, val)
    }
  }

function getSet(thing, key, val, getter, setter){
  if(!thing)
    return

  if(val === void 0){
    if(getter)
      return thing[getter](key)
    else
      return thing[key]
  }else{
    if(setter){
      thing[setter](key, val)
      return val
    }else{
      return thing[key] = val
    }
  }
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js":[function(require,module,exports){
//check this for more compression http://www.htmlgoodies.com/html5/client/optimizing-websockets-bandwidth.html#fbid=6QZx8napu20

/*
var crcTable
  , create = function () {
      crcTable = []
      for (var c, n = 0, k; n < 256; c = ++n) {
        for (k = 0; k < 8; k++, c = ((c & 1) ? ((0xEDB88320) ^ (c >>> 1)) : (c >>> 1)));
        crcTable[n] = c
      }
      return crcTable
    }

exports = module.exports = function (str) {
  for (var tab = crcTable || create(), crc = -1, i = 0, l = str.length; i < l; i++) {
    crc = (crc >>> 8) ^ tab[(crc ^ str.charCodeAt(i)) & 0xFF]
  }
  return exports.encode(((crc ^ (-1)) >>> 0))
}


*/

exports = module.exports = function(key, seed) {
  var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;
  seed = 1

  remainder = key.length & 3; // key.length % 4
  bytes = key.length - remainder;
  h1 = seed;
  c1 = 0xcc9e2d51;
  c2 = 0x1b873593;
  i = 0;
  
  while (i < bytes) {
      k1 = 
        ((key.charCodeAt(i) & 0xff)) |
        ((key.charCodeAt(++i) & 0xff) << 8) |
        ((key.charCodeAt(++i) & 0xff) << 16) |
        ((key.charCodeAt(++i) & 0xff) << 24);
    ++i;
    
    k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

    h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
    h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
    h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
  }
  
  k1 = 0;
  
  switch (remainder) {
    case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
    case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
    case 1: k1 ^= (key.charCodeAt(i) & 0xff);
    
    k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= k1;
  }
  
  h1 ^= key.length;

  h1 ^= h1 >>> 16;
  h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
  h1 ^= h1 >>> 16;

  return (h1 >>> 0).toString(36)
}

// exports = module.exports = function( str )
// {
//   var FNV1_32A_INIT = 0x811c9dc5;
//   var hval = FNV1_32A_INIT;
//   for ( var i = 0; i < str.length; ++i )
//   {
//     hval ^= str.charCodeAt(i);
//     hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
//   }
//   return hval >>> 0;
// }

/**
 * Encode to base 62 (url save)
*/
exports.encode = function c (a, b) {
  b = b || ""
  return ~~ a 
       ? c(a / 62, String.fromCharCode(((a %= 62) > 9 
          ? a > 35 ? 29 : 87 
          : 48) + a) + b) 
       : b
}

/**
 * decode base 62
*/
exports.decode = function (a, b, c, d) {
  for (b = c = 0; d = a.charCodeAt(c++); b = b * 62 + d - [ , 48, 29, 87][d >> 5]);
  return b
}


// exports.decode64

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js":[function(require,module,exports){
module.exports = function id(pre, level){
  var r = rnd()
  if(level) 
    while(level--){
      r += rnd()
    }
  return pre ? pre + r : r
}

function rnd(){
  return Number(String(Math.random()).slice(2)).toString(36)
}
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
require('./object') //these things add extra methods to util for readability in a seperate module
require('./prop')


exports.isNode = (typeof window === 'undefined') ? true : false

/**
 * Add is similar to .push it returns the array instead of length
 * Can be extended to support more types e.g. add an object to another
 * @method add
 * @param  {Array}  obj Target
 * @param  {Object} add Object to add
 * @deprecated
 */
exports.add = function (obj, add) {
  if (add) obj.push.apply(obj, add);
  return obj
}

/**
 * Finds items in an array
 * @method checkArray
 * @param  {Object|Array}                 list  Defines the list where you want to search through, only uses .length field
 * @param  {Object}                       val   Defines the value you want to search for
 * @param  {Boolean|String|Number}        [index] When index is true return the index instead of true or false, when index and index !== true index is used as a field in objects in the array
 * @param  {String}                       [field] When field return field instead of index or true
 * @return {*}
 */
exports.checkArray = function (list, val, index, field) {
  var arr = index instanceof Array
  if(!list) return false
  for (var i = 0, l = list.length, t; i < l; i++) {
    t = list[i]
    if (index !== void 0) {
      if (index === true) {
        if (t === val) return i
      } else if (arr ? exports.path(t,index)===val : t[index] === val) return field ? t : i
    } else {
      if (t === val) return true
    }
  }
  return false
}

/**
 * Pass arguments (arguments) and return a new array, when index return a new array sliced from index
 * @method arg
 * @param  {Arguments} args        Arguments
 * @param  {Number}    [index = 0] When index return a new array sliced from index
 * @return {Array}
 */
exports.arg = function (args, index) {
  return Array.prototype.slice.call(args, !index ? 0 : index)
}

/**
 * Check if obj is empty exclude field names passed to list
 * @method empty
 * @param  {Object}       obj  Object
 * @param  {Object|Array} list Takes any object with .length
 * @return {Boolean}           True/false
 */
exports.empty = function (obj, list) {
  for (var i in obj) {
    if (!list || !this.checkArray(list, i)) return false
  }
  return true
}

exports.inject = require('./inject')

},{"./inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js","./prop":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/prop.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js":[function(require,module,exports){

var V = require('../')
  , util = require('./')

var $TEST
if(!util.isNode) {
  $TEST = window.$TEST
}



module.exports = exports = function(extend) {

  var args = arguments

  if(args[0]&&args[0].$TEST) {
     $TEST = window.$TEST = true
  }

  if( (typeof this === 'function') || (V.Base && (this instanceof V.Base)) || typeof this === 'object') {
    if((V.Base 
        && (this===V.Base 
        || (this.prototype instanceof V.Base)
        || (this instanceof V.Base))
      )) { 
      args = util.arg(args)
      args.unshift(this)
      extend = this
    } else {
      return inject.apply(this,args)
    }
  }
  for(var i = 1; i < args.length; i++) {
   makeExtend(extend, args[i])
  }
  return extend
}

function makeExtend(extend, module) {
  if($TEST) console.log('9', module, extend)
  if(module.extend) {
    if($TEST) console.log('9.1', extend)
     module.extend(extend)
  } else if(module instanceof Array) {
    var arr = module.concat()
      , mod = arr[0]
    arr[0] = extend
     if($TEST) console.log('9.2')
    mod.extend.apply(mod,arr)
  } 
} 

function inject() {
  if($TEST) console.log('5')
  //do special stuff voor blacklist
  // Custom.prototype = new this() //lighter
  var Custom
    , extendResidue = []
    , Aspects = [this]

  for (var i = 0, Aspect, args = arguments, len = args.length; i < len; i++) {
    
    Aspect = args[i]

    if(typeof Aspect === 'function') {
      if(!Custom) {
        Custom = function() {
          for (var j = 0, len = Aspects.length; j < len;  j++) {
            Aspects[j].apply(this, arguments)
          }
        }
        inherits( Custom, this )
      }
      Aspects.push(Aspect)
      for (var method$ in Aspect.prototype) if ({}.hasOwnProperty.call(Aspect.prototype, method$)) {
        if (method$ === 'constructor') continue
        Custom.prototype[method$] = Aspect.prototype[method$]
      }
    } else {
      if($TEST) console.log('6')
      if(Custom) {
              if($TEST) console.log('7')

       makeExtend(Custom , Aspect)
      } else {
        // if($TEST) console.log('8')
        extendResidue.push(Aspect)
      }
    }
  }

  if(!Custom) Custom = this
  
  for(var j in extendResidue) {
    // console.log('8.'+j, extendResidue[j], Custom)
    makeExtend(Custom,extendResidue[j])
  }

  return Custom
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor
  ctor.prototype = Object.create
    ( superCtor.prototype
    , { constructor: 
        { value: ctor
        , enumerable: false
        , writable: true
        , configurable: true
        }
      }
    )
}

/*
 Dit moet worden geadd voor V.Objects
/*
  object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)
      if (val !== void 0) this.val = val
      // console.log(constructor)
      if(constructor) constructor.apply(this,arguments)  
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

veel dingen werken als extension niet als losse class -- 

*/


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , vigour = require('../') //only here to be able to use util without vigour.Object maybe refactor this away?
  , DOT = '.'

/**
 * lookup
 * polyfill if __lookupSetter__ does not exist;
 */
exports.lookup = Object.__lookupSetter__ || function (i) {
  var t = this
    , a
  while (t) {
    a = Object.getOwnPropertyDescriptor(t, i)
    if (a && a.set) return true
    t = Object.getPrototypeOf(t)
  }
  return false
}

/**
 * Used to set a val to an field on a object, whether it is a vigour.Object or a regular object
 * @method set
 * @param {Object} obj   Defines target Object
 * @param {String} field Target field
 * @param {*}      val   Value to set
 * @todo                 Move this function to a different module (e.g. 'convenience' module)
 */
exports.set = function (obj, field, val, vobj, stamp, noupdate) {
  return (vigour.Object && (obj instanceof vigour.Object))
    ? obj.set(field, val, vobj, stamp, noupdate)
    : (obj[field] = val)
}


/**
 * Returns object on the end of a defined path
 * @method path
 * @example
 * // returns obj.a.b.c
 * var obj = { a: { b: { c: 1 }}}
 * V.util.object.path(obj,['a','b','c'])
 * @param  {Object}    obj            Object to search
 * @param  {Array}     path           Array of fields in path
 * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
 * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
 * @param  {Function}  [writeHandler] Callback on write
 * @param  {Boolean}   [noupdate]     When true, updates will be skipped on write
 * @param  {Number}    [i = 0]        Starting point for searching through path
 * @return {*}                        Object on the end of a defined path
 */

exports.path = function ( obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i ) {
  if (!i) i = 0

  var field = path[i]
    , result
    , c
    , target = (!self && obj && obj.__t === 4) ? obj.from[field] : obj && obj[field]
    , l = i < path.length - 1

  // if(field === void 0) {
  //   throw new Error('path must not contain undefined')
  // }

  if (l && !(target instanceof Object)) target = void 0

  if ((val !== void 0) && (target === void 0 || (!l && overwrite))) {
    c = true
    exports.set(obj, field, l ? {} : val, l ? false : vobj, stamp, noupdate)
    target = obj[field]
  }

  if (l) {
    result = target
      ? this.path(target, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, ++i)
      : target
  } else {
    result = (!self && target && target.__t === 4) ? target.from : target;
    if (c && writeHandler) writeHandler(result)
  }

  return result
}

/**
 * Adds path using 'dot-notation'
 * @method dotField
 * @example
 * // returns blur:{d:{a:{s:{}}}}
 * var blur = {};
 * V.util.object.dotField(blur,'d.a.s');
 * @param  {Object} obj   Object where field will be added
 * @param  {String} field String using 'dot-notation'
 * @return {Object}       Returns field
 */
exports.dotField = function (obj, field) {
  if (~field.indexOf(DOT)) {
    var path = field.split(DOT)
      , first = path.shift()
      , val = {}
    this.path(val, path, obj[field])
    delete obj[field]
    obj[first] = val
    field = first
  }
  return field
}

/**
 * Checks if two lists contain identical content
 * @method compareArrays
 * @param  {Array|Object} a         Takes any object with .length
 * @param  {Array|Object} b         Takes any object
 * @param  {Boolean}      keys      use Object.keys for b
 * @return {Boolean}      True/false
 * @todo                  Maybe change title => compareLists
 */
exports.compareArrays = function(a, b, keys) {
  var bl = keys ? Object.keys(b).length : b.length
  if (a.length !== bl) return false
  for (var i = a.length - 1; i >= 0; i--) {
    if (a[i] != b[i]) return false
  }
  return true
}

/**
 * Gets object from specified path. When path is a string checks for 'dotnotation'.
 * @method get
 * @example
 * // returns 'foo'
 * var a = {b:{c:'foo'}}
 * V.util.object.get(a,'b.c')
 * @param  {Object}       obj  Defines object or V.Value
 * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
 * @return {*}                 obj[path]|nested object/value
 */
exports.get = function (obj, path, self) {
  //TODO: make one interface for get

  if (!obj || !path) return
  if (!self && obj.__t === 4 && !obj._filter) obj = obj.from
  if (!(path instanceof Array)) {
    if (~path.indexOf(DOT)) {
      path = path.split(DOT)
    } else {
      return (!self && obj[path] && obj[path].from) || obj[path]
    }
  }
  //self is too far away in the arguments
  return this.path(obj, path, void 0, false, false, false, false, false, self)
}

/**
 * Returns true if an object is an instance of an object and not a function , V.Object or V.Base
 * @method isObj
 * @param  {Object}  obj Object to inspect
 * @return {Boolean}     True/False
 */
exports.isObj = function (obj) {
  return (obj instanceof Object
    && typeof obj !== 'function'
    && (!vigour.Object || !(obj instanceof vigour.Object))
    && (!vigour.Base || !(obj instanceof vigour.Base)))
}

/**
 * Creates new object with the same value , takes custom objects into account (new obj.constructor())
 * @method clone
 * @param  {Object} obj Object to clone
 * @return {Object}     Returns clone
 */
exports.clone = function (obj, exclude, shallow) {
  if (this.isObj(obj)) {
    var copy = new obj.constructor()
    for (var i in obj) {
      if(!exclude || !exclude[i])
        copy[i] = !shallow
          ? this.clone(obj[i], exclude)
          : obj[i]
    }
    return copy
  }
  return obj
};

/**
 * Merges object b into object a and returns object a
 * @method merge
 * @param  {Object} a Object a
 * @param  {Object} b Object b
 * @return {Object}   Object a
 */
exports.merge = function (a, b, norefs, overwrite) {
  for (var i in b) {
    var aisobj = util.isObj(a[i])
      , bisobj = util.isObj(b[i])

    if (aisobj && bisobj) {
      util.merge(a[i], b[i], norefs, overwrite)
    } else if(!norefs || !bisobj){
      if( overwrite === void 0
       || !(i in a)
       || typeof overwrite === 'function' && overwrite(a[i], b[i])
        ){
        a[i] = b[i]
      }

    }else{
      a[i] = b[i] instanceof Array ? [] : {}
      util.merge(a[i], b[i], norefs, overwrite)
    }
  }
  return a
}

// exports.resolve = function(a, b, bFrom, j) {
//   var same = true;
//   if(b instanceof Object) {
//     for(var i in b) {
//       if(a[i]!==void 0) {
//         if(exports.resolve(a[i],b[i],bFrom ? bFrom[i] : b[i],i)) {
//           if(bFrom) {
//             delete bFrom[i]
//           }
//         } else {
//           same = false
//         }
//       } else {
//         same = false
//       }
//     }
//     if(same) {
//       if(!(bFrom&&j!==void 0)) return true
//       delete bFrom[j]
//     }
//     return same;
//   } else {
//     if(a==b) {
//       if(bFrom&&j!==void 0) {
//         delete bFrom[j]
//       }
//       return true
//     }
//   }
// }

exports.resolve = function(a, b, bFrom, j) {
  // console.log('lolresolve\n',bFrom)
  var same = true;
  if(b instanceof Object) {
    for(var i in b) {
      if(a[i]!==void 0) {
        if(exports.resolve(a[i],b[i],(bFrom!==void 0 && bFrom!==null) ? bFrom[i] : b[i],i)) {
          if(bFrom!==void 0 && bFrom!==null) {
            if(bFrom[i]===null) {
              same = false
            } else {
              delete bFrom[i]
            }
          }
        } else {
          same = false
        }
      } else {
        same = false
      }
    }
    if(same) {
      if(!(bFrom&&j!==void 0)) return true
      delete bFrom[j]
    }
    return same;
  } else {
    if(a==b) {
      if(bFrom&&j!==void 0) {
        delete bFrom[j]
      }
      return true
    }
  }
}

/**
 * Adds value to array if it is not contained in array, executes handler on encountering val in array
 * @method include
 * @param  {Object|Array}   obj       Takes any object with .length
 * @param  {*}              val       Value to add
 * @param  {Function}       [handler] Function to execute on encountering val in array
 * @param  {Boolean}        arr       Include elements of val separately rather than including val itself
 * @return {Boolean}                  True/false
 */
exports.include = function (obj, val, handler, arr) {

  if(arr && val instanceof Array) {
    var ret = false
    for(var i = 0 , len = val.length; i < len; i++) {
      ret = exports.include(obj, val[i], handler)
    }
    return ret
  }

  var i = 0
    , l = obj.length
    , field
    , check

  if (obj.__t === 1) {
    for (;i < l; i++) {
      field = check = obj[i]
      if (check.__t === 4) check = check.from
      if (check === val || check.val === val) {
        if (handler) handler(field)
        return false
      }
    }
    obj.push(val)
    return true
  } else if (obj instanceof Array) {
    for (;i < l; i++) {
      if (obj[i] === val) {
        return false
      }
    }
    obj.push(val)
    return true
  }
}

exports.changeType = function( obj ) {
  var result
  if(obj instanceof Array) {
    result = {}
    for(var i=0,len=obj.length;i<len;i++) {
      result[i]=obj[i]
    }
  } else {
    result = []
    for(var i in obj) {
      result.push(obj[i])
    }
  }
  return result
}

/**
 * Ensures a value is not or contains no V.Objects, only their "raw" versions
 * This needs to be unified with convert, or at least get a better name.
 * @method raw
 * @param  {*}   val   the value to be processed
 * @return {*}         the processed value
 */
exports.raw = function( val, rparams ) {
  if (val instanceof Object) {
    if (val instanceof vigour.Object) {
      return val.raw
    } else {
      var result
      if (val instanceof Array) {
        result = []
        for (var i = 0, l = val.length; i < l; i++) {
          result[i] = this.raw(val[i], rparams)
        }
      } else {
        result = {}
        for (var f in val) {
          result[f] = this.raw(val[f], rparams)
        }
      }
      return result
    }
  } else {
    return val
  }
}

//add level and stops for certain branches
exports.walk = function(obj, fn ) {
  for(var i in obj) {
    if(obj[i] instanceof Object) {
      if(!fn(i, obj[i], obj, true)) {
        if(exports.walk(obj[i], fn)) return true
      } else {
        return true
      }
    } else {
      if(fn(i, obj[i], obj)) {
        return true
      }
    }
  }
}

exports.checkParentFactory = function( parentField ) {
  return function(field, get, links, match) {
    if(get&&get!==true) {
      match = get
      get = false
    }
    var fields = field instanceof vigour.Object ? false : field,
      curr = this,
      found;
    while (curr) {
      found = fields === false ? curr === field : exports.get(curr, fields, !links);
      if (found) {
        if(match) {
          if(match === found || (found instanceof vigour.Object) && found.val === match) {
            return !get && fields ? curr : found;
          }
        } else {
          return !get && fields ? curr : found;
        }
      }
      curr = curr[parentField];
    }
  }
}

exports.disjoin = function disjoin(a, b, check) {
  // console.log('disjoin!')
  var fncheck = typeof check === 'function'
  
  a = getEndpoint(a)
  b = getEndpoint(b)

  a.each(function(){
    var item_a = this
    var item_a_from = item_a.from
    var remove
    b.each(function(){
      var item_b = this
      var item_b_from = item_b.from
      
      
      if(fncheck){
        remove = check(item_a_from, item_b_from)
      } else if(check === true){
        remove = item_a_from === item_b_from
      } else {
        // console.log('compare a', item_a_from.raw, 'to b', item_b_from.raw)
        // console.log('field', check)
        // console.log('a:', item_a_from[check].val)
        // console.log('b:', item_b_from[check].val)
        // console.log('same:', item_a_from[check].val === item_b_from[check].val)

        remove = item_a_from[check] && item_b_from[check] &&
          item_a_from[check].val === item_b_from[check].val
      }
      return remove
    })
    if(remove){
      // console.log('YES CHECK REMOVE')
      // TODO: 
      item_a.remove()
    }
  })

}

function getEndpoint(obj){
  while(obj && obj.__t === 4 && !obj._filter){
    obj = obj._val
  }
  return obj
}

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/process.js":[function(require,module,exports){
//processes
var vObject = require('../object')

// console.log('init process!')

module.exports = {}

},{"../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/prop.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , V = require('../')
/**
 * Setstores are used to avoid updates troughout prototype chains for changes of fields on objects
 * It uses two fields
 *   .__ to indicate own values for pieces of an object inherited trough the prototype chain
 *   ._ is the refence back to the objects as ste in the prototype
 * @constructor setstore
 */
exports.setstore = function() {
  if ( !this.__ ) this.__ = {}
}

//TODO: reconstruct value using pieces of objects in __

exports.getStore = function( name ) {
  return this.__ 
          ? ( this.__[name] !== void 0 
            ? this.__[name] 
            : this._[name]
            ) 
          : this._ && this._[name]
}

function extensions( extend, fn, base, args, extended ) {
    
  if(window.$TEST) {
    console.log(12, extend)
  }

  if( !extend.extensions ) 
  {
    if(base) {
      extend.extensions = []
    } else {
      // console.log(extend)
      if(V.Object && extend instanceof V.Object ) {
        util.define( extend, 'extensions',[])
      } else {
        //gebruik deze extension stylo
        util.define( extend, 'extensions',{val:[], setClass:true} )
      }
    }
  }

  // console.log( 'EXTEND'.red, extend.extensions, base, fn, this, extended )

  if( util.checkArray( extend.extensions, this )===false ) 
  {

    // console.log( 'EXTEND -2'.red, this )

    if( !extended ) extend.extensions = [ this ].concat( extend.extensions ) 

      // console.log( 'EXTEND -3'.red, extend.extensions )
      //somethin weird!

    // console.log( 'EXTEND -3'.red, this, extend, extend.extensions.length )

    var myArgs = util.arg( args )
    if( base && !extended ) {
      myArgs[0] = base
    }
    if(window.$TEST) console.error('??xxx?', myArgs, fn, this)
    var ret = fn.apply( this, myArgs ) //this is the app, extend is the extension 
    if(window.$TEST, ret)
    return ret
  } else {
    if(window.$TEST) console.error('???')
  }

}

exports.extend = function() {


  var extendArray = util.arg( arguments )

  return function(extend) {

    if(window.$TEST) console.log('10 --->', extend)

    var base
      , proto

    if( typeof extend === 'function' ) 
    {
      if( V.Base && ( extend.prototype instanceof V.Base ) ) {
        base = extend.base
        proto = true
      } else {
        proto = extend.prototype
      }
    } else if( V.Base && ( extend instanceof V.Base ) ) 
    {
      proto = extend
    }

    for
    ( 
      var fn
        , ret
        , args = util.arg( arguments )
        , extendArr
        , xArg
        , i = 0
        , len = extendArray.length
        ; i < len
        ; i ++ 
    ) 
    {    
      if(extendArray[i] instanceof Array) 
      {
        extendArr = extendArray[i][0]
        xArg = util.arg(extendArray[i],1)
        xArg.unshift(extend)
      } else 
      {
        xArg = args
        extendArr = extendArray[i]
      }

      if(window.$TEST) {
        console.log('11',  extendArr.extend ?  extendArr : this, base || proto  )
      }

      ret = extensions.call 
      ( extendArr.extend ?  extendArr : this 
      , base || proto || extend
      , extendArr.extend ||  extendArr
      , base
      , xArg
      , extendArr.extend ? true : false 
      ) 
      || extend

    }
    return ret
  }

}

/**
 * Add is used as a shortcut method for Object.defineProperty and extends setstore functionality to normal prototypes
 * @method add
 * @param  {Object}          obj  When obj is a constructor it selects obj.prototype, when obj is a normal object this is used instead
 * @param  {String|Array}    name When name is a string it adds the name for the object, when name is a array do the same setting for each name
 * @param  {Object|Function} val  When val is an object , use this object for Object.defineProperty with default for enummerable:false, when object is empty adds {value:{},ennumerable:false}, when val is a function it automatically wraps a property definition object with {value: val , enummerable:false}, when val is not a function and not an object (boolean, string, number) adds special setstore value
 * @param  {Function}        [set]  Adds custom setters to a setstore object, when set is a string the add functions interprets the arguments as name : property definition pairs
 * @param  {Function}        [get]  Adds custom getters to a setstore object
 * @
 */
exports.define = function (obj, name, val, set, get, id) {
  if (typeof set === 'string') {
    var _args = util.arg(arguments)
    for (var i = 1, l = _args.length; i < l; i += 2) {
      exports.define(obj, _args[i], _args[i + 1])
    }
  } else {
    if (name instanceof Array) {
      for (var i = 0, l = name.length; i < l; i++) {
        exports.define(obj, name[i], val)
      }
    } else {
      if (typeof val === 'function' || val instanceof Array) {
        val = {
          enumerable: false,
          value: val,
          configurable: true
        }
      } else if (!val || ( !(val instanceof Object) || val.setClass  )) {

        if( val && val.setClass ) {
          val = val.val
        }

        var proto = obj.prototype || obj


        //

        //TODO: not a good solution -- has to redefine constantly ( too heavy )
        // if( proto !== obj.prototype && proto._ ) {
        //    //TODO: this can go completely wrong when you expect inheritance not to break when making a new class!
        //    if( proto.constructor.prototype._ === proto._ ) {
        //       var old = proto._
        //       proto._ = {}
        //       for(var key in old) {
        //         proto._[key] = old[key]
        //       }
        //    }
        // }
        
        //maybe make into a method
        if( id) {
          // console.log('DEFINE! DO IT'.red.inverse, name, id, proto)
          if (!proto.__) proto.__ = {}
          proto.__[name] = val
        } else {
          if (!proto._) proto._ = {}
          proto._[name] = val
        }



      

        //if proto is not a prototype (how to check?) then use __ perhaps?

        //moet hier niet altijd ze eiguh worden gemaakt?

       //default dit is eigenlijk het enige dat mis gaat

        var setter = function(val) {
              exports.setstore.call(this)
              //TODO: fix closure for val
              if (val || val === 0 || val === false) this.__[name] = val
            }
          , wset = function(val) {
              val = set.call(this, val);
              setter.call(this, val);
            }
          , getter = function() {
              return exports.getStore.call(this, name);
            }
          , wget = function() {
              var prop = getter.call(this);
              return get.call(this, prop);
            }

        val = {
          enumerable: false,
          configurable: true,
          get: get ? wget : getter,
          set: set ? wset : setter
        }

      } else if (!val.enumerable) {
        if (util.empty(val)) val.value = {}
        val.configurable = true
        val.enumerable = false
      }

      Object.defineProperty(obj.prototype || obj, name, val)

      // Object.defineProperty(obj.prototype || obj, name, val)
      //mayeb do both?
    }
  }
}
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../base')
  , Value = require('./')
  , objectSet = require('../object').set
  , util = require('../util')
  // , raf = require('../browser/animation/raf')

exports.clonelist = [
  [ '_base', false ], '_caller', '_prop', '_name', '_skip'
]

function resolveListener( listener, val, prop, instance ) {
  if (listener) {
    if ( listener._bind === instance && listener.__t === 4 ) {
      // console.log('bind resolve'.red.bold, val )
      listener.val = val
    }
    else if (!listener._bind ) { 

      if( listener.__t === 4 && listener._val === prop )
      {
        // listener.val = 
        listener.val = val
        console.log('----------', listener.__t )
      }
      else
      {
        // console.log('ultimate ugly!')
        val.addListener(listener) //dit fixed  
      }

      //TODO: implement this later
      // if( listener instanceof Array ) {
      //   var mark = listener[1]
      //   if( mark ) {
      //     if( mark === prop._base || mark === instance || instance instanceof mark._class ) {
      //       //TODO: propably need to check for inheritance ( mark instance of prop._base)
      //       // console.log('mark resolve'.green.inverse, listener)
      //       // val.addListener([ listener[0] , instance ], true)
      //     }
      //   }
      // }

      
      // val.addListener(_listeners[i])
    }
  }
}

// function resolveListener( ) {

// }

/**
 * V.value.base.type
 * Defines the base type used in V.Value
 * @type
 */
exports.type = {
  type: Value,
  /**
   * Defines what this type will do on creation.
   * @method create
   * @param  {*} val              Value
   * @param  {[type]}  [prop]     [description] //WORDT NIET GEBRUIKT
   * @param  {Object}  [settings] Settingobject
   * @param  {Boolean} [noupdate] When true, doesn't update the V.Value
   * @return {Object}             Returns the V.Value
   */
  create: function(val, prop, settings, noupdate) {
    var v = new Value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings.set) {
      if (!settings._vset) {
        settings._vset = function(stamp, from, remove, cval) {
          // var t = this
          // t.__s = true
          // if(!t._s) {
            // raf(function() {
              // console.log('IM HERE?')
              // t.__s = null
              settings.set.call(
                   this._caller
                || this._base
                || this, this, stamp, from, remove, cval
              )
            // })
          // }

        }
      }
      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  /**
   * Defines what this type will do on set.
   * @method set
   * @param  {*}      val      Value
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingsobject
   * @return {*}               Returns value
   */
  set: function(val, prop, settings) {

    if(!prop) return
    // console.log('SET FUN!')
    prop._caller = this
    //deze bind zou alleen moeten werken voor als je iets op het exact goede momment changed!

    prop._bind = false
    if (this !== prop._base) {
      var _listeners = prop._listeners
        , _b = prop._base
        , i
        , _this = this

      util.setstore.call(this)
      exports.clonelist[0][1] = this //beetje dirty...

      //clone is always used to get rid of flags
      if (val !== void 0 && !val.clear) {
        val = prop.clone(val, false, exports.clonelist)
      } else {
        // if(prop._flag) {
        //   value.flags[prop._flag[0]].remove && value.flags[prop._flag[0]].remove.call(this,prop._flag)
        // }
        //listener on nested child on parent

         //--->  new width for this one
         // --->  hey a listener on me /w a bind on my instance!
         //  ----> add listener to me (listener on class prop)
         //   -----> hey lets reset this little guys width
         //    ------>  lets add Listener
         //     -------->  double listeners on this one
        var v = new Value()
        v._base = this
        v._prop = settings
        v._caller = this

        // clean FLAGS from node!
        if(val) delete val.clear
        v.val = val
        val = v
      }

      this.__[settings.name] = val

      if( this._class ) this._class.prototype._[settings.name] = val

      // for each field (only 1 level deep for now)
      prop.each
      ( 
        function(key) {
          // console.log('resolve', prop._prop.name, key)
           if( this._listeners ) {
            for (i =  this._listeners.length - 1; i >= 0; i--) {
              resolveListener( this._listeners[i], val[key], prop, _this )
            }
            //TODO: check if this is nessecary
            if(val[key].val !== this.val)
            {
              // console.log(val[key]) 
              // val[key]._update()
            }
          }
        }
      )

      if( _listeners ) {

        for (i = _listeners.length - 1; i >= 0; i--) {
          resolveListener( _listeners[i], val, prop, _this )
        }

      }

      val = null
      // console.log('UPDACE ----'.yellow)
      this[settings.name]._update(val)
    }

    return val
  },
  /**
   Defines what this type will do on get.
   * @method get
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingobject
   * @return {Object}          [description]
  */
  get: function(prop, settings) {
    // console.log('GETTING!', prop, settings.name)
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./'),
  util = require('../../util'),
  object = require('../../object'),
  ownModel = function(base) {
    if (!base.__ || !base.__.model) { //maybe a utility? use it at different spots like settings
      base.model = {};
      if (!base._.model) {
        base._dListen();
      }
    }
    return base.model;
  };
/**
 * data
 * data adds a reference to the data property of the current base class;
 * if there is not _base.model use data.base.extend(baseClass);
 * @flag
 */
flags.data = {
  useVal:true, //(reset???)
  set: function(val, stamp, reset) {

    var current = this.checkParent('_prop.name'),
      name = current._prop.name,
      base = current._base,
      model = ownModel(base);
    if (model.flags && model.flags[name]) {
      if (!(model.flags[name] instanceof Array)) {
        model.flags[name] = [model.flags[name]];
      }
      if (!util.checkArray(model.flags[name], this)) {
        model.flags[name].push(this);
      }
    } else {
      if (!base.model.flags) {
        base.model.flags = {};
      }
      base.model.flags[name] = this;
    }

    // console.log('LEZZ SET IT!', val, stamp, reset, current)

    var getData = function() {
      var data = this._d;
      if (data === void 0) {
        var parent = this;
        while (data === void 0 && parent) {

          // if(parent.model && (!parent.model.inherit || parent.model.inherit.val!==false)) {
          //   return data
          // }

          // console.error('set it /w parent!', this.name, parent.name)

          if (parent._d) {

            if(parent.model && parent.model.field && parent.model.field.val !== parent.modelParsed) {
              parent._d = parent._d[parent.model.field.val] || parent._d.from[parent.model.field.val]
              console.error('het hey its parent model', parent.model.field.val)
              // parent.model = {}
              parent.modelParsed = parent.model.field.val
            }

            // if(par)

            if(this.model&&this.model.field && this.modelParsed !== this.model.field.val) {
              console.error('hey hey hey! i got a model myself!', this.model.field.val, parent._d.keys, parent._d)

              data = this._dSet(parent._d[this.model.field.val] || parent._d.from[this.model.field.val], true);
              // this.model = {}
              this.modelParsed = this.model.field.val
              // this.model.parsed = this.model.field.val
            } else {
              data = this._dSet(parent._d, true);
            }


            // if(parent.model && parent.model.field) {
            //   console.error('it is a field!', parent.model.field.val)
            // }
          } else {
            parent = parent.node.parentNode;
            if (parent) {
              parent = parent.base;
            }
          }
        }
      }
      return data;
    };
    if (val instanceof Object) {
      var v = val.val || val;
      this._val = function() {
        var data = getData.call(this);
        // console.log('---->',v,data)
        return data && v.call(this, data);
      };
      val = val.listen || true;
    } else {
      this._val = function() {
        var data = getData.call(this),
          ret;
        data = val === true ? data : util.get(data, val);
        if (data !== void 0) {
          ret = data.__t && !data._filter && data.val;
          if (!ret && ret !== 0 && ret !== '') { //weird
            ret = data;
          }
        } else {
          ret = '';
        }
        return ret;
      };
    }
    if(!this._flag) this._flag = {}

    // this.__lval = false
    // current._caller.setSetting({
    //   name: name,
    //   parent: function(parent) {
    //     console.log('!@#!@#!@#')
    //     this.updateData()
    //   }
    // });

    this._flag.data = ['data', this._val, val, name];
  },
  remove: function() {
    var current = this.checkParent('_prop.name'),
      model = ownModel(current._base),
      t = this;
    if (model && model.flags) {
      for (var i in model.flags) {
        if (i === current._prop.name) {
          var item = model.flags[i];
          if (item instanceof object || item.length === 1) {
            model.flags[i] = null;
            delete model.flags[i];
          } else {
            model.flags[i].splice(util.checkArray(item, t), 1);
          }
        }
      }
    }
    this._update() //pas hiermee op!
    // var t = this
    setTimeout(function() {
      //deze pas uitvoeren nadat alle klaar is! dit is dirty!
      t._update()
    },0)
  }
};
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var value = require('../'),
    base = require('../base'),
    flags = require('../../object/flags');
    
    base.clonelist.push(['_flag', true]); //true clone!
    flags.extend(value);
    module.exports = value.flags;
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../object/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js","../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/parent.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./')
  , value = require('../')
  , util = require('../../util')
  , vObject = require('../../object')


//todo add element signature in from so it can travel trough updates --- if parent (need less funky things)

/**
 * parent
 * parent makes it possible to add listeners to parent properties
 * using multiple parent properties in one property is still very wrong
 * @flag
 */
value.prototype._blacklist.push('_parentStore')

function baseReset(base,name) {
  if(base && base.node) {
    if(name==='x' || name ==='y') base.cleanCoordinates(name)
    if(base[name]) {
      base[name]._prop._vset.call(base[name])
    }
  }
}


// window.pcheck = 0

// window.pprops = {}

//base,vset,t,type,mparent,fbase, v, val, stamp, from, remove, added, oldval, true, firstSkip
function checker(vset, t, type, mparent, fbase, v, val, stamp, from, remove, added, oldval, first, firstSkip, p) {
  if(p&&(this.parent instanceof mparent) ||  (!p && this.parent===mparent) || firstSkip ) {

    // pcheck++

    var s
      , base = this._from.base.node && this._from.base
      , name = t._prop.name

    // if(!window.pprops[name]) window.pprops[name] = 0

    // window.pprops[name]++


    t._caller = this

    //gaurd voor changes -- if no change -- do nothing
    vset.call(t, stamp, from, remove, val)

    if(base&&base[name]&&base[name+'__p']!==stamp) {
      t._caller = base
      t._caller[name+'__p'] = stamp
      vset.call(t, stamp, from, remove, val)
      t._caller = this
      s=true
    }

    // console.log(this.node)
    for(var i in t._listeners) {
      if(t._listeners[i].pop && t._listeners[i][2]==='parent') {
        if(t._listeners[i][1]._lstamp===stamp) {
          t._listeners[i][1]._lstamp=null
        }
        t._listeners[i][0].call(t._listeners[i][1], type, this, base, v, val, stamp, from, remove, added, oldval, true)
      }
    }

    //reset this._from.base[t._prop.name]===t
    if(s) baseReset(base, name)

  }
}

function updateHandler(type,mparent,fbase,v, val, stamp, from, remove, added, oldval,firstSkip,inherit) {

  var t = this

  this._parentStore[0] = mparent

  this._update(val, from ? this.stamp() : stamp, from, remove, added, oldval, false, false, function() {
    var vset =  this.checkParent('_prop._vset', true)
      , base = this.checkParent('_base', true)
      , complexParent = true
      , p

    if( (mparent===base.parent && from)  ) {
      p = true
    }

    checker.call(base,vset,t,type,mparent,fbase, v, val, stamp, false, remove, added, oldval, true, firstSkip)

    base.eachInstance(function() {
     checker.call(this, vset, t,type, mparent,fbase, v, val, stamp, false, remove, added, oldval, false, p)
    }, t._prop.name)

    vObject.prototype._update.call(this, val, stamp, false, remove, added, oldval, function(l) {
      return l[2]==='parent'
    })

    if(!inherit && v._caller && mparent!==v._caller) {
      updateHandler.call(this,type,v._caller,fbase, v, val, stamp, false, remove, added, oldval,firstSkip,true)
    }

  })
}

function _parent(parent, noupdate, prop, flag, reset) {

  // console.log('_parent call'.cyan.inverse, flag)

  var _lparent = prop._parentStore[0]
    , pname = flag[2]   //flags.parent.val
    , pprop = parent[pname]
    , fbase = this._from.base
    , newP
    , baseSet

  if (!pprop) return

  // console.log('ADD LISTENER TO PARENT')

  pprop.addListener(
    [ updateHandler
    , prop
    , 'parent'
    , parent
    , this //fbase
  ], function(l,listeners,index) {

    if(l[3]!==parent &&  _lparent!==parent && l[4]!==fbase) {
      prop._parentStore[0] = parent
      l[4] = fbase
      newP = true //hoe deze smart afvangen?
    }
  }, false, true)

  // if(reset) {
  //   for(var i in pprop._listeners) {
  //     if(pprop._listeners[i].pop && pprop._listeners[i][1]===fbase[prop._prop.name]) {
  //       if(pprop!==parent._from.base[pname]) {
  //         pprop._listeners.splice(i,1)
  //         break;
  //       }
  //     }
  //   }
  // }

  if (newP || (!_lparent || (_lparent !== parent && _lparent[pname] !== pprop) ) ) {
    prop._parentStore[0] = parent
    if (!noupdate) {
      prop._caller = (baseSet = fbase.node && fbase || prop._base)
      prop._prop._vset.call(prop, prop)
      prop._caller = this
      updateHandler.call(prop,'parent',parent,fbase,pprop,false,vObject.stamp(),false,false,false,false,true,true)
      baseReset(baseSet,prop._prop.name)
    }
  }
}

function _init(val, flag, reset) {
  var parent = this.parent
  // console.log('try parent', flag, parent)
  if (parent) _parent.call(this, parent, true, val, flag, reset)
}

function _val(val) {
  var parent = this.parent || val.checkParent('_parentStore.0', true)
  //flags.parent.val
  if(parent && !val._flag.parent) {
    console.error('NO PARENT FLAG!')
    return
  }
  // console.log('---->',val._flag.parent[2])
  if (parent ) return parent[val._flag.parent[2]].val
}

flags.parent =
{ reset: true
, useVal: true
, set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name'),
      name = current._prop.name
    //flags.parent.val
    if(!this._flag) this._flag = {}

      //overwriting previous parent
      //
    // console.log('SET PARENT---->')
    this._flag.parent = ['parent', _val, val, this]
    if (!current._parentStore) current._parentStore = [false]

    // console.log('GOTS PARENTSTORE!', reset, current._parentStore, this._flag.parent)

    current._parentStore.push(this)
    //setParent settings
    // console.log('---> CREATE SETTING'.yellow.inverse)
    current._caller.setSetting({
      name: name,
      parent: function(parent) {

        // console.log('---> SET SETTING'.yellow.inverse)

        for (var store = this[name]._parentStore, i = store ? store.length - 1 : 0; i > 0; i--) {
          if(store[i]._flag.parent) {
            _parent.call(this, parent, false, this[name], store[i]._flag.parent)
          } else {
            console.error('2 NO PARENT FLAG!')
          }
        }
      }
    });
    //try to minimize val calulations
    this._val = _val
    this._skip = true
    //onInit (if it already has some parents)
    _init.call(current._base, current, this._flag.parent, reset)
    //reAttach listeners for instances
    current._base.eachInstance(_init, name, current, this._flag.parent)
  }
, remove: function(flag) {

    // console.log('REMOVE PARENT'.cyan.inverse)

    var current = this.checkParent('_prop.name'),
      base = current._base,
      listens = current._listens,
      name = current._prop.name,
      val = flag[2],  //flags.parent.val
      parentStore = current._parentStore,
      removelistener = function() {
        var parent = this.parent
        if (parent && parent[val]) {
          if (listens.length > 0) {
            if (util.checkArray(listens, parent[val])) {
              // console.log('REMOVE LISTENER!', parent[val], listens.length, parent[val]._listeners.length, parent[val]._listeners , current)


              //more specific only remove if val matches --- store function
              parent[val].removeListener( false, current )

              //mark = false


              // console.log('REMOVE LISTENER! -- result -- no update?', listens.length)

            }
          } else {
            return true
          }
        }
      }

    this._val = 0

    if (listens && !removelistener.call(base)) {
      base.eachInstance(removelistener, name)
    }

    // console.log('PARENTSTORE', parentStore, current)
    parentStore.splice(util.checkArray(parentStore, this, true), 1)

    if (parentStore.length === 1) {
      // console.log('---> REMOVE SETTING'.yellow.inverse, parentStore)
      base.removeSetting(name, 'parent') //ff corigeren voor andere parent settings!!! op andere fields
      //dit maakt het helemaal kapot!
      // console.warn('REMOVE PARENTSTORE!')
      current._parentStore = null
    }
  }
}
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

//TODO: flags on the basis of path ( similair to cases )

//TODO: make Value flags more injectable
var flags = module.exports = require( './' )
  , processes = require( '../../util/process' )
  , Value = require( '../' )
  , util = require( '../../util' )
  , ajax = require('../../browser/network/ajax')
  , vObject = require('../../object')

//TODO: maybe add promise

exports.create = function( flag, settings, Constructor, extendflags ) {

  if( !extendflags ) extendflags = flags
  if( !Constructor ) Constructor = Value

  var tempStore = '__temp'+flag+'__'
    , inProgress =  '__inprogress'+flag+'__'
    , origUpdate = Constructor.prototype._update
    , once = settings && settings.once
    , deferMethod = settings && settings.deferMethod
    , origSet
    , origRemove
    , deferflag = 
      { reset: true
      , set: function( val, stamp, reset ) {
          if( !this._flag ) this._flag = {}
          this._flag[flag] = [ flag, false, val, this ]
        }
      , remove: function() {
          var defer = this._flag && this._flag[flag]
            , vobj

          if( defer && defer[1] )
          {

            // if( deferMethod ) 
            // {
              // vobj = deferMethod.call( _this, arr, defer[2], _this[tempStore], origUpdate, Constructor )
            // }
            // if() {
              vobj = typeof defer[2] === 'string'
                   ? processes[defer[2]]
                   : typeof defer[2] !== 'function' && defer[2]
            // }

            if( vobj && vobj.removeListener )
            {
              vobj.removeListener( defer[1] )
            }
            else if( vobj && vobj !== true )
            {
              for( var vobj$ in vobj )
              {
                vobj.removeListener( vobj[vobj$] )
              }
            }
          }
        }
      }


  Constructor.prototype._blacklist.push
  ( tempStore
  , inProgress
  , '_history'
  // , '_initialised'
  )

  if( deferMethod ) {
    settings.deferMethod = null
  }

   if( once ) {
    settings.once = null
    Constructor.prototype._blacklist.push( once )
  }

  if( settings ) {
    for( var key in settings )
    {
      if( key === 'set' )
      {
        origSet = deferflag.set
        deferflag.set = function( val, stamp, reset ) {
          settings.set.call( this, origSet, arguments )
        }
      }
      else if( key === 'remove' )
      {
        origRemove = deferflag.remove
        deferflag.remove = function( val, stamp, reset ) {
          settings.remove.call( this, origRemove, arguments )
        }
      }
      else 
      {
        deferflag[key] = settings[key]
      }
    }
  }

  extendflags[flag] = deferflag

  //extend update
  util.define
  ( Constructor
  , '_update'
  , function( val, stamp ) {



      if( ( this._flag && this._flag[flag] ) && ( !once || !this[once] ) ) //&& !this._initialised 
      {

        // this.clearCache()

        // console.error('_updace', val, this._path)

        // console.error( '$EEEEE1', this._path)

        // console.log(this._path, val, stamp)
        var _this = this
          , defer = _this._flag && _this._flag[flag]
          , tempdefer = _this[tempStore]
          , add
          , arr
          , vobj
          , recur
          , fn

        if( !tempdefer )
        {
          _this[tempStore] = tempdefer = []
          add = true
        } else {
          //TODO: fix caching stamp, most efficient but may break things /w instances etc
          // console.log('stamp cahcing', this._path)

          if( stamp && tempdefer[0][1] !== stamp )
          {

            // tempdefer.push(util.arg( arguments ))
            // console.log('stamp cahcing pass' , this._path, tempdefer)
            // tempdefer[0][0] = val
            // tempdefer[0][1] = stamp
            var arg = util.arg(arguments)
            for(var i in arg) {
              tempdefer[0][i] = arg[i]
            }
          }


        // console.error('_updace 3', val, this._path)

         // if(this._name === '$test') console.log('stop its')
          return
        }

        arr = util.arg( arguments )

        // console.error('_updace 2', val, this._path)

        tempdefer.push( arr )

        if( add )
        {
          // if(this._name === '$test') console.error('do it 1')

          if( deferMethod ) 
          {
            vobj = deferMethod.call( _this, arr, defer[2], tempStore, origUpdate, Constructor, inProgress )
          }
          else 
          {
            vobj = typeof defer[2] === 'string'
               ? processes[defer[2]]
               : defer[2]
          }

          if( vobj )
          {

              // console.log('heyho2!!!!!', val,this._path)

          
            //TODO: replace with a standard function, lose the extra closure!
            recur = function() {

              if( once ) 
              {
                _this[once] = true
              }
              //dit ook kunnen meegeven
                // console.error('LETS TRY')

              //TODO: using a closure here may not be nessecary anymore, use another identifier
              for( var i = 0; i < tempdefer.length; i++ ) { //length needs to update
                // _this._caller = tempdefer[i].splice( tempdefer[i].length-1, 1 )
                // tempdefer[i][1] = this.stamp()
                // try{
                  // console.error('LETS TRY go go go',val, i, tempdefer[i])
                  // var stampx = tempdefer[i][1]
                    // , valx = tempdefer[i][0]

                  origUpdate.apply( _this, tempdefer[i] )  

                  // if( (tempdefer[i][1] && tempdefer[i][1]!==stampx) || (tempdefer[i][0] && tempdefer[i][0]!==valx) ) {
                  //   console.warn('defer new update within the loop now it fires! -- be carefull may break')
                  //   var ref = tempdefer[i]
                  //   // setTimeout( function() { 
                  //     _this.clearCache()
                  //     _this[tempStore] = null
                  //     _this[inProgress] = null
                  //     _this.clearReferencesCache()
                  //     // console.log('?????',ref)
                  //     _this._update.apply( _this, ref ) 
                  //   // } ,100) 
                  //   // alert('new update set within loop!')

                  // }
                // }catch(e){console.error('WA', e)}
                
              }

              //listener gets removed but order is different
              if( this.removeListener ) this.removeListener( recur )

              _this[tempStore] = null
            }

            if( typeof vobj === 'function' )
            {

              if( !_this[inProgress] )
              {
               
                fn = function( val ) {
                  
                  if( val!==true && _this[inProgress] ) {
                    _this[inProgress]()
                  }
                  _this[inProgress] = null
                  _this[tempStore] = null
                }

                _this[inProgress] = recur

                if( vobj.call( this, fn , arr, tempdefer ) === true )
                {
                  _this[tempStore] = null
                  _this[inProgress] = null
                }
                // else
                // {
                //   console.log( '?' )
                //   //TODO: check if this is the best way, (updating recur, or mayeb just use the same recur)
                //   _this._deferinprogress = recur
                // }

              }

            }
            else if( vobj === true )
            {

              if( this.val || this.val === 0 )
              {
                origUpdate.apply( _this, arr )
                _this[tempStore] = null
              }  
              else
              {
                console.error( 'no value! from defer type:', flag)
              }
            }
            else if( !vobj.addListener )
            {
              for( var vobj$ in vobj )
              {
                vobj[vobj$].addListener( recur )
              }
            }
            else
            {

              vobj.addListener( recur )
            }

            defer[1] = recur
          }
        }

      }
      else
      {
        // console.log( flag, once, 'should do orig update bitches!', arguments, this )
        origUpdate.apply( this, arguments )
      }

    }
  )

} 

//TODO: injectable
//TODO:_tempdefer hoeft niet altijd maak create -- update type flag
//always update method
// exports.create( 'force', 
// { deferMethod: function( args, vobj, tempStore, update ) {
//     var _this = this
//     //dit zit natuurlijk dieper!
//     _this._skip = true //maybe check if it rly gets reset?
//     _this._ignoreValue = true
//     _this.clearCache()
//     _this[ tempStore ] = null
//     update.apply( _this, args )
//   }  
// })
//deze moet nog wat dieper

// exports.create( 'history', 
// { deferMethod: function( args, vobj, tempStore, update, Constructor ) {
//     //vobj option voor flag
//     if(!this._history) this._history = []

//     this._history.unshift( args )
//     this[tempStore] = null //total control! (old including arguments)

//     //allright that works this.clearCache() //cache dingen adden
//     update.apply( this, args )
//   }
// })

// exports.create( '$type', 
// { deferMethod: function( args, vobj, tempStore, update ) {
//     var _this = this
//       , haveToUpdate

//     //arrays etc
//     _this.clearCache()

//     if( vobj === true )
//     {
//       if( _this.val ) haveToUpdate = true
//     }
//     else if( vobj === 'string' )
//     {
//       if( typeof _this.val === 'string' ) haveToUpdate = true
//     }
//     else if( vobj === 'number' )
//     {
//       if( typeof _this.val === 'number' ) haveToUpdate = true
//     }
//     else if( typeof vobj === 'function' )
//     {
//       if( vobj.apply( _this, args ) ) haveToUpdate = true
//     }

//     if( haveToUpdate ) {
//       _this[tempStore] = null
//       update.apply( _this, args )
//     }
//   }  
// })

exports.create( '$bubble', { 
  deferMethod: function( args, vobj, tempStore, update ) {
    var _this = this
    var doUpdate
    var references
    _this[tempStore] = null

    if( vobj ) {
      if(references = vobj.references) {
        if(references instanceof Object) {
          if(references.$lte 
            && _this.referenceLevel(_this._updateOrigin) <= references.$lte 
          ) {
            doUpdate = true
          }
        } else if(references > -1) {
          //also maximum for example
          // console.error(_this._path, _this.referenceLevel(_this._updateOrigin), 'uOriginPath', _this._updateOrigin._path, '._val',_this._val._path,  'cloud', !!_this._val.cloud)
          if( _this.referenceLevel(_this._updateOrigin) === references ) {
            doUpdate = true
          } 
        } 
        // else if(references === true) {
        //   //only if refference
        //   if(_this.referenceLevel(_this._updateOrigin)!==false) {
        //     doUpdate = true
        //   } 
        
        // }

      } else if( vobj && vobj.self === true ){

          if( args[2] === void 0 || this._val === args[0] || !args[0] && this._updateOrigin===this) {
            doUpdate = true
          }
        }
        
        if(doUpdate) {  
          update.apply(_this, args)
        } else {
          _this.clearReferencesCache()
        }

      } else {
        update.apply(_this, args)
      }

   
  }  
})

exports.create( 'defer' )

//TODO: vObj flag ( accessable trough object[flag] )

Value.operators.responseData = function( val, operator ) {
  return operator===false ? val : operator
}

//vobj parser!

exports.create( 'ajax', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
//     console.log('set ajax defer')
    if( ! this.loading ) {
      //name, val, vobj, stamp, noupdate, from
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor ) {
    var _this = this  

    return vobj && function( update, args ) {

      var origu = update

      update = function( type, kill ) {
        _this.clearCache()
        _this._skip = true
        _this._ignoreValue = true
        if( type ) {
          args[0] = type
          if(! ( _this._val instanceof vObject ) ) {
            _this.val = type
          } 
        }
        if( _this.loading ) _this.loading.val = false
        origu( kill )
        _this._ignoreValue = null
      }

      if( typeof vobj === 'object' )
      {
        var params = vobj
        vobj = {}
        for( var key in params ) {
          if( key === 'defer' ) {
            vobj[key] = params[key]
          } else {
            if(!vobj[key]) {
              if( key !== 'complete' && key !== 'error' && typeof params[key] === 'function' ) {
                vobj[ key ] = params[ key ].call( _this, vobj, args[0], args )
                if( !vobj[key] ) {
                  return true
                }
              } else {
                vobj[key] = params[key]
              }

              if( vobj[key] instanceof vObject ) {
                vobj[key] = vobj[key].val //custom get or raw
              } 
            }
          }
        }
      }

      if( typeof vobj === 'function' ) 
      {
        vobj = vobj.call( _this, vobj, args[0], args )
        if(!vobj) return true
      }

      if( typeof vobj === 'string' ) 
      {
        vobj = { url: vobj }
      }

      if( vobj.url instanceof vObject ) {
        vobj.url = vobj.url.val
      }

      if( !vobj || !( vobj.url || vobj.api ) ) 
      {
        return true
      }

      var complete = vobj.complete
        , error = vobj.error

      vobj.complete = function( data ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, null, data, vobj )
        }
        else
        {
          if(!_this.responseData) {
            _this.set( 'responseData', data )
          }
          else {
            _this.responseData.merge( data )
          }
          ;complete && complete( data )
          update( 'success' )
        }
      }

      vobj.error = function( err ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, err, vobj )
        }
        else
        {
          if( _this.responseData )
          { 
            _this.responseData.each( function( key ) {
              if( !Constructor.operators[key] && !Constructor.flags[key] )
              {
                this.remove()
              }
            })
          }
          _this.set( 'responseData' , void 0 )
          if( error ) error( data )
          update( 'error' )
        }
      }

      if( _this.loading ) {
        //TODO:correct responses managemet -- pretty easy todo
        _this.loading.val = true
      }

      ajax( vobj ) //TODO: let it return a promise
    }  
  }
})

//temp args 

//TODO: dit later vervangen met local flags (api)
//TODO: unify ajax hiermee voor oncsitent error handeling -- of extension op ajax
exports.create( 'apiDefer', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
    if(! this.loading ) {
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor, inProgress ) {
    var _this = this  
   
    return vobj && function( update, args ) {

      if( !args[0] || args[0].apiDefer ) return true

      var wrappedUpdate = function( val, kill ) {

        // console.error('DO DO DO', val, _this, tempStore, _this[tempStore])

        // _this[tempStore] = null
           
        // _this[inProgress] = null


        _this.loading.val = false
        if( val && val!==true ) 
        {
          _this.val = args[0] = val
          try {
            update( val ) //val -- val
          } catch( err ) {
            // console.error( 'DEEPER ERROR IN API DEFER , SOMETHING WRONG /w this API', val )
            //best example is facebook login true and gone but only weh the .loading is there
            //most be a very deep issues i geuss... hard to recreate 
            _this.type = err

            //this is wrong misses _this call and other args
            update( 'error' )
          }

          _this.clearCache()
          _this._val = false
        }
        else 
        {
          //this is wrong misses _this call and other args
          update( val )
        }
      }
      
      _this.loading.val = true
      var api = _this.checkParent( 'api', true )

      if( api && api.val !== true ) 
      {

        api.once(function( val ) {
          if( val === 'error' ) 
          {
            _this.clearCache() //hier ff een functie voor maken!
            _this.val = args[0] = 'error'
            _this.type = this.type || 'api'
            _this.loading.val = false
            wrappedUpdate()
          }
          else if( val === true )
          {
            vobj.call( _this, wrappedUpdate, args )
          }
        })
        api.val = true
      } 
      else
      {
        vobj.call( _this, wrappedUpdate, args )
      }
    }
  }
})

exports.create( 'init', 
{ set: function( set, args ) {
    if( !this.initialised )
    {
      set.apply( this, args ) //niet nodig!
    }
  }
, remove: function( remove, args ) {
    remove.apply( this, args )
    this.initialised = null
  }
, once: 'initialised'
})

module.exports = exports

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../browser/network/ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../util/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/process.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./');

/**
 * self
 * @flag
 */
flags.self = {
  reset: true,
  useVal:true,
  set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name')
    if (current._base && current._base[val]) {
      current._base[val].addListener(this)
      this._val = function() {
        return this[val] && this[val].val
      }
      if(!this._flag)  this._flag = {}
      this._flag.self = ['self', this._val, val, this]
    }
  }
};

},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = module.exports = require('./')
/**
 * listen
 * adds listeners to a V.Value
 * @property
 **/
flags.listen = {
  reset:true,
  set: function(val, stamp, reset) {
    if(!val)
    {
      console.error('no val in flags listen!')
//       debugger
      return
    }
    if(!this._flag) this._flag = {}
    //eventueel mergen!
      
    // console.log('listen'.cyan.inverse, reset, val)
    //if reset make sure its resetted correctly!
    this._flag.listen = ['listen', false, val, this ] 
    if (val instanceof Array) {
      for (var i = val.length - 1; i >= 0; val[i--].addListener(this));
    } else {
      //ok
      var _this = this
      // val.addListener(function() {
      //   console.log('TROUGH LISTEN!!!!'.magenta.inverse, val._path)
      //   // _this._update.apply(_this, arguments)
      // }) 
      val.addListener(this) //dit moet beter (remove listener if possible)
    }
  },
  remove:function() {
    if(this._flag&&this._flag.listen) {
      var val = this._flag.listen[2]
      if (val instanceof Array) {
        for (var i = val.length - 1; i >= 0; val[i--].removeListener(this));
      } else {
        val.removeListener(this) //dit moet beter (remove listener if possible)
      }
    }
  }
}

},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require( '../object' )
  , util = require( '../util' )
  , vigour = require( '../' )

/**
 * vigour.Value
 * v values are optimized for use in combination /w instances of vigourBase, have operators and support method values
 * @Class
 */
module.exports = exports = vigour.Value = object.new(
{ mixed: true
, merge: true
})

//parent problems

var _getOperator = function( val, force, i, t, bind, operators ) {
  var f = t[i]._get(bind, force, val);
  if (f !== void 0 && f !== null) {
    val = operators[i](val || ((typeof f === 'string') ? '' : 0), f);
  }
  return val;
};

exports.prototype._blacklist.push('_lstamp', '_clearCache', '_lval', '__lval','___lval', '_base', '_caller', '_bind', '_prop', '_instances', '_skip', '_overwrite')
//_caller stamp for get for lvals (last values)
util.define(exports,
  'clearCache', function() {
    this.___lval = null
    this.__lval = null
    this._lval = null 
  },
  'clearReferencesCache', function() {
    from = this._val
    while(from) {
      if(from.clearCache) from.clearCache()
      if(from && from._val) {
        from = from._val
      } else {
        from = null
      }
    }
  },
  'ignoreCache', { get:function() {
      var t = this
      while(t) {
        // console.log('hoe zit het??',t )
        if( t._prop && t._prop.cache === false ) return true
        t = t._parent
      } 
    } 
  },
  /**
   * Used to get .val which calculates a constructed value
   * _bind is very important binds listeners to specific instances
   * @method _get
   * @param  {[type]} bind  [description]
   * @param  {[type]} force [description]
   * @return {[type]}       [description]
   */
   '_get', function(bind, force, currentVal) {

    if(this._clearCache) {
      this.clearCache()
    }

    // console.log('_get',this._name, this._val,this);
    if (this._overwrite) {
      return this._overwrite;
    }
    if (!this._lval && this._lval !== 0 || force) {
      var val = this._val,
        nolval,
        operators = this.operators;

      if (val instanceof object) {
        val = val._get(this._bind || bind, force, currentVal);
      } else if (typeof val === 'function') {

        // console.log('RIGHT HERE', currentVal)
        var a = this;
        if (!bind) {
          while (a._parent && !a._caller) {
            a = a._parent;
          }
        }
        val = val.call(bind || a._caller || a._base || this, this, currentVal); //if currentval else something else;
        nolval = true;
        //for functions you need to clear _lval since you never know if there is something in the function updated
      }
      if (operators) {
        if (this.__t === 1 && operators[this._name]) { 
          //operator is an array
          val = 0; //string
          for (var j = 0, l = this.length; j < l; j++) {
            if (this[j]) {
              vj = this[j]._get(bind, false, (currentVal || 0) + val);
              if (!vj) {
                vj = 0; //string
              }
              if (typeof vj === 'string' && val === 0) {
                val = '';
              }
              val += vj; //only add no operator stuff
              if (!this[j]._lval) {
                nolval = true;
              }
            }
          }
        } else {
          //also add before
          var ordered;
          for (var i in this) {
            if (operators[i]) {
              if (!operators[i].order) {
                if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) {
                  force = true;
                }
                val = _getOperator(val, force, i, this, bind, operators);
                if (!nolval && !this[i]._lval) {
                  nolval = true;
                }
              } else {
                if (ordered) {
                  if (!ordered.pop) {
                    ordered = [ordered];
                  }
                  var o = operators[i].order,
                    ol = ordered.length - 1;
                  for (var h = 0; h !== true && h <= ol; h++) {
                    if (h === ol) {
                      if (o < operators[ordered[h]].order) {
                        var a = ordered[h];
                        ordered[ol] = i;
                        ordered.push(a);
                      } else {
                        ordered.push(i);
                      }
                      h = true;
                    } else if (h === ol && o > operators[ordered[h]].order) {
                      ordered.push(i);
                      h = true;
                    }
                  }
                } else {
                  ordered = i;
                }
              }
            }
          }
          //shorter
          if (ordered) {
            // console.log(ordered);
            var x;
            i = ordered.pop ? (x = 1) && ordered[0] : ordered;
            while (i && this[i]) {
              if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) force = true
              val = _getOperator(val, force, i, this, bind, operators);
              if (!nolval && !this[i]._lval) nolval = true
              i = ordered[x++];
            }
          }
        }
      }
      if (!nolval && !force) {
        this._lval = val;
        this.__lval = val;
      } else if (!(this._base && this._base.instances)) {
        this.__lval = val;
      }
      return val;
    } else {
      return this.__lval;
    }
  },
  /**
   * Fires all listeners
   * @method update
   * @param  {[type]} instance    [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @return {[type]}             [description]
   */
  'update',
  function(instance, noinstances, instancesUpdates, stamp, from, remove, added) {
    //is this really nessecary?
    this._update.call( this, void 0, stamp || this.stamp(), from, remove, false, false, noinstances, instance, instancesUpdates  ); //this.val
    return this;
  },
  /**
   * Extends vigourObject._update
   * Adds loads of stuff to optimize updates for calculations
   * @method _update
   * @param  {[type]} val         [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} instance    [description]
   * @return {[type]}             [description]
   */
  '_update',
  function( val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates ) {

    var t = this,
      base = t._base;

    if (val instanceof exports && !t._bind) 
    {
      if (val._caller) {
        t._bind = val._caller;
      }
    }

    if ( (!t._lstamp) || t._lstamp !== stamp  ) {

    // var operators = t.operators
    // var lval 
    // var calcVal
    // var passValueCache 

    // if( !t.ignoreCache ) {
    //   //TODO: this is a temporary fix needs to be faster
    //   //make this a method
    //   function cleanup(t) {
    //   	t._lval = void 0
    //   	t.__lval = void 0 
    //   	if(t._val instanceof object ) {
    //   		//TODO: if stuff doesnt update uncomment this line
    //   		// cleanup(t._val)
    //   	}
  	 //    for(var $field in t) {
  	 //    	if(operators[$field]) {
  	 //    		cleanup(t[$field])
  	 //    	} else if($field > -1) {
  	 //    		cleanup(t[$field])
  	 //    	}
  	 //    }
    // 	}
    //   cleanup(t)

    //   lval = t.___lval
    //   calcVal = t.val
    //   passValueCache = lval === void 0 || lval !== calcVal
    //   t.___lval = calcVal

    // } else {

      // t.clearCache()
      // passValueCache = true
    // }

     // if (  passValueCache || ( base && base.instances ) || t._skip ) { //pass this calculation to vset else its too heavy;

    t._lval = false  
    // t._skip = true
    if(base && base.instances || t._skip || t.__lval === void 0 || t.___lval !== t.val ) {

      // if(window.smut) {
        // console.log('wtf is happening!!!!', t._path, t, t._updateOrigin, arguments)
      // }

        var prop = t._prop,
          parent = t._parent,
          vset = prop && prop._vset;

        var operators = t.operators
  
        //make this better
        if (!(from && remove) && operators && (operators[t._name] || (parent && parent.__t === 1 && operators[parent._name] && (!from || t._name == parent.length - 1)))) {
          //works for arrays since arrays are always replaced on update , updating an individual item using .set will not result in an update at this pont which has to be resolved
          var _op = this._parent;
          while (operators[_op._name]) {
            _op._lval = false; //if no change to lval can go wrong...
            _op = _op._parent;
          }
          if (_op) {
          	//this geatly increases updates may be important for animation but not nessecary for anything else!
            _op._update(val, stamp, this, remove, added, oldval, noinstances, instance, instancesUpdates);
          }
        }

        if (instancesUpdates) {
          instancesUpdates.call(t, val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates);
        } else {
          if (instance) {
            base = instance;
          }
          if (vset) {
            t._caller = base;
            vset.call(t, stamp, from, remove, val);
          }
          if (base && vset && base.instances && !noinstances && prop.updateinstances !== false) {
            base.eachInstance(function() { //look for current caller instance perhaps?
              t._caller = this;
              vset.call(t, stamp, from, remove, val);
            }, prop.name, t);
            t._caller = base;
          }
          //form gone lets see!
          //from self doorgeven in chain ==-- if ! not from from ---> , extra arg
          object.prototype._update.call(t, val, stamp, from || t, remove, added, oldval)
        }

        //pas op met deze!
        t._lstamp = stamp;
    }
    else {
      // if(window.smut) console.log('catch it!', arguments)
    }


    }
  })

//requiring operators does not automaticly require vigourValue, may be handy?
util.define(exports, 'operators', {
  value: exports.operators = require('./operators')
})




},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js":[function(require,module,exports){
var Value = require('vigour-js/value'),
  util = require('vigour-js/util'),
  VObject = require('vigour-js/object')

exports.extend = util.extend(
  function(Target){
    if( Target.prototype instanceof VObject || Target === VObject) {
      // TODO: fix this to affect all VObject blacklists...
      Target.prototype._blacklist.push('_$length')

      util.define( Target,
        '$length', {
          get: function () {
            // TODO: ...so we dont have to do blacklist check:
            util.include(this._blacklist, '_$length')
            return this._$length || (this._$length = makeLength(this))
          }
        }
      )
    } else {
      throw new Error('cannot extend "$length" on non VObject Class')
    }
  }
)

function makeLength(instance) {
  var $length = new Value({
    val: function(){
      return getLength(instance)
    }
  })

  instance.on(function(val){

    // var identifier = instance._path.length 
    //   ? instance._path
    //   : instance._prop && instance._prop.name
    // console.log('UPDATE ON', identifier, 'SHINE DAT LENGTH?!', $length.val
    // )
    // TODO: only update if added or removed
    $length._update.apply($length, arguments)
  })

  return $length
}

function getLength (current) {
  if(!current){
    return 0
  } if (current._filter) {
    return current.length
  } else if (current.__t === 4) {
    return getLength(current._val)
  } else if (current.__t < 3) {
    return current.keys.length
  } else if (typeof current._val === 'string') {
    return current._val.length
  } else {
    return 0
  }
}

},{"vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/on.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    Extension for Base classes to create an inheritable on - value
  */

var Value = require('./')
  , util = require('../util')
  , Base = require('../base')

exports.extend = util.extend
( function(base)
  {
    if( base instanceof Base )
    {

      base.extend
      (
        {
          name:'on',
          set:function(val) {
            
          },
          remove:function(val) {
            //remove
            // console.log('im being removed!')
             if(this.on.$remove) {
              this.on.$remove.update()
            }
          },
          new:function(val) {
            //init
            // console.log('INIT!----', this, val, arguments)
            if(this.on.$new) {
              this.on.$new.update()
            }
          },
          parent:function(val) {
            //init
            if(this.on.$parent) {
              this.on.$parent.update()
            }
          },
          render:function(val) {
            //init
            // console.log('RENDER!----', this, val, arguments)
            if(this.on.$render) {
              this.on.$render.update()
            }
          }
        }
      )

    }
    else
    {
      throw new Error('cannot extend "on" on non Base Class')
    }
  }
)

},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js":[function(require,module,exports){
/**
 * operators
 * operators can be set on V.Value.operators
 * define operators on this module
 * @property
 */
var util = require('../util')
  , V = require('../')
  
exports.add = function( val, operator ) {
  return val + operator
}
exports.sub = function( val, operator ) {
  return val - operator
}
exports.multiply = function( val, operator ) {
  return val * operator
}
exports.divide = function( val, operator ) {
  return val / operator
}
exports.max = function( val, operator ) {
  return val > operator ? operator : val
}
exports.min = function( val, operator ) {
  return val < operator ? operator : val
}
exports.transform = function( val, operator ) {
  return operator === false ? val : operator
}
exports.abs = function( val, operator ) {
  return operator ? Math.abs(val) : val
}
exports.floor = function( val, operator ) {
  return val | 0
}
exports.ceil = function ( val, operator ) {
  return Math.ceil( val )
}
exports.prepend = function( val, operator ) {
  return operator + val
}
exports.or = function ( val, operator ) {
  return val || operator
}
exports.when = function( val, operator ) {
  return operator && val
}
exports.$convertType = function ( val, operator ) {
  //convertType
  if( operator === 'boolean' )
  { 
    return val ? true : false
  } 
  else if( operator === 'number' )
  {
    //do isNan start using loDash for this kind of stuff ( almost nothing )
    //convert falsy or NaN values to 0
    return Number( val )
  }
}

exports.$convertTime = function( time, decimals ) {
  var hrs = ~~ (time / 3600)
  var mins = ~~ ((time % 3600) / 60)
  var secs = !isNaN(parseFloat(decimals)) && isFinite(decimals)
      ? (time % 60).toFixed(decimals) : ~~(time % 60)

  ret = "";
  if (hrs > 0) ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
  ret += "" + mins + ":" + (secs < 10 ? "0" : "");
  ret += "" + secs;
  return ret || 0;
};

exports.default = function( val, operator ) {

// console.log( '????', val )
  
  //pas op met die 0
  if( (!val && val !== 0) || val._val === false || val === 'error' || val === 'success' )
  {
    //TODO: Arrays for default operator
    return operator
  }
  return val
}

exports.default.order = 1000
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/index.js":[function(require,module,exports){
module.exports = exports = require('./lib/')
},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/lib/index.js":[function(require,module,exports){
var pkg = require('../package.json')
  , pluginId = pkg.plugin.id

module.exports = exports = {}

exports.get = function (opts, cb) {
  if (!cb) {
    cb = opts
    opts = {}
  }
  try {
    window.vigourNative.bridge(pluginId, 'get', opts, cb)
  } catch (e) {
    cb(e)
  }
}

exports.set = function (opts, cb) {
  if (!cb) {
    cb = opts
    opts = {}
  }
  try {
    window.vigourNative.bridge(pluginId, 'set', opts, cb)
  } catch (e) {
    cb(e)
  }
}
},{"../package.json":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/package.json"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/package.json":[function(require,module,exports){
module.exports={"name":"vigour-native-statusBar","version":"2015/06/08 17:19:02 UTC (0.0.1)","author":{"name":"Shawn Inder","email":"shawn@vigour.io"},"repository":{"type":"git","url":"git+https://github.com/vigour-io/vigour-native-statusBar.git","branch":"master"},"engines":{"node":">=0.10.0"},"main":"index.js","scripts":{"start":"gaston","test":"test/test.js"},"description":"Allows one to control the native status bar from a web app","keywords":["vigour","native","plugin","statusBar"],"bugs":{"url":"https://github.com/vigour-io/vigour-native-statusBar/issues"},"homepage":"https://github.com/vigour-io/vigour-native-statusBar","dependencies":{"gaston":"git+ssh://git@github.com/vigour-io/gaston.git","vigour-native":"git+ssh://git@github.com/vigour-io/vigour-native.git","vigour-fs":"git+ssh://git@github.com/vigour-io/vigour-fs.git","vigour-dev-tools":"git+ssh://git@github.com/vigour-io/vigour-dev-tools.git"},"optionalDependencies":{},"devDependencies":{"npm":"^2.7.6","npmlog":"^1.2.0"},"plugin":{"id":"statusbar","android":{"className":"io.vigour.plugin.statusbar.StatusBarPlugin","instantiation":"new StatusBarPlugin(this, webView)","libName":"statusbar-debug.aar"}},"gitHead":"588de4723cbde673fb22b4a28b70472045d3c8ff","readme":"# vigour-native-statusBar\nAllows one to control the native status bar from a web app\n\n##Install\n`npm i vigour-native-statusBar`\n\n##Usage\nSee [test/index.js](test/index.js)\n\n##Building a set of native apps from your codebase\n- `npm run build`\n- `npm run build -- ios android`","readmeFilename":"README.md","_id":"vigour-native-statusBar@0.0.1","_shasum":"81cc25910be7f1595417c3b8fdfb8382b1247f47","_from":"git+ssh://git@github.com/vigour-io/vigour-native-statusBar.git","_resolved":"git+ssh://git@github.com/vigour-io/vigour-native-statusBar.git#588de4723cbde673fb22b4a28b70472045d3c8ff","sha":"0.0.1"}
},{}],"/Users/shawn/Work/directv-fl/src/app/index.js":[function(require,module,exports){
var app = module.exports = require( 'vigour-js/app' )
  .inject(
    require( 'vigour-js/app/content' ),
    require( 'vigour-js/app/user' )
  )

require( './user' )
require( './values' )
require( './playback')
require( './init' )

window.a = app

},{"./init":"/Users/shawn/Work/directv-fl/src/app/init.js","./playback":"/Users/shawn/Work/directv-fl/src/app/playback.js","./user":"/Users/shawn/Work/directv-fl/src/app/user.js","./values":"/Users/shawn/Work/directv-fl/src/app/values.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","vigour-js/app/user":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js"}],"/Users/shawn/Work/directv-fl/src/app/init.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var config = require( 'vigour-js/util/config' )
var user = app.user

// preloader
app.css = {
  addClass: 'preload'
}

user.data.is( 'loaded' )
  //do this later when content gets bound
  .then( function() { 
    app.ready.val = true
    //add this later
    // return app.content.is( 'loaded' ) 
  })
  .done( function() {
    app.css = {
      removeClass: 'preload'
    }
  })



app.initialised.once(true, function() {
  // console.log(document.domain.replace(/\:\d\d\d\d/, ':10001'))

  app.cloud = config.cloud === 'domain' ? document.domain+ ':10001'  : config.cloud
// =======
  // if(window.gaston && window.gaston.serverAddress.indexOf('{') === -1) {
  //   app.cloud = 'ws://' +
  //     window.gaston.serverAddress.split('//')[1].split(':')[0] + 
  //     ':10001'
  // } else {
  //   app.cloud = 'ws://' + config.cloud
  // }
  
// >>>>>>> dev
  user.token.val = 'futureland'
})

/*   
'ws://' 
  + window.gaston.serverAddress.split('//')[1].split(':')[0]
  + ':10001'//
*/

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/app/playback.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var Value = require( 'vigour-js/value' )
var cases = app.cases
var user = app.user

app.isPlaying.val = {
  val: false,
  $isReceiver:user.receiver.playing
}

app.volume = {
  val:1,
  $isReceiver: user.receiver.volume
}

cases.$isPlaying = app.isPlaying

if(cases.$isPhone) {
  app.popup.on(function(val) {
    if(val) {
      if(app.isPlaying.val===true) {
        app.isPlaying.from.val = false
        app.popup.is(function() {
          return this.val === false
        }, function() {
          app.isPlaying.from.val = true
        })
      }
    }
  })
}

cases.$isFullscreen = new Value( {
  val: function() {
    return app.state.val === 'player'
  },
  listen: app.state
} )

// cases.$isLoadingVideo = new Value( {
//   val: false,
//   defer: function( update ) {
//     var _this = this
//     if ( this._timer ) {
//       clearTimeout( this._timer )
//       this._timer = null
//     }
//     if ( this._val ) {
//       this._timer = setTimeout( function() {
//         _this.val = false
//         _this._timer = null
//       }, 2000 )
//     }
//     update()
//   }
// } )

// app.isPlaying.on( function( val ) {
//   if ( cases.$isLoggedIn.val ) {
//     if ( val === true ) {
//       // TODO: this crashes now, so i commented it out
//       // var media = app.user.navigation.media.from
//       // if ( media._parent._name !== 'channels' ) {
//       //   var epi = app.user.usage.from.get( media._contentPath ),
//       //     show = epi._parent._parent._parent._parent

//       //   if ( show ) {
//       //     show.set( 'media', media )
//       //   }
//       // }
//     }
//   }
// })

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/app/user.js":[function(require,module,exports){
var app = require('vigour-js/app')
var user = app.user.inject(
  require('vigour-js/app/user/token'),
  require('vigour-js/app/user/usage'),
  require('vigour-js/app/user/navigation'),
  require('vigour-js/app/user/multiscreen')
)

user.set({
  search: false,
  focus_row: 'spotlight',
  // focus_channels:0,
  focus_actor:0,
  focus_channels:0,
  focus_spotlight:0,
  focus_watching:0,
  focus_recommended:0,
  focus_releases:0,
  recentSearches: {},
  popup:0,
  trailerMuted:true
  // url: require( 'vigour-js/browser/network/url' )
})

app.popup.val = user.popup

var Value = require('vigour-js/value')

app.deviceMessage = new Value({
  val: user.receiverClient,
  transform: function( c, cv ){
    var title = cv && cv.from && cv.from.title && cv.from.title.val
    // console.error('deviceMessage! ', title)
    return title ? 'Connected to ' + title : 'Not Connected'
  }
})

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/user/multiscreen":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/multiscreen/index.js","vigour-js/app/user/navigation":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/navigation.js","vigour-js/app/user/token":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/token.js","vigour-js/app/user/usage":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/usage.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/app/values.js":[function(require,module,exports){
var app = require('./')
var user = app.user
var cases = app.cases
var Value = require('vigour-js/value')
  // TODO: base this on device role
// app.state.val = {
//   default: 'first'
// }

app.state.val = cases.$isPhone ? 'first' : 'second'

app.current = new Value({
  val: user.navigation.last,
  transform: function(v, last) {
    var key = last.key && last.key.val
    return key === 'page' ? user.navigation.page.val : key
  },
  listen: [
    user.navigation.content,
    user.navigation.page
  ]
})

app.previous = new Value({
  val:app.current,
  defer:function(update,args){
    var val = this._val.val
    if(typeof val === 'string' && val !== this.current){
      this.prev = this.current
      this.current = val
    }
    update()
  },
  transform:function(val){
    return val._parent.prev || 0
  }
})

app.secondPopup = new Value(false)

app.hideStatusbar = new Value({
  val: false,
  transform: app.isPlaying
})

cases.$hasReceiver.on(function() {
  app.css = this.val ? {
    addClass: 'hasReceiver'
  } : {
    removeClass: 'hasReceiver'
  }
})

if(!cases.$isPhone){
  cases.$isReceiver.on(function(){
    app.state.val = this.val ? 'second' : 'inactive'
  })
}
},{"./":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/channel/index.js":[function(require,module,exports){
require('./style.less')

var Actors = require('/Users/shawn/Work/directv-fl/src/components/shared/actors')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')
var Progress = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar').Bar
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Poll = require('/Users/shawn/Work/directv-fl/src/components/shared/poll')
var Statistics = require('/Users/shawn/Work/directv-fl/src/components/shared/statistics')
var Trivia = require('/Users/shawn/Work/directv-fl/src/components/shared/trivia')
var Content = require('../content')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/bar')
var Tweets = require('/Users/shawn/Work/directv-fl/src/components/shared/tweets')

module.exports = new Content({
  'holder.page': {
    container:{
      'model.field':'guide.0',
      titlebar:new Bar({
        css: 'ui-bar',
        accent: {},
        left: {
          title:new Title(),
          timefiller: {
            'left.text.data':'start-time',
            'middle.filler': new Progress({
              'seek.w': '75%'
            }),
            'right.text.data':'end-time'  
          }  
        }
      }),
      description:new Description({
        display:{
          data:'description',
          transform:function(v,cv){
            return cv ? 'block' : 'none'
          }
        }
      }),
      actors:new Actors(),
      poll:new Poll(),
      statistics:new Statistics(),
      trivia:new Trivia(),
      tweets:new Tweets(),
    },
    collection:{
      data:'guide',
      element:new Bar({
        left: {
          title:new Title(),
          info: {
            'left.text':{
              data:'start-time',
              add:[
                ' - ',
                {data:'end-time'}
              ]
            }
          }  
        }
      })
    }
  }
}).Class

},{"../content":"/Users/shawn/Work/directv-fl/src/components/active/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/channel/style.less","/Users/shawn/Work/directv-fl/src/components/shared/actors":"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js","/Users/shawn/Work/directv-fl/src/components/shared/bar":"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/poll":"/Users/shawn/Work/directv-fl/src/components/shared/poll/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/statistics":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","/Users/shawn/Work/directv-fl/src/components/shared/trivia":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js","/Users/shawn/Work/directv-fl/src/components/shared/tweets":"/Users/shawn/Work/directv-fl/src/components/shared/tweets/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/channel/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/content/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Player = require('/Users/shawn/Work/directv-fl/src/components/active/player')
var Topbar = require('/Users/shawn/Work/directv-fl/src/components/active/topbar')

module.exports = new Element({
  css: 'content-item',
  x: {
    translate: true
  },
  scrollbar: 'y',
  holder: {
    y: {
      val: 0,
      animation: {
        time: 18,
        easing: 'outCubic',
        complete: function() {
          var _this = this
          if (this.y.val === -this.player.h.val - 1) {
            if (!_this.isSwipedup.val) {
              _this.swipeup.display = 'none'
            }
            if (!_this.timeouty) {
              _this.timeouty = setTimeout(function() {
                if (_this.isSwipedup.val) {
                  _this.swipeup.display = 'block'
                }
                _this.timeouty = false
                _this.y.val = _this.isSwipedup.val ? -_this.player.h.val + 30 : 0
              }, 0)
            }
          }
        }
      }
    },
    player: new Player(),
    swipeup: {
      display: 'none',
      nested: {
        position: 'absolute',
        w: app.w,
        h: app.h,
        msg:{
          icon:new Icon({
            icon:'pullback'
          }),
          text: 'Resume Here'
        },
        'events.click': function() {
          app.user.receiver.media.$userOrigin = false
        }
      },
      y: {
        val: app.h,
        multiply: -1
      },
      h: app.h
    },
    extend: {
      isSwipedup: function(val) {
        if (!this.rendered && val && val.val) {
          this.swipeup.display = 'block'
          this.y = -this.player.h.val + 30
        } else if (this.swipeup.display.val === 'block') {
          this.y = -this.player.h.val - 1
        } else {
          this.y = val.val === true ? -this.player.h.val - 1 : 0
        }
      },
      receiverMedia: function(val) {
        var data = this.parent.data
        if(data){
          var swipeup = this.isSwipedup = val.from === data.from
          if (swipeup) {
            this.player.playing.from = false
          } else {
            var time = data.from.get('time')
            if (time.val < 0) {
              data.from.get('time').val = Math.abs(time.val)
            }
          }
        }
      }
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/active/content/style.less","/Users/shawn/Work/directv-fl/src/components/active/player":"/Users/shawn/Work/directv-fl/src/components/active/player/index.js","/Users/shawn/Work/directv-fl/src/components/active/topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/content/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/discover/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var _focused = require('/Users/shawn/Work/directv-fl//src/components/util').focused
var List = require('/Users/shawn/Work/directv-fl//src/components/shared/list')

var ListHolder = new Element( {
  'header.text':{data:'title'},
  'events.down': function( e ) {
    var _this = this
    var holder = this.parent
    var eY = e.y
    var eX = e.x
    var id = 'passCheck'

    this.addEvent( 'move', function( e ) {
      var dY = e.y - eY
      var dX = e.x - eX
      if ( Math.abs( dX ) > Math.abs( dY ) ) {
        holder.$focus.$userOrigin = _this.name
      }
      _this.removeEvent( false, id )
    }, id )

    this.addEvent( 'up', function( e ) {
      _this.removeEvent( false, id )
    }, id )
  }
} ).Class

module.exports = new Element( {
  css: 'first-discover',
  spotlight: new ListHolder( {
    header:false,
    list: new List.Spotlight({'model.field':'spotlight'}),
    dots: new List.Dots()
  } ),
  channels: new ListHolder({
    model:{field:'channels'},
    list: new List.Channel()
  } ),
  watching: new ListHolder( {
    model:{field:'watching'},
    list: new List.Watching()
  } ),
  releases: new ListHolder( {
    model:{field:'releases'},
    list: new List.Poster()
  } ),
  recommended: new ListHolder( {
    model:{field:'recommended'},
    list: new List.Poster()
  } ),
  extend:{
    $focus: function( val ) {
      var child = typeof val.val === 'string'
        ? this[val.val]
        : this.children[ val.val || 0 ]
      _focused( this, child )
    }
  },
  scrollbar: 'y',
  'events.scroll': function( e ) {
    if(exports.ignoreScroll) return
    var node = this.node
    var fraction = (exports.scrollTop = node.scrollTop) / ( node.scrollHeight - node.offsetHeight )
    var index = Math.round( fraction * ( this.children.length - 1 ) )
    var name = this.children[index].name
    this.$focus.$userOrigin = name
  },
  setSetting: {
    name: 'prepValues',
    parent: function() {
      var children = this.children
      var child
      var field
      var length = children.length
      var i = length - 1
      var obj

      for ( ; i >= 0; i-- ) {
        child = children[i]
        field = 'focus_' + children[i].name
        if ( !app.user[ field ] ){
          obj = {}
          obj[ field ] = 0
          app.user.set( obj )
        }
        child.list.$focus = app.user[ field ]
        if(child.dots) child.dots.container.$focus = app.user[ field ]
      }

      if(exports.scrollTop){
        exports.ignoreScroll = true
        this.node.scrollTop = exports.scrollTop
        window.requestAnimationFrame(function(){
          exports.ignoreScroll = false
        })
      }else{
        var _this = this
        exports.ignoreScroll = true
        window.requestAnimationFrame(function(){
          exports.ignoreScroll = false
          var node = _this.node
          if(node){
            var focus = _this.$focus.val
            var index = getIndex(_this[focus])
            node.scrollTop = index/(length - 1) * ( node.scrollHeight - node.offsetHeight )
          }
        })
      }

    }
  }
} ).Class

function getIndex( _this ){
  if (_this._index === void 0) {
    var siblings = _this.parent.children
    for (var i = siblings.length - 1; i >= 0; i--) {
      siblings[i]._index = i
    }
  }
  return _this._index
}

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/active/discover/style.less","/Users/shawn/Work/directv-fl//src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/discover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/episode/index.js":[function(require,module,exports){
require('./style.less')

var Movie = require('../movie')

module.exports = new Movie({
  'holder.page': {
    'actors.body.collection.data':'show.actors',
    'recommendations.body.collection.data':'show.recommendations'
  }
}).Class


},{"../movie":"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/episode/style.less"}],"/Users/shawn/Work/directv-fl/src/components/active/episode/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var cases = app.cases
var Topbar = require('./topbar')
var Menu = require('./menu')
var Remote = require('./remote')
var Popup
var First

//app alleen maar zo requiren zodat je erbij kan vars moeten altijd megegevb wirden
//app kan je usen voor dingen als app.w, app.h of default cases

if ( cases.$isPhone ) {

  var Switcher = require( './switcher' )

  First = new Element({
    // w:app.w,
    y:{val:0,translate:true},
    // h:app.h,
    css: 'first-state',
    menu: new Menu({
      menu: app.menu
    }),
    on: {
      //replace on with extended vars (nicer) maybe make a type for this (value that also tries to get parent if its no full)
      //value that has a function on it thats just the defer?
      popup:{
        defer:function(update) {
          this.clearCache()
          var caller = this._parent._caller
          if(typeof this.val === 'string' || this.from._contentType === 'actors') {
            if(!caller.popup) {
              Popup = Popup || require('./popup')
              caller.set({
                popup: new Popup({
                  popup:this._val
                })
              })
            }
          }
          update()
        }
      },
      secondPopup:{
        defer:function(update) {
          this.clearCache()
          var caller = this._parent._caller
          if(typeof this.val === 'string' || this.from._contentType === 'actors') {
            if(!caller.volume) {
              Popup = Popup || require('./popup')
              caller.set({
                volume: new Popup({
                  popup:this._val
                })
              })
            }
          }
          update()
        }
      }
    },
    holder: {
      css:{
        val: app.menu, 
        transform: function(val, cv) {
          return cv ? 'open' : ''

        }
      },
      x:{ 
        val: app.menu,
        multiply:325,
        animation:{ time: 12, easing:'outCubic' } 
      },
      topbar: new Topbar(),
      // w: {
      //   parent: 'w'
      // },
      // h:{
      //   parent: 'h'
      // },
      events: {
        down:function(e) {
          if(app.menu.val) {
            e.prevent = true
            app.menu.val = false
          }
        }
      },
      switcher: new Switcher({
        // w:app.w,
        // h:{ val:app.h,sub:Topbar.base.h }
      }),
      miniplayer: new Remote({
        
      }) 
    }
  }).Class

} else {

  First = new Element({
    text: 'oops not phone in firstscreen'
  }).Class

}

module.exports = First
},{"./menu":"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js","./popup":"/Users/shawn/Work/directv-fl/src/components/active/popup/index.js","./remote":"/Users/shawn/Work/directv-fl/src/components/active/remote/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/style.less","./switcher":"/Users/shawn/Work/directv-fl/src/components/active/switcher/index.js","./topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js":[function(require,module,exports){
require('./style.less')
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')

var MenuItem = new Element({
	icon: new Icon({icon:'search'}),
	css:'menu-item',
	title:{}
}).Class

module.exports = exports = new Element({
	w:app.w,
	h:app.h,
	logo: {},
	css:'menu',
	extend: {
		menu:function(){},
		navigation:function(){}
	},
	// scrollbar:'y',
	append: [
		MenuItem,
		{ 'title.text':'search',
			'icon.icon': 'searchMenu',
			'events.click':function() {
				this.parent.navigation.from.page.$userOrigin = 'search'
				this.parent.menu.from.val = false
			}
		},
		{ 'title.text':'discover',
			'icon.icon': 'discover',
		 'events.click':function() {
				this.parent.navigation.from.page.$userOrigin = 'discover'
				this.parent.menu.from.val = false
			}
		},
		{
			'title.text':'on demand',
			'icon.icon': 'shows',
			css:'menu-item inactive'
		},
		{
			'title.text':'live tv',
			'icon.icon': 'tv',
		  css:'menu-item inactive'
		},
		{
			'title.text':'guide',
			'icon.icon': 'epg',
			css:'menu-item inactive'
		}
	],
	footer: {
		profile:{},
		title: {
			text:'Kevin Tague'
		},
		settings: new Icon({
			icon:'settings'
		})
	}
}).set({
	navigation:{
		defer:function(update) {
			if(this.from.page) {
				for(var i in this._caller.children) {
					var child = this._caller.children[i]
					var title = child.title &&  child.title.text.val
					var page = this.from.page.val

					if( title && title===page && this._focused!==child) {
						if(this._focused) {
							this._focused.css ='menu-item'
						}

						this._focused = this._caller.children[i]
						this._focused.css = 'menu-item focused' 
						break;
					}
				}
			}
			update()
		}
	}
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/menu/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/menu/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js":[function(require,module,exports){
require('./style.less')

var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/bar')
var Actors = require('/Users/shawn/Work/directv-fl/src/components/shared/actors')
var Recommendations = require('/Users/shawn/Work/directv-fl/src/components/shared/recommendations')
var Content = require('../content')
var Mpaa = require('/Users/shawn/Work/directv-fl/src/components/shared/mpaa')
var Rating = require('/Users/shawn/Work/directv-fl/src/components/shared/rating')

module.exports = new Content({
  'holder.page': {
    titlebar:new Bar({
      left:{
        title:new Title(),
        subtitle:new Subtitle()
      },
      right:{
        mpaa:new Mpaa(),
        rating:new Rating()
      }
    }),
    description: new Description(),
    actors:new Actors(),
    recommendations:new Recommendations()
  }
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/active/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/movie/style.less","/Users/shawn/Work/directv-fl/src/components/shared/actors":"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js","/Users/shawn/Work/directv-fl/src/components/shared/bar":"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mpaa":"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js","/Users/shawn/Work/directv-fl/src/components/shared/rating":"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js","/Users/shawn/Work/directv-fl/src/components/shared/recommendations":"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/movie/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/player/fullscreen.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')

var Fullscreen = new Element({
  icon: new Icon({ icon: 'fullscreen' }),
  events: {
    click: function(){
      console.log('go fullscreen!')
    }
  }
}).Class

module.exports = Fullscreen

},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/player/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Video = require('vigour-js/browser/element/video')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var app = require('vigour-js/app')
var Fullscreen = require('./fullscreen')
var Seekbar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar')

var postpone = require('vigour-js/browser/events/util').postpone

var ASSETS = require('vigour-js/util/config').pointers.assets

var cases = require('vigour-js/browser/cases')

var Loader = require('/Users/shawn/Work/directv-fl/src/components/shared/loader')

var Player = new Element({
  css:'first-player',
  video: new Video({
    player: require( 'vigour-js/browser/element/video/html5' ),
    src: { data: 'video', prepend: ASSETS },
    duration: { data: 'duration' },
    volume: 1,
    time: { data: 'time' },
    events:{
      stalled:function() {
        var preload = this.parent.preload
        if( preload ) preload(true)
      },
      play: function() {
        if(this.rendered && this.getBuffer()<0.001) {
          this.parent.preload(true)
        }
      },
      canplay:function() {
        this.parent.preload(false)
      },
      progress: function(p, b) {
        //dit gaat eruit

        if(this.preloading && b-p > 0.1) {
          this.parent.preload(false)
        }

        if(this.data._contentType!=='channels') {
          this.data.from.set('time', -Math.abs(p))
        }
      }
    }
  }),
  h:210,
  // loader: {
  //   'w,h':200,
  // },
  overlay: {
    middle: {
      left: { play: {
          icon: new Icon({ 
            icon: {
              val: 'play',
              $isPlaying: 'pause'
            } 
          }),
          subtitle: {
            text: {
              val: 'Play',
              $isPlaying: 'Pause'
            }
          },
          events: {
            down: function(e){
              if(this.checkParent('overlay',true).opacity.val > 0.5) {
                var playing = this.checkParent('overlay').playing.from
                playing.val = !playing.val
                // e.tempPrevent = true
                e.prevent = true
              }
            }
          }
        }
      },
      middle: { 
        line: {},
        display: {
          val: 'none',
          $hasReceiver: 'table-cell',
          transform: function(){}
        }
      },
      right: { 
        swipeup: {
          icon: new Icon({ icon: 'swipeup' }),
          subtitle: {
            text: 'Play on '
          },
          events: {
            down: function(e){
              if(this.checkParent('overlay',true).opacity.val > 0.5) {
                app.user.receiver.playing.$userOrigin = true
                app.user.receiver.media.$userOrigin = this.checkParent('data',true).from
                e.prevent = true
              }
            }
          }
        },
        display: {
          val: 'none',
          $hasReceiver: 'table-cell',
          transform: function(){}
        }
      }
    },
    bottom: {
      left: { 
        table: {
          display: {
            data:function(data) {
              return data._contentType==='channels' ? 'none' : 'table'
            }
          },
          time:{ holder: { text:{data:'time', multiply: { data:'duration'}, abs:true, $convertTime:true } } },
          holder :{
            seekbar: new Seekbar({
             button:{y:{val:-8,translate:true}}
            })
          },
          duration:{ text:{ data:'duration', $convertTime:true } }
        }
      },
      right: { fullscreen: new Fullscreen() }
    },
    opacity: {
      val:1, animation:{
        time:18,
        easing:'outCubic'
      }
    }
  },
  define: {
    preload: function(val) {
      // if(val===true && this.rendered) {
      //  this.preloading = true
      //  this.overlay.bottom.left.table.holder.seekbar.css = 'ui-seekbar loading'
      //  this.overlay.opacity = 1
      // } else {
      //   this.preloading = false
      //   this.overlay.bottom.left.table.holder.seekbar.css = 'ui-seekbar'
      //   if(this.video.$playing.val===true) {
      //     this.overlay.opacity = 0
      //   }
      // }
    },
    fadeOut:postpone(function() {
      if(this.playing && this.playing.val===true && !this.preloading) {
        this.overlay.opacity = 0
      }
    },3000)
  },
  events: {
    down: function(e) {
      if(this.overlay.opacity.val===0 || e.tempPrevent) {
        this.overlay.opacity = 1 
        if(this.playing.val===true) {
          this.fadeOut()
        }
      } else if(this.playing.val===true && !e.tempPrevent) {
        this.overlay.opacity = 0
      }
    },
    move:function() {
      if(this.playing.val===true) {
        this.fadeOut()
      }
    }
  },
  extend:{
    playing: {
      set:function(val) {
        this.video.$playing = val
        if(val.val===true) {
          this.overlay.opacity = 0
        } else {
          this.overlay.opacity = 1
        }
      // if()
      },
      remove:function() {
        app.isPlaying.from = false
      }
    },
    receiver: function(val, stamp) {
      if(cases.$hasReceiver.val) {
        var receiverClient = val.from
      }
    }
  }
}).Class

module.exports = Player

},{"./fullscreen":"/Users/shawn/Work/directv-fl/src/components/active/player/fullscreen.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/player/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/loader":"/Users/shawn/Work/directv-fl/src/components/shared/loader/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/player/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/index.js":[function(require,module,exports){
require('./style.less')

var Page = require('../page.js')
var app = require('vigour-js/app')
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var List = require('/Users/shawn/Work/directv-fl/src/components/shared/list')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var Trivia = require('/Users/shawn/Work/directv-fl/src/components/shared/trivia')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')

module.exports = exports = new Page({
  w: app.w,
  h: {
    val: app.h,
    sub: 60
  },
  scrollbar: 'y',
  carousel: {
    container: new List.Carousel({
      collection: {
        data: 'img.cover',
        element: new Element({
          css: 'focus-item',
          img: new Img({
            overlay: {},
            'background.data': true
          })
        })
      },
      $focus: {
        data: 'focus'
      }
    }),
    dots: new List.Dots({
      container: {
        collection: {
          data: 'img.cover',
          element: new Element()
        },
        $focus: {
          data: 'focus',
          default:0
        }
      }
    }),
    'model.subscription': {
      img: {
        cover: {
          $: true
        }
      }
    }
  },
  bio: new Description({
    'header.text': 'bio',
    'body.text.data': 'bio'
  }),
  famous: {
    'header.text': 'Famous For',
    collection: {
      data: 'catalog',
      element: new Poster({
        'events.click': function() {
          app.popup.$userOrigin = false
          app.user.navigation.content.$userOrigin = this.data.from
        }
      })
    }
  },
  trivia: new Trivia({
    model: {
      field: 'trivia'
    }
  }),
  on: {
    $parent: {
      defer: function(update) {
        this._parent._caller.parent.parent.topbar.middle.text = this._parent._caller.data.get('title')
        update()
      }
    }
  }
}).Class

},{"../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/style.less","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl/src/components/shared/trivia":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var cases = require( 'vigour-js/browser/cases' )
var ua = require( 'vigour-js/browser/ua' )

var raf = require( 'vigour-js/browser/animation/raf' )
var app = require( 'vigour-js/app' )
var Icon = require( '../../../shared/icon' )

var Device = new Element({
  css: 'device',
  icon: new Icon({ icon: { 
    data: 'device'
  } }),
  info: {
    title: { text: { data: 'title'} },
    subtitle: { text: { data: 'info' } }
  }
}).Class

module.exports = exports = new Element( {
  css: 'active devices',
  myDevice: new Device({
    model: { inherit: false },
    on: {
      $new: {defer: function(update){
        this._parent._caller.data = app.cloud.client
        update()
      }}
    },
    info: {
      title: { text: 'This Device' },
      subtitle: { text: { data: 'title' } }
    }
  }),
  listTitle: { text: 'Available Devices' },
  middle: {
    display: {
      val: 'block',
      $hasDevices: 'none'
    },
    text: 'No Devices Available'
  },
  list: {
    display: {
      val: 'none',
      $hasDevices: 'block'
    },
    collection: {
      element: new Device( {
        css: 'device',
        model: function( data ) {
          if( data && data.from && data.from.device && 
              /(phone)/.test(
                data.from.device.val 
              )
            ) {
            this.opacity = 0.5
          }
        },
        events: {
          click: function() {
            var user = app.user//this.checkParent( 'on.user', true )._val
            var client = this.data.from
            if( /(tv)|(tablet)|(IFE)/.test( 
                  client.device.val 
                ) 
              ) {
              user.setReceiver( client )
            }
          }
        }
      } ),
      data: true
    }
  },
  on: {
    $render: {
      defer: function(update) {
        // ff binden nog
        var caller = this._parent._caller
        caller.on.devices._val._update()
        update()
      }
    },
    $parent:{
      defer:function(update) {
        this._parent._caller.parent.parent.topbar.middle.text = 'devices'
        update()
      }
    },
    devices: {
      defer: function( update ) {
        var caller = this._parent._caller
        caller.on.receiver._update()
        caller.data = this.from
        update()
      }
    },
    receiver: {
      defer: function( update ) {
        var _this = this
        // TODO: get rid of this raf
        raf( function() {
          if ( _this._parent ) {
            var caller = _this._parent._caller
            var receiver =  _this.from
              
            var elem = caller.list.find( '_d.from', receiver.from )
            if ( elem ) {
              if ( _this.focus && _this.focus._node ) {
                _this.focus.css = {
                  removeClass: 'focused'
                }
              }
              _this.focus = elem
              elem.css = {
                addClass: 'focused'
              }
            } else if ( _this.focus ) {
              if ( _this.focus && _this.focus._node ) {
                _this.focus.css = {
                  removeClass: 'focused'
                }
                _this.focus = null
              }
            }
          }
          update()
        } )
      }
    }
  }
} ).Class

},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')

var Popup = require('../../shared/popup')

var Actor
var Volume
var Devices
var Remote

//basis of popup is shared (also used for remote? or is remote a popup thing?)

module.exports = exports = new Popup({
  popup:{
    // misc:function(update) {
    //  var val = this.val
    //  //dit is gedeeld -- zou ook vanuit app kunnen eventueel
    // },
    defer:function(update,args) {

      this.clearCache()
      
      var val = this.val
      var element
      var switcher = this._caller && this._caller.switcher
      var params = {}
      var topbarParams

      if(!switcher) {
        return true
      }

      if(val === false) {
        // console.error('wtf is happenin????')
        this._caller.y = app.h.val
      } else if(this.from._contentType === 'actors') { //listen to misc different!
        //word if this._contentType === 'actor' // doe dit -- popup.val word op gelistend in app
        element = Actor = Actor || require('./actor')
        params = { 
          // carousel:{
          //   container:{
          //     $focus: this.from.get('focus',2)
          //   },
          //   dots:{
          //     container:{
          //       $focus: this.from.get('focus',2)
          //     }
          //   }
          // },
          data: this.from
        }
      } else if(val === 'volume') { //listen to misc different!
        element = Volume = Volume || require('./volume')
      } else if(val === 'devices') { //listen to misc different!
        // topbar.middle.text.val = app.deviceMessage
        element = Devices = Devices || require('./devices')

        var user = app.user

        params = {
          on: {
            devices: user.devices,
            receiver: user.receiverClient
          }
        }
      } else if(val === 'remote') { //listen to misc different!
        element = Remote = Remote || require('./remote')
        topbarParams = {
          // left:{
          //   icon:'navDown'
          // },
          middle:{
            text:{data:'title'},
            data:app.user.receiver.media
          }
          // right:{
          //   display:'none'
          // }
        }
      } 

      if(element) {
        switcher.transition = {
          element: element,
          $params: params
        }
      }

      if(topbarParams){
        switcher.parent.topbar.set(topbarParams)
      }

      update()
    }
  }
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../shared/popup":"/Users/shawn/Work/directv-fl/src/components/shared/popup/index.js","./actor":"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/index.js","./devices":"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/index.js","./remote":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/style.less","./volume":"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

//maybe add scroll, only when list is too large
module.exports = new Element({
// x:{translate:true}
// , scrollbar:'y'
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/carousel.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('../../../shared/icon')
var List = require('../../../shared/list')
var offset = require('vigour-js/browser/events/offset')

var thumb = new List.Item.Info({
	css:'carousel-item',
	scale:{
		parent:'x',
		transform:function(){
			var rect = this.node.getBoundingClientRect()
			var left = rect.left
			var right = rect.right
			var middle = app.w.val/2
			var width = rect.width
			var val = Math.max(1 - Math.abs((left + width/2) - middle)/1000,0.8)
			this.css = left <= middle && right >= middle
				?	'carousel-item front'
				: 'carousel-item'
			return val
		}
	},
  'events.click':function() {
  	app.popup.$userOrigin = false
    app.user.navigation.content.$userOrigin = this.data.from
  }
})

module.exports = exports = new Element({
	w:app.w,
	h:240,
	extend: {
		media: function(val) {
			//look for focus
			//doe dat pas on is loaded
			// if(val.from._contentType==='channels') {

			var _this = this
			var slider = this.slider
			var children = slider.children

			for(var i in children) {
				var child = children[i]
				if(child.data === val.from && this.focused !== child) {
					if(!slider._check && children.length > 1){
						slider.x._p = true
						slider.$focus = i
						slider.x._p = null
						slider._check = true
					}else{
						slider.$focus = i
					}
					if(!this.listenFocus) {
						this.listenFocus = true
						slider.$focus.on(function() {
							var focus = slider.children[this.val].data
							if(val.from!==focus && focus) {
								//nu moet er een once listener op time
								app.user.receiver.media.$userOrigin = focus
								app.user.navigation.content.$userOrigin = focus
								focus.get('time').is('loaded', function() {
									if(app.user.receiver.media.from===focus) {
										this.val = Math.abs(this.val)
									}
								})
							}
						})
					}
				}
			}
			// }
		}
	},
	slider: new List.Carousel({
		x:{val:280-30+2},
		collection: {
			data:true,
			filter:true,
			element:thumb
		},
		model:{
			complete:function(){
				if(this.children[1] && this.parent.media){ // force an update when children are ready
					this.x._p = true
					this.parent.media.update()
					this.model = false
					this.x._p = null
				}
			}
		}
	})
}).Class


},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../../shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/offset":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/index.js":[function(require,module,exports){
require('./style.less')

var Page = require( '../page.js' )
var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Seekbar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar')

var Carousel = require('./carousel')

var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')

var Guide = new Element({
	'header.text': 'Up Next',
	items: {
		collection: {
			data:'guide',
			element: new Element({
				css:'body',
				title: { text: { data:'title' } },
				subtitle: {
					text: {
						data:'start-time',
						add:[
							' - ',
							{ data:'end-time' }
						]
					}
				}
			})
		}
	}
}).Class

module.exports = exports = new Page({
	css:'remote',
	// text:{val:'remoteit!'},
	carousel: new Carousel(),
	info: {

	},
	controls: {
		title: { text:{ data:'guide.0.title', default:{data:'title'} }},
		seekbar: new Seekbar(),
		buttons: {
			left: new Icon({
				icon:'rewind'
			}),
			play: new Icon({
				extend: {
					playing: function(val) {
						this.icon = val.val === true ? 'pause' : 'play'
					}
				},
				icon:'play',
				'events.click':function() {
					this.playing.$userOrigin = !this.playing.val
				}
			}),
			right: new Icon({
				icon:'fastforward'
			}),
			volume: new Icon({
				icon:'volume',
				'events.click': function() {
					app.secondPopup.val = 'volume'
				}
			})
		}
	},
	extend: {
		receiverMedia: function(val) {
			var info = this.info
			var from = val.from
			this.controls.data = val.from
			
			//bug fix
			var seek = this.controls.seekbar.seek
			seek.w.update(seek)

			if(from._contentType==='channels') {
				if(info.guide&&info.guide.data !== from) {
					info.empty()
				}
				if(!info.guide) {
					info.empty()
					info.set({
						guide: new Guide({data:from})
					})
					this.carousel.data = app.content.get('channels')
				}
				this.carousel.media = from

			} else if( from._contentType !== 'receiver') {
				if(info.description && info.description.data !== from) {
					info.empty()
				}
				if(!info.description) {
					info.empty()
					info.set({
						description: new Description({data:from})
					})
					if(from._contentType==='movies') {
						this.carousel.data = app.content.get('movies')
						//focus gaat weird!
					} else if(from._contentType === 'series') {
						//content type word episode ---
						//harder to do
						this.carousel.data = app.content.get('series')
					}

				}
				this.carousel.media = from
			}
		}
	},
	on: {
		$parent:{defer:function(update) {
			this._parent._caller.parent.parent.topbar.middle.text = 'remote'
			update()
		}},
		$new:{defer:function(update) {
			this._parent._caller.receiverMedia = app.user.receiver.media
			this._parent._caller.controls.buttons.play.playing = app.user.receiver.playing
			update()
		}}
	}
}).Class



},{"../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./carousel":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/carousel.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/style.less","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Page = require( '../page.js' )
var Icon = require('../../../shared/icon')
var offset = require('vigour-js/browser/events/offset')

require('./style.less')

module.exports = exports = new Page({
	w:app.w,
	css:'volume',
	top: {
		title: { text: '100%' },
		volume: new Icon({
			icon:'volume', 
			'events.click': function() {
				this.parent.parent.volume.$userOrigin = 1
			}
		})
	},
	extend: {
		volume:function(val) {
			if(!this._volset && val.from!==val) {
				this._volset = true
				this.slider.block.y = val
				this.slider.block.middle.text = val
			}
		}
	},
	on: {
		$new:{ 
			defer:function(update) {
				var caller = this._parent._caller
				if(!caller.volume) {
					caller.volume = app.user.receiver.volume
				}
				update()
			} 
		},
		$parent:{
			defer:function(update) {
				this._parent._caller.parent.parent.topbar.middle.text.val = 'volume'
				update()
			}
		}
	},
	slider: {
		w: app.w,
		h:{val:app.h,sub:350},
		x:{max:0,min:0},
		block: {
			y:{ 
				transform: function(v,cv) {
					cv = cv>-1 ? cv : 1
					return (this.parent && (this.parent.h.val-30)-60)*( 1-cv )+30
				}
			},
			events: {
				drag:function(e) {

					if( !this._offset ) {
						this._offset = offset.y(this.parent)
					}
					//dragstart
					if(!this._draginfos) {
						this._draginfos = e.y-offset.y(this)+this._offset
					}
				
					var calc = 1 - ( e.y - this._draginfos ) / (this.parent.h.val-30)
					if(calc>1) calc = 1
					if(calc<0) calc = 0
					this.parent.parent.volume.$userOrigin = calc
				},
				up:function() {
					this._draginfos = false
				}
			},
			left: new Icon({
				icon: 'menu'
			}),
			middle: {
				text: { 
					transform: function(c, cv) {
						return Math.round(cv*100)+'%'
					}
				}
			},
			right: new Icon({
				icon: 'menuRight'
			}),
			// w:{val:app.w,sub:30},
			h:60
		}
	},
	mute: {
		muted: new Icon({icon:'muted'}),
		'events.click':function() {
			this.parent.volume.$userOrigin = 0
		}
	}
}).Class



},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/offset":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/remote/index.js":[function(require,module,exports){
require('./style.less')

var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('../../shared/icon')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')

module.exports = exports = new Element({
	css:'mini-remote',
	y:{val:0,animation:{ time:10, easing:'outCubic'}},
	extend: {
		playing: function(val) {
			this.right.icon = val.val === true ? 'pause' : 'play'
		},
		media: function(val) {
			var type = val.from._contentType
			if( type === 'movies' || type === 'channels' || type === 'series' || type === 'episodes' ) {
				var _this = this
				// setTimeout(function() {
				// 	_this.parent.switcher.h = { add:-50 }
				// },500)

				this.y = 0
				if(this.data!==val.from) {
					this.data = val.from
				}
			} else {
				// this.parent.switcher.h = { add:0 }
				this.y = 50
			}
		}
	},
	left: {
		background: {
			val:config.pointers.img,
			add: { data: 'img.thumb' }
		}
	},
	middle: {
		title: {
			text:{data:'title'}
		},
		info:new Subtitle()
	},
	right: new Icon({
		icon:'play',
		'events.click':function(e) {
			e.prevent = true
			this.parent.playing.$userOrigin = !this.parent.playing.val
		}
		//hier ff die listening
	}),
	'events.click': function(e) {
		app.popup.$userOrigin = 'remote'
	}
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/remote/style.less","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/remote/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/search/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
// var Input = require('./input')
var postpone = require('vigour-js/browser/events/util').postpone
var timestamp = require('monotonic-timestamp')
var config = require('vigour-js/util/config')
var Topbar = require('../topbar')
var search = require('/Users/shawn/Work/directv-fl/src/components/shared/search')

//TODO: use data bound to display instead of the big if statement

module.exports = exports = new Element({
  css:'first-search',
  extend: {
    search: function(){}
  },
  define: {
    addRecentSearch: postpone(function(srch) {
      if(!this.node) return
      if(!this.page || !this.page.recent.data) return
      var keys = this.page.recent.holder.data.keys
      var recents = this.page.recent.holder.data.$userOrigin
      if(keys.length>5) {
        recents[keys[0]].remove()
      }
      var found
      if(recents) {
        recents.each(function() {
          if(this.title.val === srch) {
            found = true
            return true
          }
        })
      }
      if(!found) {
        recents.set(timestamp(),{title:srch})
      }
    },1000)
  },
  // topbar: {
  //   left: new Icon({
  //     icon:'menu',
  //     events: {
  //       down:function(e) {
  //         e.prevent = true
  //         app.menu.val = !app.menu.val
  //       }
  //     }
  //   }),
  //   field: new Input({
  //     events: {
  //       focusout: function(e) {
  //         var overlay = this.parent.parent.overlay
  //         overlay.display = 'none'
  //       },
  //       focus:function(e) {
  //         this.parent.parent.overlay.set({
  //           display:'block'
  //         })
  //       }
  //     }
  //   })
  // },
  page:new search.ResultList({
    scrollbar:'y',
    append:{
      val:[
        new Element({
          name:'noResults',
          display:'none',
          icon: new Icon({icon:'wrong'}),
          'title.text':'No results!',
          'body.text':'Please try to refine your query'
        }),
        new search.TopResult({
          name:'topresult'
        }),
        new Element({
          name:'recent',
          model: {
            inherit:false,
            complete:function() {
              if(this.data.keys.length) {
                this.noRecent.display = 'none'
                this.holder.display = 'block'
              } else {
                this.noRecent.display = 'block'
                this.holder.display = 'none'
              }
            }
          },
          noRecent:{
            icon: new Icon({icon:'searchMenu'}),
            title: {
              text:'Start Searching!'
            },
            body: {
              text:'Find your favorite movies, shows and channels.'
            }
          },
          holder: new search.Results({
            title: {
              text:'recent searches'
            },
            collection: {
              data:true,
              element: new search.Result({
                'events.click':function(e) {
                  this.checkParent('search',true).$userOrigin = this.data.title.val
                }
              }),
              filter: {
                sort:{ field:'_name', order:'z-a'}
              }
            }
          })
        })
      ],
      before:'movies'
    }
  }),
  overlay: {
    display:'none'
  },
  search:{
    defer:function(update, args) {

      if(!this.from.cloud) return true

      var caller = this._caller
      var elem$

      var list = [
          caller.page.movies,
          caller.page.series,
          caller.page.channels,
          caller.page.actors
        ]

      // if(!caller.topbar.field.data) {
      //   caller.topbar.field.data = this._val
      // }
      
      this.clearCache()

      if(this.val) {
        var srch = search.parseSearch( this.val )
        if( srch!==false ) {
          caller.addRecentSearch(srch)
          for(var i in list) {
            search.filterCollection( list[i], srch )
          }

          caller.page.recent.display = 'none'

          caller.data.get('movies').is(function() {
            return this.keys && this.keys.length>2 
                && this.from[0] && this.from[0].actors
          }, true).then(function() {
            if(caller._node) {
              for(elem$ in list) {
                list[elem$].display = list[elem$].filter.length > 0 
                  ? 'block' 
                  : 'none'  
              }
              
              var result = search.topResult( list ) 
              caller.page.topresult.data = result || false
              caller.page.topresult.display = result ? 'block' : 'none'
              caller.page.noResults.display = result ? 'none' : 'block'
              //if no result then ----
            }
          })
        } else {
          for(elem$ in list) {
            list[elem$].display = 'none'
          }
          caller.page.topresult.display = 'none'
          caller.page.noResults.display = 'none' 
          caller.page.recent.display = 'block'  
        }
          
      } else {
        for(elem$ in list) {
          list[elem$].display = 'none'
        }
        caller.page.topresult.display = 'none'
        caller.page.noResults.display = 'none' 
        caller.page.recent.display = 'block'
      }
      update()
    }
  }
}).Class

},{"../topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/search/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/search":"/Users/shawn/Work/directv-fl/src/components/shared/search.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/search/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Icon = require('../../shared/icon')
var Menu = require('../menu')
var Discover
var Search
var Channel
var Episode
var Movie
var cases = app.cases

module.exports = exports = new Switcher({
  css: 'first-switcher',
  'extend.navigation': function() {},
  onTransition: 'slide',
  loader: new Element({
    css: 'first-loader',
    x: {
      translate: true
    },
    loadicon: new Icon({
      icon: 'error'
    })
  }),
  navigation: {
    defer: function(update, args) {
      var nav = this.from

      if (!nav || !nav.last || !nav.last.from.key) return true

      var field = nav.last.from.key.val
      var page
      var element
      var switcher = this._caller
      var params
      var options
      nav = nav[field]

      if (field === 'page') {

        var page = nav.val

        if (page === 'discover') {
          element = Discover = Discover || require('../discover')
          params = {
            $focus: app.user.focus_row,
            data: app.content.get('discover')
          }
        } else if (page === 'search') {
          element = Search = Search || require('../search')
          params = {
            data: app.cloud.data,
            search: app.user.search,
            page: {
              recent: {
                data: app.user.recentSearches.from
              }
            }
          }
        }

      } else if (field === 'content') {
        if (!switcher._swElem || switcher._swElem.data !== nav.from) {

          var type = nav._contentType

          if (type === 'movies') {
            element = Movie = Movie || require('../movie')
          } else if (type === 'episodes') {
            element = Episode = Episode || require('../episode')
          } else if (type === 'channels') {
            element = Channel = Channel || require('../channel')
          }

          options = {
            force: true
          }
          params = {
            data: nav.from,
            holder: {
              player: {
                playing: app.isPlaying,
                receiver: app.user.receiver
              },
              receiverMedia: app.user.receiver.media
            }
          }
        }

      }

      if (element) {
        switcher.transition = {
          element: element,
          $params: params,
          direction: app.menu.val ? 0 : field === 'content' ? 1 : -1,
          $options: options
        }

      }

      update()
    }
  }
}).Class

},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../channel":"/Users/shawn/Work/directv-fl/src/components/active/channel/index.js","../discover":"/Users/shawn/Work/directv-fl/src/components/active/discover/index.js","../episode":"/Users/shawn/Work/directv-fl/src/components/active/episode/index.js","../menu":"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js","../movie":"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js","../search":"/Users/shawn/Work/directv-fl/src/components/active/search/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/switcher/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js":[function(require,module,exports){
require('./style.less')
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var user = app.user
var Icon = require('../../shared/icon')
var Title = require('../../shared/title')
var Input = require('./input')

var searchField = new Input({
  events: {
    focusout: function(e) {
      // var overlay = this.parent.parent.overlay
      // overlay.display = 'none'
    },
    focus:function(e) {
      // this.parent.parent.overlay.set({
      //   display:'block'
      // })
    }
  }
}).Class

module.exports = exports = new Element({
	css:'topbar',
	extend:{
		$current:function(val){
			var current = val.val
			if(current === 'search'){
				if(!this.search){
					this.set({
						css:'topbar searching',
						add:[
							new searchField({
								name: 'search',
								data:app.user.search
							}),
							'middle'
						]
					})
				}
			}else if(this.search){
				this.search.remove()
				this.css = 'topbar'
			}

			if( current === 'content' ){
				this.middle.data = user.navigation.content.from
			}else if( current === 'discover' ){
				this.middle.data = { title:current }
			}

		}
	},
	left: new Icon({ 
		icon:{
			val:app.current,
			transform:function(v,current){
				return current === 'content' ? 'back' : 'menu'
			}
		},
		events: {
			down:function(e) {
				e.prevent = true
				if( this.icon.val === 'menu' ){
					app.menu.val = !app.menu.val
				}else{
					user.navigation.page.$userOrigin = app.previous.val || 'discover'
				}
			}
		} 
	}),
	middle:new Title.Show(),
	right: new Icon({
		icon:'cast',
		'events.click':function() {
			app.popup.$userOrigin = 'devices'
		}
	})
})

module.exports = exports.Class


},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","./input":"/Users/shawn/Work/directv-fl/src/components/active/topbar/input.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/topbar/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/input.js":[function(require,module,exports){
require('./reset.less')

var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var events = require('vigour-js/browser/events')
var cases = require('vigour-js/browser/cases')
var app = require('vigour-js/app/')

module.exports = new Element({
  node: 'form',
  name: 'search',
  css: 'search-field',
  model: {
    inherit: false,
    complete: function() {
      this.table.clear.display = this.data.val ? 'table-cell' : 'none'
    }
  },
  table: {
    lefticon: new Icon({
      icon: 'search'
    }),
    inputField: {
      node: 'input',
      attr: {
        type: 'text',
        name: 'search',
        placeholder: 'Search'
      },
      text: {
        data: true
      },
      events: {
        keydown: function(e) {
          if (e.keyCode == 13) e.preventDefault()
        },
        keyup: function(e) {
          if (e.keyCode !== 9) {
            var srch = this.node.value.length ? this.node.value.trim() : ''
            this.data.$userOrigin = srch
          }
        }
      }
    },
    clear: new Icon({
      icon: 'closeSmall',
      display: 'none',
      events: {
        down: function(e) {
          e.prevent = true
          this.parent.fromDown = true
            //TODO: figure out why this.parent does not have data bound to it!
          this.parent.inputField.data.$userOrigin = ''
            // focusout.call(this.parent.parent,e)
        }
      }
    })
  },
  events: {
    focusin: focus
  }
}).Class

function focus(e) {
  console.log('wtf wtf wtf', this.parent)
  if (this.events.focus) {
    this.events.focus._val.call(this, e)
  }
}

function focusout(e) {
  if (this.events.focusout) {
    this.events.focusout._val.call(this, e)
  }
}

},{"./reset.less":"/Users/shawn/Work/directv-fl/src/components/active/topbar/reset.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/reset.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/bio/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

module.exports = new Element({
  css:'second-bio',
  'extend.$focus':function(val){
    var index = val.val
    if(index !== this._index){
      var data = this.data
      if(data){
        this.switcher.transition = {
          element:Img,
          $params:{
            opacity:0,
            background:data.from.get(['img','cover',index || 0],'')
          },
          $options:{
            force:true
          }
        }
        this._index = index
      }
    }
  },
  $focus:{
    data:'focus'
  },
  switcher:new Switcher({
    onTransition:'fade',
    // add:new Img({
    //   'background.data':'img.cover.0'
    // }),
  }),//will switch between images
  overlay:{
    'header.text.data':'title',
    bio:{
      'header.text':'Bio',
      'body.text.data':'bio'
    }
  },
  model:{
    subscription:{
      img:{
        cover:{
          $:true
        }
      }
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/bio/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/bio/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/channel/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var Widget = require('/Users/shawn/Work/directv-fl//src/components/inactive/widget')
var Content = require('../content')
var Trailer = require('../trailer')

module.exports = exports = new Content({
  css: 'second-channel',
  container: {
    left: {
      trailer: new Trailer({
        'video.src.data':'video'
      })
    },
    middle:{
      guide: new Widget.Guide()
    },
    right: new Switcher({
      onTransition: function(current, last) {
        if(last) last.remove()
        this.add(current)
      },
      model:{
        subscription:{
          guide:{
            0:{
              statistics:{
                title:true
              }
            }
          }
        },
        val:function(data){
          var widgetData = data.guide && data.guide[0]
          if(widgetData){
            this.transition = {
              element: widgetData.statistics ? Widget.Stats : Widget.About,
              $params:{ data:data }
            }
          }
        }
      }
    })
  },
  'extend.$complete':function(val){
    var complete = val.val
    if(complete === true){
      this.container.set({
        left:{
          twitter: new Widget.Twitter({
            data:this.data
          })
        }
      })
    }else if(complete === false){
      // this.container.set({
      //   left:{
      //     twitter: false
      //   }
      // })
    }
  }
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","../trailer":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/channel/style.less","/Users/shawn/Work/directv-fl//src/components/inactive/widget":"/Users/shawn/Work/directv-fl/src/components/inactive/widget/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/channel/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js":[function(require,module,exports){
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Cover = require('../cover')
var Channel
var Vod

module.exports = exports = new Element({
  cover: new Cover(),
  'extend.$active': function(val) {
    var active = val.val
    if (active !== void 0) {
      var bg = this.cover.bg
      var info = this.info
      if (active) {
        if (bg._loaded) bg.opacity = false
        bg.$wait = false
      } else {
        bg.$wait = true
        bg.opacity = 0
      }
    }
  },
  $active: true
}).Class

exports.select = function(data, type) {
  if (!type) type = data._contentType

  return type === 'channels' ? {
    element: Channel = Channel || require('../channel'),
    $params: {}
  } : {
    element: Vod = Vod || require('../vod'),
    $params: {
      $popup: app.popup
    }
  }
}

},{"../channel":"/Users/shawn/Work/directv-fl/src/components/inactive/channel/index.js","../cover":"/Users/shawn/Work/directv-fl/src/components/inactive/cover/index.js","../vod":"/Users/shawn/Work/directv-fl/src/components/inactive/vod/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/cover/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

module.exports = new Element({
  css:'second-cover',
  bg:new Img({
    opacity:0,
    $wait:true,
    background:{
      data:'img.cover.0',
      add:{
        data:'show.img.cover.0'
      }
    }
  }),
  overlay:{}
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/cover/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/cover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/discover/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var app = require('vigour-js/app')
var postpone = require('vigour-js/browser/events/util').postpone
var Content = require('../content')

var _preview = postpone(function(switcher,focusIndex) { //move this to app control stuff
  if(focusIndex !== void 0){
    var clouddata = app.cloud.data
    var focusrow = app.user.focus_row.val
    var data = clouddata.get(['discover',focusrow,'items',focusIndex])
    app.preview.val = data
    if(switcher._swElem) switcher._swElem.$active.val = true
  }
},400)

module.exports = new Switcher({
  css: 'second-discover',
  extend:{
    $highlight:function(val){
      var index = val.val
      var last = this.last
      if(index !== false){
        if(!this.fromContent){
          if(this._swElem) this._swElem.$active = false
          _preview(this,index)
          this.last = void 0
        }else{
          this.fromContent = false
        }
      }
    },
    $preview:function(val){
      val = val.val
      if(val){
        var data = val.from
        var transition = Content.select(data)
        transition.$params.data = data
        transition.$params.$complete = false
        this.transition = transition
      }
    },
    $content:function(val){
      val = val.val
      if(val){
        var data = val.from
        var transition = Content.select(data)
        transition.$params.data = data
        transition.$params.$complete = true
        this.transition = transition
        this.fromContent = true
        app.preview.val = data
      }
    }
  },
  onTransition:'fade'
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/discover/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/discover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
  , Element = require('vigour-js/app/ui/element')
  , Discover = require('./discover')
  , Search = require('./search')
  , Statusbar = require('./statusbar')
  , app = require('/Users/shawn/Work/directv-fl//src/app')
  , Navigation = require('./navigation')
  , Player = require('./player')
  , Content = require('./content')

//secondscreen toplevel
module.exports = exports = new Element({
  css:'second-state',
  y:{translate:true,val:0},
  switcher:new Switcher({ // switches between main and search
    onTransition:'fade'
  }),
  navigation:new Navigation(),
  statusbar:new Statusbar(),
  search:new Search(),
  extend:{
    $highlight:function( val ){},
    $preview:function( val ){},
    $page:function( val, stamp ){


      if(this.$media.val || !stamp) return
      var page = val.val

      app.user.trailerMuted.$userOrigin = true
      app.hideStatusbar.val = false
      
      if( page === 'discover' ){
        this.set({
          y:0,
          switcher:{
            transition:{
              element:Discover,
              $params:{
                $preview:this.$preview._val,
                $highlight:this.$highlight._val,
                $content:false
              }
            }
          },
          navigation:{
            container:{
              y:0
            }
          }
        })
      }else if(page === 'search'){
        this.set({
          y: -app.h.val + 80,
          search:{
            $search:app.user.search,
            $muted:app.user.trailerMuted,
            data:app.cloud.data
          }
        })
      }

    },
    $content:function( val,stamp ){

      // if(this.$media.val || !stamp) return
      // var data = val.from
      if(this.$media.val || !stamp) return

      app.hideStatusbar.val = false

      this.set({
        y:0,
        switcher:{
          transition: {
            element:Discover,
            $params:{
              $preview:false,
              $highlight:false,
              $content:val
            }
          }
        },
        navigation:{
          container:{
            y:420
          }
        }
      })
    },
    $media:function( val, stamp ){
      if(val.val){
        this.set({
          y:0,
          switcher:{
            transition:{
              element:Player,
              $params:{
                overlay:{
                  $volume:app.volume,
                  $time:val.val.get('time')
                },
                playing:app.isPlaying,
                data:val.$userOrigin,
                video: {
                  volume: app.volume
                }
              }
            }
          },
          navigation:{
            container:{
              y:460 + 80
            }
          }
        })
      }else{
        app.user.updateNavigation()
      }
    }
  },
  setSetting:{
    name:'updateNav',
    parent:function(){
      app.user.updateNavigation()
    }
  }
}).Class
},{"./content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./discover":"/Users/shawn/Work/directv-fl/src/components/inactive/discover/index.js","./navigation":"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/index.js","./player":"/Users/shawn/Work/directv-fl/src/components/inactive/player/index.js","./search":"/Users/shawn/Work/directv-fl/src/components/inactive/search/index.js","./statusbar":"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/index.js":[function(require,module,exports){
require('./style.less')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Element = require('vigour-js/app/ui/element')
var List = require('/Users/shawn/Work/directv-fl//src/components/shared/list')
var postpone = require('vigour-js/browser/events/util').postpone
var Switcher = require('vigour-js/app/ui/switcher')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')
var Progress = require('/Users/shawn/Work/directv-fl//src/components/inactive/progress')

var yElement = new Element({
  y: {
    translate: true,
    val:420
  }
}).Class

var titleElement = new yElement({
  'text.data': 'title'
}).Class

var map = {
  spotlight: {
    index: 0,
    list: List.Watching
  },
  channels: {
    index: 1,
    list: List.Channel
  },
  watching: {
    index: 2,
    list: List.Watching
  },
  releases: {
    index: 3,
    list: List.Poster
  },
  recommended: {
    index: 4,
    list: List.Poster
  }
}

var switchFocus = function(_this, index, focused, type) {
  var direction = index > _this.index ? -1 : 1
    //switch the title

  _this.container.set({
    bar: {
      title: {
        transition: {
          element: titleElement,
          direction: direction,
          $params: {
            data: focused
          },
          $options: {
            force: true
          }
        }
      },
      arrows: {
        up: {
          opacity:index === 0 ? 0.5 : 1
        },
        down: {
          opacity:index === 4 ? 0.5 : 1
        }
      }
    }
  })

  _this.index = index

  listFocus(_this, index, focused, type, direction)
}

var listFocus = postpone(function(_this, index, focused, type, direction) {
  var lists = _this.container.lists
  var focusItem = app.user['focus_' + type]

  if(lists){
    lists.transition = {
      element: map[type].list,
      direction: direction,
      $params: {
        data: focused,
        $focus: app.highlight.val = focusItem
      },
      $options: {
        force: true
      }
    }
  }
}, 200)

module.exports = new Element({
  css: 'second-navigation',
  container: new yElement({
    progress: new Progress({
      percentage:{
        text:{
          val:{
            parent:'on',
            animation:{
              easing:'outCubic',
              time:18
            }
          },
          transform:function(v,cv){
            return ~~cv + '%'
          }
        }
      },
      model:{
        complete:function(data){
          this.on.update(this)
        },
        inherit:false
      },
      on:{
        data:'time',
        defer:function(update){
          if(~~this.from.val){
            this._caller.opacity = 1
            update()
          }else{
            this._caller.opacity = 0
            return true
          }
        },
        multiply:100
      }
    }),
    bar: {
      title: new Switcher({
        onTransition: function(current, last, direction) {
          _transition(this, 40, current, last, direction)
        }
      }),
      arrows: {
        up:new Icon({
          icon:'upNav',
          opacity:0.1
        }),
        down: new Icon({
          icon:'downNav'
        })
      }
    },
    lists: new Switcher({
      onTransition: function(current, last, direction) {
        _transition(this, 400, current, last, direction)
      }
    })
  }),
  'model.subscription.$.$': true,
  extend:{
    $focus: function(val) { //val === 'spotlight'/'recommended' etc
      var _this = this
      var data = this.data
      if(!data) return
      
      if(!data.$length.val) {
        data.$length.once(function() {
          _this.$focus.update()
        })
        return
      }

      var focused = data[val.val]
      if(focused) {
        switchFocus(_this, map[val.val].index, focused, val.val)
      }
    }
  },
  setSetting: {
    name: 'prepValues',
    parent: function() {
      for(var type in map) {
        var field = 'focus_' + type
        if(!app.user[field]) {
          var obj = {}
          obj[field] = 0
          app.user.set(obj)
        }
      }
    }
  }
}).Class

function _transition(_this, delta, current, last, direction) {
  if(last) {
    last.y = delta * direction // should still remove
    current.y = delta * -direction
  }
  _this.add(current)
  if(_this._timer) {
    clearTimeout(_this._timer)
    _this._timer = null
  }
  _this._timer = setTimeout(function() {
    _this._timer = null
    doit()
  }, 50)

  function doit(){
    if(!current._blocked) current.y = 0
    else window.requestAnimationFrame(doit)
  }
}

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl//src/components/inactive/progress":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl//src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/player/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Video = require('vigour-js/browser/element/video')
var Progress = require('/Users/shawn/Work/directv-fl//src/components/inactive/progress')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var postpone = require('vigour-js/browser/events/util').postpone
var config = require('vigour-js/util/config')

var fadeIcon = postpone(function(_this, force){
  var icon = _this._swElem && _this._swElem.icon
  if(icon){
    icon.css = 'ui-icon fade-out'
    icon.opacity = 0
  }
},1000)

var fadeOverlay = postpone(function(_this, force){
  if(app.isPlaying.val) _this.opacity = 0
  else updatePlay(_this)
},1000)

var updatePlay = postpone(function(_this){
  app.hideStatusbar.val = false
  if(_this.$playing) _this.$playing.update()
},1000)

var Overlay = new Element({
  css:'player-overlay',
  opacity:0,
  info:{
    poster:new Img({'background.data':'img.poster'}),
    titles:{
      'nowplaying.text':'Now Playing',
      'title.text.data':'title',
      'subtitle.text.data':'subtitle'
    }
  },
  icon:new Icon({
    opacity:0,
    icon:{
      val:'play',
      $isPlaying:'pause'
    }
  }),
  next:{}
}).Class

var BarOverlay = new Element({
  opacity:0,
  container:{
    txt:{},
    progress:new Progress()
  },
  'extend.$value':function(val){
    this.container.set({ //change this for data
      txt:{
        value:{
          text:val.val
        }
      },
      progress:{
        on:val.val    
      }
    })
  }
}).Class

var SeekOverlay = new BarOverlay({
  css:'seek-overlay',
  'container.txt':{
    text:'SEEKING ',
    'value.text':{
      data:'time',
      multiply:4500,//{data:'duration'},
      $convertTime:true,//{data:'duration'},
    }
  }
}).Class

var VolumeOverlay = new BarOverlay({
  css:'volume-overlay',
  'container.txt':{
    text:'VOLUME ',
    'value.text':{
      val:0,
      transform:function(v,cv){
        return Math.round( cv * 100 || 0 ) + '%'
      }
    }
  }
}).Class

var OverlaySwitcher = new Switcher({
  extend:{
    $playing:function(val){
      this.opacity = 1
      this.transition = {
        element:Overlay,
        $params:{
          data:this.parent.data,
          icon:{
            css:'ui-icon fade-in',
            opacity:1,
            clear:true
          }
        }
      }
      if( app.isPlaying.val ) fadeOverlay( this )
      fadeIcon( this )
    },
    $time:function(val){
      if(arguments[2]===void 0 || val.val < 0 || app.user.receiver.media._contentType === 'channels') return
      this.opacity = 1
      this.transition = {
        element:SeekOverlay,
        $params:{
          $value:val.val
        }
      }
      app.hideStatusbar.val = true

      if( app.isPlaying.val ) {
        fadeOverlay( this )
      }else {
        updatePlay(this)
      }

    },
    $volume:function(val){
      if(arguments[2]===void 0) return
      this.opacity = 1
      this.transition = {
        element:VolumeOverlay,
        $params:{
          $value:val.val
        }
      }
      app.hideStatusbar.val = true
      if( app.isPlaying.val ) fadeOverlay( this )
      else updatePlay(this)
    }
  },
  onTransition:function(current,last){
    if(last){
      last.set({
        opacity:0,
        $timeout:{
          200:function(){
            last.remove()
          }
        }
      })
    }
    current.$timeout = {
      50:function(){
        this.opacity = 1
      }
    }
    this.add(current)
  }
}).Class

module.exports = new Element({
  css:'second-player',
  video:new Video({
    player: require('vigour-js/browser/element/video/html5'),
    duration:{data:'duration'},
    time: {data:'time'},
    src: { prepend:config.pointers.assets, data:'video'},
    events:{
      progress: function(p) {
        this.data.from.set('time', -Math.abs(p))
      }
    }
  }),
  overlay:new OverlaySwitcher(),
  extend:{
    playing: function(val) {
      this.overlay.$playing = val
      this.video.$playing = val
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/player/style.less","/Users/shawn/Work/directv-fl//src/components/inactive/progress":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/player/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
	css:'second-progress',
  on:{
    data:'time',
  	abs:true,
    multiply:100
  },
  display:{
    val:app.preview,
    transform:function(v,cv){
      var popup = app.popup.val
      return (cv && cv._contentType === 'channels') || (popup && typeof popup !== 'string') ? 'none' : 'block'
    },
    listen:app.popup
  },
  w:{
    self:'on',
    transform:function(v,cv){
      return Math.max(~~cv,3) + '%'
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/progress/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/search/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')
var Trailer = require('../trailer')
var search = require('/Users/shawn/Work/directv-fl//src/components/shared/search')
var when = require('promise').all
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')

var NoResults = new Element({
  container:{
    'title.text':'No Results!',
    'subtitle.text':'Please try to refine your query'
  }
}).Class

var StartSearching = new Element({
  container:{
    'title.text':'Start Searching!',
    'subtitle.text':'Find your favorite movies, shows and channels'
  }
}).Class

module.exports = new Element({
  css: 'second-search',
  extend:{
    $search:function( val ){
  	  var _this = this
    	var results = this.results
    	var children = results.list.children
    	var query = search.parseSearch( val.val )
    	var content = app.content

    	this.searchbox.query.text = query

    	if(query !== false){
    		for (var i = children.length - 1; i >= 0; i--) {
    			search.filterCollection( children[i], query )
    		}
    	}

      if(query){
        function loaded(){
          var keys = this.keys
          var from = this.from
          return keys && keys.length > 2
        }

        function done(){
          for (var j = children.length - 1; j >= 0; j--) {
            var child = children[j]
            child.display = child.filter.length ? 'block' : 'none'
          }
          var topResult = search.topResult( children )
          if( topResult ){
            results.display = 'block'
            results.topresult.data = topResult
            if(_this.message){
              _this.message.remove()
            }
          }
          else{
            results.display = 'none'
            _this.set({
              message:new NoResults()
            })
          }
        }

        when([
          content.get('movies').is(loaded),
          content.get('actors').is(loaded),
          content.get('series').is(loaded),
          content.get('channels').is(loaded)
        ]).done(done)
      }else{
        results.display = 'none'
        this.set({
          message:new StartSearching()
        })
      }

    },
    $muted:function(val){
      this.results.topresult.body.container.trailer.$muted = val.val
    }
  },
  searchbox:{
  	searchicon:new Icon({
  		icon:'search'
  	}),
  	'query.text':''
  },
  results:{
  	list:new search.ResultList(),
  	topresult:{
  		model:{inherit:false},
  		header:{
  			text:{
  				// data:'title',
  				prepend:'Top Result'// - '
  			}
  		},
  		body:{
  			container:{
  				trailer:new Trailer(),
  				info:{
  					'title.text.data':'title',
            subtitle:new Subtitle()
  				}
  			},
  			'description.text.data':'description'
  		}
  	}
  }
}).Class

},{"../trailer":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/search/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl//src/components/shared/search":"/Users/shawn/Work/directv-fl/src/components/shared/search.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","promise":"/Users/shawn/Work/directv-fl/node_modules/promise/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/search/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')

module.exports = app.cases.$isTablet 
? new Element({
    css:'second-statusbar branded',
    y:{
      translate:true,
      val:80,
      multiply:app.hideStatusbar
    },
    partner:{
      logo:{}
    },
    weather:{
      add:new Icon({icon:'weather'}),
      text:'Partially Clouded'
    },
    eta:{
      add:new Icon({icon:'airplane'}),
      text:'Time to Los Angeles: 6hr'
    },
    between:{},
    directv:{
      logo:{}
    }
  }).Class
: new Element({
    css:'second-statusbar',
    y:{
    	translate:true,
      val:80,
      multiply:app.hideStatusbar
    },
    directv:{
      logo:{}
    },
    sender:{
      icon:new Icon({icon:'phone'}),
      title:{text:'controlled by iPhone'}
    }
  }).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Video = require('vigour-js/browser/element/video')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var ASSETS = require('vigour-js/util/config').pointers.assets
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Mute = require('/Users/shawn/Work/directv-fl/src/components/shared/mute')

module.exports = new Element({
  css: 'second-trailer',
  'extend.$muted':function(){},
  $muted:true,
  video:new Video({
    player: require('vigour-js/browser/element/video/html5'),
    src:{
      data: 'trailer',
      prepend: ASSETS
    },
    duration: true,
    volume:{
      parent:'$muted',
      multiply:-1,
      add:1
    },
    loop: true,
    autoplay: true
  }),
  logo:new Img({
    'background.data':'img.logo'
  }),
  muted:new Mute({
    icon:{
      parent:'$muted'
    }
  })
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mute":"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/vod/index.js":[function(require,module,exports){
require('./style.less')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Item = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Content = require('../content')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Bio = require('../bio')

var Overview = new Content({
  css:'overview',
  container:{
    top: {
      'left.poster':new Item.Poster({
        'img.background':{
          add:{
            data:'show.img.poster'
          }
        },
      }),
      right: {
        title:new Title(),
        subtitle:new Subtitle()
      }
    },
    'description.text.data': 'description',
    starring: {
      display:{
        val:'block',
        when:{data:'actors'},
        or:'none'
      },
      'header.text': 'Starring',
      'actors.collection': {
        data: 'actors',
        element: Item.Poster
      }
    }
  }
}).Class

var Preview = new Content({
  css:'preview',
  'cover.bg.background':{
    data: 'img.cover.1',
    add:{
      data:'show.img.cover.2'
    }
  },
  'container.info': {
    title:new Title.Show(),
    subtitle:new Subtitle(),
    'description.text.data': 'description'
  }
}).Class

module.exports = new Switcher({
  css: 'second-vod',
  onTransition:'fade',
  extend:{
    $active:function(val){
      if(this._swElem) this._swElem.$active = val.val
    },
    $complete: function(val) {
      var complete = val.val
      var data = this.data
      var isEpisode = data._contentType === 'episodes'

      var params = {
        data: data.from,
        $active:this.$active
      }

      if (complete === true) {
        this.transition = {
          // element: isEpisode ? EpisodeOverview : Overview,
          element: Overview,
          $params: params
        }
      } else if (complete === false) {
        this.transition = {
          // element: isEpisode ? EpisodePreview : Preview,
          element: Preview,
          $params: params
        }
      }
    },
    $popup:function(val){
      var data = val.val
      if(data && typeof data !== 'string'){
        this.transition = {
          element:Bio,
          $params:{
            data:data.from
          }
        }
      }else{
        if(this.$complete) this.$complete.update()
      }
    },
    data:function(val){
      if(this._swElem && !this._swElem.switcher){
        this._swElem.data = val.val
      }
    }
  },
  $active:true
}).Class

},{"../bio":"/Users/shawn/Work/directv-fl/src/components/inactive/bio/index.js","../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/vod/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/vod/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/widget/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')
var Video = require('vigour-js/browser/element/video')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Mpaa = require('/Users/shawn/Work/directv-fl/src/components/shared/mpaa')
var Rating = require('/Users/shawn/Work/directv-fl/src/components/shared/rating')
var Score = require('/Users/shawn/Work/directv-fl/src/components/shared/statistics').Score

exports.Twitter = new Element({
  css: 'twitter-widget',
  'header.text': 'Tweets',
  'tweets.collection': {
    data: 'guide.0.tweets',
    element: new Element({
      css: 'tweet',
      bird: new Icon({icon:'twitter'}),
      'author.text.data': 'author',
      'body.text.data': 'body'
    })
  }
}).Class

exports.Guide = new Element({
  css: 'guide-widget',
  'header.text': 'Guide',
  'programs.collection': {
    data: 'guide',
    element: new Element({
      css: 'program',
      'title.text.data': 'title',
      progress: {
        'start.text.data': 'start-time',
        'dash.text': ' - ',
        'bar.seek': {},
        'end.text.data': 'end-time'
      }
    })
  }
}).Class

var Poller = new Element({
  css: 'poller',
  'left.logo': new Img(),
  right: {
    'title.text.data': 'title',
    bar: {
      'extend.$borderTopColor': function(val) {
        if(val.val) this.node.style.borderTopColor = val.val
      },
      '$borderTopColor.data': 'color',
      w: {
        data: 'votes',
        divide: 10000,
        multiply: 100,
        add: '%'
      }
    },
    'subtitle.text': {
      data: 'votes',
      add: ' VOTES'
    }
  },
  setSetting: {
    name: 'bindvotes',
    parent: function(parent) {
      this.right.bar.w = {
        divide: parent.on
      }
    }
  }
}).Class

var Poll = new Element({
  on: { // store the totalvotes
    data: 'poll.0.votes',
    'add.data': 'poll.1.votes'
  },
  append: [
    Poller, {
      'model.field': 'poll.0'
    }, {
      'model.field': 'poll.1'
    }
  ]
}).Class

exports.Stats = new Element({
  css: 'stats-widget',
  'header.text': 'Statistics',
  container: {
    model:{field:'guide.0'},
    score: new Score(),
    info: {
      'title.text': 'Who will win?',
      'subtitle.text': 'Use phone to vote'
    },
    poll: new Poll()
  }
}).Class

exports.About = new Element({
  css: 'about-widget',
  'header.text': 'About the Show',
  container: {
    img:new Img({
      'background.data':'img.thumb'
    }),
    info:{
      'model.field':'guide.0',
      titles:{
        'title.text.data': 'title',
        'subtitle.text.data': 'subtitle'
      },
      stickers:{
        mpaa:new Mpaa(),
        rating: new Rating()
      }
    },
    'description.text.data':'guide.0.description'
  }
}).Class
},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mpaa":"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js","/Users/shawn/Work/directv-fl/src/components/shared/rating":"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js","/Users/shawn/Work/directv-fl/src/components/shared/statistics":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var app = require('vigour-js/app')

module.exports = new Element({
  css:'ui-actors',
  display:{
    data:'actors',
    transform:function(v,cv){
      return cv ? 'block' : 'none'
    }
  },
  header: { text: 'Starring' },
  body: {
    scrollbar: 'x',
    collection: {
      data: 'actors',
      element: new Poster({
        'events.click':function() {
          app.popup.$userOrigin = this.data.from
        }
      })
    }
  }
}).Class


},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/actors/style.less","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/actors/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

module.exports = exports = new Element({
  css:'ui-bar'
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/bar/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/bar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

var Description = new Element({
	css:'ui-description',
  header: { text: 'Description' },
  body: {
    text: { data: 'description' }
  }
}).Class

module.exports = Description

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/description/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/description/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
  , cases = require('vigour-js/browser/cases')
  , icon = new Element({ css:'ui-icon' })
  , map =
    { discover:'\ue600'
    , shows:'\ue601'
    , tv:'\ue602'
    , settings:'\ue603'
    , cast:'\ue604'
    , desktop:'\ue602'
    , play:'\ue605'
    , pause:'\ue606'
    , fullscreen:'\ue607'
    , exitfullscreenAlt:'\ue608'
    , pullback:'\ue609'
    , swipeup:'\ue60a'
    , allChannels:'\ue60b'
    , disconnected:'\ue60c'
    , menu:'\ue60d'
    , IFE:'\ue60e'
    , back:'\ue60f'
    , closeSmall:'\ue610'
    , close:'\ue611'
    , wrong:'\ue612'
    , correct:'\ue613'
    , facebook:'\ue614'
    , twitter:'\ue615'
    , phone:'\ue616'
    , tablet:'\ue617'
    , volume:'\ue618'
    , muted:'\ue619'
    , pauseAlt:'\ue61a'
    , playAlt:'\ue61b'
    , rewind:'\ue61c'
    , fastforward:'\ue61d'
    , profile:'\ue61e'
    , dropdown:'\ue61f'
    , rightNav:'\ue620'
    , leftNav:'\ue621'
    , right:'\ue622'
    , search:'\ue623'
    , noResult:'\ue624'
    , searchMenu:'\ue625'
    , epg:'\ue626'
    , upNav:'\ue627'
    , downNav:'\ue628'
    , menuRight:'\ue629'
    , airplane:'\ue62a'
    , mutedAlt:'\ue62b'
    , locked:'\ue62c'
    , weather:'\ue62d'
    , empty:' '
    }

icon.extend({
  icon: function(val) {
    var name = map[val.val]
    if(name) {
      var v = '<span>' + name + '</span>',
        value = this.node.innerHTML,
        divindex = value.indexOf('<div')
      if(~divindex) v += value.slice(divindex)
      this.html = v;
    } else {
      console.error('icon error: ', val.val, ' is not defined')
    }
  }
})

module.exports = exports = icon.Class
exports.map = map

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/icon/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/icon/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')
var ASSETS = require('vigour-js/util/config').pointers.assets

module.exports = new Element({
  opacity: 0,
  background: {
    data:'img',
    prepend:ASSETS,
    load: function(t) {
      if(this.$wait && this.$wait.val){
        this.$wait.once(false,function(){
          this.opacity = false
        })
      }else{
        this.opacity = false
      }
      this._loaded = true
      t._loaded = true
    }
  },
  'extend.$wait':function(){}
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/channel.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')

module.exports = new List({
  collection: {
    data: 'items',
    element:Item.Channel
  }
}).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/dots.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var _focused = require('/Users/shawn/Work/directv-fl//src/components/util').focused

module.exports = new Element({
  css:'list-dots',
  container:{
    collection:{
      data:'spotlight.items',
      element:new Element()
    },
    'extend.$focus': function( val ) {
      // alert(typeof val.val === 'string')
      var child = typeof val.val === 'string'
        ? this[val.val]
        : this.children[ val.val || 0 ]
      _focused( this, child )
    },
    model:{ complete:function(){
      if( this.children[0] ){
        if(this.$focus) this.$focus.update()
        this.model = { complete:null }
      }
    }}
  }
}).Class
},{"/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js":[function(require,module,exports){
require( './style.less' )

var cases = require( 'vigour-js/browser/cases' )
var Element = require( 'vigour-js/app/ui/element' )
var util = require('/Users/shawn/Work/directv-fl//src/components/util')
var _focused = util.focused
var _preventAnimation = util.preventAnimation

var Base = new Element( {
  css: 'base-list',
  model: function() {

    if ( this.children[ 0 ] ) {
      if( !this.$focus ) {
        console.error('this list needs a $focus value!')
        // this.$focus = 0
      }
      _updateX(this)
      this.$focus.update()
      this.model = false
    }
  },
  setSetting: {
    name: 'updateX',
    parent: function() {
      _updateX(this)
    }
  },
  'events.click':function(){
    var parent = this.parent
    if(parent.parent.$focus) parent.parent.$focus.from = parent._name
    // console.error('this!',this.parent.parent)
  }
} ).Class

var List = new Base( {
  'extend.$focus': function( val ) {
    var _this = this
    var n = val.val || 0
    var parent = this.parent
    
    _focused( this, this.children[ n ] )
    _bounce( this )

    if( !cases.$isPhone && parent ){
      
      var node = this.node
      var parentTop = parent.node.getBoundingClientRect().top
      if(_this.rafId) window.cancelAnimationFrame(_this.rafId)
      function check(){
        var top = node.getBoundingClientRect().top
        if(!top || top === parentTop) {
          _this.x = {
            multiply: -n
          }
          _this.rafId = null
        }else{
          _this.rafId = window.requestAnimationFrame(check)
        }
      }
      check()

    }else{
      this.x = {
        multiply: -n
      }
    }
  },
  x: {
    translate: true,
    val:0,
    multiply: 0,
    defer: _defer
  },
  y:{
    translate:true,
    val:0
  },
  $isPhone: {
    x: {
      animation: {
        time: 24,
        easing: 'outCubic'
      }
    },
    'events.grab': {
      x: true,
      pass: _pass,
      move: _highlight,
      up: _position
    }
  }
} ).Class

module.exports = exports = cases.$isPhone ? new Base( {
  // model:function(){
  //   if ( this.children[ 0 ] ) {
  //     var name = this.parent._name
  //     var scrollLeft = exports[name] && exports[name].scrollLeft
  //     if(scrollLeft){
  //       exports[name].ignoreScroll = true
  //       this.node.scrollLeft = scrollLeft
  //       exports[name].ignoreScroll = false
  //     }else{
  //       if( !this.$focus ) {
  //         console.error('this list needs a $focus value!')
  //         // this.$focus = 0

  //       }
  //       _updateX(this)
  //       this.$focus.update()
  //     }
  //     this.model = false
  //   }
  // },
  'extend.$focus': function( val ) {
    var children = this.children
    _focused( this, children[ val.val || 0 ] )
    if ( !this.node.scrollLeft && val.val ) {
      this.node.scrollLeft = val.val * _step( this, children )
    }
  },
  scrollbar: 'x',
  'events.scroll': function( e ) {
    // var name = this.parent._name
    // if(!exports[name]) exports[name] = {}
    // else if(exports[name].ignoreScroll) return

    if(!this._checked){ //block the first
      this._checked = true
      return
    }

    var _this = this
    var node = this.node
    var scrollLeft = node.scrollLeft
    var fraction = scrollLeft / ( node.scrollWidth - node.offsetWidth )
    var index = Math.round( fraction * ( _length( this ) - 1 ) )
    // exports[name].scrollLeft = scrollLeft
    _this.$focus.from = index
  }
} ).Class : List

exports.Carousel = List
exports.Spotlight = require( './spotlight' )
exports.Channel = require( './channel' )
exports.Poster = require( './poster' )
exports.Watching = require( './watching' )
exports.Dots = require( './dots' )
exports.Item = require( './item' )

var treshold = 60
var flick = 10

function _bounce( list ) {
  if ( list.x._e ){
    list.x = {
      _esub: list.x._e._val
    }
    list.x.update()
  }
}

function _highlight( e, d){
  var length = _length( this )
  var step = _step( this )
  var oldpos = this._start
  var newpos = oldpos
  if ( d.x < -treshold ) {
    newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
  } else if ( d.x > treshold ) {
    newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
  }
  if(-newpos !== this.$focus.val) _set( this, newpos )
}

function _pass( e, d ) {
  if(Math.abs( d.x ) > Math.abs( d.y )){
    this._start = -this.$focus.val || 0
    return true
  }
}

function _position( e, d, ld ) { // unify with switcher
  var children = this.children
  var length = _length( this )
  var oldpos = this._start || 0
  var newpos
  var step = _step( this, children )

  if ( Math.abs( ld.x ) > flick ) {
    if ( ld.x < 0 && d.x < treshold ) {
      newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
    } else if ( ld.x > 0 && d.x > -treshold ) {
      newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
    }
  } else {
    if ( d.x < -treshold ) {
      newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
    } else if ( d.x > treshold ) {
      newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
    }
  }

  if ( newpos !== void 0 && -newpos !== this.$focus.val ) _set( this, newpos )
  
  _bounce( this )
}

function _step( list, children, corrected ) { // this can be cleaner
  var node

  if ( !children ) children = list.children
  if ( children[ 0 ] ) {
    if ( !list._step ) {
      node = list.node
      list._step = node.scrollWidth / _length( list ) // 
    }
    if ( corrected ) {
      node = list.node
      return ( node.scrollWidth - node.offsetWidth ) / ( _length( list ) - 1 )
    }
    return list._step
  }
}

function _length( _this ){
  return _this.children.length //_this._length || ( _this._length = _this.children.length )
}

function _defer( update, args ) {
  var list = this._caller
  var step = _step( list, null, true )
  if ( step ) {
    if(!this._val) this.val = step
    this._flag = null
  }
  update()
}

function _updateX( _this ){
  if( _this.x ){
    _preventAnimation(_this,function(){
      _this.x._p = true
      _this.x.update()
      _this.x._p = null
    })
  }
}

function _set( _this, newpos ){
  var field = _this.$focus._flag && _this.$focus._flag.data[2]
  var data = _this.data
  if( field && data ){
    data.from.set(field,-newpos)
  }else _this.$focus.from = -newpos
}
},{"./channel":"/Users/shawn/Work/directv-fl/src/components/shared/list/channel.js","./dots":"/Users/shawn/Work/directv-fl/src/components/shared/list/dots.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","./poster":"/Users/shawn/Work/directv-fl/src/components/shared/list/poster.js","./spotlight":"/Users/shawn/Work/directv-fl/src/components/shared/list/spotlight.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/list/style.less","./watching":"/Users/shawn/Work/directv-fl/src/components/shared/list/watching.js","/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js":[function(require,module,exports){
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var blocked = 'blocked'

module.exports = exports = new Element({
  img: new Img(),
  'events.click': function() {
    var focus = this.parent.$focus
    if (focus) focus.from = this.$index
    app.user.navigation.content.$userOrigin = this.data.from
  },
  extend: [{
      name: '$index',
      type: false,
      get: function() {
        if (this._index === void 0) {
          var siblings = this.parent.children
          for (var i = siblings.length - 1; i >= 0; i--) {
            siblings[i]._index = i
          }
        }
        return this._index
      }
    }, {
      $blocked: _blocked
    }],
  '$blocked.data':blocked
}).Class

exports.Info = new exports({
  css: 'info-item',
  'img.background.data': 'img.thumb',
  info: {
    title: new Title.Show(),
    subtitle: new Subtitle()
  }
}).Class

exports.Poster = new exports({
  css: 'poster-item',
  'img.background.data': 'img.poster',
}).Class

exports.Channel = new exports.Info({
  'logo': new Img({
    'background.data': 'img.logo'
  }),
  'info.title.text.data': 'guide.0.title'
}).Class

exports.Carousel = new Img({
  css: 'spotlight-item',
  'extend.$blocked': _blocked,
  'events.click': function() {
    app.user.navigation.content.$userOrigin = this.data.from
  },
  background: {
    data: 'img.spotlight'
  },
  '$blocked.data':blocked
}).Class

function _blocked(val){
  if(val.val){
    this.addEvent('click',function(){
      // new Audio('http://www.noiseaddicts.com/samples_1w72b820/3739.mp3').play()
      alert('This item is not available')
    },blocked)
    this.css = { addClass:blocked }
    this.set({
      lock:new Icon({icon:'locked'})
    })
  }else{
    if(this.lock){
      this.removeEvent(false, blocked)
      this.css = { removeClass:blocked }
      this.lock.remove()
    }
  }
}

},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/poster.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Img = require('/Users/shawn/Work/directv-fl//src/components/shared/img')
var app = require('vigour-js/app')
var Item = require('./item')

List.Poster = module.exports = exports = new List({
  collection: {
    data: 'items',
    element:new Item.Poster()
  }
}).Class

// exports.element = element
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl//src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/spotlight.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')
var Img = require('/Users/shawn/Work/directv-fl//src/components/shared/img')
var app = require('vigour-js/app')

module.exports = new List.Carousel( {
  collection: {
    data: 'items',
    element:Item.Carousel
  }
} ).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl//src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/list/watching.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')
var app = require('vigour-js/app')

module.exports = new List({
  collection: {
    data: 'items',
    element:new Item.Info({
      bar:{
        w:{
          data:'time',
          multiply:100,
          abs:true,
          add:'%'
        }
      }
    })
  }
}).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/loader/index.js":[function(require,module,exports){
require('./style.less')

var Sprite = require('vigour-js/app/ui/sprite')
  , Element = require('vigour-js/app/ui/element')
  , cases = require('vigour-js/browser/cases')

module.exports = new Sprite(
{ css:'ui-loader'
, w:30
, h:30
, params:{ cols:1, rows:26 } // once:true }
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/loader/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/sprite":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/sprite/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/loader/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  background:{
    data:'mpaa',
    add:{data:'show.mpaa'},
    transform:function(v, mpaa){
      if( mpaa ) return 'assets/img/app/mpaa_' + mpaa.toLowerCase() + '.png'
    }
  }
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js":[function(require,module,exports){
require('./style.less')

var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
module.exports = new Icon({
  css:'ui-icon shared-mute',
  icon:{
    transform:function(v,cv){
      return cv ? 'mutedAlt' : 'volume'
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/mute/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/mute/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/poll/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var config = require('vigour-js/util/config')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar').Bar

var VoteRow = new Element({
  css: 'ui-voterow',
  left: {
    logo: { 
      background: { 
        data: 'img',
        prepend: config.pointers.assets
      },
      'events.click': function(){
        this.data.votes.val += 1
      }
    }
  },
  right: {
    count: {
      model:function(data){
        if(data._parent){
          this.model = false
          this.votefiller.data = data._parent
        }
      },
      team: { text: { data: 'title' } },
      votes: { text: { data: 'votes' ,add: ' VOTES' } },
      votefiller: new Bar({
        seek: {
          w:{
            data:true,
            transform: function( c, cv ){
              var count = this.parent.parent
              var myvotes = count.data && count.data.votes && count.data.votes.val
              if(myvotes) {
                var v1 = cv[0].votes.val
                var v2 = cv[1].votes.val
                var total = v1 + v2
                return ( myvotes / total ) * 100 + '%'
              }
            }
          },
          'extend.$backgroundColor': function( val ){
            var count = this.parent.parent
            var mycolor = count.data && count.data.color && count.data.color.val
            if(mycolor) {
            this.node.style.backgroundColor = mycolor
            }
          },
          '$backgroundColor.data': true
        }
      })
    }
  }
}).Class

var Poll = new Element({
  css: 'ui-poll',
  display:{
    val:'block',
    when:{data:'poll.0.title'},
    or:'none'
  },
  header: { text: { data: 'poll.title' } },
  first: new VoteRow({
    model: { field: 'poll.0' }
  }),
  second: new VoteRow({
    model: { field: 'poll.1' }
  })
}).Class

module.exports = Poll

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/poll/style.less","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/poll/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/popup/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')
var Switcher = require( 'vigour-js/app/ui/switcher' )
    .inject( require( 'vigour-js/app/ui/switcher/transitions' ) )

module.exports = exports = new Element({
  css:'popup',
  topbar:{
    left:new Icon({icon:'left'}),
    middle: { text:'popup' },
    right:new Icon({
      icon:'close',
      events: {
        click:function() {
          //how to sync it with misc???
          this.parent.parent.popup.$userOrigin = false
          // app.user.navigation.misc.$userOrigin
        }
      }
    })
  },
  w:app.w,
  h:app.h,
  y:
  { val:0, 
    animation:
    { time:app.h.val / 30
    , start:app.h
    , easing:'outCubic'
    , done:function(cv) {
        var t = this
        if(cv>=100) t.remove()
      }
    }
  },
  switcher:new Switcher({
    onTransition: {
      val:'fade',
      $hasTouch: 'slide'
    },
    backFallback: function() {
      console.error('wtf moet hier...backfallback')
    }
  }),
  extend:{
    popup:function(){}
  }
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/app/ui/switcher/transitions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  text:{data:'rating',add:{data:'show.rating'}}
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var app = require('vigour-js/app')

var Recommendations = new Element({
  css: 'ui-recommendations',
  display:{
    val:'block',
    when:{data:'recommendations'},
    or:'none'
  },
  header: { text: 'You\'ll love these' },
  body: {
    scrollbar: 'x',
    collection: {
      data: 'recommendations',
      element: Poster
    }
  }
}).Class

module.exports = Recommendations

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/style.less","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/search.js":[function(require,module,exports){
var app = require('vigour-js/app/')
var Element = require('vigour-js/app/ui/element')
var display = require('vigour-js/browser/element/properties/collection/display')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Mute = require('/Users/shawn/Work/directv-fl/src/components/shared/mute')
var config = require('vigour-js/util/config')

var Result = exports.Result = app.cases.$isPhone 
? new Element({
    css:'search-result',
    body: {
      title: {
        text:{data:'title'},
      },
      arrowRight: new Icon({ icon:'right' })
    },
    'events.click':function(e) {
      app.user.navigation.content.$userOrigin = this.data
     }
  }).Class
: new Element({
    css:'search-result',
    'poster.container':new Img({
      'background.data':'img.poster'
    }),
    body:{
      'title.text.data':'title',
      subtitle:new Subtitle()
    }
  }).Class

var Results = exports.Results = new Element({
  css:'search-results',
  title: {
    text:'recent searches'
  },
  collection: {
    option:display,
    element:Result
  }
}).Class

var TopResult = exports.TopResult = new Element({
  title: {text:'top result'},
  css:'search-top-result',
  body: {
    poster:{
      img: {
        background: {
          val: config.pointers.img,
          add: { data:'img.poster' }
        },
        backdrop:{},
        mute:new Mute({
          display:{
            val:'none',
            $hasReceiver:'block'
          },
          icon:{
            val:app.user.trailerMuted
          },
          'events.click':function(e) {
            app.user.trailerMuted.$userOrigin = !app.user.trailerMuted.val
          }
        })
      }
    },
    textHolder:{
      title: { text:{ data:'title' } },
      info: { text:'112 minutes' },
      rating: {
        text: { data:'rating'}
      },
      description: { text: { data: 'description'} },
      'events.click':function(e) {
        app.user.navigation.content.$userOrigin = this.title.data
      }
    }
  },
  model: { inherit: false }
  // 'model.field':'movies.0' //deze moet dynamicly changen :(
}).Class

exports.ResultList = new Element({
  movies: new Results({
    title: {
      text:'movies'
    },
    collection: {
      element: new Result({
        model: {
          subscription: {
            title:true,
            actors:{
              $:{
                title:true
              }
            }
          }
        }
      }),
      data:'movies'
    }
  }),
  series: new Results({
    title: {
      text:'series'
    },
    collection: {
      data:'series'
    }
  }),
  channels: new Results({
    title: {
      text:'channels'
    },
    collection: {
      data:'channels'
    }
  }),
  actors: new Results({
    title: {
      text:'actors'
    },
    collection: {
      data:'actors',
      element: new Result({
        model: {
          subscription: {
            title:true,
            catalog:{
              $:{
                title:true
              }
            }
          }
        },
        'events.click':function(e) {
          //misc
          // alert('?')
          app.popup.$userOrigin = this.data.from
        }
      })
    }
  })
}).Class

exports.filterCollection = function( element, srch, filter) {
  filter = filter || {
    condition: {
      $or: [
      { title:{ $contains:srch } },
      { catalog:{ $: { title: { $contains:srch } } } },
      { actors:{ $: { title: { $contains:srch } } } }
      ]
    }
  }
  if( element.filter ) {
    element.filter.filter = filter
  } else {
    element.collection = { filter: filter }
  }    
}

exports.topResult = function( list ) {
  for(var i in list) {
    if( list[i].filter && list[i].filter[0] ) {
      return list[i].filter[0]
    }
  }
}

exports.parseSearch = function(val) {
  if(val && val.__t === 2) {
    return ''
  }
  val = val && val.trim() || ''
  var str = '';
  return val
}
},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mute":"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/properties/collection/display":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/display.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var app = require('vigour-js/app/') //  replace app stuff with parent
var ua = require('vigour-js/browser/ua')
var cases = require('vigour-js/browser/cases')
var videoUtil = require('vigour-js/browser/element/video/util')
var Icon = require('../icon')
var _limitUpdates = ua.platform === 'ios' || ua.platform === 'android'

var Bar = new Element({
  css:'ui-seekbar',
  bg:{},
  seek:{}
}).Class

var seekbar = new Bar({ 
  'seek.w':{ 
    data:'time',
    transform:function(v,cv){
      return Math.abs(cv) * 100 + '%'
    }
  },
  bg: {
    loaderbar: {
      // append:[Element,{},{},{},{},{},{},{},{}]
    }
  },
  events:
  { down: function(e) { 
      e.tempPrevent = true
      setTime.call(this, e)
    },
    drag: setTime,
    up:cases.touch
    ? function(e){
        var overlayOpacity = this.parent.parent.parent.opacity
        if(!this._skipUp) setTime.call(this, e)
        else this._skipUp = null
      }
    : setTime
  }
})

module.exports = exports = seekbar.Class

exports.Bar = Bar

function setTime(e) {

  // console.error('xxxx')

  var rect = this.node.getBoundingClientRect()
    , x
    , nr

  if(this._left){
    x = rect.top
    nr = (e.y-x)/rect.height
  }else if(this._right){
    x = rect.top
    nr = (rect.height-(e.y-x))/rect.height
  }else{
    x = rect.left
    nr = (e.x-x)/(rect.right-x)
  }

  var val = nr > 1 ? 1 : nr < 0 ? 0 : nr
  if( val !== this._prevVal )
  {
    this.seek.data.from.set('time',val)
    this._prevVal = val
  }
}
},{"../icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/style.less","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element/video/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/util.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var config = require('vigour-js/util/config')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

var Score = new Element({
  css:'ui-score',
  top: {
    info: {
      'title.text.data': 'statistics.title',
      'subtitle.text.data': 'statistics.date'
    },
    teams: {
      left: new Img({
        'background.data': 'statistics.left.img'
      }),
      right:new Img({
        'background.data': 'statistics.right.img'
      })
    }
  },
  body: {
    'left.text.data': 'statistics.left.points',
    middleleft: {
      'title.text.data': 'statistics.left.acronym',
      'subtitle.text.data': 'statistics.left.innings'
    },
    middleright: {
      'title.text.data': 'statistics.right.acronym',
      'subtitle.text.data': 'statistics.right.innings'
    },
    'right.text.data': 'statistics.right.points',
  }
}).Class

module.exports = exports = new Element({
  css: 'ui-statistics',
  display:{
    data:'statistics.title',
    transform:function(v,cv){
      return cv ? 'block' : 'none'
    }
  },
  'header.text': 'Statistics',
  body:new Score()
}).Class

exports.Score = Score
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/statistics/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  text: {
    data: 'subtitle',
    add: [
      '.', {
        data: 'year',
        add: [' - ', {
          data: 'duration',
          divide: 60,
          floor: true,
          add: ' Minutes'
        }]
      },
      '.', {
        data: 'guide.0.start-time',
        add: [' - ', {
          data: 'guide.0.end-time'
        }]
      }
    ],
    transform: function(v, cv) {
      var arr = cv.split('.')
      var l = arr.length - 1
      var str = arr[l]
      while (str[1] === '-' || (str[5] === '-' && str[7] === ' ')) { //dirty!
        str = arr[--l]
      }
      if (str) return str

      var from = this.data && this.data.from
      if (from) {
        var episode = (from._name | 0) + 1
        var season = (from._parent._parent._name | 0) + 1
        return 'Season ' + season + ' - ' + 'Episode ' + episode
      }
    }
  }
}).Class

},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )

module.exports = exports = new Element({
  'text.default.data':'title'
}).Class

exports.Show = new exports({
  'text.data':'show.title'
}).Class

// exports.Program = new exports({
//   'text.data':'guide.0.title'
// }).Class
// exports.Topbar = new exports.Show({

// })
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var ASSETS = require('vigour-js/util/config').pointers.assets

module.exports = new Element({
  css: 'ui-trivia',
  'header.text': 'Trivia',
  display:{
    data:'trivia.title',
    transform:function(v,cv){
      return cv ? 'block' : 'none'
    }
  },
  body: {
    background: { 
      data: 'img',
      prepend: ASSETS
    },
    'title.text.data': 'trivia.title',
    'subtitle.text.data': 'trivia.subtitle',
    'description.text.data': 'trivia.description'
  }
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/trivia/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/tweets/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')

var app = require('vigour-js/app')

var tweet = new Element({
  css: 'tweet',
  icon: new Icon({icon:'twitter'}),
  from: { text: { val: '@', add: { data: 'author' } } },
  msg: { text: { data: 'body' } },
  retweet: { text: 'RETWEET' }
})

var Tweets = new Element({
    css: 'ui-tweets',
    display:{
      data:'tweets',
      transform:function(v,cv){
        return cv ? 'block' : 'none'
      }
    },
    header: { text: 'Tweets' },
    holdert: { //weird name.... holder is a class
      scrollbar: 'x',
      body: {
        collection: {
          data: 'tweets',
          element: tweet
        }
      }
    }
}).Class

module.exports = Tweets

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/tweets/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/tweets/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

module.exports = new Element({
  css:'ui-wallpaper'
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var Switcher = require( 'vigour-js/app/ui/switcher' )
    .inject( require( 'vigour-js/app/ui/switcher/transitions' ) )
var app = require( 'vigour-js/app' )
var cases = app.cases
var Wallpaper = require('/Users/shawn/Work/directv-fl/src/components/shared/wallpaper')

module.exports = exports = new Switcher( {
  css:'app-switcher',
  on: {
    state: { //state lekker extended
      defer: function( update ) {
        var on = this._parent
        var switcher = on._caller
        var state = this.from.val
        
        if( state==='second' ) {

          switcher.transition = {
            element:require('/Users/shawn/Work/directv-fl//src/components/inactive'),
            $params:{ 
              $highlight:on.highlight._val,
              $preview:on.preview._val,
              $media:app.user.receiver.media,
              $page:on.navigation._val.page,
              $content:on.navigation._val.content,
              navigation:{
                data:app.content.get('discover'),
                $focus:on.focus._val,
                container:{
                  progress:{
                    data:on.preview._val
                  }
                }
                // $progress:app.progress
              }
            }
          }

        } else if( state==='first' ) {

          switcher.transition = {
            element:require('/Users/shawn/Work/directv-fl//src/components/active'),
            $params:{
              menu: {
                navigation: app.user.navigation
              },
              on:{
                focus:on.focus._val,
                popup:on.popup._val,
                secondPopup:on.secondPopup._val
              },
              holder:{
                topbar:{
                  $current: app.current,
                },
                switcher:{
                  navigation: app.user.navigation
                },
                miniplayer:{
                  media:app.user.receiver.media,
                  playing:app.user.receiver.playing
                }
              }
            }
          }

        } else if( state === 'inactive'){
        
          switcher.transition = {
            element:Wallpaper,
            $params:{}
          }

        }

        update()
      }
    }
  },
  onTransition:'fade'
} ).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/switcher/style.less","/Users/shawn/Work/directv-fl//src/components/active":"/Users/shawn/Work/directv-fl/src/components/active/index.js","/Users/shawn/Work/directv-fl//src/components/inactive":"/Users/shawn/Work/directv-fl/src/components/inactive/index.js","/Users/shawn/Work/directv-fl/src/components/shared/wallpaper":"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/app/ui/switcher/transitions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js"}],"/Users/shawn/Work/directv-fl/src/components/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/util/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
exports.focused = function( holder, focused, method ) {
  if ( focused ) {
    
    var previous = holder._focused

    if ( previous !== focused ) {

      if ( previous ) {
        previous.css = {
          removeClass: 'focused'
        }
        previous.$focused = false
      }

      focused.css = {
        addClass: 'focused'
      }

      focused.$focused = true

      if ( method ) method( focused, previous )

      holder._focused = focused
    }

  }
}

exports.preventAnimation = function( _this, method, done ){
  _this._blocked = true
  _this.css = {addClass:'dontAnimate'}
  window.requestAnimationFrame(function(){
    method()
    window.requestAnimationFrame(function(){
      _this.css = {removeClass:'dontAnimate'}
      _this._blocked = null
      if( done ) done()
    })
  })
}
},{}],"/Users/shawn/Work/directv-fl/src/main/clienthack.js":[function(require,module,exports){
var app = require('/Users/shawn/Work/directv-fl/src/app')
var url = require('vigour-js/browser/network/url')
var ua = require('vigour-js/browser/ua')
var device = url.params.device && url.params.device.val || ua.device

var clientinfo = {
  phone: {
    title: 'Kevin\'s iPhone',
    info: 'iPhone 6'
  },
  ipad: {
    title: 'Kevin\'s iPad',
    info: 'iPad 2',
    device: 'tablet'
  },
  tv: {
    title: 'Sharp',
    info: '52" LED TV',
    device: 'tv'
  },
  tablet: {
    title: 'United Airlines',
    info: 'In Flight Entertainment',
    device: 'IFE'
  },
  def: {
    title: ua.platform+' '+device,
    info: ua.platform+' '+device,
    device:device
  }
}

app.cloud.client.val = clientinfo[device] || clientinfo.def
},{"/Users/shawn/Work/directv-fl/src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/browser/network/url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/main/index.js":[function(require,module,exports){
require('./uahack')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Switcher = require('/Users/shawn/Work/directv-fl//src/components/switcher')
var user = app.user

if(app.cases.$isNative){
  var statusBar = require('vigour-native-statusBar')
  statusBar.set({
    style:'light',
    visibility:'overlay'
  }, function (err) {
    if (err) alert("error setting statusBar: " +err)
  })
}

// switcher between first/second/player

// app.ready.once(true,function(){

require('./clienthack')

// app.ready.once(true,function(){

app.set({
  switcher: new Switcher( {
    on: {
      navigation: user.navigation,
      play: app.playing,
      receiver: user.receiver,
      usage: user.usage,
      content: app.content,
      search: user.search,
      focus: user.focus_row,
      preview: app.preview,
      highlight: app.highlight,
      popup:app.popup,
      secondPopup:app.secondPopup,
      //nav word different
      // watched: user.watched.from,
      state: app.state,
      overlay: app.overlay,
      loading: app.loading,
      activeClient: user.activeClient,
      volume: app.volume
    }
  })
})


// TODO: rename app.initialized?

// app.popup.val = 'actor'
// app.menu.val = true
// })

app.initialised.val = true


// app.ready.is(true,function(){
//   app.secondPopup.val = 'volume'
// },true)
},{"./clienthack":"/Users/shawn/Work/directv-fl/src/main/clienthack.js","./uahack":"/Users/shawn/Work/directv-fl/src/main/uahack.js","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl//src/components/switcher":"/Users/shawn/Work/directv-fl/src/components/switcher/index.js","vigour-native-statusBar":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/index.js"}],"/Users/shawn/Work/directv-fl/src/main/uahack.js":[function(require,module,exports){
var ua = require('vigour-js/browser/ua')
var cases = require('vigour-js/browser/cases')

console.log('---------------- ua hacking that!', ua)


if(ua.device === 'desktop') {
  console.log('hack dat desktop')
  ua.device = 'tv'
  ua.platform = 'fancy'
  cases.$isDesktop = false
  console.log('lol set dat tv treus')
  cases.$isTv = true

  window.INACTIVE = true
} else if(ua.device === 'ipad') {
  window.INACTIVE = true

}

},{"vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"package.json":[function(require,module,exports){
module.exports={"name":"directv-fl","version":"2015/06/08 17:19:01 UTC (1.0.3)","description":"","main":"index.js","scripts":{"startGaston":"./node_modules/.bin/gaston dev","start":"npm run startGaston","test":"echo \"Error: no test specified\" && exit 1","symlink":"mkdir -p node_modules; ln -sf $(pwd) $(pwd)/node_modules","startHub":"./node_modules/vigour-hub/bin/hub -d -c directv","prestart":"npm run startHub &","build":"vNative build","release":"packer -r -c package.json,.package.json"},"repository":{"type":"git","url":"https://github.com/vigour-io/directv-fl.git","branch":"master"},"author":"Vigour","bugs":{"url":"https://github.com/vigour-io/directv-fl/issues"},"homepage":"https://github.com/vigour-io/directv-fl","dependencies":{"through2":"*","lodash":"3.2.0","monotonic-timestamp":"0.0.9","promise":"^7.0.1","vigour-js":"git+ssh://git@github.com:vigour-io/vigour-js.git#directv"},"devDependencies":{"vigour-native":"git+ssh://git@github.com:vigour-io/vigour-native.git","vigour-native-statusBar":"git+ssh://git@github.com:vigour-io/vigour-native-statusBar.git","vigour-packer-server":"git+ssh://git@github.com:vigour-io/vigour-packer-server.git","vigour-hub":"git+ssh://git@github.com:vigour-io/vigour-hub.git#directv","gaston":"git+ssh://git@github.com:vigour-io/gaston.git"},"vigour":{"cloud":"http://directv.dev.vigour.io:80","branches":{"youzi-dev":{"cloud":"http://10.0.1.2:10001"},"marcus-dev":{"cloud":"http://10.0.1.199:10001"},"shawn-dev":{"cloud":"http://192.168.2.18:10001"}},"development":{"button":false},"pointers":{"img":"http://devassets.vigour.io/","assets":"http://devassets.vigour.io/"},"packer":{"web":"index.html","assets":{"bundle.js":true,"bundle.css":true,"index.html":true,"assets":"*","fonts.css":true},"git":{"owner":"vigour-io","repo":"directv-fl"},"mail":{"fromAddress":"shawn@vigour.io","to":"shawn@vigour.io"},"slack":{},"server":{}},"native":{"platforms":{"ios":{"productName":"Direct TV - Future Land","organizationName":"Vigour","organizationIdentifier":"io.vigour.directv-fl","buildNumber":"1","appIndexPath":"index.html","appUrlIdentifier":"com.directv-fl.org","appUrlScheme":"directv-fl"}}}},"gaston":{"browserify-transforms":[{"path":"vigour-js/util/inform-transform","options":{"global":"false"}}],"require-paths":{"dtv":"src","shared":"src/components/shared","dtv-components":"src/components","dtv-active":"src/components/active","dtv-item":"src/components/active/content-item","dtv-channel":"src/components/active/content-item/channel","dtv-episode":"src/components/active/content-item/episode","dtv-movie":"src/components/active/content-item/movie"}},"sha":"1.0.3"}
},{}]},{},["/Users/shawn/Work/directv-fl/index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImNvbmZpZy5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZG9tYWluLWJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2FzdG9uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL29zLWJyb3dzZXJpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ2FzdG9uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbW9ub3RvbmljLXRpbWVzdGFtcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2NvcmUuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9lczYtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL25vZGUtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItYXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItcmF3LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2Uvbm9kZV9tb2R1bGVzL2FzYXAvcmF3LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvY2xvdWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC9jb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91aS9lbGVtZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdWkvc3ByaXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlci90cmFuc2l0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvaWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdXNlci9tb2NrZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvbXVsdGlzY3JlZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL25hdmlnYXRpb24uanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL29yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvc2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdXNlci90b2tlbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvdXNhZ2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC92YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jhc2Uvc2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL2Vhc2luZy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vZnJhbWUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9yYWYuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jYXNlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jYXNlcy9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvY3NzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2NvbGxlY3Rpb24vZGlzcGxheS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvY29sbGVjdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvY29sbGVjdGlvbi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvcHJvY2Vzcy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvc2Nyb2xsYmFyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvc2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8vaHRtbDUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL2FkdmFuY2VkLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy9iYXNpYy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9ldmVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL29mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2FqYXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9hdXRoZW50aWNhdGUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvZGF0YWNsb3VkLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2Nsb3VkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvc29ja2V0LmlvLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2RhdGEvZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2RhdGEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay91cmwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvdWEuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2RhdGEvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvZGF0YS9jb25kaXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9kYXRhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9kYXRhL3NlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9jb2xvcnMvY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWluaGVyaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeS9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL3V0ZjgvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2hhcy1jb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvaGFzLWNvcnMvbm9kZV9tb2R1bGVzL2dsb2JhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZWpzb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3Byb21pc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZG9uZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2VzNi1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvbm9kZS1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9ub2RlX21vZHVsZXMvYXNhcC9hc2FwLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9vYmplY3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2pzb24zL2xpYi9qc29uMy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3RvLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9vYmplY3QvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL29iamVjdC9jb21wb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9vYmplY3QvaGFzaHBhdGguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL29iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L2xpc3Rlbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvY29uZmlnL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL2NvbmZpZy91YS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9kZWJ1Zy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9kZWJ1Zy9sb2cuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvZGVidWcvcGVyZm9ybWFuY2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL2hhc2guanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaW5qZWN0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9wcm9jZXNzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL3Byb3AuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL2RhdGEuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9mbGFncy9wYXJlbnQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3NlbGYuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9sZW5ndGguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL29uLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9vcGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyL3BhY2thZ2UuanNvbiIsInNyYy9hcHAvaW5kZXguanMiLCJzcmMvYXBwL2luaXQuanMiLCJzcmMvYXBwL3BsYXliYWNrLmpzIiwic3JjL2FwcC91c2VyLmpzIiwic3JjL2FwcC92YWx1ZXMuanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvY2hhbm5lbC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9jb250ZW50L2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2Rpc2NvdmVyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2VwaXNvZGUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvbWVudS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9tb3ZpZS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wbGF5ZXIvZnVsbHNjcmVlbi5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wbGF5ZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvYWN0b3IvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvZGV2aWNlcy9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9wYWdlLmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3BvcHVwL3JlbW90ZS9jYXJvdXNlbC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9yZW1vdGUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvdm9sdW1lL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3JlbW90ZS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9zZWFyY2gvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvc3dpdGNoZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvdG9wYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3RvcGJhci9pbnB1dC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2Jpby9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2NoYW5uZWwvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9pbmFjdGl2ZS9jb250ZW50L2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvY292ZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9pbmFjdGl2ZS9kaXNjb3Zlci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvbmF2aWdhdGlvbi9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3BsYXllci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3Byb2dyZXNzL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvc2VhcmNoL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvc3RhdHVzYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvdHJhaWxlci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3ZvZC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3dpZGdldC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9hY3RvcnMvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2Rlc2NyaXB0aW9uL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24vaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QvY2hhbm5lbC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2RvdHMuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2l0ZW0uanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9wb3N0ZXIuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9zcG90bGlnaHQuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC93YXRjaGluZy5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9sb2FkZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbXBhYS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9tdXRlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3BvbGwvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvcG9wdXAvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvcmF0aW5nL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3JlY29tbWVuZGF0aW9ucy9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9zZWFyY2guanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2Jhci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9zdGF0aXN0aWNzL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3N1YnRpdGxlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3RpdGxlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3RyaXZpYS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC90d2VldHMvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvd2FsbHBhcGVyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc3dpdGNoZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy91dGlsL2luZGV4LmpzIiwic3JjL21haW4vY2xpZW50aGFjay5qcyIsInNyYy9tYWluL2luZGV4LmpzIiwic3JjL21haW4vdWFoYWNrLmpzIiwicGFja2FnZS5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdDQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL3VCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25lQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL1VBO0FBQ0E7QUFDQTs7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RqQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0VkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3pPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakhBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDallBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2haQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9ZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9wQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBOztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ3JNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIndpbmRvdy5uYW1lID0gJ2RpcmVjdHYtZmwnXG5cbi8vIHdpbmRvdy5wYWNrYWdlID0gcmVxdWlyZSgncGFja2FnZS5qc29uJylcbi8vIGNvbnNvbGUubG9nKCd3dGYuLi4nLCB3aW5kb3cucGFja2FnZSlcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcmVxdWlyZSggJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycgKVxuICAgICAgICAgICAgICAuaW5qZWN0XG4gICAgICAgICAgICAgICggeyAncmVwb3NpdG9yeS5icmFuY2gnOiAnYnJhbmNoZXMnIH1cbiAgICAgICAgICAgICAgLCByZXF1aXJlKCAndmlnb3VyLWpzL3V0aWwvY29uZmlnL3VhJyApXG4gICAgICAgICAgICAgIClcblxuZXhwb3J0cyggZnVuY3Rpb24oIHJlc3VsdCApIHtcbiAgZm9yKHZhciBrZXkgaW4gcmVzdWx0KSB7XG4gICAgLy8gY29uc29sZS5sb2coJ1xcbicsIGksIHJlc3VsdFtpXSlcbiAgICBleHBvcnRzW2tleV0gPSByZXN1bHRba2V5XSBcbiAgfVxuICBleHBvcnRzLnBhcnNlZCA9IHRydWVcblxufSwgZmFsc2UsIHdpbmRvdy5wYWNrYWdlLCB0cnVlICkiLCJ3aW5kb3cucGFja2FnZSA9IHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL2NvbmZpZycpXG4gICwgcmVtb3RlXG5cbmlmKCBjb25maWcuZGV2ZWxvcG1lbnQgJiYgY29uZmlnLmRldmVsb3BtZW50LmJ1dHRvbiApXG57XG4gIHJlbW90ZSA9IHJlcXVpcmUoICd2aWdvdXItanMvdXRpbC9kZWJ1ZycgKVxuICAgICAgICAgICAgLm5hdGl2ZSggZmFsc2UsIGZhbHNlLCBmdW5jdGlvbih1cmwpIHt9ICwgJ2J1bmRsZScgKVxufVxuXG5pZiggIXJlbW90ZSApIFxue1xuICB2YXIgY2FzZXMgPSByZXF1aXJlKCAndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnIClcbiAgICAsIHVhID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL3VhJyApXG5cbiAgLy8gaWYodWEuZGV2aWNlID09PSAndGFibGV0Jyl7XG4gIC8vICAgdmFyIHZpZXdwb3J0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm1ldGFbbmFtZT12aWV3cG9ydF1cIilcbiAgLy8gICB2aWV3cG9ydC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCAnd2lkdGg9ZGV2aWNlLXdpZHRoLCBpbml0aWFsLXNjYWxlPTAuNiwgbWF4aW11bS1zY2FsZT0xLjAsIHVzZXItc2NhbGFibGU9MCcpO1xuICAvLyB9XG5cbiAgcmVxdWlyZSggJy4vc3JjL21haW4nIClcbiAgXG59IixudWxsLCIvKmdsb2JhbCBkZWZpbmU6ZmFsc2UgcmVxdWlyZTpmYWxzZSAqL1xubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKXtcblx0Ly8gSW1wb3J0IEV2ZW50c1xuXHR2YXIgZXZlbnRzID0gcmVxdWlyZSgnZXZlbnRzJylcblxuXHQvLyBFeHBvcnQgRG9tYWluXG5cdHZhciBkb21haW4gPSB7fVxuXHRkb21haW4uY3JlYXRlRG9tYWluID0gZG9tYWluLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG5cdFx0dmFyIGQgPSBuZXcgZXZlbnRzLkV2ZW50RW1pdHRlcigpXG5cblx0XHRmdW5jdGlvbiBlbWl0RXJyb3IoZSkge1xuXHRcdFx0ZC5lbWl0KCdlcnJvcicsIGUpXG5cdFx0fVxuXG5cdFx0ZC5hZGQgPSBmdW5jdGlvbihlbWl0dGVyKXtcblx0XHRcdGVtaXR0ZXIub24oJ2Vycm9yJywgZW1pdEVycm9yKVxuXHRcdH1cblx0XHRkLnJlbW92ZSA9IGZ1bmN0aW9uKGVtaXR0ZXIpe1xuXHRcdFx0ZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlbWl0RXJyb3IpXG5cdFx0fVxuXHRcdGQuYmluZCA9IGZ1bmN0aW9uKGZuKXtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpe1xuXHRcdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRmbi5hcHBseShudWxsLCBhcmdzKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNhdGNoIChlcnIpe1xuXHRcdFx0XHRcdGVtaXRFcnJvcihlcnIpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZC5pbnRlcmNlcHQgPSBmdW5jdGlvbihmbil7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZXJyKXtcblx0XHRcdFx0aWYgKCBlcnIgKSB7XG5cdFx0XHRcdFx0ZW1pdEVycm9yKGVycilcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Zm4uYXBwbHkobnVsbCwgYXJncylcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVycil7XG5cdFx0XHRcdFx0XHRlbWl0RXJyb3IoZXJyKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkLnJ1biA9IGZ1bmN0aW9uKGZuKXtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGZuKClcblx0XHRcdH1cblx0XHRcdGNhdGNoIChlcnIpIHtcblx0XHRcdFx0ZW1pdEVycm9yKGVycilcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fTtcblx0XHRkLmRpc3Bvc2UgPSBmdW5jdGlvbigpe1xuXHRcdFx0dGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9O1xuXHRcdGQuZW50ZXIgPSBkLmV4aXQgPSBmdW5jdGlvbigpe1xuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cdFx0cmV0dXJuIGRcblx0fTtcblx0cmV0dXJuIGRvbWFpblxufSkuY2FsbCh0aGlzKSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xuXG5leHBvcnRzLmhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZVxuICAgIH1cbiAgICBlbHNlIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudXB0aW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG5leHBvcnRzLmZyZWVtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLnRvdGFsbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Jyb3dzZXInIH07XG5cbmV4cG9ydHMucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcbj0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge30gfTtcblxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnYnJvd3NlcicgfTtcblxuZXhwb3J0cy50bXBkaXIgPSBleHBvcnRzLnRtcERpciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy90bXAnO1xufTtcblxuZXhwb3J0cy5FT0wgPSAnXFxuJztcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudFF1ZXVlO1xuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB2YXIgaSA9IC0xO1xuICAgICAgICB3aGlsZSAoKytpIDwgbGVuKSB7XG4gICAgICAgICAgICBjdXJyZW50UXVldWVbaV0oKTtcbiAgICAgICAgfVxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG59XG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHF1ZXVlLnB1c2goZnVuKTtcbiAgICBpZiAoIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLy8gSWYgYERhdGUubm93KClgIGlzIGludm9rZWQgdHdpY2UgcXVpY2tseSwgaXQncyBwb3NzaWJsZSB0byBnZXQgdHdvXG4vLyBpZGVudGljYWwgdGltZSBzdGFtcHMuIFRvIGF2b2lkIGdlbmVyYXRpb24gZHVwbGljYXRpb25zLCBzdWJzZXF1ZW50XG4vLyBjYWxscyBhcmUgbWFudWFsbHkgb3JkZXJlZCB0byBmb3JjZSB1bmlxdWVuZXNzLlxuXG52YXIgX2xhc3QgPSAwXG52YXIgX2NvdW50ID0gMVxudmFyIGFkanVzdGVkID0gMFxudmFyIF9hZGp1c3RlZCA9IDBcblxubW9kdWxlLmV4cG9ydHMgPVxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICAvKipcbiAgUmV0dXJucyBOT1QgYW4gYWNjdXJhdGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgdGltZS5cbiAgU2luY2UganMgb25seSBtZWFzdXJlcyB0aW1lIGFzIG1zLCBpZiB5b3UgY2FsbCBgRGF0ZS5ub3coKWBcbiAgdHdpY2UgcXVpY2tseSwgaXQncyBwb3NzaWJsZSB0byBnZXQgdHdvIGlkZW50aWNhbCB0aW1lIHN0YW1wcy5cbiAgVGhpcyBmdW5jdGlvbiBndWFyYW50ZWVzIHVuaXF1ZSBidXQgbWF5YmUgaW5hY2N1cmF0ZSByZXN1bHRzXG4gIG9uIGVhY2ggY2FsbC5cbiAgKiovXG4gIC8vdW5jb21tZW50IHRoaXMgd2VuXG4gIHZhciB0aW1lID0gRGF0ZS5ub3coKVxuICAvL3RpbWUgPSB+fiAodGltZSAvIDEwMDApIFxuICAvL15eXnVuY29tbWVudCB3aGVuIHRlc3RpbmcuLi5cblxuICAvKipcbiAgSWYgdGltZSByZXR1cm5lZCBpcyBzYW1lIGFzIGluIGxhc3QgY2FsbCwgYWRqdXN0IGl0IGJ5XG4gIGFkZGluZyBhIG51bWJlciBiYXNlZCBvbiB0aGUgY291bnRlci4gXG4gIENvdW50ZXIgaXMgaW5jcmVtZW50ZWQgc28gdGhhdCBuZXh0IGNhbGwgZ2V0J3MgYWRqdXN0ZWQgcHJvcGVybHkuXG4gIEJlY2F1c2UgZmxvYXRzIGhhdmUgcmVzdHJpY3RlZCBwcmVjaXNpb24sIFxuICBtYXkgbmVlZCB0byBzdGVwIHBhc3Qgc29tZSB2YWx1ZXMuLi5cbiAgKiovXG4gIGlmIChfbGFzdCA9PT0gdGltZSkgIHtcbiAgICBkbyB7XG4gICAgICBhZGp1c3RlZCA9IHRpbWUgKyAoKF9jb3VudCsrKSAvIChfY291bnQgKyA5OTkpKVxuICAgIH0gd2hpbGUgKGFkanVzdGVkID09PSBfYWRqdXN0ZWQpXG4gICAgX2FkanVzdGVkID0gYWRqdXN0ZWRcbiAgfVxuICAvLyBJZiBsYXN0IHRpbWUgd2FzIGRpZmZlcmVudCByZXNldCB0aW1lciBiYWNrIHRvIGAxYC5cbiAgZWxzZSB7XG4gICAgX2NvdW50ID0gMVxuICAgIGFkanVzdGVkID0gdGltZVxuICB9XG4gIF9hZGp1c3RlZCA9IGFkanVzdGVkXG4gIF9sYXN0ID0gdGltZVxuICByZXR1cm4gYWRqdXN0ZWRcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcC9yYXcnKTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFN0YXRlczpcbi8vXG4vLyAwIC0gcGVuZGluZ1xuLy8gMSAtIGZ1bGZpbGxlZCB3aXRoIF92YWx1ZVxuLy8gMiAtIHJlamVjdGVkIHdpdGggX3ZhbHVlXG4vLyAzIC0gYWRvcHRlZCB0aGUgc3RhdGUgb2YgYW5vdGhlciBwcm9taXNlLCBfdmFsdWVcbi8vXG4vLyBvbmNlIHRoZSBzdGF0ZSBpcyBubyBsb25nZXIgcGVuZGluZyAoMCkgaXQgaXMgaW1tdXRhYmxlXG5cbi8vIEFsbCBgX2AgcHJlZml4ZWQgcHJvcGVydGllcyB3aWxsIGJlIHJlZHVjZWQgdG8gYF97cmFuZG9tIG51bWJlcn1gXG4vLyBhdCBidWlsZCB0aW1lIHRvIG9iZnVzY2F0ZSB0aGVtIGFuZCBkaXNjb3VyYWdlIHRoZWlyIHVzZS5cbi8vIFdlIGRvbid0IHVzZSBzeW1ib2xzIG9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB0byBmdWxseSBoaWRlIHRoZW1cbi8vIGJlY2F1c2UgdGhlIHBlcmZvcm1hbmNlIGlzbid0IGdvb2QgZW5vdWdoLlxuXG5cbi8vIHRvIGF2b2lkIHVzaW5nIHRyeS9jYXRjaCBpbnNpZGUgY3JpdGljYWwgZnVuY3Rpb25zLCB3ZVxuLy8gZXh0cmFjdCB0aGVtIHRvIGhlcmUuXG52YXIgTEFTVF9FUlJPUiA9IG51bGw7XG52YXIgSVNfRVJST1IgPSB7fTtcbmZ1bmN0aW9uIGdldFRoZW4ob2JqKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG9iai50aGVuO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5Q2FsbE9uZShmbiwgYSkge1xuICB0cnkge1xuICAgIHJldHVybiBmbihhKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5mdW5jdGlvbiB0cnlDYWxsVHdvKGZuLCBhLCBiKSB7XG4gIHRyeSB7XG4gICAgZm4oYSwgYik7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0Jykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICB9XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICB9XG4gIHRoaXMuXzMyID0gMDtcbiAgdGhpcy5fOCA9IG51bGw7XG4gIHRoaXMuXzg5ID0gW107XG4gIGlmIChmbiA9PT0gbm9vcCkgcmV0dXJuO1xuICBkb1Jlc29sdmUoZm4sIHRoaXMpO1xufVxuUHJvbWlzZS5fODMgPSBub29wO1xuXG5Qcm9taXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgaWYgKHRoaXMuY29uc3RydWN0b3IgIT09IFByb21pc2UpIHtcbiAgICByZXR1cm4gc2FmZVRoZW4odGhpcywgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICB9XG4gIHZhciByZXMgPSBuZXcgUHJvbWlzZShub29wKTtcbiAgaGFuZGxlKHRoaXMsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXMpKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHNhZmVUaGVuKHNlbGYsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHJldHVybiBuZXcgc2VsZi5jb25zdHJ1Y3RvcihmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKG5vb3ApO1xuICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgaGFuZGxlKHNlbGYsIG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXMpKTtcbiAgfSk7XG59O1xuZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gIHdoaWxlIChzZWxmLl8zMiA9PT0gMykge1xuICAgIHNlbGYgPSBzZWxmLl84O1xuICB9XG4gIGlmIChzZWxmLl8zMiA9PT0gMCkge1xuICAgIHNlbGYuXzg5LnB1c2goZGVmZXJyZWQpO1xuICAgIHJldHVybjtcbiAgfVxuICBhc2FwKGZ1bmN0aW9uKCkge1xuICAgIHZhciBjYiA9IHNlbGYuXzMyID09PSAxID8gZGVmZXJyZWQub25GdWxmaWxsZWQgOiBkZWZlcnJlZC5vblJlamVjdGVkO1xuICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgaWYgKHNlbGYuXzMyID09PSAxKSB7XG4gICAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fOCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgc2VsZi5fOCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZXQgPSB0cnlDYWxsT25lKGNiLCBzZWxmLl84KTtcbiAgICBpZiAocmV0ID09PSBJU19FUlJPUikge1xuICAgICAgcmVqZWN0KGRlZmVycmVkLnByb21pc2UsIExBU1RfRVJST1IpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlKGRlZmVycmVkLnByb21pc2UsIHJldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoc2VsZiwgbmV3VmFsdWUpIHtcbiAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb21pc2VzLWFwbHVzL3Byb21pc2VzLXNwZWMjdGhlLXByb21pc2UtcmVzb2x1dGlvbi1wcm9jZWR1cmVcbiAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB7XG4gICAgcmV0dXJuIHJlamVjdChcbiAgICAgIHNlbGYsXG4gICAgICBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpXG4gICAgKTtcbiAgfVxuICBpZiAoXG4gICAgbmV3VmFsdWUgJiZcbiAgICAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpXG4gICkge1xuICAgIHZhciB0aGVuID0gZ2V0VGhlbihuZXdWYWx1ZSk7XG4gICAgaWYgKHRoZW4gPT09IElTX0VSUk9SKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KHNlbGYsIExBU1RfRVJST1IpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICB0aGVuID09PSBzZWxmLnRoZW4gJiZcbiAgICAgIG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZVxuICAgICkge1xuICAgICAgc2VsZi5fMzIgPSAzO1xuICAgICAgc2VsZi5fOCA9IG5ld1ZhbHVlO1xuICAgICAgZmluYWxlKHNlbGYpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRvUmVzb2x2ZSh0aGVuLmJpbmQobmV3VmFsdWUpLCBzZWxmKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgc2VsZi5fMzIgPSAxO1xuICBzZWxmLl84ID0gbmV3VmFsdWU7XG4gIGZpbmFsZShzZWxmKTtcbn1cblxuZnVuY3Rpb24gcmVqZWN0KHNlbGYsIG5ld1ZhbHVlKSB7XG4gIHNlbGYuXzMyID0gMjtcbiAgc2VsZi5fOCA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5mdW5jdGlvbiBmaW5hbGUoc2VsZikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuXzg5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaGFuZGxlKHNlbGYsIHNlbGYuXzg5W2ldKTtcbiAgfVxuICBzZWxmLl84OSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2Upe1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsO1xuICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICB0aGlzLnByb21pc2UgPSBwcm9taXNlO1xufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgcHJvbWlzZSkge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB2YXIgcmVzID0gdHJ5Q2FsbFR3byhmbiwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZXNvbHZlKHByb21pc2UsIHZhbHVlKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIHJlYXNvbik7XG4gIH0pXG4gIGlmICghZG9uZSAmJiByZXMgPT09IElTX0VSUk9SKSB7XG4gICAgZG9uZSA9IHRydWU7XG4gICAgcmVqZWN0KHByb21pc2UsIExBU1RfRVJST1IpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblByb21pc2UucHJvdG90eXBlLmRvbmUgPSBmdW5jdGlvbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIHNlbGYgPSBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy50aGVuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzO1xuICBzZWxmLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0sIDApO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBFUzYgZXh0ZW5zaW9ucyB0byB0aGUgY29yZSBQcm9taXNlcy9BKyBBUElcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcC9yYXcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cbnZhciBUUlVFID0gdmFsdWVQcm9taXNlKHRydWUpO1xudmFyIEZBTFNFID0gdmFsdWVQcm9taXNlKGZhbHNlKTtcbnZhciBOVUxMID0gdmFsdWVQcm9taXNlKG51bGwpO1xudmFyIFVOREVGSU5FRCA9IHZhbHVlUHJvbWlzZSh1bmRlZmluZWQpO1xudmFyIFpFUk8gPSB2YWx1ZVByb21pc2UoMCk7XG52YXIgRU1QVFlTVFJJTkcgPSB2YWx1ZVByb21pc2UoJycpO1xuXG5mdW5jdGlvbiB2YWx1ZVByb21pc2UodmFsdWUpIHtcbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShQcm9taXNlLl84Myk7XG4gIHAuXzMyID0gMTtcbiAgcC5fOCA9IHZhbHVlO1xuICByZXR1cm4gcDtcbn1cblByb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gdmFsdWU7XG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gTlVMTDtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBVTkRFRklORUQ7XG4gIGlmICh2YWx1ZSA9PT0gdHJ1ZSkgcmV0dXJuIFRSVUU7XG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHJldHVybiBGQUxTRTtcbiAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gWkVSTztcbiAgaWYgKHZhbHVlID09PSAnJykgcmV0dXJuIEVNUFRZU1RSSU5HO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHZhbHVlLnRoZW47XG4gICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWx1ZSkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICByZWplY3QoZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZVByb21pc2UodmFsdWUpO1xufTtcblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgUHJvbWlzZSAmJiB2YWwudGhlbiA9PT0gUHJvbWlzZS5wcm90b3R5cGUudGhlbikge1xuICAgICAgICAgIHdoaWxlICh2YWwuXzMyID09PSAzKSB7XG4gICAgICAgICAgICB2YWwgPSB2YWwuXzg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWwuXzMyID09PSAxKSByZXR1cm4gcmVzKGksIHZhbC5fOCk7XG4gICAgICAgICAgaWYgKHZhbC5fMzIgPT09IDIpIHJlamVjdCh2YWwuXzgpO1xuICAgICAgICAgIHZhbC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgIH0sIHJlamVjdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW47XG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgcCA9IG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWwpKTtcbiAgICAgICAgICAgIHAudGhlbihmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICAgIHJlcyhpLCB2YWwpO1xuICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFyZ3NbaV0gPSB2YWw7XG4gICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSk7XG4gICAgfVxuICB9KTtcbn07XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpe1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuLyogUHJvdG90eXBlIE1ldGhvZHMgKi9cblxuUHJvbWlzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbiAob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuUHJvbWlzZS5wcm90b3R5cGVbJ2ZpbmFsbHknXSA9IGZ1bmN0aW9uIChmKSB7XG4gIHJldHVybiB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pO1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG5yZXF1aXJlKCcuL2RvbmUuanMnKTtcbnJlcXVpcmUoJy4vZmluYWxseS5qcycpO1xucmVxdWlyZSgnLi9lczYtZXh0ZW5zaW9ucy5qcycpO1xucmVxdWlyZSgnLi9ub2RlLWV4dGVuc2lvbnMuanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyBmaWxlIGNvbnRhaW5zIHRoZW4vcHJvbWlzZSBzcGVjaWZpYyBleHRlbnNpb25zIHRoYXQgYXJlIG9ubHkgdXNlZnVsXG4vLyBmb3Igbm9kZS5qcyBpbnRlcm9wXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJyk7XG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cblByb21pc2UuZGVub2RlaWZ5ID0gZnVuY3Rpb24gKGZuLCBhcmd1bWVudENvdW50KSB7XG4gIGFyZ3VtZW50Q291bnQgPSBhcmd1bWVudENvdW50IHx8IEluZmluaXR5O1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHdoaWxlIChhcmdzLmxlbmd0aCAmJiBhcmdzLmxlbmd0aCA+IGFyZ3VtZW50Q291bnQpIHtcbiAgICAgICAgYXJncy5wb3AoKTtcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgIGVsc2UgcmVzb2x2ZShyZXMpO1xuICAgICAgfSlcbiAgICAgIHZhciByZXMgPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIGlmIChyZXMgJiZcbiAgICAgICAgKFxuICAgICAgICAgIHR5cGVvZiByZXMgPT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgdHlwZW9mIHJlcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICApICYmXG4gICAgICAgIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgKSB7XG4gICAgICAgIHJlc29sdmUocmVzKTtcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5Qcm9taXNlLm5vZGVpZnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGNhbGxiYWNrID1cbiAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicgPyBhcmdzLnBvcCgpIDogbnVsbDtcbiAgICB2YXIgY3R4ID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykubm9kZWlmeShjYWxsYmFjaywgY3R4KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGV4KTtcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2suY2FsbChjdHgsIG51bGwsIHZhbHVlKTtcbiAgICB9KTtcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVycik7XG4gICAgfSk7XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIHJhd0FzYXAgcHJvdmlkZXMgZXZlcnl0aGluZyB3ZSBuZWVkIGV4Y2VwdCBleGNlcHRpb24gbWFuYWdlbWVudC5cbnZhciByYXdBc2FwID0gcmVxdWlyZShcIi4vcmF3XCIpO1xuLy8gUmF3VGFza3MgYXJlIHJlY3ljbGVkIHRvIHJlZHVjZSBHQyBjaHVybi5cbnZhciBmcmVlVGFza3MgPSBbXTtcbi8vIFdlIHF1ZXVlIGVycm9ycyB0byBlbnN1cmUgdGhleSBhcmUgdGhyb3duIGluIHJpZ2h0IG9yZGVyIChGSUZPKS5cbi8vIEFycmF5LWFzLXF1ZXVlIGlzIGdvb2QgZW5vdWdoIGhlcmUsIHNpbmNlIHdlIGFyZSBqdXN0IGRlYWxpbmcgd2l0aCBleGNlcHRpb25zLlxudmFyIHBlbmRpbmdFcnJvcnMgPSBbXTtcbnZhciByZXF1ZXN0RXJyb3JUaHJvdyA9IHJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKHRocm93Rmlyc3RFcnJvcik7XG5cbmZ1bmN0aW9uIHRocm93Rmlyc3RFcnJvcigpIHtcbiAgICBpZiAocGVuZGluZ0Vycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgcGVuZGluZ0Vycm9ycy5zaGlmdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIHRhc2sgYXMgc29vbiBhcyBwb3NzaWJsZSBhZnRlciByZXR1cm5pbmcsIGluIGl0cyBvd24gZXZlbnQsIHdpdGggcHJpb3JpdHlcbiAqIG92ZXIgb3RoZXIgZXZlbnRzIGxpa2UgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZXBhaW50LiBBbiBlcnJvciB0aHJvd24gZnJvbSBhblxuICogZXZlbnQgd2lsbCBub3QgaW50ZXJydXB0LCBub3IgZXZlbiBzdWJzdGFudGlhbGx5IHNsb3cgZG93biB0aGUgcHJvY2Vzc2luZyBvZlxuICogb3RoZXIgZXZlbnRzLCBidXQgd2lsbCBiZSByYXRoZXIgcG9zdHBvbmVkIHRvIGEgbG93ZXIgcHJpb3JpdHkgZXZlbnQuXG4gKiBAcGFyYW0ge3tjYWxsfX0gdGFzayBBIGNhbGxhYmxlIG9iamVjdCwgdHlwaWNhbGx5IGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBub1xuICogYXJndW1lbnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGFzYXA7XG5mdW5jdGlvbiBhc2FwKHRhc2spIHtcbiAgICB2YXIgcmF3VGFzaztcbiAgICBpZiAoZnJlZVRhc2tzLmxlbmd0aCkge1xuICAgICAgICByYXdUYXNrID0gZnJlZVRhc2tzLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJhd1Rhc2sgPSBuZXcgUmF3VGFzaygpO1xuICAgIH1cbiAgICByYXdUYXNrLnRhc2sgPSB0YXNrO1xuICAgIHJhd0FzYXAocmF3VGFzayk7XG59XG5cbi8vIFdlIHdyYXAgdGFza3Mgd2l0aCByZWN5Y2xhYmxlIHRhc2sgb2JqZWN0cy4gIEEgdGFzayBvYmplY3QgaW1wbGVtZW50c1xuLy8gYGNhbGxgLCBqdXN0IGxpa2UgYSBmdW5jdGlvbi5cbmZ1bmN0aW9uIFJhd1Rhc2soKSB7XG4gICAgdGhpcy50YXNrID0gbnVsbDtcbn1cblxuLy8gVGhlIHNvbGUgcHVycG9zZSBvZiB3cmFwcGluZyB0aGUgdGFzayBpcyB0byBjYXRjaCB0aGUgZXhjZXB0aW9uIGFuZCByZWN5Y2xlXG4vLyB0aGUgdGFzayBvYmplY3QgYWZ0ZXIgaXRzIHNpbmdsZSB1c2UuXG5SYXdUYXNrLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIHRoaXMudGFzay5jYWxsKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGFzYXAub25lcnJvcikge1xuICAgICAgICAgICAgLy8gVGhpcyBob29rIGV4aXN0cyBwdXJlbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICAgICAgICAvLyBJdHMgbmFtZSB3aWxsIGJlIHBlcmlvZGljYWxseSByYW5kb21pemVkIHRvIGJyZWFrIGFueSBjb2RlIHRoYXRcbiAgICAgICAgICAgIC8vIGRlcGVuZHMgb24gaXRzIGV4aXN0ZW5jZS5cbiAgICAgICAgICAgIGFzYXAub25lcnJvcihlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJbiBhIHdlYiBicm93c2VyLCBleGNlcHRpb25zIGFyZSBub3QgZmF0YWwuIEhvd2V2ZXIsIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBzbG93aW5nIGRvd24gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgdGFza3MsIHdlIHJldGhyb3cgdGhlIGVycm9yIGluIGFcbiAgICAgICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHR1cm4uXG4gICAgICAgICAgICBwZW5kaW5nRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgICAgICAgcmVxdWVzdEVycm9yVGhyb3coKTtcbiAgICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXMudGFzayA9IG51bGw7XG4gICAgICAgIGZyZWVUYXNrc1tmcmVlVGFza3MubGVuZ3RoXSA9IHRoaXM7XG4gICAgfVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vLyBVc2UgdGhlIGZhc3Rlc3QgbWVhbnMgcG9zc2libGUgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gaXRzIG93biB0dXJuLCB3aXRoXG4vLyBwcmlvcml0eSBvdmVyIG90aGVyIGV2ZW50cyBpbmNsdWRpbmcgSU8sIGFuaW1hdGlvbiwgcmVmbG93LCBhbmQgcmVkcmF3XG4vLyBldmVudHMgaW4gYnJvd3NlcnMuXG4vL1xuLy8gQW4gZXhjZXB0aW9uIHRocm93biBieSBhIHRhc2sgd2lsbCBwZXJtYW5lbnRseSBpbnRlcnJ1cHQgdGhlIHByb2Nlc3Npbmcgb2Zcbi8vIHN1YnNlcXVlbnQgdGFza3MuIFRoZSBoaWdoZXIgbGV2ZWwgYGFzYXBgIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZSwgYnV0IGlmIHlvdSB1c2UgYHJhd0FzYXBgIGRpcmVjdGx5LCB5b3UgYXJlIHJlc3BvbnNpYmxlIHRvXG4vLyBlaXRoZXIgZW5zdXJlIHRoYXQgbm8gZXhjZXB0aW9ucyBhcmUgdGhyb3duIGZyb20geW91ciB0YXNrLCBvciB0byBtYW51YWxseVxuLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5tb2R1bGUuZXhwb3J0cyA9IHJhd0FzYXA7XG5mdW5jdGlvbiByYXdBc2FwKHRhc2spIHtcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICByZXF1ZXN0Rmx1c2goKTtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBFcXVpdmFsZW50IHRvIHB1c2gsIGJ1dCBhdm9pZHMgYSBmdW5jdGlvbiBjYWxsLlxuICAgIHF1ZXVlW3F1ZXVlLmxlbmd0aF0gPSB0YXNrO1xufVxuXG52YXIgcXVldWUgPSBbXTtcbi8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4vLyBuZWNlc3NhcnkgdW50aWwgdGhlIG5leHQgYGZsdXNoYCBjb21wbGV0ZXMuXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGFuIGltcGxlbWVudGF0aW9uLXNwZWNpZmljIG1ldGhvZCB0aGF0IGF0dGVtcHRzIHRvIGtpY2tcbi8vIG9mZiBhIGBmbHVzaGAgZXZlbnQgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS4gYGZsdXNoYCB3aWxsIGF0dGVtcHQgdG8gZXhoYXVzdFxuLy8gdGhlIGV2ZW50IHF1ZXVlIGJlZm9yZSB5aWVsZGluZyB0byB0aGUgYnJvd3NlcidzIG93biBldmVudCBsb29wLlxudmFyIHJlcXVlc3RGbHVzaDtcbi8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbi8vIHByZXNlcnZlZCBiZXR3ZWVuIGNhbGxzIHRvIGBmbHVzaGAgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBpZlxuLy8gYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24uXG52YXIgaW5kZXggPSAwO1xuLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuLy8gdW5ib3VuZGVkLiBUbyBwcmV2ZW50IG1lbW9yeSBleGhhdXN0aW9uLCB0aGUgdGFzayBxdWV1ZSB3aWxsIHBlcmlvZGljYWxseVxuLy8gdHJ1bmNhdGUgYWxyZWFkeS1jb21wbGV0ZWQgdGFza3MuXG52YXIgY2FwYWNpdHkgPSAxMDI0O1xuXG4vLyBUaGUgZmx1c2ggZnVuY3Rpb24gcHJvY2Vzc2VzIGFsbCB0YXNrcyB0aGF0IGhhdmUgYmVlbiBzY2hlZHVsZWQgd2l0aFxuLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4vLyBJZiBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgYGZsdXNoYCBlbnN1cmVzIHRoYXQgaXRzIHN0YXRlIHdpbGwgcmVtYWluXG4vLyBjb25zaXN0ZW50IGFuZCB3aWxsIHJlc3VtZSB3aGVyZSBpdCBsZWZ0IG9mZiB3aGVuIGNhbGxlZCBhZ2Fpbi5cbi8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93bi5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHdoaWxlIChpbmRleCA8IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgIC8vIGJlZ2luIGZsdXNoaW5nIG9uIHRoZSBuZXh0IHRhc2sgdGhlIHRhc2sgdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgcXVldWVbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgIC8vIFByZXZlbnQgbGVha2luZyBtZW1vcnkgZm9yIGxvbmcgY2hhaW5zIG9mIHJlY3Vyc2l2ZSBjYWxscyB0byBgYXNhcGAuXG4gICAgICAgIC8vIElmIHdlIGNhbGwgYGFzYXBgIHdpdGhpbiB0YXNrcyBzY2hlZHVsZWQgYnkgYGFzYXBgLCB0aGUgcXVldWUgd2lsbFxuICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgIC8vIHNoaWZ0IHRhc2tzIG9mZiB0aGUgcXVldWUgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAgICAgIC8vIEluc3RlYWQsIHdlIHBlcmlvZGljYWxseSBzaGlmdCAxMDI0IHRhc2tzIG9mZiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChpbmRleCA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIGZvciAodmFyIHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxdWV1ZS5sZW5ndGggLSBpbmRleDsgc2NhbiA8IG5ld0xlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbc2Nhbl0gPSBxdWV1ZVtzY2FuICsgaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUubGVuZ3RoIC09IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgaW5kZXggPSAwO1xuICAgIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbi8vIGByZXF1ZXN0Rmx1c2hgIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc3RyYXRlZ3kgYmFzZWQgb24gZGF0YSBjb2xsZWN0ZWQgZnJvbVxuLy8gZXZlcnkgYXZhaWxhYmxlIFNhdWNlTGFicyBTZWxlbml1bSB3ZWIgZHJpdmVyIHdvcmtlciBhdCB0aW1lIG9mIHdyaXRpbmcuXG4vLyBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9zcHJlYWRzaGVldHMvZC8xbUctNVVZR3VwNXF4R2RFTVdraFA2QldDejA1M05VYjJFMVFvVVRVMTZ1QS9lZGl0I2dpZD03ODM3MjQ1OTNcblxuLy8gU2FmYXJpIDYgYW5kIDYuMSBmb3IgZGVza3RvcCwgaVBhZCwgYW5kIGlQaG9uZSBhcmUgdGhlIG9ubHkgYnJvd3NlcnMgdGhhdFxuLy8gaGF2ZSBXZWJLaXRNdXRhdGlvbk9ic2VydmVyIGJ1dCBub3QgdW4tcHJlZml4ZWQgTXV0YXRpb25PYnNlcnZlci5cbi8vIE11c3QgdXNlIGBnbG9iYWxgIGluc3RlYWQgb2YgYHdpbmRvd2AgdG8gd29yayBpbiBib3RoIGZyYW1lcyBhbmQgd2ViXG4vLyB3b3JrZXJzLiBgZ2xvYmFsYCBpcyBhIHByb3Zpc2lvbiBvZiBCcm93c2VyaWZ5LCBNciwgTXJzLCBvciBNb3AuXG52YXIgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPSBnbG9iYWwuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWwuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcblxuLy8gTXV0YXRpb25PYnNlcnZlcnMgYXJlIGRlc2lyYWJsZSBiZWNhdXNlIHRoZXkgaGF2ZSBoaWdoIHByaW9yaXR5IGFuZCB3b3JrXG4vLyByZWxpYWJseSBldmVyeXdoZXJlIHRoZXkgYXJlIGltcGxlbWVudGVkLlxuLy8gVGhleSBhcmUgaW1wbGVtZW50ZWQgaW4gYWxsIG1vZGVybiBicm93c2Vycy5cbi8vXG4vLyAtIEFuZHJvaWQgNC00LjNcbi8vIC0gQ2hyb21lIDI2LTM0XG4vLyAtIEZpcmVmb3ggMTQtMjlcbi8vIC0gSW50ZXJuZXQgRXhwbG9yZXIgMTFcbi8vIC0gaVBhZCBTYWZhcmkgNi03LjFcbi8vIC0gaVBob25lIFNhZmFyaSA3LTcuMVxuLy8gLSBTYWZhcmkgNi03XG5pZiAodHlwZW9mIEJyb3dzZXJNdXRhdGlvbk9ic2VydmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihmbHVzaCk7XG5cbi8vIE1lc3NhZ2VDaGFubmVscyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBnaXZlIGRpcmVjdCBhY2Nlc3MgdG8gdGhlIEhUTUxcbi8vIHRhc2sgcXVldWUsIGFyZSBpbXBsZW1lbnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMCwgU2FmYXJpIDUuMC0xLCBhbmQgT3BlcmFcbi8vIDExLTEyLCBhbmQgaW4gd2ViIHdvcmtlcnMgaW4gbWFueSBlbmdpbmVzLlxuLy8gQWx0aG91Z2ggbWVzc2FnZSBjaGFubmVscyB5aWVsZCB0byBhbnkgcXVldWVkIHJlbmRlcmluZyBhbmQgSU8gdGFza3MsIHRoZXlcbi8vIHdvdWxkIGJlIGJldHRlciB0aGFuIGltcG9zaW5nIHRoZSA0bXMgZGVsYXkgb2YgdGltZXJzLlxuLy8gSG93ZXZlciwgdGhleSBkbyBub3Qgd29yayByZWxpYWJseSBpbiBJbnRlcm5ldCBFeHBsb3JlciBvciBTYWZhcmkuXG5cbi8vIEludGVybmV0IEV4cGxvcmVyIDEwIGlzIHRoZSBvbmx5IGJyb3dzZXIgdGhhdCBoYXMgc2V0SW1tZWRpYXRlIGJ1dCBkb2VzXG4vLyBub3QgaGF2ZSBNdXRhdGlvbk9ic2VydmVycy5cbi8vIEFsdGhvdWdoIHNldEltbWVkaWF0ZSB5aWVsZHMgdG8gdGhlIGJyb3dzZXIncyByZW5kZXJlciwgaXQgd291bGQgYmVcbi8vIHByZWZlcnJhYmxlIHRvIGZhbGxpbmcgYmFjayB0byBzZXRUaW1lb3V0IHNpbmNlIGl0IGRvZXMgbm90IGhhdmVcbi8vIHRoZSBtaW5pbXVtIDRtcyBwZW5hbHR5LlxuLy8gVW5mb3J0dW5hdGVseSB0aGVyZSBhcHBlYXJzIHRvIGJlIGEgYnVnIGluIEludGVybmV0IEV4cGxvcmVyIDEwIE1vYmlsZSAoYW5kXG4vLyBEZXNrdG9wIHRvIGEgbGVzc2VyIGV4dGVudCkgdGhhdCByZW5kZXJzIGJvdGggc2V0SW1tZWRpYXRlIGFuZFxuLy8gTWVzc2FnZUNoYW5uZWwgdXNlbGVzcyBmb3IgdGhlIHB1cnBvc2VzIG9mIEFTQVAuXG4vLyBodHRwczovL2dpdGh1Yi5jb20va3Jpc2tvd2FsL3EvaXNzdWVzLzM5NlxuXG4vLyBUaW1lcnMgYXJlIGltcGxlbWVudGVkIHVuaXZlcnNhbGx5LlxuLy8gV2UgZmFsbCBiYWNrIHRvIHRpbWVycyBpbiB3b3JrZXJzIGluIG1vc3QgZW5naW5lcywgYW5kIGluIGZvcmVncm91bmRcbi8vIGNvbnRleHRzIGluIHRoZSBmb2xsb3dpbmcgYnJvd3NlcnMuXG4vLyBIb3dldmVyLCBub3RlIHRoYXQgZXZlbiB0aGlzIHNpbXBsZSBjYXNlIHJlcXVpcmVzIG51YW5jZXMgdG8gb3BlcmF0ZSBpbiBhXG4vLyBicm9hZCBzcGVjdHJ1bSBvZiBicm93c2Vycy5cbi8vXG4vLyAtIEZpcmVmb3ggMy0xM1xuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciA2LTlcbi8vIC0gaVBhZCBTYWZhcmkgNC4zXG4vLyAtIEx5bnggMi44Ljdcbn0gZWxzZSB7XG4gICAgcmVxdWVzdEZsdXNoID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGZsdXNoKTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgcmVxdWVzdHMgdGhhdCB0aGUgaGlnaCBwcmlvcml0eSBldmVudCBxdWV1ZSBiZSBmbHVzaGVkIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLlxuLy8gVGhpcyBpcyB1c2VmdWwgdG8gcHJldmVudCBhbiBlcnJvciB0aHJvd24gaW4gYSB0YXNrIGZyb20gc3RhbGxpbmcgdGhlIGV2ZW50XG4vLyBxdWV1ZSBpZiB0aGUgZXhjZXB0aW9uIGhhbmRsZWQgYnkgTm9kZS5qc+KAmXNcbi8vIGBwcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIilgIG9yIGJ5IGEgZG9tYWluLlxucmF3QXNhcC5yZXF1ZXN0Rmx1c2ggPSByZXF1ZXN0Rmx1c2g7XG5cbi8vIFRvIHJlcXVlc3QgYSBoaWdoIHByaW9yaXR5IGV2ZW50LCB3ZSBpbmR1Y2UgYSBtdXRhdGlvbiBvYnNlcnZlciBieSB0b2dnbGluZ1xuLy8gdGhlIHRleHQgb2YgYSB0ZXh0IG5vZGUgYmV0d2VlbiBcIjFcIiBhbmQgXCItMVwiLlxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spIHtcbiAgICB2YXIgdG9nZ2xlID0gMTtcbiAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIoY2FsbGJhY2spO1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShub2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAgICAgICAgdG9nZ2xlID0gLXRvZ2dsZTtcbiAgICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlO1xuICAgIH07XG59XG5cbi8vIFRoZSBtZXNzYWdlIGNoYW5uZWwgdGVjaG5pcXVlIHdhcyBkaXNjb3ZlcmVkIGJ5IE1hbHRlIFVibCBhbmQgd2FzIHRoZVxuLy8gb3JpZ2luYWwgZm91bmRhdGlvbiBmb3IgdGhpcyBsaWJyYXJ5LlxuLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcblxuLy8gU2FmYXJpIDYuMC41IChhdCBsZWFzdCkgaW50ZXJtaXR0ZW50bHkgZmFpbHMgdG8gY3JlYXRlIG1lc3NhZ2UgcG9ydHMgb24gYVxuLy8gcGFnZSdzIGZpcnN0IGxvYWQuIFRoYW5rZnVsbHksIHRoaXMgdmVyc2lvbiBvZiBTYWZhcmkgc3VwcG9ydHNcbi8vIE11dGF0aW9uT2JzZXJ2ZXJzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGZhbGwgYmFjayBpbiB0aGF0IGNhc2UuXG5cbi8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21NZXNzYWdlQ2hhbm5lbChjYWxsYmFjaykge1xuLy8gICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4vLyAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBjYWxsYmFjaztcbi8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4vLyAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoMCk7XG4vLyAgICAgfTtcbi8vIH1cblxuLy8gRm9yIHJlYXNvbnMgZXhwbGFpbmVkIGFib3ZlLCB3ZSBhcmUgYWxzbyB1bmFibGUgdG8gdXNlIGBzZXRJbW1lZGlhdGVgXG4vLyB1bmRlciBhbnkgY2lyY3Vtc3RhbmNlcy5cbi8vIEV2ZW4gaWYgd2Ugd2VyZSwgdGhlcmUgaXMgYW5vdGhlciBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4vLyBJdCBpcyBub3Qgc3VmZmljaWVudCB0byBhc3NpZ24gYHNldEltbWVkaWF0ZWAgdG8gYHJlcXVlc3RGbHVzaGAgYmVjYXVzZVxuLy8gYHNldEltbWVkaWF0ZWAgbXVzdCBiZSBjYWxsZWQgKmJ5IG5hbWUqIGFuZCB0aGVyZWZvcmUgbXVzdCBiZSB3cmFwcGVkIGluIGFcbi8vIGNsb3N1cmUuXG4vLyBOZXZlciBmb3JnZXQuXG5cbi8vIGZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21TZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbi8vICAgICByZXR1cm4gZnVuY3Rpb24gcmVxdWVzdENhbGwoKSB7XG4vLyAgICAgICAgIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4vLyAgICAgfTtcbi8vIH1cblxuLy8gU2FmYXJpIDYuMCBoYXMgYSBwcm9ibGVtIHdoZXJlIHRpbWVycyB3aWxsIGdldCBsb3N0IHdoaWxlIHRoZSB1c2VyIGlzXG4vLyBzY3JvbGxpbmcuIFRoaXMgcHJvYmxlbSBkb2VzIG5vdCBpbXBhY3QgQVNBUCBiZWNhdXNlIFNhZmFyaSA2LjAgc3VwcG9ydHNcbi8vIG11dGF0aW9uIG9ic2VydmVycywgc28gdGhhdCBpbXBsZW1lbnRhdGlvbiBpcyB1c2VkIGluc3RlYWQuXG4vLyBIb3dldmVyLCBpZiB3ZSBldmVyIGVsZWN0IHRvIHVzZSB0aW1lcnMgaW4gU2FmYXJpLCB0aGUgcHJldmFsZW50IHdvcmstYXJvdW5kXG4vLyBpcyB0byBhZGQgYSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgdGhhdCBjYWxscyBmb3IgYSBmbHVzaC5cblxuLy8gYHNldFRpbWVvdXRgIGRvZXMgbm90IGNhbGwgdGhlIHBhc3NlZCBjYWxsYmFjayBpZiB0aGUgZGVsYXkgaXMgbGVzcyB0aGFuXG4vLyBhcHByb3hpbWF0ZWx5IDcgaW4gd2ViIHdvcmtlcnMgaW4gRmlyZWZveCA4IHRocm91Z2ggMTgsIGFuZCBzb21ldGltZXMgbm90XG4vLyBldmVuIHRoZW4uXG5cbmZ1bmN0aW9uIG1ha2VSZXF1ZXN0Q2FsbEZyb21UaW1lcihjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbiAgICAgICAgLy8gV2UgZGlzcGF0Y2ggYSB0aW1lb3V0IHdpdGggYSBzcGVjaWZpZWQgZGVsYXkgb2YgMCBmb3IgZW5naW5lcyB0aGF0XG4gICAgICAgIC8vIGNhbiByZWxpYWJseSBhY2NvbW1vZGF0ZSB0aGF0IHJlcXVlc3QuIFRoaXMgd2lsbCB1c3VhbGx5IGJlIHNuYXBwZWRcbiAgICAgICAgLy8gdG8gYSA0IG1pbGlzZWNvbmQgZGVsYXksIGJ1dCBvbmNlIHdlJ3JlIGZsdXNoaW5nLCB0aGVyZSdzIG5vIGRlbGF5XG4gICAgICAgIC8vIGJldHdlZW4gZXZlbnRzLlxuICAgICAgICB2YXIgdGltZW91dEhhbmRsZSA9IHNldFRpbWVvdXQoaGFuZGxlVGltZXIsIDApO1xuICAgICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGlzIHRpbWVyIGdldHMgZnJlcXVlbnRseSBkcm9wcGVkIGluIEZpcmVmb3hcbiAgICAgICAgLy8gd29ya2Vycywgd2UgZW5saXN0IGFuIGludGVydmFsIGhhbmRsZSB0aGF0IHdpbGwgdHJ5IHRvIGZpcmVcbiAgICAgICAgLy8gYW4gZXZlbnQgMjAgdGltZXMgcGVyIHNlY29uZCB1bnRpbCBpdCBzdWNjZWVkcy5cbiAgICAgICAgdmFyIGludGVydmFsSGFuZGxlID0gc2V0SW50ZXJ2YWwoaGFuZGxlVGltZXIsIDUwKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVUaW1lcigpIHtcbiAgICAgICAgICAgIC8vIFdoaWNoZXZlciB0aW1lciBzdWNjZWVkcyB3aWxsIGNhbmNlbCBib3RoIHRpbWVycyBhbmRcbiAgICAgICAgICAgIC8vIGV4ZWN1dGUgdGhlIGNhbGxiYWNrLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuLy8gVGhpcyBpcyBmb3IgYGFzYXAuanNgIG9ubHkuXG4vLyBJdHMgbmFtZSB3aWxsIGJlIHBlcmlvZGljYWxseSByYW5kb21pemVkIHRvIGJyZWFrIGFueSBjb2RlIHRoYXQgZGVwZW5kcyBvblxuLy8gaXRzIGV4aXN0ZW5jZS5cbnJhd0FzYXAubWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyID0gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyO1xuXG4vLyBBU0FQIHdhcyBvcmlnaW5hbGx5IGEgbmV4dFRpY2sgc2hpbSBpbmNsdWRlZCBpbiBRLiBUaGlzIHdhcyBmYWN0b3JlZCBvdXRcbi8vIGludG8gdGhpcyBBU0FQIHBhY2thZ2UuIEl0IHdhcyBsYXRlciBhZGFwdGVkIHRvIFJTVlAgd2hpY2ggbWFkZSBmdXJ0aGVyXG4vLyBhbWVuZG1lbnRzLiBUaGVzZSBkZWNpc2lvbnMsIHBhcnRpY3VsYXJseSB0byBtYXJnaW5hbGl6ZSBNZXNzYWdlQ2hhbm5lbCBhbmRcbi8vIHRvIGNhcHR1cmUgdGhlIE11dGF0aW9uT2JzZXJ2ZXIgaW1wbGVtZW50YXRpb24gaW4gYSBjbG9zdXJlLCB3ZXJlIGludGVncmF0ZWRcbi8vIGJhY2sgaW50byBBU0FQIHByb3Blci5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90aWxkZWlvL3JzdnAuanMvYmxvYi9jZGRmNzIzMjU0NmE5Y2Y4NTg1MjRiNzVjZGU2ZjllZGY3MjYyMGE3L2xpYi9yc3ZwL2FzYXAuanNcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZG9tYWluOyAvLyBUaGUgZG9tYWluIG1vZHVsZSBpcyBleGVjdXRlZCBvbiBkZW1hbmRcbnZhciBoYXNTZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCI7XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBtZWFucyBwb3NzaWJsZSB0byBleGVjdXRlIGEgdGFzayBpbiBpdHMgb3duIHR1cm4sIHdpdGhcbi8vIHByaW9yaXR5IG92ZXIgb3RoZXIgZXZlbnRzIGluY2x1ZGluZyBuZXR3b3JrIElPIGV2ZW50cyBpbiBOb2RlLmpzLlxuLy9cbi8vIEFuIGV4Y2VwdGlvbiB0aHJvd24gYnkgYSB0YXNrIHdpbGwgcGVybWFuZW50bHkgaW50ZXJydXB0IHRoZSBwcm9jZXNzaW5nIG9mXG4vLyBzdWJzZXF1ZW50IHRhc2tzLiBUaGUgaGlnaGVyIGxldmVsIGBhc2FwYCBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgaWYgYW5cbi8vIGV4Y2VwdGlvbiBpcyB0aHJvd24gYnkgYSB0YXNrLCB0aGF0IHRoZSB0YXNrIHF1ZXVlIHdpbGwgY29udGludWUgZmx1c2hpbmcgYXNcbi8vIHNvb24gYXMgcG9zc2libGUsIGJ1dCBpZiB5b3UgdXNlIGByYXdBc2FwYCBkaXJlY3RseSwgeW91IGFyZSByZXNwb25zaWJsZSB0b1xuLy8gZWl0aGVyIGVuc3VyZSB0aGF0IG5vIGV4Y2VwdGlvbnMgYXJlIHRocm93biBmcm9tIHlvdXIgdGFzaywgb3IgdG8gbWFudWFsbHlcbi8vIGNhbGwgYHJhd0FzYXAucmVxdWVzdEZsdXNoYCBpZiBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxubW9kdWxlLmV4cG9ydHMgPSByYXdBc2FwO1xuZnVuY3Rpb24gcmF3QXNhcCh0YXNrKSB7XG4gICAgaWYgKCFxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQXZvaWRzIGEgZnVuY3Rpb24gY2FsbFxuICAgIHF1ZXVlW3F1ZXVlLmxlbmd0aF0gPSB0YXNrO1xufVxuXG52YXIgcXVldWUgPSBbXTtcbi8vIE9uY2UgYSBmbHVzaCBoYXMgYmVlbiByZXF1ZXN0ZWQsIG5vIGZ1cnRoZXIgY2FsbHMgdG8gYHJlcXVlc3RGbHVzaGAgYXJlXG4vLyBuZWNlc3NhcnkgdW50aWwgdGhlIG5leHQgYGZsdXNoYCBjb21wbGV0ZXMuXG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbi8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgbmV4dCB0YXNrIHRvIGV4ZWN1dGUgaW4gdGhlIHRhc2sgcXVldWUuIFRoaXMgaXNcbi8vIHByZXNlcnZlZCBiZXR3ZWVuIGNhbGxzIHRvIGBmbHVzaGAgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBpZlxuLy8gYSB0YXNrIHRocm93cyBhbiBleGNlcHRpb24uXG52YXIgaW5kZXggPSAwO1xuLy8gSWYgYSB0YXNrIHNjaGVkdWxlcyBhZGRpdGlvbmFsIHRhc2tzIHJlY3Vyc2l2ZWx5LCB0aGUgdGFzayBxdWV1ZSBjYW4gZ3Jvd1xuLy8gdW5ib3VuZGVkLiBUbyBwcmV2ZW50IG1lbW9yeSBleGNhdXN0aW9uLCB0aGUgdGFzayBxdWV1ZSB3aWxsIHBlcmlvZGljYWxseVxuLy8gdHJ1bmNhdGUgYWxyZWFkeS1jb21wbGV0ZWQgdGFza3MuXG52YXIgY2FwYWNpdHkgPSAxMDI0O1xuXG4vLyBUaGUgZmx1c2ggZnVuY3Rpb24gcHJvY2Vzc2VzIGFsbCB0YXNrcyB0aGF0IGhhdmUgYmVlbiBzY2hlZHVsZWQgd2l0aFxuLy8gYHJhd0FzYXBgIHVubGVzcyBhbmQgdW50aWwgb25lIG9mIHRob3NlIHRhc2tzIHRocm93cyBhbiBleGNlcHRpb24uXG4vLyBJZiBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgYGZsdXNoYCBlbnN1cmVzIHRoYXQgaXRzIHN0YXRlIHdpbGwgcmVtYWluXG4vLyBjb25zaXN0ZW50IGFuZCB3aWxsIHJlc3VtZSB3aGVyZSBpdCBsZWZ0IG9mZiB3aGVuIGNhbGxlZCBhZ2Fpbi5cbi8vIEhvd2V2ZXIsIGBmbHVzaGAgZG9lcyBub3QgbWFrZSBhbnkgYXJyYW5nZW1lbnRzIHRvIGJlIGNhbGxlZCBhZ2FpbiBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93bi5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHdoaWxlIChpbmRleCA8IHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICB2YXIgY3VycmVudEluZGV4ID0gaW5kZXg7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIGluZGV4IGJlZm9yZSBjYWxsaW5nIHRoZSB0YXNrLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSB3aWxsXG4gICAgICAgIC8vIGJlZ2luIGZsdXNoaW5nIG9uIHRoZSBuZXh0IHRhc2sgdGhlIHRhc2sgdGhyb3dzIGFuIGVycm9yLlxuICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgcXVldWVbY3VycmVudEluZGV4XS5jYWxsKCk7XG4gICAgICAgIC8vIFByZXZlbnQgbGVha2luZyBtZW1vcnkgZm9yIGxvbmcgY2hhaW5zIG9mIHJlY3Vyc2l2ZSBjYWxscyB0byBgYXNhcGAuXG4gICAgICAgIC8vIElmIHdlIGNhbGwgYGFzYXBgIHdpdGhpbiB0YXNrcyBzY2hlZHVsZWQgYnkgYGFzYXBgLCB0aGUgcXVldWUgd2lsbFxuICAgICAgICAvLyBncm93LCBidXQgdG8gYXZvaWQgYW4gTyhuKSB3YWxrIGZvciBldmVyeSB0YXNrIHdlIGV4ZWN1dGUsIHdlIGRvbid0XG4gICAgICAgIC8vIHNoaWZ0IHRhc2tzIG9mZiB0aGUgcXVldWUgYWZ0ZXIgdGhleSBoYXZlIGJlZW4gZXhlY3V0ZWQuXG4gICAgICAgIC8vIEluc3RlYWQsIHdlIHBlcmlvZGljYWxseSBzaGlmdCAxMDI0IHRhc2tzIG9mZiB0aGUgcXVldWUuXG4gICAgICAgIGlmIChpbmRleCA+IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICAvLyBNYW51YWxseSBzaGlmdCBhbGwgdmFsdWVzIHN0YXJ0aW5nIGF0IHRoZSBpbmRleCBiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9mIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIGZvciAodmFyIHNjYW4gPSAwLCBuZXdMZW5ndGggPSBxdWV1ZS5sZW5ndGggLSBpbmRleDsgc2NhbiA8IG5ld0xlbmd0aDsgc2NhbisrKSB7XG4gICAgICAgICAgICAgICAgcXVldWVbc2Nhbl0gPSBxdWV1ZVtzY2FuICsgaW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcXVldWUubGVuZ3RoIC09IGluZGV4O1xuICAgICAgICAgICAgaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgaW5kZXggPSAwO1xuICAgIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbnJhd0FzYXAucmVxdWVzdEZsdXNoID0gcmVxdWVzdEZsdXNoO1xuZnVuY3Rpb24gcmVxdWVzdEZsdXNoKCkge1xuICAgIC8vIEVuc3VyZSBmbHVzaGluZyBpcyBub3QgYm91bmQgdG8gYW55IGRvbWFpbi5cbiAgICAvLyBJdCBpcyBub3Qgc3VmZmljaWVudCB0byBleGl0IHRoZSBkb21haW4sIGJlY2F1c2UgZG9tYWlucyBleGlzdCBvbiBhIHN0YWNrLlxuICAgIC8vIFRvIGV4ZWN1dGUgY29kZSBvdXRzaWRlIG9mIGFueSBkb21haW4sIHRoZSBmb2xsb3dpbmcgZGFuY2UgaXMgbmVjZXNzYXJ5LlxuICAgIHZhciBwYXJlbnREb21haW4gPSBwcm9jZXNzLmRvbWFpbjtcbiAgICBpZiAocGFyZW50RG9tYWluKSB7XG4gICAgICAgIGlmICghZG9tYWluKSB7XG4gICAgICAgICAgICAvLyBMYXp5IGV4ZWN1dGUgdGhlIGRvbWFpbiBtb2R1bGUuXG4gICAgICAgICAgICAvLyBPbmx5IGVtcGxveWVkIGlmIHRoZSB1c2VyIGVsZWN0cyB0byB1c2UgZG9tYWlucy5cbiAgICAgICAgICAgIGRvbWFpbiA9IHJlcXVpcmUoXCJkb21haW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZG9tYWluLmFjdGl2ZSA9IHByb2Nlc3MuZG9tYWluID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBgc2V0SW1tZWRpYXRlYCBpcyBzbG93ZXIgdGhhdCBgcHJvY2Vzcy5uZXh0VGlja2AsIGJ1dCBgcHJvY2Vzcy5uZXh0VGlja2BcbiAgICAvLyBjYW5ub3QgaGFuZGxlIHJlY3Vyc2lvbi5cbiAgICAvLyBgcmVxdWVzdEZsdXNoYCB3aWxsIG9ubHkgYmUgY2FsbGVkIHJlY3Vyc2l2ZWx5IGZyb20gYGFzYXAuanNgLCB0byByZXN1bWVcbiAgICAvLyBmbHVzaGluZyBhZnRlciBhbiBlcnJvciBpcyB0aHJvd24gaW50byBhIGRvbWFpbi5cbiAgICAvLyBDb252ZW5pZW50bHksIGBzZXRJbW1lZGlhdGVgIHdhcyBpbnRyb2R1Y2VkIGluIHRoZSBzYW1lIHZlcnNpb25cbiAgICAvLyBgcHJvY2Vzcy5uZXh0VGlja2Agc3RhcnRlZCB0aHJvd2luZyByZWN1cnNpb24gZXJyb3JzLlxuICAgIGlmIChmbHVzaGluZyAmJiBoYXNTZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50RG9tYWluKSB7XG4gICAgICAgIGRvbWFpbi5hY3RpdmUgPSBwcm9jZXNzLmRvbWFpbiA9IHBhcmVudERvbWFpbjtcbiAgICB9XG59XG4iLCJ2YXIgQ2xvdWQgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2Nsb3VkJylcbiAgICAuaW5qZWN0KFxuICAgICAgcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9kYXRhY2xvdWQnKSxcbiAgICAgIHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvYXV0aGVudGljYXRlJylcbiAgICApLFxuICBWYWx1ZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZScpLFxuICBEYXRhID0gcmVxdWlyZSgndmlnb3VyLWpzL2RhdGEnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsJyksXG4gIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKSxcbiAgdWEgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci91YScpLFxuICByYWYgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vcmFmJylcblxuLy8gdmFyIHNlbXZlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL3NlbXZlcicpXG5cbnJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZS9mbGFncy9wcm9jZXNzJykgLy8gbXVzdGJlY29tZSBpbmplY3RhYmxlIG9uIG9iamVjdCAoIGFsbCB0aGVzZSBleHRlbnNpb24gc2hvdWxkIGJlIGxvY2F0ZWQgc2VwZXJhdGVseSApXG5cbmZ1bmN0aW9uIHNldENsaWVudEluZm8gKGNsb3VkLCBiYXNlKSB7XG4gIC8vIHRvZG86IG1vdmUgY2xpZW50IHRvIGNsb3VkXG4gIFxuICB2YXIgb2xkY2xpZW50ID0gY2xvdWQuY2xpZW50LmZyb20ucmF3XG4gIHZhciBvYmogPSBvbGRjbGllbnQgXG4gICAgPyB7IFxuICAgICAgICB0aXRsZTogb2xkY2xpZW50LnRpdGxlLFxuICAgICAgICBkZXZpY2U6IG9sZGNsaWVudC5kZXZpY2UsXG4gICAgICAgIGluZm86IG9sZGNsaWVudC5pbmZvXG4gICAgICB9XG4gICAgOiB7fVxuICBmaWx0ZXJFbXB0eShvYmopXG5cbiAgdmFyIGNsaWVudCA9IGNsb3VkLmRhdGEuZ2V0KFsnY2xpZW50cycsIGNsb3VkLmNsaWVudGlkXSksXG4gICAgdGl0bGUsIGRldmljZSwgY2FzdElkXG5cbiAgdmFyIGluZm8gPSBjYXNlcy50b3VjaCBcbiAgICA/IHVhLmRldmljZSArICcgJyArIFxuICAgICAgKCB1YS5wbGF0Zm9ybSA9PT0gJ2lvcycgPyAnaU9TJyA6IHVhLnBsYXRmb3JtICkgK1xuICAgICAgKCB1YS52ZXJzaW9uID8gJyAnICsgdWEudmVyc2lvbiA6ICcnIClcbiAgICA6IHVhLnBsYXRmb3JtICsgJyAnICsgdWEuYnJvd3NlciArICcgJyArIHVhLnZlcnNpb25cblxuICBpZiAoY2FzZXMuJGlzSW9zKSB7XG4gICAgdGl0bGUgPSB1YS5kZXZpY2UgPT09ICdwaG9uZScgPyAnaXBob25lJyA6ICdpcGFkJ1xuICAgIGRldmljZSA9IHVhLmRldmljZVxuICB9IGVsc2Uge1xuICAgIGlmICh1YS5wbGF0Zm9ybSA9PT0gJ2FwcGxldHYnKSB7XG4gICAgICB0aXRsZSA9ICdBcHBsZSBUVidcbiAgICAgIGRldmljZSA9ICdjYXN0J1xuICAgIH0gZWxzZSBpZiAoY2FzZXMuJGlzQ2hyb21lY2FzdCkge1xuICAgICAgdGl0bGUgPSAnQ2hyb21lY2FzdCdcbiAgICAgIGRldmljZSA9ICdjYXN0J1xuICAgICAgY2FzdElkID0gd2luZG93LnNlc3Npb25JZFxuICAgIH0gZWxzZSB7XG4gICAgICBkZXZpY2UgPSB1YS5kZXZpY2VcbiAgICAgIHRpdGxlID0gY2FzZXMuJGlzRGVza3RvcCA/IHVhLnBsYXRmb3JtIDogdWEucGxhdGZvcm0gKyAnICcgKyBkZXZpY2VcbiAgICB9XG4gIH1cblxuICB1dGlsLm1lcmdlKCBvYmosIHtcbiAgICB0aXRsZTogdGl0bGUsXG4gICAgZGV2aWNlOiBkZXZpY2UsXG4gICAgaW5mbzogaW5mb1xuICB9LCBmYWxzZSwgZmFsc2UgKVxuXG4gIGlmIChjYXN0SWQpIHtcbiAgICBvYmouY2FzdElkID0gY2FzdElkIHx8IGZhbHNlXG4gIH1cblxuICAvLyBjbGllbnQubWVyZ2Uob2JqLCBmYWxzZSwgZmFsc2UpXG4gIGNsaWVudC52YWwgPSBvYmpcbiAgY2xvdWQuY2xpZW50LnZhbCA9IGNsaWVudFxuXG4gIC8vIERFQlVHIExPR1M6IFxuICAvLyBjbG91ZC5jbGllbnQub24oZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSl7XG4gIC8vICAgLy8gY29uc29sZS5sb2coJ1xcblxcblxcblxcbnVwZGF0ZSBrZW5rZXInLCB2YWwsIGZyb20pXG4gIC8vICAgdmFyIG9yaWdpbiA9IGZyb20gfHwgdGhpcy5fdXBkYXRlT3JpZ2luXG4gIC8vICAgaWYodmFsICYmIHZhbC50b2tlbiB8fCAob3JpZ2luICYmIG9yaWdpbi5fbmFtZSA9PT0gJ3Rva2VuJykpIHtcbiAgLy8gICAgIGNvbnNvbGUuZXJyb3IoJ1RPS0VOU0VUVE9LRU5TRVRUT0tFTlNFVCcsIHZhbCAmJiAodmFsLnRva2VuIHx8IHZhbCkgKVxuICAvLyAgIH1cbiAgLy8gfSlcblxuICAvLyB1c2VyLmNsaWVudFVzZXJUb2tlbiA9IHVzZXIuY2xpZW50LmZyb20uZ2V0KCd1c2VyVG9rZW4nKSBkZXplIGlzIGR1aWRlbGlqayBmdWNrZWQgdXAgYW5kIGhhcyB0byBiZSBmaXhlZFxufVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKCByZXF1aXJlKCcuL3ZhbHVlcycpLCBmdW5jdGlvbiAoYmFzZSkge1xuICB2YXIgX2Nsb3VkID0gbmV3IENsb3VkKG5ldyBWYWx1ZSgpKVxuICAgICwgX2ZpcnN0IC8vPSB0cnVlXG4gIFxuICBjYXNlcy4kaXNDb25uZWN0ZWQgPSBuZXcgVmFsdWUoIF9jbG91ZC5jb25uZWN0ZWQgKVxuXG4gIC8vIHRvZG86IG1vdmUgdG8gY2xvdWRcbiAgX2Nsb3VkLmNsaWVudCA9IG5ldyBWYWx1ZSgpXG5cbiAgX2Nsb3VkLm9uY2UoJ3dlbGNvbWUnLCBmdW5jdGlvbiAoaWQpIHtcbiAgICBzZXRDbGllbnRJbmZvKF9jbG91ZCwgYmFzZSlcbiAgfSlcblxuICAvLyBfY2xvdWQub24oJ3JlY29ubmVjdCcsKVxuICAvLyBjb25zb2xlLmVycm9yKCc+Pj4gYWRkaW5nIHJlY29ubmVjdCBsaXN0ZW5lcicpXG4gIF9jbG91ZC5vbigncmVjb25uZWN0JywgZnVuY3Rpb24oKSB7XG4gICAgLy8gY29uc29sZS5sb2coJz4+Pj4gcmVjb25uZWN0IHNldCB1cCByZXNldCBjbGllbnQgaW5mbyEnLCBfY2xvdWQuY2xpZW50LmZyb20ucmF3KVxuICAgIHZhciBzZXRPYmogPSB7fVxuICAgIF9jbG91ZC5jbGllbnQuZnJvbS5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgIGlmKGkgIT09ICdrZXknICYmIGkgIT09ICd0eXBlJyAmJiBpICE9PSAnaXAnKXtcbiAgICAgICAgc2V0T2JqW2ldID0gdGhpcy5fdmFsXG4gICAgICB9XG4gICAgfSlcbiAgICBfY2xvdWQuY2xpZW50LmZyb20ub24oJ3JlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYoT2JqZWN0LmtleXMoc2V0T2JqKS5sZW5ndGgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Jlc2V0IGRhdCBjbGllbnQgaW5mbycsIHNldE9iailcbiAgICAgICAgX2Nsb3VkLmRhdGEuY2xpZW50cy5zZXQoX2Nsb3VkLmNsaWVudGlkLCBzZXRPYmopXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBiYXNlLmRlZmluZSh7XG4gICAgY2xvdWQ6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX2Nsb3VkXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIGlmICh1dGlsLmlzT2JqKHZhbCkpIHtcbiAgICAgICAgICBpZiAodmFsLmZhc3RMb2dpbikge1xuICAgICAgICAgICAgX2Nsb3VkLmZhc3RMb2dpbi52YWwgPSB0cnVlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbC5hcGkpIHtcbiAgICAgICAgICAgIF9jbG91ZC5hcGkudmFsID0gdmFsLmFwaVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh2YWwudXJsKSB7XG4gICAgICAgICAgICBfY2xvdWQudXJsLnZhbCA9IHZhbC51cmxcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2Nsb3VkLnVybC52YWwgPSB2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICB2YXIgX3ZlcnNpb24gPSBuZXcgRGF0YSggX2Nsb3VkLmRhdGEuZ2V0KCdhcHAnKSwgeyBzdWJzY3JpcHRpb246IHsgJDp0cnVlIH0gfSApXG5cbiAgLy9zZW12YXIgLS0gQVBQIFZFUlNJT04gRE9FUyBOT1QgV09SSyFcbiAgYmFzZS52ZXJzaW9uRGF0YSA9IG5ldyBWYWx1ZSh7XG4gICAgdmFsOiBfdmVyc2lvbixcbiAgICBkZWZlcjogZnVuY3Rpb24odXBkYXRlLCBhcmdzKSB7XG4gICAgICB2YXIgZG9VcGRhdGVcbiAgICAgIHZhciB0XG4gICAgICBpZih0aGlzLmZyb20udmVyc2lvbikge1xuICAgICAgICBjb25zb2xlLmxvZygnaGV5IGhleSBoZXknKVxuICAgICAgICBpZiggIXdpbmRvdy5wYWNrYWdlICkgXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCAnbm8gd2luZG93IHBhY2thZ2UnLCB3aW5kb3cucGFja2FnZSApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuZXd2ZXJzaW9uID0gdGhpcy5mcm9tLnZlcnNpb24udmFsXG4gICAgICAgICAgICAsIG9sZHZlcnNpb24gPSB3aW5kb3cucGFja2FnZS52ZXJzaW9uXG5cbiAgICAgICAgICBpZihuZXd2ZXJzaW9uICYmIG9sZHZlcnNpb24pIHtcbiAgICAgICAgICAgIG5ld3ZlcnNpb24gPSBuZXd2ZXJzaW9uLnNwbGl0KCcuJylcbiAgICAgICAgICAgIG9sZHZlcnNpb24gPSBvbGR2ZXJzaW9uLnNwbGl0KCcuJylcbiAgICAgICAgICAgIG5ld3ZlcnNpb24gPSBOdW1iZXIobmV3dmVyc2lvblsxXSlcbiAgICAgICAgICAgIG9sZHZlcnNpb24gPSBOdW1iZXIoKG9sZHZlcnNpb25bMV18fDApKVxuICAgICAgICAgICAgaWYoIG5ld3ZlcnNpb24gPiBvbGR2ZXJzaW9uICkge1xuICAgICAgICAgICAgICBkb1VwZGF0ZSA9IHRydWVcbiAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgd2luZG93LnBhY2thZ2UudmVyc2lvbiA9IHRoaXMuZnJvbS52ZXJzaW9uLnZhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBcbiAgICAgIHVwZGF0ZSggZG9VcGRhdGUgPyB2b2lkIDAgOiB0cnVlIClcbiAgICB9XG4gIH0pXG5cbn0pXG5cblxuZnVuY3Rpb24gZmlsdGVyRW1wdHkob2JqKSB7XG4gIGZvcih2YXIgZiBpbiBvYmopIHtcbiAgICBpZihvYmpbZl0gPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIG9ialtmXVxuICAgIH1cbiAgfVxufVxuIiwidmFyIFZhbHVlID0gcmVxdWlyZSgnLi4vdmFsdWUnKVxuICAsIENsb3VkRGF0YSA9IHJlcXVpcmUoICcuLi9icm93c2VyL25ldHdvcmsvY2xvdWQvZGF0YScgKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCB2T2JqID0gcmVxdWlyZSgnLi4vb2JqZWN0JylcblxuXG51dGlsLmRlZmluZVxuKCBDbG91ZERhdGFcbiwgJ19jb250ZW50UGF0aCdcbiwgeyBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHAgPSB0aGlzLl9wYXRoXG4gICAgICBmb3IodmFyIGkgaW4gcCApIHtcbiAgICAgICAgaWYoIHBbaV0gPT09ICdzaG93cycgfHwgcFtpXSA9PT0gJ2NoYW5uZWxzJyApIHtcbiAgICAgICAgICByZXR1cm4gcC5zbGljZSggaSApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc29sZS5lcnJvcignX2NvbnRlbnRQYXRoIHVzZWQgb24gbm9uLWNvbnRlbnQgZGF0YScsIHRoaXMsIHApXG4gICAgICAvLyB0aHJvdyBuZXcgRXJyb3IoJ19jb250ZW50UGF0aCB1c2VkIG9uIG5vbi1jb250ZW50IGRhdGEnKVxuICAgICAgLy8gcmV0dXJuIHRoaXMuX3BhdGguc2xpY2UoIGJhc2UuaW5zdGFuY2VzWzBdLmRhdGEuZnJvbS5fcGF0aC5sZW5ndGggKVxuICAgIH1cbiAgfVxuKVxuXG51dGlsLmRlZmluZShcbiAgdk9ialxuLCAnX2NvbnRlbnRUeXBlJ1xuLCB7IGdldDpmdW5jdGlvbigpIHtcbiAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tXG4gICAgICBpZiggZnJvbS5jbG91ZCAmJiBmcm9tLl9wYXJlbnQgKSByZXR1cm4gZnJvbS5fcGFyZW50Ll9uYW1lXG4gICAgfVxuICB9XG4pXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoIFxuICByZXF1aXJlKCcuL3ZhbHVlcycpXG4sIHJlcXVpcmUoJy4vY2xvdWQnKVxuLCBmdW5jdGlvbiggYXBwICkge1xuICAgIHZhciBjb250ZW50ID0gYXBwLmNvbnRlbnQgPSBuZXcgVmFsdWUoe30pXG4gICAgLy8gdmFyIGdldCA9IFZhbHVlLnByb3RvdHlwZS5nZXRcbiAgICB1dGlsLmRlZmluZShjb250ZW50LCAnZ2V0JywgZnVuY3Rpb24oKXtcbiAgICAgICAgaWYoIHRoaXMuX3ZhbCAmJiB0aGlzLl92YWwuY2xvdWQgKSB7IFxuICAgICAgICAgIHJldHVybiB0aGlzLl92YWwuZ2V0LmFwcGx5KHRoaXMuX3ZhbCwgYXJndW1lbnRzKSBcbiAgICAgICAgfSBlbHNlIHsgXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCAnYXBwLmNvbnRlbnQgLCBkb250IGhhdmUgY2xvdWQgZGF0YSEnKSBcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgIGFwcC5yZWdpb24ub24ob25DaGFuZ2UpXG4gICAgYXBwLmxhbmd1YWdlLm9uKG9uQ2hhbmdlKVxuXG4gICAgb25DaGFuZ2UoKVxuXG4gICAgZnVuY3Rpb24gb25DaGFuZ2UoKXtcbiAgICAgIHZhciByZWdpb24gPSBhcHAucmVnaW9uLnZhbFxuICAgICAgICAsIGxhbmd1YWdlID0gYXBwLmxhbmd1YWdlLnZhbFxuXG4gICAgICAvL1RPRE86bWFrZSB0aGlzIGNvbmZpZ3VyYWJsZSBpbiB0aGUgYXBwXG4gICAgICBpZihsYW5ndWFnZT09PSdpdCcpIHtcbiAgICAgICAgbGFuZ3VhZ2UgPSAnZW4nXG4gICAgICB9XG5cbiAgICAgIGlmKHJlZ2lvbiAmJiBsYW5ndWFnZSl7XG4gICAgICAgIC8vVE9ETzogbWFrZSBtdHZEYXRhIGNvbmZpZ3VyYWJsZVxuICAgICAgICAvLyBjb250ZW50LnZhbCA9IGFwcC5jbG91ZC5kYXRhLmdldChbJ210dkRhdGEnLCByZWdpb24sIGxhbmd1YWdlXSlcblxuICAgICAgICAvLyBjb250ZW50LnZhbCA9IGFwcC5jbG91ZC5kYXRhXG5cbiAgICAgIH1cbiAgICAgIGNvbnRlbnQudmFsID0gYXBwLmNsb3VkLmRhdGFcbiAgICB9XG4gICAgXG4gIH1cbilcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFxuICogY291bGQgdGhpbmsgb2Ygc29tZXRoaW5nIHNvIHN0eWxlIHJlcXVpcmVzIGFyZSBwYXJzZWQgb3B0aW9uYWx5XG4gKiBtYXliZSBpbiB2aWdvdXItanMgdXNlIGR5bmFtaWMgc2NyaXB0IHRhZ3MgYW5kIHBhcnNlIHRob3NlIC93IGdhc3RvbiBpZiB5b3UgYXJlIHVzaW5nIGdhc3RvblxuICogdGhpcyB3aWxsIG1ha2UgaXQgbW9yZSB1c2FibGUgZm9yIG90aGVycyBpbiB0aGUgZnV0dXJlIGFuZCBtYWtlcyBpdCBjb21wYXRpYmxlIHdpdGggcHVyZSBicm93c2VyaWZ5XG4gKi9cblxucmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcbnJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9lYXNpbmcnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4vdWkvZWxlbWVudCcpXG4gICwgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG4gICwgYW5pbWF0aW9uID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uJylcbiAgLCBldmVudHMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvYWR2YW5jZWQnKVxuICAsIHVhID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvdWEnKVxuICAsIHJhZiA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9yYWYnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbCcpXG4gICwgYXBwXG4gICwgX2lvcyA9IHVhLnBsYXRmb3JtPT09J2lvcydcbiAgLCBfd2luZG93cyA9IHVhLnBsYXRmb3JtID09PSAnd2luZG93cydcbiAgLCBhcnIgPSBbJ3Bob25lJywndGFibGV0JywndHYnLCdkZXNrdG9wJywnaW9zJywnYW5kcm9pZCcsJ3dpbmRvd3MnLCdtYWMnLCckaGFzVG91Y2gnLCdzbG93JywnY2hyb21lY2FzdCddIC8vbWF5YmUgbWFrZSB0aGlzIGNvbmZpZ3JhYmxlXG4gIC8vdWkvY2FzZXMgLS1cbiAgLCBpID0gYXJyLmxlbmd0aCAtIDFcblxuLy9oaWVyIHByb2Nlc3MgaW4gcmVxdWlyZW4gZW4gYWRkZWQgJ2FwcFN0YXJ0JyBvZnpvaWV0cyBkZXJnZWxpamtzXG4vL2FkZCBvb2sgcHJvY2VzcyBhYW4gYmFzZSBkaW5nZW4gZGFuIHdvcmQgaWV0cyBwYXMgZ2VhZGQgbmEgZWVuIGJlcGFhbGRlIHByb2Nlc3MgdXBkYXRlXG4vL3VsdHJhIG1vZm8gcG93ZXJmdWxsXG5cbmNhc2VzLiRpc0lvc0Jyb3dzZXIgPSBfaW9zICYmICggJ3N0YW5kYWxvbmUnIGluIG5hdmlnYXRvciAmJiAhbmF2aWdhdG9yLnN0YW5kYWxvbmUgKVxuY2FzZXMuJGlzSW9zRnVsbCA9ICghY2FzZXMuJGlzSW9zQnJvd3NlciYmX2lvcykgfHwgKChfaW9zIHx8IF93aW5kb3dzKSAmJiAhIXdpbmRvdy5jb3Jkb3ZhKSB8fCBmYWxzZVxuY2FzZXMuJGlzUmV0aW5hID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxXG5jYXNlcy4kaXNTbG93ID0gKF93aW5kb3dzICYmIHVhLmRldmljZSA9PT0gJ3Bob25lJykgfHwgKHVhLm5vUmFmJiZ1YS5oYXNUcmFuc2l0aW9uKSB8fCBfaW9zICYmICh3aW5kb3cuc2NyZWVuLmhlaWdodCA9PT0gKDk2MCAvIDIpKSB8fCB1YS5kZXZpY2UgPT09ICd0didcbmNhc2VzLiRpc05hdGl2ZSA9IHdpbmRvdy5jb3Jkb3ZhID8gdHJ1ZSA6IGZhbHNlXG5jYXNlcy4kaXNXaW5kb3dzTW9iaWxlID0gdWEucGxhdGZvcm0gPT09ICd3aW5kb3dzJyAmJiB1YS5kZXZpY2UgPT09ICdwaG9uZScgJiYgISF3aW5kb3cuY29yZG92YVxuY2FzZXMuJGlzUGhvbmVCcm93c2VyID0gdWEuZGV2aWNlID09PSAncGhvbmUnICYmICEoIGNhc2VzLiRpc05hdGl2ZSB8fCBjYXNlcy4kaXNJb3NGdWxsIClcbi8vcGFja2VyIGNhc2Ugdm9vciB3ZWIgLy8gbmF0aXZlXG5cbmFwcCA9IG1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICAneCx5Jzp7dmFsOjAsY2xlYW46dHJ1ZSx0cmFuc2xhdGU6dHJ1ZX1cbiwgbm9kZTogZG9jdW1lbnQuYm9keVxuLCB3OiB3aW5kb3cuaW5uZXJXaWR0aFxuLCBoOiB3aW5kb3cuaW5uZXJIZWlnaHRcbiwgY3NzOiAnYXBwJ1xufSlcblxuLy9pZihjYXNlcy4kaXNpb3NGdWxsKSB7XG4gIC8vIGFwcC55ID0ge2FkZDoyMH1cbiAgLy8gYXBwLmggPSB7c3ViOjIwfVxuLy99XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuLy8gICBjb25zb2xlLmxvZygncmVzaXplISEnLCd3Oicsd2luZG93LmlubmVyV2lkdGgsJ2g6Jyx3aW5kb3cuaW5uZXJIZWlnaHQsJ2Jsb2NrPzonLGFwcC5ibG9ja1Jlc2l6ZSlcbiAgaWYoIWFwcC5ibG9ja1Jlc2l6ZSkge1xuICAgIC8vIGFuaW1hdGlvbi5wcmV2ZW50ID0gdHJ1ZVxuICAgIGFwcC53LnZhbCA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgYXBwLmgudmFsID0gd2luZG93LmlubmVySGVpZ2h0XG4gICAgLy8gYW5pbWF0aW9uLnByZXZlbnQgPSBmYWxzZVxuICB9IGVsc2Uge1xuICAgIGFwcC5ibG9ja1Jlc2l6ZSA9IGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdENhc2Uoc3RyKSB7XG4gIGlmKHN0ciAhPT0gJyRoYXNUb3VjaCcpe1xuICAgIHZhciBjc3NTdHIgPSAgJ3MnICsgc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xuICAgIHZhciBjYXNlU3RyID0gJyRpJyArIGNzc1N0clxuICAgIGlmKGNhc2VzW2Nhc2VTdHJdPT09dm9pZCAwKSB7XG4gICAgICBjYXNlc1tjYXNlU3RyXSA9ICh1YS5kZXZpY2UgPT09IHN0ciB8fCB1YS5wbGF0Zm9ybSA9PT0gc3RyKSA/IHRydWUgOiBmYWxzZVxuICAgIH1cbiAgICBhcHAuY3NzID0ge2FkZENsYXNzOmNhc2VzW2Nhc2VTdHJdID8gJ2knICsgY3NzU3RyIDogJ25vdEknKyBjc3NTdHJ9XG4gIH1lbHNle1xuICAgIGFwcC5jc3MgPSB7YWRkQ2xhc3M6Y2FzZXMuJGhhc1RvdWNoID8gJ2hhc1RvdWNoJyA6ICdub3RIYXNUb3VjaCd9XG4gIH1cbn1cblxuLy8gbGlzdGVuZXIgPSBldmVudFV0aWxzLnRocm90dGxlKGxpc3RlbmVyLDYwKVxuLy8gbGlzdGVuZXIgPVxuLy8gY2FzZXMuJGlzbm9DYWxjID0gIXV0aWwuaGFzQ2FsYygpXG4vL2Nhc2UgdG9vIHNlZSBpZiBhcHAgaXMgcnVubmluZyBpbiBhIGJyb3dzZXIgb24gaW9zIChsaW1pdHMgdmlkZW8gY2FwYWJpbGl0aWVzKVxuXG5pZihjYXNlcy4kaXN0b3VjaCkgZXZlbnRzLmRvY3VtZW50LmFkZEV2ZW50KCdtb3ZlJyxmdW5jdGlvbihlKSB7XG4gIGlmKCFldmVudHMuX21heWJlc2Nyb2xsICYmICFldmVudHMuX3NldHNjcm9sbCkgZS5wcmV2ZW50RGVmYXVsdCgpXG59LCdhcHAnKVxuXG5pZignb3JpZW50YXRpb24nIGluIHdpbmRvdykgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ29yaWVudGF0aW9uY2hhbmdlJyxsaXN0ZW5lcilcbmlmKCFfaW9zKSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJyxsaXN0ZW5lcilcblxuLy9hZGRpbmcgIzxjYXNlPiBpbiB1cmwgZm9yY2VzIGNhc2UsIG11bHRpcGxlIGhhc2hlcyA9PT4gbXVsdGlwbGUgY2FzZXNcbi8vdGhpcyBpcyBmb3IgdGVzdGluZyBwdXJwb3NlcyAsIGFkZCBkZXZlbG9wbWVudCBpbmRlbnRpZmllciBmb3IgY29tcGlsZXJcblxuLy90aGlzIGhhcyB0byBnb1xuaWYod2luZG93LmxvY2F0aW9uLmhhc2gpIHtcbiAgdmFyIGhhc2hDYXNlcyA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnNwbGl0KCcjJylbMV1cbiAgICAsIHggPSBoYXNoQ2FzZXMuc3BsaXQoJywnKVxuXG4gIGZvcih2YXIgaiBpbiB4KSB7XG4gICAgdmFyIHkgPSB4W2pdLnNwbGl0KCc9JylcbiAgICB1YVt5WzBdXSA9IHlbMV1cbiAgfVxuICBcbn1cblxuaWYodWEuZGV2aWNlID09PSAndHYnKSB7XG4gIGNhc2VzLiRpc1Nsb3cgPSB0cnVlXG59XG5cbmZvcig7aSA+PSAwOykgZGVmYXVsdENhc2UoYXJyW2ktLV0pXG5cblxuXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi4vLi4vLi4vYnJvd3Nlci9lbGVtZW50JylcblxucmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUvZmxhZ3MvcGFyZW50JylcbnJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlL2ZsYWdzL3NlbGYnKVxucmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG5yZXF1aXJlKCcuLi8uLi8uLi92YWx1ZS9mbGFncy91dGlsJylcbnJlcXVpcmUoJy4uLy4uLy4uL2Jyb3dzZXIvZXZlbnRzJylcblxubW9kdWxlLmV4cG9ydHMgPVxuICBFbGVtZW50XG4gIC5pbmplY3RcbiAgKCByZXF1aXJlKCcuLi8uLi8uLi9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9jb2xsZWN0aW9uJylcbiAgLCByZXF1aXJlKCcuLi8uLi8uLi9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcycpXG4gICwgcmVxdWlyZSgnLi4vLi4vLi4vYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvc2Nyb2xsYmFyJylcbiAgLCByZXF1aXJlKCcuLi8uLi8uLi9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9wcm9jZXNzJylcbiAgLCByZXF1aXJlKCcuLi8uLi8uLi92YWx1ZS9vbicpXG4gIClcblxuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi9lbGVtZW50JylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vYnJvd3Nlci9ldmVudHMvdXRpbCcpIFxuICAsIHNwcml0ZSA9IG5ldyBFbGVtZW50KHsgXG4gICAgJ3csaCc6NTAsXG4gICAgeDp7dHJhbnNsYXRlOnRydWUsdmFsOjB9XG4gIH0pXG5cbnNwcml0ZS5leHRlbmQoeyBuYW1lOiAncGFyYW1zJyAvL3RoaXMgaGFzIHRvIGNvbWUgZnJvbSB1aSAoZWxlbWVudClcbiAgLCB0eXBlOiBmYWxzZVxuICAsIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgdGhpcy5fcGFyYW1zID0gdmFsXG4gICAgdGhpcy5DbGFzcy5wcm90b3R5cGUuX3BhcmFtcyA9IHZhbCAvL3RlbXA/XG4gIH1cbn0pXG5cbnNwcml0ZS5zZXRTZXR0aW5nKHtcbiAgbmFtZTonc3Bpbm5lcicsXG4gIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IHRoaXNcbiAgICAgICwgcGFyYW1zID0gdGhpcy5fcGFyYW1zIHx8IHt9XG4gICAgICAsIHN0YXJ0ID0gcGFyYW1zLnN0YXJ0IHx8IDBcbiAgICAgICwgc3BlZWQgPSBwYXJhbXMuZnJhbWVzIHx8IDNcbiAgICAgICwgcm93cyA9IHBhcmFtcy5yb3dzIHx8IDFcbiAgICAgICwgY29scyA9IHBhcmFtcy5jb2xzIHx8IDAgLy9pZ25vcmVcbiAgICAgICwgb25jZSA9IHBhcmFtcy5vbmNlXG4gICAgICAsIGNudCA9IHN0YXJ0XG4gICAgICAsIHN0ZXBzID0gKHBhcmFtcy5zdGVwcyB8fCAocm93cypjb2xzLXN0YXJ0KSB8fCAxOSlcbiAgICAgICwgY3VyUm93ID0gMFxuICAgICAgLCBjdXJDb2wgPSAwXG5cbiAgICBpZighdC5kaXNwbGF5IHx8ICF0LmRpc3BsYXkuX2Jhc2U9PT10KSB7XG4gICAgICB0LmRpc3BsYXkgPSB0LmRpc3BsYXkgJiYgdC5kaXNwbGF5LnZhbCB8fCAnYmxvY2snXG4gICAgfVxuICAgIHQuZGlzcGxheS5hZGRMaXN0ZW5lcihbZGlzcGxheUxpc3RlbmVyLHRdLHRydWUpXG5cbiAgICB0Lm5vZGUuc3R5bGUuYmFja2dyb3VuZFNpemUgPSB0aGlzLncudmFsKmNvbHMrJ3B4IGF1dG8nXG4gICAgLy9yZW1lYmVyIHdoZXJlIGl0IHdhcyBwZXJoYXBzIGlmIHJlLXJlbmRlcmVkXG4gICAgaWYodC5kaXNwbGF5LnZhbD09PSdub25lJykgcmV0dXJuXG5cbiAgICB0Ll9zcGlubmVyID0gdXRpbC5pbnRlcnZhbChmdW5jdGlvbigpIHsgLy90ZXN0IGludGVydmFsIGZvciBsZWFrc1xuICAgICAgdC5ub2RlLnN0eWxlLmJhY2tncm91bmRQb3NpdGlvbiA9IFxuICAgICAgICAoLXQudy52YWwqY3VyQ29sKSsncHggJysocm93cyA/ICgtdC5oLnZhbCpjdXJSb3cpIDogMCkrJ3B4J1xuICAgICAgY250KytcbiAgICAgIGlmKGNudCA9PT0gc3RlcHMpIHtcbiAgICAgICAgY250ID0gc3RhcnRcbiAgICAgICAgaWYob25jZSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1hYWFhYJylcbiAgICAgICAgICByZW1vdmVSYWYuY2FsbCh0KVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJSb3cgPSByb3dzID8gfn4oY250L2NvbHMpIDogMFxuICAgICAgY3VyQ29sID0gY250LShjdXJSb3cpKmNvbHNcbiAgICB9LHNwZWVkKVxuICB9LFxuICByZW1vdmU6cmVtb3ZlUmFmXG59KVxuXG5mdW5jdGlvbiByZW1vdmVSYWYoKSB7XG4gICAgIC8vIGFsZXJ0KCdsZXRzIHJlbW92ZSB0aGlzIGJhZGJveScpXG5cbiAgaWYodGhpcy5fc3Bpbm5lcikge1xuICAgIHRoaXMuX3NwaW5uZXIoKVxuICAgIHRoaXMuX3NwaW5uZXIgPSBudWxsXG4gIH1cbn1cblxuZnVuY3Rpb24gZGlzcGxheUxpc3RlbmVyICh2YWwpIHtcbiAgaWYodmFsLnZhbD09PSdub25lJykge1xuICAgIHJlbW92ZVJhZi5jYWxsKHRoaXMpXG4gIH0gZWxzZSB7XG4gICAgaWYoIXRoaXMuX3NwaW5uZXIpIHRoaXMuc2V0dGluZygncmVuZGVyJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNwcml0ZS5DbGFzc1xuXG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cblxudmFyIEJhc2UgPSByZXF1aXJlKCd2aWdvdXItanMvYmFzZScpXG4gICwgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQnKVxuICAsIFZhbHVlID0gcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlJylcbiAgLCBWT2JqZWN0ID0gcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdCcpXG4gICwgc3dpdGNoZXIgPSBuZXcgRWxlbWVudCgpXG4gICwgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG5cbmZ1bmN0aW9uIGV4dGVuZEZhY3RvcnkoIGZpZWxkICl7XG4gIHJldHVybiB7IG5hbWU6ZmllbGRcbiAgLCB0eXBlOmZhbHNlXG4gICwgc2V0OmZ1bmN0aW9uKCBmbiApe1xuICAgICAgaWYoZm4gaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgIHtcbiAgICAgICAgdmFyIHNldCA9IHt9XG4gICAgICAgIHNldFsnXycrZmllbGRdID0gZm5cbiAgICAgICAgdGhpcy5kZWZpbmUoc2V0KVxuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdwcm9wZXJ0eSAnICsgZmllbGQgKyAnIG5lZWRzIHRvIGJlIGEgZnVuY3Rpb24nKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5WYWx1ZS5mbGFncy4kcGFyYW1zID0ge1xuICBzZXQ6ZnVuY3Rpb24oIHZhbCApIHtcbiAgICB0aGlzLnBhcmFtcyA9IHZhbFxuICB9XG59XG5cblZhbHVlLmZsYWdzLiRvcHRpb25zID0ge1xuICBzZXQ6ZnVuY3Rpb24oIHZhbCApIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB2YWxcbiAgfVxufVxuXG5zd2l0Y2hlci5leHRlbmRcbiggeyBsb2FkZXI6e31cbiAgLCBhbmltYXRpb246e31cbiAgLCBkZWxheTp7fVxuICAsIGRvbmU6e31cbiAgLCBmb3JjZTp7fVxuICAsIGJhY2tGYWxsYmFjazpcbiAgICB7IGNhY2hlOmZhbHNlXG4gICAgLy8gLCBzZXQ6ZnVuY3Rpb24oKXt9XG4gICAgfVxuICAsIG9uVHJhbnNpdGlvbjpcbiAgICB7IGNhY2hlOmZhbHNlXG4gICAgLy8gLCBzZXQ6ZnVuY3Rpb24oKXt9XG4gICAgfVxuICAsIHRyYW5zaXRpb246XG4gICAgeyBjYWNoZTpmYWxzZVxuICAgICwgc2V0OmZ1bmN0aW9uKCB2YWwgKXtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2YWwuZWxlbWVudCAmJiB2YWwuZWxlbWVudC5fdmFsXG4gICAgICAgICAgLCBwYXJhbXMgPSB2YWwucGFyYW1zXG4gICAgICAgICAgLCBvcHRpb25zID0gdmFsLm9wdGlvbnMgfHwge31cbiAgICAgICAgICAsIGZvcmNlID0gb3B0aW9ucyAmJiBvcHRpb25zLmZvcmNlXG4gICAgICAgICAgLCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5cbiAgICAgICAgICAsIGxhc3QgPSB0aGlzLl9zd0VsZW0gfHwgY2hpbGRyZW5bMF1cbiAgICAgICAgICAsIGJhc2UgPSBlbGVtZW50ICYmIGVsZW1lbnQuYmFzZVxuICAgICAgICAgICwgY2hpbGRyZW5MZW5ndGggPSBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAsIGN1cnJlbnRcbiAgICAgICAgICAsIGNoaWxkXG4gICAgICAgICAgLCBkaXJlY3Rpb25cbiAgICAgICAgICAsIF90aGlzID0gdGhpc1xuXG4gICAgICAgIC8vaWYgdGhlcmUgYXJlIG9sZCBsb2FkaW5nIGxpc3RlbmVycyByZW1vdmUgdGhlc2VcbiAgICAgICAgaWYoIHRoaXMuX2xvYWRpbmcgKVxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5fbG9hZGluZ1sxXS5yZW1vdmVMaXN0ZW5lciggdGhpcy5fbG9hZGluZ1swXSApXG4gICAgICAgICAgdGhpcy5fbG9hZGluZyA9IHZvaWQgMFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYoIF90aGlzLl90aW1lciApe1xuICAgICAgICAvLyAgIGNsZWFyVGltZW91dCggX3RoaXMuX3RpbWVyIClcbiAgICAgICAgLy8gICBfdGhpcy5fdGltZXIgPSBudWxsXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnb3B0aW9ucz8hJy5ncmVlbi5pbnZlcnNlLG9wdGlvbnMpXG4gICAgICAgIC8vaXMgaXQgdGhlIHNhbWUgLCBpcyBpdCBub3QgdGhlIHNhbWUgd2hhdHVwIVxuICAgICAgICBpZiggYmFzZSAmJiBiYXNlIGluc3RhbmNlb2YgRWxlbWVudCB8fCBlbGVtZW50ID09PSBFbGVtZW50IClcbiAgICAgICAgeyBcbiAgICAgICAgICBpZiggIWZvcmNlICYmIHRoaXMuX3N3RWxlbSAmJiB0aGlzLl9zd0VsZW0gaW5zdGFuY2VvZiBlbGVtZW50IClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLl9zd0VsZW0uc2V0KCBwYXJhbXMgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAge1xuXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSBhcmUgc3RpbGwgb2xkIHBhZ2VzLCByZW1vdmUgdGhlc2VcbiAgICAgICAgICAgIGlmKCBjaGlsZHJlbkxlbmd0aCA+IDEgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBmb3IgKCBpID0gY2hpbGRyZW5MZW5ndGggLSAxOyBpID49IDA7IGktLSApIFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXVxuICAgICAgICAgICAgICAgIGlmKCBjaGlsZCAhPT0gbGFzdCApIGNoaWxkLnJlbW92ZSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGlyZWN0aW9uID0gdGhpcy5fZGlyZWN0aW9uID0gdmFsLmRpcmVjdGlvbiAmJiB2YWwuZGlyZWN0aW9uLl92YWxcbiAgICAgICAgICAgIGlmKCBvcHRpb25zICYmIG9wdGlvbnMubG9hZGVyICYmICFvcHRpb25zLmxvYWRlci4kbG9hZGVkIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYoICF0aGlzLmxvYWRlciApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnbm8gbG9hZGVyIGRlZmluZWQhJyApXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbG9hZGVyID0gbmV3IHRoaXMubG9hZGVyLl92YWwuQ2xhc3MoKVxuXG4gICAgICAgICAgICAgIGlmKCBvcHRpb25zLmxvYWRlciBpbnN0YW5jZW9mIFZPYmplY3QgKSAvL1RPRE86IHRoaXMgaGFzIGdvdHRlbiBWRVJZIGRpcnR5ID4gY2xlYW4gdGhpcyB1cCFcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuZG9uZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICBpZiggIWN1cnJlbnQgKSBjdXJyZW50ID0gbmV3IGVsZW1lbnQoIHBhcmFtcyApXG4gICAgICAgICAgICAgICAgICBpZiggbG9hZGVyLl9yZW1vdmUgKVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRvbmUgPSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWxheSA9IGNhc2VzLnRhYmxldCA/IDQwMCA6IDIwMCAvL2RpdCBpcyBuYXR1dXJsaWprIGFic3VyZFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoIF90aGlzLl9zd0VsZW0gaW5zdGFuY2VvZiBlbGVtZW50IClcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9zd0VsZW0uc2V0KCBwYXJhbXMgKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uVHJhbnNpdGlvbi5fdmFsLmNhbGwoIF90aGlzLCBjdXJyZW50LCBfdGhpcy5fc3dFbGVtICwgMCwgb3B0aW9ucyApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kZWxheSA9IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gb3B0aW9ucy5sb2FkZXIuX3BhdGhcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gWyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmKCBfdGhpcy5fdGltZXIgKXtcbiAgICAgICAgICAgICAgICAgIC8vICAgY2xlYXJUaW1lb3V0KCBfdGhpcy5fdGltZXIgKVxuICAgICAgICAgICAgICAgICAgLy8gICBfdGhpcy5fdGltZXIgPSBudWxsXG4gICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICBsb2FkZXIuX3JlbW92ZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgIGlmKCBjdXJyZW50ICYmIG9wdGlvbnMuZG9uZSApIG9wdGlvbnMuZG9uZSgpXG5cbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zLmxvYWRlciBdXG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnYWRkIHRoZSBsaXN0ZW5lciBmb3InLHBhdGgpXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGluZ1sxXS5pcygnbG9hZGVkJywgdGhpcy5fbG9hZGluZ1swXSApXG4gICAgICAgICAgICAgICAgLy8gX3RoaXMuX3RpbWVyID0gc2V0VGltZW91dCggdGhpcy5fbG9hZGluZ1swXSwgNTAwMCApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kb25lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgIGlmKCAhY3VycmVudCApIGN1cnJlbnQgPSBuZXcgZWxlbWVudCggcGFyYW1zIClcblxuICAgICAgICAgICAgICAgICAgb3B0aW9ucy5kb25lID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLmRlbGF5ID0gMjAwXG5cbiAgICAgICAgICAgICAgICAgIGlmKCBfdGhpcy5fc3dFbGVtIGluc3RhbmNlb2YgZWxlbWVudCApXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9zd0VsZW0uc2V0KCBwYXJhbXMgKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vblRyYW5zaXRpb24uX3ZhbC5jYWxsKCBfdGhpcywgY3VycmVudCwgX3RoaXMuX3N3RWxlbSAsIDAsIG9wdGlvbnMgKVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLmRlbGF5ID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb3B0aW9ucy5sb2FkZXIgPSB2b2lkIDBcblxuICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbi5fdmFsLmNhbGwoIHRoaXMsIGxvYWRlciwgbGFzdCwgZGlyZWN0aW9uLCBvcHRpb25zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjdXJyZW50ID0gbmV3IGVsZW1lbnQocGFyYW1zKVxuICAgICAgICAgICAgICBvcHRpb25zLmRvbmUgPSB2b2lkIDBcbiAgICAgICAgICAgICAgb3B0aW9ucy5kZWxheSA9IHZvaWQgMFxuICAgICAgICAgICAgICBvcHRpb25zLmxvYWRlciA9IHZvaWQgMFxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb24uX3ZhbC5jYWxsKCB0aGlzLCBjdXJyZW50LCBsYXN0ICwgZGlyZWN0aW9uLCBvcHRpb25zIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIG9wdGlvbnMuYW5pbWF0aW9uICE9PSB2b2lkIDAgKSBvcHRpb25zLmFuaW1hdGlvbiA9IHZvaWQgMFxuICAgICAgICAgICAgaWYoIG9wdGlvbnMuZGVsYXkgKSBvcHRpb25zLmRlbGF5ID0gdm9pZCAwXG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihwYXJhbXMpXG4gICAgICAgIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdvbmx5IHBhcmFtcyBkZWZpbmVkIScsIHBhcmFtcylcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHBhcmFtcylcbiAgICAgICAge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ25vIHBhcmFtcyBhbmQgbm8gZWxlbWVudCBkZWZpbmVkIScpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbilcblxuc3dpdGNoZXIuZGVmaW5lXG4oeyBiYWNrOmZ1bmN0aW9uKCl7IC8vcmVtb3ZlIGJhY2sgbG9naWMgZnJvbSBzd2l0Y2hlciAoeW91IGNhbid0IGlzb2xhdGUgaXQhIGllIHdoZW4geW91IGxhbmQgb24gcGFnZSwgd2hhdCBpcyBiYWNrPylcbiAgICAgIHRoaXMuYmFja0ZhbGxiYWNrLl92YWwuY2FsbCggdGhpcyApXG5cdFx0fVxuICAsIGFkZDpmdW5jdGlvbiggZWxlbWVudCwgcHJldmlvdXMgKXtcbiAgICAgIGNvbnNvbGUubG9nKCdhZGQtLS0+JyxlbGVtZW50KVxuICAgICAgdGhpcy5fc3dFbGVtID0gZWxlbWVudFxuXG4gICAgICAvLyB0cnlcbiAgICAgIC8vIHtcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUuYWRkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgLy8gfVxuICAgICAgLy8gY2F0Y2goZXJyKVxuICAgICAgLy8ge1xuICAgICAgLy8gICBjb25zb2xlLmVycm9yKCdlcnJvciBhZGRpbmcgdGhlIG5ldyBlbGVtZW50JyxlcnIsYXJndW1lbnRzKVxuICAgICAgLy8gfVxuICAgIH1cblx0fVxuKVxuXG5zd2l0Y2hlci5leHRlbmRcbiggeyBuYW1lOidvbidcbiAgLCBzZXQ6ZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgIC8vIHNldCBoaXN0b3J5IHZhcmlhYmxlIGZvciBhbGxcbiAgICAgIC8vIHZhbC5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgICAvLyAgIHZhciBmcm9tID0gdGhpcy4kdXNlck9yaWdpbi52YWxcbiAgICAgIC8vICAgaWYoIWZyb20pIHJldHVyblxuICAgICAgLy8gICBpZighZnJvbS5faGlzdG9yeSkgZnJvbS5zZXQoJ2hpc3RvcnknLHRydWUpXG4gICAgICAvLyAgIGlmKCF0aGlzLl9fY2hlY2tlZClcbiAgICAgIC8vICAge1xuICAgICAgLy8gICAgIHRoaXMub24oZnVuY3Rpb24oKXtcbiAgICAgIC8vICAgICAgIHZhciBjYWxsZXIgPSB0aGlzLl9wYXJlbnQuX2NhbGxlclxuICAgICAgICAgICAgXG4gICAgICAvLyAgICAgICBpZighY2FsbGVyLl9iYWNrU3RvcmUpXG4gICAgICAvLyAgICAgICB7IFxuICAgICAgLy8gICAgICAgICBjYWxsZXIuX2JhY2tTdG9yZSA9IFsgdGhpcyBdXG4gICAgICAvLyAgICAgICB9XG4gICAgICAvLyAgICAgICBlbHNlIGlmKGNhbGxlci5fZGlyZWN0aW9uID09PSAtMSlcbiAgICAgIC8vICAgICAgIHtcbiAgICAgIC8vICAgICAgICAgaWYoY2FsbGVyLl9iYWNrU3RvcmVbMV0gIT09IHZvaWQgMCkgY2FsbGVyLl9iYWNrU3RvcmUuc2hpZnQoKVxuICAgICAgLy8gICAgICAgICBlbHNlIGNhbGxlci5fYmFja1N0b3JlID0gWyB0aGlzIF1cbiAgICAgIC8vICAgICAgIH1cbiAgICAgIC8vICAgICAgIGVsc2UgaWYoY2FsbGVyLl9kaXJlY3Rpb24gPT09IDEpXG4gICAgICAvLyAgICAgICB7XG4gICAgICAvLyAgICAgICAgIGNhbGxlci5fYmFja1N0b3JlLnVuc2hpZnQoIHRoaXMgKVxuICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAvLyAgICAgfSlcbiAgICAgIC8vICAgICB0aGlzLl9fY2hlY2tlZCA9IHRydWVcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSlcbiAgICB9XG4gICwgcmVtb3ZlOmZ1bmN0aW9uKCl7IC8vIGNyZWF0ZSByZWZzIHRvIG9yaWdpbmFsXG4gICAgICBpZiggdGhpcy5fbG9hZGluZyApXG4gICAgICB7XG4gICAgICAgIHRoaXMuX2xvYWRpbmdbMV0ucmVtb3ZlTGlzdGVuZXIodGhpcy5fbG9hZGluZ1swXSlcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IG51bGxcbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYoIHRoaXMuX3N3VGltZXIgKSBjbGVhclRpbWVvdXQoIHRoaXMuX3N3VGltZXIgKVxuICAgICAgaWYoIHRoaXMuX3RpbWVyICkgY2xlYXJUaW1lb3V0KCB0aGlzLl90aW1lciApXG5cbiAgICAgIGlmKCB0aGlzLm9uLiRyZW1vdmUgKSB0aGlzLm9uLiRyZW1vdmUudXBkYXRlKClcbiAgICB9XG4gICwgbmV3OmZ1bmN0aW9uKCl7XG4gICAgICBpZiggdGhpcy5vbi4kbmV3ICkgdGhpcy5vbi4kbmV3LnVwZGF0ZSgpXG4gICAgfVxuICB9XG4pXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IHN3aXRjaGVyLkNsYXNzKCkuQ2xhc3MiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE1LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpLFxuICBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJyksXG4gIHV0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbCcpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZnVuY3Rpb24oYmFzZSkge1xuICBiYXNlLnNldCh7XG4gICAgb25UcmFuc2l0aW9uOiB7XG4gICAgICBkZWZlcjogZnVuY3Rpb24odXBkYXRlKSB7IC8vb2JzY3VyZSB0cmFuc2Zvcm1cbiAgICAgICAgaWYgKGV4cG9ydHNbdGhpcy5fdmFsXSkgdGhpcy5fdmFsID0gZXhwb3J0c1t0aGlzLl92YWxdXG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9KVxufSlcblxuLy9zbGlkZSB0cmFuc2l0aW9uXG5leHBvcnRzLnNsaWRlID0gZnVuY3Rpb24oY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gIGlmIChkaXJlY3Rpb24gJiYgbGFzdCkgYW5pbWF0ZSh0aGlzLCBjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24sIG9wdGlvbnMpXG4gIGVsc2UgYmFzaWModGhpcywgY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uLCBvcHRpb25zKVxufVxuXG4vL2ZhZGUgdHJhbnNpdGlvblxuZXhwb3J0cy5mYWRlID0gZnVuY3Rpb24oY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gIGJhc2ljKHRoaXMsIGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbiwgb3B0aW9ucylcbn1cblxuLy9iYXNpYyB0cmFuc2l0aW9uXG5mdW5jdGlvbiBiYXNpYyhfdGhpcywgY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBkb25lID0gb3B0aW9ucy5kb25lLFxuICAgIG5vQW5pbWF0aW9uID0gb3B0aW9ucy5hbmltYXRpb24gPT09IGZhbHNlLFxuICAgIGRlbGF5ID0gb3B0aW9ucy5kZWxheVxuXG4gIGlmIChsYXN0KSB7XG4gICAgYWRkKF90aGlzLCBjdXJyZW50LCBsYXN0KVxuXG4gICAgaWYgKG5vQW5pbWF0aW9uKSB7XG4gICAgICByZW1vdmUoX3RoaXMsIGxhc3QpXG4gICAgICBhZGQoX3RoaXMsIGN1cnJlbnQpXG5cbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGlmIChkZWxheSkge1xuICAgICAgICAgIHRpbWVyKF90aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRvbmUpIG9wdGlvbnMuZG9uZSgpXG4gICAgICAgICAgfSwgZGVsYXkpXG4gICAgICAgIH0gZWxzZSBkb25lKClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRlbGF5KSB7XG4gICAgICB0aW1lcihfdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGZhZGUoX3RoaXMsIGxhc3QsIG9wdGlvbnMpXG4gICAgICB9LCBkZWxheSlcbiAgICB9IGVsc2UgZmFkZShfdGhpcywgbGFzdCwgb3B0aW9ucylcbiAgfSBlbHNlIGFkZChfdGhpcywgY3VycmVudCwgZmFsc2UsIGRvbmUpXG59XG5cbi8vYW5pbWF0ZWQgdHJhbnNpdGlvblxuZnVuY3Rpb24gYW5pbWF0ZShfdGhpcywgY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uLCBvcHRpb25zKSB7XG4gIHZhciBhbmltYXRpb25UaW1lID0gMjAgLy8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZVxuICAgICxcbiAgICBhcHBXaWR0aCA9IGFwcC53LnZhbCxcbiAgICBjdXJyZW50U3RhcnQsIGZvcndhcmQgPSBkaXJlY3Rpb24gPT09IDEsXG4gICAgbGFzdEVuZFxuXG4gIGlmIChmb3J3YXJkKSB7XG4gICAgY3VycmVudFN0YXJ0ID0gYXBwV2lkdGhcbiAgICBsYXN0RW5kID0gYXBwV2lkdGggLyAtM1xuICB9IGVsc2Uge1xuICAgIGN1cnJlbnRTdGFydCA9IGFwcFdpZHRoIC8gLTNcbiAgICBsYXN0RW5kID0gYXBwV2lkdGhcbiAgfVxuXG4gIGlmIChjYXNlcy4kaXNXaW5kb3dzKSB7XG4gICAgY3VycmVudC54ID0ge1xuICAgICAgdHJhbnNsYXRlOiB0cnVlLFxuICAgICAgdmFsOiBjdXJyZW50U3RhcnRcbiAgICB9XG5cbiAgICBsYXN0LnggPSB7XG4gICAgICB0cmFuc2xhdGU6IHRydWUsXG4gICAgICB2YWw6IDBcbiAgICB9XG5cbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgY3VycmVudC54ID0gMFxuICAgICAgbGFzdC54ID0gbGFzdEVuZFxuXG4gICAgICB0aW1lcihfdGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZShfdGhpcywgbGFzdCwgb3B0aW9ucy5kb25lKVxuICAgICAgfSwgMjEwKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY3VycmVudC54ID0ge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIHN0YXJ0OiBjdXJyZW50U3RhcnQsXG4gICAgICAgIHRpbWU6IGFuaW1hdGlvblRpbWUsXG4gICAgICAgIGRlbGF5OiAxLFxuICAgICAgICBlYXNpbmc6ICdvdXRDdWJpYycsXG4gICAgICAgIGRvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlbW92ZShfdGhpcywgbGFzdCwgb3B0aW9ucy5kb25lKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmFsOiAwXG4gICAgfVxuXG4gICAgbGFzdC54ID0ge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIHRpbWU6IGFuaW1hdGlvblRpbWUsXG4gICAgICAgIGRlbGF5OiAyLFxuICAgICAgICBlYXNpbmc6ICdvdXRDdWJpYydcbiAgICAgIH0sXG4gICAgICB2YWw6IGxhc3RFbmRcbiAgICB9XG4gIH1cblxuICBpZiAoIWZvcndhcmQpIGFkZChfdGhpcywgY3VycmVudCwgbGFzdClcbiAgZWxzZSBhZGQoX3RoaXMsIGN1cnJlbnQpXG5cbn1cblxuZnVuY3Rpb24gYWRkKF90aGlzLCB0b0FkZCwgYmVmb3JlLCBkb25lKSB7XG4gIGlmICh0b0FkZCkgX3RoaXMuYWRkKHRvQWRkLCBiZWZvcmUpXG4gIGlmIChkb25lKSBkb25lKClcbn1cblxuZnVuY3Rpb24gZmFkZShfdGhpcywgbGFzdCwgb3B0aW9ucykge1xuICBsYXN0Lm9wYWNpdHkgPSAwXG4gIGxhc3Qubm9kZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnXG4gIHRpbWVyKF90aGlzLCBmdW5jdGlvbigpIHtcbiAgICByZW1vdmUoX3RoaXMsIGxhc3QsIG9wdGlvbnMuZG9uZSlcbiAgfSwgMjAwKVxufVxuXG5mdW5jdGlvbiByZW1vdmUoX3RoaXMsIHRvUmVtb3ZlLCBkb25lKSB7XG4gIGlmICh0b1JlbW92ZSkgdG9SZW1vdmUucmVtb3ZlKClcbiAgaWYgKGRvbmUpIGRvbmUoKVxufVxuXG5mdW5jdGlvbiB0aW1lcihfdGhpcywgZm4sIHRpbWUpIHtcbiAgaWYgKF90aGlzLl9zd1RpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KF90aGlzLl9zd1RpbWVyKVxuICAgIF90aGlzLl9zd1RpbWVyID0gbnVsbFxuICB9XG4gIF90aGlzLl9zd1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBmbi5jYWxsKF90aGlzKVxuICAgIF90aGlzLl9zd1RpbWVyID0gbnVsbFxuICB9LCB0aW1lKVxufVxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcblxucmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmRcbiggZnVuY3Rpb24oIGJhc2UgKSB7XG4gICAgLy8gYmFzZVxuICAgIGJhc2UuZXh0ZW5kXG4gICAgKCBcbiAgICAgIHsgaWQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgIHZhciBpZCA9IHZhbC52YWxcblxuICAgICAgICAgIGlmKCBpZCAmJiB0aGlzLmNsb3VkICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5jbG91ZC5kYXRhLmdldChbICd1c2VycycsIGlkIF0pXG4gICAgICAgICAgfSBcbiAgICAgICAgICBlbHNlIGlmKCAhaWQgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyB0aGlzLmRhdGEgPSB2b2lkIDBcbiAgICAgICAgICAgIC8vVE9ETzogdGhpcyB3b3JrcyBidWdneSBpbiB2YWx1ZXMgLS0tIHZvaWQgMCBkb2VzIG5vdCB1cGRhdGUgZGF0YSwgbWF5YmUganVzdCB1c2UgZmFsc2UgZm9yIG5vd1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2Jhc2UubW9ja2RhdGEnKVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gYmFzZS5tb2NrZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgLCBkYXRhOiB7XG4gICAgICAgICAgLy9tb2NrZGF0YSBvbiBzdGFydCBjYW4gYnJlYWsgZXZlcnl0aGluZyBkb3duXG4gICAgICAgICAgdmFsOiBiYXNlLm1vY2tkYXRhICxcbiAgICAgICAgICBzZXQ6ZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgICAgICAgIHZhciB1c2VyID0gdGhpc1xuXG4gICAgICAgICAgICAvLyBpZighdGhpcy5maXJzdCkge1xuICAgICAgICAgICAgICAvLyB0aGlzLmZpcnN0ID0gdHJ1ZVxuICAgICAgICAgICAgLy8gfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYodXNlci5pbnN0YW5jZXMgJiYgdXNlci5pbnN0YW5jZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IgKCctLSB0bXAgZml4IGRhdGEgb24gYmFzZSBzd2l0Y2ggdG8gaW5zdGFuY2VbMF0nIClcbiAgICAgICAgICAgICAgLy9UT0RPOiB0aGlzIGlzIGEgaGFja3kgc29sdXRpb24hIGZpeCBsYXRlclxuICAgICAgICAgICAgICB1c2VyID0gdXNlci5pbnN0YW5jZXNbMF1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHZhbC5mcm9tLmNsb3VkICApIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiggdXNlci5fX19jICE9PSB2YWwuZnJvbSApIFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdXNlci5pbml0aWFsaXNlZCA9IG51bGxcbiAgICAgICAgICAgICAgICB1c2VyLl9fX2MgPSB2YWwuZnJvbVxuICAgICAgICAgICAgICAgIGZvcih2YXIga2V5IGluIHVzZXIub24udXNlcikge1xuICAgICAgICAgICAgICAgICAgdXNlci5vbi51c2VyW2tleV0uY2FsbCggdXNlciwga2V5IClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXNlci5pbml0aWFsaXNlZCA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYoIHVzZXIuX19fYyA9PT0gZmFsc2UgKSByZXR1cm5cbiAgICAgICAgICAgICAgdXNlci5fX19jID0gZmFsc2VcbiAgICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gdXNlci5vbi51c2VyKSB7XG4gICAgICAgICAgICAgICAgdXNlci5vbi5tb2NrW2tleV0uY2FsbCggdXNlciwga2V5IClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1c2VyLmluaXRpYWxpc2VkID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG5cbn0pXG4iLCJyZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy9zZWxmJylcbnJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxucmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3MvdXRpbCcpXG4gIC8vVE9ETzogY2xlYW4gdGhlc2UgdG8gd29yayAvdyBpbmplY3RcblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksXG4gIFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUnKSxcbiAgQmFzZSA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UnKSxcbiAgRGF0YSA9IHJlcXVpcmUoJy4uLy4uL2RhdGEnKSxcbiAgdk9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpLmluamVjdChcbiAgICByZXF1aXJlKCcuL29yaWdpbicpXG4gICksXG4gIHRpbWVzdGFtcCA9IHJlcXVpcmUoJ21vbm90b25pYy10aW1lc3RhbXAnKSxcbiAgX3N1YnNjcmlwdGlvbnMgPSB7fSxcbiAgTW9ja0RhdGEgPSByZXF1aXJlKCcuL21vY2tkYXRhJyksXG4gIG1vY2tkYXRhID0gbmV3IE1vY2tEYXRhKHt9KVxuICAvLyBtYWtlIG1vY2tkYXRhIHZhaWxhYmxlXG5cbnZhciBfZXh0ZW5kID0gQmFzZS5wcm90b3R5cGUuZXh0ZW5kXG5cbnZhciB1c2VyID0gbmV3IEJhc2Uoe1xuICBkZWZhdWx0VHlwZTogcmVxdWlyZSgnLi90eXBlJylcbn0pXG5cbnVzZXIuZGVmaW5lKHtcbiAgc3Vic2NyaXB0aW9uczoge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIF9zdWJzY3JpcHRpb25zXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIGlmICh2YWwpIHV0aWwubWVyZ2UoX3N1YnNjcmlwdGlvbnMsIHZhbClcbiAgICB9XG4gIH0sXG4gIG1vY2tkYXRhOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbW9ja2RhdGFcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgaWYgKHZhbCkgbW9ja2RhdGEubWVyZ2UodmFsKVxuICAgIH1cbiAgfSxcbiAgb246IHtcbiAgICB2YWx1ZToge1xuICAgICAgbW9jazoge30sXG4gICAgICB1c2VyOiB7fVxuICAgIH1cbiAgfVxuLCBleHRlbmQ6IGZ1bmN0aW9uKCBzZXR0aW5ncyApIHtcblxuICAgIGlmKHNldHRpbmdzLm1vY2spIHtcbiAgICAgIHRoaXMubW9ja2RhdGEgPSBzZXR0aW5ncy5tb2NrXG4gICAgfVxuXG4gICAgdmFyIHJldCA9IF9leHRlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuXG4gICAgaWYoc2V0dGluZ3MudmFsICE9PSB2b2lkIDApIHtcbiAgICAgIHRoaXNbc2V0dGluZ3MubmFtZV0gPSBzZXR0aW5ncy52YWxcbiAgICB9XG5cbiAgICBpZiggc2V0dGluZ3Mub24gKSB7XG5cbiAgICAgIGlmKCB0eXBlb2Ygc2V0dGluZ3Mub24gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgIHNldHRpbmdzLm9uLmNhbGwoIHRoaXMsIHNldHRpbmdzLm5hbWUgKSBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKCB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmNsb3VkICkge1xuICAgICAgICAgIHNldHRpbmdzLm9uLnVzZXIgJiYgc2V0dGluZ3Mub24udXNlci5jYWxsKCB0aGlzLCBzZXR0aW5ncy5uYW1lICkgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0dGluZ3Mub24ubW9jayAmJiBzZXR0aW5ncy5vbi5tb2NrLmNhbGwoIHRoaXMsIHNldHRpbmdzLm5hbWUgKSBcbiAgICAgICAgfVxuICAgICAgfSAgICBcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cbn0pXG5cbi8vIHVzZXJcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChcbiAgcmVxdWlyZSgnLi4vY2xvdWQnKSxcbiAgZnVuY3Rpb24gKGJhc2UpIHtcbiAgICB2YXIgYXBwdXNlciA9IGJhc2UudXNlciA9IG5ldyB1c2VyLkNsYXNzKCkuaW5qZWN0KFxuICAgICAgcmVxdWlyZSgnLi9zZXQnKSxcbiAgICAgIHJlcXVpcmUoJy4vaWQnKVxuICAgICAgLy9pbmplY3QgcGFzIG9wIGV4dGVuZD8/P1xuICAgIClcbiAgICBhcHB1c2VyLnBhcmVudCA9IGJhc2VcbiAgICBhcHB1c2VyLmNhc2VzID0gYmFzZS5jYXNlc1xuICAgIGFwcHVzZXIuY2xvdWQgPSBiYXNlLmNsb3VkXG4gIH1cbikiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIERhdGEgPSByZXF1aXJlKCcuLi8uLi9kYXRhJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gRGF0YS5uZXcoKSAgXG5cbnV0aWwuZGVmaW5lKCBleHBvcnRzLFxuJ2dldCcsIGZ1bmN0aW9uKCB2YWwsIHNldCwgbm90c2VsZiApIHtcbiAgcmV0dXJuIHRoaXMucGF0aFxuICAoICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgPyB2YWwgOiBTdHJpbmcodmFsKS5zcGxpdCgnLicpXG4gICwgc2V0ICE9PSB2b2lkIDAgPyBzZXQgOiB7fVxuICAsIGZhbHNlXG4gICwgZmFsc2VcbiAgLCBmYWxzZVxuICAsIGZhbHNlXG4gICwgdHJ1ZVxuICAsICFub3RzZWxmXG4gIClcbn0pXG5cbiIsInZhciB1dGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwnKSxcbiAgVmFsdWUgPSByZXF1aXJlKCd2aWdvdXItanMvdmFsdWUnKSxcbiAgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpLFxuICBEYXRhID0gcmVxdWlyZSgndmlnb3VyLWpzL2RhdGEnKS5pbmplY3QoXG4gICAgcmVxdWlyZSgndmlnb3VyLWpzL2RhdGEvc2VsZWN0aW9uJykgICAgXG4gICksXG4gIENvbXBvdW5kID0gcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdC9jb21wb3VuZCcpLFxuICBldmVudHMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMnKSxcbiAgdWEgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci91YScpLFxuICByYWYgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vcmFmJylcblxudmFyIFZPYmplY3QgPSByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0JylcblZPYmplY3QuaW5qZWN0KFxuICByZXF1aXJlKCd2aWdvdXItanMvdmFsdWUvbGVuZ3RoJylcbilcblxudmFyIElOQUNUSVZFID0gdHlwZW9mIHdpbmRvdyAhPT0gdm9pZCAwICYmIHdpbmRvdy5JTkFDVElWRVxuXG52YXIgZGV2aWNlSXNDYW5kaWRhdGUgPSAvKGRlc2t0b3ApfCh0dil8KGNhc3QpfCh0YWJsZXQpfChhaXJwbGF5KS9pXG5jYXNlcy4kaXNDYW5kaWRhdGUgPSBkZXZpY2VJc0NhbmRpZGF0ZS50ZXN0KHVhLmRldmljZSlcblxudmFyIGRldmljZUlzVHZMaWtlID0gLyh0dil8KGNhc3QpfChhaXJwbGF5KS9pXG5cbnJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZS9mbGFncy9wcm9jZXNzJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbiAodXNlcikge1xuXG4gIHZhciBjb250ZW50ID0gdXNlci5wYXJlbnQuaW5qZWN0KHJlcXVpcmUoJy4uLy4uL2NvbnRlbnQnKSkuY29udGVudFxuXG4gIGNvbnRlbnQub24oJ3NlbGYnLCBmdW5jdGlvbigpIHtcbiAgICBpZiggdXNlci50b2tlbi52YWwgKSB7XG4gICAgICBpZih1c2VyLnJlY2VpdmVyLm1lZGlhLnZhbCAmJiB1c2VyLnJlY2VpdmVyLm1lZGlhLmZyb20gIT09IHVzZXIucmVjZWl2ZXIubWVkaWEgKSB7XG4gICAgICAgIGlmKHVzZXIucmVjZWl2ZXIubWVkaWEuZnJvbSE9PSBjb250ZW50LmdldCggdXNlci5yZWNlaXZlci5tZWRpYS5mcm9tLl9jb250ZW50UGF0aCApKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignbGV0cyBnbyBjaGFuZ2UgaXQhJywgdXNlci5yZWNlaXZlci5tZWRpYSlcbiAgICAgICAgICB1c2VyLnJlY2VpdmVyLm1lZGlhLiR1c2VyT3JpZ2luID0gY29udGVudC5nZXQoIHVzZXIucmVjZWl2ZXIubWVkaWEuZnJvbS5fY29udGVudFBhdGggKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBcbiAgfSlcblxuICAvLyBleHRlbmQgYmFzaWMgcHJvcGVydGllc1xuICB1c2VyLmV4dGVuZCh7XG4gICAgcmVjZWl2ZXI6IHtcbiAgICAgIG1vY2s6IHtcbiAgICAgICAgcmVjZWl2ZXI6IHtcbiAgICAgICAgICB2b2x1bWU6IDEsXG4gICAgICAgICAgbWVkaWE6IGZhbHNlLFxuICAgICAgICAgIHBsYXlpbmc6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2YWw6IHtcbiAgICAgICAgbWVkaWE6IHtcbiAgICAgICAgICAkYnViYmxlOiB7XG4gICAgICAgICAgICByZWZlcmVuY2VzOntcbiAgICAgICAgICAgICAgJGx0ZToxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZWZlcjpmdW5jdGlvbih1cGRhdGUpe1xuICAgICAgICAgICAgdmFyIHBsYXlpbmcgPSB0aGlzLl9wYXJlbnQucGxheWluZ1xuICAgICAgICAgICAgaWYocGxheWluZyAmJiAhdGhpcy5mcm9tLnZhbCkgcGxheWluZy5mcm9tLnZhbCA9IGZhbHNlXG4gICAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICByZWNlaXZlcjoge1xuICAgICAgICAgIHZvbHVtZTogdHJ1ZSxcbiAgICAgICAgICBwbGF5aW5nOnRydWUsXG4gICAgICAgICAgbWVkaWE6IHtcbiAgICAgICAgICAgICQ6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBtb2NrOiBzZXRNb2NrX3JlY2VpdmVyLFxuICAgICAgICB1c2VyOiBzZXRVc2VyX3JlY2VpdmVyXG4gICAgICB9XG4gICAgfSxcbiAgICBjbGllbnRzOiB7XG4gICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgY2xpZW50czoge1xuICAgICAgICAgICQ6IHtcbiAgICAgICAgICAgICQ6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBtb2NrOiBzZXRDbGllbnRzLFxuICAgICAgICB1c2VyOiBzZXRDbGllbnRzXG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5kaWRhdGVzOiB7IHZhbDoge30gfSxcbiAgICBzaWJsaW5nczogeyB2YWw6IHt9IH0sXG4gICAgcmVjZWl2ZXJDbGllbnQ6IHtcbiAgICAgIHZhbDoge30sXG4gICAgICBvbjoge1xuICAgICAgICBtb2NrOiBzZXRNb2NrX3JlY2VpdmVyQ2xpZW50LFxuICAgICAgICB1c2VyOiBzZXRVc2VyX3JlY2VpdmVyQ2xpZW50XG4gICAgICB9LFxuICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgIHJlY2VpdmVyQ2xpZW50OntcbiAgICAgICAgICAkOiB0cnVlICBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWN0aXZlQ2xpZW50OiB7XG4gICAgICB2YWw6IHt9LFxuICAgICAgbW9jazoge1xuICAgICAgICBhY3RpdmVDbGllbnQ6IHRydWVcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgYWN0aXZlQ2xpZW50OntcbiAgICAgICAgICAkOiB0cnVlICBcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIG1vY2s6IHNldE1vY2tfYWN0aXZlQ2xpZW50LFxuICAgICAgICB1c2VyOiBzZXRVc2VyX2FjdGl2ZUNsaWVudFxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgXG4gIC8vIGV4dGVuZCBkZXZpY2VzIChuZWVkcyBzaWJsaW5ncylcbiAgdXNlci5leHRlbmQoe1xuICAgIGRldmljZXM6IHtcbiAgICAgIHZhbDogbmV3IENvbXBvdW5kKHVzZXIuc2libGluZ3MpXG4gICAgfVxuICB9KVxuICBcbiAgLy8gZXh0ZW5kIGNhc2UgdmFsdWVzXG4gIHVzZXIuZXh0ZW5kKHtcbiAgICBoYXNSZWNlaXZlcjoge1xuICAgICAgdmFsOiB7XG4gICAgICAgIHZhbDogdXNlci5yZWNlaXZlckNsaWVudCxcbiAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbih2YWwsIGN2KSB7XG4gICAgICAgICAgdmFyIGVuZHBvaW50ID0gdXNlci5yZWNlaXZlckNsaWVudC5mcm9tXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIGVuZHBvaW50ICYmICFlbmRwb2ludC5fcmVtb3ZlZCAmJlxuICAgICAgICAgICAgZW5kcG9pbnQuY2xvdWQgJiYgZW5kcG9pbnQuX3BhdGhbMF0gPT09ICdjbGllbnRzJ1xuICAgICAgICAgICkgfHwgMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpc1JlY2VpdmVyOiB7ICAgICAgXG4gICAgICB2YWw6IHtcbiAgICAgICAgZGVmZXI6IGZ1bmN0aW9uKHVwZGF0ZSwgYXJncyl7XG4gICAgICAgICAgdmFyIG9yaWdpbiA9IGFyZ3NbMl0gfHwgdGhpcy5fdXBkYXRlT3JpZ2luXG4gICAgICAgICAgaWYoIW9yaWdpbiB8fCBcbiAgICAgICAgICAgICAhKG9yaWdpbi5fcHJvcCB8fCBvcmlnaW4uX25hbWUgPT09ICdyZWNlaXZlckNsaWVudCcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdibG9jayB1cGRhdGUnLCBvcmlnaW4pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbm8gYmxvY2snKVxuICAgICAgICAgIHZhciBzdGFtcCA9IGFyZ3NbMV1cbiAgICAgICAgICBpZihzdGFtcCAhPT0gJ2NsZWFudXAnKSB7XG4gICAgICAgICAgICBpZih1c2VyLl9oYW5kbGVPbGRJc1JlY2VpdmVyKSB7XG4gICAgICAgICAgICAgIGlmKCB1c2VyLl93YXNSZWNlaXZlciAmJiBcbiAgICAgICAgICAgICAgICAgICF1c2VyLmhhc1JlY2VpdmVyLnZhbCAmJlxuICAgICAgICAgICAgICAgICAgIXVzZXIuaXNBY3RpdmUudmFsXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignaSB3YXMgcmVjZWl2ZXIgZm9yIHRoaXMgZ3V5JywgdXNlci5kYXRhLl92YWwucmF3KVxuICAgICAgICAgICAgICAgIHVzZXIuc2V0UmVjZWl2ZXIodXNlci5jbG91ZC5jbGllbnQuZnJvbSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB1c2VyLl9oYW5kbGVPbGRJc1JlY2VpdmVyID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgICAgIHVzZXIuX3dhc1JlY2VpdmVyID0gdGhpcy52YWxcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgfSxcbiAgICAgICAgdmFsOiB1c2VyLnJlY2VpdmVyQ2xpZW50LFxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHZhbCwgY3YpIHtcbiAgICAgICAgICB2YXIgZW5kcG9pbnQgPSB1c2VyLnJlY2VpdmVyQ2xpZW50LmZyb21cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZW5kcG9pbnQgJiYgIWVuZHBvaW50Ll9yZW1vdmVkICYmXG4gICAgICAgICAgICBlbmRwb2ludC5jbG91ZCAmJiBlbmRwb2ludCA9PT0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuICAgICAgICAgICkgfHwgMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBoYXNDYW5kaWRhdGVzOiB7IFxuICAgICAgdmFsOiB7IFxuICAgICAgICB2YWw6IHVzZXIuY2FuZGlkYXRlcy4kbGVuZ3RoLFxuICAgICAgICAkY29udmVydFR5cGU6ICdib29sZWFuJ1xuICAgICAgfVxuICAgIH0sXG4gICAgaGFzRGV2aWNlczoge1xuICAgICAgdmFsOiB7IFxuICAgICAgICB2YWw6IHVzZXIuZGV2aWNlcy4kbGVuZ3RoLFxuICAgICAgICAkY29udmVydFR5cGU6ICdib29sZWFuJ1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNBY3RpdmU6IHtcbiAgICAgIHZhbDoge1xuICAgICAgICBkZWZlcjogZnVuY3Rpb24odXBkYXRlLCBhcmdzKXtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0gaXNBY3RpdmUgY2hlY2sgZGF0IScpXG4gICAgICAgICAgdmFyIG9yaWdpbiA9IGFyZ3NbMl0gfHwgdGhpcy5fdXBkYXRlT3JpZ2luXG4gICAgICAgICAgaWYoIW9yaWdpbiB8fCBcbiAgICAgICAgICAgICAhKG9yaWdpbi5fcHJvcCB8fCBvcmlnaW4uX25hbWUgPT09ICdhY3RpdmVDbGllbnQnKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbm8gYmxvY2tpdCcsIFxuICAgICAgICAgICAgLy8gICBvcmlnaW4uX3BhdGgsXG4gICAgICAgICAgICAvLyAgIG9yaWdpbixcbiAgICAgICAgICAgIC8vICAgJ1xcbnZhbDonLCBhcmdzWzBdXG4gICAgICAgICAgICAvLyApXG4gICAgICAgICAgICB1cGRhdGUodHJ1ZSlcbiAgICAgICAgICAgIC8vIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzdGFtcCA9IGFyZ3NbMV1cblxuICAgICAgICAgIGlmKHN0YW1wKSB7XG4gICAgICAgICAgICBpZihzdGFtcCAhPT0gJ2NsZWFudXAnKSB7XG4gICAgICAgICAgICAgIGlmKHVzZXIuX2hhbmRsZU9sZElzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgaWYoIHVzZXIuX3dhc0FjdGl2ZSAmJiBcbiAgICAgICAgICAgICAgICAgICAgISggdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gJiYgXG4gICAgICAgICAgICAgICAgICAgICAgIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luLl92YWxcbiAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignaSB3YXMgYWN0aXZlQ2xpZW50IGZvciB0aGlzIGd1eSBSRVNFVCcpXG4gICAgICAgICAgICAgICAgICB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiA9IHVzZXIuY2xvdWQuY2xpZW50Ll92YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdXNlci5faGFuZGxlT2xkSXNBY3RpdmUgPSBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgdXNlci5fd2FzQWN0aXZlID0gdGhpcy52YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZ28gdXBkYXRlIScpXG4gICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgfSxcbiAgICAgICAgdmFsOiB1c2VyLmFjdGl2ZUNsaWVudCxcbiAgICAgICAgLy8gJGJ1YmJsZToge1xuICAgICAgICAvLyAgIHJlZmVyZW5jZXM6IDJcbiAgICAgICAgLy8gfSxcbiAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiAoYywgY3YpIHtcbiAgICAgICAgICB2YXIgZW5kcG9pbnQgPSB1c2VyLmFjdGl2ZUNsaWVudC5mcm9tXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIChlbmRwb2ludCAmJiBlbmRwb2ludC52YWwgPT09IHRydWUpIHx8XG4gICAgICAgICAgICBlbmRwb2ludCA9PT0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuICAgICAgICAgICkgfHwgMFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRSZWNlaXZlcjoge1xuICAgICAgdHlwZTogZmFsc2UsXG4gICAgICB2YWw6IGZ1bmN0aW9uKGNsaWVudCkge1xuICAgICAgICB2YXIgdXNlciA9IHRoaXNcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignc2V0UmVjZWl2ZXIgY2FsbGVkIGxvbCcpXG4gICAgICAgIGNsaWVudCA9IGNsaWVudC5mcm9tXG4gICAgICAgIGlmKCFjbGllbnQpIHJldHVyblxuXG4gICAgICAgIHZhciBjYXN0dHlwZSA9IGNsaWVudC5jYXN0ICYmIGNsaWVudC5jYXN0LnZhbFxuXG4gICAgICAgIGlmKGNhc3R0eXBlKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3NldFJlY2VpdmVyISB1c2VyLmNhc3RbY2FzdHR5cGVdJywgdXNlci5jYXN0W2Nhc3R0eXBlXSlcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0UmVjZWl2ZXIhIHVzZXIuY2FzdFtjYXN0dHlwZV0uc2V0UmVjZWl2ZXInLCB1c2VyLmNhc3RbY2FzdHR5cGVdLnNldFJlY2VpdmVyKVxuICAgICAgICAgIHVzZXIuY2FzdFtjYXN0dHlwZV0uc2V0UmVjZWl2ZXIoY2xpZW50KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWVudC5zZXQoJ3Rva2VuJywgdXNlci50b2tlbi52YWwpXG4gICAgICAgICAgdXNlci5yZWNlaXZlckNsaWVudC4kdXNlck9yaWdpbiA9IGNsaWVudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuICBcbiAgLy8gREVCVUc6XG4gIC8vIHVzZXIuYWN0aXZlQ2xpZW50Lm9uKGZ1bmN0aW9uKCl7XG4gIC8vICAgY29uc29sZS5lcnJvcignYWN0aXZlQ2xpZW50IGhhcHBlbmluIScsIHRoaXMuZnJvbSAmJiB0aGlzLmZyb20udG9TdHJpbmcoKSlcbiAgLy8gfSlcbiAgXG4gIC8vIHVzZXIuaGFzUmVjZWl2ZXIub24oZnVuY3Rpb24oKXtcbiAgLy8gICBjb25zb2xlLmVycm9yKCdsb2wgaGFzUmVjZWl2ZXIgbGlzdGVuZXIgZmlyZXMhIHZhbDonLCB0aGlzLnZhbClcbiAgLy8gfSlcbiAgLy8gdXNlci5pc1JlY2VpdmVyLm9uKGZ1bmN0aW9uKCl7XG4gIC8vICAgY29uc29sZS5lcnJvcignbG9sIGlzUmVjZWl2ZXIgbGlzdGVuZXIgZmlyZXMhIHZhbDonLCB0aGlzLnZhbClcbiAgLy8gfSlcbiAgLy8gdXNlci5hY3RpdmVDbGllbnQub24oZnVuY3Rpb24oKXtcbiAgLy8gICBjb25zb2xlLmVycm9yKCdsb2wgYWN0aXZlQ2xpZW50IGxpc3RlbmVyIGZpcmVzISB2YWw6XFxuJywgdGhpcy5mcm9tLnRvU3RyaW5nKCkpXG4gIC8vIH0pXG5cbiAgLy8gbGlzdGVuZXJzOlxuXG4gIC8vIG9uIGFjdGl2aXR5OiBtYWtlIG1lIGFjdGl2ZUNsaWVudFxuICBpZighY2FzZXMuJGlzQ2hyb21lY2FzdCAmJiAhSU5BQ1RJVkUpIHtcbiAgICB2YXIgYWN0aXZlRXZlbnQgPSBjYXNlcy4kaXNUdiA/ICdrZXlkb3duJyA6ICdkb3duJ1xuICAgIGV2ZW50cy5kb2N1bWVudC5hZGRFdmVudChhY3RpdmVFdmVudCwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYoIHVzZXIuY2xvdWQuY2xpZW50Ll92YWwgJiZcbiAgICAgICAgICAhKGNhc2VzLiRpc0Z1bGxzY3JlZW4gJiYgY2FzZXMuJGlzRnVsbHNjcmVlbi52YWwpXG4gICAgICAgICkge1xuICAgICAgICB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiA9IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cbiAgICAgIH1cbiAgICB9KSAgXG4gIH1cbiAgXG5cbiAgLy8gcmUtZXN0YWJsaXNoIG9sZCBzZXR1cCBhZnRlciByZWNvbm5lY3RcbiAgdXNlci5jbG91ZC5vbignd2VsY29tZScsIGZ1bmN0aW9uKCl7XG4gICAgaWYodXNlci5jbG91ZC5fc3RhdHVzID4gMil7XG4gICAgICB1c2VyLl9oYW5kbGVPbGRJc0FjdGl2ZSA9IHRydWVcbiAgICAgIHVzZXIuX2hhbmRsZU9sZElzUmVjZWl2ZXIgPSB0cnVlXG4gICAgICB1c2VyLmNsb3VkLmRhdGEub25jZShmdW5jdGlvbigpe1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnb2sgZ28gcmVzZXQgZGF0IG9sZCBzaXR1YXRpb24nKVxuICAgICAgICB1c2VyLmlzQWN0aXZlLnVwZGF0ZSgpXG4gICAgICAgIHVzZXIuaXNSZWNlaXZlci51cGRhdGUoKVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgLypcbiAgKiB3aGVuIEkgYmVjb21lIGFjdGl2ZSwgdW5zZXQgbXlzZWxmIGFzIHJlY2VpdmVyXG4gICogYW5kIGlmIG5vdCBpcGxvZ2luID4gc2VsZWN0IG5ldyByZWNlaXZlclxuICAqL1xuICB1c2VyLmlzQWN0aXZlLm9uKHRydWUsIGZ1bmN0aW9uKCkge1xuICAgIHZhciBpc1JlY2VpdmVyID0gdXNlci5pc1JlY2VpdmVyLnZhbFxuICAgIC8vIGNvbnNvbGUubG9nKCdpc1JlY2VpdmVyPyEnLCBpc1JlY2VpdmVyKVxuXG4gICAgaWYodXNlci5oYXNDYW5kaWRhdGVzLnZhbCkgeyAvLyAgJiYgIXVzZXIuaXBsb2dpbi52YWxcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd1c2VyLmhhc0NhbmRpZGF0ZXMudmFsJywgdXNlci5oYXNDYW5kaWRhdGVzLnZhbClcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdpc1JlY2VpdmVyJywgXG4gICAgICAvLyAgIGlzUmVjZWl2ZXIsIFxuICAgICAgLy8gICAnXFxudXNlci5oYXNSZWNlaXZlci52YWwnLCB1c2VyLmhhc1JlY2VpdmVyLnZhbFxuICAgICAgLy8gICApXG4gICAgICBpZihpc1JlY2VpdmVyIHx8ICF1c2VyLmhhc1JlY2VpdmVyLnZhbCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnb2sgc2VsZWN0IHJlY2VpdmVyIGJlY2F1c2UgaSBiZWNhbWUgYWN0aXZlIScpXG4gICAgICAgIHZhciBuZXdyZWNlaXZlciA9IHNlbGVjdFJlY2VpdmVyKHVzZXIsIHVzZXIuY2FuZGlkYXRlcylcbiAgICAgICAgaWYobmV3cmVjZWl2ZXIpIHtcbiAgICAgICAgICAvLyB3YWl0IGZvciBteSBvd24gaXNhY3RpdmUgc2V0XG4gICAgICAgICAgcmFmKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB1c2VyLnNldFJlY2VpdmVyKG5ld3JlY2VpdmVyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSBpZihpc1JlY2VpdmVyKSB7XG4gICAgICAgICAgdXNlci5yZWNlaXZlckNsaWVudC4kdXNlck9yaWdpbiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihpc1JlY2VpdmVyKXtcbiAgICAgIHVzZXIucmVjZWl2ZXJDbGllbnQuJHVzZXJPcmlnaW4gPSBudWxsXG4gICAgfVxuICB9KSAgXG4gIFxuXG4gIC8vIHdoZW4gcmVjZWl2ZXIgbGVhdmVzLCBJIG1pZ2h0IGhhdmUgdG8gYmVjb21lIHRoZSBuZXcgcmVjZWl2ZXJcbiAgaWYoY2FzZXMuJGlzQ2FuZGlkYXRlKSB7XG4gICAgdXNlci5oYXNSZWNlaXZlci5vbigwLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tKXtcbiAgICAgIGlmKHN0YW1wID09PSB1c2VyLmNsb3VkLnN0YW1wKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd5ZXMgdXBkYXRlIGlzIG9rJylcbiAgICAgICAgaWYoIXVzZXIuaXNBY3RpdmUudmFsKXtcbiAgICAgICAgICAvLyB3YWl0IGZvciBhbGwgcmVtb3ZlcyB0byBmaW5pc2hcbiAgICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIC8vIHNlbGVjdCByZWNlaXZlclxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ29rIHNlbGVjdCByZWNlaXZlciBiZWNhdXNlIHJlY2VpdmVyIGxlZnQhJylcbiAgICAgICAgICAgIHZhciBuZXdyZWNlaXZlciA9IHNlbGVjdFJlY2VpdmVyKHVzZXIsIHVzZXIuY2xpZW50cylcbiAgICAgICAgICAgIC8vIGlmIGl0cyBtZSA+IHVwZGF0ZSB1c2VyXG4gICAgICAgICAgICBpZihuZXdyZWNlaXZlciA9PT0gdXNlci5jbG91ZC5jbGllbnQuZnJvbSkge1xuICAgICAgICAgICAgICB1c2VyLnNldFJlY2VpdmVyKG5ld3JlY2VpdmVyKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2kgYW0gbm90IG5ldyByZWNlaXZlciEgbmV3cmVjZWl2ZXIgaXMnLCBuZXdyZWNlaXZlciAmJiBuZXdyZWNlaXZlci5yYXcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3VwZGF0ZSBub3QgZnJvbSB0aGUgY2xvdWQnKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvLyB3aGVuIGEgdHYgam9pbnMsIEkgbWlnaHQgd2FudCB0byBncmFiIGl0XG4gIGlmKCF1c2VyLmlwbG9naW4udmFsKXtcbiAgICB1c2VyLmNhbmRpZGF0ZXMub24oZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCl7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCctLS0tLS0tLSBjaGVjayBmb3IgdHYgam9pbmVyXFxuJyxcbiAgICAgIC8vICAgJ3VzZXIuaGFzQ2FuZGlkYXRlcy52YWwnLCB1c2VyLmhhc0NhbmRpZGF0ZXMudmFsLCAnXFxuJyxcbiAgICAgIC8vICAgJ3VzZXIuaXNBY3RpdmUudmFsJywgdXNlci5pc0FjdGl2ZS52YWwsICdcXG4nLFxuICAgICAgLy8gICAndXNlci5pbml0aWFsaXNlZCcsIHVzZXIuaW5pdGlhbGlzZWRcbiAgICAgIC8vIClcbiAgICAgIC8vIGNvbnNvbGUubG9nKHVzZXIuY2FuZGlkYXRlcy50b1N0cmluZygpKVxuICAgICAgaWYodXNlci5oYXNDYW5kaWRhdGVzLnZhbCAmJiB1c2VyLmlzQWN0aXZlLnZhbCAmJlxuICAgICAgICAgIHVzZXIuaW5pdGlhbGlzZWRcbiAgICAgICAgKSB7XG4gICAgICAgIGdyYWJUVih1c2VyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignbm8gY2FuZGlkYXRlcycpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIFxuICAvLyBtYWtlIGNhc2VzXG4gIGNhc2VzLiRpc0FjdGl2ZSA9IHVzZXIuaXNBY3RpdmVcbiAgLy8gY2FzZXMuJGhhc0NhbmRpZGF0ZXMgPSB1c2VyLmhhc0NhbmRpZGF0ZXNcbiAgY2FzZXMuJGhhc0RldmljZXMgPSB1c2VyLmhhc0RldmljZXNcbiAgY2FzZXMuJGhhc1JlY2VpdmVyID0gdXNlci5oYXNSZWNlaXZlclxuICBjYXNlcy4kaXNSZWNlaXZlciA9IHVzZXIuaXNSZWNlaXZlclxuXG5cbn0pXG5cbi8vIGNsaWVudHNcbmZ1bmN0aW9uIHVwZGF0ZUNsaWVudHMoKSB7XG4gIHRoaXMuY2xpZW50cy51cGRhdGUoKVxufVxuXG5mdW5jdGlvbiBzZXRDbGllbnRzICgpIHtcbiAgdmFyIHVzZXIgPSB0aGlzXG4gIHZhciBsaW5rZWQgPSB1c2VyLmRhdGEuX3ZhbFxuXG4gIC8vIGNsaWVudHNcbiAgdmFyIGxpbmtlZGNsaWVudHMgPSBsaW5rZWQuZ2V0KCdjbGllbnRzJylcbiAgLy8gY2FjaGUgb2xkLCBzZXQgbmV3LCBhbmQgcmVtb3ZlIGxpc3RlbmVyIGlmIGNhY2hlZCBvbGRcbiAgdmFyIG9sZGNsaWVudHMgPSB1c2VyLmNsaWVudHMuX3ZhbFxuICB1c2VyLmNsaWVudHMgPSBsaW5rZWRjbGllbnRzXG4gIGxpbmtlZGNsaWVudHMuYWRkTGlzdGVuZXIoW3VwZGF0ZUNsaWVudHMsIHVzZXJdLCB0cnVlKVxuICBpZiggb2xkY2xpZW50cyApIHtcbiAgICBvbGRjbGllbnRzLnJlbW92ZUxpc3RlbmVyKHVwZGF0ZUNsaWVudHMsIHVzZXIpXG4gIH1cblxuICAvLyBjYW5kaWRhdGVzXG4gIC8vIGNhY2hlIHByZXZpb3VzZSB2YWx1ZVxuICB2YXIgb2xkY2FuZGlkYXRlcyA9IHVzZXIuY2FuZGlkYXRlcyAmJiB1c2VyLmNhbmRpZGF0ZXMuX3ZhbFxuICAvLyBtYWtlIGNhbmRpZGF0ZXNcbiAgdmFyIGNhbmRpZGF0ZXMgPSB1c2VyLmNhbmRpZGF0ZXMgPSBuZXcgRGF0YSggbGlua2VkY2xpZW50cywge1xuICAgIGNvbmRpdGlvbjogeyBcbiAgICAgIGRldmljZToge1xuICAgICAgICAkY29udGFpbnM6ICcoZGVza3RvcCl8KHR2KXwoY2FzdCl8KHRhYmxldCl8KGFpcnBsYXkpJ1xuICAgICAgfSxcbiAgICAgIGtleToge1xuICAgICAgICAkZXhpc3RzOiB0cnVlLFxuICAgICAgICAkbmU6IHRoaXMuY2xvdWQuY2xpZW50aWRcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIC8vIGFkZCBsaXN0ZW5lciBiZWNhdXNlIG9mIHJlYXNvbnNcbiAgY2FuZGlkYXRlcy5vbihmdW5jdGlvbigpe1xuICAgIHVzZXIuY2FuZGlkYXRlcy51cGRhdGUoKVxuICB9KVxuICAvLyBjbGVhbiB1cCBkYXQgb2xkIHNlbGVjdGlvblxuICBpZihvbGRjYW5kaWRhdGVzKSB7XG4gICAgb2xkY2FuZGlkYXRlcy5yZW1vdmUoKVxuICB9XG4gIFxuICAvLyBzaWJsaW5nc1xuICAvLyBjYWNoZSBwcmV2aW91c2UgdmFsdWVcbiAgdmFyIG9sZHNpYmxpbmdzID0gdXNlci5zaWJsaW5ncyAmJiB1c2VyLnNpYmxpbmdzLl92YWxcbiAgLy8gbWFrZSBzaWJsaW5nc1xuICB2YXIgc2libGluZ3MgPSB1c2VyLnNpYmxpbmdzID0gbmV3IERhdGEoIGxpbmtlZGNsaWVudHMsIHtcbiAgICBjb25kaXRpb246IHtcbiAgICAgIGtleToge1xuICAgICAgICAkZXhpc3RzOiB0cnVlLFxuICAgICAgICAkbmU6IHRoaXMuY2xvdWQuY2xpZW50aWRcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIC8vIGFkZCBsaXN0ZW5lciBiZWNhdXNlIG9mIHJlYXNvbnNcbiAgc2libGluZ3Mub24oZnVuY3Rpb24oKXtcbiAgICAvLyBjb25zb2xlLmxvZygndXBkYXRlIG9uIGNhbmRpZGF0ZXMgPiB1cGRhdGUgdXNlci5jYW5kaWRhdGVzJylcbiAgICB1c2VyLnNpYmxpbmdzLnVwZGF0ZSgpXG4gIH0pXG4gIC8vIGNsZWFuIHVwIGRhdCBvbGQgc2VsZWN0aW9uXG4gIGlmKG9sZHNpYmxpbmdzKSB7XG4gICAgb2xkc2libGluZ3MucmVtb3ZlKClcbiAgfVxufVxuXG4vLyBhY3RpdmVDbGllbnRcblxudmFyIGFjUmVtb3ZlVGFyZ2V0XG52YXIgYWNBZGRlZFRhcmdldFxuXG5mdW5jdGlvbiBzZXRNb2NrX2FjdGl2ZUNsaWVudCAoKSB7XG4gIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tIHNldE1vY2tfYWN0aXZlQ2xpZW50IScpXG5cbiAgdmFyIHVzZXIgPSB0aGlzXG5cbiAgaWYoYWNSZW1vdmVUYXJnZXQpIHtcbiAgICBhY1JlbW92ZVRhcmdldC5yZW1vdmVMaXN0ZW5lcihhY1JlbW92ZUNoZWNrLCB1c2VyKVxuICAgIGFjUmVtb3ZlVGFyZ2V0ID0gbnVsbFxuICB9XG4gIGlmKGFjQWRkZWRUYXJnZXQpIHtcbiAgICBhY0FkZGVkVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGFjQWRkZWRDaGVjaywgdXNlcilcbiAgICBhY0FkZGVkVGFyZ2V0ID0gbnVsbFxuICB9XG5cbiAgdmFyIGxpbmtlZCA9IHVzZXIuZGF0YS5fdmFsXG5cbiAgdXNlci5hY3RpdmVDbGllbnQgPSBsaW5rZWQuZ2V0KCdhY3RpdmVDbGllbnQnLCB7fSlcbiAgdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gPSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG5cbn1cblxuXG5cbmZ1bmN0aW9uIHNldFVzZXJfYWN0aXZlQ2xpZW50ICgpIHtcbiAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0gc2V0VXNlcl9hY3RpdmVDbGllbnQhJylcblxuICB2YXIgdXNlciA9IHRoaXNcblxuICAvLyBjb25zb2xlLmxvZygnZGF0IGFjdGl2ZUNsaWVudDonLCBcbiAgLy8gICB1c2VyLmRhdGEuX3ZhbC5hY3RpdmVDbGllbnRcbiAgLy8gICA/ICd5ZXMgYWN0aXZlY2xpZW50XFxuJyArIHVzZXIuZGF0YS5fdmFsLmFjdGl2ZUNsaWVudC50b1N0cmluZygpXG4gIC8vICAgOiAnbm8gYWN0aXZlQ2xpZW50IGluIG1hIG5ldyB1c2VyISFcXG4nICsgdXNlci5kYXRhLl92YWwudG9TdHJpbmcoKVxuICAvLyApXG5cbiAgaWYoYWNBZGRlZFRhcmdldCkge1xuICAgIGFjQWRkZWRUYXJnZXQucmVtb3ZlTGlzdGVuZXIoYWNBZGRlZENoZWNrLCB1c2VyKVxuICAgIGFjQWRkZWRUYXJnZXQgPSBudWxsXG4gIH1cbiAgXG4gIHZhciBsaW5rZWQgPSB1c2VyLmRhdGEuX3ZhbFxuICB2YXIgbGlua2VkUmVmID0gbGlua2VkLmdldCgnYWN0aXZlQ2xpZW50Jywge30pXG5cbiAgaWYoYWNSZW1vdmVUYXJnZXQpIHtcbiAgICBhY1JlbW92ZVRhcmdldC5yZW1vdmVMaXN0ZW5lcihhY1JlbW92ZUNoZWNrLCB1c2VyKVxuICB9XG4gIGFjUmVtb3ZlVGFyZ2V0ID0gbGlua2VkUmVmXG4gIGFjUmVtb3ZlVGFyZ2V0LmFkZExpc3RlbmVyKFthY1JlbW92ZUNoZWNrLCB1c2VyXSwgdHJ1ZSlcblxuICB1c2VyLmFjdGl2ZUNsaWVudCA9IGxpbmtlZFJlZlxuICBcbiAgLy8gY29uc29sZS5lcnJvcignVVNFUlNXSVRDSCBBQ1RJVkVDTElFTlQnKVxuICBpZighSU5BQ1RJVkUpe1xuICAgIGlmKGNhc2VzLiRpc1R2KSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdJTSBUViBVU0VSU1dJVENIIFdBVCBUTyBETycpXG4gICAgICAvLyB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiA9IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cbiAgICAgIC8vIFRPRE86IGZpeCB0aGlzOlxuICAgICAgdmFyIGFjdGl2ZUNsaWVudCA9IGxpbmtlZFJlZi5mcm9tXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdhY3RpdmVDbGllbnQgaXMnLCBhY3RpdmVDbGllbnQpXG4gICAgICAvLyBjb25zb2xlLmxvZygnaSBhbScsIHVzZXIuY2xvdWQuY2xpZW50LmZyb20ucmF3KVxuICAgICAgaWYoIShhY3RpdmVDbGllbnQgJiYgYWN0aXZlQ2xpZW50Ll9uYW1lICE9PSAnYWN0aXZlQ2xpZW50JykpIHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignc2V0IG1hc2VsZiBhY3RpdmUnKVxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdTRVQgTUUgVE8gREFUIGFjdGl2ZUNsaWVudCAoVFYpJylcbiAgICAgICAgdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gPSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1ZHBhdGUgYWN0aXZlQ2xpZW50IGJlY2F1c2UgZG8gaXQnKVxuICAgICAgICB1c2VyLmFjdGl2ZUNsaWVudC51cGRhdGUoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZighY2FzZXMuJGlzQ2hyb21lY2FzdCkge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignU0VUIE1FIFRPIERBVCBhY3RpdmVDbGllbnQnKVxuICAgICAgdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gPSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG4gICAgfVxuICB9XG4gIFxuXG4gIGlmKHVzZXIuaGFzQ2FuZGlkYXRlcy52YWwpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnY2hlY2sgZm9yIHR2IHRvIGdyYWIgb24gc2V0VXNlcl9hY3RpdmVDbGllbnQnKVxuICAgIGdyYWJUVih1c2VyKVxuICB9XG5cbiAgdXNlci5hY3RpdmVDbGllbnQudXBkYXRlKClcblxufVxuZnVuY3Rpb24gYWNSZW1vdmVDaGVjayAoZmlyZXIsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSkge1xuICB2YXIgdXNlciA9IHRoaXNcbiAgaWYoZmlyZXIuX3JlbW92ZWQpIHtcbiAgICBpZihhY0FkZGVkVGFyZ2V0KSB7XG4gICAgICBhY0FkZGVkVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGFjQWRkZWRDaGVjaywgdXNlcilcbiAgICB9XG4gICAgYWNBZGRlZFRhcmdldCA9IGZpcmVyLl9wYXJlbnRcbiAgICBhY0FkZGVkVGFyZ2V0LmFkZExpc3RlbmVyKFthY0FkZGVkQ2hlY2ssIHVzZXJdLCB0cnVlKVxuICB9XG59XG5mdW5jdGlvbiBhY0FkZGVkQ2hlY2sgKGZpcmVyLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkKSB7XG4gIHZhciB1c2VyID0gdGhpcyxcbiAgICBsaW5rZWR1c2VyID0gZmlyZXJcblxuICBpZihsaW5rZWR1c2VyLmFjdGl2ZUNsaWVudCl7XG4gICAgYWNBZGRlZFRhcmdldC5yZW1vdmVMaXN0ZW5lcihhY0FkZGVkQ2hlY2ssIHVzZXIpXG4gICAgYWNBZGRlZFRhcmdldCA9IG51bGxcbiAgICBcbiAgICBhY1JlbW92ZVRhcmdldCA9IGxpbmtlZHVzZXIuYWN0aXZlQ2xpZW50XG4gICAgYWNSZW1vdmVUYXJnZXQuYWRkTGlzdGVuZXIoW2FjUmVtb3ZlQ2hlY2ssIHVzZXJdLCB0cnVlKVxuXG4gICAgdXNlci5hY3RpdmVDbGllbnQgPSBsaW5rZWR1c2VyLmFjdGl2ZUNsaWVudFxuICB9XG59XG5cbi8vIHJlY2VpdmVyQ2xpZW50XG52YXIgcmNBZGRlZFRhcmdldFxudmFyIHJjUmVtb3ZlVGFyZ2V0XG5cbmZ1bmN0aW9uIHNldE1vY2tfcmVjZWl2ZXJDbGllbnQgKCkge1xuICB2YXIgdXNlciA9IHRoaXNcblxuICBpZihyY0FkZGVkVGFyZ2V0KSB7XG4gICAgcmNBZGRlZFRhcmdldC5yZW1vdmVMaXN0ZW5lcihyY0FkZGVkQ2hlY2ssIHVzZXIpXG4gIH1cbiAgaWYocmNSZW1vdmVUYXJnZXQpIHtcbiAgIHJjUmVtb3ZlVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHJjUmVtb3ZlQ2hlY2ssIHVzZXIpIFxuICB9XG5cbiAgdmFyIGxpbmtlZCA9IHVzZXIuZGF0YS5fdmFsXG4gIHVzZXIucmVjZWl2ZXJDbGllbnQgPSBsaW5rZWQuZ2V0KCdyZWNlaXZlckNsaWVudCcsIGZhbHNlKVxufVxuZnVuY3Rpb24gc2V0VXNlcl9yZWNlaXZlckNsaWVudCAoKSB7XG4gIHZhciB1c2VyID0gdGhpc1xuXG4gIGlmKHJjQWRkZWRUYXJnZXQpIHtcbiAgICByY0FkZGVkVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHJjQWRkZWRDaGVjaywgdXNlcilcbiAgICByY0FkZGVkVGFyZ2V0ID0gbnVsbFxuICB9XG5cbiAgdmFyIGxpbmtlZCA9IHVzZXIuZGF0YS5fdmFsXG4gIHZhciBsaW5rZWRSZWYgPSBsaW5rZWQuZ2V0KCdyZWNlaXZlckNsaWVudCcsIHt9KVxuXG4gIGlmKHJjUmVtb3ZlVGFyZ2V0KSB7XG4gICAgcmNSZW1vdmVUYXJnZXQucmVtb3ZlTGlzdGVuZXIocmNSZW1vdmVDaGVjaywgdXNlcilcbiAgfVxuICByY1JlbW92ZVRhcmdldCA9IGxpbmtlZFJlZlxuICByY1JlbW92ZVRhcmdldC5hZGRMaXN0ZW5lcihbcmNSZW1vdmVDaGVjaywgdXNlcl0sIHRydWUpXG5cbiAgdXNlci5yZWNlaXZlckNsaWVudCA9IGxpbmtlZFJlZlxuXG4gIGlmKGNhc2VzLiRpc1R2KSB7XG4gICAgLy8gc2V0IHR2IHRvIHJlY2VpdmVyIGlmIGFjdGl2ZWNsaWVudCBhbmQgbm8gcmVjZWl2ZXJcbiAgICB2YXIgYWN0aXZlQ2xpZW50ID0gdXNlci5hY3RpdmVDbGllbnQuZnJvbVxuICAgIGlmKCBhY3RpdmVDbGllbnQgJiYgYWN0aXZlQ2xpZW50Ll9fdCA9PT0gMiAmJlxuICAgICAgICBhY3RpdmVDbGllbnQgIT09IHVzZXIuY2xvdWQuY2xpZW50LmZyb20gJiZcbiAgICAgICAgIXVzZXIuaGFzUmVjZWl2ZXIudmFsXG4gICAgICApIHtcbiAgICAgIHVzZXIuc2V0UmVjZWl2ZXIodXNlci5jbG91ZC5jbGllbnQuZnJvbSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoY2FzZXMuJGlzQ2hyb21lY2FzdCkge1xuICAgIC8vIGFsd2F5cyBzZXQgY2hyb21lY2FzdCB0byByZWNlaXZlclxuICAgIHVzZXIuc2V0UmVjZWl2ZXIodXNlci5jbG91ZC5jbGllbnQuZnJvbSlcbiAgfVxuXG59XG5mdW5jdGlvbiByY1JlbW92ZUNoZWNrIChmaXJlciwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlKSB7XG4gIHZhciB1c2VyID0gdGhpc1xuICBpZihmaXJlci5fcmVtb3ZlZCkge1xuICAgIGlmKHJjQWRkZWRUYXJnZXQpIHtcbiAgICAgIHJjQWRkZWRUYXJnZXQucmVtb3ZlTGlzdGVuZXIocmNBZGRlZENoZWNrLCB1c2VyKVxuICAgIH1cbiAgICByY0FkZGVkVGFyZ2V0ID0gZmlyZXIuX3BhcmVudFxuICAgIHJjQWRkZWRUYXJnZXQuYWRkTGlzdGVuZXIoW3JjQWRkZWRDaGVjaywgdXNlcl0sIHRydWUpXG4gIH1cbn1cbmZ1bmN0aW9uIHJjQWRkZWRDaGVjayAoZmlyZXIsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQpIHtcbiAgdmFyIHVzZXIgPSB0aGlzLFxuICAgIGxpbmtlZHVzZXIgPSBmaXJlclxuXG4gIGlmKGxpbmtlZHVzZXIucmVjZWl2ZXJDbGllbnQpe1xuICAgIHJjQWRkZWRUYXJnZXQucmVtb3ZlTGlzdGVuZXIocmNBZGRlZENoZWNrLCB1c2VyKVxuICAgIHJjQWRkZWRUYXJnZXQgPSBudWxsXG5cbiAgICByY1JlbW92ZVRhcmdldCA9IGxpbmtlZHVzZXIucmVjZWl2ZXJDbGllbnRcbiAgICByY1JlbW92ZVRhcmdldC5hZGRMaXN0ZW5lcihbcmNSZW1vdmVDaGVjaywgdXNlcl0sIHRydWUpXG5cbiAgICB1c2VyLnJlY2VpdmVyQ2xpZW50ID0gbGlua2VkdXNlci5yZWNlaXZlckNsaWVudFxuICB9XG59XG4vLyByZWNlaXZlclxuZnVuY3Rpb24gc2V0TW9ja19yZWNlaXZlciAoKSB7XG4gIHZhciB1c2VyID0gdGhpc1xuICBsaW5rUmVjZWl2ZXIodXNlcilcbn1cbmZ1bmN0aW9uIHNldFVzZXJfcmVjZWl2ZXIgKCkge1xuICB2YXIgdXNlciA9IHRoaXNcbiAgbGlua1JlY2VpdmVyKHVzZXIpXG59XG5mdW5jdGlvbiBsaW5rUmVjZWl2ZXIgKHVzZXIpIHtcbiAgdmFyIGxpbmtlZCA9IHVzZXIuZGF0YS5fdmFsXG4gICAgLCBsaW5rZWRyZWNlaXZlciA9IGxpbmtlZC5nZXQoJ3JlY2VpdmVyJywge30pXG5cbiAgdXNlci5yZWNlaXZlciA9IHtcbiAgICB2b2x1bWU6IGxpbmtlZHJlY2VpdmVyLmdldCgndm9sdW1lJywgMSksXG4gICAgbWVkaWE6IGxpbmtlZHJlY2VpdmVyLmdldCgnbWVkaWEnLCBmYWxzZSksXG4gICAgcGxheWluZzogbGlua2VkcmVjZWl2ZXIuZ2V0KCdwbGF5aW5nJywgZmFsc2UpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2VsZWN0UmVjZWl2ZXIodXNlciwgbGlzdCkge1xuICAvLyBjb25zb2xlLmVycm9yKCdcXG5cXG49PT09PT09PT09PT09PT09PT09PT09PT09c2VsZWN0UmVjZWl2ZXIhISFcXG5cXG4nKVxuICB3aGlsZShsaXN0ICYmIGxpc3QuX190ID09PSA0ICYmICFsaXN0Ll9maWx0ZXIpe1xuICAgIGxpc3QgPSBsaXN0Ll92YWxcbiAgfVxuICBpZighbGlzdCkge1xuICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdjb3VsZCBub3QgZGV0ZXJtaW5lIGxpc3QgdG8gc2VsZWN0IGZyb20nKVxuICB9XG4gIHZhciB3aW5uZXJcbiAgbGlzdC5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGNsaWVudCA9IHRoaXMuX3ZhbFxuICAgIC8vIHNhbml0eSBjaGVja1xuICAgIGlmKCFjbGllbnQgfHwgY2xpZW50Ll9yZW1vdmVkIHx8ICFjbGllbnQuZGV2aWNlKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcignYmFkIGNsaWVudCcsIFxuICAgICAgICAncGF0aDonLCBjbGllbnQgJiYgY2xpZW50Ll9wYXRoLFxuICAgICAgICAnY2xpZW50OicsIGNsaWVudCAmJiBjbGllbnQucmF3IHx8IGNsaWVudFxuICAgICAgKVxuICAgIH1cbiAgICAvLyBza2lwIGlmIGNsaWVudCBpcyB0aGUgYWN0aXZlQ2xpZW50XG4gICAgaWYoY2xpZW50ID09PSB1c2VyLmFjdGl2ZUNsaWVudC5mcm9tKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIGRldmljZSA9IGNsaWVudC5kZXZpY2UudmFsXG4gICAgLy8gc2tpcCBpZiBjbGllbnQgaXMgbm90IGEgY2FuZGlkYXRlXG4gICAgaWYoIWRldmljZUlzQ2FuZGlkYXRlLnRlc3QoZGV2aWNlKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gc2tpcCBpZiBjbGllbnQgaXMgaW4gdXNlIGJ5IG90aGVyIHVzZXJcbiAgICBpZihjbGllbnQudG9rZW4gJiYgY2xpZW50LnRva2VuLnZhbCAhPT0gdXNlci50b2tlbi52YWwpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBjbGllbnQgaXMgYSBwb3NzaWJsZSB3aW5uZXJcbiAgICB3aW5uZXIgPSBjbGllbnRcbiAgICAvLyBzdGljayBpZiBjbGllbnQgaXMgdHYtbGlrZVxuICAgIGlmKGRldmljZUlzVHZMaWtlLnRlc3QoZGV2aWNlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH0pXG4gIC8vIGNvbnNvbGUuZXJyb3IoJ1xcblxcbj09PT09PT09PT09PT09PT09PT09PT09PT0gd2lubmVyOicsd2lubmVyLHVzZXIuY2xvdWQuY2xpZW50aWQsJ1xcblxcbicpXG5cbiAgcmV0dXJuIHdpbm5lclxufVxuXG5mdW5jdGlvbiBncmFiVFYodXNlcil7XG4gIC8vIGNvbnNvbGUuZXJyb3IoJz09PT09PT09PT09PT0gZ3JhYlRWIScpXG4gIHVzZXIuY2FuZGlkYXRlcy5fdmFsLmVhY2goZnVuY3Rpb24oKXtcbiAgICB2YXIgY2FuZGlkYXRlID0gdGhpcy5mcm9tXG4gICAgLy8gY29uc29sZS5lcnJvcignY2FuZGlkYXRlJywgXG4gICAgLy8gICAnZGV2aWNlSXNUdkxpa2UnLCBkZXZpY2VJc1R2TGlrZS50ZXN0KGNhbmRpZGF0ZS5kZXZpY2UudmFsKSxcbiAgICAvLyAgICchY2FuZGlkYXRlLnRva2VuJywgIShjYW5kaWRhdGUudG9rZW4gJiYgY2FuZGlkYXRlLnRva2VuLnZhbCksXG4gICAgLy8gICAnY2FuZGlkYXRlLnRva2VuJywgKGNhbmRpZGF0ZS50b2tlbiAmJiBjYW5kaWRhdGUudG9rZW4udmFsKVxuICAgIC8vIClcbiAgICBpZihjYW5kaWRhdGUuZGV2aWNlLnZhbCA9PT0gJ3R2JyAmJlxuICAgICAgICAhKGNhbmRpZGF0ZS50b2tlbiAmJiBjYW5kaWRhdGUudG9rZW4udmFsKVxuICAgICAgKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdncmFiIGRhdCEnKVxuICAgICAgY2FuZGlkYXRlLnNldCgndG9rZW4nLCB1c2VyLnRva2VuLnZhbClcbiAgICAgIGlmKCF1c2VyLmhhc1JlY2VpdmVyLnZhbCkge1xuICAgICAgICB1c2VyLnNldFJlY2VpdmVyKGNhbmRpZGF0ZSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbi8vIGZ1bmN0aW9uIGxvZygpe1xuLy8gICBjb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXG5cXG5cXG4nKVxuLy8gICBjb25zb2xlLmxvZyh3aW5kb3cuRkxBRywnOicpXG4vLyAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cylcbi8vICAgY29uc29sZS5sb2coJ1xcblxcblxcblxcbi0tLS0tLS0tLS0tLS0tLS0tLS0tJylcbi8vIH1cbi8vIGxvZy5zdGFydCA9IGZ1bmN0aW9uKGZsYWcpe1xuLy8gICBjb25zb2xlLmxvZygnXFxuXFxuXFxuPT09PT09PT09PT09PT09PT09PT09PSBTVEFSVCcsXG4vLyAgICAgd2luZG93LkZMQUcgPyB3aW5kb3cuRkxBRyA6ICcnLCBmbGFnLCAnXFxuXFxuJ1xuLy8gICApXG4vLyB9XG4vLyBsb2cuZW5kID0gZnVuY3Rpb24oZmxhZyl7XG4vLyAgIGNvbnNvbGUubG9nKCdcXG5cXG49PT09PT09PT09PT09PT09PT09PT09IEVORCcsXG4vLyAgICAgd2luZG93LkZMQUcgPyB3aW5kb3cuRkxBRyA6ICcnLCBmbGFnLCAnXFxuXFxuJ1xuLy8gICApXG4vLyB9XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsJylcbnZhciB2T2JqZWN0ID0gcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdCcpXG52YXIgTW9ja0RhdGEgPSByZXF1aXJlKCcuL21vY2tkYXRhJylcblxucmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxuXG4vL25hdiBpcyB0YWtpbmcgY2FyZSBvZjogXG4vLyBkb3VibGUgdXBkYXRlcyBvbiB0aGUgc2FtZSB0aGluZyB3aXRoIHRoZSBzYW1lIHZhbHVlIChzeW5jaW5nIGluIGl0IHRyb3VnaCB0aGUgY2xvdWQpXG4vLyB1cGRhdGluZyBuYXZpZ2F0aW9uXG4vLyBtb2NrIGFuZCB1c2VyIGRhdGEsIHN1YnNjcmlwdGlvbnNcblxuLy9UT0RPOiBhZGQgdmlld1xuXG4vLyBjb250ZW50IGVuIHN3aXRjaCBvcCBjb250ZW50IHBha2tlblxuLy8gICBwYWdlXG4vLyAgIGNvbnRlbnRcbi8vIG9vayBidWJibGU6IDEgb3AgYWxsZSBkaW5nZW5cbi8vIGZ1bmN0aW9uIHVwZGF0ZU5hdmlnYXRpb25cblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZFxuKCBmdW5jdGlvbiggdXNlciApIHtcblxuICB2YXIgY29udGVudCA9IHVzZXIucGFyZW50LmluamVjdChyZXF1aXJlKCcuLi9jb250ZW50JykpLmNvbnRlbnRcblxuICBjb250ZW50Lm9uKCdzZWxmJywgZnVuY3Rpb24oKSB7XG4gICAgdmFyIG5hdiA9IHVzZXIubmF2aWdhdGlvblxuICAgIHZhciBjb250ZW50ID0gdGhpc1xuICAgIHZhciBjb250ZW50TmF2ID0gbmF2LmNvbnRlbnQuZnJvbVxuICAgIHZhciBtaXNjID0gbmF2Lm1pc2MuZnJvbVxuXG4gICAgaWYoY29udGVudE5hdi5fY29udGVudFBhdGgpIHtcbiAgICAgIG5hdi5jb250ZW50LiR1c2VyT3JpZ2luLnZhbCA9IGNvbnRlbnQuZnJvbS5nZXQoY29udGVudE5hdi5fY29udGVudFBhdGgpIC8vRElUIElOIE5BVklHQVRJT05cbiAgICB9XG5cbiAgICBpZihtaXNjLl9jb250ZW50UGF0aCkge1xuICAgICAgbmF2LmNvbnRlbnQuJHVzZXJPcmlnaW4udmFsID0gY29udGVudC5mcm9tLmdldChtaXNjLl9jb250ZW50UGF0aCkgLy9ESVQgSU4gTkFWSUdBVElPTlxuICAgIH1cbiAgfSlcblxuICB1c2VyLmRlZmluZSh7XG4gICAgdXBkYXRlTmF2aWdhdGlvbjogZnVuY3Rpb24oIGtleSApIHtcbiAgICAgIGlmKHRoaXMubmF2aWdhdGlvbi5sYXN0ICYmIHRoaXMubmF2aWdhdGlvbi5sYXN0LiR1c2VyT3JpZ2luKSB7XG4gICAgICAgIGtleSA9IGtleSB8fCB0aGlzLm5hdmlnYXRpb24ubGFzdC4kdXNlck9yaWdpbi5nZXQoJ2tleScpLnZhbFxuICAgICAgICBpZiggdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uW2tleV0uX3VwZGF0ZSggdGhpcy5uYXZpZ2F0aW9uW2tleV0uX3ZhbC5fdmFsICwgJ2wnK01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSo5OTk5KSApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubmF2aWdhdGlvbi5wYWdlLiR1c2VyT3JpZ2luID0gJ2Rpc2NvdmVyJ1xuICAgIH1cbiAgfSlcblxuICB1c2VyLmV4dGVuZCh7XG4gICAgbmF2aWdhdGlvbjoge1xuICAgICAgbW9jazoge1xuICAgICAgICBuYXZpZ2F0aW9uOiBcbiAgICAgICAgeyBjb250ZW50OiBmYWxzZVxuICAgICAgICAsIHBhZ2U6IGZhbHNlIFxuICAgICAgICAsIG1pc2M6IGZhbHNlXG4gICAgICAgICwgbGFzdDogeyBrZXk6ICdwYWdlJywgdGltZTogMCB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgbmF2aWdhdGlvbjogXG4gICAgICAgIHsgY29udGVudDp0cnVlXG4gICAgICAgICwgcGFnZTp0cnVlXG4gICAgICAgICwgbWlzYzogdHJ1ZVxuICAgICAgICAsIGxhc3Q6IFxuICAgICAgICAgIHsga2V5OnRydWVcbiAgICAgICAgICAsIHRpbWU6dHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICB9XG4gICAgICB9LFxuICAgICAgdmFsOiBcbiAgICAgIHsgcGFnZTogeyBkZWZlcjogZGVmZXJOYXZpZ2F0aW9uIH1cbiAgICAgICwgY29udGVudDogeyBkZWZlcjogZGVmZXJOYXZpZ2F0aW9uIH1cbiAgICAgICwgbWlzYzogeyBkZWZlcjogZGVmZXJOYXZpZ2F0aW9uIH1cbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICB1c2VyOiBmdW5jdGlvbiBuYXZpZ2F0aW9uVG9Vc2VyRGF0YSgga2V5ICkge1xuXG4gICAgICAgICAgcmVzb2x2ZUxhc3RMaXN0ZW5lcih0aGlzKVxuICAgICAgICAgIFxuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IHtcbiAgICAgICAgICAgIGxhc3Q6IHRoaXMuZGF0YS5fdmFsLmdldCggWyBrZXksICdsYXN0JyBdIClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fX2ZpcnN0ID0gdHJ1ZVxuXG4gICAgICAgICAgdmFyIG5hdiA9IHRoaXMubmF2aWdhdGlvblxuICAgICAgICAgICAgLCB1c2VyRGF0YSA9IHRoaXMuZGF0YS4kdXNlck9yaWdpblxuXG4gICAgICAgICAgdGhpcy5fbGFzdHVwZGF0ZSA9IGZ1bmN0aW9uIGxhc3RVcGRhdGVVc2VyKCB2YWwsIHN0YW1wLCBmcm9tICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaGV5IHRoaXMgc2hvdWxkIGRvIHRoZSB1cGRhdGUnKVxuXG4gICAgICAgICAgICBpZiggdGhpcy5rZXkgJiYgbmF2W3RoaXMua2V5LnZhbF0gKSAgXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2hleSB0aGlzIHNob3VsZCBkbyB0aGUgdXBkYXRlITEnKVxuXG4gICAgICAgICAgICAgIG5hdlt0aGlzLmtleS52YWxdLiR1c2VyT3JpZ2luLl91cGRhdGUoIHZvaWQgMCwgJ2wnK3N0YW1wICApXG4gICAgICAgICAgICAgIG5hdi51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5hdi5sYXN0LmZyb20ub24odGhpcy5fbGFzdHVwZGF0ZSlcblxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0tFWScsa2V5KVxuICAgICAgICAgIC8vIGRlYnVnZ2VyXG5cbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSBcbiAgICAgICAgICB7IHBhZ2U6IHVzZXJEYXRhLmdldCggWyBrZXksICdwYWdlJyBdLCAnZGlzY292ZXInICkgXG4gICAgICAgICAgLCBjb250ZW50OiB1c2VyRGF0YS5nZXQoIFsga2V5LCAnY29udGVudCcgXSApXG4gICAgICAgICAgLCBtaXNjOiB1c2VyRGF0YS5nZXQoIFsga2V5LCAnbWlzYycgXSApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYobmF2Lmxhc3QuZnJvbS5rZXkpIHtcbiAgICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgICAgICBuYXYubGFzdC5mcm9tLl91cGRhdGUoIHZvaWQgMCwgdk9iamVjdC5zdGFtcCgpIClcbiAgICAgICAgICB9IGVsc2UgaWYoIW5hdi5sYXN0LmZyb20ua2V5KSB7XG4gICAgICAgICAgICAvL25vIHBhZ2Ugc3dpdGNoIHRvIGRlZmF1bHQgKCBtYWtlIGEgZGVmYXVsdCBwb3NzaWxiZSApXG4gICAgICAgICAgICBuYXYucGFnZS4kdXNlck9yaWdpbiA9ICdkaXNjb3ZlcidcbiAgICAgICAgICB9XG5cbiAgICAgICAgfSxcbiAgICAgICAgbW9jazogZnVuY3Rpb24gbmF2aWdhdGlvblRvTW9ja0RhdGEoKSB7XG5cbiAgICAgICAgICByZXNvbHZlTGFzdExpc3RlbmVyKHRoaXMpXG4gICAgXG4gICAgICAgICAgdmFyIG5hdiA9IHRoaXMubmF2aWdhdGlvblxuXG4gICAgICAgICAgIHZhciBtb2NrID0gdGhpcy5tb2NrZGF0YS5uYXZpZ2F0aW9uXG4gICAgICAgICAgICAsIHNldCA9IFxuICAgICAgICAgICAgICB7IHBhZ2U6IG1vY2sucGFnZVxuICAgICAgICAgICAgICAsIGNvbnRlbnQ6IG1vY2suY29udGVudFxuICAgICAgICAgICAgICAsIG1pc2M6IG1vY2subWlzY1xuICAgICAgICAgICAgICAvLyAsIGxhc3Q6IG1vY2subGFzdCBcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0geyBsYXN0OiBtb2NrLmxhc3QgfVxuXG4gICAgICAgICAgLy9UT0RPOiB0aGlzIGlzIGEgdGVtcCBmaXggc2hvdWxkIGdvIGJhY2sgdG8gcGFnZSB5b3UgbG9nb3V0IGZyb20hXG4gICAgICAgICAgaWYodGhpcy5fX2ZpcnN0KSB7XG4gICAgICAgICAgICBtb2NrLnBhZ2UudmFsID0gJ2Rpc2NvdmVyJ1xuICAgICAgICAgIH0gXG4gICAgXG4gICAgICAgICAgdGhpcy5fbGFzdHVwZGF0ZSA9IGZ1bmN0aW9uIGxhc3RVcGRhdGVNb2NrKCB2YWwsIHN0YW1wLCBmcm9tICkge1xuICAgICAgICAgICAgaWYoIG5hdlt0aGlzLmtleS52YWxdICkgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG5hdlt0aGlzLmtleS52YWxdLiR1c2VyT3JpZ2luLl91cGRhdGUoIHZvaWQgMCwgJ2wnK3N0YW1wICApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmF2Lmxhc3QuZnJvbS5vbiggdGhpcy5fbGFzdHVwZGF0ZSApXG4gICAgICAgICAgLy8gdmFyIG5hdiA9IGhvZSBrb20gaWsgaGllciBhYW4gbW4gdXNlcj8/P1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJz8/Pz8/Jyx0aGlzLnRva2VuLl9sdmFsLCB0aGlzLnRva2VuLnZhbClcbiAgICAgICAgICAvLyBuZWVkIHRvIHVzZSBzZXR0ZXIgKG5vdCBuYXYgcmVmKVxuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IHNldFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGZ1bmN0aW9uIHJlc29sdmVMYXN0TGlzdGVuZXIoIHVzZXIgKSB7XG4gICAgaWYoIHVzZXIuX2xhc3R1cGRhdGUgXG4gICAgICAgICYmIHVzZXIubmF2aWdhdGlvbi5sYXN0IFxuICAgICAgICAmJiB1c2VyLm5hdmlnYXRpb24ubGFzdC5mcm9tICE9PSB1c2VyLm5hdmlnYXRpb24ubGFzdFxuICAgICApe1xuICAgICAgdXNlci5uYXZpZ2F0aW9uLmxhc3QuZnJvbS5yZW1vdmVMaXN0ZW5lcih1c2VyLl9sYXN0dXBkYXRlKVxuICAgICAgdXNlci5fbGFzdHVwZGF0ZSA9IG51bGxcbiAgICAgfVxuICB9ICAgICAgXG5cbiAgZnVuY3Rpb24gZGVmZXJOYXZpZ2F0aW9uKCB1cGRhdGUsIGFyZ3MgKSB7XG4gICAgaWYoIGFyZ3NbMV0gJiYgYXJnc1sxXVswXSA9PT0gJ2wnICYmIFxuICAgICAgdGhpcy5fbmFtZSA9PT0gdGhpcy5fcGFyZW50Lmxhc3QuZnJvbS5rZXkudmFsXG4gICAgKSB7XG5cbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAvL1RPRE86IG1vcmUgc3BlY2lmaWMgbWF5IGJlIHRvbyBtYW55IHVwZGF0ZXM/Pz9cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdsZXp6IHVwZGF0ZSBpdCcsIHRoaXMuX3BhcmVudC5fcGF0aCwgdGhpcy5fcGF0aClcblxuICAgICAgdXBkYXRlKClcblxuICAgICAgLy8gdGhpcy5fcGFyZW50Ll91cGRhdGUuYXBwbHkoIHRoaXMuX3BhcmVudCwgYXJncyApXG5cblxuICAgIH0gXG4gICAgZWxzZSBcbiAgICB7XG4gICAgICB1cGRhdGUoIHRydWUgKVxuICAgIH1cbiAgfSBcblxufSlcbiIsIi8vdXNlck9yaWdpblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBNb2NrRGF0YSA9IHJlcXVpcmUoJy4vbW9ja2RhdGEnKVxuICAsIHRpbWVzdGFtcCA9IHJlcXVpcmUoJ21vbm90b25pYy10aW1lc3RhbXAnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKCBmdW5jdGlvbiggdk9iamVjdCApIHtcblxuICB2YXIgX2NvcmVTZXQgPSB2T2JqZWN0LnNldFxuICAgICwgX2Zyb21Vc2VyID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgICAgICAgdmFyIHZhbCA9IG9ialxuICAgICAgICAgICwgbmF2XG4gICAgICAgICAgLCBsYXN0XG5cbiAgICAgICAgd2hpbGUgKHZhbCAmJiAhdmFsLl9yZW1vdmVkICYmIHZhbCBpbnN0YW5jZW9mIHZPYmplY3QpIHtcblxuICAgICAgICAgIGlmKCB2YWwuX3BhcmVudCAmJiB2YWwuX3BhcmVudC5fcHJvcCAmJiB2YWwuX3BhcmVudC5fcHJvcC5uYW1lID09PSAnbmF2aWdhdGlvbicgKSB7XG4gICAgICAgICAgICBuYXYgPSB2YWxcbiAgICAgICAgICB9IFxuXG4gICAgICAgICAgaWYoICggdmFsLmNsb3VkICYmIHZhbC5fcGF0aFswXSA9PT0gJ3VzZXJzJyApIFxuICAgICAgICAgICAgICB8fCB2YWwgaW5zdGFuY2VvZiBNb2NrRGF0YSBcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIFsgdmFsLCBuYXYgXVxuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0ID0gdmFsO1xuICAgICAgICAgIHZhbCA9IHZhbC5fdmFsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGxhc3QgJiYgIWxhc3QuX3JlbW92ZWQgJiYgbGFzdCAhPT0gb2JqXG4gICAgICAgICAgPyBsYXN0IFxuICAgICAgICAgIDogZmFsc2VcblxuICAgICAgICByZXR1cm4gWyByZXN1bHQsIG5hdiBdXG5cbiAgICAgIH1cblxuICB1dGlsLmRlZmluZSggdk9iamVjdCwgXG4gICAgJyR1c2VyT3JpZ2luJywge1xuICAgIHNldDogZnVuY3Rpb24oIHZhbCApIHtcblxuICAgICAgdmFyIHNlYXJjaCA9IF9mcm9tVXNlcih0aGlzKVxuICAgICAgICAsIGZvdW5kID0gc2VhcmNoWzBdIC8vfHwgdGhpc1xuICAgICAgICAsIG5hdiA9IHNlYXJjaFsxXVxuICAgICAgICAsIHNhbWVcblxuICAgICAgaWYoIWZvdW5kKSB7XG4gICAgICAgIHZhciBwcm9wbmFtZSA9IHRoaXMuX3Byb3AgJiYgdGhpcy5fcHJvcC5uYW1lXG5cbiAgICAgICAgaWYocHJvcG5hbWUpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCc+Pj4+Pj4+PiBtYWtpbmcgYW5kIGxpbmtpbmcnLCBwcm9wbmFtZSlcblxuICAgICAgICAgIHZhciB1c2VyID0gdGhpcy5fY2FsbGVyLFxuICAgICAgICAgICAgbGlua2VkdXNlciA9IHVzZXIuZGF0YS5fdmFsXG5cbiAgICAgICAgICBpZighbGlua2VkdXNlcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignPz8/PycsIHZhbClcbiAgICAgICAgICAgIGRlYnVnZ2VyXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm91bmQgPSBsaW5rZWR1c2VyLmdldChwcm9wbmFtZSwge30pXG4gICAgICAgICAgdGhpcy52YWwgPSBmb3VuZFxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdGT1VORCcsIHRoaXMuX3Byb3AgJiYgdGhpcy5fcHJvcC5uYW1lLCBmb3VuZC5fcGF0aCwgZm91bmQucmF3LCBmb3VuZClcbiAgICAgIH1cblxuICAgICAgaWYoIWZvdW5kKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignbm8gdXNlciBidXQgZG8gZnJvbScpXG4gICAgICAgIC8vIHJldHVybiBfY29yZVNldCggdGhpcy5mcm9tLCB2YWwgKVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGZpbmQgY29ycmVjdCAkdXNlck9yaWdpbiBmb3IgJysgKCB0aGlzLl9uYW1lIHx8IHRoaXMuX3Byb3AgJiYgJ3Byb3BldHkgJyt0aGlzLl9wcm9wLm5hbWUgKSApXG4gICAgICB9XG5cbiAgICAgIF9jb3JlU2V0LmNhbGwoIGZvdW5kICwgdmFsKVxuXG4gICAgICBpZihuYXYgJiYgbmF2Ll9uYW1lICkge1xuICAgICAgICBuYXYuX3BhcmVudC5sYXN0LmZyb20udmFsID0gXG4gICAgICAgIHsgdGltZTogdGltZXN0YW1wKClcbiAgICAgICAgLCBrZXk6IG5hdi5fbmFtZVxuICAgICAgICB9XG4gICAgICB9IFxuXG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9mcm9tVXNlciggdGhpcyApWzBdIC8vfHwgdGhpc1xuICAgIH1cbiAgfSlcbn0pIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIHVzZXIgPSByZXF1aXJlKCcuLycpXG4gICwgdk9iaiA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoIFxuZnVuY3Rpb24oIGJhc2UgKSB7XG5cbiAgZnVuY3Rpb24gc2V0VXNlcihpKSB7XG4gICAgLy9tYWtlIHRoZXNlIDIgbW9yZSBkZWZ1YWx0XG4gICAgLy8gY29uc29sZS5sb2coaSlcbiAgICAvLyBjb25zb2xlLmxvZyggJ3N3dGljaCB0byB1c2VyJywgaSwgdGhpcy5kYXRhLl92YWwgKVxuICAgIHRoaXNbaV0gPSB0aGlzLmRhdGEuJHVzZXJPcmlnaW4uZ2V0KCBpLCB0aGlzW2ldLl9wcm9wLiRkZWZhdWx0IClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldE1vY2soaSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCAnc3d0aWNoIHRvIG1vY2snLCBpLCB0aGlzLm1vY2tkYXRhW2ldIClcbiAgICB0aGlzW2ldID0gdGhpcy5tb2NrZGF0YVtpXVxuICB9XG5cbiAgYmFzZS5kZWZpbmUoe1xuICAgIF9zZXQ6IGZ1bmN0aW9uKHZhbCwgaSApIFxuICAgIHtcbiAgICAgIGlmICggdGhpc1tpXSBpbnN0YW5jZW9mIHZPYmogKSBcbiAgICAgIHtcbiAgICAgICAgLy9UT0RPOiB0b3JvdWdoIHRlc3RpbmdcbiAgICAgICAgdGhpc1tpXS52YWwgPSB2YWxbaV1cbiAgICAgIH0gXG4gICAgICBpZiAodHlwZW9mIHRoaXNbaV0gPT09ICdmdW5jdGlvbicpIFxuICAgICAge1xuICAgICAgICBpZiAodmFsW2ldIGluc3RhbmNlb2YgQXJyYXkpIFxuICAgICAgICB7XG4gICAgICAgICAgdGhpc1tpXS5hcHBseSh0aGlzLHZhbFtpXSlcbiAgICAgICAgfSBlbHNlIFxuICAgICAgICB7XG4gICAgICAgICAgdGhpc1tpXSh2YWxbaV0pXG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICBlbHNlIFxuICAgICAge1xuICAgICAgICBpZiAoIHRoaXMuaXNQcm9wZXJ0eSggaSwgdmFsICkgKSB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCd0aGlzIGlzIGEgcHJvcGVydHkhJywgaSAsIHZhbCApXG4gICAgICAgICAgdGhpc1tpXSA9IHZhbFtpXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKCB0aGlzW2ldICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gbWVyZ2U/IGNoZWNrIG9vayB2b29yIGNsb3VkIGJpanZvb3JiZWVsZFxuICAgICAgICAgICAgdGhpc1tpXSA9IHZhbFtpXVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ05PVyBMRVRTIE1BS0UgQSBCQVNJQyBUWVBFJywgaSwgdGhpcylcblxuICAgICAgICAgICAgdmFyIG1vY2sgPSB7fVxuXG4gICAgICAgICAgICBtb2NrW2ldID0gdmFsW2ldXG5cbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb24gPSB7fVxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uW2ldID0gdHJ1ZVxuXG4gICAgICAgICAgICAvLyB0aGlzLm1vY2tkYXRhID0gbW9ja1xuXG4gICAgICAgICAgICB0aGlzLmV4dGVuZCh7XG4gICAgICAgICAgICAgIG5hbWU6aVxuICAgICAgICAgICAgLCBtb2NrOiBtb2NrXG4gICAgICAgICAgICAsICRkZWZhdWx0OiB2YWxbaV1cbiAgICAgICAgICAgICwgc3Vic2NyaXB0aW9uOiBzdWJzY3JpcHRpb24gLy9tYXliZSBkbyB0aGlzIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICAgICwgb246IHtcbiAgICAgICAgICAgICAgICBtb2NrOiBzZXRNb2NrXG4gICAgICAgICAgICAgICwgdXNlcjogc2V0VXNlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAvL2RpdCBiZXRlci0tLS0gbW9ldCBuYW1lbGlqayBuaWV0IHZhbFtpXSB3b3JkZW4gbWFhciBtb2NrZGF0YSAob2YgbWV0ZWVuIHN3aXRjaGVuIG5hYXIgdXNlckRhdGEpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgXG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaGV5JywgaSwgdGhpc1tpXSApXG4gICAgICAgIFxuICAgICAgfVxuICAgIH1cbiAgfSlcblxufSkiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUnKVxuICAsIGNhc2VzID0gcmVxdWlyZSgnLi4vLi4vYnJvd3Nlci9jYXNlcycpXG5cbnJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxuXG4vL1RPRE86IHVybCBlcnJvciBvbiBzdGFydCB1cCAoc2V0IGZyb20gY2xvdWQpXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kXG4oIGZ1bmN0aW9uKCBiYXNlICkge1xuXG4gIGJhc2UuZGVmaW5lKHtcbiAgICB1cGRhdGVJZDogZnVuY3Rpb24oIHJlcyApIHtcbiAgICAgIHRoaXMuaWQgPSByZXMgaW5zdGFuY2VvZiBBcnJheSA/IHJlc1sgcmVzLmxlbmd0aCAtMSBdIDogcmVzXG4gICAgICBcbiAgICAgIC8vaGllciBmZiB2b29yIG5hdmlnYXRpb25cbiAgICAgIC8vZ2V0IGxhc3Q/XG4gICAgfVxuICAsIGF1dGhlbnRpY2F0ZTogZnVuY3Rpb24gYXV0aGVudGljYXRlKCBfdGhpcywgcmVxdWVzdCwgdmFsLCB1cGRhdGUgKSB7XG4gICAgICB2YXIgdXNlciA9IHRoaXNcbiAgICAgICAgLCBjbG91ZCA9IHVzZXIuY2xvdWRcblxuICAgICAgaWYoY2xvdWQucGFyYW1zLmZhc3RMb2dpbiAmJiB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgdmFyIHVzZXJJZCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd1c2VySWQnKVxuICAgICAgICBpZih1c2VySWQpe1xuICAgICAgICAgIHJlcXVlc3QuaWQgPSB1c2VySWRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coJ2dvIGNsb3VkLmF1dGhlbnRpY2F0ZSEhJylcbiAgICAgIGNsb3VkLmF1dGhlbnRpY2F0ZSggcmVxdWVzdCwgZnVuY3Rpb24oIHJlcyApIHtcbiAgICAgICAgXG4gICAgICAgIGlmKHJlcy5lcnJvciAmJiB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcklkJylcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jbGVhckNhY2hlKClcblxuICAgICAgICBpZih2YWwgIT09IF90aGlzLnZhbCl7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignXFxuXFxuXFxuZGlkIGEgZmFzdCByZS1sb2dpbiEgLS0gZG91YmxlIGNoZWNrJylcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCByZXMuZXJyb3IgfHwgIV90aGlzLnZhbCApe1xuICAgICAgICAgIF90aGlzLnZhbCA9IGZhbHNlXG4gICAgICAgICAgdXNlci5pZCA9IGZhbHNlXG4gICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgICBpZiggcmVzLmVycm9yICl7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhdXRoZW50aWNhdGUgZXJyb3I6JywgcmVzLmVycm9yKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgaWYoISAodXNlci5pcGxvZ2luICYmIHVzZXIuaXBsb2dpbi52YWwpICl7XG4gICAgICAgICAgICAgIHVzZXIuY2xvdWQuZW1pdCgnbG9nb3V0JywgcmVzIClcblxuICAgICAgICAgICAgICBpZih0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiICl7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXJJZCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd0b2tlbiBpcyBzZXQgdG8gZmFsc2Ugd2hpbGUgYXV0aGVudGljYXRpbmcgKGxvZ291dCEgLS0gbmVlZCB0byBnZXQgYSBtZXRob2QgdG8gYnJlYWsgaXQgd2hpbGUgaW4gcHJvZ3Jlc3MpJylcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdBVVRIIFNVQzYnLCB1c2VyLCByZXMgKVxuICAgICAgICAgIC8vZGl0IGlzIG9vayB3cm9uZyBjb21wbGV0ZWx5ISAtLSBkaXQgYWxsZWVuIGRvZW4gbWV0IGVlbiB1c2VydG9rZW4hISEhXG4gICAgICAgICAgLy8gYW5kZXJzIHdhY2h0ZW4gdG90IGVlbiBvdmVydGFrZSBhY3RpZVxuICAgICAgICAgIGlmKCBfdGhpcy52YWwgIT09IHRydWUgKSB7XG4gICAgICAgICAgICB1c2VyLnVwZGF0ZUlkKCByZXMgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKGNsb3VkLnBhcmFtcy5mYXN0TG9naW4gJiYgdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICB2YXIgdXNlcklkXG4gICAgICAgICAgICBpZihyZXMgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgICAgICAgdXNlcklkID0gcmVzW3Jlcy5sZW5ndGgtMV1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdXNlcklkID0gcmVzXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgndXNlcklkJywgdXNlcklkKSAgXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYodXNlci5pcGxvZ2luICYmIHVzZXIuaXBsb2dpbi52YWwpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdUViBMT0dJTiBTVUNDRVNTISBtYXliZSBnbyBtYWtlIG1hc2VsZiBkYXQgdXNlcicpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnPj4+IHRva2VuJywgdXNlci50b2tlbi52YWwpXG4gICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG4gIFxuICAvLyBjb25zb2xlLmxvZygnPz8/Pz8/Pz8/Pz8/PyBzZXQgaXBsb2dpbicsIGNhc2VzLiRpc1R2IHx8IGNhc2VzLiRpc0Nocm9tZWNhc3QpXG4gIC8vIGJhc2UuaXBsb2dpbiA9IGNhc2VzLiRpc1R2IHx8IGNhc2VzLiRpc0Nocm9tZWNhc3RcbiAgXG4gIGJhc2UuZXh0ZW5kKFxuICB7IC8vcHJpbWFyeVxuICAgIGlwbG9naW46IHsgdmFsOiBjYXNlcy4kaXNUdiB8fCBjYXNlcy4kaXNDaHJvbWVjYXN0IH0sXG4gICAgdG9rZW46e1xuICAgICAgLy8gVE9ETzogd2hlbiBJUCBiYXNlZCBjb25uZWN0aXZpdHkgaXMgZml4ZWQgdGhpcyBpcyBub3QgbmVlZGVkXG4gICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgdG9rZW46IHRydWVcbiAgICAgIH0sXG4gICAgICB2YWw6e1xuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCB2YWwsIGN2ICkge1xuICAgICAgICAgIHJldHVybiAoIGN2IGluc3RhbmNlb2YgT2JqZWN0ICkgPyBmYWxzZSA6IGN2XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmVyOmZ1bmN0aW9uKCB1cGRhdGUsIGFyZ3MsIHRlbXBkZWZlciApIHtcblxuICAgICAgICAgIGlmKGFyZ3NbMF0gJiYgYXJnc1swXS5kZWZlcikgcmV0dXJuIHRydWVcblxuICAgICAgICAgIHZhciB0b2tlbiA9IHRoaXNcbiAgICAgICAgICB2YXIgdXNlciA9IHRva2VuLl9jYWxsZXJcblxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1RPS0VOIFNFVCF4eHgnLCB0b2tlbilcblxuICAgICAgICAgIHVzZXIuY2xvdWQuY29ubmVjdGVkLmlzKHRydWUsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG9sZHZhbCA9IGFyZ3NcbiAgICAgICAgICAgICAgLCB2YWwgPSB0b2tlbi52YWxcbiAgICAgICAgICAgICAgLCB1c2VySWQgPSB1c2VyLmlkICYmIHVzZXIuaWQudmFsXG4gICAgICAgICAgICAgICwgaXBsb2dpbiA9IHVzZXIuaXBsb2dpbiAmJiB1c2VyLmlwbG9naW4udmFsXG5cbiAgICAgICAgICAgIC8vIGlmKCB1c2VyLmlwbG9naW4gJiYgdXNlci5pcGxvZ2luLnZhbCApe1xuICAgICAgICAgICAgLy8gICBpcGxvZ2luID0gdHJ1ZVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy9ET1VCTEUgQ0hFQ0sgLS0tIHRoaXMgd2FzIGluIHRoZXJlIHRvIGFsbHdheXMgbWFrZSBzdXJlIHRoaXMgc3R1ZmYgZGlkIG5vdCBoYXBwZW4uLi5cbiAgICAgICAgICAgIC8vIGlmKCB1c2VyLmFjdGl2ZUNsaWVudCAmJiB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiAmJiB1c2VyLmFjdGl2ZUNsaWVudC5mcm9tID09PSB1c2VyLmNsaWVudC5mcm9tICApIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ21jIGRpcnR5IGxldHMgZml4IHRoaXMgaGVyZSEgb24gbG9nb3V0IHNldCBmYWxzZSB0byBiZSBjZXJ0YWluJywgdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gKVxuICAgICAgICAgICAgICAvLyB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiA9IGZhbHNlXG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIHRva2VuLmNsZWFyQ2FjaGUoKVxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd0b2tlbiBpcyBzZXQhJywgdmFsKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Rva2VuIGlzIHNldCEnLCBpcGxvZ2luKVxuXG4gICAgICAgICAgICBpZiggdXNlcklkICYmICFpcGxvZ2luICl7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdMT0dPVVQgLS0tPiBFTUlUJy5yZWQuaW52ZXJzZSwgdXNlcklkIClcbiAgICAgICAgICAgICAgdmFyIF9sYXN0ID0gdXNlci5jbG91ZC5sb2dvdXQoIHVzZXJJZCApXG4gICAgICAgICAgICAgIGlmKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VySWQnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCB2YWwgKXtcblxuICAgICAgICAgICAgICB2YXIgdXJsID0gdXNlci5jbG91ZC5hcGkuZ2V0KCdhdXRoJylcblxuICAgICAgICAgICAgICB2YXIgcmVxdWVzdCA9IFxuICAgICAgICAgICAgICB7IHVybDogdXJsXG4gICAgICAgICAgICAgICwgc3ViczogdXNlci5zdWJzY3JpcHRpb25zXG4gICAgICAgICAgICAgICwgdG9rZW46IHZhbFxuICAgICAgICAgICAgICAvL1RPRE86IGFsc28gYWRkIHR2XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLCBhdXRoID0gdXNlci5fX2F1dGhlbnRpY2F0ZWRfX1xuXG4gICAgICAgICAgICAgIGlmKCBpcGxvZ2luICl7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbGwgdHYgdmliZXNcbiAgICAgICAgICAgICAgICBpZiggdmFsID09PSB0cnVlICkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3QudG9rZW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdC50diA9IHRydWVcblxuICAgICAgICAgICAgICAgIGlmKCAhYXV0aCApe1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0lQTE9HSU4gRklSU1QgVElNRSBQT1AgREFUIEFVVEhFTlRJQ0FURScpXG4gICAgICAgICAgICAgICAgICB1c2VyLl9hdXRocmVxdWVzdCA9IHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgIHVzZXIuYXV0aGVudGljYXRlKCB0b2tlbiwgcmVxdWVzdCwgdmFsLCB1cGRhdGUgKVxuICAgICAgICAgICAgICAgICAgdXNlci5fX2F1dGhlbnRpY2F0ZWRfXyA9IHRydWVcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIHZhciB1c2VycyA9IHVzZXIuY2xvdWQuZGF0YS5nZXQoJ3VzZXJzJylcbiAgICAgICAgICAgICAgICAgICAgLCBzZXRcblxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignSVBMT0dJTiBVU0VSU1dJVENIJylcbiAgICAgICAgICAgICAgICAgIC8vIGZpbmQgdGhlIHVzZXIgSSBzaG91bGQgc3dpdGNoIHRvXG4gICAgICAgICAgICAgICAgICB1c2Vycy5lYWNoKGZ1bmN0aW9uKCBrZXkgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJz4+IEhBVkUgVVNFUicsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbG91ZHVzZXIgPSB0aGlzXG5cbiAgICAgICAgICAgICAgICAgICAgaWYoY2xvdWR1c2VyLnRva2VuICYmIGNsb3VkdXNlci50b2tlbi52YWwgPT09IHRva2VuLnZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGltIHN3aXRjaGluZyB0byB0aGlzIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICBzZXQgPSBjbG91ZHVzZXIuX25hbWVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc3dpdGNoIHRvIHRoaXMgdXNlcnQhJylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZihcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3VkdXNlci5yZWNlaXZlckNsaWVudCAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3VkdXNlci5yZWNlaXZlckNsaWVudC5mcm9tID09PSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICApe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcigndGhpcyBvdGhlciB1c2VyIGhhcyBtZSBhcyByZWNlaXZlckNsaWVudCwgYmV0dGVyIHJlbW92ZScpXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG91ZHVzZXIucmVjZWl2ZXJDbGllbnQuJHVzZXJPcmlnaW4gPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmKGNsb3VkdXNlci5hY3RpdmVDbGllbnQgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG91ZHVzZXIuYWN0aXZlQ2xpZW50LmZyb20gPT09IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd0aGlzIG90aGVyIHVzZXIgaGFzIG1lIGFzIHJlY2VpdmVyQ2xpZW50LCBiZXR0ZXIgcmVtb3ZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3VkdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4gPSBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgaWYoIXNldCkge1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmlkID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICB1c2VyLmlkID0gc2V0XG5cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB1c2VyLl9hdXRocmVxdWVzdCA9IHJlcXVlc3RcbiAgICAgICAgICAgICAgICB1c2VyLmF1dGhlbnRpY2F0ZSggdG9rZW4sIHJlcXVlc3QsIHZhbCwgdXBkYXRlIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHVzZXIuaWQgPSBmYWxzZVxuICAgICAgICAgICAgICB1cGRhdGUoKSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBsb2NhbFN0b3JhZ2VUb2tlbjoge1xuICAgICAgdmFsOiB7XG4gICAgICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSwgYXJncykge1xuICAgICAgICAgIHZhciB1c2VyID0gdGhpcy5fY2FsbGVyXG4gICAgICAgICAgaWYoIXVzZXIuX3JlYWRMb2NhbFN0b3JhZ2UgJiYgdHlwZW9mIHRoaXMudmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdXNlci5fcmVhZExvY2FsU3RvcmFnZSA9IHRoaXMudmFsXG4gICAgICAgICAgICB2YXIgdG9rZW4gPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSh1c2VyLl9yZWFkTG9jYWxTdG9yYWdlKVxuICAgICAgICAgICAgaWYodG9rZW4gJiYgdG9rZW4gIT09ICd0cnVlJykge1xuICAgICAgICAgICAgICB1c2VyLnRva2VuID0gdG9rZW5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZXIudG9rZW4ub24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciB0b2tlbnZhbCA9IHRoaXMudmFsXG4gICAgICAgICAgICAgIGlmKHR5cGVvZiB0b2tlbnZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh1c2VyLl9yZWFkTG9jYWxTdG9yYWdlLCB0b2tlbnZhbClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh1c2VyLl9yZWFkTG9jYWxTdG9yYWdlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlKHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIC8vIGJhc2UudG9rZW4gPSBmYWxzZVxuXG4gIGJhc2UuY2FzZXMuJGlzTG9nZ2VkSW4gPSBuZXcgVmFsdWUoXG4gIHsgdmFsOiBiYXNlLnRva2VuXG4gICwgdHJhbnNmb3JtOmZ1bmN0aW9uKHZhbCwgY3YpIHtcbiAgICAgIGlmKGN2ID09PSB0cnVlKSByZXR1cm4gMFxuICAgIH1cbiAgfSlcblxuICB2YXIgbXljbGllbnQgPSBiYXNlLmNsb3VkLmNsaWVudFxuXG4gIG15Y2xpZW50Lm9uKGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20pe1xuICAgIC8vIGNvbnNvbGUubG9nKCdzb21ldGhpbmcgaGFwcGVuZWQgb24gbXkgY2xvdWQgY2xpZW50IScpXG4gICAgb3JpZ2luID0gZnJvbSB8fCB0aGlzLl91cGRhdGVPcmlnaW5cbiAgICBpZihzdGFtcCA9PT0gYmFzZS5jbG91ZC5zdGFtcCkge1xuICAgICAgdmFyIGNsb3VkY2xpZW50ID0gbXljbGllbnQuZnJvbVxuICAgICAgaWYoY2xvdWRjbGllbnQudG9rZW4pe1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0gdG9rZW4gb24gdXNlciBpcyBub3cnLCBiYXNlLnRva2VuLnZhbCwgJ3NldCB3aXRoJywgY2xvdWRjbGllbnQudG9rZW4udmFsKVxuICAgICAgICBiYXNlLnRva2VuLnZhbCA9IGJhc2UuX2F1dGhyZXF1ZXN0LnRva2VuID0gY2xvdWRjbGllbnQudG9rZW4udmFsXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tIGRpZCBzZXQgdG9rZW4gb24gdXNlcicpXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIGJhc2UudG9rZW4uX25hbWUgPSAndG9rZW4nXG5cbn0pXG5cblxuXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UnKVxuICAsIFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUnKS8vLm5ldygpXG4gICwgb2JqZWN0U2V0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0Jykuc2V0XG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG4vLyBWYWx1ZS5pbmplY3QocmVxdWlyZSgnLi9saXN0ZW5fZml4JykpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB0eXBlOiBWYWx1ZSxcbiAgY3JlYXRlOiBmdW5jdGlvbih2YWwsIHByb3AsIHNldHRpbmdzLCBub3VwZGF0ZSkge1xuXG4gICAgLy8gY29uc29sZS5sb2coJ2NyZWF0ZSBpdCcsIHZhbCwgc2V0dGluZ3MgKVxuICAgIHZhciB2ID0gbmV3IFZhbHVlKClcbiAgICB2Ll9iYXNlID0gdGhpc1xuICAgIHYuX2NhbGxlciA9IHYuX2Jhc2VcbiAgICB2Ll9wcm9wID0gc2V0dGluZ3NcbiAgICAvLyBjb25zb2xlLmxvZygnc2V0JylcbiAgICBvYmplY3RTZXQuY2FsbCh2LCB2YWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSlcbiAgICAvLyBjb25zb2xlLmxvZygnZG9uZSBzZXR0aW5nJylcbiAgICBpZiAodGhpcy5fY2xhc3MpIHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fW3NldHRpbmdzLm5hbWVdID0gdlxuICAgIGlmIChzZXR0aW5ncykge1xuXG4gICAgICBpZiAoIXNldHRpbmdzLl92c2V0KSB7XG5cbiAgICAgICAgLy9jYW4gYWxzbyBhZGQgYSB0aGluZyB0byBzZXQgb24gZ2V0IGJ5IGRlZmF1bHQ/XG5cbiAgICAgICAgaWYoc2V0dGluZ3MubW9jaykge1xuICAgICAgICAgIC8vaWYgbm90IHNldCBhZGQgc29tZSBlZmZpY2llbmN5IHBselxuICAgICAgICAgIHRoaXMubW9ja2RhdGEgPSBzZXR0aW5ncy5tb2NrXG4gICAgICAgIH1cblxuICAgICAgICBpZihzZXR0aW5ncy5zdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBzZXR0aW5ncy5zdWJzY3JpcHRpb25cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNldHRpbmdzLm9uKSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiBzZXR0aW5ncy5vbiA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgIHRoaXMub24ubW9ja1tzZXR0aW5ncy5uYW1lXSA9IHNldHRpbmdzLm9uXG4gICAgICAgICAgICB0aGlzLm9uLnVzZXJbc2V0dGluZ3MubmFtZV0gPSBzZXR0aW5ncy5vblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZihzZXR0aW5ncy5vbi5tb2NrICYmICF0aGlzLm9uLm1vY2tbc2V0dGluZ3MubmFtZV0pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYmFzZSwgYmFzZS5vbilcbiAgICAgICAgICAgICAgdGhpcy5vbi5tb2NrW3NldHRpbmdzLm5hbWVdID0gc2V0dGluZ3Mub24ubW9ja1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoc2V0dGluZ3Mub24udXNlciAmJiAhdGhpcy5vbi51c2VyW3NldHRpbmdzLm5hbWVdKSB7XG4gICAgICAgICAgICAgIHRoaXMub24udXNlcltzZXR0aW5ncy5uYW1lXSA9IHNldHRpbmdzLm9uLnVzZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5fdnNldCA9IGZ1bmN0aW9uKHN0YW1wLCBmcm9tLCByZW1vdmUsIGN2YWwpIHtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgYmFzZSA9IHRoaXMuX2NhbGxlclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2Jhc2VcbiAgICAgICAgICAgICAgICB8fCB0aGlzXG5cblxuICAgICAgICAgIC8vaWYgIWJhc2UgLS1cbiAgICAgICAgICAvLyBpZighYmFzZS4pXG5cbiAgICAgICAgICBpZihzZXR0aW5ncy5zZXQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNldC5jYWxsKFxuICAgICAgICAgICAgICBiYXNlLCB0aGlzLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBjdmFsXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghbm91cGRhdGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1VQREFURSBjcmVhdGlvbicpXG4gICAgICAgIHYuX3VwZGF0ZSh2YWwpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odmFsLCBwcm9wLCBzZXR0aW5ncykge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3NldCBpdCcsIHZhbCApXG4gICAgdGhpcy5fY2FsbGVyID0gdGhpc1xuICAgIHJldHVybiB2YWxcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbihwcm9wLCBzZXR0aW5ncykge1xuICAgIGlmIChwcm9wKSBwcm9wLl9jYWxsZXIgPSB0aGlzXG4gICAgaWYgKHNldHRpbmdzLmdldCkgcmV0dXJuIHNldHRpbmdzLmdldC5jYWxsKHRoaXMsIHByb3ApXG4gICAgcmV0dXJuIHByb3BcbiAgfVxufSIsInZhciB1dGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwnKVxuXG52YXIgdk9iamVjdCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QnKVxuXG52YXIgTW9ja0RhdGEgPSByZXF1aXJlKCcuL21vY2tkYXRhJylcblxudmFyIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKVxuXG52YXIgRGF0YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9kYXRhJylcbiAgICAgIC5pbmplY3QoIHJlcXVpcmUoJ3ZpZ291ci1qcy9kYXRhL3NlbGVjdGlvbicpIClcblxuXG5yZXF1aXJlKCd2aWdvdXItanMvdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmRcbiggZnVuY3Rpb24oIHVzZXIgKSB7XG5cbiAgdmFyIGNvbnRlbnQgPSB1c2VyLnBhcmVudC5pbmplY3QocmVxdWlyZSgnLi4vY29udGVudCcpKS5jb250ZW50XG5cbiAgdXNlci5leHRlbmQoe1xuICAgIHVzYWdlOiB7XG4gICAgICBtb2NrOiB7XG4gICAgICAgIHVzYWdlOnt9XG4gICAgICB9LFxuICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgIHVzYWdlOiB7XG4gICAgICAgICAgc2hvd3M6IHtcbiAgICAgICAgICAgICQ6IHtcbiAgICAgICAgICAgICAgbWVkaWE6e1xuICAgICAgICAgICAgICAgIC8vZGl0IG1vZXQgc293aWVzbyBuaWV0IHRpdGxlIHdvcmRlbiEgbGlldmVyIGdld29vbiB0cnVlIG9mIGlkIG9mem9cbiAgICAgICAgICAgICAgICAkOnRydWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZmF2b3VyaXRlOnRydWUsXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDp0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgbW9jazpmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLnVzYWdlID0gdGhpcy5tb2NrZGF0YS51c2FnZVxuICAgICAgICB9LFxuICAgICAgICB1c2VyOmZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudXNhZ2UgPSB0aGlzLmRhdGEuZnJvbS5nZXQoJ3VzYWdlJyx7fSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB3YXRjaGVkOntcbiAgICAgIG9uOiB7XG4gICAgICAgIC8vbWlzY2hpZW4gZWlnZW4gLCBuaWV1d2Ugc2VsZWN0aW9uIG1ha2VuIGFsdmFzdFxuICAgICAgICBtb2NrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZih0aGlzLl9fd2F0Y2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fX3dhdGNoZWQucmVtb3ZlKClcbiAgICAgICAgICAgIHRoaXMuX193YXRjaGVkID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICBpZih0aGlzLndhdGNoZWQpIHRoaXMud2F0Y2hlZC4kZW1wdHkoKVxuICAgICAgICAgIHRoaXMud2F0Y2hlZCA9IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHVzZXI6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIHVzZXIgPSB0aGlzXG4gICAgICAgICAgaWYodGhpcy5fX3dhdGNoZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX193YXRjaGVkLnJlbW92ZSgpXG4gICAgICAgICAgICB0aGlzLl9fd2F0Y2hlZCA9IG51bGxcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fX3dhdGNoZWQgPSBuZXcgRGF0YSggdXNlci51c2FnZS5mcm9tLmdldCgnc2hvd3MnKSAsIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbjogeyBcbiAgICAgICAgICAgICAgbWVkaWE6IHtcbiAgICAgICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICAgICAgJGV4aXN0czogdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgICB1c2VyLndhdGNoZWQgPSB7fVxuXG4gICAgICAgICAgc2VsZWN0aW9uLm9uKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHNldHMgPSB7fVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24uZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgIHZhciBibGEgPSAgY29udGVudC5nZXQodGhpcy5fcGF0aC5zbGljZSgtMikpXG4gICAgICAgICAgICAgIHZhciBvYmogPSB7fVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdXRpbC5wYXRoKG9iaiwgYmxhLl9wYXRoLCB7XG4gICAgICAgICAgICAgICAgaW1nOnRydWUsXG4gICAgICAgICAgICAgICAgdGl0bGU6dHJ1ZVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgdmFyIF9jbG91ZCA9ICB1c2VyLnBhcmVudC5jbG91ZFxuICAgICAgICAgICAgIF9jbG91ZC5zdWJzY3JpYmUob2JqKVxuXG4gICAgICAgICAgICAgIHVzZXIud2F0Y2hlZC5zZXQodGhpcy5fbmFtZSwgXG4gICAgICAgICAgICAgIHsgc2hvdzogYmxhXG4gICAgICAgICAgICAgICwgbWVkaWE6IHRoaXMubWVkaWEuZnJvbVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHVzZXIud2F0Y2hlZFt0aGlzLl9uYW1lXS5vbmNlKCdyZW1vdmUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBfY2xvdWQudW5zdWJzY3JpYmUob2JqKVxuICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgIHNldHNbdGhpcy5fbmFtZV0gPSB0cnVlXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB1c2VyLndhdGNoZWQuZWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIGlmKCFzZXRzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgaWYodXNlci53YXRjaGVkKVxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgc2V0cyA9IGZhbHNlXG5cbiAgICAgICAgICAgIHVzZXIud2F0Y2hlZC51cGRhdGUoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgc2VsZWN0aW9uLl91cGRhdGUoKVxuXG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgfSxcblxuICAgIGZhdm91cml0ZXM6e1xuICAgICAgb246IHtcbiAgICAgICAgLy9taXNjaGllbiBlaWdlbiAsIG5pZXV3ZSBzZWxlY3Rpb24gbWFrZW4gYWx2YXN0XG4gICAgICAgIG1vY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKHRoaXMuX19mYXZvdXJpdGVzKSB7XG4gICAgICAgICAgICB0aGlzLl9fZmF2b3VyaXRlcy5yZW1vdmUoKVxuICAgICAgICAgICAgdGhpcy5fX2Zhdm91cml0ZXMgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRoaXMuZmF2b3VyaXRlcykgdGhpcy5mYXZvdXJpdGVzLiRlbXB0eSgpXG4gICAgICAgICAgdGhpcy5mYXZvdXJpdGVzID0ge31cbiAgICAgICAgfSxcbiAgICAgICAgdXNlcjpmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdXNlciA9IHRoaXNcbiAgICAgICAgICBpZih1c2VyLl9fZmF2b3VyaXRlcykge1xuICAgICAgICAgICAgdXNlci5fX2Zhdm91cml0ZXMucmVtb3ZlKClcbiAgICAgICAgICAgIHVzZXIuX19mYXZvdXJpdGVzID0gbnVsbFxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmZhdm91cml0ZXMuJGVtcHR5KClcbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdXNlci5fX2Zhdm91cml0ZXMgPSBuZXcgRGF0YSggdXNlci51c2FnZS5mcm9tLmdldCgnc2hvd3MnKSAsIHtcbiAgICAgICAgICAgIGNvbmRpdGlvbjogeyBcbiAgICAgICAgICAgICAgZmF2b3VyaXRlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHVzZXIuZmF2b3VyaXRlcyA9IHt9XG5cbiAgICAgICAgICBzZWxlY3Rpb24ub24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2V0cyA9IHt9XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgdmFyIGJsYSA9ICBjb250ZW50LmdldCh0aGlzLl9wYXRoLnNsaWNlKC0yKSlcblxuICAgICAgICAgICAgICB1c2VyLmZhdm91cml0ZXMuc2V0KHRoaXMuX25hbWUsYmxhKVxuICAgICAgICAgICAgICBzZXRzW3RoaXMuX25hbWVdID0gdHJ1ZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdXNlci5mYXZvdXJpdGVzLmVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgICAgICBpZighc2V0c1tuYW1lXSAgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBzZXRzID0gZmFsc2VcblxuICAgICAgICAgICAgdXNlci5mYXZvdXJpdGVzLnVwZGF0ZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgICBzZWxlY3Rpb24uX3VwZGF0ZSgpXG5cbiAgICAgICAgfVxuICAgICAgfSBcbiAgICB9XG4gIH0pXG5cbiAgdXNlci5leHRlbmQoe1xuICAgIGhhc1dhdGNoZWQ6IHtcbiAgICAgIHZhbDoge1xuICAgICAgICB2YWw6IHVzZXIud2F0Y2hlZCxcbiAgICAgICAgdHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc0Zhdm91cml0ZXM6IHtcbiAgICAgIHZhbDoge1xuICAgICAgICB2YWw6IHVzZXIuZmF2b3VyaXRlcyxcbiAgICAgICAgdHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgdmFyIG9sZENvbnRlbnQgPSBjb250ZW50Ll92YWxcblxuICBjb250ZW50Lm9uKCdzZWxmJywgZnVuY3Rpb24oKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2NvbnRlbnQgaXMgY2hhbmdpbmcgZnJvbScsIG9sZENvbnRlbnQgJiYgb2xkQ29udGVudC5fcGF0aCwgJ3RvJywgdGhpcy5fdmFsLl9wYXRoKVxuICAgIGlmKCB1c2VyLnRva2VuLnZhbCApIHtcbiAgICAgIHJlc29sdmVXYXRjaGVkTWVkaWEoIHVzZXIgKVxuICAgICAgdXNlci5mYXZvdXJpdGVzLl9wcm9wLm9uLnVzZXIuY2FsbCh1c2VyKVxuICAgICAgdXNlci53YXRjaGVkLl9wcm9wLm9uLnVzZXIuY2FsbCh1c2VyKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXNvbHZlV2F0Y2hlZE1lZGlhKCB1c2VyIClcbiAgICAgIHVzZXIuZmF2b3VyaXRlcy5fcHJvcC5vbi5tb2NrLmNhbGwodXNlcilcbiAgICAgIHVzZXIud2F0Y2hlZC5fcHJvcC5vbi51c2VyLmNhbGwodXNlcilcbiAgICB9XG4gIH0pXG5cbiAgY2FzZXMuJGhhc0Zhdm91cml0ZXMgPSB1c2VyLmhhc0Zhdm91cml0ZXNcbiAgY2FzZXMuJGhhc1dhdGNoZWQgPSB1c2VyLmhhc1dhdGNoZWRcblxufSlcblxuZnVuY3Rpb24gcmVzb2x2ZVdhdGNoZWRNZWRpYSggdXNlciApIHtcbiAgdXNlci53YXRjaGVkLmZyb20uZWFjaChmdW5jdGlvbigpIHtcbiAgICB2YXIgbWVkaWEgPSB0aGlzLm1lZGlhICYmIHRoaXMubWVkaWEuZnJvbVxuICAgIGlmKG1lZGlhKSB7XG5cbiAgICAgIHZhciBuZXdQYXRoID0gdXNlci5wYXJlbnQuY29udGVudC5mcm9tLl9wYXRoLmNvbmNhdCggbWVkaWEuX2NvbnRlbnRQYXRoICkgICAgICAgXG4gICAgICB2YXIgb2xkUGF0aCA9IG1lZGlhLl9wYXRoXG5cbiAgICAgIGlmKCAhdXRpbC5jb21wYXJlQXJyYXlzKCBvbGRQYXRoLCBuZXdQYXRoICkgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZXNvbHZlJywgb2xkUGF0aCwgbmV3UGF0aClcbiAgICAgICAgdGhpcy5tZWRpYS52YWwgPSB1c2VyLnBhcmVudC5jb250ZW50LmdldCggbmV3UGF0aCApXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBoYXNUcmFuc2Zvcm0oIGMsIGN2KSB7XG4gIHZhciBzZWxlY3Rpb24gPSBjLl9wYXJlbnQuX3ZhbFxuICBpZihzZWxlY3Rpb24pIHtcbiAgICBpZihzZWxlY3Rpb24uJGxlbmd0aC52YWw+MCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDBcbn1cbiAgIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoJy4uL3ZhbHVlJylcbiAgLCB1cmwgPSByZXF1aXJlKCcuLi9icm93c2VyL25ldHdvcmsvdXJsJylcbiAgLCB1YSA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvdWEnKVxuXG5yZXF1aXJlKCcuLi92YWx1ZS9mbGFncy9wcm9jZXNzJylcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKCBmdW5jdGlvbiggYXBwICkge1xuXG4gIC8vdXNlIGNhc2VzIHJlZmVyZW5jZSBvbiBhcHBcbiAgdmFyIGNhc2VzID0gYXBwLmNhc2VzIHx8ICggYXBwLmNhc2VzID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9jYXNlcycpIClcblxuICBhcHAuaW5pdGlhbGlzZWQgPSBuZXcgVmFsdWUoIGZhbHNlIClcblxuICBhcHAub3ZlcmxheSA9IG5ldyBWYWx1ZSggZmFsc2UgKVxuXG4gIGFwcC5mb2N1c1N0YXRlID0gbmV3IFZhbHVlKCdtZW51JylcblxuICBhcHAucmVnaW9uID0gbmV3IFZhbHVlKHsgaW5pdDogYXBwLmluaXRpYWxpc2VkIH0pXG4gIC8vYnJvd3NlclxuICAvL3VhLmJyb3dzZXJcblxuICBhcHAudXJsID0gdWEuZGV2aWNlID09PSAndHYnICYmIHVhLnBsYXRmb3JtID09PSAnbGcnIFxuICAgICAgICA/ICBuZXcgVmFsdWUoe2RlZmVyOmZ1bmN0aW9uKCl7fSwgcGFyYW1zOnt9LCBzdHJpbmc6Jyd9KSBcbiAgICAgICAgOiAgdXJsIFxuICAvL29vayBwYXMgb3AgYXBwIGluaXRpbGlzZWQhXG5cbiAgYXBwLnJlYWR5ID0gbmV3IFZhbHVlKClcblxuICBhcHAubWVudSA9IG5ldyBWYWx1ZSh7IGluaXQ6IGFwcC5yZWFkeSB9KVxuXG4gIC8vVE9ETzpuZXR3b3JrXG4gIC8vbW92ZSBuZXR3b3JrIGFwaSBmaWxlIHRvIGhlcmUgcGVyaGFwc1xuICBhcHAubmV0d29yayA9IG5ldyBWYWx1ZSgpXG5cbiAgLy9UT0RPOiBkb3VibGUgY2hlY2sgdGhpcyBpcyBlZmZpY2llbnRcbiAgYXBwLmxvYWRpbmcgPSBuZXcgVmFsdWUoeyBcbiAgICBpbml0OiBhcHAucmVhZHlcbiAgLCBkZWZlcjogZnVuY3Rpb24oIHVwZGF0ZSwgYXJncyApIHtcbiAgICAgIC8vVE9ETzogY2FjaGVkIHVwZGF0ZVBhdGggP1xuICAgICAgdmFyIGlkID0gdGhpcy51cGRhdGVQYXRoLmpvaW4oJy4nKVxuICAgICAgaWYoIGFyZ3NbMF09PT1mYWxzZSAmJiAoIChpZCAmJiBpZCA9PT0gdGhpcy5pZCkgfHwgIXRoaXMuaWQgKSApIHtcbiAgICAgICAgdGhpcy52YWwgPSBhcmdzWzBdXG4gICAgICAgIHRoaXMuaWQgPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmKCBhcmdzWzBdID09PSB0cnVlICkge1xuICAgICAgICB0aGlzLmlkID0gaWRcbiAgICAgICAgdGhpcy52YWwgPSB0cnVlXG4gICAgICB9XG4gICAgICB1cGRhdGUoKVxuICAgIH1cbiAgICAvL2FkZCBkZWZlcmVkIGxhdGVyIChtYXliZSBkb250IHNob3cgYSBsb2FkZXIgZm9yIGxlc3MgdGhlbiB4eHggc2VjKSBcbiAgfSlcblxuICAvLyAnX3NldCcsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgbm91cGRhdGUsIGFkZGVkLCBvbGR2YWwpIHtcbiAgLy9hZGQgbG9jYWxzdG9yYWdlXG5cbiAgdmFyIGd1ZXNzTGFuZ3VhZ2UgPSBhcHAuZ3Vlc3NMYW5ndWFnZSA9IGZ1bmN0aW9uIGd1ZXNzTGFuZ3VhZ2UoKXtcbiAgICAvL1RPRE86IGNvcmRvdmEgbGFuZ3VhZ2VcbiAgICB2YXIgZ3Vlc3MgPSB3aW5kb3cubmF2aWdhdG9yLnVzZXJMYW5ndWFnZVxuICAgICAgICAgICAgIHx8IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2VcbiAgICAgICAgICAgICB8fCBhcHAucmVnaW9uLnZhbCBcbiAgICBpZihndWVzcylcbiAgICAgIHJldHVybiBndWVzcy5zbGljZSgwLDIpLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gYXBwLmxhbmd1YWdlID0gbmV3IFZhbHVlKCAgXG4gIHsgdHJhbnNmb3JtOiBmdW5jdGlvbiggdmFsLCBjdiApIHtcbiAgICAgIGlmKCFjdiB8fCB0eXBlb2YgY3YgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGN2ID0gZ3Vlc3NMYW5ndWFnZSgpXG4gICAgICB9IFxuICAgICAgcmV0dXJuIGN2ID8gY3Yuc2xpY2UoMCwyKS50b0xvd2VyQ2FzZSgpIDogZmFsc2VcbiAgICB9XG4gICwgaW5pdDogYXBwLmluaXRpYWxpc2VkIFxuICB9KVxuXG4gIGFwcC5mdWxsc2NyZWVuID0gbmV3IFZhbHVlKHsgZm9yY2U6IHRydWUgfSlcblxuICBhcHAubG9hZGVyID0gbmV3IFZhbHVlKClcblxuICBhcHAudm9sdW1lID0gbmV3IFZhbHVlKFxuICB7IHZhbDoxXG4gICwgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgLy8gY29uc29sZS5sb2coJ3ZvbHVtZT8nLGN2LGlzTmFOKGN2KSA/IDEgOiBjdilcbiAgICAgIC8vVE9ETzogdXNlIGxvRGFzaCBmb3IgaXNOYW5cbiAgICAgIHJldHVybiBpc05hTihjdikgPyAxIDogY3ZcbiAgICB9XG4gIH0pXG5cbiAgYXBwLnBvcHVwID0gbmV3IFZhbHVlKHsgaW5pdDogYXBwLnJlYWR5IH0pXG5cbiAgYXBwLnByZXZpZXcgPSBuZXcgVmFsdWUoeyBpbml0OiBhcHAucmVhZHkgfSlcblxuICBhcHAuaGlnaGxpZ2h0ID0gbmV3IFZhbHVlKHsgaW5pdDogYXBwLnJlYWR5IH0pXG5cbiAgYXBwLnN0YXRlID0gbmV3IFZhbHVlKHsgaW5pdDogYXBwLnJlYWR5IH0pXG4gIFxuICBhcHAubm90aWZpY2F0aW9uID0gbmV3IFZhbHVlKCBcbiAgeyBpbml0OiBhcHAucmVhZHkgIFxuICAsIGZvcmNlOiB0cnVlIC8vVE9ETzogbWFrZSB0aGlzIGJldHRlclxuICB9KVxuXG4gIGFwcC5pc1BsYXlpbmcgPSBuZXcgVmFsdWUoXG4gIHsgaW5pdDogYXBwLnJlYWR5XG4gICwgdmFsOmZhbHNlXG4gIH0pXG5cbiAgYXBwLnJlc3RyaWN0UGxheWJhY2sgPSBuZXcgVmFsdWUoKVxuXG4gIC8vbWFrZSBpbmplY3RhYmxlXG4gIGFwcC53aWZpT25seSA9IG5ldyBWYWx1ZShcbiAgICBsb2NhbFN0b3JhZ2UgXG4gICAgPyB7IHZhbDogbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3dpZmlPbmx5JykgfHwgZmFsc2VcbiAgICAgICwgZGVmZXI6ZnVuY3Rpb24oIHVwZGF0ZSApe1xuICAgICAgICAgIGlmKHRoaXMuX3ZhbCkgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3dpZmlPbmx5Jyx0cnVlKVxuICAgICAgICAgIGVsc2UgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3dpZmlPbmx5JylcbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgOiBmYWxzZVxuICApXG5cbiAgYXBwLnJlc3RyaWN0UGxheWJhY2sudmFsID0gXG4gIHsgdmFsOiBhcHAud2lmaU9ubHlcbiAgLCB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICByZXR1cm4gKCBjdiAmJiBjYXNlcy4kaXNOYXRpdmUgJiYgYXBpLm5ldHdvcmsudmFsICE9PSAnd2lmaScgKVxuICAgICAgICA/IHRydWVcbiAgICAgICAgOiBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IG1vdmUgdGhpcyAoc2V0dGluZyBjYXNlIHZhbHVlKSBvdXQgb2YgYXBwIHZhbHVlc1xuICBjYXNlcy4kc3RvcmVBdmFpbGFibGUgPSBuZXcgVmFsdWUoIFxuICAgIGNhc2VzLiRpc05hdGl2ZSAmJiAoIGNhc2VzLiRpc0lvcyB8fCBjYXNlcy4kaXNBbmRyb2lkIHx8IGNhc2VzLiRpc1dpbmRvd3NNb2JpbGUgKSAvLyYmIHdpbmRvdy5TdG9yZVxuICApXG5cbn0pIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIFYgPSByZXF1aXJlKCcuLi8nKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCBpbmplY3QgPSByZXF1aXJlKCcuLi91dGlsL2luamVjdCcpXG4vLyAsIHJhZiA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicpXG5cblxuLypcbiAgdXRpbC5kZWZpbmUoIGV4dGVuZCwgJ2V4dGVuc2lvbnMnLHt2YWw6W10sIHNldENsYXNzOnRydWV9IClcbiovXG5cbi8qKlxuICogQmFzZSBpcyB1c2VkIGFzIGEgY2xhc3MgY29uc3RydWN0b3IuXG4gKiBAY29uc3RydWN0b3IgVi5CYXNlXG4gKiBAcGFyYW0gIHsqfSBbdmFsXSBTdGFydHZhbHVlIGZvciBuZXcgVi5CYXNlXG4gKi9cbnZhciBiYXNlID0gVi5CYXNlID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24odmFsKSB7XG4gIHRoaXMuX2Zyb20gPSB0aGlzLmNvbnN0cnVjdG9yXG4gIGlmICh2YWwpIHRoaXMuc2V0KHZhbClcbn1cblxuZXhwb3J0cy5zZXR0aW5ncyA9IHJlcXVpcmUoJy4vc2V0dGluZ3MnKVxuXG4vKipcbiAqIFNldHMgcHJvcGVydGllcyBkZWZpbmVkIGluIGFuIG9iamVjdC5cbiAqIERlZmluZSBhIF9zZXQgbWV0aG9kIG9uIGEgYmFzZSBpbnN0YW5jZSB0byBnZXQgY3VzdG9tIG1ldGhvZCBwZXIgc2V0LlxuICogQGZ1bmN0aW9uIF9zZXRcbiAqIEBwYXJhbSAgeyp9IHZhbCAgICAgICAgIEFueSB2YWx1ZVxuICogQHBhcmFtICB7Kn0gW3BhcmFtc10gICAgQWRkZWQgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtCb29sZWFufSBub3NldCAgV2hlbiB0cnVlIHJldHVybnMgYSBwYXJzZWQgdmFsIG9iamVjdCBidXQgc2V0IG5vdGhpbmdcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIHJldHVybiBzZWxmIGZvciBjaGFpbmluZ1xuICovXG52YXIgX3NldCA9IGV4cG9ydHMuc2V0ID0gZnVuY3Rpb24odmFsLCBwYXJhbXMsIG5vc2V0KSB7XG4gIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgaWYgKH5pLmluZGV4T2YoJywnKSkge1xuICAgICAgZm9yICh2YXIgYXJyID0gaS5zcGxpdCgnLCcpLCBtdWx0aW9iaiA9IHt9LCBtID0gMCwgbWwgPSBhcnIubGVuZ3RoOyBtIDwgbWw7IG0rKykge1xuICAgICAgICBtdWx0aW9ialthcnJbbV1dID0gdXRpbC5jbG9uZSh2YWxbaV0pXG4gICAgICB9XG4gICAgICBpZiAoIW5vc2V0KSB7XG4gICAgICAgIF9zZXQuY2FsbCh0aGlzLCBtdWx0aW9iaiwgcGFyYW1zLCBub3NldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB2YWxbaV1cbiAgICAgICAgZm9yICh2YXIgbiBpbiBtdWx0aW9iaikge1xuICAgICAgICAgIHZhbFtuXSA9IG11bHRpb2JqW25dXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaSA9IHV0aWwuZG90RmllbGQodmFsLCBpKVxuXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCAnU0VUJywgdGhpcywgdGhpcy5fc2V0KVxuXG4gICAgICBpZiAodGhpcy5fc2V0ICYmICFub3NldCkge1xuICAgICAgICB0aGlzLl9zZXQuY2FsbCh0aGlzLCB2YWwsIGksIHBhcmFtcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vVE9ETzogY2hlY2sgZm9yIHByb3BlcnR5IG1vdmUgZnJvbSBlbGVtZW50IHNldCB0byBoZXJlXG4gICAgICAgIC8vIGlmKCBWLk9iamVjdCAmJiB0aGlzLmlzUHJvcGVydHkoIGksIHZhbCApICYmIHRoaXNbaV0gaW5zdGFuY2VvZiBWLk9iamVjdCApXG4gICAgICAgIC8vIHtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZygnPz8nLCBpLCB2YWwsIHRoaXMuaXNQcm9wZXJ0eSggaSwgdmFsICkgKVxuICAgICAgICAvLyAgIHRoaXNbaV0udmFsID0gdmFsW2ldXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyB7XG4gICAgICAgICAgdGhpc1tpXSA9IHZhbFtpXVxuICAgICAgICAvLyB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBub3NldCA/IHZhbCA6IHRoaXNcbn07XG5cbnV0aWwuZGVmaW5lKGJhc2UsXG4gIC8qKlxuICAgKiBXaGVuIGEgQmFzZSBpcyBleHRlbmRlZCB3aXRob3V0IGRlZmluaW5nIHRoZSB0eXBlIHRoaXMgaXMgdGhlIGRlZmF1bHQgdHlwZS5cbiAgICogQHByb3BlcnR5IGRlZmF1bHRUeXBlXG4gICAqL1xuICAnaXNQcm9wZXJ0eScsIGZ1bmN0aW9uKCBpLCB2YWwpIHtcbiAgICB2YXIgdCA9IHRoaXNcbiAgICAgICwgcmVzdWx0ID0gXG5cbiAgICAgIFxuICAgIC8vIHZhbFtpXSBpbnN0YW5jZW9mIE9iamVjdCAgLy9USElTIE1BWSBHTyBBV0FZIExBVEVSXG4gICAgICAgICAgIC8vVE9ETzogY2hlY2sgaWYgdGhpcyBpcyByZWFsbHkgbmVzc2VyYWN5ICggdm9pZCAwIClcbiAgICAgICAgICAgLy8gJiYgXG5cbiAgICAgIC8vU1VQRVIgREFOR0VSR09VUyBUSElOR1xuXG4gICAgICAgICAgISggdC5fW2ldID09PSB2b2lkIDAgLy8tLS0gZGFuZ2VyIHJlc29sdmUgd2hlbiBkZWZpbmUgXyBpcyBmaXhlZFxuICAgICAgICAgICAmJiAhdXRpbC5sb29rdXAuY2FsbCh0LCBpKSBcbiAgICAgICAgICAgJiYgdHlwZW9mIHRbaV0hPT0nZnVuY3Rpb24nIFxuICAgICAgICAgIClcblxuICAgIC8vIGNvbnNvbGUubG9nKCB2YWxbaV0gaW5zdGFuY2VvZiBPYmplY3QsIHQuX1tpXSA9PT0gdm9pZCAwLCAndmFsOicsdC5fW2ldLCAhdXRpbC5sb29rdXAuY2FsbCh0LCBpKSwgdHlwZW9mIHRbaV0hPT0nZnVuY3Rpb24nICApXG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ0lTIFBST1BFUlRZJywgaSwgcmVzdWx0IClcblxuICAgIHJldHVybiByZXN1bHRcbiAgfSxcbiAgJ2RlZmF1bHRUeXBlJywgZmFsc2UsXG4gICdleHRlbnNpb25zJywgZmFsc2UsXG4gICdkZWZpbmUnLCBmdW5jdGlvbih2YWwpIHtcbiAgICBmb3IodmFyIGkgaW4gdmFsKSB7XG4gICAgICB1dGlsLmRlZmluZSggdGhpcywgaSwgdmFsW2ldIClcbiAgICAgIHV0aWwuZGVmaW5lKCB0aGlzLkNsYXNzLCBpLCB2YWxbaV0gKVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEV4dGVuZCBpcyB1c2VkIHRvIGFkZCBwcm9wZXJ0aWVzIHRvIGJhc2UuXG4gICAqIFNldHRpbmdzIGFyZSBzaW1pbGFyIHRvIHN0YW5kYXJkIGRlZmluZVByb3BlcnR5LlxuICAgKiBAbWV0aG9kIGV4dGVuZFxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgIHNldHRpbmdzICAgICAgICBEZWZpbmUgdGhlIGZvbGxvd2luZyBmaWVsZHM6IG5hbWUsIHR5cGUsIHNldCwgbmV3LCByZW1vdmUuXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgc2V0dGluZ3MubmFtZSAgIERlZmluZSB0aGUgbmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICogQHBhcmFtICAge09iamVjdH0gICBbc2V0dGluZ3MudHlwZV0gRGVmaW5lIHRoZSB0eXBlIG9mIG9iamVjdCBlLmcuIFYuVmFsdWUsIHNldCB0eXBlIHRvIGZhbHNlIGlmIHlvdSB3YW50IHRvIHVzZSBzdGFuZGFyZCBkZWZpbmVQcm9wZXJ0eVxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259IHNldHRpbmdzLnNldCAgICBEZWZpbmUgYSBmdW5jdGlvbiBvbiBzZXRcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBzZXR0aW5ncy5uZXcgICAgRGVmaW5lIGEgZnVuY3Rpb24gb24gY29uc3RydWN0XG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gc2V0dGluZ3MucmVtb3ZlIERlZmluZSBhIGZ1bmN0aW9uIG9uIHJlbW92ZVxuICAgKiBAcmV0dXJuICB7W3R5cGVdfSAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnZXh0ZW5kJywgZnVuY3Rpb24oc2V0dGluZ3MpIHtcblxuICAgIC8vVE9ETzogYWRkIHRvIGluc3RhbmNlIGFzIHdlbGwgLCBoYXZlIGEgZGljdGlvbmFyeSBvZiBleHRlbnN0aW9ucyAtLSBnZXQgdG8gb3JnaW5hbCBlYXN5bHlcbiAgICB2YXIgYXJncyA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICAgICwgbCA9IGFyZ3MubGVuZ3RoXG4gICAgICAsIGlcblxuICAgIGlmIChsID4gMSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IHRoaXMuZXh0ZW5kKCBhcmdzW2krK10gKSk7XG4gICAgfSBlbHNlIGlmICghc2V0dGluZ3MubmFtZSkge1xuICAgICAgZm9yIChpIGluIHNldHRpbmdzKSB7XG5cbiAgICAgICAgaWYoIHR5cGVvZiBzZXR0aW5nc1tpXSA9PT0gJ2Z1bmN0aW9uJyApIFxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5leHRlbmQoIHsgbmFtZTogaSwgc2V0OiBzZXR0aW5nc1tpXSB9IClcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICBzZXR0aW5nc1tpXS5uYW1lID0gaVxuICAgICAgICAgIHRoaXMuZXh0ZW5kKCBzZXR0aW5nc1tpXSApXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmKCBzZXR0aW5ncyA9PT0gdHJ1ZSApe1xuICAgICAgICBhbGVydCgpXG4gICAgICB9XG5cblxuICAgICAgaWYgKCFzZXR0aW5ncy5kZWYgJiYgc2V0dGluZ3MuZGVmICE9PSAwKSBzZXR0aW5ncy5kZWYgPSBmYWxzZTtcbiAgXG4gICAgICBpZiAodGhpcy5DbGFzcy5wcm90b3R5cGUuX3NldHRpbmdzKSB7XG4gICAgICAgIGV4cG9ydHMuc2V0dGluZ3MucGFyc2UuY2FsbCh0aGlzLCBzZXR0aW5ncylcbiAgICAgICAgaWYgKHNldHRpbmdzLl9zZXR0aW5ncykgZXhwb3J0cy5zZXR0aW5ncy5jcmVhdGUuY2FsbCh0aGlzLCBzZXR0aW5ncylcbiAgICAgIH1cbiAgICAgIC8vMS4gbm9ybWFsIGV4dGVuc2lvbnNcbiAgICAgIGlmIChzZXR0aW5ncy50eXBlID09PSBmYWxzZSB8fCAoICFzZXR0aW5ncy50eXBlICYmICF0aGlzLmRlZmF1bHRUeXBlICkgKSB7XG5cbiAgICAgICAgLy9UT0RPOiB0ZXN0IGlmIGRvdWJsZSBkZWZpbmUgaXMgYWN0dWFsbHkgb2shXG4gICAgICAgIC8vIHV0aWwuZGVmaW5lKHRoaXMsIHNldHRpbmdzLm5hbWUsIHNldHRpbmdzKVxuXG4gICAgICAgIHV0aWwuZGVmaW5lKHRoaXMuQ2xhc3MsIHNldHRpbmdzLm5hbWUsIHNldHRpbmdzKVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLzIuIFYuVmFsdWVzXG4gICAgICAgIGlmICghc2V0dGluZ3MudHlwZSkgc2V0dGluZ3MudHlwZSA9IHRoaXMuZGVmYXVsdFR5cGVcbiAgICAgICAgICAvL2EgdHlwZSBoYXMgZmllbGRzIHR5cGUsIHNldCAsZ2V0LCBjcmVhdGVcbiAgICAgICAgdmFyIGdldCA9ICBmdW5jdGlvbihwcm9wKSB7XG4gICAgICAgICAgICAvL2N1c3RvbSBnZXRcbiAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy50eXBlLmdldCBcbiAgICAgICAgICAgICAgPyBzZXR0aW5ncy50eXBlLmdldC5jYWxsKHRoaXMsIHByb3AsIHNldHRpbmdzKVxuICAgICAgICAgICAgICA6IHByb3BcbiAgICAgICAgICB9XG4gICAgICAgICAgLCBzZXQgPSAgZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgICAgICAgIHZhciBwcm9wID0gdGhpc1tzZXR0aW5ncy5uYW1lXVxuICAgICAgICAgICAgaWYocHJvcD09PW51bGwpIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb3A9PT1zZXR0aW5ncy5kZWYpIHsgLy8ocHJvcCBpbnN0YW5jZW9mIFYuT2JqZWN0KVxuICAgICAgICAgICAgICAvL3JldHVybiBpcyBoaWVyIG1pc2NoaWVuIG5pZXQgbm9kaWc7XG4gICAgICAgICAgICAgIHJldHVybiBzZXR0aW5ncy50eXBlLmNyZWF0ZS5jYWxsKHRoaXMsIHZhbCwgcHJvcCwgc2V0dGluZ3MpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWwgPSBzZXR0aW5ncy50eXBlLnNldC5jYWxsKHRoaXMsIHZhbCwgcHJvcCwgc2V0dGluZ3MpXG4gICAgICAgICAgICAgIGlmICh2YWwhPT0gbnVsbCkgcHJvcC52YWwgPSB2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgLy9UT0RPOiB0ZXN0IGlmIGRvdWJsZSBkZWZpbmUgaXMgYWN0dWFsbHkgb2shXG4gICAgICAgIHV0aWwuZGVmaW5lKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgc2V0dGluZ3MubmFtZSxcbiAgICAgICAgICBzZXR0aW5ncy5kZWYsXG4gICAgICAgICAgc2V0LFxuICAgICAgICAgIGdldCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgICAgLy9kaXQgYnJlYWtlZCB3YXQgc2hpdFxuXG4gICAgICAgIC8vb3Igb24gdmFsdWUgPyB2YWx1ZS5wcm9wXG5cbiAgICAgICAgLy9tYWtlIGV4dGVuZGVkIHByb3RvdHlwZSBvYmplY3QgcGVyaGFwc1xuICAgICAgICAvLyB0aGlzLkNsYXNzLnByb3RvdHlwZVsnX18nK3NldHRpbmdzLm5hbWUrJ19fJ10gPSBzZXR0aW5nc1xuXG4gICAgICAgIHV0aWwuZGVmaW5lKFxuICAgICAgICAgIHRoaXMuQ2xhc3MsXG4gICAgICAgICAgc2V0dGluZ3MubmFtZSxcbiAgICAgICAgICBzZXR0aW5ncy5kZWYsXG4gICAgICAgICAgc2V0LFxuICAgICAgICAgIGdldFxuICAgICAgICApXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmVtb3ZlcyB0aGlzIEJhc2UuIEFsc28gcmVtb3ZlcyBhbGwgbGlzdGVuZXJzIGFkZGVkIHRvIGV4dGVuc2lvbnMuXG4gICAqIEluc3RhbmNlcyB0cnVlIHdpbGwgcmVtb3ZlIGFsbCBpbnN0YW5jZXMgYXMgd2VsbC5cbiAgICogQG1ldGhvZCByZW1vdmVcbiAgICogQHBhcmFtICB7W3R5cGVdfSBpbnN0YW5jZXMgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBmcm9tcmVtb3ZlIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBwYXJhbXMgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdyZW1vdmUnLCBmdW5jdGlvbihpbnN0YW5jZXMsIGZyb21yZW1vdmUsIHBhcmFtcykge1xuXG4gICAgLy8gdGhpcy5fcmVtb3ZpbmcgPSB0cnVlXG5cbiAgICBpZighdGhpcy5fZnJvbSkgcmV0dXJuXG5cbiAgICB0aGlzLnNldHRpbmcoJ3JlbW92ZScsIFtwYXJhbXNdKTtcblxuICAgIGlmICghZnJvbXJlbW92ZSkge1xuICAgICAgdmFyIGlucyA9IHRoaXMuX2Zyb20uYmFzZS5pbnN0YW5jZXNcbiAgICAgIGlmKGlucykge1xuICAgICAgICBmb3IgKHZhciBuID0gMCwgbCA9IGlucy5sZW5ndGg7IGluc1tuXSAhPT0gdGhpcyB8fCAhaW5zLnNwbGljZShuLCAxKTsgbisrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIHRoaXMuX18pIHtcbiAgICAgIGlmICh0aGlzLl9fW2ldIGluc3RhbmNlb2YgVi5PYmplY3QpIHtcbiAgICAgICAgLy9uZXN0ZWQsIGJsYWNrbGlzdCwgbm90IChmaWVsZHMgaW4gb2JqZWN0KSwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0nLCBpLCB0aGlzLl9fW2ldLCB0aGlzLl9fW2ldLl9wYXRoIClcbiAgICAgICAgdGhpcy5fX1tpXS5yZW1vdmUoZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fX1tpXSA9IG51bGxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19baV0gPSBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX18gPSBudWxsXG5cbiAgICBpZiAoaW5zdGFuY2VzICYmIHRoaXMuaW5zdGFuY2VzKSB7XG4gICAgICBmb3IgKGogPSB0aGlzLmluc3RhbmNlcy5sZW5ndGggLSAxOyBqID49IDA7IHRoaXMuaW5zdGFuY2VzW2otLV0ucmVtb3ZlKHRydWUsIHRydWUpKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBqIGluIHRoaXMpIHtcbiAgICAgIC8vIGlmKHRoaXNbal0gaW5zdGFuY2VvZiBWLkJhc2UpIHtcbiAgICAgIC8vICAgdGhpc1tqXS5yZW1vdmUoKVxuICAgICAgLy8gfSBcbiAgICAgIHRoaXNbal0gPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX3NldHRpbmdzID0gbnVsbFxuICAgIHRoaXMuXyA9IG51bGxcbiAgICBkZWxldGUgdGhpcy5fc2V0dGluZ3NcbiAgICBkZWxldGUgdGhpcy5fXG4gICAgZGVsZXRlIHRoaXMuX19cbiAgICAvLyBkZWxldGUgdGhpcy5fY2xhc3M7IG1heSBub3QgYmUgbmVzc2VjYXJ5XG4gIH0sXG4gIC8qc2V0IG9uIHByb3RvdHlwZSovXG4gICdzZXQnLCBfc2V0LFxuICAnZ2V0JywgZnVuY3Rpb24oIHBhdGgsIHNlbGYgKSB7XG4gICAgcmV0dXJuIHV0aWwuZ2V0KCB0aGlzLCBwYXRoLCBzZWxmIClcbiAgfSxcblxuICAnaW5qZWN0JywgaW5qZWN0LFxuICAvKipcbiAgICogUGFzc2VzIGZpZWxkIHBhcmFtZXRlciBvbmx5IGZvciBpbnN0YW5jZXMgbWF0Y2hpbmcgYSBmaWVsZFxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBmbiAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICBmaWVsZCBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAgeyp9ICAgICAgICB2YWwgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAgeyp9ICAgICAgICBwICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnZWFjaEluc3RhbmNlJywgZnVuY3Rpb24oZm4sIGZpZWxkLCB2YWwsIHApIHtcbiAgICB2YXIgaW5zdGFuY2VzID0gdGhpcy5pbnN0YW5jZXM7XG4gICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbnN0YW5jZXMubGVuZ3RoLCBpbnN0YW5jZTsgaSA8IGw7IGkrKykge1xuICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tpXTtcblxuXG4vL3Byb2JsZW0hIGhhcyB0byBjb3JyZWN0IGZvciBtaXNzaW5nIGluc3RhbmNlcyEhIVxuLy8gICBjb25zb2xlLmxvZyhpbnN0YW5jZSwgaW5zdGFuY2VzKVxuXG4gICAgICAgICAgXG5cbiAgICAgICAgaWYgKGluc3RhbmNlICYmICghZmllbGQgfHwgIWluc3RhbmNlLl9fIHx8ICFpbnN0YW5jZS5fX1tmaWVsZF0pKSB7XG4gICAgICAgICAgaWYgKGZuLmNhbGwoaW5zdGFuY2UsIHZhbCwgcCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5zdGFuY2UuZWFjaEluc3RhbmNlKGZuLCBmaWVsZCwgdmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYoIWluc3RhbmNlKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignXFxuXFxuXFxuXFxuaW5zdGFuY2UgaW4gYmFzZSBnb25lPycsIGkgLCBpbnN0YW5jZXMpXG4gICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjbGFzcyBmcm9tIHRoZSBjdXJyZW50IEJhc2UgaW5zdGFuY2VcbiAgICogQGNvbnN0cnVjdG9yIENsYXNzXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gICdDbGFzcycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9jbGFzcykge1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLl9jbGFzcyA9IGZ1bmN0aW9uKHZhbCwgcHJvdG8sIHNldHRpbmcpIHtcbiAgICAgICAgICBpZiAoIXByb3RvKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHRoaXMuX2Zyb20uYmFzZTtcbiAgICAgICAgICAgIGZyb20uaW5zdGFuY2VzLnB1c2godGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5nKSB7XG4gICAgICAgICAgICAgIHRoaXMuc2V0dGluZygnbmV3JywgW2Zyb20sIHNldHRpbmddKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXQodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2NsYXNzLmJhc2UgPSB0aGlzO1xuICAgICAgICB0aGlzLl9jbGFzcy5wcm90b3R5cGUgPSBuZXcgdGhpcy5fZnJvbShmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fXyA9IG51bGw7XG4gICAgICAgIHV0aWwuc2V0c3RvcmUuY2FsbCh0aGlzKTtcbiAgICAgICAgdmFyIGksIF9wcm90byA9IHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fID0ge307XG4gICAgICAgIGZvciAoaSBpbiB0aGlzLl9fKSB7XG4gICAgICAgICAgX3Byb3RvW2ldID0gdGhpcy5fX1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgaW4gdGhpcy5fKSB7XG4gICAgICAgICAgaWYgKF9wcm90b1tpXSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBfcHJvdG9baV0gPSB0aGlzLl9baV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fZnJvbSA9IHRoaXMuX2NsYXNzO1xuICAgICAgICB0aGlzLl9jbGFzcy5pbmplY3QgPSBpbmplY3RcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9jbGFzcztcbiAgICB9XG4gIH0pOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBiYXNlID0gcmVxdWlyZSgnLi8nKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLyoqXG4gKiBTZXR0aW5ncyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBjYXNlcyBlLmcuIG9uUmVtb3ZlIG9yIG9uTmV3IGluc3RhbmNlXG4gKiBAcHJvcGVydHlcbiAqL1xudXRpbC5kZWZpbmUoYmFzZSwgJ19zZXR0aW5ncycpO1xuXG5iYXNlLnByb3RvdHlwZS5fLl9zZXR0aW5ncyA9IHt9O1xuXG4vKipcbiAqIFNldCBzZXR0aW5ncyBvbiBCYXNlXG4gKiBAZnVuY3Rpb24gX3NldFxuICogQHBhcmFtICB7T2JqZWN0fSAgc2V0ICAgICAgT2JqZWN0IHRvIHNldFxuICogQHBhcmFtICB7Qm9vbGVhbn0gW3JlbW92ZV1cbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtmb3JjZV0gIFRydWUvZmFsc2VcbiAqL1xudmFyIF9zZXQgPSBmdW5jdGlvbihzZXQsIHJlbW92ZSwgZm9yY2UpIHtcbiAgdmFyIF9zID0gc2V0Ll9zZXR0aW5ncyAvL2UuZy4gbm9kZSAsIHJlbW92ZSBhbmQgcGFyZW50XG4gICAgLCB0ID0gdGhpc1xuICAgICwgX190ID0gdC5fLl9zZXR0aW5nc1xuICAgICwgc2V0dGluZ1xuICAgICwgaVxuICAgICwgX3RcblxuICB1dGlsLnNldHN0b3JlLmNhbGwodClcblxuICBpZiAoIXQuX18uX3NldHRpbmdzKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ2NyZWF0ZSBteSBvd24gc2V0dGluZ3MnKVxuICAgIHQuX18uX3NldHRpbmdzID0ge31cbiAgICBmb3IgKHZhciBqIGluIF9fdCkge1xuICAgICAgdC5fc2V0dGluZ3Nbal0gPSBfX3Rbal1cbiAgICB9XG4gIH1cblxuICBfdCA9IHQuX18uX3NldHRpbmdzXG5cbiAgLy8gY29uc29sZS5sb2coJ1NFVFRJTkdTPycuaW52ZXJzZSwgc2V0LCBfX3QpXG5cbiAgZm9yIChpIGluIF9zKSB7XG4gICAgc2V0dGluZyA9IF9zW2ldXG4gICAgLy9lZmZpY2llbnQgbWVtb3J5IG1hbmFnZW1lbnQgb25seSBtYWtlIG93biBpZiBhYnNvbHV0ZWx5IG5lc3NlY2FyeVxuICAgIGlmICgocmVtb3ZlICYmIF90W3NldHRpbmddW3NldC5uYW1lXSkgfHwgKCFyZW1vdmUgJiYgIV90W3NldHRpbmddW3NldC5uYW1lXSkgfHwgZm9yY2UpIHtcbiAgICAgIFxuICAgICAgaWYgKF90W3NldHRpbmddID09PSBfX3Rbc2V0dGluZ10pIHtcbiAgICAgICAgX3Rbc2V0dGluZ10gPSB7fVxuICAgICAgICBmb3IgKHZhciBuIGluIF9fdFtzZXR0aW5nXSkge1xuICAgICAgICAgIF90W3NldHRpbmddW25dID0gX190W3NldHRpbmddW25dXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICB0aGlzLmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpc1tzZXQubmFtZV0gIT09IHRbc2V0Lm5hbWVdKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2V0dGluZyAhPT0gX3QgJiYgdGhpcy5fc2V0dGluZ3Nbc2V0dGluZ10gPT09IF90W3NldHRpbmddKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmb3VuZCB0aGF0IHRoZSBzZXR0aW5ncyBhcmUgdGhlIHNhbWUgYW5kIG5vdCB0aGUgc2FtZSBwcm9wZXJ0eSBtYWtlIG15IG93bicpO1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tIFNFVFRJTkcnKVxuICAgICAgICAgICAgICBfc2V0LmNhbGwodGhpcywgX3Rbc2V0dGluZ11bc2V0Lm5hbWVdLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5nICE9PSBfdCAmJiB0aGlzLl9zZXR0aW5nc1tzZXR0aW5nXSAhPT0gX3Rbc2V0dGluZ10pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLSBSRU1PVkUgU0VUVElORycpXG5cbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codGhpcy5uYW1lLHNldC5uYW1lLCdmb3VuZCB0aGF0IHRoZSBwcm9wZXJ0eSBpcyB0aGUgc2FtZSBidXQgc2V0dGluZ3MgYXJlIG5vdCEnKTtcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVTZXR0aW5nKHNldC5uYW1lLCBzZXR0aW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfdFtzZXR0aW5nXVtzZXQubmFtZV0gPSBudWxsO1xuICAgICAgICBkZWxldGUgX3Rbc2V0dGluZ11bc2V0Lm5hbWVdOyAvL2RlbGV0ZSBpcyBrdXQhO1xuICAgICAgICBpZiAodXRpbC5lbXB0eShfdFtzZXR0aW5nXSkpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbGV0cyBwdXQgdGhpcyB0byB0cnVlIScpXG4gICAgICAgICAgX3Rbc2V0dGluZ10gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tIERPIFNFVFRJTkcnLCBzZXQsIF90LCBzZXR0aW5nLCBzZXQubmFtZSlcbiAgICAgICAgaWYoX3Rbc2V0dGluZ109PT10cnVlKSB7XG4gICAgICAgICAgX3Rbc2V0dGluZ109e31cbiAgICAgICAgfVxuICAgICAgICBfdFtzZXR0aW5nXVtzZXQubmFtZV0gPSBzZXQ7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRVNVTFQ/Jywgc2V0dGluZywgX3Rbc2V0dGluZ10pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY29uc29sZS5sb2coJ1NFVFRJTkdTPyAtLSByZXN1bHQnLmludmVyc2UsIF90LCB0aGlzLl9zZXR0aW5ncz09PV90LCB0aGlzLkJMVVhFTilcblxufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0dGluZ1xuICogQG1ldGhvZCBjcmVhdGVcbiAqIEBwYXJhbSAge1t0eXBlXX0gc2V0IFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbihzZXQpIHtcbiAgc2V0Ll9zZXQgPSBzZXQuc2V0O1xuICBzZXQuc2V0ID0gZnVuY3Rpb24odmFsLCBwcm9wKSB7XG4gICAgX3NldC5jYWxsKHRoaXMsIHNldClcbiAgICBzZXQuX3NldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0cyBzZXR0aW5ncyBmcm9tIHNldHRpbmdzb2JqZWN0IGFuZCBzdG9yZXMgdGhlbSBpbiBhbiBhcnJheS5cbiAqIEBtZXRob2QgcGFyc2VcbiAqIEBwYXJhbSAge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ29iamVjdFxuICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3QgICBTZXR0aW5nc29iamVjdFxuICovXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oc2V0dGluZ3MsIG9iamVjdCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIG9iamVjdCA9IHRoaXMuX3NldHRpbmdzXG4gIH1cbiAgZm9yICh2YXIgaSBpbiBvYmplY3QpIHtcbiAgICBpZiAoc2V0dGluZ3NbaV0pIHtcbiAgICAgIGlmICghc2V0dGluZ3MuX3NldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzLl9zZXR0aW5ncyA9IFtdO1xuICAgICAgfVxuICAgICAgc2V0dGluZ3MuX3NldHRpbmdzLnB1c2goaSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZHMgc2V0dGluZyhzKSB0byBCYXNlIHByb3RvdHlwZVxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSAge1N0cmluZ1tdfSAgICBuYW1lICBBcnJheSBvZiBzZXR0aW5nbmFtZXNcbiAqIEBwYXJhbSAge1Byb3RvdHlwZX0gICBwcm90byBQcm90b3R5cGUgZWcuIG15QmFzZSBjbGFzc1xuICovXG5leHBvcnRzLmFkZCA9IGZ1bmN0aW9uKG5hbWUsIHByb3RvKSB7IC8vc3RhcnQgdXNpbmcgdGhpcyBzb21ldGltZXMhO1xuICBpZiAobmFtZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZm9yICh2YXIgaSBpbiBuYW1lKSB7XG4gICAgICBpZiAocHJvdG8pIHtcbiAgICAgICAgdGhpcy5hZGQobmFtZVtpXSwgcHJvdG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRTZXR0aW5nKG5hbWVbaV0sIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdXRpbC5zZXRzdG9yZS5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCF0aGlzLl9fLl9zZXR0aW5ncykge1xuICAgICAgICB0aGlzLl9fLl9zZXR0aW5ncyA9IHt9O1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiBpbiB0aGlzLl8uX3NldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzW2pdID0gdGhpcy5fLl9zZXR0aW5nc1tqXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NldHRpbmdzW25hbWVdID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvdG8ucHJvdG90eXBlLl9zZXR0aW5nc1tuYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEFkZCBzZXR0aW5ncyB0byBpbnN0YW5jZXMgb2YgQmFzZVxuICogc2V0dGluZ3Mgb25seSB3b3JrIGZvciBpbnN0YW5jZXMgb2YgdGhlIGFkZGVkIEJhc2VzZXR0aW5nc1xuICogQG1ldGhvZFxuICovXG51dGlsLmRlZmluZShiYXNlLFxuICAnYWRkU2V0dGluZycsIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBleHBvcnRzLmFkZC5jYWxsKHRoaXMsIG5hbWUpO1xuICAgIGlmICh0aGlzLl9jbGFzcykge1xuICAgICAgdGhpcy5fY2xhc3MucHJvdG90eXBlLl8uX3NldHRpbmdzID0gdGhpcy5fc2V0dGluZ3M7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogU2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIHNldHRpbmcuY3JlYXRlXG4gICAqIEBtZXRob2Qgc2V0U2V0dGluZ1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNldCBTZXR0aW5nb2JqZWN0XG4gICAqL1xuICAnc2V0U2V0dGluZycsIGZ1bmN0aW9uKHNldCkge1xuICAgIC8vZWVyc3QgY2hlY2tlbiBvZiBpZSBhbCBiZXN0YWF0IGFuZGVycyBrYW4gaGV0IHZvb3Jrb21lbiBkYXQgaGV0IHRldmVlbCBpc1xuICAgIGV4cG9ydHMucGFyc2UuY2FsbCh0aGlzLCBzZXQpO1xuXG4gICAgLy8gY29uc29sZS5sb2coJ1NFVCBTRVRUSU5HJy55ZWxsb3cuaW52ZXJzZSwgc2V0LCB0aGlzLl9zZXR0aW5ncyApXG5cbiAgICAvL2dldCBnZWJydWlrZW4gLS0tIG9iamVjdCBpcyBlZW4gY2hlY2sgb3AgbWVlcmRlcmUgZmllbGRzIHJldHVybnMgdHJ1ZSBvZiBmYWxzZSAvLyBiaWogZ2V0IG9vayBtb2dlbGlqayBvbSBmaWVsZCBtZWUgdGUgZ2V2ZW5cbiAgICBfc2V0LmNhbGwodGhpcywgc2V0KTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgU0VUVElORyAtLSByZXN1bHQnLnllbGxvdy5pbnZlcnNlLCB0aGlzLl9zZXR0aW5ncyApXG5cbiAgfSxcbiAgLyoqXG4gICAqIFtkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCByZW1vdmVTZXR0aW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgbmFtZSAgICAgTmFtZSBvZiB0aGUgc2V0dGluZyB0byByZW1vdmVcbiAgICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSBzZXR0aW5ncyBTZXR0aW5nb2JqZWN0XG4gICAqL1xuICAncmVtb3ZlU2V0dGluZycsIGZ1bmN0aW9uKG5hbWUsIHNldHRpbmdzKSB7XG5cbiAgICAvLyBpZighc2V0dGluZ3MpIHtcbiAgICAvLyAgIC8vdGhpcyBtYXkgYWxsIGJlIG5vdCBuZXNzZWNhcnkhXG4gICAgLy8gICBmb3IodmFyIGkgaW4gdGhpcy5fc2V0dGluZ3MpIHtcbiAgICAvLyAgICAgZm9yKHZhciBqIGluIHRoaXMuX3NldHRpbmdzW2ldKSB7XG4gICAgLy8gICAgICAgaWYodGhpcy5fc2V0dGluZ3NbaV1bal0ubmFtZT09PW5hbWUpIHtcbiAgICAvLyAgICAgICAgIHNldHRpbmdzPXRoaXMuX3NldHRpbmdzW2ldW2pdXG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyAgICAgICB9XG4gICAgLy8gICAgIH1cbiAgICAvLyAgIH1cbiAgICAvLyB9XG5cbiAgICBpZiAoIShzZXR0aW5ncyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgLy90aGlzIG1heSBhbGwgYmUgbm90IG5lc3NlY2FyeSFcbiAgICAgIC8vIGlmKHNldHRpbmdzIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAvLyAgIHNldHRpbmdzID0gc2V0dGluZ3MuX3NldHRpbmdzXG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgICBzZXR0aW5ncyA9IFtzZXR0aW5nc107XG4gICAgICAvLyB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IHNldHRpbmdzLmxlbmd0aCAtIDEsIGZvdW5kLCBfc2V0dGluZ3MgPSB0aGlzLl9zZXR0aW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChfc2V0dGluZ3MgJiYgX3NldHRpbmdzW3NldHRpbmdzW2ldXSAmJiBfc2V0dGluZ3Nbc2V0dGluZ3NbaV1dW25hbWVdKSB7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb3VuZCkge1xuICAgICAgX3NldC5jYWxsKHRoaXMsIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgX3NldHRpbmdzOiBzZXR0aW5nc1xuICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgb2JqZWN0IGhhcyBzZXR0aW5ncyBhbmQgZXhlY3V0ZXMgdGhlbS4gQXJndW1lbnRzIGFyZSBwYXNzZWQgdG8gc2V0dGluZ3MuXG4gICAqIEBtZXRob2Qgc2V0dGluZ1xuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICAgIG5hbWUgTmFtZSBvZiB0aGUgc2V0dGluZ1xuICAgKiBAcGFyYW0gIHtBcmd1bWVudHN9IGFyZyAgQXJndW1lbnRzIHRvIHBhc3MgdG8gc2V0dGluZ3NcbiAgICovXG4gICdzZXR0aW5nJywgZnVuY3Rpb24obmFtZSwgYXJnKSB7IC8vbWlzc2NoaWVuIGFyZ1xuICAgIHZhciBfcyA9IHRoaXMuX3NldHRpbmdzO1xuICAgIGlmIChfcyAmJiBfc1tuYW1lXSAmJiBfc1tuYW1lXSAhPT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSBpbiBfc1tuYW1lXSkge1xuICAgICAgICBfc1tuYW1lXVtpXVtuYW1lXS5hcHBseSh0aGlzLCBhcmcpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbi8qKlxuICogQmFzZSBoYXMgdHdvIGRlZmF1bHQgc2V0dGluZ3NcbiAqIG5ldyBpcyBpbnZva2VkIG9uIGNvbnN0cnVjdGlvbiAsIHJlbW92ZSBvbiByZW1vdmFsO1xuICogQHNldHRpbmdzXG4gKi9cbmV4cG9ydHMuYWRkKFsnbmV3JywgJ3JlbW92ZSddLCBiYXNlKVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xudmFyIGFuaW1hdGlvbiA9IHJlcXVpcmUoJy4vJyk7XG5hbmltYXRpb24uZWFzaW5nID0gZXhwb3J0cztcbi8vIHQ6IGN1cnJlbnQgdGltZSwgYjogYmVnaW5uaW5nIHZhbHVlLCBjOiBjaGFuZ2UgSW4gdmFsdWUsIGQ6IGR1cmF0aW9uXG4vLyBjb3VydGVzeSBvZiBSb2JlcnQgUGVubmVyXG5leHBvcnRzLmluQ3ViaWMgPSBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gIHJldHVybiBjICogKHQgLz0gZCkgKiB0ICogdCArIGI7XG59O1xuXG5leHBvcnRzLm91dEN1YmljID0gZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogdCArIDEpICsgYjtcbn07XG5cbmV4cG9ydHMub3V0QmFjayA9IGZ1bmN0aW9uKHQsIGIsIGMsIGQsIHMpIHtcbiAgdmFyIHMgPSAxLjcwMTU4O1xuICByZXR1cm4gYyAqICgodCA9IHQgLyBkIC0gMSkgKiB0ICogKChzICsgMSkgKiB0ICsgcykgKyAxKSArIGI7XG59OyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlJylcbiAgLCBmcmFtZSA9IG5ldyBWYWx1ZSgxKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBfb24gPSBmdW5jdGlvbigpIHtcbiAgICAvLyBjb25zb2xlLmdyb3VwKClcbiAgICAvLyBjb25zb2xlLmxvZygnXFxuXFxuLS0tLVJBRi0tLS0nLm1hZ2VudGEuYm9sZClcbiAgICBleHBvcnRzLnJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShfb24pXG4gICAgZnJhbWUudmFsKytcbiAgICAvLyBjb25zb2xlLmdyb3VwRW5kKClcbiAgfVxuXG5mcmFtZS5kb25lID0gbmV3IFZhbHVlKHRydWUpXG5cbnV0aWwuZGVmaW5lKGZyYW1lLFxuICAnYWRkTGlzdGVuZXInLCBmdW5jdGlvbih2YWwsIG1hcmssIHJlbW92ZSkge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKXtcbiAgICAgIHRoaXMuZG9uZS52YWwgPSBmYWxzZVxuICAgICAgX29uKClcbiAgICB9XG4gICAgVmFsdWUucHJvdG90eXBlLmFkZExpc3RlbmVyLmNhbGwodGhpcywgdmFsLCBtYXJrLCByZW1vdmUpXG4gIH1cbiwgJ3JlbW92ZUxpc3RlbmVyJywgZnVuY3Rpb24odmFsLCBtYXJrLCByZW1vdmUpIHtcbiAgICB2YXIgdCA9IHRoaXNcbiAgICBWYWx1ZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIuY2FsbCh0LCB2YWwsIG1hcmssIHJlbW92ZSlcbiAgICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGV4cG9ydHMucmFmSWQpXG4gICAgICB0aGlzLnZhbCA9IDFcbiAgICAgIHRoaXMuZG9uZS52YWwgPSB0cnVlXG4gICAgfVxuICB9XG4pXG5cbm1vZHVsZS5leHBvcnRzID0gZnJhbWUiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG5cbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi4vZWxlbWVudCcpLmluamVjdChyZXF1aXJlKCcuLi9lbGVtZW50L3Byb3BlcnRpZXMnKSkgLy9lbGVtZW50IGFkZGVkIChleHRlbmQpIC8vY2FsbCBleHRlbmQgb24gZmxhZ3MgKG1ha2UgYnVmZmVyIGlmIGFscmVhZHkgZXh0ZW5kZWQpXG4gICwgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgZmxhZ3MgPSByZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy91dGlsJylcbiAgLCBvcGVyYXRvcnMgPSByZXF1aXJlKCcuLi8uLi92YWx1ZS9vcGVyYXRvcnMnKVxuICAsIGZyYW1lID0gcmVxdWlyZSgnLi9mcmFtZScpXG4gICwgX2xpbmVhciA9IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4gYyAqIHQgLyBkICsgYlxuICB9XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbm9wZXJhdG9ycy5fYSA9IGZ1bmN0aW9uICh2YWwsIG9wZXJhdG9yKSB7XG4gIHJldHVybiBvcGVyYXRvclxufVxuXG5mdW5jdGlvbiBwcmV2ZW50U2V0KHZhbCkge1xuICB0aGlzLl9wID0gdHJ1ZVxuICB0aGlzLnZhbCA9IHZhbFxuICB0aGlzLl9wID0gZmFsc2Vcbn1cblxub3BlcmF0b3JzLl9hLm9yZGVyID0gMlxuXG5mbGFncy5hbmltYXRpb24gPSB7XG4gIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgIFxuICAgIHZhciB0aGlzT2JqZWN0ID0gdGhpc1xuICAgICAgLCBfcCA9IHRoaXNPYmplY3QuY2hlY2tQYXJlbnQoJ19wcm9wJylcblxuICAgIGlmICh2YWwpIHtcblxuICAgICAgaWYgKCF0aGlzT2JqZWN0Ll92YWwpIHRoaXNPYmplY3QudmFsID0gMFxuXG4gICAgICB2YXIgbmFtZSA9IF9wLl9wcm9wLm5hbWVcbiAgICAgICAgLCBlbGVtZW50ID0gX3AuX2NhbGxlclxuICAgICAgICAsIG5vTGlzdGVuZXIgPSB2YWwubm9MaXN0ZW5lclxuICAgICAgICAsIHBhdGggPSB0aGlzT2JqZWN0Ll9wYXRoXG4gICAgICAgICwgaWQgPSBuYW1lLmNvbmNhdChwYXRoLmpvaW4oJycpKVxuICAgICAgICAsIHNraXAgPSB2YWwuc2tpcFxuICAgICAgICAsIGVhc2luZyA9IHZhbC5lYXNpbmcgXG4gICAgICAgICAgJiYgZXhwb3J0cy5lYXNpbmdbdmFsLmVhc2luZ10gXG4gICAgICAgICAgfHwgdmFsLmVhc2luZyBcbiAgICAgICAgICB8fCBfbGluZWFyXG4gICAgICAgICwgdGltZSwgc3RhcnQsIHJlYWR5XG5cbiAgICAgIGlmKCFfcC5fYW5pbUxpc3RlbikgX3AuX2FuaW1MaXN0ZW4gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHZhciB0biA9IHRoaXNbbmFtZV1cbiAgICAgICAgaWYodG4pIHRuLnVwZGF0ZSh0aGlzLCB0cnVlKVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgRk9SVEVTVElORyA9IGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGhcbiAgICAgICAgICBjb25zb2xlLmxvZygnX2FuaW1MaXN0ZW4gc2V0dGluZycsZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICBmcmFtZS5yZW1vdmVMaXN0ZW5lcih2b2lkIDAsIHRoaXMpXG4gICAgICAgICAgY29uc29sZS5sb2coJz4+IF9hbmltTGlzdGVuIHNldHRpbmcnLGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpXG4gICAgICAgICAgaWYoRk9SVEVTVElORyAmJiBGT1JURVNUSU5HID09PSAoZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aCkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcigndGhpcyA+PicsdGhpcylcbiAgICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuc2V0U2V0dGluZyh7XG4gICAgICAgIG5hbWU6J2FuaW1hdGlvbicsXG4gICAgICAgIHJlbW92ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgRk9SVEVTVElORyA9IGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGhcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIHNldHRpbmcnLGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpXG4gICAgICAgICAgXG5cbiAgICAgICAgICBmcmFtZS5yZW1vdmVMaXN0ZW5lciggdm9pZCAwLCB0aGlzKVxuXG5cbiAgICAgICAgICBpZihmcmFtZS5fbGlzdGVuZXJzICYmIEZPUlRFU1RJTkcgJiYgRk9SVEVTVElORyA9PT0gKGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSBpbiBmcmFtZS5fbGlzdGVuZXJzICkge1xuICAgICAgICAgICAgICBpZiggZnJhbWUuX2xpc3RlbmVyc1tpXSBpbnN0YW5jZW9mIEFycmF5ICkge1xuLy8gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDT01QQVJFJyxmcmFtZS5fbGlzdGVuZXJzW2ldWzFdPT09dGhpcywgZnJhbWUuX2xpc3RlbmVyc1tpXVsxXSwgJ3ZzJywgdGhpcyApXG4gICAgICAgICAgICAgICAgaWYoIGZyYW1lLl9saXN0ZW5lcnNbaV1bMV09PT10aGlzLCBmcmFtZS5fbGlzdGVuZXJzW2ldWzFdICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmcmFtZS5fbGlzdGVuZXJzLnNwbGljZShpLDEpXG4vLyAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RoaXMgPj4nLHRoaXMubm9kZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cblxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBfcC5wcmV2ZW50U2V0ID0gcHJldmVudFNldFxuXG4gICAgICBfcC5zZXQoJ3RyYW5zbGF0ZScsIHRydWUpXG5cbiAgICAgIHRoaXNPYmplY3Quc2V0KCdfYScsIHtcbiAgICAgICAgdGltZTogdmFsLnRpbWUgfHwgNjAsXG4gICAgICAgIHZhbDogZnVuY3Rpb24odiwgY3YsIGIpIHtcbiAgICAgICAgICBcbiAgICAgICAgICB2YXIgdCA9IHRoaXNcbiAgICAgICAgICAgICwgYVxuICAgICAgICAgICAgLCBwcm9wID0gX3AgLy90W25hbWVdIHx8XG4gICAgICAgICAgICAsIHByID0gdFtuYW1lXVxuXG4gICAgICAgICAgaWYgKCF0Ll9hKSB0Ll9hID0ge31cbiAgICAgICAgXG4gICAgICAgICAgaWYgKCF0Ll9hW2lkXSkge1xuXG4gICAgICAgICAgICBzdGFydCA9IHZhbC5zdGFydCA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICA/IHQucmVuZGVyZWQgJiYgKHRoaXNPYmplY3QuX19sdmFsICE9PSB2b2lkIDApXG4gICAgICAgICAgICAgICAgPyB0aGlzT2JqZWN0Ll9fbHZhbFxuICAgICAgICAgICAgICAgIDogY3ZcbiAgICAgICAgICAgICAgOiB2YWwuc3RhcnQgaW5zdGFuY2VvZiBvYmplY3QgXG4gICAgICAgICAgICAgICAgPyB2YWwuc3RhcnQudmFsXG4gICAgICAgICAgICAgICAgOiB2YWwuc3RhcnRcblxuICAgICAgICAgICAgdC5fYVtpZF0gPSB7XG4gICAgICAgICAgICAgIF9zdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIF9lbmQ6IHN0YXJ0LFxuICAgICAgICAgICAgICBfY3VycmVudDogc3RhcnQsXG4gICAgICAgICAgICAgIF9jb3VudDogMFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXQucmVuZGVyZWQpIHJldHVybiBzdGFydFxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0LnJlbmRlcmVkKSB7XG4gICAgICAgICAgICBpZihza2lwKSB7XG4gICAgICAgICAgICAgIHQuX2FbaWRdLl9jdXJyZW50ID0gY3ZcbiAgICAgICAgICAgICAgc2tpcCA9IGZhbHNlXG4gICAgICAgICAgICAgIHJldHVybiBjdlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhID0gdC5fYVtpZF1cbiAgICAgICAgICAgIGlmIChwci5fcCB8fCBleHBvcnRzLnByZXZlbnQpIHtcbiAgICAgICAgICAgICAgYS5fZnJhbWUgPSAwXG4vLyAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZW1vdmUgcHJldmVudCcsZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgZnJhbWUucmVtb3ZlTGlzdGVuZXIocHJvcC5fYW5pbUxpc3RlbiwgdGhpcywgdHJ1ZSlcbi8vICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz4+IHJlbW92ZSBwcmV2ZW50JyxmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgICAgICAgICBpZiAocHIuX3AgIT09IDEpIHtcbiAgICAgICAgICAgICAgICBhLl9jdXJyZW50ID0gYS5fZW5kID0gY3ZcbiAgICAgICAgICAgICAgICBpZiAodmFsLmNvbXBsZXRlKSBub0xpc3RlbmVyID0gdmFsLmNvbXBsZXRlLmNhbGwodCwgY3YpXG4gICAgICAgICAgICAgICAgaWYgKHZhbC5kb25lKSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgdmFsLmRvbmUuY2FsbCh0LGN2KSB9LCAwKVxuICAgICAgICAgICAgICAgIGlmICh2YWwub25jZSkge1xuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgICAgICBpZih2YWwub25jZSkgdmFsLm9uY2UuY2FsbCh0LGN2KSBcbiAgICAgICAgICAgICAgICAgICAgdmFsLm9uY2UgPSBudWxsXG4gICAgICAgICAgICAgICAgICB9LCAwKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChhLl9mcmFtZSAhPT0gZnJhbWUudmFsKSB7XG4gICAgICAgICAgICAgIGlmIChhLl9mcmFtZSB8fCAoY3YgIT09IHZvaWQgMCAmJiBhLl9jdXJyZW50ICE9PSBjdikpIHsgLy9jaGVja2luZyBhLmZyYW1lIGZhc3RlciB0aGFuIGNvbXBhcmluZyBhLmN1cnJlbnQgdG8gY3ZcbiAgICAgICAgICAgICAgICBpZiAoYS5fZW5kICE9PSBjdikge1xuXG4gICAgICAgICAgICAgICAgICBpZiAodmFsLmluaXQpIHZhbC5pbml0LmNhbGwodCwgYS5fY3VycmVudClcbiAgICAgICAgICAgICAgICAgIGlmKCFub0xpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLmFkZExpc3RlbmVyKFtwcm9wLl9hbmltTGlzdGVuLCB0aGlzLCBuYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICwgZnVuY3Rpb24gKGxpc3RlbkFycmF5LCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaSBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobGlzdGVuZXJzW2ldLnBvcCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGxpc3RlbmVyc1tpXS5wb3AgJiYgbGlzdGVuZXJzW2ldWzFdPT09dCAmJiBsaXN0ZW5lcnNbaV1bMl09PT1uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWUgXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhLl9zdGFydCA9IGEuX2N1cnJlbnRcbiAgICAgICAgICAgICAgICAgIGEuX2VuZCA9IGN2XG4gICAgICAgICAgICAgICAgICBhLl9jb3VudCA9IDBcbiAgICAgICAgICAgICAgICAgIHRpbWUgPSB+fnYudGltZS52YWxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYS5fZnJhbWUgPSBmcmFtZS52YWxcblxuICAgICAgICAgICAgICAgIGlmKHZhbC5kZWxheSl7XG4gICAgICAgICAgICAgICAgICB2YWwuZGVsYXktLVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuX3N0YXJ0XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNudCA9ICsrYS5fY291bnRcbiAgICAgICAgICAgICAgICBhLl9jdXJyZW50ID0gZWFzaW5nLmNhbGwodCwgY250LCBhLl9zdGFydCwgYS5fZW5kIC0gYS5fc3RhcnQsIHRpbWUgfHwgKHRpbWUgPSB+fnYudGltZS52YWwpKVxuICAgICAgICAgICAgICAgIGlmKHZhbFtjbnRdKSB2YWxbY250XS5jYWxsKHRoaXMsYS5fY3VycmVudCxjdilcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoYS5fY291bnQgPT09IHRpbWUpIHsgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGEuX2N1cnJlbnQgPSBjdlxuICAgICAgICAgICAgICAgIGEuX2ZyYW1lID0gMFxuICAgICAgICAgICAgICAgIGEuX2NvdW50ID0gMFxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbC5jb21wbGV0ZSkgbm9MaXN0ZW5lciA9IHZhbC5jb21wbGV0ZS5jYWxsKHQsIGN2KVxuICAgICAgICAgICAgICAgIGlmICh2YWwuZG9uZSkgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7IHZhbC5kb25lLmNhbGwodCxjdikgfSwgMClcbiAgICAgICAgICAgICAgICBpZiAodmFsLm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICAgICAgaWYodmFsLm9uY2UpIHZhbC5vbmNlLmNhbGwodCxjdikgXG4gICAgICAgICAgICAgICAgICAgIHZhbC5vbmNlID0gbnVsbFxuICAgICAgICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZighbm9MaXN0ZW5lcilcbiAgICAgICAgICAgICAgICB7XG4vLyAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncmVtb3ZlIG5vbGlzdGVuZXInLGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICBmcmFtZS5yZW1vdmVMaXN0ZW5lcihwcm9wLl9hbmltTGlzdGVuLCB0aGlzLCB0cnVlKVxuLy8gICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJz4+IHJlbW92ZSBub2xpc3RlbmVyJyxmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEuX2N1cnJlbnRcbiAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgICAgICAgXG4gICAgICBfcC5fc2tpcCA9IHRydWVcbiAgICAgIHRoaXNPYmplY3QuX3NraXAgPSB0cnVlXG4gICAgICBcbiAgICAgIGlmICh2YWwuc3RhcnQgIT09IHZvaWQgMCkge1xuICAgICAgICB2YXIgY2FsbGVyID0gdGhpcy5fY2FsbGVyXG4gICAgICAgIGlmKCFjYWxsZXIpIGNhbGxlciA9IHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wJykuX2NhbGxlclxuICAgICAgICBjYWxsZXIuc2V0UmVuZGVyKG5hbWUsIGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgICAgIHRoaXMudXBkYXRlKG5hbWUpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSBcbiAgICBlbHNlIHtcbiAgICAgIHRoaXNPYmplY3QucmVtb3ZlKCdfYScpXG4gICAgICB0aGlzT2JqZWN0Ll9za2lwID0gdm9pZCAwXG4gICAgICBfcC5fc2tpcCA9IHZvaWQgMFxuICAgICAgX3JlbW92ZShfcClcbiAgICB9XG5cbiAgfVxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cbnZhciB1YSA9IHJlcXVpcmUoJy4uL3VhJyksXG4gIFJBRiA9ICdlcXVlc3RBbmltYXRpb25GcmFtZScsXG4gIENBUCA9ICdSJyArIFJBRixcbiAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICBsYXN0RnJhbWUgPSAwO1xuXG51dGlsLmRlZmluZSh1YSwgJ2hhc1RyYW5zaXRpb24nLCB7XG4gIGdldDpmdW5jdGlvbigpIHtcbiAgICBpZighdWEuX2hhc1RyYW5zaXRpb24pIHtcbiAgICAgICB2YXIgYiA9IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50XG4gICAgICAgICwgcyA9IGIuc3R5bGVcbiAgICAgICAgLCBwID0gJ3JhbnNpdGlvbic7XG4gICAgICB1YS5faGFzVHJhbnNpdGlvbiA9IHR5cGVvZiBzWyd0JytwXSA9PT0gJ3N0cmluZycgXG4gICAgICAgIHx8IHR5cGVvZiBzW3VhLnByZWZpeCArICdUJytwXSA9PT0gJ3N0cmluZydcbiAgICB9XG4gICAgcmV0dXJuIHVhLl9oYXNUcmFuc2l0aW9uXG4gIH1cbn0pXG4gIFxuUkFGID0gJ3InICsgUkFGO1xuaWYgKCF3aW5kb3dbUkFGXSkgeyBcblxuICB1YS5ub1JhZiA9IHRydWVcblxuICAvL3dpbmRvd1t1YS5wcmVmaXggKyBDQVBdIHx8IFxuXG4gIHdpbmRvd1tSQUZdID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChjYWxsYmFjaywgMjApO1xuICB9O1xuICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbihpZCkge1xuICAgIGNsZWFyVGltZW91dChpZCk7XG4gIH07XG59XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB3aW5kb3dbUkFGXVxuXG5leHBvcnRzLnRpbWVyID0gZnVuY3Rpb24oIGZuLCBmcmFtZXMsIHJlcGVhdCApe1xuICBpZiggLS1mcmFtZXMgKXtcbiAgICBleHBvcnRzKGZ1bmN0aW9uKCl7XG4gICAgICBpZiggcmVwZWF0ICkgZm4oKVxuICAgICAgZXhwb3J0cy50aW1lciggZm4sIGZyYW1lcywgcmVwZWF0IClcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMoIGZuIClcbiAgfVxufVxuXG5leHBvcnRzLnJlcGVhdCA9IGZ1bmN0aW9uKCBmbiwgZnJhbWVzICl7XG4gIGV4cG9ydHMudGltZXIoIGZuLCBmcmFtZXMsIHRydWUgKVxufVxuXG4vL2NoZWNrIGlvcyA2IHBhdWwgaXJpc2ggc2F5cyBzdHVmZiBnb2VzIHdyb25nIHRoZXJlLi4uIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgY2FzZXMgPSByZXF1aXJlKCcuLycpLFxuICBlbGVtZW50ID0gcmVxdWlyZSgnLi4vZWxlbWVudCcpLFxuICBzZXRGbGFncyA9IHJlcXVpcmUoJy4uL2VsZW1lbnQvc2V0JyksXG4gIGJhc2UgPSByZXF1aXJlKCcuLi8uLi9iYXNlJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tQ0FTRVMgRk9SIFNFVC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciBfY3NzID0gZnVuY3Rpb24odCwgbmFtZSwgaW52ZXJ0LCByZW1vdmUpIHtcbiAgICBpZiAoIWludmVydCkge1xuICAgICAgaWYoIXQuY3NzKSB7IHQuY3NzID0gJycgfVxuICAgICAgdC5jc3Muc2V0KCByZW1vdmUgPyAncmVtb3ZlQ2xhc3MnIDogJ2FkZENsYXNzJywgbmFtZSApIFxuICAgICAgdC5jc3MudXBkYXRlKHQpXG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdcXG5cXG5cXG5zZXQgY3NzISEhISF4eHgnLCBuYW1lLCB0Lm5vZGUpXG5cbiAgICAgIHQuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignXFxuXFxuXFxuaW5zdGFuY2UhIHNldCBjc3MhISEhIScsIG5hbWUsIHQubm9kZSlcblxuICAgICAgICAvLyBpZih0aGlzLmNzcyAhPT0gdC5jc3MpIHtcbiAgICAgICAgICB0aGlzLmNzcy5zZXQoIHJlbW92ZSA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnLCBuYW1lICkgXG4gICAgICAgICAgdGhpcy5jc3MudXBkYXRlKHRoaXMpXG4gICAgICAgIC8vIH1cbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICBtZXRob2RzID0gY2FzZXMubWV0aG9kcztcblxuc2V0RmxhZ3MucmVtb3ZlID0gZnVuY3Rpb24oaSwgdmFsLCBjb3B5LCB0b3ApIHtcbiAgLy90aGlzIGNvdWxkIGJlY29tZSBhIHNlcGVyYXRlIG1vZHVsZSBzaW5jZSByZW1vdmUgbWF5IGJlIHVzZWZ1bGwgZm9yIGRpZmZlcmVudCBwdXJwb3Nlc1xuICBpZiAodmFsICYmIHZhbC5fX3JlbW92ZV9fKSB7XG4gICAgaWYgKHRoaXNbaV0gaW5zdGFuY2VvZiBiYXNlKSB7XG4gICAgICB0b3BbaV0gPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHV0aWwubG9va3VwLmNhbGwodGhpcywgaSkpIHtcbiAgICAgIGRlbGV0ZSB2YWwuX19yZW1vdmVfXztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbFtpXTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuc2V0RmxhZ3MuY2FzZXMgPSBtZXRob2RzLnJlYWRlcihmdW5jdGlvbiBjYXNlUmVhZGVyQmFzZShuYW1lLCB2YWwsIGR5bmFtaWMsIGludmVydCkge1xuICB2YXIgdCA9IHRoaXMsXG4gICAgZiA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgb2JqID0gYmFzZS5zZXQob2JqLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgICBpZiAodXRpbC5pc09iaihvYmpbaV0pKSB7XG4gICAgICAgICAgb2JqW2ldID0gZihvYmpbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgbWV0aG9kLFxuICAgIHBhcnNlZCxcbiAgICBzZXQsXG4gICAgc1ZhbCxcbiAgICBvcmlnaW5hbDtcbiAgdmFsID0gZih2YWwpO1xuXG4gIGlmIChkeW5hbWljKSB7XG4gICAgaWYgKCF0Ll9jYXNlcykge1xuICAgICAgdC5fY2FzZXMgPSB7fTtcbiAgICB9XG4gICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgaWYgKHQuX2Nhc2VzW25hbWVdLm1ldGhvZCkge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKG5hbWUsICdjYXNlID09PSBudWxsICwgcmVtb3ZlIGl0Jyk7XG4gICAgICAgIGNhc2VzW25hbWVdLnJlbW92ZUxpc3RlbmVyKHQuX2Nhc2VzW25hbWVdLm1ldGhvZCk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzZXNbbmFtZV0udmFsKSB7XG4gICAgICAgIHQuY3NzID0ge1xuICAgICAgICAgIHJlbW92ZUNsYXNzOiBuYW1lXG4gICAgICAgIH07XG4gICAgICAgICB0LmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuY3NzID0ge1xuICAgICAgICAgICAgICByZW1vdmVDbGFzczogbmFtZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgIH0pXG4gICAgICB9XG4gICAgICBkZWxldGUgdC5fY2FzZXNbbmFtZV07IC8vcmVtb3ZlcyBjYXNlIG9yZ2luYWxcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignU0VUIENBU0UnLG5hbWUsdC5fY2FzZXNbbmFtZV0mJnQuX2Nhc2VzW25hbWVdLm1ldGhvZCk7XG4gICAgICBwYXJzZWQgPSBtZXRob2RzLm9yaWdpbmFsKHQsIHRydWUsIHZhbCwgdC5fY2FzZXMsIHRydWUsIG5hbWUpO1xuICAgICAgdC5fY2FzZXNbbmFtZV0gPSB7XG4gICAgICAgIHZhbDogdmFsLFxuICAgICAgICBvcmlnOiBwYXJzZWRbMF0sXG4gICAgICAgIG5lc3RlZDogcGFyc2VkWzFdXG4gICAgICB9O1xuXG4gICAgICBpZiAoIXQuX2Nhc2VzW25hbWVdLm1ldGhvZCkge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd0aGlzIGlzIHdoYXQgaSBoYXZlIHNldCBmb3Igb3JpZ2luYWwnLCB0Ll9jYXNlcyk7XG4gICAgICAgIG1ldGhvZCA9IHQuX2Nhc2VzW25hbWVdLm1ldGhvZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0xFVFMgVFJZIFRPIFJVTiBNRVRIT0QnLG5hbWUsdmFsKTtcblxuICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgIHNldCA9IG1ldGhvZHMubWVyZ2UodHJ1ZSwgbmFtZSwgdmFsLCB0Ll9jYXNlcyk7IC8vYXJnIG5vIHZhbDtcbiAgICAgICAgICAgIHNWYWwgPSBzZXQgWzBdO1xuICAgICAgICAgICAgb3JpZ2luYWwgPSBzZXRbMV07XG4gICAgICAgICAgICBkZWxldGUgc1ZhbC52YWw7XG4gICAgICAgICAgICBkZWxldGUgb3JpZ2luYWwudmFsO1xuICAgICAgICAgICAgaWYgKGNhc2VzW25hbWVdLnZhbCkge1xuICAgICAgICAgICAgICBfY3NzKHQsIG5hbWUsIGludmVydCk7XG4gICAgICAgICAgICAgIHQuc2V0KHNWYWwsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgX2Nzcyh0LCBuYW1lLCBpbnZlcnQsIHRydWUpO1xuICAgICAgICAgICAgICB0LnNldChvcmlnaW5hbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdBREQgTElTVEVORVIgVE8nLG5hbWUsICB0Ll9jYXNlc1tuYW1lXSk7XG4gICAgICAgIGNhc2VzW25hbWVdLmFkZExpc3RlbmVyKG1ldGhvZCk7XG4gICAgICAgIC8vcmVtb3ZlIHNldHRpbmcgb24gcmVtb3ZlIChzYXZlcyBtZW1vcnkpXG4gICAgICAgIHQuc2V0U2V0dGluZyh7XG4gICAgICAgICAgbmFtZTogJ19jJyArIG5hbWUsXG4gICAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKHRoaXMgPT09IHQgKSB7XG4gICAgICAgICAgICAgIGNhc2VzW25hbWVdLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCk7IC8vaWYoIXRoaXMuY3NzID09PSB0aGlzLl9mcm9tLmJhc2UuY3NzKSBcbiAgICAgICAgICAgICAgdGhpcy5fY2FzZXNbbmFtZV0ubWV0aG9kID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG5hbWUsICdhbHJlYWR5IGdvdCBsaXN0ZW5lcnMgZm9yIGNhc2UnLG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGNhc2VzW25hbWVdLnZhbCkge1xuICAgICAgICBfY3NzKHQsIG5hbWUsIGludmVydCk7XG4gICAgICAgIHQuc2V0KHZhbCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIF9jc3ModCwgbmFtZSwgaW52ZXJ0KTtcbiAgICB0LnNldCh2YWwpOyAvL21heWJlIGNvcHkgYXJncz9cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn0pOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICBlbGVtZW50ID0gcmVxdWlyZSgnLi4vZWxlbWVudCcpLCAvL2VsZW1lbnQgL3cgZXh0ZW5kXG4gIHZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUnKSxcbiAgZmxhZ3MgPSByZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncycpO1xuXG4vKipcbiAqIGNhc2VzXG4gKiBjYXNlcyBhcmUgdXNlZCB0byBzZXQgb25lIG9yIG1vcmUgdmFsdWVzIHdoZW4gYSBzcGVjaWZpYyBjYXNlIGlzIHRydWVcbiAqIHRoZXJlIGFyZSAyIHR5cGVzIG9mIGNhc2VzICwgc3RhdGljIGFuZCBkeW5hbWljICxcbiAqIHN0YXRpYyBjYXNlcyBhcmUgc2V0IGF0IGluaXRpYWxpemF0aW9uIG9mIHRoZSBhcHBsaWNhdGlvbiAsIHVzZWZ1bGwgZm9yIHRoaW5ncyBzdWNoIGFzIGRldmljZSB0eXBlIChwaG9uZSwgZGVza3RvcCwgdHYpXG4gKiBkeW5hbWljIGNhc2VzIGNhbiBiZSBjaGFuZ2VkIGR5bmFtaWNseSBhbmQgT2JqZWN0cyBvciBCYXNlcyB0aGF0IHVzZSB0aGUgY2FzZSB3aWxsIGJlIGNoYW5nZWQgZHluYW1pY2x5IGFzIHdlbGxcbiAqL1xuXG51dGlsLmRlZmluZShleHBvcnRzLCAnbWV0aG9kcycsIHt9KTtcbi8vbXVsdGlwbGUsIHJlY3Vyc2l2ZSBhbmQgb3JpZ2luYWwgaGF2ZSB0byBiZWNvbWUgZXh0ZW5zaW9ucyBvbiBWLk9iamVjdC5jb252ZXJ0IHNvIGl0J3MgcG9zc2libGUgdG8gdXNlIHRoZSBzYW1lIGZvciBkYXRhIGFuZCBldmVudHNcblxudmFyIF9pc09iaiA9IHV0aWwuaXNPYmosXG4gIC8qXG4gICAgX3JlY3VyXG4gICAgc3BlY2lhbCBtZXJnZSB0aGF0IGFkZHMgX19yZW1vdmVfXyBpZiBhIGZpZWxkIGhhcyB0byBiZSByZW1vdmVkXG4gICovXG4gIF9yZWN1ciA9IGZ1bmN0aW9uKG9yaWdpbmFsLCBtZXJnZSwgZmllbGRFeGlzdHMpIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKG9yaWdpbmFsLCBtZXJnZSwgZmllbGRFeGlzdHMpXG5cbiAgICB2YXIga2V5cywgaSwga2V5LCBvcmlnaW5hbENoaWxkLCBtZXJnZUNoaWxkO1xuICAgIGlmIChmaWVsZEV4aXN0cykge1xuICAgICAga2V5cyA9IHt9O1xuICAgICAgZm9yIChrZXkgaW4gb3JpZ2luYWwpIHtcbiAgICAgICAga2V5c1trZXldID0gdHJ1ZTsgLy9rZXlzIGNhbiBiZSB1bmRlZmluZWQgLS0gY29kZSBjYW4gYmVjb21lIHNob3J0ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpIGluIG1lcmdlKSB7XG4gICAgICBpZiAoIWZpZWxkRXhpc3RzIHx8IGtleXNbaV0pIHtcbiAgICAgICAgb3JpZ2luYWxDaGlsZCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICBtZXJnZUNoaWxkID0gbWVyZ2VbaV07XG4gICAgICAgIGlmIChvcmlnaW5hbENoaWxkIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKG9yaWdpbmFsQ2hpbGQuX19yZW1vdmVfXyAmJiAobWVyZ2VDaGlsZCAmJiAhbWVyZ2VDaGlsZC5fX3JlbW92ZV9fKSkge1xuICAgICAgICAgICAgZGVsZXRlIG9yaWdpbmFsQ2hpbGQuX19yZW1vdmVfXztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCEobWVyZ2VDaGlsZCBpbnN0YW5jZW9mIE9iamVjdCkpIHtcbiAgICAgICAgICAgIG1lcmdlW2ldID0ge1xuICAgICAgICAgICAgICB2YWw6IG1lcmdlQ2hpbGRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICAgIF9yZWN1cihvcmlnaW5hbENoaWxkLCBtZXJnZUNoaWxkLCBmaWVsZEV4aXN0cyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWxbaV0gPSBtZXJnZUNoaWxkO1xuICAgICAgICAgIG9yaWdpbmFsQ2hpbGQgPSAnYnVybic7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qXG4gICAgICAgICAgX211bHRpcGxlXG4gICAgICAgICAgbWVyZ2UgbXVsdGlwbGUgb3JnaW5hbHMgaW50byBhIG5ldyBvcmdpbmFsIG9iamVjdCBhbHNvIHJlc29sdmUgbmVzdGVkIGNhc2VzXG4gICAgICAqL1xuICBfbXVsdGlwbGUgPSBmdW5jdGlvbih0LCBuZXN0ZWQsIGNhc2VzLCBjdXJyZW50T2JqLCBjdXJyZW50VmFsLCBiYXNlLCBuYW1lLCBwYXRoLCBvcmlnKSB7XG5cbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIG9yaWcgPSB0O1xuICAgICAgcGF0aCA9IFtdO1xuICAgIH1cbiAgICB2YXIgaiwgX2Nhc2UsIGN2Q2hpbGQ7XG5cbiAgICBpZigoY3VycmVudFZhbCBpbnN0YW5jZW9mIG9iamVjdCkgJiYgIWJhc2UpIHtcblxuICAgICAgLy8gY3VycmVudE9iai52YWwgPSB0Ll92YWxcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1ZPQkonLCBjdXJyZW50T2JqKVxuXG5cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRWYWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGZvciAoaiBpbiBjdXJyZW50VmFsKSB7XG4gICAgICAgIGN2Q2hpbGQgPSBjdXJyZW50VmFsW2pdO1xuICAgICAgICBpZiAoZXhwb3J0c1tqXSkge1xuICAgICAgICAgIF9jYXNlID0gZXhwb3J0c1tqXTtcbiAgICAgICAgICBpZiAoX2Nhc2UgaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgICAgICAgIGlmICghYmFzZSB8fCAhZWxlbWVudC5zZXQubG9va3VwLmNhbGwob3JpZywgcGF0aFtwYXRoLmxlbmd0aCAtIDFdKSkgeyAvL2VsZW1lbnQgaXMgcmVxdWlyZWQgaW4gY2FzZXMuYmFzZSwgbWFrZSB0aGlzIHBhcnQgZXh0ZW5kYWJsZVxuICAgICAgICAgICAgICBuZXN0ZWRbal0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV9pc09iaihjdkNoaWxkKSkge1xuICAgICAgICAgICAgY3VycmVudE9iai52YWwgPSB0ICYmICh0Ll92YWwgIT09IHZvaWQgMCA/IHQuX3ZhbCA6IHZvaWQgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChqKTtcbiAgICAgICAgICAgIC8vc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBuZXN0ZWQgZm9yIGN1cnJlbnQgbmVzdGVkIGNhc2U7XG4gICAgICAgICAgICBfbXVsdGlwbGUodCwgbmVzdGVkLCBjYXNlcywgY3VycmVudE9iaiwgY3ZDaGlsZCwgYmFzZSwgbmFtZSwgcGF0aCwgb3JpZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRPYmpbal0gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChfaXNPYmooY3ZDaGlsZCkpIHtcbiAgICAgICAgICAgIGlmICghY3VycmVudE9ialtqXSkge1xuICAgICAgICAgICAgICBjdXJyZW50T2JqW2pdID0gKHQgJiYgdFtqXSAmJiB0W2pdLmNvbnZlcnQgJiYgdFtqXS5jb252ZXJ0KGN2Q2hpbGQpKSB8fCAoY3ZDaGlsZCBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoLnB1c2goaik7XG4gICAgICAgICAgICBfbXVsdGlwbGUodCAmJiB0W2pdLCBuZXN0ZWQsIGNhc2VzLCBjdXJyZW50T2JqW2pdLCBjdkNoaWxkLCBiYXNlLCBuYW1lLCBwYXRoLCBvcmlnKTtcbiAgICAgICAgICAgIGlmIChiYXNlICYmICghdCB8fCAhdFtqXSkpIHtcbiAgICAgICAgICAgICAgY3VycmVudE9ialtqXS5fX3JlbW92ZV9fID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHQgJiYgY3VycmVudE9iaiAmJiAhY3VycmVudE9ialtqXSkge1xuICAgICAgICAgICAgICBpZiAoZmxhZ3Nbal0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudE9ialtqXTtcbiAgICAgICAgICAgICAgICBjdXJyZW50T2JqLnZhbCA9IHQuX3ZhbCAhPT0gdm9pZCAwID8gdC5fdmFsIDogdm9pZCAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRPYmpbal0gPSBqID09PSAndmFsJyBcbiAgICAgICAgICAgICAgICAgID8gKHQuX3ZhbCAhPT0gdm9pZCAwID8gdC5fdmFsIDogdm9pZCAwKSBcbiAgICAgICAgICAgICAgICAgIDogKHRbal0hPT12b2lkIDAgJiYgdFtqXS5jb252ZXJ0ICYmIHRbal0uY29udmVydCgpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKlxuICAgICAgb3JpZ2luYWxcbiAgICAgIGNyZWF0ZSBhIG9yZ2luYWwgc3RvcmUgZm9yIGEgbmV3IGNhc2VcbiAgICAqL1xuZXhwb3J0cy5tZXRob2RzLm9yaWdpbmFsID0gZnVuY3Rpb24odCwgaXNPYmosIHZhbCwgY2FzZXMsIGJhc2UsIG5hbWUpIHtcblxuXG5cbiAgdmFyIG9iaiA9IGlzT2JqID8gdC5jb252ZXJ0KHZhbCkgOiB0Ll92YWwsXG4gICAgaSwgY2ZsYWcsIG5lc3RlZCA9IHt9O1xuXG4gIF9tdWx0aXBsZSh0LCBuZXN0ZWQsIGNhc2VzLCBvYmosIHZhbCwgYmFzZSwgbmFtZSk7XG5cbiAgLy8gZm9yKHZhciBpIGluIG5lc3RlZCkge1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoJ05FU1RFRDo6OicsaSk7XG4gIC8vIH1cbiAgLy8gY29uc29sZS5sb2coYmFzZSA/ICdCQVNFOic6ICdQUk9QRVJUWTonICwgbmFtZSwnT1JJR0lOQUwgR0VORVJBVElPTicsJ1xcbnZhbDonLHZhbCwnXFxub2JqOicsb2JqLCdcXG5uZXN0ZWQ6JyxuZXN0ZWQsJ1xcbmNhc2VzOicsY2FzZXMpO1xuXG4gIGZvciAoaSBpbiBjYXNlcykge1xuICAgIGlmICghbmVzdGVkW2ldKSB7XG4gICAgICBjZmxhZyA9IGNhc2VzW2ldLm9yaWc7XG4gICAgICBpZiAoIWlzT2JqKSB7XG4gICAgICAgIGlmIChfaXNPYmooY2ZsYWcpKSB7XG4gICAgICAgICAgaWYgKGNmbGFnLnZhbCkge1xuICAgICAgICAgICAgb2JqID0gY2ZsYWcudmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvYmogPSBjZmxhZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF9pc09iaihjZmxhZykpIHtcbiAgICAgICAgICBpZiAoIWNhc2VzW2ldLm5lc3RlZFtuYW1lXSkge1xuICAgICAgICAgICAgX3JlY3VyKG9iaiwgY2ZsYWcsIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvYmoudmFsKSB7XG4gICAgICAgICAgb2JqLnZhbCA9IGNmbGFnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuXG4gIHJldHVybiBbb2JqLCBuZXN0ZWRdO1xufTtcbi8qXG4gIG1lcmdlXG4gIG1lcmdlIGR5bmFtaWMgY2FzZXMgKG92ZXJ3cml0ZSAvdyBjYXNlcyB0aGF0IGFyZSB0cnVlIGFuZCBmdXJ0aGVyIGluIHRoZSBvcmRlciBvZiBjYXNlcylcbiovXG5leHBvcnRzLm1ldGhvZHMubWVyZ2UgPSBmdW5jdGlvbihpc09iaiwgbmFtZSwgdmFsLCBjYXNlcykge1xuICB2YXIgb3JpZ2luYWwgPSB1dGlsLmNsb25lKGNhc2VzW25hbWVdLm9yaWcpLFxuICAgIHNWYWwgPSB2YWwsXG4gICAgb3ZlcndyaXRlLFxuICAgIGksXG4gICAgbWVyZ2UsXG4gICAgb3JpZ2luYWxDaGlsZDtcbiAgZm9yIChpIGluIGNhc2VzKSB7XG4gICAgaWYgKGkgIT09IG5hbWUgJiYgIWNhc2VzW25hbWVdLm5lc3RlZFtpXSkge1xuICAgICAgaWYgKGV4cG9ydHNbaV0udmFsKSB7XG4gICAgICAgIG1lcmdlID0gY2FzZXNbaV0udmFsO1xuICAgICAgICBpZiAoX2lzT2JqKG9yaWdpbmFsKSB8fCBfaXNPYmoobWVyZ2UpKSB7XG4gICAgICAgICAgaWYgKCFfaXNPYmoob3JpZ2luYWwpKSB7XG4gICAgICAgICAgICBvcmlnaW5hbCA9IHtcbiAgICAgICAgICAgICAgdmFsOiBvcmlnaW5hbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfaXNPYmoobWVyZ2UpKSB7XG4gICAgICAgICAgICBtZXJnZSA9IHtcbiAgICAgICAgICAgICAgdmFsOiBtZXJnZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3JlY3VyKG9yaWdpbmFsLCBtZXJnZSwgdHJ1ZSk7XG4gICAgICAgICAgZm9yIChpIGluIGV4cG9ydHMpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsQ2hpbGQgPSBvcmlnaW5hbFtpXTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbENoaWxkICE9PSBudWxsICYmIG9yaWdpbmFsQ2hpbGQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBkZWxldGUgb3JpZ2luYWxbaV07IC8vZGVsZXRlIGlzIHByZXR0eSBzbG93XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdmVyd3JpdGUpIHtcbiAgICAgICAgICAgIGlmIChpc09iaikge1xuICAgICAgICAgICAgICBpZiAoc1ZhbCA9PT0gdmFsKSB7XG4gICAgICAgICAgICAgICAgc1ZhbCA9IHV0aWwuY2xvbmUoc1ZhbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbWVyZ2UgPSB1dGlsLmNsb25lKG1lcmdlKTtcbiAgICAgICAgICAgICAgZm9yIChpIGluIGV4cG9ydHMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVyZ2VbaV0gIT09IG51bGwgJiYgbWVyZ2VbaV0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignUkVNT1ZFIEZJWCcsIGkpO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIG1lcmdlW2ldOyAvL2RlbGV0ZSBpcyBwcmV0dHkgc2xvd1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfcmVjdXIoc1ZhbCwgbWVyZ2UsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKG1lcmdlLnZhbCkge1xuICAgICAgICAgICAgICAgIHNWYWwgPSBtZXJnZS52YWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3JpZ2luYWwgPSBtZXJnZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdmVyd3JpdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3NWYWwsIG9yaWdpbmFsXTtcbn07XG4vKlxuICByZWFkZXJcbiAgYWJzdHJhY3Rpb24gZm9yIHVzZSBpbiBjYXNlcy5vYmplY3QgYW5kIGNhc2VzLmJhc2VcbiovXG5leHBvcnRzLm1ldGhvZHMucmVhZGVyID0gZnVuY3Rpb24oZm4sIGR5bmFtaWMsIF9zdGF0aWMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHJlYWRlcihuYW1lLCB2YWwpIHtcbiAgICB2YXIgaW52ZXJ0ID0gKG5hbWVbMF0gPT09ICchJyksXG4gICAgICB2Q2FzZSA9IGludmVydCA/IGV4cG9ydHNbKG5hbWUuc2xpY2UoMSkpXSA6IGV4cG9ydHNbbmFtZV0sXG4gICAgICByZXQ7XG4gICAgaWYgKHZDYXNlKSB7XG4gICAgICBpZiAodkNhc2UgaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGludmVydCAmJiAhZXhwb3J0c1tuYW1lXSkge1xuICAgICAgICAgIGV4cG9ydHNbbmFtZV0gPSBuZXcgdmFsdWUoe1xuICAgICAgICAgICAgdmFsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICF2Q2FzZS52YWw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGlzdGVuOiB2Q2FzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldCA9IGZuID8gZm4uY2FsbCh0aGlzLCBuYW1lLCB2YWwsIHRydWUsIGludmVydCkgOiBkeW5hbWljO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gaW52ZXJ0ID8gISFmbiA6IGZuID8gZm4uY2FsbCh0aGlzLCBuYW1lLCB2YWwpIDogX3N0YXRpY1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW52ZXJ0KSB7XG4gICAgICByZXQgPSBmbiA/IGZuLmNhbGwodGhpcywgbmFtZSwgdmFsLCBmYWxzZSwgaW52ZXJ0KSA6IF9zdGF0aWM7XG4gICAgfVxuICAgIGlmICh2Q2FzZSA9PT0gZmFsc2UgJiYgZm4pIHtcbiAgICAgIHJldCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH07XG59O1xuXG5yZXF1aXJlKCcuL29iamVjdCcpO1xucmVxdWlyZSgnLi9iYXNlJyk7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgZmxhZ3MgPSByZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncycpLFxuICBDYXNlcyA9IHJlcXVpcmUoJy4vJyksXG4gIG9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICBtZXRob2RzID0gQ2FzZXMubWV0aG9kcyxcbiAgZHluYW1pYyA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIHJlc2V0LCBuYW1lKSB7XG5cbiAgICAgIGlmKCF0aGlzLl9mbGFnKSB0aGlzLl9mbGFnID0ge31cblxuICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgIC8vc2VsZWN0aW9uIGZvciB0Ll9mbGFnIGVhc3kgbWFrZW5cbiAgICAgICAgICBcbiAgICAgICAgICBcbiAgICAgICAgZmxhZ3MgPSB0Ll9mbGFnLmNhc2UgfHwgKHQuX2ZsYWcuY2FzZSA9IFtcbiAgICAgICAgICAnY2FzZScsXG4gICAgICAgICAgdC5fdmFsLFxuICAgICAgICAgIGZhbHNlLCB7fSxcbiAgICAgICAgICBkeW5hbWljXG4gICAgICAgIF0pLFxuICAgICAgICBjYXNlcyA9IGZsYWdzWzNdLFxuICAgICAgICBpc09iaiA9IHV0aWwuaXNPYmoodmFsKSxcbiAgICAgICAgc2V0VmFsID0gKGlzT2JqICYmICF2YWwudmFsKSA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGNhc2VzW25hbWVdKSB7XG4gICAgICAgICAgQ2FzZXNbbmFtZV0ucmVtb3ZlTGlzdGVuZXIoY2FzZXNbbmFtZV0ubWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgY2FzZXNbbmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGFnc1s1XSA9IHRydWU7XG4gICAgICAgIGlmICghY2FzZXNbbmFtZV0pIHtcbiAgICAgICAgICB2YXIgeCA9IG1ldGhvZHMub3JpZ2luYWwodCwgaXNPYmosIHZhbCwgY2FzZXMsIGZhbHNlLCBuYW1lKTtcbiAgICAgICAgICBjYXNlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgIHZhbDogdmFsLFxuICAgICAgICAgICAgb3JpZzogeFswXSxcbiAgICAgICAgICAgIG5lc3RlZDogeFsxXSxcbiAgICAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBzZXQgPSBtZXRob2RzLm1lcmdlKGlzT2JqLCBuYW1lLCB2YWwsIGNhc2VzKSxcbiAgICAgICAgICAgICAgc1ZhbCA9IHNldFswXSxcbiAgICAgICAgICAgICAgb3JpZ2luYWwgPSBzZXRbMV07XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5hbWUpXG4gICAgICAgICAgICAgIC8vIGlmKG5hbWUgPT09ICckaXNBY3RpdmUnICljb25zb2xlLmVycm9yKCdib2Vsb2UgYm9lbG9lIGJvZWxvZSEhIScsc1ZhbCxvcmlnaW5hbClcblxuICAgICAgICAgICAgICBmbGFnc1s1XSA9IHRydWU7IC8vdGhlIGNsb3N1cmVzIGhlcmUgYXJlIG5vdCByZWFsbHkgbmVzc2VjYXJ5IGJldHRlciB0byBhdm9pZFxuICAgICAgICAgICAgICBpZiAoQ2FzZXNbbmFtZV0udmFsKSB7XG5cbiAgICAgICAgICAgICAgICBpZighc1ZhbCkgY29uc29sZS53YXJuKG5hbWUsJ3dyb25nIGluIGNhc2VzIScsIHNWYWwsIENhc2VzLCBmbGFncylcbiAgICAgICAgICAgICAgICBpZiAoc2V0VmFsICYmIHNWYWwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGlmKG5hbWUgPT09ICckaXNBY3RpdmUnICljb25zb2xlLmxvZygneWVlIGl0cyB0cnVlJylcbiAgICAgICAgICAgICAgICAgIGZsYWdzWzFdID0gc1ZhbC52YWwgfHwgc1ZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdC52YWwgPSBzVmFsO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmKG5hbWUgPT09ICckaXNBY3RpdmUnICljb25zb2xlLmxvZygnbm8gd2F5IGdvemVlJylcblxuICAgICAgICAgICAgICAgIGlmIChzZXRWYWwpIGZsYWdzWzFdID0gb3JpZ2luYWwgJiYgb3JpZ2luYWwudmFsIHx8IG9yaWdpbmFsXG5cbiAgICAgICAgICAgICAgICBpZihuYW1lID09PSAnJGlzQWN0aXZlJyApY29uc29sZS5sb2coJ25vIHdheSBnb3plZSAyJyxvcmlnaW5hbCwgdClcblxuICAgICAgICAgICAgICAgIHQudmFsID0gb3JpZ2luYWw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmxhZ3NbNV0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgQ2FzZXNbbmFtZV0uYWRkTGlzdGVuZXIoZmxhZ3NbM11bbmFtZV0ubWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQ2FzZXNbbmFtZV0udmFsKSB7XG4gICAgICAgICAgaWYgKHNldFZhbCkge1xuICAgICAgICAgICAgZmxhZ3NbMV0gPSB2YWwudmFsIHx8IHZhbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqZWN0LnNldC5jYWxsKHQsIHZhbCwgc3RhbXAsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAvL25vdCBhbHdheXNcbiAgICAgICAgICB0Ll9pZ25vcmVmb3Jub3cgPSB0cnVlXG5cbiAgICAgICAgfVxuICAgICAgICBmbGFnc1s1XSA9IG51bGw7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyByZXNldDpmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3Jlc2V0JylcbiAgICAvLyB9LFxuICAgIC8vYWRkIHJlc2V0IGxhdGVyXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihmbGFncywgbmFtZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coZmxhZ3MsIG5hbWUpXG4gICAgICB2YXIgY250ID0gMFxuICAgICAgZm9yICh2YXIgaSBpbiBmbGFnc1szXSkge1xuICAgICAgICAvLyBpZihmbGFnc1szXSlcbiAgICAgICAgY250KytcbiAgICAgICAgaWYoIXRoaXMuX2lnbm9yZWZvcm5vdyAmJiAhbmFtZSB8fCBpPT09bmFtZSkge1xuICAgICAgICAgIGNudCAtLVxuICAgICAgICAgIENhc2VzW2ldLnJlbW92ZUxpc3RlbmVyKGZsYWdzWzNdW2ldLm1ldGhvZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2lnbm9yZWZvcm5vd1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihjbnQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NBU0UgT0JKRUNUIFJFTU9WQUwgLS0tIElUIElTIE5PVCBFTVBZJylcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0YWNrOiAnY2FzZSdcbiAgfSxcbiAgX3N0YXRpYyA9IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIHJlc2V0LCBuYW1lKSB7XG4gICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgIG9iamVjdC5zZXQuY2FsbCh0aGlzLCB2YWwsIHN0YW1wLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG5mbGFncy5keW5hbWljLmNhc2VzID0gbWV0aG9kcy5yZWFkZXIoZmFsc2UsIGR5bmFtaWMsIF9zdGF0aWMpOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxuLypcbiAgZ2V0cyBhbmQgY2FjaGVzIHZhbHVlcyBmb3IgY3NzIGNsYXNzZXMsIGFsc28gcG9zc2libGUgdG8gY2hhbmdlIHN0eWxlcyBvZiBjbGFzc2VzXG4gIHJldHVybiBhbiBhcnJheSBvZiBtdWx0aXBsZSBjc3Mgb2JqZWN0cyBjb3JyZXNwb25kaW5nIHRvIHRoZSBjbGFzcyBuYW1lXG4gIHdoZW4geW91IHBhc3MgZmllbGQgaXQgc2VhcmNoZXMgdGhlIGZpZWxkIHRyb3VnaCBhbGwgdGhlIGNsYXNzZXMgc2VsZWN0ZWQsIGFsd2F5cyB0YWtlcyBmaXJzdCBhcmd1bWVudFxuICBtYXliZSBoYXZlIHRvIG1ha2UgdGhpcyBmb3IgdGhpbmdzIHN1Y2ggYXMgZGl2IHNlbGVjdG9ycyAvIG5lc3RlZCBzdHVmZiAtLS0gd2lsbCBiZSBjcHUgaW50ZW5zaXZlITtcbiovXG52YXIgc2VsZWN0b3IgPSAnY3NzUnVsZXMnLFxuICBwYXJzZWNsYXNzID0gZnVuY3Rpb24oc2xjdHIpIHtcbiAgICBzbGN0ciA9ICcuJyArIHNsY3RyLnJlcGxhY2UoL1xcLi9nLCAnIC4nKS50b0xvd2VyQ2FzZSgpO1xuICAgIGZvciAodmFyIHJvYmosIHNlbGVjdCA9IGRvY3VtZW50LnN0eWxlU2hlZXRzLCBsZW5ndGggPSBzZWxlY3QubGVuZ3RoLCBpID0gMCwgc2VsZWN0SXRlbTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBzZWxlY3RJdGVtID0gc2VsZWN0W2ldW3NlbGVjdG9yXSB8fCBzZWxlY3RbaV1bKHNlbGVjdG9yID0gJ3J1bGVzJyldOyAvL2xvY2F0aW9uIG9mIHRoaXMgcG9seWZpbGwgY2FuIGJlIGltcHJvdmVkXG4gICAgICBpZihzZWxlY3RJdGVtKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gc2VsZWN0SXRlbS5sZW5ndGgsIGl0ZW07IHNlbGVjdEl0ZW0sIGogPCBsOyBpdGVtID0gc2VsZWN0SXRlbVtqKytdLCBpdGVtLnNlbGVjdG9yVGV4dCA9PT0gc2xjdHIgJiYgKHJvYmogPSBpdGVtLnN0eWxlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByb2JqO1xuICB9LFxuICBjID0gZnVuY3Rpb24oY3NzQ2xhc3MsIGNhY2hlKSB7XG4gICAgdmFyIHQgPSBleHBvcnRzO1xuICAgIGNhY2hlLnB1c2godFtjc3NDbGFzc10gfHwgKHRbY3NzQ2xhc3NdID0gcGFyc2VjbGFzcyhjc3NDbGFzcykpIHx8IHt9KTtcbiAgICByZXR1cm4gY3NzQ2xhc3M7XG4gIH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2xjdHIsIGZpZWxkKSB7XG4gIGlmIChzbGN0cikge1xuICAgIHZhciBjYWNoZSA9IHRoaXNbc2xjdHJdO1xuICAgIGlmICghY2FjaGUpIHtcbiAgICAgIGNhY2hlID0gW107XG4gICAgICBmb3IgKHZhciBzZWxlY3RhcnJheSA9IHNsY3RyLnNwbGl0KCcgJyksIGkgPSAwLCBsID0gc2VsZWN0YXJyYXkubGVuZ3RoLCBjc3NDbGFzczsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoKGNzc0NsYXNzID0gYyhzZWxlY3RhcnJheVtpXSwgY2FjaGUpLnNwbGl0KCcuJykpIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICBjKGNzc0NsYXNzW2Nzc0NsYXNzLmxlbmd0aCAtIDFdLCBjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXNbc2xjdHJdID0gY2FjaGU7XG4gICAgfVxuICAgIGlmIChmaWVsZCkge1xuICAgICAgaWYoIShjYWNoZSBpbnN0YW5jZW9mIEFycmF5KSlcbiAgICAgICAgcmV0dXJuXG4gICAgICBmb3IgKHZhciByZXQsIGkgPSBjYWNoZS5sZW5ndGggLSAxOyAhcmV0ICYmIGkgPj0gMDsgcmV0ID0gY2FjaGVbaS0tXVtmaWVsZF0pO1xuICAgICAgY2FjaGUgPSByZXQ7ICBcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlO1xuICB9XG59OyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBiYXNlID0gcmVxdWlyZSgnLi4vLi4vYmFzZScpXG4gICwgdmFsdWVCYXNlID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUvYmFzZScpXG4gICwgdmlnb3VyID0gcmVxdWlyZSgnLi4vLi4vJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgZWxlbWVudEJhc2UgPSBuZXcgYmFzZSgpXG5cbmVsZW1lbnRCYXNlLmRlZmF1bHRUeXBlID0gdmFsdWVCYXNlLnR5cGVcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gdmlnb3VyLkVsZW1lbnQgPSBlbGVtZW50QmFzZS5DbGFzc1xuZXhwb3J0cy5iYXNlID0gZWxlbWVudEJhc2VcblxudmFyIF9kb2MgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiAnbm8gZG9jdW1lbnQnLCAvL3JlZmVyZW5jZSB0byBkb2N1bWVudCBpcyBmYXN0ZXIgdGhhbiB1c2luZyB3aW5kb3cuZG9jdW1lbnQ7XG4gIC8qKlxuICAgKiBSZW1vdmVzIGNoaWxkcmVuIGZyb20gcGFyZW50IG5vZGVcbiAgICogQG1ldGhvZCBfcmVtb3ZlQ2hpbGRyZW5cbiAgICovXG4gIF9yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGMgPSB0aGlzLl9ub2RlLmNoaWxkTm9kZXMsIGkgPSAwLCBsID0gYy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChjW2ldLmJhc2UpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2dcbiAgICAgICAgY1tpXS5iYXNlLnJlbW92ZShmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBub2RlXG4gKiBhZGRzIGFuZCBjbG9uZXMgaHRtbCBub2RlcztcbiAqIEBhdHRyaWJ1dGVcbiAqL1xuZXhwb3J0cy5iYXNlLmV4dGVuZCh7XG4gICAgbmFtZTogJ25vZGUnLFxuICAgIHR5cGU6IGZhbHNlICxcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIG5vZGUgaXMgc2V0XG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0gIHsqfSB2YWwgRGVmaW5lcyB0aGUgdmFsdWUgb2YgdGhpcy5fbm9kZVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAvL2NoYW5naW5nIG5vZGUgYnVncyAvdyBjb252ZXJzaW9uc1xuICAgICAgLy9pZnJhbWUgc2VsZWN0b3JzIGRvbnQgZXZhbHVhdGUgdG8gYSBzdHJpbmdcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QgfHwgIXZhbC5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbm9kZSA9IHZhbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25vZGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQodmFsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX25vZGUuYmFzZSA9IHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHlvdSBnZXQgbm9kZVxuICAgICAqIEBtZXRob2QgZ2V0XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5fbm9kZSkge1xuICAgICAgICB0aGlzLm5vZGUgPSBfZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHlvdSBjcmVhdGUgYSBuZXcgbm9kZVxuICAgICAqIEBtZXRob2QgbmV3XG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBmcm9tICAgIFRhcmdldFxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbmV3bm9kZSBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgXCJuZXdcIjogZnVuY3Rpb24oZnJvbSwgbmV3bm9kZSkge1xuICAgICAgaWYgKCFuZXdub2RlKSB7XG4gICAgICAgIHZhciBub2RlID0gZnJvbS5fbm9kZTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICB0aGlzLl9ub2RlID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSk7IC8vZXNwZWNpYWx5IGdvb2QgdG8gZG8gZm9yIG1lbW9yeSAoYWxzbyBzYXZlcyAyMCUgb24gY3B1KVxuICAgICAgICAgIHRoaXMuX25vZGUuYmFzZSA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25vZGUgPSBuZXdub2RlO1xuICAgICAgfVxuICAgICAgaWYgKGZyb20uX25vZGUgJiYgZnJvbS5fbm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgdmFyIGksIGMgPSB0aGlzLl9ub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgICAgY2YgPSBmcm9tLl9ub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgICAgbCA9IGMubGVuZ3RoLFxuICAgICAgICAgIGNpLCBjZmI7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjZmIgPSBjZltpXS5iYXNlO1xuICAgICAgICAgIGlmIChjZmIpIHtcbiAgICAgICAgICAgIGNbaV0uYmFzZSA9IG5ldyBjZmIuQ2xhc3MoZmFsc2UsIGZhbHNlLCBjW2ldKTtcbiAgICAgICAgICAgIC8vbWF5YmUgY2FsbCBjaGlsZHJlbiBuZXcgc3R1ZmYgd2l0aCBhIGN1c3RvbSBzZXR0aW5nIGFzIHdlbGw/XG4gICAgICAgICAgICBpZiAoY2ZiLl9uYW1lKSB7XG4gICAgICAgICAgICAgIGNbaV0uYmFzZS5fbmFtZSA9IGNmYi5fbmFtZTtcbiAgICAgICAgICAgICAgdGhpc1tjZmIuX25hbWVdID0gY1tpXS5iYXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY1tpXS5iYXNlLnNldHRpbmcoJ3BhcmVudCcsIFt0aGlzXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHdoYXQgaGFwcGVucyB3aGVuIHlvdSByZW1vdmUgYSBub2RlXG4gICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgKiBAcGFyYW0gIHsqfSAgW3BhcmFtXSBJZiBwYXJhbSBkb2Vzbid0IHJlbW92ZSBub2RlIGZyb20gcGFyZW50XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihwYXJhbSkge1xuICAgICAgX3JlbW92ZUNoaWxkcmVuLmNhbGwodGhpcyk7XG4gICAgICBpZih0aGlzLl9ub2RlKSB0aGlzLl9ub2RlLmJhc2UgPSBudWxsIC8vbGl0dGxlIHNsb3cgb3B0aW1pemUgbGF0ZXJcbiAgICAgIGlmICghcGFyYW0pIHtcbiAgICAgICAgdmFyIF9wID0gdGhpcy5fbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICBpZiAoX3ApIHtcbiAgICAgICAgICBfcC5yZW1vdmVDaGlsZCh0aGlzLl9ub2RlKTtcbiAgICAgICAgICBpZiAodGhpcy5fbmFtZSAmJiBfcC5iYXNlKSB7XG4gICAgICAgICAgICBfcC5iYXNlW3RoaXMuX25hbWVdID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBTZXQgY3NzIGNsYXNzIG9mIGEgZGl2XG4gICAqIFVzZSBhZGRDbGFzcyBvciByZW1vdmVDbGFzcyB0byBhZGQvcmVtb3ZlIGEgY2xhc3NcbiAgICogQGF0dHJpYnV0ZSBjc3NcbiAgICogQHBhcmFtICB7T2JqZWN0fSB2YWwgW2Rlc2NyaXB0aW9uXVxuICAgKiB3YXJuaW5nOiB0aGUgYWRkIG9wZXJhdG9yIGluIGNzcyBpcyBjdXJyZW50bHkgdXNlZCBieSAubmFtZSxcbiAgICogYW5kIHdpbGwgYmUgcmVwbGFjZWQgd2hlbiB5b3UgdHJ5IHRvIGJ1aWxkIGEgc3RyaW5nXG4gICAqIHVzaW5nIHt2YWw6IC4uLi4gYWRkOiAuLi4ufVxuICAgKi9cbiAge1xuICAgIC8vIF9fJGNzczogZnVuY3Rpb24odmFsKSB7XG4gICAgICAvLyB0aGlzLmNzc1xuICAgIC8vIH1cbiAgICBjc3M6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIF92YWwgPSB2YWwudmFsIHx8ICcnO1xuICAgICAgdmFsLl9za2lwID0gdHJ1ZTsgLy9fc2tpcCBpcyBhbiB1Z2x5IG5hbWVcbiAgICAgIGlmKHZhbC5hZGRDbGFzcyl7XG4gICAgICAgIGlmICghfl92YWwuaW5kZXhPZih2YWwuYWRkQ2xhc3MudmFsKSkge1xuICAgICAgICAgIHZhbC5fdmFsID0gKChfdmFsLmxlbmd0aCA+IDAgPyBfdmFsICsgJyAnIDogJycpICsgdmFsLmFkZENsYXNzLnZhbCk7XG4gICAgICAgICAgaWYodmFsLmFkZCkgdmFsLl92YWwgPSB2YWwuX3ZhbC5yZXBsYWNlKHZhbC5hZGQudmFsLCcnKVxuICAgICAgICAgIHZhbC5fbHZhbCA9IGZhbHNlO1xuICAgICAgICAgIHZhbC5fX2x2YWwgPSBmYWxzZTtcbiAgICAgICAgICB2YWwuX19fbHZhbCA9IGZhbHNlO1xuICAgICAgICAgIF92YWwgPSB2YWwudmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhbC5hZGRDbGFzcy5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYodmFsLnJlbW92ZUNsYXNzKXtcbiAgICAgICAgaWYgKF92YWwgJiYgdmFsLl92YWwpIHtcbiAgICAgICAgICB2YWwuX3ZhbCA9IHZhbC5fdmFsLnJlcGxhY2UobmV3IFJlZ0V4cCgnID8nICsgdmFsLnJlbW92ZUNsYXNzLnZhbCksICcnKTtcbiAgICAgICAgICB2YWwuX2x2YWwgPSBmYWxzZTtcbiAgICAgICAgICB2YWwuX19sdmFsID0gZmFsc2U7XG4gICAgICAgICAgdmFsLl9fX2x2YWwgPSBmYWxzZTtcbiAgICAgICAgICBfdmFsID0gdmFsLnZhbDtcbiAgICAgICAgfVxuICAgICAgICB2YWwucmVtb3ZlQ2xhc3MucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmKCBfdmFsICkge1xuICAgICAgICB0aGlzLm5vZGUuY2xhc3NOYW1lID0gX3ZhbC5yZXBsYWNlKCckJywnJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc05hbWUgPSAnJ1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIE1ha2VzIGl0IHBvc3NpYmxlIHRvIHJlZmVyZW5jZSBhIGNoaWxkIGJ5IG5hbWVcbiAgICogU2V0dGluZyBvbiBhIGNsYXNzIGRvZXMgbm90IHVwZGF0ZSBuYW1lcyBvZiBpbnN0YW5jZXNcbiAgICogRWxlbWVudFtOQU1FXVxuICAgKiBAYXR0cmlidXRlIG5hbWVcbiAgICovXG4gIHtcbiAgICBuYW1lOiAnbmFtZScsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMucGFyZW50O1xuICAgICAgaWYgKHRoaXMuX25hbWUpIHtcbiAgICAgICAgaWYgKF9wKSB7XG4gICAgICAgICAgX3BbdGhpcy5fbmFtZV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9uYW1lID0gdmFsO1xuICAgICAgaWYgKCF0aGlzLl9ub2RlIHx8IHZhbCAhPT0gdGhpcy5ub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgLy9uYW1lIGRvZXMgbm90IGluaGVyaXQsIGJld2FyZSFcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1dIQVRTIFRISVM/Jyx2YWwpO1xuICAgICAgICAvLyB0aGlzLmNzcyA9IHthZGRDbGFzczp2YWx9O1xuICAgICAgICAvLyB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgICAgIGlmKCF0aGlzLmNzcyB8fCB0aGlzLmNzcy5fdmFsIT09dmFsKXRoaXMuY3NzID0geyBhZGQ6ICcgJyArIHZhbCB9XG4gICAgICAgIC8vc3BlY2lhbCBuYW1lIGZpZWxkP1xuICAgICAgfVxuICAgICAgaWYgKF9wKSB7XG4gICAgICAgIF9wW3ZhbF0gPSB0aGlzO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgcGFyZW50IGJhc2UgZWxlbWVudFxuICAgKiBAYXR0cmlidXRlIHBhcmVudFxuICAgKi9cbiAge1xuICAgIG5hbWU6ICdwYXJlbnQnLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5fbm9kZSkge1xuICAgICAgICB2YXIgX3AgPSB0aGlzLl9ub2RlLnBhcmVudE5vZGUgfHwgdGhpcy5fcDtcbiAgICAgICAgcmV0dXJuIF9wID8gX3AuYmFzZSB8fCBfcC5fcCA6IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgY2hpbGROb2RlcyAvdyBiYXNlIGNsYXNzZXMgYXJyYXkgc2xvdywgY2FjaGUgaWYgcG9zc2libGVcbiAgICogQGF0dHJpYnV0ZSBjaGlsZHJlblxuICAgKi9cbiAge1xuICAgIG5hbWU6ICdjaGlsZHJlbicsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmKCF0aGlzLl9ub2RlKSByZXR1cm4gW11cbiAgICAgIHZhciBjID0gdGhpcy5fbm9kZS5jaGlsZE5vZGVzLFxuICAgICAgICBsID0gYy5sZW5ndGgsXG4gICAgICAgIF9jID0gbmV3IEFycmF5KGwpLFxuICAgICAgICBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICBfY1tpXSA9IGNbaV0uYmFzZSB8fCBjW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jO1xuICAgIH1cbiAgfSk7XG5cbnZhciByZWN1clJlbmRlciA9IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gIGlmICghdGhpcy5sYXN0aW5kZXgpIHRoaXMuc2V0dGluZygncmVuZGVyJywgW3BhcmVudF0pIC8vZXhlY3V0ZSByZW5kZXIgc2V0dGluZ3NcblxuICBpZiAodGhpcy5yZW5kZXJzKSB7XG5cbiAgICAvLyBjb25zb2xlLmVycm9yKCdSRU5ERVIgLS0tJywgdGhpcy5uYW1lLCB0aGlzLnJlbmRlcnMpXG5cbiAgICBmb3IgKHZhciBwXG4gICAgICAsIGMgPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1xuICAgICAgLCBjbFxuICAgICAgLCBhcnIgPSB0aGlzLnJlbmRlcnNcbiAgICAgICwgb2JqXG4gICAgICAsIGkgPSB0aGlzLmxhc3RpbmRleCB8fCAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgb2JqID0gYXJyW2ldXG5cbiAgICAgaWYob2JqKSB7XG4gICAgICAgIHAgPSB1dGlsLmNoZWNrQXJyYXkoYywgb2JqLCAnYmFzZScpXG4gICAgICAgIGlmIChwICE9PSBmYWxzZSkge1xuICAgICAgICAgIHJlY3VyUmVuZGVyLmNhbGwob2JqLCB0aGlzKVxuICAgICAgICB9IGVsc2UgaWYob2JqLl9mcm9tKSB7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQ0xBU1MhJyxvYmosIG9iai5uYW1lICYmIHRoaXNbb2JqLm5hbWVdICYmIHRoaXNbb2JqLm5hbWVdID09PSBjbClcblxuICAgICAgICAgIGNsID0gb2JqLkNsYXNzXG5cbiAgICAgICAgICBpZihvYmoubmFtZSAmJiB0aGlzW29iai5uYW1lXSAmJiB0aGlzW29iai5uYW1lXSA9PT0gY2wpIHtcbiAgICAgICAgICAgIHJlY3VyUmVuZGVyLmNhbGwodGhpc1tvYmoubmFtZV0sIHRoaXMpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgZm9yICh2YXIgaiBpbiBjKSB7XG4gICAgICAgICAgICAgaWYgKGNbal0uYmFzZSAmJiBjW2pdLmJhc2UgaW5zdGFuY2VvZiBjbCkge1xuICAgICAgICAgICAgICAgcmVjdXJSZW5kZXIuY2FsbChjW2pdLmJhc2UsIHRoaXMpXG4gICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhcnIuc3BsaWNlKGksMSlcbiAgICB9XG4gIH1cblxuICB0aGlzLmxhc3RpbmRleCA9IGxcbn0sXG5cbnNldFJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcCwgcHA7XG4gIGlmICh0aGlzLnBhcmVudCkge1xuICAgIHAgPSB0aGlzLnBhcmVudDtcbiAgICBpZiAocC5yZW5kZXJzKSB7XG4gICAgICBwLnJlbmRlcnMucHVzaCh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5yZW5kZXJzID0gW3RoaXNdO1xuICAgICAgcHAgPSBwLnBhcmVudDtcbiAgICAgIGlmIChwcCAmJiAhKHBwLl9zZXR0aW5ncyAmJiBwcC5fc2V0dGluZ3MucmVuZGVyICE9PSB0cnVlKSkge1xuICAgICAgICBzZXRSZW5kZXIuY2FsbChwKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sXG5cbnZhbFJlbmRlciA9IGZ1bmN0aW9uKHZhbCkge1xuICB2YXIgX3NldHRpbmdzID0gKHZhbC5fXyAmJiB2YWwuX18uX3NldHRpbmdzIHx8IHZhbC5fLl9zZXR0aW5ncylcbiAgaWYgKHZhbC5fLnJlbmRlcnMgfHwgdmFsLl9fICYmIHZhbC5fXy5yZW5kZXJzIHx8IF9zZXR0aW5ncy5yZW5kZXIgIT09IHRydWUpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVycykgdGhpcy5yZW5kZXJzID0gW11cbiAgICBpZiAoISh0aGlzLl9fICYmIHRoaXMuX18ucmVuZGVycykpIHRoaXMucmVuZGVycyA9IHV0aWwuY2xvbmUodGhpcy5yZW5kZXJzKVxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMucmVuZGVycz09PXRoaXMuX18ucmVuZGVycywgdGhpcy5fXy5yZW5kZXJzLCB0aGlzLl8ucmVuZGVycylcblxuICAgIC8vIGNvbnNvbGUubG9nKHV0aWwuY2hlY2tBcnJheSh0aGlzLnJlbmRlcnMsdmFsLl9mcm9tKSlcbiAgICAvLyBjb25zb2xlLmxvZygnWFhYWFhYJyx2YWwpXG4gICAgLy8gaWYodXRpbC5jaGVja0FycmF5KHRoaXMucmVuZGVycyx2YWwuX2Zyb20uX2Zyb20sJ19mcm9tLl9mcm9tJyk9PT1mYWxzZSYmdXRpbC5jaGVja0FycmF5KHRoaXMucmVuZGVycyx2YWwuX2Zyb20sJ19mcm9tJyk9PT1mYWxzZSkge1xuICAgICAgdGhpcy5yZW5kZXJzLnB1c2godmFsKVxuICAgIC8vIH1cbiAgICAvLyBjb25zb2xlLmxvZygncmVuZGVycyBwdXNoIC0tLSBjcmVhdGVzIGxlYWtzIScpXG4gIH1cbn1cblxuLy9kZWZpbmUgdmFudWl0IGJhc2UgKGtvcnRlciEpXG51dGlsLmRlZmluZShleHBvcnRzLFxuICAgJ2FwcGVuZCcsIGZ1bmN0aW9uKGFycikge1xuXG4gICAgLy8gYWxlcnQoJ0FQUEVORCcpXG4gICAgLy8gY29uc29sZS5sb2coJ0FQUEVORCcuaW52ZXJzZSxhcnIpXG5cbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzXG5cbiAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGg+MSkge1xuICAgICAgICBhcnIgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gICAgICB9IC8vZWxzZSBpZihhcnIgKVxuXG4gICAgICB2YXIgaW5zZXJ0YmVmb3JlXG4gICAgICBpZighYXJyLmxlbmd0aCAmJiAhKGFyciBpbnN0YW5jZW9mIGV4cG9ydHMpICYmIGFyci52YWwpIHtcbiAgICAgICAgaW5zZXJ0YmVmb3JlID0gYXJyLmJlZm9yZVxuICAgICAgICBhcnIgPSBhcnIudmFsXG4gICAgICB9XG4gICAgICB2YXIgQ2xhc3MgPSBhcnJbMF1cbiAgICAgICwgaSA9IDBcbiAgICAgICwgbCA9IGFyci5sZW5ndGhcbiAgICAgIGlmKCFhcnIubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuYWRkKGFyciwgaW5zZXJ0YmVmb3JlKVxuICAgICAgfSBlbHNlIGlmKHR5cGVvZiBDbGFzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3IodmFyIGk9MSwgbCA9IGFyci5sZW5ndGg7aTxsO2krKykge1xuICAgICAgICAgIHRoaXMuYWRkKG5ldyBDbGFzcyhhcnJbaV0pLCBpbnNlcnRiZWZvcmUpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcig7aTxsO2krKykge1xuICAgICAgICAgIHRoaXMuYWRkKGFycltpXSwgaW5zZXJ0YmVmb3JlKVxuICAgICAgICB9XG4gICAgICB9XG4gIH0sXG4gICdjaGVja1JlbmRlcicsIGZ1bmN0aW9uKHZhbCwgbm90UmVuZGVyZWQpIHtcbiAgICBpZiAodmFsKSB2YWxSZW5kZXIuY2FsbCh0aGlzLCB2YWwpXG4gICAgaWYgKCFub3RSZW5kZXJlZCkge1xuICAgICAgdmFyIF9yZW5kZXJzID0gKHRoaXMuX18gJiYgdGhpcy5fXy5yZW5kZXJzIHx8IHRoaXMuXy5yZW5kZXJzKVxuICAgICAgaWYgKCAoIChfcmVuZGVycyAgfHwgKCh0aGlzLl9fICYmIHRoaXMuX18uX3NldHRpbmdzKSAgfHwgdGhpcy5fLl9zZXR0aW5ncykucmVuZGVyICE9PSB0cnVlKVxuICAgICAgICAgICYmICghdGhpcy5sYXN0aW5kZXggfHwgKF9yZW5kZXJzICYmIHRoaXMubGFzdGluZGV4IDwgX3JlbmRlcnMubGVuZ3RoKSlcbiAgICAgICAgKSAmJiB0aGlzLnJlbmRlcmVkKSB7XG4gICAgICAgIHJlY3VyUmVuZGVyLmNhbGwodGhpcywgdGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmKHRoaXMucGFyZW50KSB2YWxSZW5kZXIuY2FsbCh0aGlzLnBhcmVudCwgdGhpcylcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdjaGVja1BhcmVudCcsIHV0aWwuY2hlY2tQYXJlbnRGYWN0b3J5KCdwYXJlbnQnKSxcbiAgJ2dldCcsZnVuY3Rpb24ocGF0aCwgc2VsZikgeyAvL2dldCBkb2VzIG5vdCBuZWVkIGFuIGFycmF5IGFzIHBhdGhcbiAgICByZXR1cm4gdXRpbC5nZXQodGhpcywgcGF0aCwgc2VsZik7XG4gIH0sXG4gICdmaW5kJywgZnVuY3Rpb24oZ2V0LCBtYXRjaCwgbGV2ZWwpIHtcbiAgICBpZihsZXZlbCA9PT0gdm9pZCAwKSBsZXZlbCA9IHRydWVcbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1xuICAgICAgLCBpID0gMFxuICAgICAgLCBmb3VuZFxuICAgICAgLCBjaGlsZFxuICAgICAgLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGhcbiAgICAgICwgcGFzc09uID0gbGV2ZWw9PT10cnVlID8gdHJ1ZSA6IGxldmVsLTFcbiAgICBmb3IoO2k8bGVuO2krKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXS5iYXNlXG4gICAgICBpZihjaGlsZCkge1xuICAgICAgICBpZihjaGlsZC5nZXQoZ2V0LCB0cnVlKT09bWF0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgICAgfSBlbHNlIGlmKGxldmVsKSB7XG4gICAgICAgICAgZm91bmQgPSBjaGlsZC5maW5kKGdldCwgbWF0Y2gsIHBhc3NPbilcbiAgICAgICAgICBpZihmb3VuZCkgcmV0dXJuIGZvdW5kXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdzZXRSZW5kZXInLCBmdW5jdGlvbihuYW1lLCB2YWwpIHtcbiAgICB0aGlzLnNldFNldHRpbmcoe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHJlbmRlcjogdmFsXG4gICAgfSk7XG4gICAgc2V0UmVuZGVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7IC8vbG9vayBmb3IgY3VycmVudCBjYWxsZXIgaW5zdGFuY2UgcGVyaGFwcz9cbiAgICAgIHNldFJlbmRlci5jYWxsKHRoaXMpXG4gICAgfSwgbmFtZSk7XG4gIH0sXG4gICdyZW5kZXJzJywgZmFsc2UsXG4gIC8qKlxuICAgKiBBZGQgZWxlbWVudCBhcyBjaGlsZFxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSAge09iamVjdH0gIHZhbCAgT2JqZWN0IHRvIGJlIGFkZGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgUmV0dXJucyB0aGUgVi5lbGVtZW50XG4gICAqL1xuICAnYWRkJywgZnVuY3Rpb24odmFsLCBpbnNlcnRiZWZvcmUpIHtcbiAgICBcbiAgICBpZihpbnNlcnRiZWZvcmUpIHtcbiAgICAgIGlmKHR5cGVvZiBpbnNlcnRiZWZvcmUgPT09ICdzdHJpbmcnKSBpbnNlcnRiZWZvcmUgPSB0aGlzW2luc2VydGJlZm9yZV1cbiAgICAgIGlmKGluc2VydGJlZm9yZSkge1xuICAgICAgICB0aGlzLm5vZGUuaW5zZXJ0QmVmb3JlKHZhbC5ub2RlLCBpbnNlcnRiZWZvcmUubm9kZSB8fCBpbnNlcnRiZWZvcmUpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdjYW5ub3QgZmluZCBpbnNlcnRiZWZvcmUnKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IodmFsKVxuXG4gICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodmFsLm5vZGUpXG4gICAgfVxuXG4gICAgdmFsLnNldHRpbmcoJ3BhcmVudCcsIFt0aGlzXSkgLy9leGVjdXRlIHBhcmVudCBzZXR0aW5nc1xuICAgIGlmICh2YWwubmFtZSkgdGhpc1t2YWwubmFtZV0gPSB2YWxcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy9uZWVkcyBjbGVhbmluZyBjb3N0cyAzJSBub3cuLi5cbiAgICB0aGlzLmNoZWNrUmVuZGVyKHZhbClcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuXG4gICAqIEBtZXRob2QgZW1wdHlcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gaW5zdGFuY2VzIFRydWUgd2lsbCByZW1vdmUgYWxsIGluc3RhbmNlcyBvZiBjaGlsZHJlbiByZW1vdmVkXG4gICAqL1xuICAnZW1wdHknLFxuICBmdW5jdGlvbihpbnN0YW5jZXMpIHtcbiAgICB2YXIgYyA9IHRoaXMubm9kZS5jaGlsZE5vZGVzXG4gICAgICAsIGlcbiAgICB0aGlzLm5vZGUuaW5uZXJIdG1sID0gJydcbiAgICBmb3IgKGkgPSBjLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBpZiAoY1tpXS5iYXNlKSBjW2ldLmJhc2UucmVtb3ZlKGluc3RhbmNlcylcbiAgICB9XG4gIH0pO1xuXG5leHBvcnRzLmJhc2UuYWRkU2V0dGluZygncGFyZW50JylcbmV4cG9ydHMuYmFzZS5hZGRTZXR0aW5nKCdyZW5kZXInKVxucmVxdWlyZSgnLi9zZXQnKSIsInZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi91dGlsJylcblxuZXhwb3J0cy5wcmVwYXJlID0gZnVuY3Rpb24oZWwpIHtcbiAgaWYoIWVsLmRpc3BsYXkpIGVsLmRpc3BsYXkgPSAnYmxvY2snXG59XG5cbmV4cG9ydHMubmV3RWxlbWVudCA9IGZ1bmN0aW9uKGRhdGEsIGVsZW1lbnQsIHQpIHtcbiAgdmFyIGMgPSBjb2xsZWN0aW9uLmNoaWxkcmVuKHQpXG4gIGZvcih2YXIgaSBpbiBjKSB7XG4gICAgaWYoY1tpXS5fZCAmJiBjW2ldLl9kPT09ZGF0YSkge1xuICAgICAgY1tpXS5kaXNwbGF5ID0gZWxlbWVudC5kaXNwbGF5LnZhbFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cbiBcbmV4cG9ydHMucmVtID0gZnVuY3Rpb24gKGVsLCB0LCBoYXNGaWx0ZXIsIG5vUmVzb2x2ZSkge1xuIGVsLmRpc3BsYXkgPSAnbm9uZSdcbiByZXR1cm4gdHJ1ZVxufVxuXG5leHBvcnRzLmZyYWdtZW50ID0gZnVuY3Rpb24oYSxiLGV4Y2x1ZGUsaSkge1xuICAvL3NpbmNlIGl0IG5ldmVyIHJlbW92ZXMgZXhjbHVkZXMgc2hvdWxkIG5ldmVyIGJlIGFwcGxpZWRcbiAgLy9leGNsdWRlIGlzIG5vcm1hbGx5IHVzZWQgdG8gbm90IGFkZCB0aGluZ3MgYWdhaW4gaWYgdGhleSBhbHJlYWR5IGV4aXN0XG4gIGlmKGV4Y2x1ZGUpIGV4Y2x1ZGVbaV09bnVsbFxufVxuIiwiXG52YXIgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4vdXRpbCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3V0aWwnKVxuXG4vKipcbiAqIGNvbGxlY3Rpb25cbiAqIGxpbmtzIGFycmF5cyBvciBvYmplY3QgdG8gZWxlbWVudHNcbiAqIHVzZSBmaWx0ZXIgaWYgeW91IHdhbnQgdG8gY29udmVydFxuICogQGF0dHJpYnV0ZVxuICovXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoXG4gIHJlcXVpcmUoJy4uL2RhdGEnKSxcbiAgZnVuY3Rpb24oYmFzZSl7XG5cbiAgICBiYXNlLmV4dGVuZCh7XG4gICAgICBuYW1lOidjb2xsZWN0aW9uJyxcbiAgICAgIC8vIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgdGhpcy51cGRhdGUoJ2NvbGxlY3Rpb24nKSBcbiAgICAgIC8vIH0sXG4gICAgICByZW1vdmU6ZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKHRoaXMuX2NvbEVsZW0pIHRoaXMuX2NvbEVsZW0ucmVtb3ZlKClcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgY2hhbmdlLCBhZGRlZCkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3h4eHghQCMhIUAjISMnLCB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLnRvU3RyaW5nKCkpXG5cbiAgICAgICAgdmFsLl9za2lwID0gdHJ1ZVxuXG4gICAgICAgIHZhciBoYXNGaWx0ZXIgPSBjb2xsZWN0aW9uLmZpbHRlcih2YWwsIHRoaXMpXG4gICAgICAgICAgLCBkYXRhID0gdGhpcy5maWx0ZXIgfHwgdmFsLnZhbFxuICAgICAgICAgICwgb3B0aW9ucyA9IHRoaXMuX2NvbE9wdGlvbnMgfHwgdmFsLm9wdGlvbnMgXG4gICAgICAgICAgICAgICYmICh0aGlzLl9jb2xPcHRpb25zID0gdmFsLm9wdGlvbnMuY29udmVydCgpKVxuICAgICAgICAgICwgb3JpZyA9ICB2YWwuZWxlbWVudFxuICAgICAgICAgICwgZWwgPSB0aGlzLl9jb2xFbGVtIFxuICAgICAgICAgICAgICB8fCAob3JpZyAmJiBvcmlnLl92YWwpICYmICh0aGlzLl9jb2xFbGVtID0gbmV3IChvcmlnLl92YWwuQ2xhc3MgfHwgb3JpZy5fdmFsKSgpKVxuICAgICAgICAgICwgZmlyc3RSdW4gPSAhdGhpcy5fY29sSW5pdFxuICAgICAgICAgICwgc2xTdGFtcFxuICAgICAgICAgICwgZWxWYWxcbiAgICAgICAgICAsIGNvbEVsZW0gPSB0aGlzLl9jb2xFbGVtXG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnISEhT1BUSU9OUyEnLCBvcHRpb25zKVxuXG4gICAgICAgIC8vZGlydHkgYmxvY2shIGNsZWFuIGl0IEZBU1RcblxuICAgICAgICAvLyB8fCAhdGhpcy5yZW5kZXJlZCBcblxuICAgICAgICBpZighKGRhdGEgJiYgZWwpKSByZXR1cm4gLy98fCF0aGlzLnJlbmRlcmVkXG4gICAgICAgIFxuICAgICAgICBzbFN0YW1wID0gb3JpZy5fc2xTdGFtcFxuICAgICAgICBlbFZhbCA9IG9yaWcuX3ZhbFxuXG4gICAgICAgIGlmKHNsU3RhbXApIHtcbiAgICAgICAgICBvcmlnLl9zbFN0YW1wID0gc3RhbXBcbiAgICAgICAgfSBlbHNlIGlmKGNvbEVsZW0gJiYgb3JpZy5fc2xTdGFtcCAhPT0gc3RhbXApIHtcbiAgICAgICAgICBpZighKGVsVmFsLkNsYXNzICYmIChjb2xFbGVtIGluc3RhbmNlb2YgZWxWYWwuQ2xhc3MpKSBcbiAgICAgICAgICAgICYmICEoIWVsVmFsLkNsYXNzICYmIChjb2xFbGVtIGluc3RhbmNlb2YgZWxWYWwpKSkge1xuICAgICAgICAgICAgZWwgPSB0aGlzLl9jb2xFbGVtID0gbmV3IChlbFZhbC5DbGFzcyB8fCBlbFZhbCkoKVxuICAgICAgICAgICAgb3JpZy5fc2xTdGFtcCA9IHN0YW1wXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvb2sgbGV1ayBmZiB1cGRhdGUnLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGNoYW5nZSwgYWRkZWQpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Bhc3MhJylcbiAgICAgICAgICBcbiAgICAgICAgaWYoZmlyc3RSdW4pIHtcblxuICAgICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5wcmVwYXJlICYmIG9wdGlvbnMucHJlcGFyZShlbClcblxuICAgICAgICAgIHRoaXMuX2NvbEluaXQgPSB0cnVlXG4gICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKGNvbGxlY3Rpb24uZnJhZ21lbnQoIGRhdGEsIGVsLCB0aGlzLCBmYWxzZSwgb3B0aW9uc1xuICAgICAgICAgICAgLCBoYXNGaWx0ZXIgKSlcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYoZnJvbSAmJiBmcm9tLl9wYXJlbnQgPT09IGRhdGEuZnJvbSkge1xuICAgICAgICAgICAgaWYocmVtb3ZlKSB7XG4gICAgICAgICAgICAgIHZhciByID0gdXRpbC5jaGVja0FycmF5KGNvbGxlY3Rpb24uY2hpbGRyZW4odGhpcyksZnJvbSwnX2QnLHRydWUpXG4gICAgICAgICAgICAgIGlmKHIpIHtcbiAgICAgICAgICAgICAgICBpZighKG9wdGlvbnMgJiYgb3B0aW9ucy5yZW0gJiYgb3B0aW9ucy5yZW0ociwgdGhpcywgaGFzRmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgIHIucmVtb3ZlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZih1dGlsLmNoZWNrQXJyYXkoY29sbGVjdGlvbi5jaGlsZHJlbih0aGlzKSxmcm9tLCdfZCcpPT09ZmFsc2UpIHtcblxuICAgICAgICAgICAgICBjb2xsZWN0aW9uLmVsZW1lbnQoIGZyb20sIGVsLCB0aGlzLCB0cnVlLCB0aGlzLm5vZGUsIG9wdGlvbnMsIGhhc0ZpbHRlciwgdHJ1ZSApXG4gICAgICAgICAgICB9IGVsc2UgaWYoaGFzRmlsdGVyICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5pbmRleENoYW5nZSkge1xuXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5pbmRleENoYW5nZShcbiAgICAgICAgICAgICAgICAgIHV0aWwuY2hlY2tBcnJheShjb2xsZWN0aW9uLmNoaWxkcmVuKHRoaXMpLGZyb20sJ19kJyx0cnVlKVxuICAgICAgICAgICAgICAgICAgLCB0aGlzLCBoYXNGaWx0ZXIgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzEyMlhYWFhYJywgZnJvbSwgaGFzRmlsdGVyLCBjb2xsZWN0aW9uLmZpbHRlcih2YWwsIHRoaXMpKSAvL3RyeSB0byBmaXggb3JkZXIgYnkgbmFtZSBiZXR0ZXJcblxuICAgICAgICAgICAgaWYoIWZyb20pIHtcblxuICAgICAgICAgICAgICBpZihyZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uLmNsZWFyKHRoaXMsIG9wdGlvbnMpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgYyA9IGNvbGxlY3Rpb24uY2hpbGRyZW4odGhpcylcbiAgICAgICAgICAgICAgICAgICwgZXhjbHVkZSA9IHt9XG4gICAgICAgICAgICAgICAgICAsIG5hbWVcbiAgICAgICAgICAgICAgICAgICwgZkZpZWxkXG4gICAgICAgICAgICAgICAgICAsIGtleXNcbiAgICAgICAgICAgICAgICAgICwgY2hpbGRcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdYWFhYWCcsaGFzRmlsdGVyKSAvL3RyeSB0byBmaXggb3JkZXIgYnkgbmFtZSBiZXR0ZXJcbiAgICAgICAgICAgICAgICBpZihoYXNGaWx0ZXI9PT10cnVlKSB7XG4gICAgICAgICAgICAgICAgICBrZXlzID0gZGF0YS5rZXlzXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yKHZhciBqIGluIGMpIHtcbiAgICAgICAgICAgICAgICAgIGNoaWxkID0gY1tqXVxuICAgICAgICAgICAgICAgICAgbmFtZSA9IGNbal0uX2QuX25hbWVcblxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coY1tqXSwgaGFzRmlsdGVyLCBrZXlzLCB1dGlsLmNoZWNrQXJyYXkoZGF0YSxjaGlsZC5fZCkgPT09IGZhbHNlKVxuXG4gICAgICAgICAgICAgICAgICBpZihoYXNGaWx0ZXIgJiYgIWtleXMgPyB1dGlsLmNoZWNrQXJyYXkoZGF0YSxjaGlsZC5fZCkgPT09IGZhbHNlIDogIWRhdGFbbmFtZV0gfHwgZGF0YVtuYW1lXSE9PWNoaWxkLl9kICkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDSEVDSyEtLS0nLGopXG5cbiAgICAgICAgICAgICAgICAgICAgaWYoIShvcHRpb25zICYmIG9wdGlvbnMucmVtICYmIG9wdGlvbnMucmVtKGNoaWxkLCB0aGlzLCBoYXNGaWx0ZXIsIGhhc0ZpbHRlcikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGQucmVtb3ZlKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzIGlzIG1vcmUgZWZmaWNpZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKGRhdGFbbmFtZV0hPT1jW2pdLl9kKSBjW2pdLmRhdGEgPSBkYXRhW25hbWVdIFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlW25hbWVdPXRydWVcbiAgICAgICAgICAgICAgICAgICAgaWYoaGFzRmlsdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYob3B0aW9ucyAmJiBvcHRpb25zLmluZGV4Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjaGlsZC5fZC5faW5kZXhDYWNoZVtoYXNGaWx0ZXJdWzBdIT09Y2hpbGQuaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmluZGV4Q2hhbmdlKGNoaWxkLCB0aGlzLCBoYXNGaWx0ZXIsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKGhhc0ZpbHRlcj09PXRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGohPXV0aWwuY2hlY2tBcnJheShrZXlzLG5hbWUsdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV4Y2x1ZGVbbmFtZV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIShvcHRpb25zICYmIG9wdGlvbnMucmVtICYmIG9wdGlvbnMucmVtKGNbal0sIHRoaXMsIGhhc0ZpbHRlciwgaGFzRmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChcbiAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uZnJhZ21lbnQoZGF0YSwgZWwsIHRoaXMsIGV4Y2x1ZGUsIG9wdGlvbnMsIGhhc0ZpbHRlcilcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG59KSIsInZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi4vJylcbiAgLCBEYXRhID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vZGF0YScpLmluamVjdChyZXF1aXJlKCcuLi8uLi8uLi8uLi9kYXRhL3NlbGVjdGlvbicpKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi91dGlsJylcblxudmFyIHIgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFN0cmluZyh+fihNYXRoLnJhbmRvbSgpKjkpKSsnJ1xufVxuXG5leHBvcnRzLmVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgZWxlbWVudCwgdCwgdXBkYXRlLCBub2RlLCBvcHRpb25zLCBoYXNGaWx0ZXIsIHJlc29sdmUpIHtcbiAgdmFyIGVsZW1cbiAgaWYob3B0aW9ucyAmJiBvcHRpb25zLm5ld0VsZW1lbnQpIHtcbiAgICBlbGVtID0gb3B0aW9ucy5uZXdFbGVtZW50LmFwcGx5KHRoaXMsYXJndW1lbnRzKVxuICAgIGlmKGVsZW09PT10cnVlKSByZXR1cm5cbiAgfVxuICBlbGVtID0gZWxlbSB8fCBuZXcgZWxlbWVudC5DbGFzcygpXG4gIFxuICBlbGVtLl9jb2wgPSB0cnVlXG5cbi8vICAgY29uc29sZS5sb2coICctLS0tPicsIGRhdGEgKVxuXG4gIGlmIChkYXRhICE9PSB2b2lkIDApIGVsZW0uX2RTZXQoZGF0YSlcbiAgaWYgKG5vZGUpIG5vZGUuYXBwZW5kQ2hpbGQoZWxlbS5ub2RlKVxuICBlbGVtLnNldHRpbmcoJ3BhcmVudCcsIFt0XSlcbiAgO29wdGlvbnMmJm9wdGlvbnMuZWxlbWVudCYmb3B0aW9ucy5lbGVtZW50KGVsZW0sIHQsIGhhc0ZpbHRlciwgcmVzb2x2ZSlcbiAgaWYgKHVwZGF0ZSAmJiBkYXRhICE9PSB2b2lkIDApIGVsZW0udXBkYXRlRGF0YSgpXG4gIHQuY2hlY2tSZW5kZXIoZWxlbSwgdHJ1ZSlcbiAgcmV0dXJuIGVsZW1cbn1cblxuZXhwb3J0cy5mcmFnbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBlbGVtZW50LCB0LCBleGNsdWRlLCBvcHRpb25zLCBoYXNGaWx0ZXIpIHtcbiAgdmFyIGZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KClcbiAgICAsIGl0ZW0gPSBmdW5jdGlvbihpKSB7XG4gICAgICAgIC8vaWYgeW91IHVzZSB0aGUgcGFzc2VkIGkgaXQgaXMgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIHNlbGVjdGlvbnNcbiAgICAgICAgaWYodGhpcy5fbmFtZSkgaSA9IHRoaXMuX25hbWVcbiAgICAgICAgaWYoIShvcHRpb25zJiZvcHRpb25zLmZyYWdtZW50JiZvcHRpb25zLmZyYWdtZW50KHQsdGhpcyxleGNsdWRlLGkpKVxuICAgICAgICAgICYmICghZXhjbHVkZSB8fCAhZXhjbHVkZVtpXSkgKSB7XG4gICAgICAgICAgdmFyIGVsZW0gPSBleHBvcnRzLmVsZW1lbnQoIHRoaXMgfHwgbnVsbCwgZWxlbWVudCwgdCwgZmFsc2UsIGZyYWcsIG9wdGlvbnNcbiAgICAgICAgICAgICAgLCBoYXNGaWx0ZXIpXG4gICAgICAgICAgaWYoZWxlbSkgZnJhZy5hcHBlbmRDaGlsZCggZWxlbS5ub2RlIClcbiAgICAgICAgICBlbGVtLnVwZGF0ZURhdGEoKVxuICAgICAgICB9XG4gICAgICB9XG4gIGZyYWcuX3AgPSB0XG5cbiAgaWYoZGF0YS5lYWNoKSB7XG4gICAgZGF0YS5lYWNoKGl0ZW0pXG4gIH0gZWxzZSB7XG4gICAgLy9ub3JtYWwgZGF0YVxuICAgIGZvcih2YXIgaSBpbiBkYXRhKSB7XG4gICAgICBpdGVtLmNhbGwoIGRhdGFbaV0gLGkgKVxuICAgIH1cbiAgfVxuXG4gIC8vIGVsZW1lbnQudXBkYXRlRGF0YSh0cnVlKVxuICByZXR1cm4gZnJhZ1xufVxuXG5leHBvcnRzLmNoaWxkcmVuID0gZnVuY3Rpb24gKHQsIG9wdGlvbnMpIHtcbiAgaWYoIXQpIHJldHVyblxuICB2YXIgY2ggPSBbXVxuICBmb3IodmFyIGkgaW4gdC5ub2RlLmNoaWxkTm9kZXMpIHtcbiAgICB2YXIgY2hpbGQgPSB0Lm5vZGUuY2hpbGROb2Rlc1tpXS5iYXNlXG4gICAgaWYoY2hpbGQgJiYgY2hpbGQuX2NvbCkge1xuICAgICAgY2gucHVzaChjaGlsZClcbiAgICB9XG4gIH1cbiAgO29wdGlvbnMmJm9wdGlvbnMuY2hpbGRyZW4mJm9wdGlvbnMuY2hpbGRyZW4oY2gpXG4gIHJldHVybiBjaFxufVxuXG5leHBvcnRzLmNsZWFyID0gZnVuY3Rpb24gKHQsIG9wdGlvbnMpIHtcbiAgdC5jb2xJbml0ID0gbnVsbFxuICB2YXIgYyA9IGV4cG9ydHMuY2hpbGRyZW4odClcbiAgZm9yKHZhciBpIGluIGMpIHsgY1tpXS5yZW1vdmUoKSB9XG4gIDtvcHRpb25zJiZvcHRpb25zLmNsZWFyJiZvcHRpb25zLmNsZWFyKHQpXG59XG5cbmV4cG9ydHMuZmlsdGVyID0gZnVuY3Rpb24gKHZhbCx0KSB7XG5cblxuICB2YXIgZGF0YSA9IHZhbC52YWxcblxuXG4gIC8vIGNvbnNvbGUubG9nKCdETyBJIEhBVkUgRlVMVEVSIT4/JyxkYXRhLCAgdmFsLCB0KVxuXG5cbiAgaWYodmFsLmZpbHRlciAmJiB2YWwuZmlsdGVyLnZhbD09PXRydWUpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnc29ydCBieSBuYW1lJykgbW9ldCBiZXRlclxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZ290IGl0IURBVEF4IScpXG5cbiAgICByZXR1cm4gdHJ1ZVxuICAgIC8vZGlmZmVyZW50IHZpYmVzXG4gIH1cblxuICBpZiAoZGF0YSAmJiB2YWwuZmlsdGVyICYmICF0LmZpbHRlcikge1xuXG4gICAgLy8gY29uc29sZS5sb2coJ01BS0UgTkVXIFNUWVVGRkYnKVxuXG4gICAgdmFyIGEgPSB2YWwuZmlsdGVyLnJhd1xuICAgIC8vZGl0IGlzIGthcG90XG4gICAgZGF0YSA9IHQuZmlsdGVyID0gbmV3IERhdGEoZGF0YSwgYSlcblxuICAgIC8vIGNvbnNvbGUubG9nKCdGSUxURVJTU1NTIScsIGEsIHQpXG4gICAgLy8gZGVidWdnZXJcblxuICAgIGEuX2NvbCA9IHRydWVcbiAgICBcbiAgICBkYXRhLmFkZExpc3RlbmVyKGZ1bmN0aW9uICh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUpIHtcbiAgICAgIHQuY29sbGVjdGlvbi5fdXBkYXRlKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSlcbiAgICB9KVxuICAgIFxuICAgIHQuc2V0U2V0dGluZyh7XG4gICAgICAvLyBuYW1lOiAnY29sbGVjaXRvbmZpbHRlcicsXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdC5maWx0ZXIucmVtb3ZlKClcbiAgICAgICAgdC5maWx0ZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIGNvbnNvbGUubG9nKCdEQVRBeCEnKVxuICAgIHJldHVybiBkYXRhLl91aWRcbiAgICAvLyByZXR1cm4gdC5maWx0ZXIuX3VpZC8vZGF0YSBpcyBmaWx0ZXJcbiAgfSBlbHNlIGlmKGRhdGEgJiYgZGF0YS5fZmlsdGVyKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdEeHh4QVRBeCEnKVxuXG4gICAgcmV0dXJuIGRhdGEuX3VpZFxuICB9IFxuICBlbHNlIGlmKHQuZmlsdGVyKSB7XG5cbiAgICByZXR1cm4gdC5maWx0ZXIuX3VpZFxuICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygnTk8gREFUQVghIEZJTFRFUicsIHQpXG5cbn1cblxuLy8gZXhwb3J0cy5pbmRleENoYW5nZSA9IGZ1bmN0aW9uKGVsLCB0LCBoYXNGaWx0ZXIsIG5vUmVzb2x2ZSkge1xuLy8gdmFyIG9sZEluZGV4ID0gZWwuX2QuX2luZGV4Q2FjaGVbaGFzRmlsdGVyXVsxXVxuLy8gICAgICwgbmV3SW5kZXggPSBlbC5fZC5faW5kZXhDYWNoZVtoYXNGaWx0ZXJdWzBdXG4vLyAgICAgLCBjaCA9ICFub1Jlc29sdmUgJiYgY29sbGVjdGlvbi5jaGlsZHJlbih0LGV4cG9ydHMpXG4vLyAgICAgLCBsXG5cblxuLy8gICBleHBvcnRzLnh5KGVsKVxuXG4vLyAgIGlmKG5vUmVzb2x2ZSkgcmV0dXJuXG5cbi8vICAgbCA9IGNoLmxlbmd0aFxuICBcbiAgXG4vLyAgIHZhciBjbG9uZSA9IGVsLm5vZGUuY2xvbmVOb2RlKHRydWUpXG4vLyAgIHQubm9kZS5yZW1vdmVDaGlsZChlbClcbi8vICAgZWwuX25vZGUgPSBjbG9uZVxuXG5cbiAgIFxuLy8gICAvLyB0LmggPSB0Lm5vZGUuc2Nyb2xsSGVpZ2h0XG4vLyB9IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGRhdGEgPSByZXF1aXJlKCcuLi8uLi8uLi9kYXRhL2Jhc2UnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcbiAgLCBmbGFncyA9IHJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlL2ZsYWdzJylcblxuLyoqXG4gICogZXh0ZW5kcyB1cGRhdGVEYXRhIHRvIHRha2UgY2hpbGROb2RlcyBpbnRvIGFjY291bnRcbiAgKiBtYXkgbmVlZCB0byBhZGQgZXh0cmEgYXJndW1lbnQgZm9yIGdvIGRlZXBcbiAgKiBAbWV0aG9kXG4qL1xuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChbIGRhdGEsIHtcbiAgdXBkYXRlRGF0YTogZnVuY3Rpb24gKCBpbnN0YW5jZXMsIGRhdGEsIGZtb2RlbCApIHtcblxuICAgIC8vIGlmKCBpbnN0YW5jZXMgKSBjb25zb2xlLmVycm9yKCc/Pz8/LS0tLS0tLS0tLS0+Pj4+PicpXG5cbiAgICBpZiAodGhpcy5fZCkge1xuICAgICAgdGhpcy5fc3Vic2NyaWJlZCA9IGZhbHNlXG4gICAgICBkYXRhID0gdGhpcy5fZFxuICAgIH1cblxuICAgIHZhciBmZm1vZGVsID0gZmFsc2VcbiAgICB2YXIgcGFyc2VkID0gZmFsc2VcbiAgICBpZiAoIWZtb2RlbCAmJiAhdGhpcy5tb2RlbCAmJiAhdGhpcy5fZm1vZGVsKSBmZm1vZGVsID0gdHJ1ZVxuICAgIC8vZm1vZGVsIGlzIGZpcnN0IG1vZGVsXG4gICAgZm9yICh2YXIgY2hpbGRyZW4gPSB0aGlzLm5vZGUuY2hpbGROb2Rlc1xuICAgICAgLCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMVxuICAgICAgLCBiYXNlOyBpID49IDA7IGktLSkge1xuXG4gICAgICBiYXNlID0gY2hpbGRyZW5baV0uYmFzZVxuICAgICAgXG4gICAgICAvLyBpZihiYXNlICYmIGJhc2UubW9kZWwgJiYgYmFzZS5tb2RlbC5maWVsZCAmJiBiYXNlLm1vZGVsUGFyc2VkICE9PSBiYXNlLm1vZGVsLmZpZWxkLnZhbCAmJiBiYXNlLmluc3RhbmNlcyAmJiBpbnN0YW5jZXMpIHtcbiAgICAgIC8vICAgLy8gY29uc29sZS5lcnJvcignMScsIGJhc2UgJiYgYmFzZS5uYW1lLCBiYXNlLmluc3RhbmNlcylcbiAgICAgIC8vICAgICAgIGlmKCFkYXRhICYmIGluc3RhbmNlcykge1xuICAgICAgLy8gICAgICAgICBpZighZGF0YSkge1xuICAgICAgLy8gICAgICAgICAgIGRhdGEgPSBiYXNlLmNoZWNrUGFyZW50KCdfZCcsdHJ1ZSkgfHwgdGhpcy5jaGVja1BhcmVudCgnX2QnLHRydWUpXG4gICAgICAvLyAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2hleSBoZXkgaGV5JywgZGF0YSwgdGhpcy5fZCwgYmFzZS5fZCwgYmFzZSlcbiAgICAgIC8vICAgICAgICAgfVxuICAgICAgLy8gICAgICAgICBjb25zb2xlLmVycm9yKCdsZXp6Z28gaW5zdGFuY2VzJywgZGF0YSlcbiAgICAgIC8vICAgICAgICAgLy8gYmFzZS5fZCA9IGRhdGEgPSBkYXRhLmdldCh0aGlzLm1vZGVsLmZpZWxkLnZhbCkgLy91dGlsLnBhdGgoZGF0YSx0aGlzLm1vZGVsLmZpZWxkLnZhbC5zcGxpdCgnLicpKVxuICAgICAgLy8gICAgICAgICBmb3IodmFyIGkgaW4gYmFzZS5pbnN0YW5jZXMpIHtcbiAgICAgIC8vICAgICAgICAgICBpZighYmFzZS5pbnN0YW5jZXNbaV0ubW9kZWwucGFyc2VkKSB7XG4gICAgICAvLyAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCc/JyxiYXNlLmluc3RhbmNlc1tpXS5tb2RlbC5wYXJzZWQpXG4gICAgICAvLyAgICAgICAgICAgICBiYXNlLmluc3RhbmNlc1tpXS51cGRhdGVEYXRhKGZhbHNlLCBkYXRhKVxuICAgICAgLy8gICAgICAgICAgIH1cbiAgICAgIC8vICAgICAgICAgfVxuICAgICAgLy8gICAgICAgICAvLyBiYXNlLm1vZGVsUGFyc2VkID0gXG4gICAgICAvLyAgICAgICAgIC8vIGJhc2UubW9kZWwgPSB7fVxuICAgICAgLy8gICAgICAgICAvLyBiYXNlLm1vZGVsLnBhcnNlZCA9IGJhc2UubW9kZWwuZmllbGQudmFsIFxuICAgICAgLy8gICAgICAgICAvLyByZXR1cm5cbiAgICAgIC8vICAgICAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgLy8gaWYoYmFzZSAmJiBiYXNlLm1vZGVsICYmIGJhc2UubW9kZWwuZmllbGQgJiYgIWJhc2UuX2QpIHtcbiAgICAgICAgLy8gYmFzZS5fZFNldChkYXRhLCB0cnVlKVxuICAgICAgLy8gfVxuXG4gICAgICBpZiAoYmFzZVxuICAgICAgJiYgKCEoYmFzZS5tb2RlbCAmJiBiYXNlLm1vZGVsLmluaGVyaXQgJiYgYmFzZS5tb2RlbC5pbmhlcml0LnZhbD09PWZhbHNlKSlcbiAgICAgICYmIChiYXNlLl9kID09PSB2b2lkIDAgfHwgYmFzZS5fZGZyb20gfHwgKGJhc2UubW9kZWwgJiYgYmFzZS5tb2RlbC5maWVsZCkgKSkge1xuICAgICAgICB2YXIgdGRhdGEgPSBkYXRhXG5cbiAgICAgICAgaWYgKGJhc2UubW9kZWwgJiYgKGRhdGEgfHwgYmFzZS5tb2RlbCAmJiBiYXNlLm1vZGVsLmZpZWxkKSkge1xuICAgICAgICAgIGlmIChmZm1vZGVsKSBiYXNlLl9mbW9kZWwgPSB0cnVlXG5cbiAgICAgICAgICAvL2hpZXIgb29rIGZmIG1vZGVsIHBhcnNlbiFcbiAgICAgICAgICBpZihiYXNlLm1vZGVsICYmIGJhc2UubW9kZWwuZmllbGQpIHtcbiAgICAgICAgICAgIHRkYXRhID0gZGF0YS5nZXQoYmFzZS5tb2RlbC5maWVsZC52YWwpXG4gICAgICAgICAgICBiYXNlLm1vZGVsUGFyc2VkID0gYmFzZS5tb2RlbC5maWVsZC52YWxcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IodGRhdGEpXG4gICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcih0ZGF0YS5fY2FjaGVkUGF0aClcblxuICAgICAgICAgIGJhc2UuX2RTZXQodGRhdGEsIHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICBiYXNlLnVwZGF0ZURhdGEoZmFsc2UsIHRkYXRhLCBiYXNlLl9mbW9kZWwgfHwgZm1vZGVsKVxuICAgICAgfVxuICAgIH1cbiAgfVxufV0pIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG4gIC8qXG4gICAgaGVyZSBzb21lIGJhc2ljIGh0bWwgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gVi5FbGVtZW50Lk5lc3NlY2FyeVxuICAgIGZvciB2YWx1ZXMgdGhhdCB5b3Ugd2FudCB0byBiZSBhYmxlIHRvIGJpbmQgdG8gVi5PYmplY3RzXG4gICAgVXNlcyBiYXNlLmV4dGVuZCAtLSBzZWUgY29yZS5iYXNlIGZvciBtb3JlIGluZm9ybWF0aW9uXG4gICovXG5cbnZhciB1YSA9IHJlcXVpcmUoJy4uLy4uL3VhJylcbnZhciBjc3MgPSByZXF1aXJlKCcuLi8uLi9jc3MnKVxudmFyIFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUnKVxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcbnZhciBoYXNoID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9oYXNoJylcbnZhciByYWYgPSByZXF1aXJlKCcuLi8uLi9hbmltYXRpb24vcmFmJylcbnZhciBfbG9hZCA9IHJlcXVpcmUoJy4uLycpLmltYWdlcyA9IHt9XG52YXIgX3RyYW5zZm9ybSA9IHVhLnByZWZpeCArICdUcmFuc2Zvcm0nXG52YXIgX2Nzc1RyYW5zZm9ybSA9IHVhLnByZWZpeCArICctdHJhbnNmb3JtJ1xudmFyIHBvc3Rwb25lID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxudmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5LnN0eWxlXG4gICAgLy90aGluayBhYm91dCBkb2MgcmVhZHkgZXZlbnQgb3IgZmFsbGJhY2sgaWYgbm8gYm9keVxudmFyIF90cmFuc2xhdGUgPSBib2R5LnBlcnNwZWN0aXZlUHJvcGVydHkgIT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgIHx8IGJvZHkuV2Via2l0UGVyc3BlY3RpdmUgIT0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgID8gWyd0cmFuc2xhdGUzZCgnLCAnLDBweCknXVxuICAgICAgICAgICAgICAgICAgICA6IFsndHJhbnNsYXRlKCcsICcpJ11cbnZhciBfY29vcmRpbmF0ZSA9IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB2YXIgbWFyZ2luID0gJ21hcmdpbicgKyAoc3R5bGVbMF0udG9VcHBlckNhc2UoKSArIHN0eWxlLnNsaWNlKDEpKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYodmFsLmNsZWFuKSB7XG4gICAgICAgICAgX2NsZWFuQ29vcmRpbmF0ZS5jYWxsKHRoaXMsc3R5bGUsbWFyZ2luKVxuICAgICAgICAgIHZhbC5jbGVhbiA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsLnRyYW5zbGF0ZSkge1xuICAgICAgICAgIHRoaXMudHJhbnNsYXRlKHZhbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm5vZGUuc3R5bGVbdGhpcy5yZWxhdGl2ZSA/IG1hcmdpbiA6IHN0eWxlXSA9IHZhbC52YWwgKyAncHgnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG52YXIgX2NsZWFyVHJhbnNmb3JtID0gbmV3IFJlZ0V4cChfY3NzVHJhbnNmb3JtKycoLio/KTsnKVxudmFyIF9jbGVhciA9XG4gICAgeyB4OiAvKG1hcmdpbi1sZWZ0KC4qPyk7KXwobGVmdCguKj8pOykvZ1xuICAgICwgeTogLyhtYXJnaW4tdG9wKC4qPyk7KXwodG9wKC4qPyk7KS9nXG4gICAgfVxudmFyIF9jbGVhbkNvb3JkaW5hdGUgPSBmdW5jdGlvbiggY2hlY2sgKSB7XG4gICAgICB2YXIgdCA9IHRoaXMuX3RcbiAgICAgICwga2VlcCA9IGZhbHNlXG4gICAgICAsIHZhbCA9IHRoaXNbY2hlY2tdXG4gICAgICAsIGNzc1RleHQgPSB0aGlzLm5vZGUuc3R5bGUuY3NzVGV4dC5yZXBsYWNlKCBfY2xlYXJbY2hlY2tdLCAnJyApXG5cbiAgICBpZiggdmFsICYmIHZhbC50cmFuc2xhdGUgJiYgdmFsLnRyYW5zbGF0ZS52YWw9PT1mYWxzZSkgdmFsLnRyYW5zbGF0ZSA9IG51bGxcblxuICAgIGlmKHRoaXMubm9kZS5zdHlsZVtfdHJhbnNmb3JtXSAmJiAhdmFsLnRyYW5zbGF0ZSkge1xuICAgICAgaWYodCkge1xuICAgICAgICBpZighdGhpc1tjaGVja10udHJhbnNsYXRlKSB7XG4gICAgICAgICAgZm9yKHZhciBpID0gMiA7IGkgPCA2IDsgaSsrKSB7XG4gICAgICAgICAgICBpZih0W2ldKWtlZXA9dHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZWVwPXRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoIWtlZXApIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoX2NsZWFyVHJhbnNmb3JtLCcnKVxuICAgIH1cbiAgICB0aGlzLm5vZGUuc3R5bGUuY3NzVGV4dCA9IGNzc1RleHRcbiAgfVxuXG52YXIgc2V0VGltZXJzLCByZW1vdmVUaW1lcnMsIF9zZXRUaW1lb3V0XG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZnVuY3Rpb24oYmFzZSkge1xuICB1dGlsLmRlZmluZShiYXNlLkNsYXNzLFxuICAgICdjbGVhbkNvb3JkaW5hdGVzJywgZnVuY3Rpb24oY29vcmQpIHtcbiAgICAgICBpZih0aGlzLl9ub2RlKSB7XG4gICAgICAgIGlmKCFjb29yZCkge1xuICAgICAgICAgIF9jbGVhbkNvb3JkaW5hdGUuY2FsbCh0aGlzLCd4JylcbiAgICAgICAgICBfY2xlYW5Db29yZGluYXRlLmNhbGwodGhpcywneScpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2NsZWFuQ29vcmRpbmF0ZS5jYWxsKHRoaXMsY29vcmQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICd0cmFuc2xhdGUnLCBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgX3hcbiAgICAgICwgX3lcbiAgICAgICwgX3ZhbCA9ICB2YWwudmFsXG4gICAgICAsIF9zY2FsZVxuICAgICAgLCBfcm90YXRlXG4gICAgICAsIF9yb3RhdGVZXG4gICAgICAsIF9yb3RhdGVYXG4gICAgICAsIF9zdHIgPSAnJ1xuICAgICAgLCBfbmFtZSA9IHZhbCAmJiB2YWwuX3Byb3AubmFtZVxuICAgICAgLCBfdCA9IHRoaXMuX3QgPSB0aGlzLl90IHx8IFtdXG4gICAgICAsIG5vcGUgPSBmYWxzZVxuXG4gICAgLy9jaXJ0aWNhbCBwZXJmb3JtYW5jZSBwb2ludCBoZW5jZSB1c2Ugb2YgfCAwXG4gICAgaWYgKF9uYW1lID09PSAneCcpIHtcbiAgICAgIF94ID0gX3ZhbCB8IDBcbiAgICAgIGlmIChfeCA9PT0gX3RbMF0pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3knKSB7XG4gICAgICBfeSA9IF92YWwgfCAwXG4gICAgICBpZiAoX3kgPT09IF90WzFdKSBub3BlID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoX25hbWUgPT09ICdyb3RhdGUnKSB7XG4gICAgICBfcm90YXRlID0gX3ZhbFxuICAgICAgaWYgKF9yb3RhdGUgPT09IF90WzJdKSBub3BlID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoX25hbWUgPT09ICdzY2FsZScpIHtcbiAgICAgIF9zY2FsZSA9IF92YWxcbiAgICAgIGlmIChfc2NhbGUgPT09IF90WzNdKSBub3BlID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoX25hbWUgPT09ICdyb3RhdGVZJykge1xuICAgICAgX3JvdGF0ZVkgPSBfdmFsXG4gICAgICBpZiAoX3JvdGF0ZVkgPT09IF90WzRdKSBub3BlID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoX25hbWUgPT09ICdyb3RhdGVYJykge1xuICAgICAgX3JvdGF0ZVggPSBfdmFsXG4gICAgICBpZiAoX3JvdGF0ZVggPT09IF90WzRdKSBub3BlID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICghbm9wZSkge1xuICAgICAgX3RbMF0gPSAgX3ggfHwgKHRoaXMueC50cmFuc2xhdGUgJiYgdGhpcy54LnZhbCB8IDApIHx8IDBcbiAgICAgIF90WzFdID0gIF95IHx8ICh0aGlzLnkudHJhbnNsYXRlICYmIHRoaXMueS52YWwgfCAwKSB8fCAwXG4gICAgICBfdFsyXSA9IF9yb3RhdGUgfHwgdGhpcy5yb3RhdGUudmFsXG4gICAgICBfdFszXSA9IF9zY2FsZSB8fCB0aGlzLnNjYWxlLnZhbFxuICAgICAgX3RbNF0gPSBfcm90YXRlWSB8fCB0aGlzLnJvdGF0ZVkudmFsXG4gICAgICBfdFs1XSA9IF9yb3RhdGVYIHx8IHRoaXMucm90YXRlWC52YWxcbiAgICAgIGlmIChfdFswXSB8fCBfdFsxXSkge1xuICAgICAgICBfc3RyID0gX3N0clxuICAgICAgICAgIC5jb25jYXQoXG4gICAgICAgICAgICBfdHJhbnNsYXRlWzBdXG4gICAgICAgICAgKyBfdFswXSArICdweCwnXG4gICAgICAgICAgKyBfdFsxXSArICdweCdcbiAgICAgICAgICArIF90cmFuc2xhdGVbMV1cbiAgICAgICAgICApXG4gICAgICB9XG4gICAgICBpZiAoX3RbMl0pIHsgX3N0ciA9IF9zdHIuY29uY2F0KCcgcm90YXRlKCcgKyBfdFsyXSArICdkZWcpJykgfVxuICAgICAgaWYgKF90WzNdKSB7IF9zdHIgPSBfc3RyLmNvbmNhdCgnIHNjYWxlKCcgKyBfdFszXSArICcpJykgfVxuICAgICAgaWYgKF90WzRdKSB7IF9zdHIgPSBfc3RyLmNvbmNhdCgnIHJvdGF0ZVkoJyArIF90WzRdICsgJ2RlZyknKSB9XG4gICAgICBpZiAoX3RbNV0pIHsgX3N0ciA9IF9zdHIuY29uY2F0KCcgcm90YXRlWCgnICsgX3RbNV0gKyAnZGVnKScpIH1cbiAgICAgIHRoaXMubm9kZS5zdHlsZVtfdHJhbnNmb3JtXSA9IF9zdHJcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfSwgJ3VwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBfYXJncyA9IHV0aWwuYXJnKGFyZ3VtZW50cyksIGwgPSBfYXJncy5sZW5ndGgsIHA7IGkgPCBsOyBpKysgKSB7XG4gICAgICBpZiAoX2FyZ3NbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB0aGlzLnVwZGF0ZS5hcHBseSh0aGlzLCBfYXJnc1tpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwID0gdXRpbC5nZXQodGhpcywgX2FyZ3NbaV0pO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgIHAudXBkYXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICB2YXIgZG9uZSA9IHBvc3Rwb25lKGZ1bmN0aW9uKHZhbCxzZWxmLHNkaXIpe1xuICAgIGlmKHNlbGYpe1xuICAgICAgaWYodmFsLl9saXN0ZW5lcnMgIT09IHZvaWQgMCkgdmFsLnZhbCA9IHNlbGYubm9kZVtzZGlyXVxuICAgICAgZWxzZSBzZWxmW3NkaXJdLl9fbHZhbCA9IHZvaWQgMFxuICAgIH1cbiAgfSwyMClcblxuICBmdW5jdGlvbiBjcmVhdGVTY3JvbGwoZGlyKXtcbiAgICB2YXIgcyA9ICdzY3JvbGwnXG4gICAgICAsIHNkaXIgPSBzICsgZGlyIC8vc2Nyb2xsTGVmdCBvciBzY3JvbGxUb3BcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOnNkaXIsXG4gICAgICBzZXQ6ZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciB2ID0gdmFsLnZhbFxuICAgICAgICAgICwgc2VsZiA9IHRoaXNcbiAgICAgICAgaWYodiAhPT0gdm9pZCAwKSBzZWxmLm5vZGVbc2Rpcl0gPSB2XG4gICAgICAgIGlmKCFzZWxmLl9fc1Qpe1xuICAgICAgICAgIHNlbGYuX19zVCA9IHRydWVcbiAgICAgICAgICBzZWxmLmFkZEV2ZW50KHMsZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGRvbmUodmFsLHNlbGYsc2RpcilcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgIH0sXG4gICAgICBnZXQ6ZnVuY3Rpb24odmFsKXtcbiAgICAgICAgaWYodmFsLl9fbHZhbCA9PT0gdm9pZCAwKSB2YWwudmFsID0gdGhpcy5ub2RlW3NkaXJdXG4gICAgICAgIHJldHVybiB2YWxcbiAgICAgIH0sXG4gICAgICByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICAgICwgdmFsID0gc2VsZltzZGlyXS5fX2x2YWxcbiAgICAgICAgaWYodmFsKXtcbiAgICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYubm9kZVtzZGlyXSA9IHZhbFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIGJhc2UuZXh0ZW5kKHtcbiAgICBuYW1lOiAncmVsYXRpdmUnLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcyA9IHRoaXMucG9zaXRpb24gIT09IGZhbHNlID8gdGhpcy5wb3NpdGlvbi52YWwgOiAodGhpcy5wb3NpdGlvbiA9IHtcbiAgICAgICAgY3NzOiB0cnVlLFxuICAgICAgICB2YWw6IGNzcyh0aGlzLmNzcy52YWwsICdwb3NpdGlvbicpXG4gICAgICB9KVxuICAgICAgcmV0dXJuIHMgIT09ICdhYnNvbHV0ZSdcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiBmYWxzZSxcbiAgICBuYW1lOiAncmVuZGVyZWQnLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmV0ID0gdGhpcy5fcmVuZGVyZWQgfHwgKHRoaXMubm9kZSA9PT0gZG9jdW1lbnQuYm9keSksXG4gICAgICAgIHBhcmVudDtcbiAgICAgIGlmICghcmV0KSB7XG4gICAgICAgIHBhcmVudCA9IHRoaXMubm9kZS5wYXJlbnROb2RlO1xuICAgICAgICB3aGlsZSAoIXJldCAmJiBwYXJlbnQpIHtcbiAgICAgICAgICBpZiAocGFyZW50LmJhc2UgJiYgcGFyZW50Ll9yZW5kZXJlZCkge1xuICAgICAgICAgICAgcmV0ID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhcmVudCA9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgdGhpcy5fcmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSxcbiAgY3JlYXRlU2Nyb2xsKCdMZWZ0JyksXG4gIGNyZWF0ZVNjcm9sbCgnVG9wJyksXG4gIHtcbiAgICBwb3NpdGlvbjogZnVuY3Rpb24odmFsKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnPz8/Pz8nLHZhbC5jc3MudmFsKVxuICAgICAgLy8gaWYgKCF2YWwuY3NzKSB7IC8vY2hlY2sgd2hlbiBpZ25vcmluZyB0aGlzIGJlY29tZXMgYSBwcm9ibGVtXG4gICAgICAgIHRoaXMubm9kZS5zdHlsZS5wb3NpdGlvbiA9IHZhbC52YWw7XG4gICAgICAvLyB9XG4gICAgfSxcbiAgICAvLyBzY3JvbGxUb3A6ZnVuY3Rpb24odmFsKSB7XG4gICAgLy8gICBjb25zb2xlLmVycm9yKHZhbC52YWwpXG4gICAgLy8gICB0aGlzLm5vZGUuc2Nyb2xsVG9wID0gdmFsLnZhbFxuICAgIC8vIH0sXG4gICAgcm90YXRlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHZhbCk7XG4gICAgfSxcbiAgICByb3RhdGVZOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHZhbCk7XG4gICAgfSxcbiAgICByb3RhdGVYOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHZhbCk7XG4gICAgfSxcbiAgICBzY2FsZTogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLnRyYW5zbGF0ZSh2YWwpO1xuICAgIH0sXG4gICAgc3JjOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciB2ID0gdmFsLnZhbDtcbiAgICAgIGlmICh2ICYmIHZbdi5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgICAgIHRoaXMubm9kZS5zcmMgPSB2O1xuICAgICAgfVxuICAgIH0sXG4gICAgYXR0cjpmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciB0ID0gdGhpc1xuICAgICAgdmFsLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICB0Lm5vZGUuc2V0QXR0cmlidXRlKGksdGhpcy52YWwpXG4gICAgICB9KVxuICAgIH0sXG4gICAgYmFja2dyb3VuZFBvczogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gdmFsLnZhbFxuICAgIH0sXG4gICAgYmFja2dyb3VuZEJhdGNoOiBmdW5jdGlvbih2YWwpIHtcblxuXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kOiBmdW5jdGlvbih2YWwpIHsgLy9vcHRpb25hbCBtYXliZSBpbiBhIHNlcGVyYXRlIG1vZHVsZVxuICAgICAgdmFyIHYgPSB2YWwudmFsXG4gICAgICAgICwgdCA9IHRoaXNcbiAgICAgICAgLCBzdHlsZSA9IHRoaXMubm9kZS5zdHlsZVxuICAgICAgICAsIHVybFxuICAgICAgICAsIGhhc2hlZFxuICAgICAgICAsIHBhcmVudEJhdGNoXG4gICAgICAgICwgYmF0Y2hcblxuICAgICAgaWYodmFsLmdvbmUgJiYgdmFsLmdvbmUudmFsKSB7XG4gICAgICAgIHZhbC5fc2tpcCA9IHRydWVcbiAgICAgICAgc3R5bGUuYmFja2dyb3VuZEltYWdlID0gJydcbiAgICAgIH0gZWxzZSBpZiAodiAmJiB2W3YubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgICAgICB1cmwgPSAndXJsKCcgKyB2ICsgJyknXG4gICAgICAgIGlmKHN0eWxlLmJhY2tncm91bmRJbWFnZT09PXVybCkgcmV0dXJuXG5cbiAgICAgICAgLy9WYWx1ZVxuICAgICAgICBpZiAodmFsLnNpemUpIHN0eWxlLmJhY2tncm91bmRTaXplID0gdmFsLnNpemUudmFsXG5cbiAgICAgICAgaWYgKHZhbC5sb2FkKSB7XG5cbiAgICAgICAgICBoYXNoZWQgPSBoYXNoKHYpXG4gICAgICAgICAgcGFyZW50QmF0Y2ggPSB0aGlzLmNoZWNrUGFyZW50KCdiYWNrZ3JvdW5kQmF0Y2gnKVxuICAgICAgICAgIGlmKHBhcmVudEJhdGNoKSBiYXRjaCA9IHBhcmVudEJhdGNoLmJhY2tncm91bmRCYXRjaFxuXG4gICAgICAgICAgaWYoIV9sb2FkW2hhc2hlZF0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IG51bGxcbiAgICAgICAgICAgIC8vYWxzbyByZW1vdmUgc2V0dGluZ1xuXG4gICAgICAgICAgICBpZihiYXRjaCkge1xuICAgICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYmF0Y2guX3JhZilcbiAgICAgICAgICAgICAgaWYoIWJhdGNoLmJhdGNoKSBiYXRjaC5iYXRjaCA9IFtdXG4gICAgICAgICAgICAgIGJhdGNoLmJhdGNoLnB1c2goaGFzaClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2xvYWRbaGFzaGVkXT1uZXcgVmFsdWUoZmFsc2UpXG4gICAgICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJylcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgIGlmKGJhdGNoKSB7XG4gICAgICAgICAgICAgICBiYXRjaC5iYXRjaC5zcGxpY2UodXRpbC5jaGVja0FycmF5KGJhdGNoLmJhdGNoLGhhc2hlZCksMSlcbiAgICAgICAgICAgICAgIGlmKGJhdGNoLmJhdGNoLmxlbmd0aD09PTApIHtcbiAgICAgICAgICAgICAgICBiYXRjaC5iYXRjaCA9IG51bGxcbiAgICAgICAgICAgICAgICBiYXRjaC5fcmFmID0gcmFmKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYocGFyZW50QmF0Y2guX25vZGUpIGJhdGNoLl92YWwuY2FsbChwYXJlbnRCYXRjaClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfbG9hZFtoYXNoZWRdLnZhbCA9IHRydWVcbiAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IG51bGxcbiAgICAgICAgICAgICAgaW1nID0gbnVsbFxuICAgICAgICAgICAgICBfbG9hZFtoYXNoZWRdLnJlbW92ZShmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSxmYWxzZSx0cnVlKVxuICAgICAgICAgICAgICBfbG9hZFtoYXNoZWRdID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1nLnNyYyA9IHZcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihfbG9hZFtoYXNoZWRdIT09dHJ1ZSkge1xuICAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IG51bGxcblxuICAgICAgICAgICAgX2xvYWRbaGFzaGVkXS5hZGRMaXN0ZW5lcihbZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmKHZhbC5sb2FkICYmIHZhbC5sb2FkLnZhbCE9PXRydWUpIHZhbC5sb2FkLl92YWwuY2FsbCh0aGlzLCB0KTtcbiAgICAgICAgICAgIH0sdmFsLl9iYXNlXSwgdHJ1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlXG5cbiAgICAgICAgICAgIGlmKGJhdGNoKSB7XG4gICAgICAgICAgICAgIGlmKCghYmF0Y2guYmF0Y2gpIHx8IGJhdGNoLmJhdGNoLmxlbmd0aD09PTApIHtcbiAgICAgICAgICAgICAgICBiYXRjaC5iYXRjaCA9IG51bGxcbiAgICAgICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoYmF0Y2guX3JhZilcbiAgICAgICAgICAgICAgICBiYXRjaC5fcmFmID0gcmFmKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgIGlmKHBhcmVudEJhdGNoLl9ub2RlKSBiYXRjaC5fdmFsLmNhbGwocGFyZW50QmF0Y2gpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih2YWwubG9hZC52YWwhPT10cnVlKSB2YWwubG9hZC5fdmFsLmNhbGwodGhpcywgdCk7XG5cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSB1cmxcblxuICAgICAgfVxuICAgIH0sXG4gICAgcGFkZGluZzogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUucGFkZGluZyA9IHZhbC52YWwgKyAncHgnO1xuICAgIH0sXG4gICAgeTogX2Nvb3JkaW5hdGUoJ3RvcCcpLFxuICAgIHg6IF9jb29yZGluYXRlKCdsZWZ0JyksXG4gICAgZGlzcGxheTogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLm5vZGUuc3R5bGUuZGlzcGxheSA9IHZhbC52YWw7XG4gICAgfSxcbiAgICB3OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCd3Jyk7XG4gICAgICB2YXIgdiA9IHZhbC52YWxcbiAgICAgIHRoaXMubm9kZS5zdHlsZS53aWR0aCA9ICh2ID4gLTEgPyAodiB8IDApICArICdweCcgOiB2ICkgfHwgJzEwMCUnIFxuICAgIH0sXG4gICAgaDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAvLyB2YXIgdiA9IHZhbC52YWwgfCAwIHR5cG8gb3IgYnVnP1xuICAgICAgdmFyIHYgPSB2YWwudmFsXG4gICAgICB0aGlzLm5vZGUuc3R5bGUuaGVpZ2h0ID0gKHYgPiAtMSA/ICh2IHwgMCkgICsgJ3B4JyA6IHYgKSB8fCAnMTAwJSdcbiAgICB9LFxuICAgIG9wYWNpdHk6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHYgPSB2YWwudmFsO1xuICAgICAgaWYodj09PWZhbHNlKSB0aGlzLm5vZGUuc3R5bGUub3BhY2l0eSA9IG51bGxcbiAgICAgIGVsc2UgdGhpcy5ub2RlLnN0eWxlLm9wYWNpdHkgPSB2ID4gLTEgPyB2IDogMTtcbiAgICB9LFxuICAgIGh0bWw6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHYgPSB2YWwudmFsIHx8ICcnXG4gICAgICBpZiggdi5yZXBsYWNlIClcbiAgICAgIHtcbiAgICAgICAgLy9hZGQgc29tZSBpbmplY3Rpb24gcHJldmVudGlvbiBhcyBvcHRpb24/IChubyBzY3JpcHQgZXRjKVxuICAgICAgICB2ID0gdi5yZXBsYWNlKC9cXHQvZywgJyAgICAnKVxuICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHJcXG58XFxufFxcci9nLCAnPGJyLz4nKVxuICAgICAgICAgICAgIC5yZXBsYWNlKC8gIC9nLCAnJm5ic3A7ICcpXG4gICAgICAgICAgICAgLnJlcGxhY2UoLyAgL2csICcgJm5ic3A7JykgLy8gc2Vjb25kIHBhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGVzIG9kZCBudW1iZXIgb2Ygc3BhY2VzLCB3aGVyZSB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVuZCB1cCB3aXRoIFwiJm5ic3A7XCIgKyBcIiBcIiArIFwiIFwiXG4gICAgICAgIHRoaXMubm9kZS5pbm5lckhUTUwgPSB2XG4gICAgICB9XG5cbiAgICB9LFxuICAgIGhyZWY6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy5ub2RlLmhyZWYgPSB2YWwudmFsO1xuICAgIH0sXG4gICAgdGV4dDogZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdTRVRUSU5HIFRFWFQnLmdyZWVuLmludmVyc2UuIHZhbC52YWwsIHZhbClcblxuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVcbiAgICAgICAgLCBub2RlcyA9IG5vZGUuY2hpbGROb2Rlc1xuICAgICAgICAsIHYgPSB2YWwudmFsIHx8IHZhbC52YWwgPT09IDAgPyB2YWwudmFsIDogJydcblxuICAgICAgaWYodiBpbnN0YW5jZW9mIE9iamVjdCkgdiA9ICcnXG5cbiAgICAgIGlmICgvdGV4dC8udGVzdChub2RlLnR5cGUpKSB7XG4gICAgICAgIG5vZGUudmFsdWUgPSB2O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2Rlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChub2Rlc1tpXS5ub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0JMQUJMQScuaW52ZXJzZSx2KVxuICAgICAgICAgICAgbm9kZXNbaV0ubm9kZVZhbHVlID0gdjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodikpO1xuICAgIH0sXG4gICAgJHRpbWVvdXQ6IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICBpZihzZXRUaW1lcnMgPT09IHZvaWQgMCl7XG4gICAgICAgIHNldFRpbWVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMuJHRpbWVvdXRcbiAgICAgICAgICBpZiggdGltZW91dCApIHtcbiAgICAgICAgICAgIGlmKF9zZXRUaW1lb3V0ID09PSB2b2lkIDApe1xuICAgICAgICAgICAgICBfc2V0VGltZW91dCA9IGZ1bmN0aW9uKCBfdGhpcywgdGltZW91dCwga2V5cywgaSApIHtcbiAgICAgICAgICAgICAgICB2YXIgdGltZSA9IGtleXNbIGkgXSAtICgga2V5c1sgaSAtIDEgXSB8fCAwIClcbiAgICAgICAgICAgICAgICB2YXIgZm4gPSB0aW1lb3V0WyBrZXlzWyBpIF0gXS5fdmFsXG4gICAgICAgICAgICAgICAgZm4uaWQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGZuLmlkID0gbnVsbFxuICAgICAgICAgICAgICAgICAgaWYoICFmbi5kb25lIHx8ICFfdGhpcy5kb25lICkge1xuICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKCBfdGhpcyApXG4gICAgICAgICAgICAgICAgICAgIGZuLmRvbmUgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRvbmUgPSBudWxsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZigga2V5c1sgKytpIF0gKSBfc2V0VGltZW91dCggX3RoaXMsIHRpbWVvdXQsIGtleXMsIGkgKVxuICAgICAgICAgICAgICAgIH0sIHRpbWUgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3NldFRpbWVvdXQoIF90aGlzLCB0aW1lb3V0LCB0aW1lb3V0LmtleXMsIDAgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoIHRoaXMucmVuZGVyZWQgKSB7XG4gICAgICAgIHNldFRpbWVycy5jYWxsKCB0aGlzIClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U2V0dGluZygge1xuICAgICAgICAgIG5hbWU6ICdzZXRUaW1lcnMnLFxuICAgICAgICAgIHJlbmRlcjogc2V0VGltZXJzXG4gICAgICAgIH0gKVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFNldHRpbmcoIHtcbiAgICAgICAgbmFtZTogJ3JlbW92ZVRpbWVycycsXG4gICAgICAgIHJlbW92ZTogcmVtb3ZlVGltZXJzIHx8IChyZW1vdmVUaW1lcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCctLS0tLS0tLVJFTU9WRScsdGhpcy5fbm9kZSlcbiAgICAgICAgICB2YXIgdGltZXJzID0gdGhpcy4kdGltZW91dFxuICAgICAgICAgIGlmKCB0aW1lcnMgKSB7XG4gICAgICAgICAgICB0aW1lcnMuZWFjaCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBmbiA9IHRoaXMuX3ZhbFxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCctLS0tLS0tLS1yZW1vdmluZycsZm4sZm4uZG9uZSlcbiAgICAgICAgICAgICAgaWYoIHRoaXMuZG9uZSApIHRoaXMuZG9uZSA9IG51bGxcbiAgICAgICAgICAgICAgaWYoIGZuLmlkICkgY2xlYXJUaW1lb3V0KCBmbi5pZCApXG4gICAgICAgICAgICAgIGlmKCBmbi5kb25lICkgZm4uZG9uZSA9IG51bGxcbiAgICAgICAgICAgIH0gKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gKVxuICAgIH1cbiAgfSk7XG59KTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGZ1bmN0aW9uKGJhc2UpIHtcbiAgdmFyIHByb3RvID0gYmFzZS5DbGFzcy5wcm90b3R5cGVcbiAgICAsIGFkZCA9IHByb3RvLmFkZFxuXG4gIHV0aWwuZGVmaW5lXG4gICggcHJvdG9cbiAgLCAnYWRkJ1xuICAsICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICBpZiggIXZhbC5wcm9jZXNzIClcbiAgICAgICB7XG4gICAgICAgICAgYWRkLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgIH0gZWxzZVxuICAgICAgIHtcbiAgICAgICAgICB2YWwuX190ZW1wQWRkID0gdXRpbC5hcmcoIGFyZ3VtZW50cyApXG4gICAgICAgICAgdmFsLl9fdGVtcEFkZC51bnNoaWZ0KHRoaXMpXG4gICAgICAgfVxuICAgICB9XG4gIClcblxuICBiYXNlLmV4dGVuZCh7XG4gICAgcHJvY2VzczogZnVuY3Rpb24odmFsKSB7XG4gICAgICBjb25zb2xlLmxvZygneHh4eF9fX3h4eHgnKVxuICAgICAgaWYodGhpcy5fX3RlbXBBZGQgJiYgIXRoaXMucGFyZW50KSB7XG4gICAgICAgIGFkZC5hcHBseSh0aGlzLl9fdGVtcEFkZFswXSwgdGhpcy5fX3RlbXBBZGQuc2xpY2UoMSkpXG4gICAgICAgIHRoaXMuX190ZW1wQWRkID0gbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfSlcblxufSlcblxuLy9wcm9jZXNzIHdvcmR0IG1pc2NoaWVuIG1lZXIgZWVuIG9wZXJhdG9yP1xuLy9zb29ydCBmaWVsZCBlaWdlbmxpamsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzJylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJy4uLy4uL2Nhc2VzJylcbiAgLCB1YSA9IHJlcXVpcmUoJy4uLy4uL3VhJylcbiAgLCBnbG9iYWwgPSBmYWxzZVxuICAsIE5PTkUgPSAnbm9uZSdcbiAgLCBfaW9zID0gdWEucGxhdGZvcm09PT0naW9zJ1xuICAsIF9hbmRyb2lkID0gdWEucGxhdGZvcm09PT0nYW5kcm9pZCdcbiAgLCBWSVNJQkxFID0gJ3Zpc2libGUnXG4gICwgZXh0ZW5kID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpLmV4dGVuZFxuICAsIGRvYyA9IGV2ZW50cy5kb2N1bWVudFxuICAsIHRpbWVyXG4gICwgZm5cblxuaWYoY2FzZXMuJGhhc1RvdWNoKXtcblxuICBmdW5jdGlvbiBibHVyIChlKXtcbiAgICBpZighZG9jdW1lbnQuYWN0aXZlRWxlbWVudCl7XG4gICAgICBkb2MucmVtb3ZlRXZlbnQoZmFsc2UsJ2JsdXInKVxuICAgIH1lbHNlIGlmKGUudGFyZ2V0LnRhZ05hbWUhPT0nSU5QVVQnICYmIGUudGFyZ2V0LnRhZ05hbWUhPT0nRk9STScpe1xuICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5ibHVyKClcbiAgICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSwnYmx1cicpXG4gICAgfVxuICB9XG5cbiAgZXZlbnRzLnByZXZlbnREb3duID0gXG4gIHsgdmFsOlxuICAgIHsgZG93bjpmdW5jdGlvbihlLG1ldGhvZCkge1xuICAgICAgICBpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSBkb2MuYWRkRXZlbnQoJ3VwJyxibHVyLCdibHVyJylcbiAgICAgICAgZWxzZSBpZihlLnRhcmdldC50YWdOYW1lIT09J0lOUFVUJyAmJiBlLnRhcmdldC50YWdOYW1lIT09J0ZPUk0nICYmICFldmVudHMuX21heWJlc2Nyb2xsKSBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBldmVudHMuc2Nyb2xsYmFyID0gXG4gIHsgdmFsOiBcbiAgICB7IGRvd246ZnVuY3Rpb24oZSxtZXRob2QsdmFsKSB7XG5cbiAgICAgICAgdmFyIHNjcm9sbFN0YXJ0XG4gICAgICAgICAgLCB0ID0gdGhpc1xuICAgICAgICAgICwgc2Nyb2xsU3RyXG4gICAgICAgICAgLCB4QXhpcyA9ICh2YWwuX3ZhbCA9PT0gJ3gnKVxuICAgICAgICAgICwgYXhpc1xuICAgICAgICAgICwgb3RoZXJheGlzXG4gICAgICAgICAgLCBtb3ZlXG4gICAgICAgICAgLCBkXG4gICAgICAgICAgLCBib3R0b21QcmV2ZW50XG4gICAgICAgICAgXG4gICAgICAgIGlmKHhBeGlzKSB7XG4gICAgICAgICAgYXhpcyA9ICd4J1xuICAgICAgICAgIG90aGVyYXhpcyA9ICd5J1xuICAgICAgICAgIHNjcm9sbFN0ciA9ICdzY3JvbGxMZWZ0J1xuICAgICAgICAgIGQgPSB0Lm5vZGUuc2Nyb2xsV2lkdGggLSB0Lm5vZGUub2Zmc2V0V2lkdGhcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgYXhpcyA9ICd5J1xuICAgICAgICAgIG90aGVyYXhpcyA9ICd4J1xuICAgICAgICAgIHNjcm9sbFN0ciA9ICdzY3JvbGxUb3AnXG4gICAgICAgICAgZCA9IHQubm9kZS5zY3JvbGxIZWlnaHQgLSB0Lm5vZGUub2Zmc2V0SGVpZ2h0XG4gICAgICAgIH1cblxuICAgICAgICBzY3JvbGxTdGFydCA9IHQubm9kZVtzY3JvbGxTdHJdIC8vPD09PT09PT09IGxlc3MgZWZmaWNpZW50IGJ1dCBtb3JlIHByZWRpY3RhYmxlIGZvciBjb21wZW5zYXRpb25cblxuICAgICAgICBpZihkID4gMCl7XG4gICAgICAgICAgZXZlbnRzW2F4aXNdID0gdHJ1ZVxuICAgICAgICAgIGV2ZW50cy5fbWF5YmVzY3JvbGwgPSB0cnVlXG4gICAgICAgICAgaWYoIXhBeGlzKXtcbiAgICAgICAgICAgIGlmICghc2Nyb2xsU3RhcnQpe1xuICAgICAgICAgICAgICBzY3JvbGxTdGFydCA9IHQubm9kZVtzY3JvbGxTdHJdID0gIDFcbiAgICAgICAgICAgIH1lbHNlIGlmKHNjcm9sbFN0YXJ0PT09ZCkge1xuICAgICAgICAgICAgICBzY3JvbGxTdGFydCA9IHQubm9kZVtzY3JvbGxTdHJdID0gZCAtIDFcbiAgICAgICAgICAgIH1lbHNlIGlmKHNjcm9sbFN0YXJ0ID4gZCl7XG4gICAgICAgICAgICAgIGJvdHRvbVByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHkgPSBlLnlcbiAgICAgICAgICAgICwgeCA9IGUueFxuICAgICAgICAgICAgLCBtb3ZlaWQgPSBzY3JvbGxTdHIgKyBheGlzXG4gICAgICAgICAgXG4gICAgICAgICAgZG9jLmFkZEV2ZW50KCdtb3ZlJyxmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHgtZS54KVxuICAgICAgICAgICAgICAsIGRZID0geS1lLnlcbiAgICAgICAgICAgICAgLCBkeSA9IE1hdGguYWJzKGRZKVxuXG4gICAgICAgICAgICBpZih4QXhpcyl7XG4gICAgICAgICAgICAgIGlmKGR5ID4gZHgpe1xuICAgICAgICAgICAgICAgIGV2ZW50c1theGlzXSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYoIWV2ZW50c1tvdGhlcmF4aXNdKSBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGlmKGR4ID4gZHkpe1xuICAgICAgICAgICAgICAgIGV2ZW50c1theGlzXSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaWYoIWV2ZW50c1tvdGhlcmF4aXNdKSBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZihib3R0b21QcmV2ZW50ICYmIGRZID4gMCl7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW92ZSA9IHRydWVcbiAgICAgICAgICAgIGJsdXIoZSlcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSxtb3ZlaWQpXG4gICAgICAgICAgfSxtb3ZlaWQpXG5cbiAgICAgICAgICBkb2MuYWRkRXZlbnQoJ3VwJyxmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbXMgPSBldmVudHMuX21heWJlc2Nyb2xsLCBtc2wsIGFyclxuXG4gICAgICAgICAgICBpZighbW92ZSl7XG4gICAgICAgICAgICAgIHZhciBzY3JsbCA9IHQubm9kZVtzY3JvbGxTdHJdXG4gICAgICAgICAgICAgIG1vdmUgPSAhKHNjcmxsID09PSBzY3JvbGxTdGFydCkgfHwgc2NybGwgPCAwIHx8ICggc2NybGwgPiBkICYmICFib3R0b21QcmV2ZW50IClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIW1vdmUgJiYgIWV2ZW50c1tvdGhlcmF4aXNdICYmICFldmVudHMuY2xpY2suYmxvY2sgJiYgbXMgJiYgbXMubGVuZ3RoKXtcbiAgICAgICAgICAgICAgbXNsID0gbXMubGVuZ3RoXG4gICAgICAgICAgICAgIHdoaWxlKG1zbC0tKSBpZighZS5wcmV2ZW50KXtcbiAgICAgICAgICAgICAgICBhcnIgPSBtc1ttc2xdXG4gICAgICAgICAgICAgICAgYXJyWzBdLmNhbGwoYXJyWzFdLGUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIWV2ZW50c1tvdGhlcmF4aXNdIHx8IG1vdmUpIGV2ZW50cy5fbWF5YmVzY3JvbGwgPSBmYWxzZVxuXG4gICAgICAgICAgICBldmVudHNbYXhpc10gPSBmYWxzZVxuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLHNjcm9sbFN0cilcblxuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCA9IDBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSxzY3JvbGxTdHIpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgIFxuICAgIHZhciBzdHlsZSA9IHRoaXMubm9kZS5zdHlsZVxuXG4gICAgc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJ1xuICAgIHN0eWxlLndlYmtpdE92ZXJmbG93U2Nyb2xsaW5nID0gJ3RvdWNoJ1xuICAgIHN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnYXV0bydcbiAgICBzdHlsZS50b3VjaEFjdGlvbiA9ICdhdXRvJ1xuXG4gICAgaWYgKHZhbC52YWwgPT09ICd4Jykge1xuICAgICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdwYW4teCdcbiAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gJ3Bhbi14J1xuICAgICAgc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbidcbiAgICAgIHN0eWxlLm92ZXJmbG93WCA9ICdzY3JvbGwnXG4gICAgfWVsc2UgaWYgKHZhbC52YWwgPT09ICd5Jykge1xuICAgICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdwYW4teSdcbiAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gJ3Bhbi15J1xuICAgICAgc3R5bGUub3ZlcmZsb3dYID0gJ2hpZGRlbidcbiAgICAgIHN0eWxlLm92ZXJmbG93WSA9ICdzY3JvbGwnXG4gICAgfVxuXG4gICAgdGhpcy5ldmVudHMgPSB7IHNjcm9sbGJhcjp2YWwudmFsIH1cbiAgICBpZighZ2xvYmFsKSB7XG4gICAgICBnbG9iYWwgPSB0cnVlXG4gICAgICBkb2MuZXZlbnRzID0geyBwcmV2ZW50RG93bjp0cnVlIH1cbiAgICB9XG4gIH1cblxufWVsc2V7XG5cbiAgZm4gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgY29uc29sZS5lcnJvcignbnVudSBoZXkhJylcblxuICAgIHZhciBzdHlsZSA9IHRoaXMubm9kZS5zdHlsZTtcbiAgICBzdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcbiAgICBzdHlsZS5vdmVyZmxvd1kgPSB2YWwudmFsICE9PSAneCcgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xuICAgIHN0eWxlLm92ZXJmbG93WCA9IHZhbC52YWwgIT09ICd5JyA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XG4gIH1cblxufVxuXG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZChmdW5jdGlvbihiYXNlKSB7XG4gIGJhc2UuZXh0ZW5kKHsgc2Nyb2xsYmFyOmZuIH0pXG59KSAgIiwidmFyIHVhID0gcmVxdWlyZSgnLi4vLi4vdWEnKVxuICAsIF9wcmVmaXggPSAnLScrdWEucHJlZml4LnRvTG93ZXJDYXNlKClcbiAgLCBfdHJhbnNmb3JtID0gX3ByZWZpeCArICctdHJhbnNmb3JtJ1xuXG5leHBvcnRzLmdldE1hdHJpeCA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgaWYobm9kZS5zdHlsZVtfdHJhbnNmb3JtXSkge1xuICAgIHZhciBhcnIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKVxuICAgICAgLmdldFByb3BlcnR5VmFsdWUoX3RyYW5zZm9ybSkucmVwbGFjZSgnbWF0cml4KCcsICcnKS5zcGxpdCgnLCcpXG4gICAgcmV0dXJuIGFyclxuICB9XG59XG5cbi8vIGV4cG9ydHMuaGFzQ2FsYyA9IGZ1bmN0aW9uKCkge1xuLy8gICB2YXIgZHVtbXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuLy8gICAgICwgcHJvcHMgPSBbIF9wcmVmaXgrJy1jYWxjJywgJ2NhbGMnIF1cbi8vICAgICAsIGkgPSBwcm9wcy5sZW5ndGhcbi8vICAgd2hpbGUoaS0xKSB7XG4vLyAgICAgZHVtbXkuc3R5bGUuY3NzVGV4dCA9ICd3aWR0aDonICsgcHJvcHNbaS0xXSArICcoMXB4KTsnXG4vLyAgICAgaWYgKGR1bW15LnN0eWxlLmxlbmd0aCkgcmV0dXJuIHByb3BzW2ktMV1cbi8vICAgICBpLS1cbi8vICAgfVxuLy8gfSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBlbGVtZW50ID0gcmVxdWlyZSgnLi8nKVxuICAsIG9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpXG5cbi8qKlxuICogZmxhZ3NcbiAqIGFkZCBrZXl3b3JkcyB0byBzZXQgb2JqZWN0cyB3aGljaCBhcmUgY2hlY2tlZCB1c2luZyBhIGZ1bmN0aW9uIGluIGZsYWdzXG4gKiBzaW1wbHkgYWRkIGZpZWxkcyB0byB0aGUgc2V0IG1vZHVsZVxuICovXG52YXIgZmxhZ3MgPSBleHBvcnRzXG4gIC8qKlxuICAgKiBfZmxhZ1xuICAgKiBmdW5jdGlvbiB0aGF0IGNhbGxzIGZsYWcgZnVuY3Rpb25zIG9uIGVsZW1lbnQuc2V0LmZsYWdzXG4gICAqL1xuICAsIF9mbGFnID0gZnVuY3Rpb24obmFtZSwgdmFsLCBjb3B5LCB0b3ApIHtcbiAgICAgIHZhciBmO1xuICAgICAgZm9yICh2YXIgaSBpbiBmbGFncykge1xuICAgICAgICBmID0gZmxhZ3NbaV0uY2FsbCh0aGlzLCBuYW1lLCB2YWwsIGNvcHksIHRvcCk7XG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgcmV0dXJuIGY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbnV0aWwuZGVmaW5lKGVsZW1lbnQsXG4gIC8qKlxuICAgKiBzZXRcbiAgICogYWRkcyBjaGlsZHJlbiBmb3Igbm9uIGV4aXN0aW5nIGF0dHJpYnV0ZXNcbiAgICogX29yaWdpbmFsIGFyZSBvcmlnaW5hbCB2YWx1ZXMgY2hhbmdlZCBieSBjYXNlcyBhbmQgZXZlbnRzXG4gICAqIGluc3RhbmNlcyAtIGFkZCBvciByZW1vdmUgY2hpbGRyZW4gZnJvbSBpbnN0YW5jZXM7XG4gICAqL1xuICAnX3NldCcsIGZ1bmN0aW9uKHZhbCwgaSwgaW5zdGFuY2VzKSB7XG4gICAgLy90aGlzXG4gICAgaWYgKCFfZmxhZy5jYWxsKHRoaXMsIGksIHZhbFtpXSwgaW5zdGFuY2VzLCB2YWwpKSB7XG5cbiAgICAgIGlmICggIXRoaXMuaXNQcm9wZXJ0eSggaSwgdmFsICkgKSB7XG5cbiAgICAgICAgaWYgKHZhbFtpXSBpbnN0YW5jZW9mIGVsZW1lbnQpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlXG4gICAgICAgICAgaWYgKHRoaXNbaV0pIHtcbiAgICAgICAgICAgIGZvcih2YXIgYz10aGlzLm5vZGUuY2hpbGROb2Rlcyxub2RlJD0wLGxlbj1jLmxlbmd0aDtub2RlJDxsZW47bm9kZSQrKykge1xuICAgICAgICAgICAgICBpZihjW25vZGUkXT09PXRoaXNbaV0ubm9kZSkge1xuICAgICAgICAgICAgICAgIGJlZm9yZSA9IGNbKG5vZGUkKzEpXVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2ldLnJlbW92ZSAmJiB0aGlzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL3JlcGxhY2UgZWxlbWVudCBpZiBpdHMgYWxyZWFkeSB0aGVyZVxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoYWRkLCBpbnN0YW5jZXMsIHZhbFtpXSlcbiAgICAgICAgICB2YXIgYWRkID0gaW5zdGFuY2VzID8gbmV3IHZhbFtpXS5DbGFzcyA6IHZhbFtpXTtcbiAgICAgICAgICBhZGQubmFtZSA9IGk7XG4gICAgICAgICAgdGhpcy5hZGQoYWRkLCBiZWZvcmUpO1xuICAgICAgICAgIGlmIChpbnN0YW5jZXMpIHtcbiAgICAgICAgICAgIHRoaXMuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICB2YXIgYSA9IG5ldyBhZGQuQ2xhc3MoKTtcbiAgICAgICAgICAgICAgYS5fbmFtZSA9IGk7XG4gICAgICAgICAgICAgIHRoaXMuYWRkKGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFxuICAgICAgICAgIGlmKCB0aGlzW2ldIGluc3RhbmNlb2Ygb2JqZWN0ICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy9UT0RPOiB0b3JvdWdoIHRlc3RpbmdcbiAgICAgICAgICAgIHRoaXNbaV0udmFsID0gdmFsW2ldXG4gICAgICAgICAgfSBcbiAgICAgICAgICBlbHNlIGlmKCB2YWxbaV0gaW5zdGFuY2VvZiBvYmplY3QgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byBzZXQgdXNpbmcgYSB2T2JqZWN0PyBtYXliZSByZXF1aXJlIHNvbWUgc3R1ZmYgKGUuZy4gZGF0YSknKVxuICAgICAgICAgICAgdGhpc1tpXSA9IHZhbFtpXVxuICAgICAgICAgIH0gXG4gICAgICAgICAgZWxzZSBpZiggdGhpc1tpXSBpbnN0YW5jZW9mIGVsZW1lbnQgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiggdmFsW2ldICkge1xuICAgICAgICAgICAgICB0aGlzW2ldLnNldCh2YWxbaV0sIGluc3RhbmNlcylcbiAgICAgICAgICAgIH0gZWxzZSBpZiggdmFsW2ldID09PSBmYWxzZSApe1xuICAgICAgICAgICAgICBpZiAoIGluc3RhbmNlcyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzW2ldKSB0aGlzW2ldLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzW2ldLnJlbW92ZSgpXG4gICAgICAgICAgICAgIHRoaXNbaV0gPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBcbiAgICAgICAgICBlbHNlIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmKHZhbFtpXSBpbnN0YW5jZW9mIE9iamVjdCApIHtcbiAgICAgICAgICAgICAgdmFyIGFkZCA9IG5ldyBlbGVtZW50KCkuc2V0KHZhbFtpXSwgaW5zdGFuY2VzKVxuICAgICAgICAgICAgICBhZGQubmFtZSA9IGk7XG4gICAgICAgICAgICAgIHRoaXMuYWRkKGFkZClcbiAgICAgICAgICAgICAgaWYgKGluc3RhbmNlcylcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaEluc3RhbmNlKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhID0gbmV3IGFkZC5DbGFzcygpXG4gICAgICAgICAgICAgICAgICBhLl9uYW1lID0gaVxuICAgICAgICAgICAgICAgICAgdGhpcy5hZGQoYSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1wiJyArIGkgKyAnXCIgaXMgbm90IGFuIGV4aXN0aW5nIHByb3BlcnR5LiBcIicgKyB2YWxbaV0gKyAnXCIgaXMgYSBwcmltaXRpdmUuIEFkZGluZyBhcyBwcmltaXRpdmUuJyApXG4gICAgICAgICAgICAgIHRoaXNbaV0gPSB2YWxbaV1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYodHlwZW9mIHRoaXNbaV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZih2YWxbaV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdGhpc1tpXS5hcHBseSh0aGlzLHZhbFtpXSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tpXSh2YWxbaV0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbaV0gPSB2YWxbaV1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9keW5hbWljIGNoYW5nZXMgdG8gdGhlIF9vcmlnaW5hbCBzZXQgb2JqZWN0IHBvb2xcbiAgICAgIC8vaWYgKCFjb3B5ICYmIHRoaXMuX29yaWdpbmFsKSB7XG4gICAgICAvL3RoaXMuX29yaWdpbmFsW2ldID0gdmFsW2ldOyAvL2NoZWNrIGlmIHN0dWZmIC93IGNsYXNzZXMgaXMgbmVzc2VjYXJ5O1xuICAgICAgLy99XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogY29udmVydFxuICAgKiBmb3IgZWFjaCBmaWVsZHMgaW4gdmFsIGNvbnZlcnQgYmFjayB0byBhIHNldE9iamVjdDtcbiAgICovXG4gICdjb252ZXJ0JywgZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIHNldE9iaiA9IHt9LFxuICAgICAgaXNPYmo7XG4gICAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICAgIGlzT2JqID0gdXRpbC5pc09iaih2YWxbaV0pXG4gICAgICBpZiAodGhpc1tpXSBpbnN0YW5jZW9mIGVsZW1lbnQpIHtcbiAgICAgICAgc2V0T2JqW2ldID0gaXNPYmogPyB0aGlzW2ldLmNvbnZlcnQodmFsW2ldKSA6IHRoaXNbaV1cbiAgICAgIH0gZWxzZSBpZiAodGhpc1tpXSBpbnN0YW5jZW9mIG9iamVjdCkge1xuICAgICAgICBzZXRPYmpbaV0gPSB0aGlzW2ldLmNvbnZlcnQoaXNPYmogJiYgdmFsW2ldKVxuICAgICAgfSBlbHNlIGlmICh0aGlzW2ldID09PSB2b2lkIDAgfHwgKHV0aWwubG9va3VwLmNhbGwodGhpcywgaSkgJiYgdGhpc1tpXSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHNldE9ialtpXSA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRPYmpbaV0gPSB0aGlzW2ldXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXRPYmpcbiAgfSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG4vL2R1cmF0aW9uIGluIGEgVi5WYWx1ZSAtLT4gdXBkYXRlIGlmIG5lc3NlY2FyeT9cbnZhciB1YSA9IHJlcXVpcmUoJy4uLy4uL3VhJylcbiAgLCB2aWRlbyA9IHJlcXVpcmUoJy4vJylcbiAgLCBwb3N0cG9uZSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxuICAsIF93aW5QaG9uZSA9IHVhLnBsYXRmb3JtID09PSAnd2luZG93cycgJiYgdWEuZGV2aWNlID09PSAncGhvbmUnXG4gICwgX2lvcyA9IHVhLnBsYXRmb3JtID09PSAnaW9zJ1xuICAsIF9hbmRyb2lkID0gdWEucGxhdGZvcm0gPT09ICdhbmRyb2lkJ1xuICAsIF9pb3M3ID0gX2lvcyAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnNwbGl0KCdPUycpWzFdWzFdID09PSAnNycgLy8gVEVNUCBGSVggVU5USUwgV0UgRE8gVUFcbiAgLCBfY2FucGxheSA9ICdjYW5wbGF5Jy8vX2lvczcgPyAnY2FucGxheXRocm91Z2gnIDogJ2NhbnBsYXknIFxuXG5mdW5jdGlvbiBjcmVhdGVMaXN0ZW5lciAoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzXG4gICAgLCBsID0gYXJncy5sZW5ndGhcblxuICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBfdGhpcyA9IHRoaXM7IGkgPCBsOyB0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lcihhcmdzW2krK11cbiAgICAgICwgZnVuY3Rpb24oZSkgeyB0eXBlLl92YWwuY2FsbChfdGhpcyxlKSB9KSk7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBfY2FucGxheUxpc3RlbmVyICgpIHtcbiAgaWYgKCAhdGhpcy5fY2FucGxheSAmJiAhX3dpblBob25lICkgeyAvL2xhdGVyIHZlcnNpb25zIChpZiBmaXhlZGluIDkpXG4gICAgXG4gICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgLCBub2RlID0gdGhpcy5ub2RlXG4gICAgXG4gICAgdGhpcy5fY2FucGxheSA9IHRydWVcbiAgICBcbiAgICAvLyBpZihfaW9zKSBub2RlLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuXG4gICAgZnVuY3Rpb24gY2FuUGxheSgpIHtcbiAgICAgIGlmICggX3RoaXMudGltZSApIHtcbiAgICAgICAgXG4gICAgICAgIGlmICghX3RoaXMudGltZS52YWwpIHRoaXMuX2ZpcnN0VCA9IHRydWVcbiAgICAgICAgICAvL2ZpeGVzIGZvciBwaG9uZWdhcCEgd2luZG93c21vYmlsZVxuICAgICAgICBpZiAoX2FuZHJvaWQgJiYgdWEuYnJvd3NlciAhPT0gJ2Nocm9tZScpIHsgXG4gICAgICAgICAgLy9hbmQgc3BlY2lhbCBicm93c2VyITsgY2hlY2sgZmlyZWZveDsgLy9pZGVudGlmeSBtb3JlIGJyb3dzZXJzIHRoYXQgZG8gbm90IG5lZWQgdGhpcyBjcmFwXG4gICAgICAgICAgdmFyIHRyaWVzID0gMFxuICAgICAgICAgIGNsZWFySW50ZXJ2YWwoIF90aGlzLl90aW1lRml4SW50ZXJ2YWwgKVxuICAgICAgICAgIF90aGlzLl90aW1lRml4SW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRpbWUoKVxuICAgICAgICAgICAgaWYgKHRyaWVzID09PSAzKSB7XG4gICAgICAgICAgICAgIF90aGlzLl9jYW5wbGF5ID0gbnVsbFxuICAgICAgICAgICAgICBjbGVhckludGVydmFsKF90aGlzLl90aW1lRml4SW50ZXJ2YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMubm9kZS5kdXJhdGlvbiAhPT0gMSkgeyAvL2FuZHJvaWQgc2V0cyBkdXJhdGlvbiB0byAxIGFzIGRlZmF1bHQgaW5zdGVhZCBvZiAwXG4gICAgICAgICAgICAgIHRyaWVzKytcbiAgICAgICAgICAgICAgaWYgKF90aGlzLnBsYXlpbmcpIF90aGlzLm5vZGUucGxheSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgMjAwKVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgaWYgKF90aGlzLnRpbWUudmFsKSB7XG4gICAgICAgICAgICBpZiAoX2lvczcpIHtcbiAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgX3RoaXMudXBkYXRlVGltZSgpIH0sIDApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfdGhpcy51cGRhdGVUaW1lKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX2ZvcmNlVGltZSA9IHRydWUgXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIF9pb3MgJiYgdGhpcy5wbGF5aW5nICl7XG4gICAgICAgICAgICB2YXIgdGltZSA9IF90aGlzLnRpbWUudmFsICogX3RoaXMuZHVyYXRpb24udmFsXG4gICAgICAgICAgICBmdW5jdGlvbiB0aW1ldXBkYXRlKCl7XG4gICAgICAgICAgICAgIGlmKH5+bm9kZS5jdXJyZW50VGltZSA+PSB+fnRpbWUpe1xuICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGUpXG4gICAgICAgICAgICAgICAgaWYoX2lvczcpe1xuICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY2FucGxheXRocm91Z2goKXtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wbGF5KClcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheXRocm91Z2gnLGNhbnBsYXl0aHJvdWdoKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsY2FucGxheXRocm91Z2gpXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBub2RlLnBsYXkoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCB0aW1ldXBkYXRlKVxuICAgICAgICAgICAgbm9kZS5wYXVzZSgpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuX2NhbnBsYXkgPSBudWxsXG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoX2NhbnBsYXksIGNhblBsYXkpXG4gICAgfVxuXG4gICAgdGhpcy5fY2FuUGxheSA9IGNhblBsYXlcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoX2NhbnBsYXksIGNhblBsYXkpXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VGltZSAodmFsKSB7XG4gIGlmICh0aGlzLm5vZGUucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMubm9kZS5jdXJyZW50VGltZSA9IHZhbFxuICAgIGlmIChfaW9zKSB0aGlzLl9jb3JyZWN0VGltZSA9IHZhbFxuICB9IGVsc2Uge1xuICAgIF9jYW5wbGF5TGlzdGVuZXIuY2FsbCh0aGlzKVxuICB9XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSAgXG57IHByb2dyZXNzOiB7XG4gICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgIHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdlbmQnLCAoX3RoaXMuX3ByRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIF90aGlzLmNsZWFyUHJvZ3Jlc3MoKVxuICAgICAgfSkpXG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLHRoaXMuX2NhblBsYXkpXG4gICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kJywgdGhpcy5fcHJFbmQpIC8vbWF5YmUgbm8gcGxheSBhbmQgcGF1c2UhO1xuICAgIH1cbiAgfVxuLCBidWZmZXI6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBidWZmZXJlZCA9IHRoaXMubm9kZSAmJiB0aGlzLm5vZGUuYnVmZmVyZWRcbiAgICBpZiAoYnVmZmVyZWQpIHtcbiAgICAgIHZhciBsID0gYnVmZmVyZWQubGVuZ3RoXG4gICAgICAgICwgcGl2ID0gLTFcbiAgICAgICAgLCB0ID0gdGhpcy5ub2RlLmN1cnJlbnRUaW1lIHx8IDBcbiAgICAgICAgLCBsc1xuICAgICAgICAsIHR0XG4gICAgICAgICwgaSA9IDBcbiAgICAgIFxuICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbHMgPSBidWZmZXJlZC5zdGFydChpKVxuICAgICAgICBpZiAobHMgPiBwaXYgJiYgbHMgPCB0KSB7XG4gICAgICAgICAgcGl2ID0gaVxuICAgICAgICAgIHR0ID0gbHNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGl2ID4gLTEpIHtcbiAgICAgICAgcGl2ID0gYnVmZmVyZWQuZW5kKHBpdilcbiAgICAgICAgcmV0dXJuIHBpdiA8IHQgPyAwIDogcGl2IC8gdGhpcy5kdXJhdGlvbi52YWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwXG4gIH1cbiwgcGxheTogZnVuY3Rpb24odmFsKSB7XG4gICAgaWYodGhpcy5ub2RlICYmIHRoaXMubm9kZS5wYXVzZSkge1xuICAgICAgaWYgKHZhbCkge1xuICAgICAgICB0aGlzLm5vZGUucGxheSgpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5ub2RlLnBhdXNlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiwgdGltZTogXG4gIC8vdGVzdHMgZm9yIGFuZHJvaWQgLCB3aW5waG9uZSwgZmlyZWZveHBob25lIChzZWVraW5nIG9uIHdpbnBob25lIGlzIG5vdCBwb3NzaWJsZSBhbnl3YXlzKVxuICB7IHNldCAgIC8vX2lvcyAgfHwgX2FuZHJvaWQgLy91YS5kZXZpY2UgPT09ICdwaG9uZScgfHwgdWEuZGV2aWNlID09PSAndGFibGV0J1xuICAgICAgLy8gcG9zdHBvbmUoc2V0VGltZSlcbiAgICA6IHNldFRpbWVcbiAgLCBnZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHRpbWUgPSB0aGlzLm5vZGUgJiYgdGhpcy5ub2RlLmN1cnJlbnRUaW1lXG4gICAgICBpZiAodGhpcy5fY29ycmVjdFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvcnJlY3RUaW1lID4gdGltZSAtIDIgJiYgdGhpcy5fY29ycmVjdFRpbWUgPCB0aW1lICsgMikgeyAvL3x8IHRoaXMuY250XG4gICAgICAgICAgdGltZSA9IHRoaXMuX2NvcnJlY3RUaW1lXG4gICAgICAgICAgaWYgKCF0aGlzLmNudCkge1xuICAgICAgICAgICAgdGhpcy5jbnQgPSAzXG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jbnQgPCAyKSB7XG4gICAgICAgICAgICB0aGlzLl9jb3JyZWN0VGltZSA9IGZhbHNlXG4gICAgICAgICAgICB0aGlzLl9jbnQgPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9jb3JyZWN0VGltZSs9MC41IC8vc2hvdWxkIGJlIGludGVydmFsIG9mIHByb2dyZXNzIHVwZGF0ZXNcbiAgICAgICAgICAgIHRoaXMuX2NudC0tXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpbWUgPSB0aGlzLl9jb3JyZWN0VGltZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGltZSAvIHRoaXMuZHVyYXRpb24udmFsIHx8IHZhbC52YWxcbiAgICB9XG4gIH1cbiwgZHVyYXRpb246IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlXG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5yZWFkeVN0YXRlID8gbm9kZS5kdXJhdGlvbiA6IHZhbCAmJiB2YWwudmFsXG4gIH1cbiwgYXV0b3BsYXk6IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmKHRoaXMubm9kZSkgdGhpcy5ub2RlLmF1dG9wbGF5ID0gdmFsLnZhbFxuICB9XG4sIGxvb3A6IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmKHRoaXMubm9kZSkgdGhpcy5ub2RlLmxvb3AgPSB2YWwudmFsXG4gIH1cbiwgdm9sdW1lOiBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgdm9sdW1lID0gdmFsLnZhbFxuICAgIGlmKHRoaXMubm9kZSAmJiAhaXNOYU4odm9sdW1lKSkgdGhpcy5ub2RlLnZvbHVtZSA9IHZvbHVtZVxuICB9XG5cbiwgXCJuZXdcIjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hZGRFdmVudCgnZG93bicsZnVuY3Rpb24oZSl7IGUucHJldmVudERlZmF1bHQoKSB9KVxuICAgIF9jYW5wbGF5TGlzdGVuZXIuY2FsbCh0aGlzKVxuICAgIGlmICh0aGlzLnZvbHVtZSkgdGhpcy52b2x1bWUudXBkYXRlKHRoaXMpXG4gIH1cbiwgZXZlbnRzOiB7XG4gICAgcGF1c2U6ZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICBpZihfaW9zICYmIF90aGlzLm5vZGUpIHsgXG4gICAgICAgX3RoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgIGlmKCFfdGhpcy5pZ25vcmVldmVudHMpIF90aGlzLnBhdXNlKCkgICAgIFxuICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuICAsIHByb2dyZXNzOiB2aWRlby5wcm9ncmVzc1xuICAsIHJlYWR5OiBjcmVhdGVMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnKVxuICAsIGNhbnBsYXk6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgaWYoX3RoaXMubm9kZSkgX3RoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKF9jYW5wbGF5LCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmKF90aGlzLm5vZGUgJiYgX3RoaXMubm9kZS5yZWFkeVN0YXRlPT09NCkge1xuICAgICAgICAgIF90aGlzLl9zdGFsbGVkID0gZmFsc2VcbiAgICAgICAgICB2YWwuX3ZhbC5jYWxsKF90aGlzLGUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAsIHN0YWxsZWQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgICAsIG5vZGUgPSB0aGlzLm5vZGVcbiAgICAgICAgLCBsaXN0ZW4gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdmFyIHRpbWUgPSBfdGhpcy5nZXRUaW1lKClcbiAgICAgICAgICBpZighKF90aGlzLmdldEJ1ZmZlcih0aW1lKS10aW1lID4gMC4wNSkpIHtcbiAgICAgICAgICAgIF90aGlzLl9zdGFsbGVkID0gdHJ1ZVxuICAgICAgICAgICAgdmFsLl92YWwuY2FsbChfdGhpcyxlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgaWYobm9kZSl7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignc3RhbGxlZCcsIGxpc3RlbiApXG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignd2FpdGluZycsIGxpc3RlbiApXG4gICAgICB9XG4gICAgfVxuICAsIHBsYXk6IFxuICAgIHsgcGxheTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50cy5wbGF5KSB0aGlzLmV2ZW50cy5wbGF5Ll92YWwuY2FsbCh0aGlzKVxuICAgICAgfVxuICAgICwgc2V0OiBmYWxzZVxuICAgIH1cbiAgLCBlbmQ6IGNyZWF0ZUxpc3RlbmVyKCdlbmRlZCcpXG4gIH1cbiwgc3JjOiBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgc3JjID0gdGhpcy5ub2RlLnNyY1xuICAgIGlmIChzcmMgIT09IHZhbCB8fCB2YWwgfHwgIXZhbCAmJiBzcmMpIHRoaXMubm9kZS5zcmMgPSB2YWwudmFsXG4gIH1cbn1cblxuaWYgKCF2aWRlby5wbGF5ZXIpIHZpZGVvLnBsYXllciA9IG1vZHVsZS5leHBvcnRzIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4uLycpXG4gIC5pbmplY3RcbiAgKCByZXF1aXJlKCcuLi9wcm9wZXJ0aWVzJylcbiAgKVxuXG4gICwgZXZlbnRzID0gcmVxdWlyZSgnLi4vLi4vZXZlbnRzJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG4gICwgcG9zdHBvbmUgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG4gICwgYmFzZSA9IG5ldyBlbGVtZW50KHtcbiAgICAgIG5vZGU6ICd2aWRlbydcbiAgfSlcbiAgXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBiYXNlLkNsYXNzXG52YXIgdmlkZW8gPSBleHBvcnRzXG5leHBvcnRzLmJhc2UgPSBiYXNlXG5cbmJhc2Uuc2V0U2V0dGluZyhcbnsgbmFtZTogJ192aWRlb1NldHRpbmdzJ1xuLCBuZXc6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBsYXllci5uZXcpIHRoaXMucGxheWVyLm5ldy5jYWxsKHRoaXMpXG4gIH1cbiwgcmVtb3ZlOmZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBsYXllci5yZW1vdmUpIHRoaXMucGxheWVyLnJlbW92ZS5jYWxsKHRoaXMpXG4gIH1cbiwgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgICBpZiAodGhpcy5wbGF5ZXIucmVuZGVyKSB0aGlzLnBsYXllci5yZW5kZXIuY2FsbCh0aGlzKVxuICB9XG59KVxuLy9wcm94eSBhZGRlbiAtLT4gc2hvdWxkIGJlIGFuIGV4dGVuc2lvbiBvbiBzcmNcbmJhc2Uubm9kZS5zZXRBdHRyaWJ1dGUoJ3dlYmtpdC1wbGF5c2lubGluZScsICcnKVxuXG4vL2Nsb3VkIHNob3J0ZW4gdGhlc2UgMyBmdW5jdGlvbnNcbmZ1bmN0aW9uIF92aWRFdmVudHMgKHZhbCkge1xuXG4gIHRoaXMuX3JlYWR5Rm9yRXZlbnRzID0gdHJ1ZVxuXG4vLyAgIGNvbnNvbGUubG9nKCdcXG5cXG5cXG5cXG5cXG5uXFxuXFxuXFxuU0VUIFZJREVWRU5UUycpXG5cbiAgdmFyIHQgPSB0aGlzXG4gICAgLCBlID0gKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikuZXZlbnRzXG4gIHZhbC5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoZVtpXSAmJiBlW2ldLnNldCAhPT0gZmFsc2UpIChlW2ldLnNldCB8fCBlW2ldKS5jYWxsKHQsIHRoaXMsIGkpXG4gIH0pXG4gIHJldHVybiBlXG59XG5cbmZ1bmN0aW9uIF9yZW1vdmVWaWRFdmVudHMgKHZhbCkge1xuICB2YXIgdCA9IHRoaXNcbiAgICAsIGUgPSAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5ldmVudHNcblxuICB2YWwuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgaWYgKGVbaV0gJiYgZVtpXS5yZW1vdmUpIGVbaV0ucmVtb3ZlLmNhbGwodCwgdGhpcywgaSlcbiAgfSlcbn1cblxuZnVuY3Rpb24gX3BsYXlIb29rIChwYXJhbSkge1xuICB2YXIgdmFsID0gdGhpcy5ldmVudHNcbiAgaWYgKHZhbCkge1xuICAgIHZhciB0ID0gdGhpc1xuICAgICAgLCBlID0gKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikuZXZlbnRzXG4gICAgdmFsLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgaWYgKGVbaV0gJiYgZVtpXS5wbGF5KSBlW2ldLnBsYXkuY2FsbCh0LCB0aGlzLCBpLCBwYXJhbSlcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIF9wcm9ncmVzcyh2YWwpIHtcblxuICAvLyBjb25zb2xlLmVycm9yKCdTRVQgcHJvZ3Jlc3MnLHRoaXMuX3Byb2dyZXNzKVxuXG4gIGlmICghdGhpcy5fcHJvZ3Jlc3MpIHtcblxuICAgICAgLy8gY29uc29sZS5lcnJvcignU0VUIHByb2dyZXNzIGZvciBSRUFMJyx0aGlzLl9wcm9ncmVzcylcblxuICAgIC8vbWF5YmUgZG8gdGhpcyB3aXRoIHJlcXVlc3RBbmltYXRpb25GcmFtZSAtLSBkYW5nZXIgbGllcyBpbiBpbmNvc2lzdGVuY3kgd2l0aCB0aW1pbmdcbiAgICB2YXIgcGFyYW1zID0gdmFsXG4gICAgICAsIGludGVydmFsID0gcGFyYW1zLmludGVydmFsICYmIHBhcmFtcy5pbnRlcnZhbC52YWwgfHwgNTAwIFxuICAgICAgLCBmbiA9IHBhcmFtcy5fdmFsXG4gICAgICAsIHQgPSB0aGlzXG4gICAgICAsIHByID0gKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikucHJvZ3Jlc3NcblxuICAgIGlmIChwciAmJiBwci5zZXQpIHByLnNldC5jYWxsKHQpXG5cbiAgICB0Ll9wcm9ncmVzcyA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnYmVmb3JlIHByb2dyZXNzIGNhbGwhJyx0LnNyYy52YWwpXG4gICAgICAvLyBpZih0LnBsYXlpbmcmJiF0Ll9fcGF1c2VkKSB7XG4gICAgICAvLyAgIC8vIHQucGxheSgpXG4gICAgICAvLyAgIC8vIG5vIHNyYyFcbiAgICAgIC8vIH1cblxuICAgICAgdmFyIHAgPSBOdW1iZXIodC5nZXRUaW1lKCkpXG4gICAgICAgICwgYiA9IHQuZ2V0QnVmZmVyKHApXG4gICAgICAgICwgZCA9IE51bWJlcih0LmR1cmF0aW9uLnZhbClcblxuICAgICAgaWYoZD09PTEpIGQ9MCAvL2FuZHJvaWQgZml4IC0tIG1heWJlIHJlbW92ZVxuXG4gICAgICBpZiAocCA+PSAxICYmIGQpIHtcbiAgICAgICAgdC5wYXVzZSgpXG4gICAgICAgIHQucGxheWluZyA9IGZhbHNlIC8vc2hvdWxkIHRoaXMgYmUgcmVtb3ZlZCBhbiBnbyB0byBlbmQ/IFxuICAgICAgICAvL2NhbGwgcGF1c2UgYW5kIHNldCB0aW1lIGluIGhlcmU/XG4gICAgICAgIHQuY2xlYXJQcm9ncmVzcygpXG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmKHQuX3N0YWxsZWQgJiYgZCkgeyAvL2p1c3QgdG8gbWFrZSBzdXJlIGJ1ZmZlcmluZyBhbHdheXMgZGlzc2FwYWVycyAgICBcbiAgICAgICAgICBpZihiPjAuODUgfHwgKHQuX19scCAmJiB0LmV2ZW50cy5jYW5wbGF5ICYmIChwID4gdC5fX2xwKygxL2QpKSkpIHsgLy9pbiBzZWNvbmRzXG4gICAgICAgICAgICB0Ll9zdGFsbGVkID0gZmFsc2VcbiAgICAgICAgICAgIHQuZXZlbnRzLmNhbnBsYXkuX3ZhbC5jYWxsKHQpXG4gICAgICAgICAgICB0Ll9fbHAgPSBudWxsXG4gICAgICAgICAgfSBlbHNlIGlmKCAoIXQuX19scCkgJiYgcD4tMSkge1xuICAgICAgICAgICAgdC5fX2xwID0gcFxuICAgICAgICAgIH0gXG4gICAgICAgIH1cblxuICAgICAgICBpZighdC5pZ25vcmVldmVudHMpIGZuLmNhbGwodCwgcCwgYilcbiAgICAgIH1cbiAgICB9LCBpbnRlcnZhbClcbiAgfVxufVxuXG50aGlzLl9wcm9ncmVzcyA9IF9wcm9ncmVzc1xuXG5leHBvcnRzLnByb2dyZXNzID0gXG57IHBsYXk6IGZ1bmN0aW9uKGksIHAsIHBhKSB7XG4gICAgaWYgKHBhKSB7XG4gICAgICBfcHJvZ3Jlc3MuY2FsbCh0aGlzLCB0aGlzLmV2ZW50cy5wcm9ncmVzcylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclByb2dyZXNzKClcbiAgICB9XG4gIH1cbiwgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAodGhpcy5wbGF5aW5nKSBfcHJvZ3Jlc3MuY2FsbCh0aGlzLCB2YWwpXG4gIH1cbiwgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsZWFyUHJvZ3Jlc3MoKVxuICB9XG59XG5cbnV0aWwuZGVmaW5lKGV4cG9ydHNcbiwgJ3Jlc3VtZVBsYXknLCBwb3N0cG9uZShmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLm5vZGUpIHtcbiAgICAgIGlmKHRoaXMuJHBsYXlpbmcudmFsPT09dHJ1ZSkge1xuICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgfVxuICAgICAgdGhpcy5pc1NlZWtpbmcgPSBudWxsXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdSRVNVTUUhJylcbiAgICB9XG4gIH0sMTAwMSlcbiwgJ3NldEV2ZW50cycsIGZ1bmN0aW9uKCkge1xuICAgIF92aWRFdmVudHMuY2FsbCh0aGlzLCB0aGlzLmV2ZW50cylcbiAgfVxuLCAncGxheScsIGZ1bmN0aW9uKGNsZWFyLCBpZ25vcmUpIHtcblxuICAgIGlmIChjbGVhcikgZGVsZXRlIHRoaXMuaWdub3JlZXZlbnRzXG4gICAgaWYgKCFpZ25vcmUgJiYgIXRoaXMuaWdub3JlZXZlbnRzICYmIHRoaXMucGxheWluZyAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnBsYXlpbmcgPSB0cnVlXG4gICAgICAgIF9wbGF5SG9vay5jYWxsKHRoaXMsIHRydWUpXG4gICAgfSBlbHNlIGlmKHRoaXMuX19wYXVzZWQgJiYgdGhpcy5ldmVudHMucHJvZ3Jlc3MpIHtcbiAgICAgIHRoaXMucGxheWluZyA9IHRydWVcbiAgICAgIF9wcm9ncmVzcy5jYWxsKHRoaXMsdGhpcy5ldmVudHMucHJvZ3Jlc3MpXG4gICAgfVxuICAgIHRoaXMuX19wYXVzZWQgPSBudWxsXG4gICAgOyh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLnBsYXkuY2FsbCh0aGlzLCB0cnVlKVxuICB9XG4sICdwYXVzZScsIGZ1bmN0aW9uKGlnbm9yZSkge1xuXG4gICAgaWYoaWdub3JlKSB0aGlzLmlnbm9yZWV2ZW50cyA9IHRydWVcblxuICAgIGlmICghdGhpcy5pZ25vcmVldmVudHMgJiYgdGhpcy5wbGF5aW5nICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5wbGF5aW5nID0gZmFsc2VcbiAgICAgIF9wbGF5SG9vay5jYWxsKHRoaXMsIGZhbHNlKVxuICAgICAgaWYodGhpcy5ldmVudHMucGF1c2UpIHtcbiAgICAgICAgdGhpcy5ldmVudHMucGF1c2UuX3ZhbC5jYWxsKHRoaXMpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2xlYXJQcm9ncmVzcygpXG4gICAgfVxuXG4gICAgdGhpcy5fX3BhdXNlZCA9IHRydWVcbiAgICA7KHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikucGxheS5jYWxsKHRoaXMsIGZhbHNlKVxuICB9XG4sICd0b2dnbGUnLCBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAodGhpcy5wbGF5aW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wbGF5KClcbiAgICB9XG4gIH1cbiwgJ3VwZGF0ZVRpbWUnLCBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9maXJzdFQgPSBmYWxzZVxuICAgIGV4cG9ydHMuc2V0VGltZS5jYWxsKHRoaXMsIHRoaXMudGltZSlcbiAgfVxuLCAnZ2V0VGltZScsIGZ1bmN0aW9uKCkge1xuXG4gICAgLy8gY29uc29sZS5lcnJvcih0aGlzLmlzU2Vla2luZylcblxuICAgIHJldHVybiB0aGlzLmlzU2Vla2luZyBcbiAgICAgIHx8ICh0aGlzLnJlbmRlcmVkICYmIHRoaXMucGxheWVyIFxuICAgICAgfHwgdmlkZW8ucGxheWVyKS50aW1lLmdldC5jYWxsKHRoaXMsIHRoaXMudGltZSkgXG4gICAgICB8fCAwXG4gIH1cbiwgJ2dldEJ1ZmZlcicsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiAodGhpcy5yZW5kZXJlZCAmJiB0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLmJ1ZmZlci5jYWxsKHRoaXMsIHZhbCB8fCAwKVxuICB9XG4sICdjbGVhclByb2dyZXNzJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3Byb2dyZXNzKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIHRoYXQgcHJvZ3Jlc3MnKVxuICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wcm9ncmVzcylcbiAgICAgIHRoaXMuX3Byb2dyZXNzID0gbnVsbFxuICAgICAgdmFyIHByID0gKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikucHJvZ3Jlc3NcbiAgICAgIGlmIChwciAmJiBwci5yZW1vdmUpIHByLnJlbW92ZS5jYWxsKHRoaXMpXG4gICAgfVxuICB9XG4pXG5cbmJhc2UuZXh0ZW5kKFxueyBuYW1lOiAncGxheWVyJ1xuLCB0eXBlOiBmYWxzZVxuLCBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHV0aWwuc2V0c3RvcmUuY2FsbCh0aGlzKVxuICAgIHRoaXMuX18ucGxheWVyID0gdmFsXG4gICAgaWYgKHZhbC5lbGVtZW50KSB0aGlzLm5vZGUgPSB2YWwuZWxlbWVudFxuICAgIGlmICh0aGlzLl9jbGFzcykgdGhpcy5fY2xhc3MucHJvdG90eXBlLl8ucGxheWVyID0gdmFsXG4gIH1cbiwgZ2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICByZXR1cm4gdXRpbC5nZXRTdG9yZS5jYWxsKHRoaXMsICdwbGF5ZXInKSB8fCB2aWRlby5wbGF5ZXIgfHwge31cbiAgfVxufVxuLCBcbnsgbmFtZTogJ2R1cmF0aW9uJ1xuLCBzZXQ6IGZ1bmN0aW9uKHZhbCkge31cbiwgZ2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICB2YWwuX292ZXJ3cml0ZSA9ICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLmR1cmF0aW9uLmNhbGwodGhpcywgdmFsKVxuICAgIHJldHVybiB2YWxcbiAgfVxufVxuLFxue1xuICBuYW1lOickcGxheWluZydcbiwgc2V0OmZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgLy9zdGFtcCBpbmZvXG4gICAgLy8gaWYoIHRoaXMucmVuZGVyZWQgKSAvL1RPRE8gYXZvaWQgaGVhdnkgY2hlY2tcbiAgICAvLyB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCchISEhISEhISEhIXNldCAkcGxheWluZycsIHZhbC52YWwpXG4gICAgICBpZiggdmFsLnZhbCApXG4gICAgICB7XG4gICAgICAgIHRoaXMucGxheSgpXG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgfVxuICAgIC8vIH1cbiAgfVxufVxuLCBcbnsgbmFtZTogJ3RpbWUnXG4sIHNldDogXG4gIChleHBvcnRzLnNldFRpbWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICBpZiAoIXRoaXMuX2lnbm9yZSkge1xuXG5cbiAgICAgIHZhbC5fb3ZlcndyaXRlID0gbnVsbFxuICAgIFxuICAgICAgdmFyIHYgPSB2YWwudmFsXG4gICAgICAgICwgaSA9IGZhbHNlXG5cbiAgICAgIGlmICh2ICE9PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maXJzdFQgfHwgdGhpcy5fZm9yY2VUaW1lID09PSB0cnVlKSB7IFxuICAgICAgICAgIHYgPSBNYXRoLmFicyh2KVxuICAgICAgICAgIGkgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuX2ZpcnN0VCA9IHRydWVcbiAgICAgICAgICB0aGlzLl9mb3JjZVRpbWUgPSBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodiA+PSAwKSB7XG5cblxuXG4gICAgICAgICAgaWYodGhpcy5kdXJhdGlvbil7XG4gICAgICAgICAgICB0aGlzLmlzU2Vla2luZyA9IHZcblxuICAgICAgICAgICAgLy8gaWYocGxheWluZykgdGhpcy5wYXVzZSgpXG5cbiAgICAgICAgICAgIGlmKHRoaXMuX19scCkgdGhpcy5fX2xwID0gbnVsbFxuICAgICAgICAgICAgOyh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLnRpbWUuc2V0LmNhbGwodGhpcywgdiAqIHRoaXMuZHVyYXRpb24udmFsKVxuICAgICAgICAgICAgaWYodGhpcy5ldmVudHMuc2Vla2luZyAmJiAhaSkgIHRoaXMuZXZlbnRzLnNlZWtpbmcuX3ZhbC5jYWxsKHRoaXMsdilcblxuICAgICAgICAgICAgdGhpcy5yZXN1bWVQbGF5KClcblxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignY2FuXFwndCBzZXQgdGltZSwgbm8gZHVyYXRpb24gZGVmaW5lZCEnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIFxuXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfSlcbn1cbiwgXG57IGF1dG9wbGF5OiBmdW5jdGlvbih2YWwpIHtcbiAgICAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5hdXRvcGxheS5jYWxsKHRoaXMsIHZhbClcbiAgfVxuLCBsb29wOiBmdW5jdGlvbih2YWwpIHtcbiAgICAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5sb29wLmNhbGwodGhpcywgdmFsKVxuICB9XG4sIHZvbHVtZTogZnVuY3Rpb24odmFsKSB7XG4gICAgKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikudm9sdW1lLmNhbGwodGhpcywgdmFsKVxuICB9XG4sIHNyYzogZnVuY3Rpb24odmFsKSB7XG4gICAgaWYodmFsLnZhbCE9PXRoaXMuX19fU3JjKSB7XG4gICAgICB0aGlzLl9fX1NyYyA9IHZhbC52YWxcbiAgICAgIGlmKHRoaXMuZXZlbnRzLnNyYykgIHRoaXMuZXZlbnRzLnNyYy5fdmFsLmNhbGwodGhpcyx2YWwpXG4gICAgICA7KHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikuc3JjLmNhbGwodGhpcywgdmFsKVxuICAgICAgLy8gY29uc29sZS5lcnJvcignISEhISEhISEhISFzZXQgc3JjJylcblxuICAgICAgaWYodGhpcy4kcGxheWluZy52YWwgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgIH1cblxuICAgIH1cbiAgfVxufVxuLCBcbnsgbmFtZTogJ2V2ZW50cydcbiwgXCJuZXdcIjogZnVuY3Rpb24oKSB7XG4gICAgLy9kZXplIGZ1bmN0aWUga3VubmVuIGluc3RlbGxlblxuICAgIGlmKCAgKHRoaXMucGxheWVyICYmIHRoaXMucGxheWVyLnNldEV2ZW50cyAhPT0gZmFsc2UpKSB7XG4gICAgICBfdmlkRXZlbnRzLmNhbGwodGhpcywgdGhpcy5ldmVudHMpXG4gICAgfVxuICB9XG4sIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5yYWZJZClcbiAgICB7IFxuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmFmSWQpXG4gICAgICB0aGlzLnJhZklkID0gbnVsbFxuICAgIH1cbiAgICBfcmVtb3ZlVmlkRXZlbnRzLmNhbGwodGhpcywgdGhpcy5ldmVudHMpXG4gIH1cbiwgc2V0OiBmdW5jdGlvbih2YWwpIHtcbi8vICAgY29uc29sZS5sb2coJ0VWRU5UUyEnKVxuICAgIFxuICAgIHZhciBhID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgIFxuICAgICAgYVs1XSA9IHRoaXMuX3JlYWR5Rm9yRXZlbnRzIFxuICAgICAgICAgICA/IF92aWRFdmVudHMuY2FsbCh0aGlzLCB2YWwpIFxuICAgICAgICAgICA6ICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLmV2ZW50cyBcblxuICAgICAgaWYoIWFbNV0uc2Vla2luZykgYVs1XS5zZWVraW5nID0ge3NldDpmYWxzZX1cbiAgICAgIGlmKCFhWzVdLnNyYykgYVs1XS5zcmMgPSB7c2V0OmZhbHNlfVxuICAgIFxuICAgIGV2ZW50cy5fc2V0LmFwcGx5KHRoaXMsIGEpXG4gIH1cbn0pXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG5leHBvcnRzLnRpbWUgPSBmdW5jdGlvbih0aW1lLCBkZWNpbWFscykge1xuICB2YXIgaHJzID0gfn4gKHRpbWUgLyAzNjAwKSxcbiAgICBtaW5zID0gfn4gKCh0aW1lICUgMzYwMCkgLyA2MCksXG4gICAgc2VjcyA9IGRlY2ltYWxzID8gKHRpbWUgJSA2MCkudG9GaXhlZChkZWNpbWFscykgOiB+fih0aW1lICUgNjApO1xuICByZXQgPSBcIlwiO1xuICBpZiAoaHJzID4gMCkgcmV0ICs9IFwiXCIgKyBocnMgKyBcIjpcIiArIChtaW5zIDwgMTAgPyBcIjBcIiA6IFwiXCIpO1xuICByZXQgKz0gXCJcIiArIG1pbnMgKyBcIjpcIiArIChzZWNzIDwgMTAgPyBcIjBcIiA6IFwiXCIpO1xuICByZXQgKz0gXCJcIiArIHNlY3M7XG4gIHJldHVybiByZXQgfHwgMDtcbn07IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xudmFyIGV2ZW50cyA9IHJlcXVpcmUoJy4vJylcbiAgLCBvcGVyYXRvcnMgPSByZXF1aXJlKCcuLi8uLi92YWx1ZS9vcGVyYXRvcnMnKVxuICAsIGRvYyA9IGV2ZW50cy5kb2N1bWVudFxuXG5tb2R1bGUuZXhwb3J0cyA9IGV2ZW50c1xuXG5vcGVyYXRvcnMuX2UgPSBmdW5jdGlvbih2YWwsIG9wZXJhdG9yKSB7XG4gIHJldHVybiB2YWwgKyBvcGVyYXRvclxufVxuXG5vcGVyYXRvcnMuX2VzdWIgPSBmdW5jdGlvbih2YWwsIG9wZXJhdG9yKSB7XG4gIHJldHVybiB2YWwgLSBvcGVyYXRvclxufVxuXG5vcGVyYXRvcnMuX2Uub3JkZXIgPSAzXG4gIFxuZnVuY3Rpb24gY2hvb3NlTW92ZSAodmFsLCBtZXRob2QpIHtcbiAgcmV0dXJuIHZhbC5tb3ZlICYmIHZhbC5tb3ZlLl92YWwgXG4gICAgfHwgIW1ldGhvZC5fX3QgJiYgbWV0aG9kICE9PSB0cnVlICYmIG1ldGhvZCBcbiAgICB8fCBtZXRob2QuX3ZhbDtcbn1cblxuZnVuY3Rpb24gZHJhZyAoZSwgbWV0aG9kLCB2YWwpIHtcbiAgdmFyIHQgPSB2YWwuYmluZCA/IHZhbC5iaW5kLl92YWwgOiB0aGlzXG4gICAgLCBtb3ZlID0gY2hvb3NlTW92ZSh2YWwsIG1ldGhvZClcbiAgICAsIGlkID0gJ2RyYWcnXG4gIGUucHJldmVudERlZmF1bHQoKVxuICBpZiAobW92ZSkgZG9jLmFkZEV2ZW50KCdtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgIG1vdmUuY2FsbCh0LCBlLCB2YWwpXG4gIH0sIGlkKVxuXG4gIGlmICh2YWwuZG93bikgdmFsLmRvd24uX3ZhbC5jYWxsKHQsIGUsIHZhbClcbiAgXG4gIGRvYy5hZGRFdmVudCgndXAnLCBmdW5jdGlvbihlKSB7XG4gICAgaWYgKHZhbC51cCkgdmFsLnVwLl92YWwuY2FsbCh0LCBlLCB2YWwpXG4gICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLCBpZClcbiAgfSwgaWQpXG59XG5cbmZ1bmN0aW9uIGFjdGl2ZSAoZSwgbWV0aG9kLCB2YWwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCBpZCA9ICdhY3RpdmUnXG4gICAgLCB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5jc3MgPSB7YWRkQ2xhc3M6dmFsLl92YWx9XG4gICAgICAgIHRpbWVyID0gbnVsbFxuICAgICAgfSw1MClcblxuICBpZihleHBvcnRzLl9kZWFjdGl2YXRlKSBleHBvcnRzLl9kZWFjdGl2YXRlKClcblxuICBleHBvcnRzLl9kZWFjdGl2YXRlID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aW1lcikgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSxpZClcbiAgICBleHBvcnRzLl9kZWFjdGl2YXRlID0gbnVsbFxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgIGlmKCFzZWxmKSByZXR1cm5cbiAgICAgIGlmKCFzZWxmLl9zdGF5QWN0aXZlKSBzZWxmLmNzcyA9IHtyZW1vdmVDbGFzczp2YWwuX3ZhbH1cbiAgICAgIGVsc2Ugc2VsZi5jc3MgPSB7YWRkQ2xhc3M6dmFsLl92YWx9XG4gICAgfSlcbiAgfVxuXG4gIGRvYy5hZGRFdmVudCgnbW92ZScsZXhwb3J0cy5fZGVhY3RpdmF0ZSxpZClcbiAgZG9jLmFkZEV2ZW50KCd1cCcsZXhwb3J0cy5fZGVhY3RpdmF0ZSxpZClcbn1cblxuZnVuY3Rpb24gc2hhbGxvd1JhdyAodm9iaikge1xuICB2YXIgb2JqID0ge31cbiAgICAsIGtleXMgPSB2b2JqLmtleXNcbiAgICAsIGtleVxuICAgICwgaSA9IGtleXMubGVuZ3RoIC0gMVxuICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrZXlzW2ldXG4gICAgb2JqW2tleV0gPSB2b2JqW2tleV1cbiAgfVxuICByZXR1cm4gb2JqXG59XG5cbmZ1bmN0aW9uIGluaXRHcmFiICh0LCBlLCB2YWwsIG5hbWUpIHtcbiAgaWYgKCF0W25hbWVdIHx8ICF0W25hbWVdLl9lKSB0W25hbWVdID0geyBfZTogMCB9XG4gIGlmICh2YWxbbmFtZV0uX3ZhbCAhPT0gdHJ1ZSkgdFtuYW1lXS5zZXQoJ19lJywgc2hhbGxvd1Jhdyh2YWxbbmFtZV0pKVxuICByZXR1cm4gZVtuYW1lXSAtICh0W25hbWVdLl9lLnZhbClcbn1cblxuZnVuY3Rpb24gZ3JhYiAoZSwgbWV0aG9kLCB2YWwsIG5lc3RlZCkge1xuICB2YXIgdCA9IHZhbC5iaW5kICYmICFuZXN0ZWQgPyB2YWwuYmluZC52YWwgOiB0aGlzXG4gICAgLCBpZCA9ICggdmFsLnkgXG4gICAgICA/ICd5JyBcbiAgICAgIDogdmFsLnggXG4gICAgICAgID8gJ3gnIFxuICAgICAgICA6ICd4eScpIFxuICAgICAgICArICdHcmFiJyBcbiAgICAgICAgKyAobmVzdGVkIHx8ICcnKVxuICBpZiAodCkge1xuICAgIGlmICh0Ll9ub2RlKSB7XG4gICAgICB2YXIgbW92ZSA9IGNob29zZU1vdmUodmFsLCBtZXRob2QpXG4gICAgICAgICwgc3RhcnRYID0gZS54XG4gICAgICAgICwgc3RhcnRZID0gZS55XG4gICAgICAgICwgcmVhZHlcbiAgICAgICAgLCBjWFxuICAgICAgICAsIGNZXG4gICAgICAgICwgb2xkWFxuICAgICAgICAsIG9sZFlcbiAgICAgICAgLCBuZXdYID0gc3RhcnRYXG4gICAgICAgICwgbmV3WSA9IHN0YXJ0WVxuICAgICAgICAsIHBhc3NcbiAgICAgICAgLCB1cEZuID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdC54Ll9wID0gZmFsc2VcbiAgICAgICAgICAgIHQueS5fcCA9IGZhbHNlXG4gICAgICAgICAgICBpZiAodmFsLnVwICYmIHBhc3MpIHtcbiAgICAgICAgICAgICAgdmFsLnVwLl92YWwuY2FsbCh0LCBlLCB7XG4gICAgICAgICAgICAgICAgeDogbmV3WCAtIHN0YXJ0WCxcbiAgICAgICAgICAgICAgICB5OiBuZXdZIC0gc3RhcnRZXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHsgeDogbmV3WCAtIG9sZFhcbiAgICAgICAgICAgICAgLCB5OiBuZXdZIC0gb2xkWVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnRzLmNsaWNrLmJsb2NrID0gZmFsc2VcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSwgaWQpXG4gICAgICAgICAgfVxuICAgICAgaWYgKCF2YWwueCAmJiAhdmFsLnkpeyAvL3RoaXMgbmVlZHMgcmV2aXNpb25cbiAgICAgICAgdmFsLnggPSB7X3ZhbDogdHJ1ZX1cbiAgICAgICAgdmFsLnkgPSB7X3ZhbDogdHJ1ZX1cbiAgICAgIH1cbiAgICAgIGlmICh2YWwuZG93bikgdmFsLmRvd24uX3ZhbC5jYWxsKHQsIGUsIHZhbCk7XG4gICAgICBkb2MuYWRkRXZlbnQoJ21vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIG9sZFggPSBuZXdYXG4gICAgICAgIG9sZFkgPSBuZXdZXG4gICAgICAgIG5ld1ggPSBlLnhcbiAgICAgICAgbmV3WSA9IGUueVxuXG4gICAgICAgIGV2ZW50cy5jbGljay5ibG9jayA9IHRydWVcblxuICAgICAgICBpZiAoIXJlYWR5KSB7XG4gICAgICAgICAgcGFzcyA9IHZhbC5wYXNzID8gdmFsLnBhc3MuX3ZhbC5jYWxsKHQsIGUsIHtcbiAgICAgICAgICAgIHg6IG5ld1ggLSBzdGFydFgsXG4gICAgICAgICAgICB5OiBuZXdZIC0gc3RhcnRZXG4gICAgICAgICAgfSkgOiB0cnVlXG4gICAgICAgICAgaWYoIXBhc3MpIHtcbiAgICAgICAgICAgIHVwRm4oZSlcbiAgICAgICAgICAgIG1vdmUgPSBmYWxzZVxuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLCBpZClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICBpZiAodmFsLngpIHtcbiAgICAgICAgICAgICAgY1ggPSBpbml0R3JhYih0LCBlLCB2YWwsICd4JylcbiAgICAgICAgICAgICAgdC54Ll9wID0gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC55KSB7XG4gICAgICAgICAgICAgIGNZID0gaW5pdEdyYWIodCwgZSwgdmFsLCAneScpXG4gICAgICAgICAgICAgIHQueS5fcCA9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwuc3RhcnQpIHZhbC5zdGFydC5fdmFsLmNhbGwodCwgZSwgdmFsKVxuICAgICAgICAgICAgcmVhZHkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCkgLy9mb3IgYW5kcm9pZFxuICAgICAgICAgIGlmIChjWCkgdC54ID0geyBfZTogbmV3WCAtIGNYIH1cbiAgICAgICAgICBpZiAoY1kpIHQueSA9IHsgX2U6IG5ld1kgLSBjWSB9XG4gICAgICAgICAgaWYgKG1vdmUpIG1vdmUuY2FsbCh0LCBlLCB7XG4gICAgICAgICAgICAgIHg6IG5ld1ggLSBzdGFydFgsXG4gICAgICAgICAgICAgIHk6IG5ld1kgLSBzdGFydFlcbiAgICAgICAgICAgIH0sdmFsKSAvL2NoZWNrIGZvciBzcGVlZFxuICAgICAgICB9XG4gICAgICB9LCBpZClcbiAgICAgIGRvYy5hZGRFdmVudCgndXAnLCB1cEZuLCBpZClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IHQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZ3JhYi5jYWxsKHRbaV0sIGUsIG1ldGhvZCwgdmFsLCBpICsgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8vYWRkIHRoZSBldmVudHNcbmV2ZW50cy5kcmFnID0geyB2YWw6IHsgZG93bjogZHJhZyB9IH1cbmV2ZW50cy5ncmFiID0geyB2YWw6IHsgZG93bjogZ3JhYiB9IH1cbmV2ZW50cy5hY3RpdmUgPSB7IHZhbDogeyBkb3duOiBhY3RpdmUgfSB9IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGV2ZW50cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKVxuICAsIGNhc2VzID0gcmVxdWlyZSgnLi4vY2FzZXMnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCB1YSA9IHJlcXVpcmUoJy4uL3VhJylcblxuY2FzZXMuJGhhc1RvdWNoID1cbiggKCAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgKVxuICB8fCB3aW5kb3cuRG9jdW1lbnRUb3VjaFxuICAmJiBkb2N1bWVudCBpbnN0YW5jZW9mIERvY3VtZW50VG91Y2hcbilcbnx8IG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzXG58fCBmYWxzZVxuXG5mdW5jdGlvbiBfYmFzaWMoZSwgbWV0aG9kLCB2YWwpIHtcbiAgZS54ID0gZS5wYWdlWFxuICBlLnkgPSBlLnBhZ2VZXG4gIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbn1cblxudXRpbC5kZWZpbmVcbiggZXZlbnRzXG4sICdfb3V0J1xuLCB7IHZhbHVlOiBbXSB9XG4pXG4vL2NsaWNrb3V0IGNhbm5vdCBiZSB1c2VkIHRvIGNyZWF0ZSBjb21wbGV4IGV2ZW50cyEgaXQncyB0b28gY3VzdG9tIFxuLy90cmllZCB0byBmaXhcblxuZnVuY3Rpb24ga2V5Qm9hcmRFdmVudCggbmFtZSwgZG9tRXZlbnQsIHdyYXBwZXIgKSB7XG5cbiAgdmFyIF9uYW1lID0gJ18nK25hbWVcblxuICB1dGlsLmRlZmluZSggZXZlbnRzLCBfbmFtZSwgeyB2YWx1ZTpbXSB9IClcblxuICB2YXIgZXZlbnQgPSBcbiAge1xuICAgIGNyZWF0ZTogZnVuY3Rpb24oIGZpZWxkLCBmcm9tICkge1xuICAgICAgdmFyIGV4ZWMgPSBmdW5jdGlvbiggZSApIHtcblxuICAgICAgICAvL2RpdCBnYWF0IGhlZWwgc25lbCBmb3V0IGhpZXJvXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdudSBmZiBvb2sgZGUgd3JhcHBlciBjYWxsZW4hJywgZmllbGQsIGZyb20sIGV2ZW50c1tmcm9tXSlcbiAgICAgICAgIGlmKCB0aGlzLnJlbmRlcmVkICkge1xuXG4gICAgICAgICAgaWYoIHdyYXBwZXIgKSB7XG4gICAgICAgICAgICB3cmFwcGVyLmNhbGwodGhpcywgZSwgdGhpcy5ldmVudHNbZnJvbV0uX3ZhbCApXG4gICAgICAgICAgICAvL3RoaXMuZXZlbnRzW2Zyb21dLl92YWwuY2FsbCh0aGlzLCBlKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCBldmVudHNbZnJvbV0gJiYgZXZlbnRzW2Zyb21dLnZhbCkge1xuICAgICAgICAgICAgdmFyIG1ldGhvZCA9IGV2ZW50c1tmcm9tXS52YWxcbiAgICAgICAgICAgIGZvcih2YXIgaSBpbiBldmVudHNbZnJvbV0pIHtcbiAgICAgICAgICAgICAgaWYoIGNhc2VzW2ldKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gZXZlbnRzW2Zyb21dW2ldXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGhvZCA9IG1ldGhvZFtmaWVsZF1cbiAgICAgICAgICAgIGlmKCBtZXRob2QgKSB7XG4gICAgICAgICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHRoaXMuZXZlbnRzW2Zyb21dLl92YWwgKVxuICAgICAgICAgICAgfSBcbiAgICAgICAgICB9IGVsc2UgaWYoIHRoaXMuZXZlbnRzW2Zyb21dICkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZnJvbV0uX3ZhbC5jYWxsKHRoaXMsIGUpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGV2ZW50cy5kb2N1bWVudC5hZGRFdmVudCggZG9tRXZlbnQsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgICBmb3IgKCB2YXIgYXJyID0gZXZlbnRzWyBfbmFtZSBdLCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICAgIGV4ZWMuY2FsbCggYXJyW2ldLCBlIClcbiAgICAgICAgICBcbiAgICAgICAgICBpZiggYXJyW2ldICkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICdkbyBpdCBub3chJywgX25hbWUsIGFyciwgYXJyW2ldLCBlKVxuICAgICAgICAgICAgYXJyW2ldLmVhY2hJbnN0YW5jZSggZXhlYywgJ2V2ZW50cycsIGUgKVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9LCBuYW1lIClcbiAgICB9LFxuICAgIGFkZDogZnVuY3Rpb24oIGlkLCBmaWVsZCApIHtcblxuICAgICAgZmllbGQgPSBfbmFtZVxuXG4gICAgICB0aGlzLnNldFNldHRpbmcoXG4gICAgICB7IG5hbWU6IGZpZWxkXG4gICAgICAsIHJlbW92ZTogZXZlbnRzWyBuYW1lIF0ucmVtb3ZlXG4gICAgICB9KVxuXG4gICAgICBpZiAoICF1dGlsLmNoZWNrQXJyYXkoIGV2ZW50c1sgX25hbWUgXSwgdGhpcyApICkgXG4gICAgICB7XG4gICAgICAgIGV2ZW50c1sgX25hbWUgXS5wdXNoKHRoaXMpXG4gICAgICB9XG5cbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnV1JPTkdXUk9OR1dST05HISEhISEnLCBfbmFtZSwgZXZlbnRzW19uYW1lXSwgZXZlbnRzKVxuICAgICAgLy9zZWxlY3RlZCBtb2V0IG1pc2NoZWluIGFsbGVlbiB2YW51aXQgVmFsdWUgJGZvY3VzZWQgLS0gbmlldCBvcCBlbGsgaXRlbSBvcCBrZXkgdXAuLi4uXG4gICAgICAvL2RvZSBkaXQgc21hcnQgLS0gZm9yIG5vdyB6b3UgYXV0byByZW1vdmUga3VubmVuIGRvZW4gYWxzIGlldHMgZXIgbmlldCBtZWVyIGlzP1xuICAgICAgdmFyIGluZGV4ID0gdXRpbC5jaGVja0FycmF5KCBldmVudHNbIF9uYW1lIF0sIHRoaXMsIHRydWUgKSBcbiAgICAgIGlmKCB+aW5kZXggKSB7XG5cbiAgICAgICAgdmFyIG5vUmVtb3ZlXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3RoaXM6JywgdGhpcyApXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdmcm9tIGJhc2U6JywgdGhpcy5fZnJvbS5iYXNlKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZXZlbnQgbmFtZTonLCBuYW1lKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZXZlbnRzOicsIHRoaXMuZXZlbnRzIClcbiAgICAgICAgaWYodGhpcy5ldmVudHMgJiYgdGhpcy5fZnJvbS5iYXNlLmV2ZW50cykgeyBcbiAgICAgICAgICBub1JlbW92ZSA9IHRoaXMuZXZlbnRzW25hbWVdID09PSB0aGlzLl9mcm9tLmJhc2UuZXZlbnRzW25hbWVdXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2V2ZW50cyBlcXVhbHMgY2xhc3M6Jywgbm9SZW1vdmUgKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ25vIG5pY2UgZXZlbnRzJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoIW5vUmVtb3ZlKSB7XG4gICAgICAgICAgZXZlbnRzWyBfbmFtZSBdLnNwbGljZSggaW5kZXgsIDEgKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUubG9nKG5vUmVtb3ZlLCAnbm9SZW1vdmUgZXZudCwgYXJlIHdlIHN1cmUgLSBmaXggdGhpcyBhc2FwJylcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAvLyB0aGlzLnJlbW92ZVNldHRpbmcoIG5hbWUgKSAtLS0gcmVkbyB0aGlzIGxhdGVyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXZlbnRzWyBuYW1lIF0gPSBldmVudFxuXG59XG5cbmV2ZW50cy4kbWFrZUtleUJvYXJkRXZlbnQgPSBrZXlCb2FyZEV2ZW50XG5cbmtleUJvYXJkRXZlbnQoICdrZXlib2FyZCcsICdrZXl1cCcgKVxua2V5Qm9hcmRFdmVudCggJ2tleWJvYXJkRG93bicsICdrZXlkb3duJyApXG5rZXlCb2FyZEV2ZW50KCAna2V5Ym9hcmREb3duJGRvd24nLCAna2V5ZG93bicgKVxua2V5Qm9hcmRFdmVudCggJ2tleWJvYXJkRG93biRjbGljaycsICdrZXlkb3duJyApXG5cbi8vLS0tLS1kaXQgZmYgZWNodCBnb2VkIGZpeGVuIVxuXG5mdW5jdGlvbiBiYXNpY0Rvd24oZSwgbWV0aG9kLCB2YWwpIHtcbiAgaWYoIGUud2hpY2ghPT0xIHx8IGV2ZW50cy5kb3duLmJsb2NrICkgcmV0dXJuXG4gICBfYmFzaWMuY2FsbCh0aGlzLGUsIG1ldGhvZCwgdmFsKVxufVxuXG5ldmVudHMuZG93biA9XG57ICRoYXNUb3VjaDpcbiAgeyB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlLCBtZXRob2QsIHZhbCkge1xuICAgICAgaWYoZXZlbnRzLmRvd24uYmxvY2spIHJldHVyblxuICAgICAgdmFyIHRhcmdldFRvdWNoZXMgPSBlLnRhcmdldFRvdWNoZXNbMF0gfHwge31cbiAgICAgIGUueCA9IHRhcmdldFRvdWNoZXMucGFnZVhcbiAgICAgIGUueSA9IHRhcmdldFRvdWNoZXMucGFnZVlcbiAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbiAgICB9XG4gIH1cbiwgdmFsOiB7IG1vdXNlZG93bjogYmFzaWNEb3duIH1cbi8vICwgdHY6IFxuLy8gICB7ICAvLyBtb3VzZWRvd246IGJhc2ljRG93biAvL2NvbWJpbmVyZW4gYmlubmVuIGtvcnQgbW9ldCB2b29yIExHXG4vLyAgICAgIGtleWJvYXJkRG93biRkb3duOiBmdW5jdGlvbiggZSwgbWV0aG9kLCB2YWwgKSB7XG4vLyAgICAgICAvL3RoaXMuXyRmb2N1c2VkICYmIFxuLy8gICAgICAgaWYoIHRoaXMuXyRmb2N1c2VkICYmIHV0aWwuY2hlY2tBcnJheSggWyAxMywgMjk0NDMgXSAsIGUua2V5Q29kZSApICE9PSBmYWxzZSApIFxuLy8gICAgICAge1xuLy8gICAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBlLCB2YWwpXG4vLyAgICAgICB9XG5cbi8vICAgICB9XG4vLyAgIH1cbn1cblxuLy9yaWdodC1kb3duXG5ldmVudHMucmRvd24gPVxueyAkaGFzVG91Y2g6XG4gIHsgdG91Y2hzdGFydDogZnVuY3Rpb24gKCkge1xuICAgICAgLy8yIGZpbmdlcnM/XG4gICAgfVxuICB9XG4sIHZhbDpcbiAgeyBtb3VzZWRvd246IGZ1bmN0aW9uIChlLCBtZXRob2QsIHZhbCkge1xuICAgICAgaWYoZS53aGljaD09PTMpIHtcbiAgICAgICAgZG9jdW1lbnQub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgLy8gZS5yZG93biA9IHRydWVcbiAgICAgICAgX2Jhc2ljLmNhbGwodGhpcyxlLG1ldGhvZCx2YWwpXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGRvY3VtZW50Lm9uY29udGV4dG1lbnUgPSBmYWxzZSB9LCAwKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vL21vdmVcbmV2ZW50cy5tb3ZlID0ge1xuICAkaGFzVG91Y2g6XG4gIHsgdG91Y2htb3ZlOiBmdW5jdGlvbiAoZSwgbWV0aG9kLCB2YWwpIHtcbiAgICAgIHZhciB0YXJnZXRUb3VjaGVzID0gZS50YXJnZXRUb3VjaGVzWzBdXG4gICAgICBlLnggPSB0YXJnZXRUb3VjaGVzLnBhZ2VYXG4gICAgICBlLnkgPSB0YXJnZXRUb3VjaGVzLnBhZ2VZXG4gICAgICBtZXRob2QuY2FsbCh0aGlzLCBlLCB2YWwpXG4gICAgICAvLyBkb2N1bWVudC53cml0ZShlLnRhcmdldFRvdWNoZXNbMF0ucGFnZVgpO1xuICAgIH1cbiAgfVxuICAsIHZhbDoge1xuICAgIG1vdXNlbW92ZTogX2Jhc2ljXG4gIH1cbn1cblxuLy91cFxuZXZlbnRzLnVwID0ge1xuICAvL2tleVVwXG4gICRoYXNUb3VjaDoge1xuICAgIHRvdWNoZW5kOiBmdW5jdGlvbihlLCBtZXRob2QsIHZhbCkge1xuICAgICAgdmFyIGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1xuICAgICAgZS54ID0gY3RbMF0ucGFnZVhcbiAgICAgIGUueSA9IGN0WzBdLnBhZ2VZXG4gICAgICBtZXRob2QuY2FsbCh0aGlzLCBlLCB2YWwpXG4gICAgfVxuICB9XG4sIHZhbDoge1xuICAgIG1vdXNldXA6IF9iYXNpY1xuICB9XG59XG5cbi8vY2xpY2tcbmV2ZW50cy5jbGljayA9IHtcbiAgLy8gdHY6IHtcbiAgLy8gICBrZXlib2FyZERvd24kY2xpY2s6IGZ1bmN0aW9uKGUsIG1ldGhvZCwgdmFsICkge1xuXG4gIC8vICAgICBpZiggdGhpcy5fJGZvY3VzZWQgJiYgdXRpbC5jaGVja0FycmF5KCBbIDEzLCAyOTQ0MyBdICwgZS5rZXlDb2RlICkgIT09IGZhbHNlICkge1xuICAvLyAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBlLCB2YWwpXG4gIC8vICAgICB9XG5cbiAgLy8gICB9XG4gIC8vIH0sXG4gIHZhbDoge1xuICAgIGRvd246IGZ1bmN0aW9uKGUsIG1ldGhvZCwgdmFsKSB7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdDTElDSyBJVCEnKVxuXG4gICAgICB2YXIgdCA9IHRoaXNcbiAgICAgICAgLCBuYW1lID0gJ2NsaWNrJ1xuICAgICAgaWYoIWV2ZW50cy5jbGljay5ibG9jayl7XG4gICAgICAgIHQuYWRkRXZlbnQoJ3VwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgIHQucmVtb3ZlRXZlbnQoJ3VwJywgbmFtZSlcbiAgICAgICAgICB2YXIgbXMgPSBldmVudHMuX21heWJlc2Nyb2xsXG4gICAgICAgICAgaWYobXMpe1xuICAgICAgICAgICAgaWYobXMubGVuZ3RoKSBldmVudHMuX21heWJlc2Nyb2xsLnVuc2hpZnQoW21ldGhvZCx0XSlcbiAgICAgICAgICAgIGVsc2UgZXZlbnRzLl9tYXliZXNjcm9sbCA9IFtbbWV0aG9kLHRdXVxuICAgICAgICAgIH1lbHNlIGlmKCFldmVudHMuY2xpY2suYmxvY2spIG1ldGhvZC5jYWxsKHQsIGUsIHZhbClcbiAgICAgICAgfSwgbmFtZSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdC5yZW1vdmVFdmVudCgndXAnLCBuYW1lKVxuICAgICAgICB9LCAzMDApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV2ZW50cy5yY2xpY2sgPSB7XG4gIHZhbDoge1xuICAgIHJkb3duOmV2ZW50cy5jbGljay52YWwuZG93blxuICB9XG59XG5cbnZhciBfb3V0UmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZGV4ID0gdXRpbC5jaGVja0FycmF5KGV2ZW50cy5fb3V0LCB0aGlzLCB0cnVlKVxuICAgIGlmICh+aW5kZXgpIHtcbiAgICAgIGV2ZW50cy5fb3V0LnNwbGljZShpbmRleCwgMSlcbiAgICAgIHRoaXMucmVtb3ZlU2V0dGluZygnX291dCcsIF9vdXRTZXR0aW5nKVxuXG4gICAgICAvLyBkZWJ1Z2dlclxuXG4gICAgfVxuICB9XG4sIF9vdXRTZXR0aW5nID0ge1xuICBuYW1lOiAnX291dCcsXG4gIHJlbmRlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF1dGlsLmNoZWNrQXJyYXkoZXZlbnRzLl9vdXQsIHRoaXMpKSB7XG4gICAgICBldmVudHMuX291dC5wdXNoKHRoaXMpXG4gICAgfVxuICB9LFxuICByZW1vdmU6IF9vdXRSZW1vdmVcbn1cblxuZXZlbnRzLm91dCA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm0gPSB0cnVlO1xuICAgIGV2ZW50cy5kb2N1bWVudC5hZGRFdmVudCgndXAnLCBmdW5jdGlvbihlKSB7XG5cbiAgICAgIHZhciBiYXNlID0gZS50YXJnZXQsXG4gICAgICAgIGV4ZWMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgcCA9IGJhc2VcbiAgICAgICAgICAgICwgdFxuICAgICAgICAgIHdoaWxlIChwICYmICF0KSB7XG4gICAgICAgICAgICBpZiAocC5iYXNlICYmIHRoaXMgPT09IHAuYmFzZSkge1xuICAgICAgICAgICAgICB0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAgPSBwLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdCAmJiB0aGlzLnJlbmRlcmVkKSB0aGlzLmV2ZW50cy5vdXQuX3ZhbC5jYWxsKHRoaXMsIGUpXG4gICAgICAgIH1cbiAgICAgIGZvciAodmFyIGFyciA9IGV2ZW50cy5fb3V0LCBpID0gYXJyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGV4ZWMuY2FsbChhcnJbaV0pXG4gICAgICAgIGlmIChhcnJbaV0pIGFycltpXS5lYWNoSW5zdGFuY2UoZXhlYywgJ2V2ZW50cycpXG4gICAgICB9XG4gICAgfSwnb3V0JylcbiAgfSxcbiAgYWRkOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IHRoaXNcbiAgICAgLy8gZXZlbnRzLl9vdXQucHVzaCh0aGlzKVxuICAgIHRoaXMuc2V0U2V0dGluZyhfb3V0U2V0dGluZylcbiAgfSxcbiAgcmVtb3ZlOl9vdXRSZW1vdmVcbn07IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuLi9lbGVtZW50JylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJy4uL2Nhc2VzJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgRmllbGRTdG9yZSA9IGZ1bmN0aW9uICgpIHt9XG5cbnV0aWwuZGVmaW5lKEZpZWxkU3RvcmUsICdfdWlkJywgeyB2YWx1ZTogMCB9KVxuXG5leHBvcnRzLl9yID0ge30gLy9saXN0IG9mIGJhc2ljIChyYXcpIGV2ZW50cyBlLmcuICdtb3VzZWRvd24nXG5cbi8vcmVtb3ZlIGV2ZW50cyBpZiB0aGVyZSBhcmUgbm8gY2hpbGRyZW4gdGhhdCB1c2UgdGhlbSBhbnltb3JlXG5cbmV4cG9ydHMuZG9jdW1lbnQgPSBuZXcgZWxlbWVudCh7IG5vZGU6IGRvY3VtZW50IH0pXG5cbmV4cG9ydHMuZG9jdW1lbnQuZXhlYyA9IGZ1bmN0aW9uKCBldmVudCApIHtcbiAgaWYoIHRoaXMuX19lW2V2ZW50XSApXG4gIHtcbiAgICB2YXIgYXJncyA9IHV0aWwuYXJnKCBhcmd1bWVudHMsIDEgKVxuICAgIGZvciggdmFyIGkgaW4gdGhpcy5fX2VbZXZlbnRdIClcbiAgICB7XG4gICAgICB0aGlzLl9fZVtldmVudF1baV0uYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlKCBpLCBmcm9tICkge1xuICBpZiggZXhwb3J0c1tpXSApXG4gIHtcbiAgICAvLyBjb25zb2xlLmxvZygnY29tcGxleCcsIGksIGZyb20pXG4gICAgX2NyZWF0ZUNvbXBsZXgoIGksIGZyb20gKVxuICB9XG4gIGVsc2VcbiAge1xuICAgIC8vIGNvbnNvbGUubG9nKCdfYmFzaWMnLCBpKVxuXG4gICAgZXhwb3J0c1tpXSA9IHsgX2Jhc2ljOiB0cnVlIH1cbiAgICBfY3JlYXRlQmFzaWMoIGkgKVxuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVXaGlsZSAoaSwgbSkge1xuICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgIHZhciBwYXJlbnQgPSBlLnRhcmdldFxuICAgICAgLCBiYXNlLCBldmVudHNcbiAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICBiYXNlID0gcGFyZW50LmJhc2VcbiAgICAgIGlmIChiYXNlKSB7XG4gICAgICAgIGV2ZW50cyA9IGJhc2UuZXZlbnRzXG4gICAgICAgIGlmIChldmVudHNbaV0pIHtcbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgZXhwb3J0c1tpXS5fbS5jYWxsKGJhc2UsIGUsIGV2ZW50c1tpXSlcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1tpXS5fdmFsKSB7XG4gICAgICAgICAgICBldmVudHNbaV0uX3ZhbC5jYWxsKGJhc2UsIGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlLnByZXZlbnQpIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGV2ZW50cyA9IGJhc2UuX19lXG4gICAgICAgIGlmIChldmVudHMgJiYgZXZlbnRzW2ldKSB7XG5cbiAgICAgICAgICBmb3IgKHZhciBqIGluIGV2ZW50c1tpXSkge1xuICAgICAgICAgICAgaWYoaiE9PSdfdWlkJykge1xuICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgIGV4cG9ydHNbaV0uX20uY2FsbChiYXNlLCBlLCBldmVudHNbaV1bal0pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJz93aGF0JywgaSwgaiwgYmFzZSwgYmFzZS5fbm9kZSlcbiAgICAgICAgICAgICAgICBldmVudHNbaV1bal0uY2FsbChiYXNlLCBlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlLnByZXZlbnQpIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUJhc2ljIChpLCByKSB7XG4gIHZhciB0eXBlID0gaSB8fCByXG5cbiAgLy8gY29uc29sZS5sb2coJ2NyZWF0ZUJhc2ljJywgdHlwZSxpKVxuXG4gIGV4cG9ydHMuX3JbaV0gPSB0cnVlXG4gIGlmKHR5cGUgPT09ICdzY3JvbGwnKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmdW5jdGlvbihlKXtcbiAgICAgIHZhciBiYXNlID0gZS50YXJnZXQuYmFzZVxuICAgICAgICAsIGV2ZW50c1xuXG4gICAgICBpZihiYXNlKSB7XG4gICAgICAgIGV2ZW50cyA9IGJhc2UuZXZlbnRzXG4gICAgICAgIGlmKGV2ZW50cyAmJiBldmVudHNbaV0pIGV2ZW50c1tpXS5fdmFsLmNhbGwoYmFzZSwgZSlcbiAgICAgICAgZXZlbnRzID0gYmFzZS5fX2VcbiAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHNbaV0pIHtcbiAgICAgICAgICBmb3IgKHZhciBqIGluIGV2ZW50c1tpXSkge1xuICAgICAgICAgICAgaWYoaiE9PSdfdWlkJykgZXZlbnRzW2ldW2pdLmNhbGwoYmFzZSwgZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LHRydWUpXG4gIH1lbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgKGV4cG9ydHNbaV0ubSA9IF9jcmVhdGVXaGlsZShpKSkpXG59XG5cbmZ1bmN0aW9uIF9zZXRDb21wbGV4ICggaSwgbSwgciwgZnJvbSApIHtcbiAgdmFyIG1ldCA9IGV4cG9ydHNbaV0uX20gPSBmdW5jdGlvbiAoZSwgdmFsKSB7XG4gICAgaWYgKGUucHJldmVudCkgcmV0dXJuXG4gICAgbS5jYWxsKHRoaXMsIGUsICh2YWwuX3ZhbCB8fCB2YWwudmFsIHx8IHZhbCksIHZhbClcbiAgfVxuICBleHBvcnRzW2ldLm0gPSBfY3JlYXRlV2hpbGUoaSwgdHJ1ZSlcbiAgZXhwb3J0cy5fcltpXSA9IHRydWVcbiAgaWYgKGV4cG9ydHNbcl0pIHtcbiAgICBpZiAoIWV4cG9ydHNbcl0ubSkge1xuICAgICAgX2NyZWF0ZShyLCBmcm9tIClcbiAgICB9XG4gICAgaWYgKCFleHBvcnRzW3JdLl9iYXNpYykge1xuICAgICAgZXhwb3J0c1tpXS5fX2UgPSBleHBvcnRzW3JdLl9fZVxuICAgICAgZXhwb3J0c1tpXS5fbSA9IGZ1bmN0aW9uIChlLCBtKSB7XG4gICAgICAgIGV4cG9ydHNbcl0uX20uY2FsbCh0aGlzLCBlLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgbWV0LmNhbGwodGhpcywgZSwgbSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0c1tpXS5fX2UgPSByXG4gICAgfVxuICB9XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoKGV4cG9ydHNbcl0gJiYgZXhwb3J0c1tyXS5fX2UpIHx8IHIsIGV4cG9ydHNbaV0ubSlcbn1cblxudmFyIGFkZFdyYXBwZXIgPSBmdW5jdGlvbiggYWRkLCBmaWVsZCwgb3JpZyApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCAnQUREIFdSQVAhJywgZmllbGQsIG9yaWcgLCBhcmd1bWVudHMgKVxuICAgIHJldHVybiBhZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDb21wbGV4KCBmaWVsZCwgZnJvbSApIHtcblxuICAvLyBjb25zb2xlLmxvZygnX2NyZWF0ZUNvbXBsZXgnICxmaWVsZCwgZnJvbSApXG5cbiAgaWYoIGV4cG9ydHNbZmllbGRdLmNyZWF0ZSApIGV4cG9ydHNbZmllbGRdLmNyZWF0ZSggZmllbGQsIGZyb20pXG4gIHZhciBtXG4gICAgLCBpXG4gICAgLCBqXG4gIGZvciAoIGkgaW4gZXhwb3J0c1tmaWVsZF0gKSB7XG4gICAgaWYgKGNhc2VzW2ldID09PSB0cnVlKSBtID0gZXhwb3J0c1tmaWVsZF1baV1cbiAgfVxuICBpZiAoIG0gfHwgKCBtID0gZXhwb3J0c1tmaWVsZF0udmFsICkgKSB7XG4gICAgZm9yIChqIGluIG0pIC8vb25seSBvbmVcbiAgICA7ZXhwb3J0c1tmaWVsZF0uX19lID0galxuXG4gICAgaWYgKG1bal0gPT09IHRydWUpIFxuICAgIHtcbiAgICAgIGV4cG9ydHNbZmllbGRdLl9iYXNpYyA9IHRydWVcbiAgICAgIF9jcmVhdGVCYXNpYyhmaWVsZCwgailcbiAgICB9IFxuICAgIGVsc2UgXG4gICAge1xuICAgICAgLy9iYXNpYyBlbiBub24gYmFzaWMgaWpuIG5pZXQgdGUgY29tYmluZXJlbiAtLSBjb21iaW5lcmVuIG5vZyBrYXBvdFxuICAgICAgLy8gY29uc29sZS5sb2coJ3NldCBjb21wbGV4IGZpZWxkJywgZmllbGQsIG0sIGosICBleHBvcnRzW2pdKSBcbiAgICAgIC8vISEhdHJpcHBsZSBjaGVjayBkaXQhISFcbiAgICAgICBmb3IoIGogaW4gbSApIFxuICAgICAgIHsgXG4gICAgICAgIGlmKCBleHBvcnRzW2pdICYmIGV4cG9ydHNbal0uYWRkIFxuICAgICAgICAgJiYgZXhwb3J0c1tmaWVsZF0gJiYgIWV4cG9ydHNbZmllbGRdLmFkZFxuICAgICAgICApIFxuICAgICAgICB7XG4gICAgICAgICAgZXhwb3J0c1tmaWVsZF0uYWRkID0gYWRkV3JhcHBlciggZXhwb3J0c1tqXS5hZGQsIGZpZWxkLCBqIClcbiAgICAgICAgfVxuICAgICAgICBfc2V0Q29tcGxleChmaWVsZCwgbVtqXSwgaiwgZnJvbSApXG4gICAgICB9XG4gICAgICAvLyEhIWRhbmdlciBsb29wISEhXG4gICAgfVxuXG4gIH1cbn1cblxuZXhwb3J0cy5fc2V0ID0gZnVuY3Rpb24gKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgY3ZhbCwgYmxhY2tsaXN0KSB7XG4gIHZhciB0ID0gdGhpc1xuICB2YWwuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgIGlmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3RbaV0pIHtcbiAgICAgIGlmICh0aGlzLl92YWwgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChleHBvcnRzW2ldKSB7XG4gICAgICAgICAgaWYgKGV4cG9ydHNbaV0ucmVtb3ZlKSBleHBvcnRzW2ldLnJlbW92ZS5jYWxsKHQpXG4gICAgICAgICAgdC5lYWNoSW5zdGFuY2UoZXhwb3J0c1tpXS5yZW1vdmUsIHZhbC5fcHJvcC5uYW1lKVxuICAgICAgICAgIHRoaXMucmVtb3ZlKClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdfY3JlJywgaSwgZXhwb3J0c1tpXSlcblxuICAgICAgICBpZiAoIShleHBvcnRzW2ldICYmIGV4cG9ydHNbaV0ubSkpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tcGFzcycsIGkpXG4gICAgICAgICAgX2NyZWF0ZShpLCBpKVxuICAgICAgICB9XG4gICAgICAgIC8vYWRkIHdyYXBwZXI/XG5cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnX3NldCcsaSwgZXhwb3J0c1tpXS5hZGQsIGV4cG9ydHNbaV0pXG5cbiAgICAgICAgaWYgKGV4cG9ydHNbaV0uYWRkKSBleHBvcnRzW2ldLmFkZC5jYWxsKCB0LCBmYWxzZSwgaSApXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5lbGVtZW50LmJhc2UuZXh0ZW5kKFxueyBuYW1lOiAnZXZlbnRzJ1xuLCBzZXQ6IGV4cG9ydHMuX3NldFxufSlcblxudXRpbC5kZWZpbmUoZWxlbWVudFxuLCAnYWRkRXZlbnQnLCBmdW5jdGlvbihmaWVsZCwgZm4sIGlkKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1hYWFgnLGZpZWxkKVxuXG4gICAgaWYgKCEoZXhwb3J0c1tmaWVsZF0gJiYgZXhwb3J0c1tmaWVsZF0ubSkpIF9jcmVhdGUoZmllbGQpXG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX19lIHx8ICh0aGlzLl9fZSA9IHt9KVxuICAgICAgLCBmID0gZXZlbnRzW2ZpZWxkXSB8fCAoZXZlbnRzW2ZpZWxkXSA9IG5ldyBGaWVsZFN0b3JlKCkpXG5cbiAgICBpZiAoIWlkKSB7XG4gICAgICBmLl91aWQrK1xuICAgICAgaWQgPSBmLl91aWRcbiAgICB9XG4gICAgZltpZF0gPSBmblxuXG4gICAgLy8gY29uc29sZS5sb2coJ2FkZEV2ZW50ISEhJywgZmllbGQpXG5cbiAgICBpZiAoZXhwb3J0c1tmaWVsZF0uYWRkKSBleHBvcnRzW2ZpZWxkXS5hZGQuY2FsbCh0aGlzLCBpZCwgZmllbGQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuLCAncmVtb3ZlRXZlbnQnLCBmdW5jdGlvbiAoZmllbGQsIGlkLCBmbikge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9fZVxuICAgICAgLCByZW1vdmVcbiAgICBpZiAoZXZlbnRzKSB7XG4gICAgICBpZiAoZmllbGQgJiYgZXZlbnRzW2ZpZWxkXSkge1xuICAgICAgICByZW1vdmUgPSAoZXhwb3J0c1tmaWVsZF0gJiYgZXhwb3J0c1tmaWVsZF0ucmVtb3ZlKVxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBpZiAoZXZlbnRzW2ZpZWxkXVtpZF0gJiYgKCFmbiB8fCBldmVudHNbZmllbGRdW2lkXSA9PT0gZm4pKSB7XG4gICAgICAgICAgICBpZiAocmVtb3ZlKSBleHBvcnRzW2ZpZWxkXS5yZW1vdmUuY2FsbCh0aGlzLCBpZClcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbZmllbGRdW2lkXVxuICAgICAgICAgIH1cbiAgICAgICAgfSBcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yIChpZCBpbiBldmVudHNbZmllbGRdKSB7XG4gICAgICAgICAgICBpZiAoIWZuIHx8IGV2ZW50c1tmaWVsZF1baWRdID09PSBmbikge1xuICAgICAgICAgICAgICBpZiAocmVtb3ZlKSBleHBvcnRzW2ZpZWxkXS5yZW1vdmUuY2FsbCh0aGlzLCBpZClcbiAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tmaWVsZF1baWRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1dGlsLmVtcHR5KGV2ZW50c1tmaWVsZF0pKSBkZWxldGUgZXZlbnRzW2ZpZWxkXVxuICAgICAgfSBcbiAgICAgIGVsc2UgaWYgKCFmaWVsZCkge1xuICAgICAgICBmb3IgKGZpZWxkIGluIGV2ZW50cykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlRXZlbnQoZmllbGQsIGlkLCBmbilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodXRpbC5lbXB0eShldmVudHMpKSBkZWxldGUgdGhpcy5fX2VcbiAgICByZXR1cm4gdGhpc1xuICB9KVxuXG5yZXF1aXJlKCcuL2Jhc2ljJylcbiIsInZhciBtYXRyaXggPSByZXF1aXJlKCcuLi9lbGVtZW50L3Byb3BlcnRpZXMvdXRpbCcpLmdldE1hdHJpeFxuICAsIHZpZ291ciA9IHJlcXVpcmUoJy4uLy4uLycpXG4gICwgY3NzID0gcmVxdWlyZSgnLi4vY3NzJylcblxuZXhwb3J0cy5sZWZ0ID0gZXhwb3J0cy54ID0gZnVuY3Rpb24gKCBvYmplY3QsIGFyciApIHtcbiAgcmV0dXJuIG9mZnNldChvYmplY3QsYXJyLCdsZWZ0Jywnb2Zmc2V0TGVmdCcsIDQpXG59XG5cbmV4cG9ydHMudG9wID0gZXhwb3J0cy55ID0gZnVuY3Rpb24gKCBvYmplY3QsIGFyciApIHtcbiAgcmV0dXJuIG9mZnNldChvYmplY3QsYXJyLCd0b3AnLCdvZmZzZXRUb3AnLCA1KVxufSBcblxuZnVuY3Rpb24gb2Zmc2V0ICggb2JqZWN0LCBhcnIsIHByb3AsIHByb3BMLCBtYXRyaXhJbmRleCApIHtcbiAgaWYoIW9iamVjdCkgcmV0dXJuIDBcbiAgdmFyIHN0YXJ0ID0gZmFsc2VcbiAgaWYoIWFycikge1xuICAgIGFyciA9IFtdXG4gICAgc3RhcnQgPSB0cnVlXG4gIH1cbiAgXG4gIGlmKHZpZ291ci5FbGVtZW50ICYmIG9iamVjdCBpbnN0YW5jZW9mIHZpZ291ci5FbGVtZW50KSBvYmplY3QgPSBvYmplY3Qubm9kZVxuXG4gIHZhciBhbW91bnQgPSBvYmplY3RbcHJvcExdXG4gICAgLCB0ZW1wID0gMFxuICBpZih0eXBlb2YoYW1vdW50KSAhPT0gJ251bWJlcicpIGFtb3VudCA9IDBcbiAgaWYob2JqZWN0LnBhcmVudE5vZGUpIGV4cG9ydHNbcHJvcF0ob2JqZWN0LnBhcmVudE5vZGUsIGFycilcbiAgICBpZiggKCAob2JqZWN0LnN0eWxlICYmIG9iamVjdC5zdHlsZS5wb3NpdGlvbilcbiAgICAgIHx8b2JqZWN0Ll9fcHJlQ3NzXG4gICAgICB8fG9iamVjdC5jbGFzc05hbWUgXG4gICAgICAgICYmIChvYmplY3QuX19wcmVDc3MgPSBjc3Mob2JqZWN0LmNsYXNzTmFtZSwgJ3Bvc2l0aW9uJyl8fHRydWUpKSBcbiAgICAgICE9PSAnYWJzb2x1dGUnICkge1xuICAgICAgICBhcnIucHVzaChbJ3JlbCcsIGFtb3VudF0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXRyaXhBcnJheSA9IG1hdHJpeChvYmplY3QpXG4gICAgICBhcnIucHVzaChbJ2FicycsIG1hdHJpeEFycmF5IFxuICAgICAgICA/IHBhcnNlSW50KG1hdHJpeEFycmF5W21hdHJpeEluZGV4XSwxMCkrYW1vdW50IC8vbm9ybWFsIGFtb3VudCBhcyB3ZWxsXG4gICAgICAgIDogYW1vdW50IF0pXG4gICAgfVxuICBcbiAgaWYoc3RhcnQpIHtcbiAgICB2YXIgbGFzdHJlbFxuICAgICAgLCBhYnMgPSAwXG4gICAgICAsIGlcbiAgICBmb3IoaSBpbiBhcnIpIHtcbiAgICAgIGlmKGFycltpXVswXSA9PSAnYWJzJykge1xuICAgICAgICBhYnMgKz0gYXJyW2ldWzFdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0cmVsID0gYXJyW2ldWzFdXG4gICAgICB9XG4gICAgfVxuICAgIGFtb3VudCA9IGFyclthcnIubGVuZ3RoIC0gMV1bMF0gPT09ICdyZWwnID8gYWJzK2xhc3RyZWwgOiBhYnNcbiAgfVxuICByZXR1cm4gYW1vdW50IHx8IDBcbn1cblxuICBcblxuXG4iLCJ2YXIgcmFmID0gcmVxdWlyZSgnLi4vYW5pbWF0aW9uL3JhZicpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG5leHBvcnRzLnRocm90dGxlID0gZnVuY3Rpb24oZm4sIGZyYW1lcywgYmluZCkge1xuICBmcmFtZXMgfHwgKGZyYW1lcyA9IDIwKSAvL34wLjRzZWNcbiAgdmFyIHRpbWVyXG4gICAgLCBhcmdcbiAgICAsIG5vYmluZCA9ICFiaW5kXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBhcmcgPSBhcmd1bWVudHNcbiAgICBpZihub2JpbmQpIGJpbmQgPSB0aGlzXG4gICAgaWYoIXRpbWVyKSB7XG4gICAgICB0aW1lciA9IGZyYW1lc1xuICAgICAgcmFmKGZ1bmN0aW9uIHJlcGVhdCgpIHtcbiAgICAgICAgdGltZXItLVxuICAgICAgICBpZighdGltZXIpIHtcbiAgICAgICAgICBmbi5hcHBseShiaW5kLGFyZykgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFmKHJlcGVhdClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuLy9UT0RPOiBwb3N0cG9uZSBiYXNlZCBvbiBmcmFtZXNcbmV4cG9ydHMucG9zdHBvbmUgPSBmdW5jdGlvbihmbiwgdGltZSwgYmluZCkge1xuICB0aW1lIHx8ICh0aW1lID0gMjAwKSAvL25vIHJhZiFcbiAgdmFyIHRpbWVyXG4gICAgLCBhcmdcbiAgICAsIG5vYmluZCA9ICFiaW5kXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICBhcmcgPSBhcmd1bWVudHNcbiAgICBpZihub2JpbmQpIGJpbmQgPSB0aGlzXG4gICAgaWYodGltZXIpIGNsZWFyVGltZW91dCh0aW1lcilcbiAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBmbi5hcHBseShiaW5kLGFyZylcbiAgICB9LHRpbWUpXG4gICAgcmV0dXJuIHRpbWVyXG4gIH1cbn1cblxuLy9UT0RPOiB0ZXN0IGZvciBsZWFrcy4uLlxuZXhwb3J0cy5pbnRlcnZhbCA9IGZ1bmN0aW9uKGZuLCBmcmFtZXMsIGJpbmQpIHtcbiAgZnJhbWVzIHx8IChmcmFtZXMgPSAzMCkgLy9+MC41c2VjXG4gIHZhciB0aW1lclxuICAgICwgY2xlYXJcbiAgICAsIGFyZyA9IHV0aWwuYXJnKGFyZ3VtZW50cywzKVxuICBpZighdGltZXIpIHtcbiAgICB0aW1lciA9IGZyYW1lc1xuICAgIHJhZihmdW5jdGlvbiByZXBlYXQoKSB7XG4gICAgICB0aW1lci0tXG4gICAgICBpZighdGltZXIpIHtcbiAgICAgICAgdGltZXIgPSBmcmFtZXNcbiAgICAgICAgZm4uYXBwbHkoYmluZCxhcmcpXG4gICAgICB9IFxuICAgICAgaWYoIWNsZWFyKSByYWYocmVwZWF0KVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGNsZWFyPXRydWVcbiAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIF9hID0gJ2FkZEV2ZW50TGlzdGVuZXInXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIHVhID0gcmVxdWlyZSgnLi4vdWEnKVxuICAsIGNudCA9IDBcblxuLyoqXG4gKiB4aHIgd3JhcHBlciwgYWRkcyBzb21lIG5pY2UgZXh0cmFzIHN1Y2ggYXMgbXVsdGlwbGUgcmVxdWVzdHMgdG8gYSBzaW5nbGUgYXBpIGNhbGxcbiAqIHhociB3cmFwcGVyIHdpbGwgaW5jbHVkZSBqc29ucCBpbiBhIGxhdGVyIHN0YWdlXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtICAge1N0cmluZ3xBcnJheX0gcGFyYW1zLnVybCAgICAgICAgIFNwZWNpZml5IHRoZSB1cmwsIGFycmF5IGZldGNoZXMgbXVsdGlwbGUgdXJsJ3NcbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy5hcGldICAgICAgICAgICBSZXBlYXQgdGhpcyBzdHJpbmcgZm9yIHRoZSB1cmwgdGhhdCBuZWVkcyB0byBiZSBjYWxsZWRcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gW3BhcmFtcy5jb21wbGV0ZV0gICAgICBTcGVjaWZ5IGEgY2FsbGJhY2sgd2hlbiBhbiBhcnJheSBpcyBwYXNzZWQgdG8gdXJsIGNvbXBsZXRlIGlzIGNhbGxlZCB3aGVuIGFsbCBpdGVtcyBhcmUgY29tcGxldGVcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gW3BhcmFtcy5lcnJvcl0gICAgICAgICBPbiBlcnJvciBjYWxsYmFja1xuICogQHBhcmFtICAge0Z1bmN0aW9ufSBbcGFyYW1zLmNoYW5nZV0gICAgICAgIEZ1bmN0aW9uIGNhbGxlZCBvbiB4aHIub25yZWFkeXN0YXRlY2hhbmdlXG4gKiBAcGFyYW0gICB7Qm9vbGVhbn0gIFtwYXJhbXMuYXN5bmNdICAgICAgICAgSWYgc2V0IHRvIGZhbHNlIHdpbGwgY2FsbCBhbiBzeW5jcm9ub3VzIHJlcXVlc3QgKG5vdCByZWNvbW1lbmRlZCEpXG4gKiBAcGFyYW0gICB7U3RyaW5nfSAgIFtwYXJhbXMudXNlcl0gICAgICAgICAgVXNlciBwYXJhbWV0ZXJcbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy5wYXNzXSAgICAgICAgICBQYXNzd29yZCBwYXJhbWV0ZXJcbiAqIEBwYXJhbSAgIHtCb29sZWFufSAgW3BhcmFtcy5wYXJzZV0gICAgICAgICBJZiBzZXQgdG8gZmFsc2Ugd2lsbCBub3QgdHJ5IHRvIHBhcnNlIHJlc3BvbnNlIHRvIEpTT05cbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy50eXBlfC5tZXRob2RdICBQT1NUIG9yIEdFVCwgZGVmYXVsdCBpcyBnZXQ7XG4gKiBAcGFyYW0gICB7U3RyaW5nfSAgIFtwYXJhbXMuY29udGVudFR5cGVdICAgcmVxdWVzdCBjb250ZW50IHR5cGUgZGVmYXVsdCBpZCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiXG4gKiBAcGFyYW0gICB7U3RyaW5nfSAgIFtwYXJhbXMubWltZV0gICAgICAgICAgZGVmaW5lcyBtaW1lIHR5cGVcbiAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gW3BhcmFtcy5wcm9ncmVzc10gICAgICBQcm9ncmVzcyBjYWxsYmFja1xuICogQHBhcmFtICAge0Jvb2xlYW58U3RyaW5nfSBbcGFyYW1zLmpzb25wXSAgIFVzZSBqc29ucCAsIGlmIHBhc3NlZCBhcyBhIHN0cmluZyBkZXRlcm1pbmVzIHNjcmlwdCs/Y2FsbGJhY2s9XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgIFtwYXJhbXMuaGVhZGVyXSAgICAgICAgU2V0cyByZXF1ZXN0IGhlYWRlcnNcbiAqIEBwYXJhbSAgIHsqfSAgICAgICAgW3BhcmFtcy5kYXRhXSAgICAgICAgICBQYXNzIGRhdGEgdG8gdGhlIHJlcXVlc3QsIGRlZmF1bHRzIHRvID8gb24gZ2V0O1xuICovXG5cbnZhciBpZnJhbWVzXG4gICwgYWpheCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocGFyYW1zLCB1cmxzZXQpIHtcbiAgICB2YXIgX3VybCA9IHBhcmFtcy51cmw7XG4gICAgaWYgKCF1cmxzZXQgJiYgX3VybCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBwYXJhbXMubSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoKCsrcGFyYW1zLnIpID09PSBwYXJhbXMubikge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIgPSBbXSwgbCA9IF91cmwubGVuZ3RoOyBpIDwgbDsgYXJyLnB1c2gocGFyYW1zLmRbX3VybFtpKytdXSkpO1xuICAgICAgICAgIHBhcmFtcy5jb21wbGV0ZShhcnIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGFyYW1zLnIgPSAwO1xuICAgICAgcGFyYW1zLmQgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGFyYW1zLm4gPSBfdXJsLmxlbmd0aDsgaSA8IGw7IG1vZHVsZS5leHBvcnRzKHBhcmFtcywgX3VybFtpKytdKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkYXRhID0gcGFyYW1zLmRhdGFcbiAgICAgICAgLCBlbmNvZGUgPSBwYXJhbXMuZW5jb2RlXG4gICAgICAgICwgdXJsID0gKHBhcmFtcy5hcGkgfHwgJycpICsgKHVybHNldCB8fCBfdXJsKVxuICAgICAgICAsIGhlYWRlcnMgPSBwYXJhbXMuaGVhZGVyc1xuICAgICAgICAsIHN1Y2Nlc3MgPSBwYXJhbXMuY29tcGxldGVcbiAgICAgICAgLCBwcm9ncmVzcyA9IHBhcmFtcy5wcm9ncmVzc1xuICAgICAgICAsIGVycm9yID0gcGFyYW1zLmVycm9yXG4gICAgICAgICwgY2hhbmdlID0gcGFyYW1zLmNoYW5nZVxuICAgICAgICAsIG1pbWUgPSBwYXJhbXMubWltZVxuICAgICAgICAsIHVzZXIgPSBwYXJhbXMudXNlclxuICAgICAgICAsIHBhc3MgPSBwYXJhbXMucGFzc1xuICAgICAgICAsIGpzb25wID0gcGFyYW1zLmpzb25wXG4gICAgICAgICwgcGFyc2UgPSBwYXJhbXMucGFyc2VcbiAgICAgICAgLCBpZnJhbWUgPSBwYXJhbXMuaWZyYW1lXG4gICAgICAgICwgcmVxZGF0YSA9IG51bGxcbiAgICAgICAgLCBmYWxsYmFjayA9IHBhcmFtcy5mYWxsYmFja1xuICAgICAgICAsIGZhbGxiYWNrSW5kZXggPSBwYXJhbXMuX2ZhbGxiYWNrSW5kZXhcbiAgICAgICAgLCBtZXRob2QgPSBwYXJhbXMudHlwZSB8fCBwYXJhbXMubWV0aG9kIHx8ICdHRVQnXG4gICAgICAgICwgY29udGVudFR5cGUgPSBwYXJhbXMuY29udGVudFR5cGUgfHwgZW5jb2RlID09PSAnanNvbidcbiAgICAgICAgICA/ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgIDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbiAgICAgICAgLCBhc3luYyA9IChwYXJhbXMuYXN5bmMgPT09IGZhbHNlKSA/IGZhbHNlIDogdHJ1ZVxuICAgICAgICBcbiAgICAgIGlmKCBqc29ucCApIFxuICAgICAge1xuICAgICAgICBhamF4Lmpzb25wKCB1cmwsIHN1Y2Nlc3MsIGVycm9yICkgIFxuICAgICAgICAvL2Z1bmN0aW9uKCB1cmwsIHN1Y2Nlc3MsIGVycm9yLCBjb250ZXh0LCBjYk5hbWUgKSB7XG4gICAgICB9IFxuICAgICAgZWxzZSBcbiAgICAgIHtcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIERBVEFcbiAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgICAgIGlmKGlmcmFtZSkge1xuICAgICAgICAgIGNudCsrXG4gICAgICAgICAgdmFyIGVsZW1cbiAgICAgICAgICAgICwgbXNnID0ge31cbiAgICAgICAgICAgICwgcmVxaWQgPSBjbnRcblxuICAgICAgICAgIGZvcih2YXIgZmllbGQgaW4gcGFyYW1zKSB7XG4gICAgICAgICAgICBpZihmaWVsZCE9PSdlcnJvcicmJmZpZWxkIT09J2lmcmFtZScmJmZpZWxkIT09J2NvbXBsZXRlJykge1xuXG4gICAgICAgICAgICAgIG1zZ1tmaWVsZF09cGFyYW1zW2ZpZWxkXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2V0bXNnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZWxlbVxuICAgICAgICAgICAgaWZyYW1lc1tpZnJhbWVdLm9ubG9hZCA9IG51bGxcbiAgICAgICAgICAgIHZhciBtc2djb21wbGV0ZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignSUZSQU1FIFJFUSBNU0cgQ09NUExFVEUnLGUuZGF0YSlcbiAgICAgICAgICAgICAgaWYoZS5kYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgZCA9IEpTT04ucGFyc2UoZS5kYXRhKVxuICAgICAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgICAgaWYoZXJyb3IpIGVycm9yKGUpXG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoZC5pZCE9PXJlcWlkKSByZXR1cm5cbiAgICAgICAgICAgICAgICBpZihkLmVycikge1xuICAgICAgICAgICAgICAgICAgaWYoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoZC5lcnIpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3AgPSBkLm1zZ1xuICAgICAgICAgICAgICAgIGlmKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNwID0gSlNPTi5wYXJzZShyZXNwKVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgc3VjY2VzcyhyZXNwLGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBtc2djb21wbGV0ZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbXNnY29tcGxldGUsIGZhbHNlKVxuICAgICAgICAgICAgICBlbGVtID0gaWZyYW1lc1tpZnJhbWVdLmNvbnRlbnRXaW5kb3dcbiAgICAgICAgICAgICAgbXNnID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIG1zZzptc2csXG4gICAgICAgICAgICAgICAgaWQ6cmVxaWRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgZWxlbS5wb3N0TWVzc2FnZShtc2csICcqJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZighaWZyYW1lcykgaWZyYW1lcyA9IHt9XG4gICAgICAgICAgaWYoIWlmcmFtZXNbaWZyYW1lXSkge1xuICAgICAgICAgICAgZWxlbSA9IGlmcmFtZXNbaWZyYW1lXSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpXG4gICAgICAgICAgICBlbGVtLnNyYyA9IGlmcmFtZVxuICAgICAgICAgICAgZWxlbS5jTGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgICBzZXRtc2dcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIGVsZW0ub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGZvcih2YXIgaCBpbiBlbGVtLmNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBlbGVtLmNMaXN0ZW5lcnNbaF0oKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsZW0uY0xpc3RlbmVycyA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW0uc3R5bGUudmlzaWJpbGl0eT0naGlkZGVuJ1xuICAgICAgICAgICAgZWxlbS5zdHlsZS53aWR0aCA9ICcwcHgnXG4gICAgICAgICAgICBlbGVtLnN0eWxlLmhlaWdodCA9ICcwcHgnXG4gICAgICAgICAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtKVxuICAgICAgICAgIH0gZWxzZSBpZihpZnJhbWVzW2lmcmFtZV0uY0xpc3RlbmVycykge1xuICAgICAgICAgICAgaWZyYW1lc1tpZnJhbWVdLmNMaXN0ZW5lcnMucHVzaChzZXRtc2cpXG4gICAgICAgICAgICAvL2VsZW0uY0xpc3RlbmVyc1tpXVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRtc2coKVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZGF0YSkge1xuXG4gICAgICAgICAgaWYgKG1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgIHVybCArPSAnPycgKyBlbkNvZGUoZGF0YSwgJ0dFVCcsIGVuY29kZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVxZGF0YSA9IGVuQ29kZShkYXRhLCAnUE9TVCcsIGVuY29kZSlcbiAgLy8gICAgICAgICAgIGNvbnNvbGUubG9nKCByZXFkYXRhIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUVUSE9ELCBVUkwsIEFTWU5DLCBVU0VSICYgUEFTU1xuICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3MpXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBIRUFERVJTXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LVR5cGUnLCBjb250ZW50VHlwZSlcbiAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICBmb3IgKHZhciBmIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGYsIGhlYWRlcnNbZl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBFVkVOVFNcbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICB4aHJbX2FdKFwibG9hZFwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgcmVzcCA9IChlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnQpLnJlc3BvbnNlO1xuICAgICAgICAgICAgaWYgKHBhcnNlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlc3AgPSBKU09OLnBhcnNlKHJlc3ApXG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zLm0pIHtcbiAgICAgICAgICAgICAgcGFyYW1zLmRbdXJsc2V0XSA9IHJlc3BcbiAgICAgICAgICAgICAgcGFyYW1zLm0oKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3VjY2VzcyhyZXNwLCBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGlmKCFmYWxsYmFja0luZGV4KSBwYXJhbXMuX2ZhbGxiYWNrSW5kZXggPSAwXG4gICAgICAgICAgaWYoZmFsbGJhY2sgJiYgZmFsbGJhY2tJbmRleCE9PWZhbGxiYWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFyYW1zLl9mYWxsYmFja0luZGV4KytcbiAgICAgICAgICAgIHBhcmFtcyA9IHV0aWwubWVyZ2UocGFyYW1zLGZhbGxiYWNrSW5kZXgpXG4gICAgICAgICAgICBhamF4KHBhcmFtcywgdXJsc2V0KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4aHJbX2FdKFwiZXJyb3JcIiwgZXJyb3IsIGZhbHNlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3Jlc3MpIHtcbiAgICAgICAgICB4aHJbX2FdKFwicHJvZ3Jlc3NcIiwgcHJvZ3Jlc3MsIGZhbHNlKVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gY2hhbmdlXG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIE1JTUVcbiAgICAgICAgaWYgKG1pbWUpIHtcbiAgICAgICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZShtaW1lKVxuICAgICAgICB9XG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBTRU5EXG5cbiAgICAgICAgeGhyLnNlbmQocmVxZGF0YSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxudmFyIGpzb25wU3RhbXAgPSAwXG5cbmFqYXguanNvbnAgPSBmdW5jdGlvbiggdXJsLCBzdWNjZXNzLCBlcnJvciwgY29udGV4dCwgY2JOYW1lICkge1xuXG4gIGlmKCAhY2JOYW1lIHx8IGNiTmFtZSA9PT0gdHJ1ZSApIGNiTmFtZSA9ICdjYWxsYmFjaydcblxuICB2YXIgbmFtZSA9ICdfanNvbnBfJyArIGpzb25wU3RhbXArK1xuICAgICwgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgXG4gIGlmICh1cmwubWF0Y2goL1xcPy8pKSBcbiAgeyBcbiAgICB1cmwgKz0gJyYnK2NiTmFtZSsnPScrbmFtZVxuICB9XG4gIGVsc2UgXG4gIHtcbiAgICB1cmwgKz0gJz8nK2NiTmFtZSsnPScrbmFtZVxuICB9XG4gIFxuICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnXG4gIHNjcmlwdC5zcmMgPSB1cmxcbiAgXG4gIGlmKGVycm9yKSB7XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbiggZSApIHtcbiAgICAgIGVycm9yKCBlIClcbiAgICB9XG4gIH1cblxuICB3aW5kb3dbbmFtZV0gPSBmdW5jdGlvbihkYXRhKXtcbiAgICBzdWNjZXNzLmNhbGwoKCBjb250ZXh0IHx8IHdpbmRvdyApLCBkYXRhKVxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0ucmVtb3ZlQ2hpbGQoc2NyaXB0KVxuICAgIHNjcmlwdCA9IG51bGxcbiAgICBkZWxldGUgd2luZG93W25hbWVdXG4gIH1cbiAgXG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KVxuXG59XG5cbnZhciBlbkNvZGUgPSBhamF4LmVuY29kZSA9IGZ1bmN0aW9uKGRhdGEsIG1ldGhvZCwgZW5jb2RlKSB7XG4gIHZhciByZXN1bHQgPSAnJ1xuXG4gIGlmKGVuY29kZSA9PT0gJ2pzb24nKXtcbiAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShkYXRhKVxuICB9IGVsc2UgaWYoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGlmICghdXRpbC5pc05vZGUgJiYgKHdpbmRvdy5Gb3JtRGF0YSAmJiBkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpICYmIG1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgIHJlc3VsdCA9IGRhdGFcbiAgICB9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgcmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkoZGF0YVtmXSlcbiAgICAgIGlmKGVuY29kZSA9PT0gJ3VyaScpIHJlc3VsdCA9IGVuY29kZVVSSUNvbXBvbmVudChyZXN1bHQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGYgaW4gZGF0YSkge1xuICAgICAgICB2YXIgdmFsID0gZGF0YVtmXVxuICAgICAgICBpZih2YWwgaW5zdGFuY2VvZiBPYmplY3QpIHZhbCA9IEpTT04uc3RyaW5naWZ5KHZhbClcbiAgICAgICAgaWYoZW5jb2RlID09PSAndXJpJyl7XG4gICAgICAgICAgZiA9IGVuY29kZVVSSUNvbXBvbmVudChmKVxuICAgICAgICAgIHZhbCA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWwpXG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IGYgKyAnPScgKyB2YWwgKyAnJidcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgwLCAtMSlcblxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAoZW5jb2RlID09PSAndXJpJykgPyBlbmNvZGVVUklDb21wb25lbnQoZGF0YSkgOiBkYXRhXG4gIH1cbiAgLy8gY29uc29sZS5sb2coJ2VuY29kZWQ6JywgcmVzdWx0KVxuICByZXR1cm4gcmVzdWx0XG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogTWFyY3VzIEJlc2plcywgbWFyY3VzQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGV4dGVuZClcblxuZnVuY3Rpb24gZXh0ZW5kKENsb3VkKSB7XG4gIHV0aWwuZGVmaW5lKCBDbG91ZFxuICAsICdhdXRoZW50aWNhdGUnLCBmdW5jdGlvbiBhdXRoZW50aWNhdGUocmVxLCBjYiwgcmUpe1xuICAgICAgd2luZG93LmF1dGhyZXF1ZXN0ID0gcmVxXG4gICAgICB2YXIgY2xvdWQgPSB0aGlzXG5cbiAgICAgIGlmKHR5cGVvZiByZXEgPT09ICdmdW5jdGlvbicpXG4gICAgICAgIHJlcSA9IHJlcSgpXG5cbiAgICAgIGlmKCFyZXEpXG4gICAgICAgIHJldHVybiBjbG91ZC5zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2Nvbm5lY3QnLCByZUF1dGgpXG5cbiAgICAgIGNsb3VkLmVtaXQoJ2F1dGhlbnRpY2F0ZScsIHJlcSwgZnVuY3Rpb24ocmVzKXtcbiAgICAgICAgaWYocmVzLmhvcClcbiAgICAgICAgICBjbG91ZC5ob3AocmVzLmhvcClcbiAgICAgICAgZWxzZSBpZihjYilcbiAgICAgICAgICBjYihyZXMpXG4gICAgICB9KVxuICAgICBcbiAgICAgIGlmKCFyZSl7XG4gICAgICAgIGNsb3VkLm9uKCdjb25uZWN0JywgcmVBdXRoKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZUF1dGgoKXtcbiAgICAgICAgY29uc29sZS5lcnJvcignY29ubmVjdCAtPj4+IHJlQXV0aD8nKVxuICAgICAgICBpZihjbG91ZC5fc3RhdHVzID4gMil7XG4gICAgICAgICAgY29uc29sZS5lcnJvcigncmVjb25uZWN0IC0+Pj4gcmVBdXRoIScsIHJlcSlcbiAgICAgICAgICBjbG91ZC5hdXRoZW50aWNhdGUocmVxLCBjYiwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2xvdWQuX3JlQXV0aCA9IHJlQXV0aFxuICAgIH1cbiAgLCAnbG9nb3V0JywgZnVuY3Rpb24gbG9nb3V0KHVzZXJpZCl7XG4gICAgICB2YXIgY2xvdWQgPSB0aGlzXG5cbiAgICAgIGNsb3VkLmVtaXQoJ2xvZ291dCcsIHVzZXJpZClcblxuICAgICAgaWYoXG4gICAgICAgIGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXSAmJiBcbiAgICAgICAgIGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXS5hY3RpdmVDbGllbnQgXG4gICAgICAgICAmJiBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0uYWN0aXZlQ2xpZW50LmZyb20uX25hbWUgPT09IGNsb3VkLmNsaWVudGlkXG4gICAgICAgKSBcbiAgICAgICB7XG4gICAgICAgICBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0uYWN0aXZlQ2xpZW50LnJlbW92ZSgpXG4gICAgICAgfVxuXG4gICAgICBcbiAgICAgIHZhciBzdGFtcCA9IGNsb3VkLnN0YW1wXG5cbiAgICAgIGlmKHVzZXJpZCl7XG4gICAgICAgIGlmKGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXSlcblxuICAgICAgICBpZiggXG4gICAgICAgICAgY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdLmFjdGl2ZUNsaWVudCBcbiAgICAgICAgICAmJiBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0uYWN0aXZlQ2xpZW50LmZyb20uX25hbWUgPT09IGNsb3VkLmNsaWVudGlkKSBcbiAgICAgICAge1xuICAgICAgICAgIGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXS5hY3RpdmVDbGllbnQuZnJvbSA9IGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXS5hY3RpdmVDbGllbnRcbiAgICAgICAgfVxuXG4gICAgICAgIGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXS5yZW1vdmUodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBzdGFtcClcbiAgICAgICAgLy8gZWxzZVxuICAgICAgICAvLyAgIGNvbnNvbGUuZXJyb3IoJ3RoYXQgdXNlciBkb2VzIG5vdCBleGlzdCcpXG4gICAgICB9IGVsc2V7XG4gICAgICAgIGNsb3VkLmRhdGEudXNlcnMuZWFjaChmdW5jdGlvbih1c2VyaWQpe1xuICAgICAgICAgIHRoaXMucmVtb3ZlKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgc3RhbXApXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIGNsb3VkLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIGNsb3VkLl9yZUF1dGgpXG4gICAgICBjbG91ZC5fcmVBdXRoID0gbnVsbFxuXG4gICAgfVxuICApXG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogTWFyY3VzIEJlc2plcywgbWFyY3VzQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi8uLi91dGlsJyApXG4gICwgTmV0d29ya0RhdGEgPSByZXF1aXJlKCAnLi4vZGF0YScgKVxuICAgIC5pbmplY3QoIHJlcXVpcmUoICcuLi8uLi8uLi9vYmplY3QvaGFzaHBhdGgnICkgKVxuICAgIC8vVE9ETzogYWRkIGxvY2Fsc3RvcmFnZSAtLT4gLCAhdXRpbC5pc05vZGUgJiYgcmVxdWlyZSgnLi4vLi4vLi4vb2JqZWN0L2xvY2Fsc3RvcmFnZScpXG4gICwgbmV0d29ya0RhdGFFbGVtZW50ID0gcmVxdWlyZSggJy4uL2RhdGEvZWxlbWVudCcgKVxuICAsIERhdGEgPSByZXF1aXJlKCAnLi4vLi4vLi4vZGF0YScgKVxuICAsIHByZXZlbnRVcGRhdGVcbiAgLCB2T2JqZWN0ID0gcmVxdWlyZSggJy4uLy4uLy4uL29iamVjdCcgKVxuICAsIG1vbm9TdGFtcCA9IHJlcXVpcmUoICdtb25vdG9uaWMtdGltZXN0YW1wJyApXG4gICwgQ2xvdWREYXRhID0gTmV0d29ya0RhdGEubmV3XG4gICAgKCBmYWxzZSAvL3B1dCBzb21lIHNldHRpbmdzIVxuICAgICwgZnVuY3Rpb24gQ2xvdWREYXRhKCB2YWwsIGhvb2ssIHBhcmVudCwgY2xvdWQgKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXNcblxuICAgICAgICBpZiggY2xvdWQgKVxuICAgICAgICB7XG4gICAgICAgICAgX3RoaXMuY2xvdWQgPSBjbG91ZFxuICAgICAgICAgIF90aGlzLmFkZExpc3RlbmVyKGNkTGlzdGVuZXIpXG5cbiAgICAgICAgICBpZighdXRpbC5pc05vZGUgJiYgISF3aW5kb3cuY29yZG92YSkgXG4gICAgICAgICAge1xuXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwYXVzZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAvL1RPRE86IHRoaXMgZG9lcyBub3Qgd29yayB5ZXQgLS0gbWFrZSBwcmV2ZW50IHVwZGF0ZSBhIHVzYWJsZSB0aGluZyBpbiBhcHAgbG9naWMgKCBlLmcuIGluIGRldmljZSBsaXN0cyBvciBjbGllbnRzIClcbiAgICAgICAgICAgICAgX3RoaXMucHJldmVudFVwZGF0ZSA9IHRydWVcbiAgICAgICAgICAgIH0sIGZhbHNlKVxuXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXN1bWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGNsb3VkLmtpY2tQaW5nKClcblxuICAgICAgICAgICAgICBpZiggX3RoaXMudGltZW91dCApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoIF90aGlzLnRpbWVvdXQgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKCBfdGhpcy5kZWZlcmVkICkgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX3RoaXMubWVyZ2UoIF90aGlzLmRlZmVyZWQuZGF0YSwgZmFsc2UsIF90aGlzLmRlZmVyZWQuc3RhbXAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5wcmV2ZW50VXBkYXRlID0gbnVsbFxuICAgICAgICAgICAgICAgIF90aGlzLmRlZmVyZWQgPSBudWxsXG4gICAgICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IG51bGxcbiAgICAgICAgICAgICAgfSwgMTAwIClcbiAgICAgICAgICAgICAgLy8gX3RoaXMucHJldmVudFVwZGF0ZSA9IHRydWUgLy93YWl0IGZvciBhbm90aGVyIHVwZGF0ZSBhbmQgdGltZW91dFxuICAgICAgICAgICAgfSwgZmFsc2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2xvdWQub25cbiAgICAgICAgICAoICdzZXQnXG4gICAgICAgICAgLCBmdW5jdGlvbiggZGF0YSApIHtcbiBcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuY2xlYXIoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjb25zb2xlLmdyb3VwKClcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdcXG4tLS0tLS0tLS0tLUlOQ09NSU5HIENMT1VELS0tLS0tLVxcbicsIGRhdGEgKVxuXG4gICAgICAgICAgICAvLyBpZigpXG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGRhdGEsIGZhbHNlLCAyKS5zbGljZSgwLDIwMCkpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKClcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGRhdGEsIGZhbHNlLCAyKSlcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSU5DT01JTkchXFxuJywgSlNPTi5zdHJpbmdpZnkoZGF0YSkpXG4gICAgICAgICAgICAgIHZhciBzZXQgPSBkYXRhLnNcbiAgICAgICAgICAgICAgICAsIHZjbG9jayA9IGRhdGEudlxuICAgICAgICAgICAgICAgIC8vICwgc3RhbXBzID0gdmNsb2NrWzFdXG4gICAgICAgICAgICAgICAgLCBzdWJzID0gY2xvdWQuc3RhdGUuc3Vicy5tYXBcbiAgICAgICAgICAgICAgICAsIHN1YnN0YW1wID0gdmNsb2NrWzFdXG5cbiAgICAgICAgICAgICAgaWYoIHZjbG9ja1swXSBpbnN0YW5jZW9mIEFycmF5IClcbiAgICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgICAgLy92Y2xvY2sgd2hlcmUgaXMgaXQ/Pz8/Pz9cblxuICAgICAgICAgICAgICAgIGZvciggdmFyIGkgPSB2Y2xvY2tbMF0ubGVuZ3RoOyBoYXNoID0gdmNsb2NrWzBdWy0taV07IClcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB1cGRhdGVTdWIoIHN1YnNbaGFzaF0sIHN1YnN0YW1wIClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVTdWIoIHN1YnNbZGF0YS52WzBdXSwgc3Vic3RhbXAgKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gc3Vic3RhbXAgPSAwXG5cbiAgICAgICAgICAgICAgLy8gZm9yKCB2YXIgcyBpbiBzdGFtcHMgKVxuICAgICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coJ2J1cnJyJywgc3RhbXBzW3NdKVxuICAgICAgICAgICAgICAvLyAgIGlmKCBzdGFtcHNbc10gPiBzdGFtcCApIHN0YW1wID0gc3RhbXBzW3NdXG4gICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICB2YXIgc3RhbXAgPSBtb25vU3RhbXAoKVxuICAgICAgICAgICAgICBjbG91ZC5zdGFtcCA9IHN0YW1wXG5cbiAgICAgICAgICAgICAgLy8gX3RoaXMuX3RpbWVcblxuICAgICAgICAgICAgICBpZiggIV90aGlzLnByZXZlbnRVcGRhdGUgKSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF90aGlzLm1lcmdlKCBkYXRhLnMsIGZhbHNlLCBzdGFtcCApXG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmKCFfdGhpcy5kZWZlcmVkKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIC8vcGF1c2UgZ2VlbiB0aW1lb3V0IGFsbGVlbiBtYWFyIHVpdHN0ZWxsZW5cbiAgICAgICAgICAgICAgICAgIF90aGlzLmRlZmVyZWQgPSBcbiAgICAgICAgICAgICAgICAgIHsgZGF0YTogZGF0YS5zXG4gICAgICAgICAgICAgICAgICAsIHN0YW1wOiBzdGFtcFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLmRlZmVyZWQuc3RhbXAgPSBzdGFtcFxuICAgICAgICAgICAgICAgICAgX3RoaXMuZGVmZXJlZC5kYXRhID0gdXRpbC5tZXJnZSggX3RoaXMuZGVmZXJlZC5kYXRhLCBkYXRhLnMpXG4gICAgICAgICAgICAgICAgICAvLyBfdGhpcy5kZWZlcmVkLmRhdGEuX3VwZGF0ZSggZGF0YS5zIClcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgKVxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiggcGFyZW50IClcbiAgICAgICAge1xuICAgICAgICAgIF90aGlzLmNsb3VkID0gcGFyZW50LmNsb3VkXG4gICAgICAgIH1cblxuICAgICAgfVxuICAgIClcbiAgLCBfX3VwZGF0ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IENsb3VkRGF0YVxuXG5mdW5jdGlvbiB1cGRhdGVTdWIoIGNhY2hlZCwgdmNsb2NrICkge1xuICBpZiggIWNhY2hlZCApIHJldHVyblxuXG4gIHJldHVybiAvLyBub3QgaW1wbGVtZW50ZWRcblxuICAvLyB2YXIgc3ViID0gY2FjaGVkLnN1YnNvYmpcbiAgLy8gaWYoICFzdWIuX3YgKSBzdWIuc2V0KCAnX3YnLCB7fSApXG5cbiAgLy8gZm9yKCB2YXIgZiBpbiB2Y2xvY2sgKVxuICAvLyB7XG4gIC8vICAgc3ViLl92LnNldCggZiwgdmNsb2NrW2ZdIClcbiAgLy8gfVxuXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN1YiggcGF0aCwgc3ViLCBwYXJ0aWFsU3ViICkge1xuXG4gIGlmKCBwYXRoLmxlbmd0aCApXG4gIHtcbiAgICB1dGlsLnBhdGgoIHN1YiwgcGF0aCwgcGFydGlhbFN1YiwgdHJ1ZSApXG4gICAgcmV0dXJuIHN1YlxuICB9XG4gIGVsc2VcbiAge1xuICAgIHJldHVybiBwYXJ0aWFsU3ViXG4gIH1cblxufVxuXG5mdW5jdGlvbiB0NHdhbGtlciggdmFsICkge1xuLy9UT0RPOiByZW1vdmUgJHQ6NFxuICBmb3IoIHZhciBpIGluIHZhbCApXG4gIHtcblxuICAgIGlmKHZhbFtpXSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICB7XG5cbiAgICAgIGlmKHZhbFtpXSBpbnN0YW5jZW9mIHZPYmplY3QpXG4gICAgICB7XG4gICAgICAgIHZhbFtpXSA9IHsgJHBhdGg6IHZhbFtpXS5fcGF0aCB9IC8vICR0OiA0IFxuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICB0NHdhbGtlciggdmFsW2ldIClcbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbn1cblxuZnVuY3Rpb24gY2RMaXN0ZW5lciggdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkICl7XG4gIHZhciBjbG91ZCA9IHRoaXMuY2xvdWRcbiAgLy8gY29uc29sZS5sb2coJ09PT08gY2xvdWRhdGEgbGlzdGVuZXJidXInLCB0aGlzLl9wYXRoLCB2YWwpXG4gIGlmKCBzdGFtcCA9PT0gJ2xvY2FsU3RvcmFnZScgfHwgc3RhbXA9PT1mYWxzZSAgKVxuICB7XG4gICAgLy8gY29uc29sZS5sb2coJ0kgV0lMTCBOT1QgVVBEQVRFJy5yZWQuaW52ZXJzZSlcbiAgICAvLyBjb25zb2xlLmxvZygnQ2xvdWQgZnJvbSBsb2NhbHN0b3JhZ2UnLmludmVyc2UucmVkKVxuICAgIHJldHVyblxuICB9XG5cblxuICBpZiggc3RhbXAgIT09IGNsb3VkLnN0YW1wICYmIHZhbCAhPT0gdm9pZCAwIClcbiAge1xuXG4gICAgLy8gY29uc29sZS5sb2coJz4+Pj4+PiBzaGluZXInKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ1xcblxcblxcblxcblxcbnVwZGF0ZSBjbG91ZCcsIHZhbClcblxuXG5cbiAgICBpZiggcmVtb3ZlICYmIGZyb20gKVxuICAgIHtcbiAgICAgIGlmKCBmcm9tLl9yZW1vdmVkIClcbiAgICAgIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnISEhISEhVVBEQVRFIENMT1VEISEhJywgZnJvbSAmJiBmcm9tLl9wYXRoLCB2YWwsIHN0YW1wKVxuXG4gICAgICAgIGNsb3VkLnNldChmcm9tLl9oYXNocGF0aCwgW2Zyb20uX3BhdGgsIG51bGwsIGNsb3VkLnRpbWVTdGFtcCgpXSlcbiAgICAgIH1cblxuICAgIH1cbiAgICBlbHNlIGlmICggZnJvbSAmJiAhdGhpcy5fY2xvdWRpZ25vcmUgKVxuICAgIHtcblxuXG4gICAgICAvLyBpZiggc3RhbXAgPT09IHZvaWQgMCApIHtcbiAgICAgIC8vICAgYWxlcnQoJ1gnKVxuICAgICAgLy8gfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2NjY2NjY2NjY2NjYyB1cGRhdGUhJywgdGhpcy5fcGF0aCAsIGZyb20uX3VwZGF0ZU9yaWdpbiwgZnJvbS5fY2FjaGVkUGF0aClcblxuICAgICAgLy8gY29uc29sZS5lcnJvcignX3VwZGF0ZSBPcmlnaW4gY2FsbCBmcm9tIGNsb3VkLmRhdGEnKSBcbiAgICAgIGlmKCBmcm9tLl91cGRhdGVPcmlnaW4gPT09IGZyb20gKSAvL2hpZXIgZ2FhdCBpZXRzIG1pc1xuICAgICAge1xuICAgICAgICBpZiggZnJvbS5fX3QgPT09IDIgJiYgdmFsIGluc3RhbmNlb2YgT2JqZWN0ICkge1xuLy8gICAgICAgICAgIGNvbnNvbGUubG9nKGZyb20sIHZhbClcbiAgICAgICAgICB0NHdhbGtlcih2YWwpXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vW1widXNlcnNcIiwgXCJVX2ZlN2NjODAwMTM2Yjc2MDhcIiwgXCJjbGllbnRzXCIsIFwiVl9rdWNvMnpzMnFmXCJdXG4gICAgICAgIHZhciBwID0gZnJvbSYmZnJvbS5fcGF0aFxuICAgICAgICBpZihwICYmIHBbMF0gPT09ICd1c2VycycgJiYgcFtwLmxlbmd0aC0yXSAmJiBwW3AubGVuZ3RoLTJdID09PSAnY2xpZW50cycgKSB7XG4gICAgICAgICAgLy9UT0RPOiB2ZXJ5IGRpcnR5IGZpeCFcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdicmVhayBpdCBkb3duIScsIHAsIHAsIHZhbCApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuICAgICAgICBpZihwICYmIHBbMF0gPT09ICd1c2VycycgJiYgcFsxXSA9PT0gJ21lZGlhJykge1xuICAgICAgICAgIHRocm93KG5ldyBFcnJvcignVEhJUyBJUyBXUk9ORyBBQk9SVCEtLS0+IHNldHRpbmcgdXNlcnMubWVkaWEgJytwLmpvaW4oJy4nKSkpXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignVEhJUyBJUyBXUk9ORyBBQk9SVCEtLS0+IHNldHRpbmcgdXNlcnMubWVkaWEnLCBwKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cblxuICAgICAgICBjbG91ZC5zZXRcbiAgICAgICAgKCBmcm9tLl9oYXNocGF0aFxuICAgICAgICAsIFsgZnJvbS5fcGF0aFxuICAgICAgICAgICwgZnJvbS5fX3QgPT09IDQgPyB7ICAkcGF0aDogdmFsLl9wYXRoIH0gOiB2YWwgLy8kdDogNCxcbiAgICAgICAgICAsIGNsb3VkLnRpbWVTdGFtcCgpXG4gICAgICAgICAgXVxuICAgICAgICApXG5cbiAgICAgIH1cblxuICAgIH1cblxuICB9XG5cbn1cblxuQ2xvdWREYXRhLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ2Nsb3VkJywgJ2RhdGFjbG91ZCcsICdfYmF0Y2hVbnN1YicsJ19jbG91ZGlnbm9yZScsICdfbHN0YW1wJywgJyR0JywgJyRsb2FkZWQnLCAnX2Zyb21sZnJvbScpXG5cbl9fdXBkYXRlID0gQ2xvdWREYXRhLnByb3RvdHlwZS5fX3VwZGF0ZVxuXG5DbG91ZERhdGEuaW5qZWN0KCByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0L2ZsYWdzJykgKVxuXG5DbG91ZERhdGEuZmxhZ3MuJHBhdGggPSB7XG4gIHJlc2V0OnRydWUsXG4gIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQpIHtcbiAgICBcbiAgICBpZiggcmVzZXQgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsb3VkIGRhdGEgJHBhdGggZmxhZyByZXNldD8/PycpXG4gICAgfVxuICBcbiAgICB2YXIgdCA9IHRoaXNcbiAgICBpZihzdGFtcCAhPT0gdGhpcy5jbG91ZC5zdGFtcCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZXQgd2l0aCAkcGF0aCBvbmx5IGFsbG93ZWQgZnJvbSB0aGUgaHViJylcbiAgICB9XG5cbiAgICB2YXIgcGF0aCA9IHV0aWwuY2hhbmdlVHlwZSggdmFsIClcbiAgICBpZihwYXRoLmxlbmd0aCl7XG4gICAgICAvLyBjb25zb2xlLmxvZygnX19fX19fX19fX18gJHBhdGggc2V0JylcbiAgICAgICAvLyB2YWwsIHNldCwgbm90c2VsZiwgc3RhbXAgXG4gICAgICAgLy8gbm91cGRhdGVcbiAgICAgIHRoaXMuXyRzZXRWYWwoIHRoaXMuY2xvdWQuZGF0YS5nZXQoIHBhdGgsIHt9LCB2b2lkIDAsIHN0YW1wICkgLHN0YW1wLGZhbHNlLHRydWUpXG4gICAgfVxuXG4gICAgaWYodGhpcy5fX3QhPT00KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsb3VkIGRhdGEgJHBhdGggZmxhZyBfX3QgIT09IDQnKVxuICAgIH1cblxuICB9XG59XG5cblxudmFyIF9zZXQgPSBDbG91ZERhdGEucHJvdG90eXBlLnNldFxuXG52YXIgXyRzZXRWYWwgPSBDbG91ZERhdGEucHJvdG90eXBlLl8kc2V0VmFsXG5cbi8vQ2xvdWREYXRhIGFkZCBmbGFnc1xuXG4vLyggbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb20gKVxudXRpbC5kZWZpbmVcbiggQ2xvdWREYXRhXG4sICdfJHNldFZhbCcsIGZ1bmN0aW9uKCB2YWwsIHN0YW1wICkge1xuICAgLy9zZXRWYWxcblxuICAgLy8gY29uc29sZS5sb2coJy4uLi4uLi4uLi4uLi4nLCB0aGlzLl9wYXRoLCBzdGFtcCwgc3RhbXAgJiYgdGhpcy5jbG91ZC5zdGFtcCA9PT0gc3RhbXApXG4gICBpZih0aGlzLmNsb3VkLnN0YW1wID09PSBzdGFtcCAmJiAhdGhpcy4kbG9hZGVkKSB7XG4gICAgLy9UT0RPOiBmYXN0ZXIgdG8gZG8gISBsb2FkZWRcbiAgICB2YXIgcGFyZW50ID0gdGhpc1xuICAgIHdoaWxlKHBhcmVudCAmJiAhcGFyZW50LiRsb2FkZWQpIHtcbiAgICAgIHBhcmVudC4kbG9hZGVkID0gdHJ1ZVxuICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnRcbiAgICB9XG4gICB9XG5cbiAgIF8kc2V0VmFsLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICB9XG4sICdzZXQnLCBmdW5jdGlvbihuYW1lLCB2YWwsIHZvYmosIHN0YW1wKXtcbiAgaWYgKHN0YW1wICE9PSB0aGlzLmNsb3VkLnN0YW1wICYmXG4gICAgICB0aGlzLl9uYW1lID09PSAnY2xpZW50cycgJiZcbiAgICAgICF0aGlzW25hbWVdICYmIFxuICAgICAgbmFtZSAhPT0gdGhpcy5jbG91ZC5jbGllbnRpZFxuICAgICApIHtcbiAgICBjb25zb2xlLmVycm9yKCdcXG5cXG5JIFdBTlQgVE8gQkxPQ0sgVEhJUyBZQSBEVVJLJyxcbiAgICAgICdcXG5zdGFtcCAhPT0gdGhpcy5jbG91ZC5zdGFtcCcsIHN0YW1wICE9PSB0aGlzLmNsb3VkLnN0YW1wLFxuICAgICAgXCJcXG50aGlzLl9uYW1lID09PSAnY2xpZW50cydcIiwgdGhpcy5fbmFtZSA9PT0gJ2NsaWVudHMnLFxuICAgICAgXCJcXG4hdGhpc1tuYW1lXVwiLCAhdGhpc1tuYW1lXSxcbiAgICAgIFwiXFxubmFtZSAhPT0gdGhpcy5jbG91ZC5jbGllbnRpZFwiLCBuYW1lICE9PSB0aGlzLmNsb3VkLmNsaWVudGlkXG4gICAgKVxuICAgIGRlYnVnZ2VyXG4gICAgLy8gcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIF9zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuLCAndXBkYXRlUXVldWUnXG4sIGZ1bmN0aW9uKCkge1xuICAgIC8vIHdoeSB0aGlzPz8/XG4gIH1cbiwgJ3N0YW1wJ1xuLCBmdW5jdGlvbigpe1xuICAgIGlmKCAhdGhpcy5jbG91ZCApIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoICdXQVQgTk8gQ0xPVUQ/ISBpbiB0aGlzOlxcbicsIHRoaXMgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb3VkLnRpbWVTdGFtcCgpXG4gIH1cbiwgJ19fdXBkYXRlJ1xuLCBmdW5jdGlvbiggdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsICkge1xuXG4gICAgLy8gaWYoc3RhbXAgJiYgdGhpcy5fbHN0YW1wID09PSBzdGFtcCkgcmV0dXJuXG5cblxuICAgIC8vIGNvbnNvbGUubG9nKGZyb20sICdcXG4nLCB0aGlzLl9sZnJvbSwgZnJvbSwgZnJvbSYmZnJvbS5fbGZyb20uX2NhY2hlZFBhdGgsIHRoaXMuX2NhY2hlZFBhdGgsIHRoaXMuX2xmcm9tKVxuICAgIGlmKGZyb20gJiYgZnJvbS5fbGZyb20pIHtcblxuICAgICAgdGhpcy5fZnJvbWxmcm9tID0gZnJvbS5fbGZyb21cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IodGhpcy5fZnJvbWxmcm9tKVxuICAgICAgLy8gcmV0dXJuXG4gICAgfVxuXG4gICAgaWYodGhpcy5fZnJvbWxmcm9tICYmIHRoaXMuX2Zyb21sZnJvbSA9PT0gKGZyb20gJiYgZnJvbS5fbGZyb20pICYmIHRoaXMuX2xzdGFtcD09PXN0YW1wKSB7XG4gICAgICAvL1RPRE86IHRoaXMgaXMgYSBtZW1vcnkgbGVhayBnZXQgcmlkIG9mIGl0IGNpcmMgcmVmcyBzaG91bGQgYmUgcmVzb2x2ZWQgZnJvbSB2b2JqIGl0c2VsZlxuICAgICAgZGVsZXRlIHRoaXMuX2Zyb21sZnJvbVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5fbHN0YW1wID0gc3RhbXBcblxuICAgIC8vIGlmKHRoaXMuX3BhdGhbMF09PT0nY2xpZW50cycpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKCcyJywgdGhpcy5fcGF0aCwgc3RhbXA9PT10aGlzLmNsb3VkLnN0YW1wKVxuICAgIC8vIH1cbiAgICAvLyBjb25zb2xlLmxvZygnMSBsZXRzIF9fdXBkYXRlJywgdGhpcy5fcGF0aCwgYXJndW1lbnRzKVxuICAgIC8vIGlmKCB0aGlzLl9pZ25vcmUgICkge1xuICAgICAgLy8gY29uc29sZS5sb2coJzIxIGxldHMgX191cGRhdGUnLCB0aGlzLl9wYXRoLCBhcmd1bWVudHMpXG4gICAgICAvLyBkZWxldGUgdGhpcy5faWdub3JlXG4gICAgICAvLyByZXR1cm4gZmFsc2VcbiAgICAvLyB9XG4gICAgLy9tb3N0IG5lc3RlZCB1cGRhdGUgaGllciBhZGRpdGlvbiBtYWtlbiB2b29yIHByb2Nlc3NcbiAgICAvLyBjb25zb2xlLmxvZyh2YWwsIHN0YW1wLCBmcm9tKVxuICAgIC8vaXMgZGl0IG1heWJlIHdlaXJkPz8/XG4gICAgcmV0dXJuIF9fdXBkYXRlLmNhbGwoIHRoaXMsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApXG4gIH1cbiwgJ19zZXQnXG4sIGZ1bmN0aW9uICh2YWwsIHN0YW1wKSB7XG4gICAgaWYoICFzdGFtcCApIHJldHVyblxuICAgIGlmKCB0aGlzLl9sc3RhbXAgPiBzdGFtcCApXG4gICAge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCdsZXRzIHNldCBpdCEhIScsIHRoaXMuX3BhdGgsIGFyZ3VtZW50cylcblxuICAgIHJldHVybiBOZXR3b3JrRGF0YS5wcm90b3R5cGUuX3NldC5hcHBseSggdGhpcyxhcmd1bWVudHMgKVxuICB9XG4sICdzdWJzY3JpYmUnXG4sIGZ1bmN0aW9uKCB2YWwsIGZyb20sIHBhcmVudEZpeGVyICkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc3RhcnQnKVxuXG4gICAgaWYoIGZyb20gJiYgZnJvbS5jbG91ZCAgJiYgZnJvbS5fdmFsID09PSB0aGlzICkge1xuXG4gICAgICAgIC8vQlVHOiBkaXQga2FuIGhlZWwgdmVlbCBicm9rZW4gbWFrZW4hISEhISEhXG4vLyAgICAgICAgIGNvbnNvbGUubG9nKCdcXG5cXG5IVVJLISEhISEhIERJVCBJUyBURU1QIE1PRVQgTklFVCBFRU4gRVhUUkEgU1VCIEdFTUFBS1QgV09SREVOIScgKVxuXG4gICAgICAgIC8vIGZyb20gPSB2b2lkIDBcblxuICAgICAgICAvL1RPRE86IGRpdCBpcyBoZWxlbWFhbCB3cm9uZyBHRVQgUklEIE9GIElUISEhIVxuICAgICAgICAvLyByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ2xldHMgZG8gaXQgc3ViIHN1YicuY3lhbi5pbnZlcnNlLCB0aGlzLCB2YWwsIGZyb20sIHBhcmVudEZpeGVyIClcbiAgICAvLyBpZihmcm9tKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnR09UIEZST00nLCBmcm9tICwgJ1NVQlNDUklCRScpXG4gICAgLy8gfVxuICAgICBpZiAoIXZhbCB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7IHJldHVybjsgfVxuICAgICAvLyBpZih2YWwgaW5zdGFuY2VvZiB2T2JqZWN0KSB7XG4gICAgIC8vICAgIHZhbCA9IHZhbC5mcm9tXG4gICAgIC8vIH1cblxuXG4gICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aFxuICAgICAgICwgZWxlbSA9IHZhbFsxXVxuICAgICAgICwgc3ViXG4gICAgICAgLCBwYXJ0aWFsU3ViXG4gICAgICAgLCBzdHJpbmdpZmllZFxuICAgICAgICwgc3Vic0FycmF5XG4gICAgICAgLCBleGlzdHNcbiAgICAgICAsIGxpc3RlbmVyc1xuICAgICAgICwgZnJvbU5hbWVcblxuICAgICAgdmFyIGZvdW5kID0gcGF0aCAmJiB1dGlsLmNoZWNrQXJyYXkoIHBhdGggLCAndXNhZ2UnIClcbiAgICBcblxuXG4gICAgLy8gaWYoIGZvdW5kIHx8IGZvdW5kPT09MCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2xldHMgdHJ5IHRvIHN1YicsIHZhbCAmJiB2YWwuX3BhdGgsICc6JywgdGhpcy5fcGF0aCApXG4gICAgICAvLyB9XG4gICBcblxuICAgIC8vIGlmKGVsZW0pIHtcbiAgICAvLyAgIGNvbnNvbGUuZXJyb3IoZWxlbSwgZWxlbS5fY29sLCBlbGVtLl9kZnJvbSwgZWxlbS5fZm1vZGVsKVxuICAgIC8vIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdTVUJTQ1JJQkUnLCBlbGVtLl9kZnJvbSwgZWxlbS5fZm1vZGVsLCAnREZST00sIEZNT0RFTCEnKVxuXG4gICAgLy8gaWYgKGVsZW0gJiYgIWVsZW0uX2NvbCAmJiAoIWVsZW0uX2Rmcm9tIHx8IGVsZW0uX2Ztb2RlbCkpIHtcbiAgICB2YXIgaXNFbGVtID0gKGVsZW0gJiYgIWVsZW0uX2NvbCAmJiAoIWVsZW0uX2Rmcm9tIHx8IGVsZW0uX2Ztb2RlbCkpXG5cbiAgICBpZiggaXNFbGVtICYmICFlbGVtLmdldE1vZGVsKSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdiZSBjYXJlZnVsbCEgY2xvdWQgZGF0YSBlbGVtIGRvZXMgbm90IGhhdmUgZ2V0TW9kZWwnKVxuICAgIH0gZWxzZSBpZiggaXNFbGVtICkge1xuXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdYWFghJylcbiAgICAgIC8vaGllciBkaW5nZW4gdmluZGVuIHZvb3JcbiAgICAgIC8vIGNvbnNvbGUubG9nKCchREZST00hJylcblxuICAgIC8vaXNFbGVtXG5cbiAgICAvL3ZhbCwgZnJvbSwgcGFyZW50Rml4ZXJcblxuICAgIC8vIGlmKHZhbFszXSAmJiB2YWxbM10gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIC8vICAgICAgIGNvbnNvbGUubG9nKCAnWUVTISEhJyApXG5cbiAgICAvLyB9XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJyEhISEhITExMTExMScsIGFyZ3VtZW50cywgdmFsWzNdLCBmcm9tLCBwYXJlbnRGaXhlciwgdGhpcywgcGF0aCApXG5cbiAgICB2YXIgZmllbGRpZ25vcmVcbiAgICBpZiggdmFsWzFdLl9pZ25vcmVGaWVsZEluU3Vic2NyaXB0aW9uICkge1xuICAgICAgLy8gYWxlcnQoJyEnK3ZhbFszXSlcbiAgICAgIGlmKCF2YWxbM10pIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0ZJRUxESUdOT1JFJy5ibHVlLmludmVyc2UsIHZhbCwgdGhpcywgcGF0aCApXG4gICAgICAgIC8vIGRlYnVnZ2VyXG5cbiAgICAgICAgLy8gaWYoZmkpXG5cbiAgICAgICAgZmllbGRpZ25vcmUgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9UT0RPOiBoYXMgdG8gYmVjb21lIHZhbFsyXSEhIVxuICAgIC8vdHlwZW9mIGZyb20gPT09ICdzdHJpbmcnID8gZnJvbSA6XG4gICAgICAvL2RpdCBpcyBuaWV0IGdvZWQhISEhXG4gICAgICBmcm9tTmFtZSA9IHZhbFszXVxuXG4gICAgLy8gY29uc29sZS5sb2coICctLS0tLS0tLTIyISEhISEhMTExMTExJywgcGFydGlhbFN1YiwgdmFsWzNdLCAnXFxuXFxuPycsIHZhbFszXS5fbmFtZSAgKVxuXG4gICAgICAvL3ZhbFszXSBpbnN0YW5jZW9mIERhdGFcbiAgICAgIHBhcnRpYWxTdWIgPSBlbGVtLmdldE1vZGVsKCB0aGlzLCAgdmFsWzNdICwgZmllbGRpZ25vcmUgKVxuICAgICAgLy8gY29uc29sZS5jbGVhcigpXG4gICAgLy8gY29uc29sZS5sb2coICctLS0tISEhISEhMTExMTExJywgcGFydGlhbFN1YiApXG4gICAgICAvLyBpZihwYXJ0aWFsU3ViICYmIHBhcnRpYWxTdWIuc3BlY2lhbEZpeCkge1xuICAgICAgLy8gICBjb25zb2xlLmxvZygnTEVUUyBETyBJVCBJVEkgSVQnLCBwYXJ0aWFsU3ViLCBwYXJ0aWFsU3ViLnNwZWNpYWxGaXgsIHBhdGgpXG4gICAgICAgIFxuICAgICAgLy8gICAvLyBpZihwYXJ0aWFsU3ViLnNwZWNpYWxGaXggaW5zdGFuY2VvZiBBcnJheSApIHtcblxuICAgICAgLy8gICAvLyAgIGNvbnNvbGUubG9nKCBwYXRoLCBwYXJ0aWFsU3ViLnNwZWNpYWxGaXgsIHBhcnRpYWxTdWIgKVxuICAgICAgLy8gICAvLyAgIGlmKHBhdGhbcGF0aC5sZW5ndGgtMV0gPT09IHBhcnRpYWxTdWIuc3BlY2lhbEZpeFswXSkge1xuXG4gICAgICAvLyAgIC8vICAgICBpZihwYXJ0aWFsU3ViLiQgJiYgcGFydGlhbFN1Yi4kW3BhcnRpYWxTdWIuc3BlY2lhbEZpeFsxXV0pIHtcbiAgICAgIC8vICAgLy8gICAgICAgICBjb25zb2xlLmxvZygnZG8gaXQhJylcbiAgICAgIC8vICAgLy8gICAgICAgICBwYXJ0aWFsU3ViID0gcGFydGlhbFN1Yi4kW3BhcnRpYWxTdWIuc3BlY2lhbEZpeFsxXV1cbiAgICAgIC8vICAgLy8gICAgIH1cblxuICAgICAgLy8gICAvLyAgIH1cblxuICAgICAgLy8gICAvLyB9IGVsc2UgXG5cbiAgICAgIC8vICAgaWYocGF0aFtwYXRoLmxlbmd0aC0xXT09PXBhcnRpYWxTdWIuc3BlY2lhbEZpeCkge1xuICAgICAgLy8gICAgIHBhdGgucG9wKClcbiAgICAgIC8vICAgfVxuICAgICAgICBcbiAgICAgIC8vICAgZGVsZXRlIHBhcnRpYWxTdWIuc3BlY2lhbEZpeFxuICAgICAgLy8gfVxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnTEVUUyBETyBJVCBJVEkgSVQnLmdyZWVuLmludmVyc2UsIHBhcnRpYWxTdWIpXG5cbiAgICAgIC8vIHBhcnRpYWxTdWIuREVCVUckbG9nKCdwYXJ0aWFsJylcblxuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRGF0YSAmJiB2YWwuX19zdWIpIHtcbiAgICAvL2lzRGF0YStTdWJzY3JpcHRpb25cbiAgICAgIC8vZGl0IG1vZXQgb29rIGdlZml4ZWQhISEhISEhISFcbiAgICAgIHBhcnRpYWxTdWIgPSBuZXR3b3JrRGF0YUVsZW1lbnQucGFyc2VEYXRhKHZhbClcblxuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2Ygdk9iamVjdCApIHtcbiAgICAvL3ZPYmplY3RcbiAgICAgIGxpc3RlbmVycyA9IHZhbC5fbGlzdGVuZXJzXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuX3BhdGgsICdMSVNURU5FUicsIGZyb20gKVxuXG4gICAgICBpZihsaXN0ZW5lcnMpIHtcbiAgICAgICAgZm9yKCB2YXIgbGlzdGVuZXIkPTAsIGxlbiQ9bGlzdGVuZXJzLmxlbmd0aDsgbGlzdGVuZXIkPGxlbiQ7IGxpc3RlbmVyJCsrICkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCchISEhISEhISEhISBsaXN0bmVyJDMzMzMzMycucmVkLmludmVyc2UsIGxpc3RlbmVyc1tsaXN0ZW5lciRdKVxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLT4nLHRoaXMuX3BhdGgsICdMSVNURU5FUiwgJyAsIGxpc3RlbmVyc1tsaXN0ZW5lciRdLl9wYXRoLCB2YWwpXG4gICAgICAgICAgdGhpcy5zdWJzY3JpYmUoIGxpc3RlbmVyc1tsaXN0ZW5lciRdLCB2YWwgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmKHZhbC5fcGFyZW50ICYmICF2YWwuX3BhcmVudC5jbG91ZCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncGFyZW50Jyx2YWwuX3BhcmVudCwgdmFsLl9wYXJlbnQuX2xpc3RlbmVycylcbiAgICAgIC8vICAgbGlzdGVuZXJzID0gdmFsLl9wYXJlbnQuX2xpc3RlbmVyc1xuXG4gICAgICAvLyAgIC8vIHZhbC5fcGFcbiAgICAgIC8vICAgaWYobGlzdGVuZXJzKSB7XG4gICAgICAvLyAgICAgZm9yICh2YXIgbGlzdGVuZXIkPTAsIGxlbiQ9bGlzdGVuZXJzLmxlbmd0aDsgbGlzdGVuZXIkPGxlbiQ7IGxpc3RlbmVyJCsrKSB7XG4gICAgICAvLyAgICAgICB0aGlzLnN1YnNjcmliZShsaXN0ZW5lcnNbbGlzdGVuZXIkXSwgZmFsc2UsIHRydWUpXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHZhbCAmJiB1dGlsLmlzT2JqKHZhbCkgJiYgISh2YWwgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIC8vaXNOb3JtYWxTdWJzY3JpcHRpb25cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdJUyBPQkonLmN5YW4pXG4gICAgICBwYXJ0aWFsU3ViID0gdmFsXG4gICAgICB2YWwgPSBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICAgfVxuXG4gICAgaWYgKHBhcnRpYWxTdWIpIHtcblxuICAgICAvL2lmISBlbXB0eVxuICAgICAvLyBjb25zb2xlLmxvZygnMiBMRVRTIERPIElUIElUSSBJVCAyJyx0aGlzICwgcGF0aCwgJ2Zyb206JywgZnJvbSwgJ3N1YjonLCBuZXR3b3JrRGF0YUVsZW1lbnQucGFyc2VEYXRhKGZyb20sIHBhcnRpYWxTdWIsIHRoaXMuX3N1YnMgKSApXG5cbiAgICAgdmFyIGZyb21DaGVja1xuICAgICBpZihmcm9tKSBwYXJ0aWFsU3ViID0gbmV0d29ya0RhdGFFbGVtZW50LnBhcnNlRGF0YShmcm9tLCBwYXJ0aWFsU3ViLCB0aGlzLl9zdWJzKVxuICAgICAgLy9kZSBjaGVjayBtb2V0IG51IGluIGZyb20gZ2ViZXVyZW5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCcuc3Vic2NyaWJlIGNsb3VkLmRhdGEgcGFydGlhbFN1YiBhcmUgd2Ugc3VyZSB0aGlzIGlzIGZyb20gYSByZWYgaW4gdGhlIGNsb3VkJy5ibHVlLmludmVyc2UsIHBhcnRpYWxTdWIsIHBhdGgpIC8vcmVwbGFjZSAvdyBmcm9tXG5cbiAgICAgIGlmKGZyb20gJiYgZnJvbS5jbG91ZCAmJiBmcm9tLl92YWwgPT09IHRoaXMpIHtcbiAgICAgICAgcGF0aCA9IGZyb20uX3BhdGggLy9pZiBmcm9tIGlzIGNsb3VkXG4gICAgICAgIC8vIGFsZXJ0KCchJylcbiAgICAgICAgZnJvbUNoZWNrID0gdHJ1ZVxuICAgICAgICAvLyBjb25zb2xlLndhcm4oJ2RvIG5vdGhpbmcgcHJvcCBmcm9tIGNsb3VkJywgZnJvbSlcbiAgICAgIH1cblxuICAgICBzdWIgPSBjcmVhdGVTdWIocGF0aCwge30sIHBhcnRpYWxTdWIpXG4gICAgIHN0cmluZ2lmaWVkID0gSlNPTi5zdHJpbmdpZnkoc3ViKVxuXG4gICAgIHZhciBzdWJzdGFyZ2V0ID0gIGZyb21DaGVjayA/IGZyb20gOiB0aGlzXG5cbiAgICAgaWYoIXN1YnN0YXJnZXQuX3N1YnMpIHN1YnN0YXJnZXQuX3N1YnMgPSBbXVxuICAgICBpZihlbGVtKSBlbGVtLl9zdWJzY3JpYmVkID0gdHJ1ZVxuICAgICAvLyBjb25zb2xlLmxvZygnM0xFVFMgRE8gSVQgSVRJIElUIDMnLnJlZC5pbnZlcnNlLCBuZXR3b3JrRGF0YUVsZW1lbnQucGFyc2VEYXRhKGZyb20sIHBhcnRpYWxTdWIpIClcblxuICAgICAgc3Vic0FycmF5ID0gWyBwYXJ0aWFsU3ViLCBlbGVtIHx8IHZhbCAsIHN0cmluZ2lmaWVkIF1cblxuICAgICAgaWYoZnJvbU5hbWUpIHtcbiAgICAgICAgc3Vic0FycmF5LnB1c2goZnJvbU5hbWUpXG4gICAgICB9XG5cbiAgICAgIGV4aXN0cyA9IHV0aWwuY2hlY2tBcnJheSggc3Vic3RhcmdldC5fc3Vicywgc3RyaW5naWZpZWQsIDIpXG4gICAgICAvL21heWJlIGNoZWNrIGlmIHZhbCBhbHJlYWR5IGV4aXN0c1xuICAgICAgLy8gY29uc29sZS5sb2coJyBURVNUIFRSVUUgLS0tLS0gU1VCU0NSSUJFJywgZnJvbSwgZXhpc3RzLCB0aGlzLl9zdWJzLCBzdHJpbmdpZmllZCwgcGFydGlhbFN1Yiwgc3ViIClcbiAgICAgIC8vVE9ETzogY2hlY2sgaWYgbm90IGV4aXN0cyBzdWJzQXJyYXkgZWFjaCBmaWVsZFxuICAgICAgLy8gY29uc29sZS5sb2coJ1BVU0ghIFNVQlMnLmdyZWVuLmludmVyc2UsIHN1YnNBcnJheSAsc3RyaW5naWZpZWQsIGV4aXN0cyApXG4gICAgICB2YXIgc2FtZVxuICAgICAgZm9yKHZhciBpIGluIHN1YnN0YXJnZXQuX3N1YnMgKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coc3Vic3RhcmdldC5fc3Vic1tpXSwgaSwgc3Vic3RhcmdldC5fcGF0aClcbiAgICAgICAgLy9jb21wYXJlIG9iamVjdHNcblxuICAgICAgICBpZiggc3Vic3RhcmdldC5fc3Vic1tpXVsxXSA9PT0gKGVsZW0gfHwgdmFsKSAmJiBzdWJzdGFyZ2V0Ll9zdWJzW2ldWzJdID09PSBzdHJpbmdpZmllZCApIHtcbiAgICAgICAgICAvL2Rpc3RpbmNhdGlvbiEhISFcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVEhFIFNBTUUnLmN5YW4uaW52ZXJzZSlcbiAgICAgICAgICBzYW1lID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgaWYoIXNhbWUpIHtcbiAgICAgIHN1YnN0YXJnZXQuX3N1YnMucHVzaCggc3Vic0FycmF5IClcbiAgICAgICAgLy9qdXN0IGRvbnQgc3Vic2NyaWJlIC0tLVxuICAgICAgICBpZiAoIGV4aXN0cz09PWZhbHNlICkge1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJyBUUlVFIC0tLS0tIFNVQlNDUklCRScsIEpTT04uc3RyaW5naWZ5KHN1YixmYWxzZSwyKSApXG4gICAgICAgICAgdGhpcy5jbG91ZC5zdWJzY3JpYmUoc3ViLCBzdHJpbmdpZmllZClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ0FMTFJFQURZIEVYSVNUUyEnLCBzdWIsIHN0cmluZ2lmaWVkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gIH1cbiwgJ3Vuc3Vic2NyaWJlJ1xuLCBmdW5jdGlvbiggdmFsLCBmcm9tICkge1xuXG4gICAgLy90b2RvOiBkb3VibGUgY2hlY2sgaWYgdGhpcyBnb2VzIHdlbGxcbiAgICAvLyBjb25zb2xlLmVycm9yKCcxdW5zdWJzY3JpYmUhJylcblxuICAgIC8vZG91bmRsZSByZW1vdmVcblxuICAgIGlmIFxuICAgICggIXZhbFxuICAgICAgfHwgdmFsLl9jb2xcbiAgICAgIHx8ICh2YWwuX2ZpbHRlciAmJiB2YWwuX2ZpbHRlci5fY29sKVxuICAgICAgfHwgISghdmFsLl9kZnJvbSB8fCB2YWwuX2Ztb2RlbClcbiAgICApIFxuICAgIHsgXG4gICAgICByZXR1cm4gXG4gICAgfVxuXG4gICAgIHZhciBwYXRoID0gdGhpcy5fcGF0aFxuICAgICAgICwgc3RyaW5naWZpZWRcbiAgICAgICAsIHN1YnNBcnJheVxuICAgICAgICwgc3ViXG4gICAgICAgLCBleGlzdHNcbiAgICAgICAsIHBhcnRpYWxTdWJcbiAgICAgICAsIGluZGV4XG4gICAgICAgLCBmaWVsZFxuICAgICAgICwgbGlzdGVuZXJzID0gdmFsLl9saXN0ZW5lcnNcblxuICAgIC8vIGNvbnNvbGUubG9nKCd1bnN1YnNjcmlibGV4JywncGF0aDonLmJsdWUsIHBhdGgsICdzdHJpbmdpZmllZDonLmJsdWUsICBzdWIsICd0aGlzOicuYmx1ZSx0aGlzLCAndmFsOicuYmx1ZSwgdmFsLCAnZnJvbTonLGZyb20gKVxuXG4gICAgaWYgKCB1dGlsLmlzT2JqKCB2YWwgKSAmJiAhKCB2YWwgaW5zdGFuY2VvZiBBcnJheSApICkgdmFsID0gSlNPTi5zdHJpbmdpZnkoIHZhbCApXG5cbiAgICBpbmRleCA9IHRoaXMuX3N1YnMgJiYgdXRpbC5jaGVja0FycmF5KCB0aGlzLl9zdWJzLCB2YWwsIDEgKVxuICAgIC8vbmlldCBhbGxlIDEncyB3ZWdoYWxlblxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1bnN1YnM/Pz8/Pz8nLnJlZC5pbnZlcnNlLCB1dGlsLmNsb25lKHRoaXMuX3N1YnMpLCB2YWwsIGluZGV4LCB0aGlzIClcbiAgICAgICAgLy9taXNzaW5nIGluZGV4IVxuXG5cbiAgICBpZiAoIGluZGV4IT09ZmFsc2UgJiYgaW5kZXggIT09IHZvaWQgMCApIHtcblxuXG5cblxuICAgICAgaWYodmFsLm1vZGVsICYmIHZhbC5tb2RlbC5wYXJzaW5nKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ01PREVMIHVuc3Vicz8/Pz8/PycucmVkLmludmVyc2UpXG4gICAgICAgIC8vIHZhciByZW1vdmVJXG5cbiAgICAgICAgLy9ibG9jayB1bnN1YnMgb24gbW9kZWwgcGFyc2luZ1xuICAgICAgICBpZih2YWwubW9kZWwgJiYgdmFsLm1vZGVsLmZpZWxkICkge1xuICAgICAgICAgIC8vIGNvbnNvbGUuY2xlYXIoKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdXQVJOISB1bnN1YnMgZmllbGQgV0FSTiEnLnJlZC5pbnZlcnNlLCBmcm9tLCB0aGlzLl9zdWJzW2luZGV4XSApXG5cbiAgICAgICAgICAvL3JlYXBwbHkgaWYgZmllbGRcbiAgICAgICAgICBmaWVsZCA9IHRoaXMuZ2V0KHZhbC5tb2RlbC5maWVsZC52YWwpXG4gICAgICAgICAgaWYoIWZpZWxkLl9zdWJzKSBmaWVsZC5fc3VicyA9IFtdXG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnV0FSTiEgdW5zdWJzIGZpZWxkIFdBUk4hJy5yZWQuaW52ZXJzZSxmaWVsZD09PXRoaXMsIGZpZWxkLCBmcm9tLCB0aGlzLl9zdWJzW2luZGV4XSApXG5cblxuICAgICAgICAgIHZhciBfX3N1YnMgPSB1dGlsXG4gICAgICAgICAgICAuZ2V0KCB0aGlzLl9zdWJzW2luZGV4XVswXSwgdmFsLm1vZGVsLmZpZWxkLnZhbCApXG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnc3Vic1swXScuYmx1ZSwgIHRoaXMuX3N1YnNbaW5kZXhdWzBdIClcblxuICAgICAgICAgIGlmKCBfX3N1YnMgKSB7XG4gICAgICAgICAgdGhpcy5fc3Vic1tpbmRleF1bMF0gPSBfX3N1YnNcbiAgICAgICAgICAvLyBmaWVsZC5fc3Vicy5wdXNoKHRoaXMuX3N1YnNbaW5kZXhdKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgU1VCUyBhbmQgcHVzaCcucmVkLmludmVyc2UsIGluZGV4LGZpZWxkLl9zdWJzLCBfX3N1YnMsIHRoaXMuX3N1YnNbaW5kZXhdLCB0aGlzLl9wYXRoKVxuICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgICAgLy8gdGhpcy5fc3Vicy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3dhcm4nLnJlZClcblxuICAgICAgICB9XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coIF9fc3VicyApXG5cblxuICAgICAgICAgXG4gICAgICAgICAgLy9kaXQgZmYgYmV0ZXIgZG9lbiAobWVlcmRlcmUgX3N1YnMpXG4gICAgICAgICAgLy90ZWwgY291bnRzXG4gICAgICAgICAgXG4gICAgICAgICAgLy92b29yIGRlemUgc3BsaWNlIGNoZWNrIG9wIGluZGV4IGVuIHN0cmluZ2lmaWVkIVxuXG4gICAgICAgICBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBzdWJzQXJyYXkgPSB0aGlzLl9zdWJzW2luZGV4XVxuICAgICAgc3RyaW5naWZpZWQgPSBzdWJzQXJyYXlbMl1cbiAgICAgIHBhcnRpYWxTdWIgPSBzdWJzQXJyYXlbMF1cbiAgICAgIC8vIGlmKGZyb20pIHBhcnRpYWxTdWIgPSBuZXR3b3JrRGF0YUVsZW1lbnQucGFyc2VEYXRhKGZyb20sIHBhcnRpYWxTdWIpXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCAncGFydGlhbFN1YicuaW52ZXJzZSwgcGFydGlhbFN1YiApXG5cbiAgICAgIHN1YiA9IGNyZWF0ZVN1YihwYXRoLCB7fSwgcGFydGlhbFN1YilcblxuICAgICAgLy92b29yIGRlemUgc3BsaWNlIGNoZWNrIG9wIGluZGV4IGVuIHN0cmluZ2lmaWVkIVxuICAgICAgLy9rYW4gZHVzIG9vayBlZmZpY2llbnRlclxuICAgICAgLy8gaWYoIHJlbW92ZUkgIT09IHZvaWQgMCApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRScsIGluZGV4KVxuICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBTVUJTJy5yZWQuaW52ZXJzZSwgaW5kZXgsIHRoaXMuX3N1YnMsIHRoaXMuX3BhdGggKVxuICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgIHRoaXMuX3N1YnMuc3BsaWNlKGluZGV4LCAxKVxuXG4gICAgICAvLyB9XG5cblxuXG4gICAgICBleGlzdHMgPSB1dGlsLmNoZWNrQXJyYXkodGhpcy5fc3Vicywgc3RyaW5naWZpZWQsIDIpXG5cbiAgICAgIGlmKGV4aXN0cyE9PWZhbHNlKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdFWElTVFM/Pz8/Jy5jeWFuLmludmVyc2UsIGV4aXN0cywgc3RyaW5naWZpZWQsIHRoaXMuX3N1YnMsIHRoaXMuX3BhdGgsIHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnIUVYSVNUUycgLCBleGlzdHMsIHN0cmluZ2lmaWVkKVxuICAgICAgfVxuXG4gICAgICBpZiAoIGV4aXN0cyA9PT0gZmFsc2UgKSB0aGlzLmNsb3VkLnVuc3Vic2NyaWJlKHN1Yiwgc3RyaW5naWZpZWQpXG4gICAgICAgIC8vIHRoaXMuX3N1YnNSQUYucHVzaChbc3ViLCBzdHJpbmdpZmllZF0pXG4gICAgICAgIC8vIHRoaXMuX3N1YnNSQUYgPSBbXSBzZWFyY2ggJiByZW1vdmUgdXNlIGRpZmZlcmVudCBpZGVudGlmaWVycyBlLmcuIHN1YnMgYXJyYXlcblxuICAgIH0gZWxzZSBpZiggdmFsLl9yZW1vdmVkICkge1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndW5zdWJzPz8yMjIyMj8/Pz8gMjIyMjIyMicucmVkLmludmVyc2UpXG5cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2lzIHRoaXMgcmVhbGx5IG5lc3NlY2FyeT8gX3JlbW92ZWQgLCBmcm9jZSBhbGwgbGlzdGVuZXJzIHJlbW92ZSB0YWdldHMgZXRjJylcbiAgICB9IGVsc2UgaWYobGlzdGVuZXJzKSB7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd1bnN1YnM/PzMzMzMzMzMzMz8/Pz8gMjIyMjIyMicucmVkLmludmVyc2UpXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tPiB0aGlzIGlzIGFsc28gcHJldHR5IGRpZmZlcmVudCEgX2xpc3RlbmVycycpXG4gICAgICBmb3IgKHZhciBsaXN0ZW5lciQ9MCwgbGVuJD1saXN0ZW5lcnMubGVuZ3RoOyBsaXN0ZW5lciQ8bGVuJDsgbGlzdGVuZXIkKyspIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyc1tsaXN0ZW5lciRdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKGxpc3RlbmVyc1tsaXN0ZW5lciRdWzFdLCB2YWwpXG4gICAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzW2xpc3RlbmVyJF0uX190KSB7XG4gICAgICAgICAgdGhpcy51bnN1YnNjcmliZShsaXN0ZW5lcnNbbGlzdGVuZXIkXSwgdmFsKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgfVxuKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBEYXRhQ2xvdWRcblxudmFyIHRpbWVzdGFtcCA9IHJlcXVpcmUoJ21vbm90b25pYy10aW1lc3RhbXAnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvb2JqZWN0JyksXG4gIENsb3VkRGF0YSA9IHJlcXVpcmUoJy4vZGF0YScpLFxuICBWT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vb2JqZWN0JyksXG4gIEJhdGNoID0gVk9iamVjdC5uZXcoe1xuICAgIG1lcmdlOiB0cnVlXG4gIH0pLFxuICBDbG91ZFN0YXRlID0gVk9iamVjdC5uZXcoe1xuICAgIG1lcmdlOiB0cnVlXG4gIH0pLFxuICBtYWtlSGFzaCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvaGFzaCcpLFxuICBiYXRjaHRpbWUgPSAyMCxcbiAgU1VCUyA9ICdzdWJzJyxcbiAgU0VUUyA9ICdzZXRzJyxcbiAgVU5TVUJTID0gJ3Vuc3VicydcblxuZnVuY3Rpb24gRGF0YUNsb3VkICgpIHtcbiAgLy8gd2luZG93LmRhdGFjbG91ZCA9IHRoaXNcbiAgdmFyIGNsb3VkID0gdGhpc1xuICBjbG91ZC5fam9pbnMgPSB7fVxuICBjbG91ZC5fc3RhdHVzID0gMVxuXG4gIGNsb3VkLm9uKCdjb25uZWN0JywgZnVuY3Rpb24gKCkge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJy0tLS0gY2xvdWQgY29ubmVjdCA+PiBjbG91ZC5fc3RhdHVzKysgY2FsbCBfcmVjb25uZWN0JylcbiAgICBjbG91ZC5fc3RhdHVzKytcbiAgICBjbG91ZC5fcmVjb25uZWN0KClcbiAgfSlcblxuICAvLyBjb25zb2xlLmxvZygnc3RhcnQgbWFraW5nIHN0YXRlJylcbiAgY2xvdWQuc3RhdGUgPSBuZXcgQ2xvdWRTdGF0ZSh7XG4gICAgICAgIHN1YnM6IHtcbiAgICAgICAgICBtYXA6IHt9LFxuICAgICAgICAgIHRyZWU6IHt9XG4gICAgICAgIH0sXG4gICAgICAgIHNldHM6IHtcbiAgICAgICAgICBtYXA6IHt9IC8qLCBsaXN0OltdKi9cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gLCB7IGxvY2Fsc3RvcmFnZTogJ1ZDJCcgfVxuICAgIClcbiAgICAvLyBjb25zb2xlLmxvZygnZG9uZSBtYWtpbmcgc3RhdGUnLCBKU09OLnN0cmluZ2lmeShjbG91ZC5zdGF0ZS5yYXcsZmFsc2UsMikpXG5cbiAgaWYgKCFjbG91ZC5zdGF0ZS5zZXRzLmxpc3QpIGNsb3VkLnN0YXRlLnNldHMuc2V0KCdsaXN0JywgW10pXG4gICAgLy8gXl4gc2V0IG1ldCBsZWdlIGFycmF5IG1lcmdlZCBuaWV0XG5cbiAgY2xvdWQuYmF0Y2ggPSB7XG4gICAgbWFwczoge1xuICAgICAgc2V0czoge30sXG4gICAgICBzdWJzOiB7fSxcbiAgICAgIHVuc3Viczoge31cbiAgICB9XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZygnLS0tLS0tU0VUIEMgREFUQScpXG5cbiAgY2xvdWQuZGF0YSA9IG5ldyBDbG91ZERhdGEoe30sIGZhbHNlIC8ve2xvY2Fsc3RvcmFnZTonY2xvdWREYXRhJ31cbiAgICAsIGZhbHNlLCB0aGlzKVxuXG4gIC8vIGNvbnNvbGUubG9nKCctLS0tLS1MT0cnKVxuXG5cbiAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoIGNsb3VkLmRhdGEucmF3LGZhbHNlLDIpKVxuICAvLyBeXiBkaXQga2FuIGRvb3Igd2VpcmRlIHNoaXQgaW4gbG9jYWxTdG9yYWdlIGRlIGNvbnN0cnVjdG9yIGxhdGVuIGthcHBlbiFcblxuICAvLyBjbG91ZC5vbignaW5jb21pbmc6OnBvbmcnLCB0aGlzLl9jbGVhckNhY2hlKVxuICAvLyBjbG91ZC5vbignZGF0YScsIHRoaXMuX2NsZWFyQ2FjaGUpXG5cbiAgY2xvdWQuX3FUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uIF9xVGltZXIgKCkge1xuICAgIGNsb3VkLl9kb0JhdGNoKClcbiAgfSwgYmF0Y2h0aW1lKVxuXG5cbiAgLy8gY2xvdWQub24oJ3dlbGNvbWUnLCBmdW5jdGlvbiBvbldlbGNvbWUoKXtcblxuICAvLyB9KVxuXG4gIGNsb3VkLm9uKCdzdWJzY3JpYmVkJywgZnVuY3Rpb24gKG1zZykge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJz4+PiBIZXkgQ2xvdWQgc2F5cyBpbSBzdWJzY3JpYmVkIHRvJywgbXNnKVxuICB9KVxuXG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUudGltZVN5bmMgPSBmdW5jdGlvbiB0aW1lU3luYyAoKSB7XG4gIC8vIGNvbnNvbGUubG9nKCd0aW1lU3luYyEnKVxuICB2YXIgY2xvdWQgPSB0aGlzLFxuICAgIG91dHN0YW1wID0gRGF0ZS5ub3coKVxuICBjbG91ZC5lbWl0KCd0aW1lJywgZnVuY3Rpb24gKGNsb3Vkc3RhbXApIHtcblxuICAgIHZhciB0cmF2ZWx0aW1lID0gRGF0ZS5ub3coKSAtIG91dHN0YW1wLFxuICAgICAgYXJyaXZhbCA9IG91dHN0YW1wICsgdHJhdmVsdGltZSAvIDIsXG4gICAgICBvZmZzZXQgPSBjbG91ZHN0YW1wIC0gYXJyaXZhbFxuICAgICAgLy8gY29uc29sZS5sb2coJ3RpbWVzdGFtcCBpbicsIHRyYXZlbHRpbWUsICdvZmZzZXQnLCBvZmZzZXQpXG4gICAgaWYgKHRyYXZlbHRpbWUgPCBjbG91ZC5fdGltZVRyYXZlbCkge1xuICAgICAgY2xvdWQuX3RpbWVUcmF2ZWwgPSB0cmF2ZWx0aW1lXG4gICAgICBjbG91ZC5fdGltZU9mZnNldCA9IG9mZnNldFxuICAgIH1cbiAgICB2YXIgdHJpZXMgPSBjbG91ZC5fdGltZVRyaWVzKytcbiAgICAgIGlmICh0cmF2ZWx0aW1lID4gNzUgJiYgdHJpZXMgPCAxMCB8fCB0cmF2ZWx0aW1lID4gNTAgJiYgdHJpZXMgPCA1IHx8IHRyYXZlbHRpbWUgPiAyMCAmJiB0cmllcyA8IDIpIHtcbiAgICAgICAgY2xvdWQudGltZVN5bmMoKVxuICAgICAgfVxuICB9KVxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLm91dExpc3QgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgdmFyIGJhdGNoID0gdGhpcy5iYXRjaFxuICBpZiAoIWJhdGNoLmxpc3RzKSB7XG4gICAgYmF0Y2gubGlzdHMgPSB7fVxuICAgIHJldHVybiBiYXRjaC5saXN0c1tsYWJlbF0gPSBbXVxuICB9IGVsc2UgaWYgKCFiYXRjaC5saXN0c1tsYWJlbF0pIHtcbiAgICByZXR1cm4gYmF0Y2gubGlzdHNbbGFiZWxdID0gW11cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmF0Y2gubGlzdHNbbGFiZWxdXG4gIH1cbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS5fZG9CYXRjaCA9IGZ1bmN0aW9uIF9kb0JhdGNoICgpIHtcbiAgdmFyIGNsb3VkID0gdGhpcyxcbiAgICBvdXQgPSBjbG91ZC5iYXRjaC5saXN0c1xuXG4gIGlmIChvdXQpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnZW1pdCBkYXQgYmF0Y2ggb3V0IScpXG4gICAgLy8gY29uc29sZS5sb2coJ0VNSVRUSU5HIScsb3V0KVxuICAgIC8vIGlmKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKXtcbiAgICAvLyAgIGNvbnNvbGUubG9nKCd3cml0aW5nIG91dCcsIEpTT04uc3RyaW5naWZ5KG91dCkuc2xpY2UoMCw1MCkpXG4gICAgLy8gICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKClcbiAgICAvLyAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG91dCxmYWxzZSwyKSlcbiAgICAvLyAgIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgIC8vIH1cbiAgICBjbG91ZC5lbWl0KCdiYXRjaCcsIG91dClcbiAgICAgIC8vIGNsb3VkLndyaXRlKG91dClcbiAgICAgIC8vIGNhY2hlIHNldHMgdW50aWxsIG5leHQgaGVhcnRiZWF0XG4gICAgICAvLyB2YXIgc2V0c2xpc3QgPSBvdXQuc2V0c1xuICAgICAgLy8gaWYoc2V0c2xpc3QpIHtcbiAgICAgIC8vICAgdmFyIGNhY2hlID0gY2xvdWQuc3RhdGUuc2V0c1xuICAgICAgLy8gICAgICwgc2V0c21hcCA9IGNsb3VkLmJhdGNoLm1hcHMuc2V0c1xuXG4gICAgLy8gICBmb3IodmFyIGhhc2ggaW4gc2V0c21hcCkge1xuICAgIC8vICAgICB2YXIgdXBkYXRlID0gc2V0c21hcFtoYXNoXS51cGRhdGVcbiAgICAvLyAgICAgaWYodXBkYXRlWzFdID09PSBudWxsKVxuICAgIC8vICAgICAgIHVwZGF0ZVsxXSA9ICckJG51bGwnXG4gICAgLy8gICAgIHN0b3JlU2V0KGhhc2gsIHVwZGF0ZSwgY2FjaGUubGlzdCwgY2FjaGUubWFwKVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBjbG91ZC5iYXRjaC5saXN0cyA9IG51bGxcbiAgICBjbG91ZC5iYXRjaC5tYXBzID0ge1xuICAgICAgc3Viczoge30sXG4gICAgICBzZXRzOiB7fSxcbiAgICAgIHVuc3Viczoge31cbiAgICB9XG4gIH1cbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS5fY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIF9jbGVhckNhY2hlICgpIHtcbiAgLy8gaWYodGhpcy5zdGF0ZS5zZXRzLmxpc3QubGVuZ3RoKXtcbiAgLy8gICB0aGlzLnN0YXRlLnNldHMucmVtb3ZlKClcbiAgLy8gICB0aGlzLnN0YXRlLnNldCgnc2V0cycsIHttYXA6e30sbGlzdDpbXX0pXG4gIC8vIH1cbiAgLy8gY291bGQgYmUgbmljZXIgaWYgd2UgaGF2ZSBhIGdvb2Qgd2F5IG9mIGNsZWFyaW5nIGFycmF5c1xufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoc3Vic29iaiwgc3RyKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdzdWJzY3JpYmUhJywgc3RyKVxuICB2YXIgY2xvdWQgPSB0aGlzLFxuICAgIHN0YXRlID0gY2xvdWQuc3RhdGUsXG4gICAgaGFzaCwgY2FjaGVkXG5cbiAgaWYgKHN1YnNvYmouaGFzaCAmJiBzdWJzb2JqLnN1YnNvYmopIHtcbiAgICAvLyBjb25zb2xlLmxvZygnZGFzIGNhY2hlZCEnKVxuICAgIGhhc2ggPSBzdWJzb2JqLmhhc2hcbiAgICBjYWNoZWQgPSBzdWJzb2JqXG4gIH0gZWxzZSB7XG4gICAgaWYgKCFzdHIpXG4gICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShzdWJzb2JqKVxuICAgIGhhc2ggPSBtYWtlSGFzaChzdHIpXG4gICAgY2FjaGVkID0gc3RhdGUuc3Vicy5tYXBbaGFzaF1cbiAgfVxuICAvLyBjb25zb2xlLmxvZygnaGFzaCcsIGhhc2gpXG5cblxuICBpZiAoIWNhY2hlZCkgeyAvLyBwbGFjZSBpbiB0cmVlXG5cbiAgICAvLyBjb25zb2xlLmxvZygnc2V0IGFjdGl2ZSEnKVxuXG4gICAgc3RhdGUuc3Vicy5tYXAuc2V0KGhhc2gsIHtcbiAgICAgIGhhc2g6IGhhc2gsXG4gICAgICBzdWJzb2JqOiBzdWJzb2JqLFxuICAgICAgYWN0aXZlOiBjbG91ZC5fc3RhdHVzLFxuICAgICAgY2xlYXJlZDogZmFsc2VcbiAgICB9KVxuICAgIGNhY2hlZCA9IHN0YXRlLnN1YnMubWFwW2hhc2hdXG4gICAgdmFyIHRyZWUgPSBzdGF0ZS5zdWJzLnRyZWVcbiAgICBpbnNlcnRMZWFmKHRyZWUsIGNhY2hlZC5zdWJzb2JqLCBjYWNoZWQpXG4gIH0gZWxzZSBpZiAoIWNhY2hlZC5hY3RpdmUgfHwgY2FjaGVkLmFjdGl2ZS5fdmFsKSB7XG4gICAgLy8gY29uc29sZS53YXJuKCdzdWJzY3JpcHRpb24gYWxyZWFkeSBhY3RpdmUhJywgY2FjaGVkLCBjYWNoZWQuYWN0aXZlKVxuICAgIHJldHVyblxuICB9IGVsc2Uge1xuICAgIGNhY2hlZC5hY3RpdmUudmFsID0gY2xvdWQuX3N0YXR1c1xuICB9XG5cbiAgdmFyIHVuc3Vic21hcCA9IGNsb3VkLmJhdGNoLm1hcHMudW5zdWJzLFxuICAgIHVuc3ViaW5kZXggPSB1bnN1YnNtYXBbaGFzaF1cblxuICBpZiAodW5zdWJpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgY2xvdWQuY2FuY2VsKGhhc2gsIHVuc3ViaW5kZXgsIFVOU1VCUylcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBzdWJzbGlzdCA9IGNsb3VkLm91dExpc3QoU1VCUyksXG4gICAgc3Vic21hcCA9IGNsb3VkLmJhdGNoLm1hcHMuc3VicyxcbiAgICBvdXRcblxuICBpZiAoIWNhY2hlZC5jbGVhcmVkLl92YWwpIHtcbiAgICBjYWNoZWQuY2xlYXJlZC52YWwgPSBjbG91ZC5fc3RhdHVzXG4gICAgdmFyIGRlcGVuZHMgPSBjbG91ZC5nZXREZXBzKHN0YXRlLnN1YnMudHJlZSwgY2FjaGVkLnN1YnNvYmosIGNhY2hlZCwge30pXG4gICAgaWYgKCF1dGlsLmVtcHR5KGRlcGVuZHMpKSB7XG4gICAgICBvdXQgPSB7XG4gICAgICAgICRzdWJzb2JqOiBjYWNoZWQuc3Vic29iai5yYXcsXG4gICAgICAgICRkZXBlbmRzOiBkZXBlbmRzXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IGNhY2hlZC5zdWJzb2JqLnJhd1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXQgPSBjYWNoZWQuc3Vic29iai5yYXdcbiAgICBjYWNoZWQuY2xlYXJlZC52YWwgPSBjbG91ZC5fc3RhdHVzXG4gIH1cblxuICBzdWJzbWFwW2hhc2hdID0gc3Vic2xpc3QubGVuZ3RoXG4gIHN1YnNsaXN0LnB1c2gob3V0KVxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLmdldERlcHMgPSBmdW5jdGlvbiBnZXREZXBzICh0cmVlLCB3YWxrZXIsIGNhY2hlZCwgbGlzdCkge1xuICB3YWxrZXIuZWFjaChmdW5jdGlvbiAoZikge1xuICAgIHZhciBicmFuY2ggPSB0cmVlW2ZdXG4gICAgaWYgKGJyYW5jaCkge1xuICAgICAgaWYgKGJyYW5jaC5fc3Vicykge1xuICAgICAgICBicmFuY2guX3N1YnMuZWFjaChmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IHRoaXMuX3ZhbFxuICAgICAgICAgIGlmIChmb3VuZC5zdWJzb2JqLl92ICYmIGZvdW5kLmhhc2guX3ZhbCAhPT0gY2FjaGVkLmhhc2guX3ZhbCAmJiAhZm91bmQuY2xlYXJlZC5fdmFsICYmICFsaXN0W2ZvdW5kLmhhc2guX3ZhbF0pIHtcbiAgICAgICAgICAgIGZvdW5kLmNsZWFyZWQudmFsID0gY2FjaGVkLmNsZWFyZWQuX3ZhbFxuICAgICAgICAgICAgbGlzdFtmb3VuZC5oYXNoLl92YWxdID0gZm91bmQuc3Vic29iai5yYXdcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBnZXREZXBzKGJyYW5jaCwgd2Fsa2VyW2ZdLCBjYWNoZWQsIGxpc3QpXG4gICAgfVxuICB9KVxuICByZXR1cm4gbGlzdFxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUgKHN1YnNvYmosIHN0cikge1xuICAvLyBzdGlsbCBkb1xuICB2YXIgY2xvdWQgPSB0aGlzXG4gIC8vIGNvbnNvbGUuZXJyb3IoJ3Vuc3Vic2NyaWJlIScsIHN1YnNvYmopXG4gIGlmIChzdWJzb2JqIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAvLyBjb25zb2xlLmxvZygndW5zdWIgd2l0aCBhcnJheScsIHN1YnNvYmopXG4gICAgdmFyIHRyZWUgPSBjbG91ZC5zdGF0ZS5zdWJzLnRyZWUsXG4gICAgICBzcG90ID0gdHJlZS5nZXQoc3Vic29iailcblxuICAgIGlmIChzcG90KSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnT0sgVU5TVUJTQ1JJQkUgVE8gVEhJUyBDUkFQJywgc3BvdClcbiAgICAgIHJlY3VyVW5zdWIoY2xvdWQsIHNwb3QsIHN0cilcbiAgICB9XG4gIH0gZWxzZSB7XG5cbiAgICB2YXIgYmF0Y2htYXAgPSBjbG91ZC5iYXRjaC5tYXBzLnN1YnMsXG4gICAgICBoYXNoLFxuICAgICAgY2FjaGVkXG5cbiAgICBpZiAoc3Vic29iai5oYXNoKSB7XG4gICAgICBoYXNoID0gc3Vic29iai5oYXNoLnZhbFxuICAgICAgY2FjaGVkID0gc3Vic29ialxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXN0cikge1xuICAgICAgICBzdHIgPSBKU09OLnN0cmluZ2lmeShzdWJzb2JqKVxuICAgICAgfVxuICAgICAgaGFzaCA9IG1ha2VIYXNoKHN0cilcblxuICAgICAgdmFyIHN0YXRlbWFwID0gY2xvdWQuc3RhdGUuc3Vicy5tYXBcblxuICAgICAgY2FjaGVkID0gc3RhdGVtYXBbaGFzaF1cbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBiYXRjaG1hcFtoYXNoXVxuXG4gICAgaWYgKGluZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgIGNsb3VkLmNhbmNlbChoYXNoLCBpbmRleCwgU1VCUylcblxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGlzdCA9IGNsb3VkLm91dExpc3QoJ3Vuc3VicycpXG4gICAgICBjbG91ZC5iYXRjaC5tYXBzLnVuc3Vic1toYXNoXSA9IGxpc3QubGVuZ3RoXG4gICAgICBsaXN0LnB1c2goaGFzaClcbiAgICB9XG5cbiAgICBjYWNoZWQuYWN0aXZlLnZhbCA9IGZhbHNlXG4gIH1cblxufVxuXG5mdW5jdGlvbiByZWN1clVuc3ViIChjbG91ZCwgc3BvdCwgY2xlYXIpIHtcbiAgLy8gY29uc29sZS5sb2coJ3JlY3VyVW5zdWIhJywgc3BvdC5fcGF0aClcbiAgc3BvdC5lYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgaWYgKHRoaXMuX3N1YnMpIHtcbiAgICAgIHRoaXMuX3N1YnMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1bnN1YiBvbiB0aGlzIScsIHRoaXMucmF3LCAnY2xlYXI/JywgY2xlYXIpXG4gICAgICAgIGlmIChjbGVhciAmJiB0aGlzLmZyb20uc3Vic29iai5fdikge1xuICAgICAgICAgIHRoaXMuZnJvbS5zdWJzb2JqLl92LnJlbW92ZSgpXG4gICAgICAgIH1cbiAgICAgICAgY2xvdWQudW5zdWJzY3JpYmUodGhpcy5mcm9tKVxuICAgICAgfSlcbiAgICB9XG4gICAgaWYgKGYgIT09ICdfc3VicycpIHtcbiAgICAgIHJlY3VyVW5zdWIoY2xvdWQsIHRoaXMsIGNsZWFyKVxuICAgIH1cbiAgfSlcbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwgKGhhc2gsIGluZGV4LCBsYWJlbCkge1xuICB2YXIgYmF0Y2ggPSB0aGlzLmJhdGNoLFxuICAgIGxpc3QgPSBiYXRjaC5saXN0c1tsYWJlbF1cbiAgcmVtb3ZlSW5kZXgobGlzdCwgaW5kZXgpXG4gIGlmICghbGlzdC5sZW5ndGgpIHtcbiAgICBkZWxldGUgYmF0Y2gubGlzdHNbbGFiZWxdXG4gICAgaWYgKHV0aWwuZW1wdHkoYmF0Y2gubGlzdHMpKSB7XG4gICAgICBkZWxldGUgYmF0Y2gubGlzdHNcbiAgICB9XG4gIH1cbiAgdmFyIG1hcCA9IGJhdGNoLm1hcHNbbGFiZWxdXG4gIGRlbGV0ZSBtYXBbaGFzaF1cbiAgZm9yIChoYXNoIGluIG1hcClcbiAgICBpZiAobWFwW2hhc2hdID4gaW5kZXgpIHtcbiAgICAgIG1hcFtoYXNoXSAtLVxuICAgIH1cbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQgKGhhc2gsIHVwZGF0ZSkge1xuXG4gIC8vIGNvbnNvbGUubG9nKCdTRVQgQ0xPVUQhJylcblxuICBpZiAoIXVwZGF0ZVswXS5sZW5ndGgpIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdFTVBUWSBQQVRIJywgdXBkYXRlKVxuICB9XG5cbiAgdmFyIGNsb3VkID0gdGhpcyxcbiAgICBsaXN0ID0gY2xvdWQub3V0TGlzdChTRVRTKSxcbiAgICBtYXAgPSBjbG91ZC5iYXRjaC5tYXBzLnNldHNcblxuICBzdG9yZVNldChoYXNoLCB1cGRhdGUsIGxpc3QsIG1hcClcbn1cblxuZnVuY3Rpb24gc3RvcmVTZXQgKGhhc2gsIHVwZGF0ZSwgbGlzdCwgbWFwKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdzdG9yZXNldD8hJylcbiAgdmFyIFYgPSBsaXN0Ll9fdCxcbiAgICBzdG9yZWQgPSBtYXBbaGFzaF1cblxuICBpZiAoc3RvcmVkKSB7XG4gICAgdmFyIHZhbCA9IHVwZGF0ZVsxXSxcbiAgICAgIHRzID0gdXBkYXRlWzJdLFxuICAgICAgb2xkdmFsID0gc3RvcmVkLnVwZGF0ZVsxXVxuXG4gICAgaWYgKFYpIG9sZHZhbCA9IG9sZHZhbC5yYXdcblxuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QgJiYgb2xkdmFsIGluc3RhbmNlb2YgT2JqZWN0ICYmICEodmFsLiRwYXRoKSAmJiAhKG9sZHZhbC4kcGF0aCkpIHtcbiAgICAgIGlmICghVikgb2xkdmFsID0gdXRpbC5jbG9uZShvbGR2YWwpXG4gICAgICB2YWwgPSB1dGlsLm1lcmdlKG9sZHZhbCwgdmFsKVxuICAgIH1cblxuICAgIGlmIChWKSB7XG4gICAgICBzdG9yZWQudXBkYXRlLnNldCgxLCB2YWwpXG4gICAgICBzdG9yZWQudXBkYXRlLnNldCgyLCB0cylcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmVkLnVwZGF0ZVsxXSA9IHZhbFxuICAgICAgc3RvcmVkLnVwZGF0ZVsyXSA9IHRzXG4gICAgfVxuXG4gICAgaWYgKCFWKSB7XG4gICAgICB2YXIgaSA9IHN0b3JlZC5pLFxuICAgICAgICBlbmQgPSBsaXN0Lmxlbmd0aCAtIDFcbiAgICAgIGlmIChpICE9PSBlbmQpIHtcbiAgICAgICAgbW92ZVRvRW5kKGxpc3QsIGkpXG4gICAgICAgIGZvciAodmFyIG1hcGhhc2ggaW4gbWFwKSB7XG4gICAgICAgICAgaWYgKG1hcFttYXBoYXNoXS5pID49IGkpIG1hcFttYXBoYXNoXS5pLS1cbiAgICAgICAgfVxuICAgICAgICBzdG9yZWQuaSA9IGVuZFxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2V0b2JqID0ge1xuICAgICAgdXBkYXRlOiB1cGRhdGUsXG4gICAgICBpOiBsaXN0Lmxlbmd0aFxuICAgIH1cbiAgICBpZiAoVikge1xuICAgICAgbWFwLnNldChoYXNoLCBzZXRvYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcFtoYXNoXSA9IHNldG9ialxuICAgIH1cblxuICAgIHN0b3JlZCA9IG1hcFtoYXNoXVxuICAgIGxpc3QucHVzaChzdG9yZWQudXBkYXRlKVxuICB9XG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUuX3JlY29ubmVjdCA9IGZ1bmN0aW9uIF9yZWNvbm5lY3QgKCkge1xuXG4gIC8vIGFsZXJ0KCcoUkUpQ09OTkVDVCEnKVxuICAvLyBjb25zb2xlLmVycm9yKCctLS0tLS0tLS0tLS0tIChSRSlDT05ORUNUIScpXG5cbiAgdmFyIGNsb3VkID0gdGhpcyxcbiAgICBzdGF0ZSA9IGNsb3VkLnN0YXRlLFxuICAgIHN1YnMgPSBzdGF0ZS5zdWJzLm1hcFxuXG4gIGNsb3VkLl90aW1lVHJpZXMgPSAwXG4gIGNsb3VkLl90aW1lVHJhdmVsID0gSW5maW5pdHlcbiAgY2xvdWQudGltZVN5bmMoKVxuXG4gIC8vIGNsZWFuIGRhdGFcbiAgY2xvdWQuc3RhbXAgPSAnY2xlYW51cCdcbiAgaWYgKGNsb3VkLmRhdGEuY2xpZW50cykge1xuICAgIHZhciBteWNsaWVudCA9IGNsb3VkLmRhdGEuY2xpZW50c1tjbG91ZC5jbGllbnRpZF1cblxuICAgIGlmKG15Y2xpZW50KSB7XG4gICAgICBteWNsaWVudCA9IG15Y2xpZW50LnJhd1xuICAgICAgZGVsZXRlIG15Y2xpZW50LmtleVxuICAgICAgZGVsZXRlIG15Y2xpZW50LnR5cGVcbiAgICAgIGRlbGV0ZSBteWNsaWVudC5pcFxuICAgICAgZGVsZXRlIG15Y2xpZW50LnRva2VuXG4gICAgfVxuXG4gICAgY2xvdWQuZGF0YS5zZXQoJ2NsaWVudHMnLCB7XG4gICAgICBjbGVhcjogdHJ1ZVxuICAgIH0sIHZvaWQgMCwgY2xvdWQuc3RhbXApXG5cbiAgICAvLyBUT0RPOiBwdXQgYWxsIGNsb3VkLmNsaWVudCBsb2dpYyBpbiBvbmUgcGxhY2VcbiAgICBpZihjbG91ZC5jbGllbnRpZCAmJiBjbG91ZC5jbGllbnQpIHtcbiAgICAgIGNsb3VkLmNsaWVudC52YWwgPSBjbG91ZC5kYXRhLmNsaWVudHMuZ2V0KGNsb3VkLmNsaWVudGlkLCB7fSlcbiAgICAgIGlmKG15Y2xpZW50KSB7XG4gICAgICAgIGNsb3VkLmNsaWVudC5mcm9tLnZhbCA9IG15Y2xpZW50XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNsb3VkLmRhdGEudXNlcnMpIHtcbiAgICBjbG91ZC5kYXRhLnVzZXJzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ0NMRUFOIENMT1VEOiBjbGVhbiB1c3J0ISEnLCB0aGlzLl9uYW1lKVxuXG4gICAgICB0aGlzLnNldCgnY2xpZW50cycsIHtcbiAgICAgICAgY2xlYXI6IHRydWVcbiAgICAgIH0sIHZvaWQgMCwgY2xvdWQuc3RhbXApXG5cbiAgICAgIC8vIENMRUFOIE1BSU5TQ1JFRU4gQU5EIEFDVElWRSBDTElFTlQ/IVxuXG4gICAgICAvLyB0aGlzLm1haW5zY3JlZW4uc2V0KCdjbGllbnRSZWYnLCBmYWxzZSwgdm9pZCAwLCBjbG91ZC5zdGFtcClcbiAgICAgIC8vIHRoaXMubWFpbnNjcmVlbi5jbGllbnRSZWYucmVtb3ZlKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgY2xvdWQuc3RhbXApXG5cbiAgICAgIC8vIHRoaXMuYWN0aXZlQ2xpZW50LnJlbW92ZSh2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGNsb3VkLnN0YW1wKVxuXG4gICAgfSlcbiAgfVxuXG4gIC8vIGlmKHNldHMubGVuZ3RoKXtcbiAgLy8gICBzZXRzLnNvcnQoYnlUcylcbiAgLy8gICBmb3IodmFyIGkgPSAwLCBzZXQgOyBzZXQgPSBzZXRzW2krK107KXtcbiAgLy8gICAgIGlmKHNldFsxXSA9PT0gJyQkbnVsbCcpXG4gIC8vICAgICAgIHNldFsxXSA9IG51bGxcbiAgLy8gICB9XG4gIC8vICAgY2xvdWQud3JpdGUoe3NldHM6c2V0c30pXG4gIC8vICAgLy8gd291bGQgYmUgbmljZXIgdG8gaW5zZXJ0IHRoZW0gaW50byBjdXJyZW50IGJhdGNoXG4gIC8vIH1cblxuICB2YXIgcmVzdWJzID0gW11cbiAgc3Vicy5lYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3Jlc3ViPycsIGYpXG4gICAgdmFyIGNhY2hlZCA9IHRoaXMsXG4gICAgICBhY3RpdmUgPSBjYWNoZWQuYWN0aXZlLFxuICAgICAgY2xlYXJlZCA9IGNhY2hlZC5jbGVhcmVkXG5cbiAgICBpZiAoYWN0aXZlLl92YWwgPT09IDEpIHtcbiAgICAgIGFjdGl2ZS52YWwgPSB0cnVlXG4gICAgICBjbGVhcmVkLnZhbCA9IHRydWVcbiAgICB9IGVsc2UgaWYgKGFjdGl2ZS5fdmFsKSB7XG4gICAgICAvLyBhY3RpdmUuX3ZhbCA9IGZhbHNlXG5cbiAgICAgIGFjdGl2ZS52YWwgPSBmYWxzZVxuICAgICAgLy8gZGl0IHdvcmR0IG5pZXQgaW4gbHMgb3BnZWxzYWdlblxuXG4gICAgICBpZiAoY2xlYXJlZC5fdmFsID09PSAxKSB7XG4gICAgICAgIGNsZWFyZWQudmFsID0gdHJ1ZVxuICAgICAgfSBlbHNlIGlmIChjbGVhcmVkLl92YWwpIHtcbiAgICAgICAgY2xlYXJlZC52YWwgPSBmYWxzZVxuICAgICAgfVxuICAgICAgcmVzdWJzLnB1c2goY2FjaGVkKVxuICAgIH0gZWxzZSBpZiAoY2xlYXJlZC5fdmFsKSB7XG4gICAgICBpZiAoY2xlYXJlZC5fdmFsID09PSAxKSB7XG4gICAgICAgIGNsZWFyZWQudmFsID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYXJlZC52YWwgPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICB9KVxuICBmb3IgKHZhciBpID0gMCwgcmVzdWI7IHJlc3ViID0gcmVzdWJzW2ldOyBpKyspIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCdyZXN1YnNjcmliZSEhJywgcmVzdWIuc3Vic29iai5yYXcpXG4gICAgY2xvdWQuc3Vic2NyaWJlKHJlc3ViKVxuICB9XG4gIC8vIGNvbnNvbGUuZXJyb3IoJ2RvbmUgcmVzdWJzY3JpYmluJylcblxuICBmb3IgKHZhciBqIGluIGNsb3VkLl9qb2lucykge1xuICAgIGNsb3VkLmpvaW4oY2xvdWQuX2pvaW5zW2pdLCB0cnVlKVxuICB9XG5cbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS50aW1lU3RhbXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cyA9IHRpbWVzdGFtcCgpXG4gIGlmICh0aGlzLl90aW1lT2Zmc2V0KSB7XG4gICAgdHMgKz0gdGhpcy5fdGltZU9mZnNldFxuICB9XG4gIHJldHVybiB0c1xufVxuXG5mdW5jdGlvbiBpbnNlcnRMZWFmICh0cmVlLCBzdWJzb2JqLCBjYWNoZWQpIHtcbiAgc3Vic29iai5lYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgaWYgKGYgPT09ICcqJykge1xuICAgICAgaWYgKCF0cmVlLiQpIHtcbiAgICAgICAgdHJlZS5zZXQoJyQnLCB7fSlcbiAgICAgIH1cbiAgICAgIHN1YnNvYmpbJyonXS5lYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHN1YnNvYmpbJyonXVtzXVsxXS5lYWNoKGZ1bmN0aW9uIChzcykge1xuICAgICAgICAgIGluc2VydExlYWYodHJlZS4kLCBzdWJzb2JqWycqJ11bc11bMV1bc3NdLCBjYWNoZWQpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICghdHJlZVtmXSkge1xuICAgICAgdHJlZS5zZXQoZiwge30pXG4gICAgfVxuICAgIGlmIChzdWJzb2JqW2ZdLnZhbCA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKCF0cmVlW2ZdLl9zdWJzKSB7XG4gICAgICAgIHRyZWVbZl0uc2V0KCdfc3VicycsIFtjYWNoZWRdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJlZVtmXS5fc3Vicy5wdXNoKGNhY2hlZClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW5zZXJ0TGVhZih0cmVlW2ZdLCBzdWJzb2JqW2ZdLCBjYWNoZWQpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBtb3ZlVG9FbmQgKGFyciwgaSkge1xuICB2YXIgdG1wID0gYXJyW2ldXG4gIHdoaWxlIChhcnJbaSArIDFdKSB7XG4gICAgYXJyW2ldID0gYXJyWysraV1cbiAgfVxuICBhcnJbaV0gPSB0bXBcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSW5kZXggKGFyciwgaSkge1xuICB3aGlsZSAoYXJyW2kgKyAxXSkge1xuICAgIGFycltpXSA9IGFyclsrK2ldXG4gIH1cbiAgYXJyLnBvcCgpXG59XG5cbi8vIGZ1bmN0aW9uIGJ5VHMgKGEsIGIpIHtcbi8vICAgcmV0dXJuIGFbMl0gLSBiWzJdXG4vLyB9XG4iLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBNYXJjdXMgQmVzamVzLCBtYXJjdXNAdmlnb3VyLmlvXG4gKi9cblxudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJyksXG4gIGlvID0gdXRpbC5pc05vZGUgXG4gICAgPyByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50JykgXG4gICAgOiByZXF1aXJlKCcuL3NvY2tldC5pby5taW4uanMnKSxcbiAgRyA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvZ2xvYmFsJyksXG4gIGlkID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9pZCcpLFxuICB1cmxFbmNvZGUgPSByZXF1aXJlKCcuLi9hamF4JykuZW5jb2RlLFxuICBWT2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vb2JqZWN0JyksXG4gIFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUnKSxcbiAgRW1pdHRlciA9IHJlcXVpcmUoJy4vZW1pdHRlcicpXG5cbnZhciBDbG91ZCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gQ2xvdWQgKHVybCwgcGFyYW1zKSB7XG4gIFxuICBpZiAoIXBhcmFtcykge1xuICAgIHBhcmFtcyA9IHt9XG4gIH1cblxuICB2YXIgY2xvdWQgPSB0aGlzXG4gIGNsb3VkLnBhcmFtcyA9IHBhcmFtc1xuICBjbG91ZC51cmwgPSB1cmxcbiAgY2xvdWQuVklEID0gcGFyYW1zLlZJRCA9IGZpeFZJRChwYXJhbXMuVklEKVxuICAgIC8vIHZhciBISUQgPSBwYXJhbXMuSElEIHx8IEcuZW52KCdISUQnKVxuICAgIC8vIGlmKEhJRClcbiAgICAvLyAgIGNsb3VkLkhJRCA9IHBhcmFtcy5ISUQgPSBISURcbiAgY2xvdWQuY29ubmVjdGVkID0gbmV3IFZhbHVlKGZhbHNlKVxuXG4gIC8vIGNsb3VkLmNvbm5lY3RlZC5hZGRMaXN0ZW5lcihmdW5jdGlvbigpe1xuICAvLyAgIGNvbnNvbGUubG9nKCdjb25uZWN0ZWQ6IHN0YXRlIGNoYW5nZSA+JywgdGhpcy52YWwpXG4gIC8vIH0pXG5cbiAgY2xvdWQuYXBpID0gbmV3IFZhbHVlKHtcbiAgICBkZWZlcjogZnVuY3Rpb24gKHVwZGF0ZSwgYXJncykge1xuICAgICAgdmFyIHR5cGUgPSB0aGlzLmZyb20uX190XG4gICAgICBpZiAodHlwZSAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nsb3VkLmFwaSBuZWVkcyB0byBiZSBhbiBPYmplY3QnKVxuICAgICAgfVxuICAgICAgdXBkYXRlKClcbiAgICB9XG4gIH0pXG5cbiAgLy8gY2xvdWQuYXBpLm9uKGZ1bmN0aW9uKCl7XG4gIC8vICBjb25zb2xlLmVycm9yKCdsb2xrIGNsb3VkLmFwaSBpcyBzZXQhISBvbicsIHRoaXMudmFsKVxuICAvLyB9KVxuXG4gIGlmIChwYXJhbXMuYXBpKSB7XG4gICAgY2xvdWQuYXBpLnZhbCA9IHBhcmFtcy5hcGlcbiAgfVxuXG4gIGNsb3VkLmFkZERvY3VtZW50TGlzdGVuZXJzKClcblxuICBpZiAodXJsIGluc3RhbmNlb2YgVk9iamVjdCkge1xuICAgIHZhciBjdXJyZW50ID0gdXJsLnZhbFxuICAgICAgLy8gY29uc29sZS5sb2coJ2N1cnJlbnQnLCBjdXJyZW50KVxuXG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGNsb3VkLmluaXQodXJsLCBwYXJhbXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwbGFjZWhvbGRlciA9IG5ldyBFbWl0dGVyKClcbiAgICAgIHBsYWNlaG9sZGVyLmVtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBjbG91ZC5lbWl0YnVmZmVyIHx8IChjbG91ZC5lbWl0YnVmZmVyID0gW10pXG4gICAgICAgIGJ1ZmZlci5wdXNoKGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIHBsYWNlaG9sZGVyLnBsYWNlaG9sZGVyID0gdHJ1ZVxuICAgICAgY2xvdWQuc29ja2V0ID0gcGxhY2Vob2xkZXJcbiAgICAgIHVybC5hZGRMaXN0ZW5lcihmdW5jdGlvbiAodmFsLCBwMSwgcDIsIHAzKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdVUkwgVkFMIENIQU5HRScsIHRoaXMudmFsKVxuICAgICAgICBpZiAodGhpcy52YWwpIHtcbiAgICAgICAgICBjbG91ZC5pbml0KHVybCwgcGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjb25zb2xlLmxvZygnbm9ybWFsIGJ1cmsganVzdCBpbml0JywgdXJsKVxuICAgIGNsb3VkLmluaXQodXJsLCBwYXJhbXMpXG4gIH1cblxufVxuXG5DbG91ZC5pbmplY3QgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL2luamVjdCcpXG5cbkNsb3VkLnByb3RvdHlwZS5hZGREb2N1bWVudExpc3RlbmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGNsb3VkID0gdGhpc1xuICBpZiAoIXV0aWwuaXNOb2RlICYmIHdpbmRvdy5jb3Jkb3ZhKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzdW1lJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Nvbm5lY3RlZDogUkVTVU1FJylcbiAgICAgIGNsb3VkLmNvbm5lY3RlZC52YWwgPSBmYWxzZVxuICAgIH0sIGZhbHNlKVxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2Nvbm5lY3RlZDogUEFVU0UnKVxuICAgICAgY2xvdWQuY29ubmVjdGVkLnZhbCA9IGZhbHNlXG4gICAgfSwgZmFsc2UpXG4gIH1cbn1cblxuQ2xvdWQucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMpIHtcbiAgLy8gY29uc29sZS5sb2coJ0NMT1VEIElOSVQhJylcbiAgdmFyIGNsb3VkID0gdGhpcyxcbiAgICBzb2NrZXQgPSBjbG91ZC5jb25uZWN0KHVybCwgcGFyYW1zLFxuICAgICAgeyBkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbG9nKCdkaXNjb25uZWN0JylcbiAgICAgICAgICBjbG91ZC5jb25uZWN0ZWQudmFsID0gZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgY29ubmVjdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGxvZygnY29ubmVjdCcpXG4gICAgICAgICAgY2xvdWQuY29ubmVjdGVkLnZhbCA9IHRydWVcbiAgICAgICAgICBzb2NrZXQuaW8uZW5naW5lLm9uKCdoZWFydGJlYXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbG91ZC5jb25uZWN0ZWQudmFsID0gdHJ1ZVxuICAgICAgICAgIH0pICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICB3ZWxjb21lOiBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgIGxvZygnd2VsY29tZScpXG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc3BsaXQoJ0AnKVxuXG4gICAgICAgICAgdmFyIGNsaWVudGlkID0gY2xvdWQuY2xpZW50aWQgPSBhZGRyZXNzWzBdLFxuICAgICAgICAgICAgaHViaWQgPSBhZGRyZXNzWzFdLFxuICAgICAgICAgICAgc3RhdGUgPSBjbG91ZC5zdGF0ZVxuXG4gICAgICAgICAgY2xvdWQuaHViID0gcGFyYW1zLmggPSBodWJpZFxuXG4gICAgICAgICAgY2xvdWQuc29ja2V0LmlvLnVyaSA9IGZpeFVybChjbG91ZC5zb2NrZXQuaW8udXJpLCBwYXJhbXMpXG4gICAgICAgIH0sXG4gICAgICAgIGhvcDogZnVuY3Rpb24gKG5ld2h1Yikge1xuICAgICAgICAgIGxvZygnaG9wJylcbiAgICAgICAgICBjbG91ZC5ob3AobmV3aHViKVxuICAgICAgICB9LFxuICAgICAgICBlcnI6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBsb2cuZXJyb3IoZXJyKVxuICAgICAgICAgIGlmIChlcnIudHlwZSA9PT0gJ3Rva2VuQ2hlY2snKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3Byb2R1Y3Rpb251c2VyVG9rZW4nKVxuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcklkJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlY29ubmVjdGluZzogbG9nZ2VyKCdyZWNvbm5lY3RpbmcnKSxcbiAgICAgICAgcmVjb25uZWN0X2F0dGVtcHQ6IGxvZ2dlcigncmVjb25uZWN0X2F0dGVtcHQnKSxcbiAgICAgICAgcmVjb25uZWN0OiBsb2dnZXIoJ3JlY29ubmVjdCcpLFxuICAgICAgICByZWNvbm5lY3RfZmFpbGVkOiBsb2dnZXIoJ3JlY29ubmVjdF9mYWlsZWQnKVxuICAgICAgfVxuICAgIClcblxuICB2YXIgZW1pdGJ1ZmZlciA9IGNsb3VkLmVtaXRidWZmZXJcbiAgaWYgKGVtaXRidWZmZXIpIHtcbiAgICBmb3IgKHZhciBlIGluIGVtaXRidWZmZXIpIHtcbiAgICAgIHNvY2tldC5lbWl0LmFwcGx5KHNvY2tldCwgZW1pdGJ1ZmZlcltlXSlcbiAgICB9XG4gICAgY2xvdWQuZW1pdGJ1ZmZlciA9IG51bGxcbiAgfVxuXG59XG5cbkNsb3VkLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKHVybCwgcGFyYW1zLCBsaXN0ZW5lcnMpIHtcblxuICB2YXIgY2xvdWQgPSB0aGlzXG5cbiAgaWYgKCF1cmwpXG4gICAgdXJsID0gY2xvdWQudXJsXG4gIGlmICghcGFyYW1zKVxuICAgIHBhcmFtcyA9IGNsb3VkLnBhcmFtc1xuXG4gIGlmICh1cmwgaW5zdGFuY2VvZiBWT2JqZWN0KSB7XG4gICAgdXJsID0gdXJsLnZhbFxuICB9XG5cbiAgdXJsID0gZml4VXJsKHVybCwgcGFyYW1zKVxuXG4gIHZhciBvbGRzb2NrZXQgPSBjbG91ZC5zb2NrZXRcblxuICBpZiAob2xkc29ja2V0ICYmICFvbGRzb2NrZXQucGxhY2Vob2xkZXIpIHtcbiAgICBvbGRzb2NrZXQuZGlzY29ubmVjdCgpXG4gICAgb2xkc29ja2V0LmlvLmRpc2Nvbm5lY3QoKVxuICB9XG5cbiAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0gY2xvdWQuY29ubmVjdCEnLCB1cmwsIHBhcmFtcylcblxuICB2YXIgc29ja2V0ID0gY2xvdWQuc29ja2V0ID0gbmV3IGlvKHVybCwge1xuICAgIGZvcmNlTmV3OiB0cnVlLFxuICAgIHRpbWVvdXQ6IDVlM1xuICB9KVxuXG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICBmb3IgKHZhciBsIGluIGxpc3RlbmVycykge1xuICAgICAgc29ja2V0Lm9uKGwsIGxpc3RlbmVyc1tsXSlcbiAgICB9XG4gIH1cblxuICBpZiAob2xkc29ja2V0KSB7XG4gICAgLy8gY29uc29sZS5lcnJvcignLS0tLS0tLS0tLS0tLSB0cmFuc2ZlcnJpbmcgb2xkIGxpc3RlbmVycycsIHNvY2tldC5fY2FsbGJhY2tzKVxuICAgIHBhc3NPbihvbGRzb2NrZXQsIHNvY2tldClcbiAgfVxuXG4gIC8vIC0tLS0tLS0gdGhlc2UgZXh0ZW50aW9ucyBhcmUgb25seSBmb3IgbG9nZ2luZ1xuICAvLyB3aW5kb3cuY2xvdWRtZXNzYWdlcyA9IFtdXG4gIC8vIHZhciBfb25ldmVudCA9IGNsb3VkLnNvY2tldC5vbmV2ZW50XG4gIC8vIGNsb3VkLnNvY2tldC5vbmV2ZW50ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICAvLyAgIHdpbmRvdy5jbG91ZG1lc3NhZ2VzLnB1c2goSlNPTi5zdHJpbmdpZnkocGFja2V0LmRhdGEsIGZhbHNlLCAyKSlcbiAgLy8gICBjb25zb2xlLmxvZygnaW5jb21pbmcgY2xvdWQgbWVzc2FnZSEnLCBKU09OLnN0cmluZ2lmeShwYWNrZXQuZGF0YSwgZmFsc2UsIDIpKVxuICAvLyAgIF9vbmV2ZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgLy8gfVxuICAvLyB2YXIgX2VtaXQgPSBjbG91ZC5zb2NrZXQuZW1pdFxuICAvLyBjbG91ZC5zb2NrZXQuZW1pdCA9IGZ1bmN0aW9uIChldmVudCwgZGF0YSkge1xuICAvLyAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgY29uc29sZS5sb2coJ1xcbmNsb3VkLnNvY2tldC5lbWl0OicsIGV2ZW50LCBkYXRhKVxuICAvLyAgICAgaWYgKGV2ZW50ID09PSAnYmF0Y2gnKSB7XG4gIC8vICAgICAgIGlmIChkYXRhLnN1YnMpIHtcbiAgLy8gICAgICAgICBmb3IgKHZhciBzIGluIGRhdGEuc3Vicykge1xuICAvLyAgICAgICAgICAgaWYgKGRhdGEuc3Vic1tzXS5tdHZEYXRhKSB7XG4gIC8vICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdcXG5zdWJzY3JpYmluIHRvIG10dkRhdGEhJywgZGF0YS5zdWJzW3NdLm10dkRhdGEpXG4gIC8vICAgICAgICAgICB9XG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICB9XG4gIC8vICAgICAgIGlmIChkYXRhLnNldHMpIHtcbiAgLy8gICAgICAgICBmb3IgKHZhciBzIGluIGRhdGEuc2V0cykge1xuICAvLyAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignc2V0OicsIEpTT04uc3RyaW5naWZ5KGRhdGEuc2V0c1tzXSkpXG4gIC8vICAgICAgICAgfVxuICAvLyAgICAgICB9XG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyAgIF9lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgLy8gfVxuICAvLyAtLS0tLS0tIHRoZXNlIGV4dGVudGlvbnMgYXJlIG9ubHkgZm9yIGxvZ2dpbmdcbiAgXG4gIHJldHVybiBzb2NrZXRcblxufVxuXG5DbG91ZC5wcm90b3R5cGUuaG9wID0gZnVuY3Rpb24gaG9wIChuZXdodWIpIHtcblxuICAvLyBjb25zb2xlLmxvZygnR09UIE9SREVSIFRPIEhPUCBUTycsIG5ld2h1YilcblxuICB2YXIgY2xvdWQgPSB0aGlzLFxuICAgIHBhcmFtcyA9IGNsb3VkLnBhcmFtc1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLSBkZXZcbiAgaWYgKG5ld2h1Yi5pbmRleE9mKCdAJykgIT09IC0xKVxuICAgIGNsb3VkLnVybCA9ICd3czovLycgKyBuZXdodWIuc3BsaXQoJ0AnKVsxXVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLSAvZGV2XG4gIGNsb3VkLmh1YiA9IHBhcmFtcy5oID0gbmV3aHViXG4gIGNsb3VkLmNvbm5lY3QoKVxufVxuXG5DbG91ZC5wcm90b3R5cGUud2hlblJlYWR5ID0gZnVuY3Rpb24gd2hlblJlYWR5IChmbikge1xuICBpZiAodGhpcy5jbGllbnRpZClcbiAgICBmbigpXG4gIGVsc2VcbiAgICB0aGlzLm9uY2UoJ3dlbGNvbWUnLCBmbilcbn1cblxuQ2xvdWQucHJvdG90eXBlLmtpY2tQaW5nID0gZnVuY3Rpb24ga2lja1BpbmcgKHRpbWUpIHtcbiAgdmFyIGUgPSB0aGlzLnNvY2tldC5pby5lbmdpbmVcbiAgZS5waW5nKClcbiAgZS5vbkhlYXJ0YmVhdCh0aW1lIHx8IGUucGluZ1RpbWVvdXQpXG4gIGUuc2V0UGluZygpXG59XG5cbkNsb3VkLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gZGlzY29ubmVjdCAoKSB7XG4gIHZhciBzb2NrZXQgPSB0aGlzLnNvY2tldFxuICBpZiAoc29ja2V0KSB7XG4gICAgc29ja2V0LmRpc2Nvbm5lY3QoKVxuICAgIHNvY2tldC5pby5kaXNjb25uZWN0KClcbiAgfVxufVxuXG5kZWxlZ2F0ZUxpc3QoQ2xvdWQucHJvdG90eXBlLCAnc29ja2V0JywgWydvbicsICdvbmNlJywgJ2VtaXQnXSlcblxuZnVuY3Rpb24gZGVsZWdhdGVMaXN0IChvYmosIHRhcmdldCwgbGlzdCkge1xuICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGRlbGVnYXRlKG9iaiwgdGFyZ2V0LCBsaXN0W2ldKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlbGVnYXRlIChvYmosIHRhcmdldCwgZmllbGQpIHtcbiAgb2JqW2ZpZWxkXSA9IGZ1bmN0aW9uIGRlbGVnYXRlZCAoKSB7XG4gICAgdmFyIHRoaW5nID0gdGhpc1t0YXJnZXRdXG4gICAgdGhpbmdbZmllbGRdLmFwcGx5KHRoaW5nLCBhcmd1bWVudHMpXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9naXQgKGZsYWcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxvZ2dlciAoKSB7XG4gICAgaWYod2luZG93Lmdhc3Rvbil7XG4gICAgICBjb25zb2xlLmxvZygnOjogdmlnb3VyLWNsb3VkIDo6JywgZmxhZywgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgdmZsYWcgPSAnOjogdmlnb3VyLWNsb3VkIDo6J1xuZnVuY3Rpb24gbG9nICgpIHtcbiAgaWYod2luZG93Lmdhc3Rvbil7XG4gICAgdmFyIGFyZ3MgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gICAgYXJncy51bnNoaWZ0KHZmbGFnKVxuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpXG4gIH1cbn1cbmxvZy5lcnJvciA9IGZ1bmN0aW9uIChmbGFnLCBlcnIpe1xuICBjb25zb2xlLmVycm9yKHZmbGFnLCBmbGFnLCAnXFxuJywgZXJyKVxufVxuZnVuY3Rpb24gbG9nZ2VyIChmbGFnKXtcbiAgcmV0dXJuIGZ1bmN0aW9uIGxvZ2dlciAoKSB7XG4gICAgdmFyIGFyZ3MgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gICAgYXJncy51bnNoaWZ0KHZmbGFnLCBmbGFnKVxuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpXG4gIH1cbn1cblxuZnVuY3Rpb24gZml4VklEIChWSUQpIHtcbiAgVklEID0gVklEIHx8IEcuc2Vzc2lvbignVklEJykgfHwgaWQoJ1ZfJylcbiAgcmV0dXJuIEcuc2Vzc2lvbignVklEJywgVklEKVxufVxuXG5mdW5jdGlvbiBwYXNzT24gKGZyb20sIHRvKSB7XG4gIGZvciAodmFyIGUgaW4gZnJvbS5fY2FsbGJhY2tzKSB7XG4gICAgdmFyIGZyb21saXN0ID0gZnJvbS5fY2FsbGJhY2tzW2VdXG4gICAgZm9yICh2YXIgaSA9IDAsIGZuOyBmbiA9IGZyb21saXN0W2ldOyBpKyspIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdoYW5kIG92ZXIgZGF0IGxpc3RuZXInLCBmbi5uYW1lID09PSAnb24nICYmIGZuLmZuID8gJ29uY2UnIDogJ29uJyxlLCBmbi5mbiB8fCBmbilcbiAgICAgIGlmIChmbi5uYW1lID09PSAnb24nICYmIGZuLmZuKSB7XG4gICAgICAgIHRvLm9uY2UoZSwgZm4uZm4pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0by5vbihlLCBmbilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnJvbS5vZmYoKVxufVxuXG5mdW5jdGlvbiBmaXhVcmwgKHVybCwgcGFyYW1zKSB7XG4gIHZhciBjdXRvZmYgPSB1cmwuaW5kZXhPZignPycpXG4gIGlmIChjdXRvZmYgPiAtMSkge1xuICAgIHVybCA9IHVybC5zbGljZSgwLCBjdXRvZmYpXG4gIH1cbiAgcmV0dXJuIHVybCArICc/JyArIHVybEVuY29kZShwYXJhbXMsICdHRVQnLCAndXJpJylcbn0iLCIhZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciBmO1widW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3c/Zj13aW5kb3c6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbD9mPWdsb2JhbDpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZiYmKGY9c2VsZiksZi5pbz1lKCl9fShmdW5jdGlvbigpe3ZhciBkZWZpbmUsbW9kdWxlLGV4cG9ydHM7cmV0dXJuIGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSh7MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9X2RlcmVxXyhcIi4vbGliL1wiKX0se1wiLi9saWIvXCI6Mn1dLDI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciB1cmw9X2RlcmVxXyhcIi4vdXJsXCIpO3ZhciBwYXJzZXI9X2RlcmVxXyhcInNvY2tldC5pby1wYXJzZXJcIik7dmFyIE1hbmFnZXI9X2RlcmVxXyhcIi4vbWFuYWdlclwiKTt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwic29ja2V0LmlvLWNsaWVudFwiKTttb2R1bGUuZXhwb3J0cz1leHBvcnRzPWxvb2t1cDt2YXIgY2FjaGU9ZXhwb3J0cy5tYW5hZ2Vycz17fTtmdW5jdGlvbiBsb29rdXAodXJpLG9wdHMpe2lmKHR5cGVvZiB1cmk9PVwib2JqZWN0XCIpe29wdHM9dXJpO3VyaT11bmRlZmluZWR9b3B0cz1vcHRzfHx7fTt2YXIgcGFyc2VkPXVybCh1cmkpO3ZhciBzb3VyY2U9cGFyc2VkLnNvdXJjZTt2YXIgaWQ9cGFyc2VkLmlkO3ZhciBpbztpZihvcHRzLmZvcmNlTmV3fHxvcHRzW1wiZm9yY2UgbmV3IGNvbm5lY3Rpb25cIl18fGZhbHNlPT09b3B0cy5tdWx0aXBsZXgpe2RlYnVnKFwiaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlc1wiLHNvdXJjZSk7aW89TWFuYWdlcihzb3VyY2Usb3B0cyl9ZWxzZXtpZighY2FjaGVbaWRdKXtkZWJ1ZyhcIm5ldyBpbyBpbnN0YW5jZSBmb3IgJXNcIixzb3VyY2UpO2NhY2hlW2lkXT1NYW5hZ2VyKHNvdXJjZSxvcHRzKX1pbz1jYWNoZVtpZF19cmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCl9ZXhwb3J0cy5wcm90b2NvbD1wYXJzZXIucHJvdG9jb2w7ZXhwb3J0cy5jb25uZWN0PWxvb2t1cDtleHBvcnRzLk1hbmFnZXI9X2RlcmVxXyhcIi4vbWFuYWdlclwiKTtleHBvcnRzLlNvY2tldD1fZGVyZXFfKFwiLi9zb2NrZXRcIil9LHtcIi4vbWFuYWdlclwiOjMsXCIuL3NvY2tldFwiOjUsXCIuL3VybFwiOjYsZGVidWc6MTAsXCJzb2NrZXQuaW8tcGFyc2VyXCI6NDZ9XSwzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgdXJsPV9kZXJlcV8oXCIuL3VybFwiKTt2YXIgZWlvPV9kZXJlcV8oXCJlbmdpbmUuaW8tY2xpZW50XCIpO3ZhciBTb2NrZXQ9X2RlcmVxXyhcIi4vc29ja2V0XCIpO3ZhciBFbWl0dGVyPV9kZXJlcV8oXCJjb21wb25lbnQtZW1pdHRlclwiKTt2YXIgcGFyc2VyPV9kZXJlcV8oXCJzb2NrZXQuaW8tcGFyc2VyXCIpO3ZhciBvbj1fZGVyZXFfKFwiLi9vblwiKTt2YXIgYmluZD1fZGVyZXFfKFwiY29tcG9uZW50LWJpbmRcIik7dmFyIG9iamVjdD1fZGVyZXFfKFwib2JqZWN0LWNvbXBvbmVudFwiKTt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwic29ja2V0LmlvLWNsaWVudDptYW5hZ2VyXCIpO3ZhciBpbmRleE9mPV9kZXJlcV8oXCJpbmRleG9mXCIpO3ZhciBCYWNrb2ZmPV9kZXJlcV8oXCJiYWNrbzJcIik7bW9kdWxlLmV4cG9ydHM9TWFuYWdlcjtmdW5jdGlvbiBNYW5hZ2VyKHVyaSxvcHRzKXtpZighKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSlyZXR1cm4gbmV3IE1hbmFnZXIodXJpLG9wdHMpO2lmKHVyaSYmXCJvYmplY3RcIj09dHlwZW9mIHVyaSl7b3B0cz11cmk7dXJpPXVuZGVmaW5lZH1vcHRzPW9wdHN8fHt9O29wdHMucGF0aD1vcHRzLnBhdGh8fFwiL3NvY2tldC5pb1wiO3RoaXMubnNwcz17fTt0aGlzLnN1YnM9W107dGhpcy5vcHRzPW9wdHM7dGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24hPT1mYWxzZSk7dGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzfHxJbmZpbml0eSk7dGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5fHwxZTMpO3RoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heHx8NWUzKTt0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yfHwuNSk7dGhpcy5iYWNrb2ZmPW5ldyBCYWNrb2ZmKHttaW46dGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLG1heDp0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCksaml0dGVyOnRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpfSk7dGhpcy50aW1lb3V0KG51bGw9PW9wdHMudGltZW91dD8yZTQ6b3B0cy50aW1lb3V0KTt0aGlzLnJlYWR5U3RhdGU9XCJjbG9zZWRcIjt0aGlzLnVyaT11cmk7dGhpcy5jb25uZWN0ZWQ9W107dGhpcy5lbmNvZGluZz1mYWxzZTt0aGlzLnBhY2tldEJ1ZmZlcj1bXTt0aGlzLmVuY29kZXI9bmV3IHBhcnNlci5FbmNvZGVyO3RoaXMuZGVjb2Rlcj1uZXcgcGFyc2VyLkRlY29kZXI7dGhpcy5hdXRvQ29ubmVjdD1vcHRzLmF1dG9Db25uZWN0IT09ZmFsc2U7aWYodGhpcy5hdXRvQ29ubmVjdCl0aGlzLm9wZW4oKX1NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsPWZ1bmN0aW9uKCl7dGhpcy5lbWl0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTtmb3IodmFyIG5zcCBpbiB0aGlzLm5zcHMpe3RoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sYXJndW1lbnRzKX19O01hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcz1mdW5jdGlvbigpe2Zvcih2YXIgbnNwIGluIHRoaXMubnNwcyl7dGhpcy5uc3BzW25zcF0uaWQ9dGhpcy5lbmdpbmUuaWR9fTtFbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb249ZnVuY3Rpb24odil7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjt0aGlzLl9yZWNvbm5lY3Rpb249ISF2O3JldHVybiB0aGlzfTtNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cz1mdW5jdGlvbih2KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7dGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM9djtyZXR1cm4gdGhpc307TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXk9ZnVuY3Rpb24odil7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O3RoaXMuX3JlY29ubmVjdGlvbkRlbGF5PXY7dGhpcy5iYWNrb2ZmJiZ0aGlzLmJhY2tvZmYuc2V0TWluKHYpO3JldHVybiB0aGlzfTtNYW5hZ2VyLnByb3RvdHlwZS5yYW5kb21pemF0aW9uRmFjdG9yPWZ1bmN0aW9uKHYpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO3RoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I9djt0aGlzLmJhY2tvZmYmJnRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7cmV0dXJuIHRoaXN9O01hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4PWZ1bmN0aW9uKHYpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heDt0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heD12O3RoaXMuYmFja29mZiYmdGhpcy5iYWNrb2ZmLnNldE1heCh2KTtyZXR1cm4gdGhpc307TWFuYWdlci5wcm90b3R5cGUudGltZW91dD1mdW5jdGlvbih2KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fdGltZW91dDt0aGlzLl90aW1lb3V0PXY7cmV0dXJuIHRoaXN9O01hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuPWZ1bmN0aW9uKCl7aWYoIXRoaXMucmVjb25uZWN0aW5nJiZ0aGlzLl9yZWNvbm5lY3Rpb24mJnRoaXMuYmFja29mZi5hdHRlbXB0cz09PTApe3RoaXMucmVjb25uZWN0KCl9fTtNYW5hZ2VyLnByb3RvdHlwZS5vcGVuPU1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oZm4pe2RlYnVnKFwicmVhZHlTdGF0ZSAlc1wiLHRoaXMucmVhZHlTdGF0ZSk7aWYofnRoaXMucmVhZHlTdGF0ZS5pbmRleE9mKFwib3BlblwiKSlyZXR1cm4gdGhpcztkZWJ1ZyhcIm9wZW5pbmcgJXNcIix0aGlzLnVyaSk7dGhpcy5lbmdpbmU9ZWlvKHRoaXMudXJpLHRoaXMub3B0cyk7dmFyIHNvY2tldD10aGlzLmVuZ2luZTt2YXIgc2VsZj10aGlzO3RoaXMucmVhZHlTdGF0ZT1cIm9wZW5pbmdcIjt0aGlzLnNraXBSZWNvbm5lY3Q9ZmFsc2U7dmFyIG9wZW5TdWI9b24oc29ja2V0LFwib3BlblwiLGZ1bmN0aW9uKCl7c2VsZi5vbm9wZW4oKTtmbiYmZm4oKX0pO3ZhciBlcnJvclN1Yj1vbihzb2NrZXQsXCJlcnJvclwiLGZ1bmN0aW9uKGRhdGEpe2RlYnVnKFwiY29ubmVjdF9lcnJvclwiKTtzZWxmLmNsZWFudXAoKTtzZWxmLnJlYWR5U3RhdGU9XCJjbG9zZWRcIjtzZWxmLmVtaXRBbGwoXCJjb25uZWN0X2Vycm9yXCIsZGF0YSk7aWYoZm4pe3ZhciBlcnI9bmV3IEVycm9yKFwiQ29ubmVjdGlvbiBlcnJvclwiKTtlcnIuZGF0YT1kYXRhO2ZuKGVycil9ZWxzZXtzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCl9fSk7aWYoZmFsc2UhPT10aGlzLl90aW1lb3V0KXt2YXIgdGltZW91dD10aGlzLl90aW1lb3V0O2RlYnVnKFwiY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZFwiLHRpbWVvdXQpO3ZhciB0aW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZGVidWcoXCJjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkXCIsdGltZW91dCk7b3BlblN1Yi5kZXN0cm95KCk7c29ja2V0LmNsb3NlKCk7c29ja2V0LmVtaXQoXCJlcnJvclwiLFwidGltZW91dFwiKTtzZWxmLmVtaXRBbGwoXCJjb25uZWN0X3RpbWVvdXRcIix0aW1lb3V0KX0sdGltZW91dCk7dGhpcy5zdWJzLnB1c2goe2Rlc3Ryb3k6ZnVuY3Rpb24oKXtjbGVhclRpbWVvdXQodGltZXIpfX0pfXRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO3RoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtyZXR1cm4gdGhpc307TWFuYWdlci5wcm90b3R5cGUub25vcGVuPWZ1bmN0aW9uKCl7ZGVidWcoXCJvcGVuXCIpO3RoaXMuY2xlYW51cCgpO3RoaXMucmVhZHlTdGF0ZT1cIm9wZW5cIjt0aGlzLmVtaXQoXCJvcGVuXCIpO3ZhciBzb2NrZXQ9dGhpcy5lbmdpbmU7dGhpcy5zdWJzLnB1c2gob24oc29ja2V0LFwiZGF0YVwiLGJpbmQodGhpcyxcIm9uZGF0YVwiKSkpO3RoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlcixcImRlY29kZWRcIixiaW5kKHRoaXMsXCJvbmRlY29kZWRcIikpKTt0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsXCJlcnJvclwiLGJpbmQodGhpcyxcIm9uZXJyb3JcIikpKTt0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsXCJjbG9zZVwiLGJpbmQodGhpcyxcIm9uY2xvc2VcIikpKX07TWFuYWdlci5wcm90b3R5cGUub25kYXRhPWZ1bmN0aW9uKGRhdGEpe3RoaXMuZGVjb2Rlci5hZGQoZGF0YSl9O01hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZD1mdW5jdGlvbihwYWNrZXQpe3RoaXMuZW1pdChcInBhY2tldFwiLHBhY2tldCl9O01hbmFnZXIucHJvdG90eXBlLm9uZXJyb3I9ZnVuY3Rpb24oZXJyKXtkZWJ1ZyhcImVycm9yXCIsZXJyKTt0aGlzLmVtaXRBbGwoXCJlcnJvclwiLGVycil9O01hbmFnZXIucHJvdG90eXBlLnNvY2tldD1mdW5jdGlvbihuc3Ape3ZhciBzb2NrZXQ9dGhpcy5uc3BzW25zcF07aWYoIXNvY2tldCl7c29ja2V0PW5ldyBTb2NrZXQodGhpcyxuc3ApO3RoaXMubnNwc1tuc3BdPXNvY2tldDt2YXIgc2VsZj10aGlzO3NvY2tldC5vbihcImNvbm5lY3RcIixmdW5jdGlvbigpe3NvY2tldC5pZD1zZWxmLmVuZ2luZS5pZDtpZighfmluZGV4T2Yoc2VsZi5jb25uZWN0ZWQsc29ja2V0KSl7c2VsZi5jb25uZWN0ZWQucHVzaChzb2NrZXQpfX0pfXJldHVybiBzb2NrZXR9O01hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oc29ja2V0KXt2YXIgaW5kZXg9aW5kZXhPZih0aGlzLmNvbm5lY3RlZCxzb2NrZXQpO2lmKH5pbmRleCl0aGlzLmNvbm5lY3RlZC5zcGxpY2UoaW5kZXgsMSk7aWYodGhpcy5jb25uZWN0ZWQubGVuZ3RoKXJldHVybjt0aGlzLmNsb3NlKCl9O01hbmFnZXIucHJvdG90eXBlLnBhY2tldD1mdW5jdGlvbihwYWNrZXQpe2RlYnVnKFwid3JpdGluZyBwYWNrZXQgJWpcIixwYWNrZXQpO3ZhciBzZWxmPXRoaXM7aWYoIXNlbGYuZW5jb2Rpbmcpe3NlbGYuZW5jb2Rpbmc9dHJ1ZTt0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCxmdW5jdGlvbihlbmNvZGVkUGFja2V0cyl7Zm9yKHZhciBpPTA7aTxlbmNvZGVkUGFja2V0cy5sZW5ndGg7aSsrKXtzZWxmLmVuZ2luZS53cml0ZShlbmNvZGVkUGFja2V0c1tpXSl9c2VsZi5lbmNvZGluZz1mYWxzZTtzZWxmLnByb2Nlc3NQYWNrZXRRdWV1ZSgpfSl9ZWxzZXtzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCl9fTtNYW5hZ2VyLnByb3RvdHlwZS5wcm9jZXNzUGFja2V0UXVldWU9ZnVuY3Rpb24oKXtpZih0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGg+MCYmIXRoaXMuZW5jb2Rpbmcpe3ZhciBwYWNrPXRoaXMucGFja2V0QnVmZmVyLnNoaWZ0KCk7dGhpcy5wYWNrZXQocGFjayl9fTtNYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwPWZ1bmN0aW9uKCl7dmFyIHN1Yjt3aGlsZShzdWI9dGhpcy5zdWJzLnNoaWZ0KCkpc3ViLmRlc3Ryb3koKTt0aGlzLnBhY2tldEJ1ZmZlcj1bXTt0aGlzLmVuY29kaW5nPWZhbHNlO3RoaXMuZGVjb2Rlci5kZXN0cm95KCl9O01hbmFnZXIucHJvdG90eXBlLmNsb3NlPU1hbmFnZXIucHJvdG90eXBlLmRpc2Nvbm5lY3Q9ZnVuY3Rpb24oKXt0aGlzLnNraXBSZWNvbm5lY3Q9dHJ1ZTt0aGlzLmJhY2tvZmYucmVzZXQoKTt0aGlzLnJlYWR5U3RhdGU9XCJjbG9zZWRcIjt0aGlzLmVuZ2luZSYmdGhpcy5lbmdpbmUuY2xvc2UoKX07TWFuYWdlci5wcm90b3R5cGUub25jbG9zZT1mdW5jdGlvbihyZWFzb24pe2RlYnVnKFwiY2xvc2VcIik7dGhpcy5jbGVhbnVwKCk7dGhpcy5iYWNrb2ZmLnJlc2V0KCk7dGhpcy5yZWFkeVN0YXRlPVwiY2xvc2VkXCI7dGhpcy5lbWl0KFwiY2xvc2VcIixyZWFzb24pO2lmKHRoaXMuX3JlY29ubmVjdGlvbiYmIXRoaXMuc2tpcFJlY29ubmVjdCl7dGhpcy5yZWNvbm5lY3QoKX19O01hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdD1mdW5jdGlvbigpe2lmKHRoaXMucmVjb25uZWN0aW5nfHx0aGlzLnNraXBSZWNvbm5lY3QpcmV0dXJuIHRoaXM7dmFyIHNlbGY9dGhpcztpZih0aGlzLmJhY2tvZmYuYXR0ZW1wdHM+PXRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKXtkZWJ1ZyhcInJlY29ubmVjdCBmYWlsZWRcIik7dGhpcy5iYWNrb2ZmLnJlc2V0KCk7dGhpcy5lbWl0QWxsKFwicmVjb25uZWN0X2ZhaWxlZFwiKTt0aGlzLnJlY29ubmVjdGluZz1mYWxzZX1lbHNle3ZhciBkZWxheT10aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtkZWJ1ZyhcIndpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdFwiLGRlbGF5KTt0aGlzLnJlY29ubmVjdGluZz10cnVlO3ZhciB0aW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoc2VsZi5za2lwUmVjb25uZWN0KXJldHVybjtkZWJ1ZyhcImF0dGVtcHRpbmcgcmVjb25uZWN0XCIpO3NlbGYuZW1pdEFsbChcInJlY29ubmVjdF9hdHRlbXB0XCIsc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtzZWxmLmVtaXRBbGwoXCJyZWNvbm5lY3RpbmdcIixzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO2lmKHNlbGYuc2tpcFJlY29ubmVjdClyZXR1cm47c2VsZi5vcGVuKGZ1bmN0aW9uKGVycil7aWYoZXJyKXtkZWJ1ZyhcInJlY29ubmVjdCBhdHRlbXB0IGVycm9yXCIpO3NlbGYucmVjb25uZWN0aW5nPWZhbHNlO3NlbGYucmVjb25uZWN0KCk7c2VsZi5lbWl0QWxsKFwicmVjb25uZWN0X2Vycm9yXCIsZXJyLmRhdGEpfWVsc2V7ZGVidWcoXCJyZWNvbm5lY3Qgc3VjY2Vzc1wiKTtzZWxmLm9ucmVjb25uZWN0KCl9fSl9LGRlbGF5KTt0aGlzLnN1YnMucHVzaCh7ZGVzdHJveTpmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aW1lcil9fSl9fTtNYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdD1mdW5jdGlvbigpe3ZhciBhdHRlbXB0PXRoaXMuYmFja29mZi5hdHRlbXB0czt0aGlzLnJlY29ubmVjdGluZz1mYWxzZTt0aGlzLmJhY2tvZmYucmVzZXQoKTt0aGlzLnVwZGF0ZVNvY2tldElkcygpO3RoaXMuZW1pdEFsbChcInJlY29ubmVjdFwiLGF0dGVtcHQpfX0se1wiLi9vblwiOjQsXCIuL3NvY2tldFwiOjUsXCIuL3VybFwiOjYsYmFja28yOjcsXCJjb21wb25lbnQtYmluZFwiOjgsXCJjb21wb25lbnQtZW1pdHRlclwiOjksZGVidWc6MTAsXCJlbmdpbmUuaW8tY2xpZW50XCI6MTEsaW5kZXhvZjo0MixcIm9iamVjdC1jb21wb25lbnRcIjo0MyxcInNvY2tldC5pby1wYXJzZXJcIjo0Nn1dLDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPW9uO2Z1bmN0aW9uIG9uKG9iaixldixmbil7b2JqLm9uKGV2LGZuKTtyZXR1cm57ZGVzdHJveTpmdW5jdGlvbigpe29iai5yZW1vdmVMaXN0ZW5lcihldixmbil9fX19LHt9XSw1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgcGFyc2VyPV9kZXJlcV8oXCJzb2NrZXQuaW8tcGFyc2VyXCIpO3ZhciBFbWl0dGVyPV9kZXJlcV8oXCJjb21wb25lbnQtZW1pdHRlclwiKTt2YXIgdG9BcnJheT1fZGVyZXFfKFwidG8tYXJyYXlcIik7dmFyIG9uPV9kZXJlcV8oXCIuL29uXCIpO3ZhciBiaW5kPV9kZXJlcV8oXCJjb21wb25lbnQtYmluZFwiKTt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwic29ja2V0LmlvLWNsaWVudDpzb2NrZXRcIik7dmFyIGhhc0Jpbj1fZGVyZXFfKFwiaGFzLWJpbmFyeVwiKTttb2R1bGUuZXhwb3J0cz1leHBvcnRzPVNvY2tldDt2YXIgZXZlbnRzPXtjb25uZWN0OjEsY29ubmVjdF9lcnJvcjoxLGNvbm5lY3RfdGltZW91dDoxLGRpc2Nvbm5lY3Q6MSxlcnJvcjoxLHJlY29ubmVjdDoxLHJlY29ubmVjdF9hdHRlbXB0OjEscmVjb25uZWN0X2ZhaWxlZDoxLHJlY29ubmVjdF9lcnJvcjoxLHJlY29ubmVjdGluZzoxfTt2YXIgZW1pdD1FbWl0dGVyLnByb3RvdHlwZS5lbWl0O2Z1bmN0aW9uIFNvY2tldChpbyxuc3Ape3RoaXMuaW89aW87dGhpcy5uc3A9bnNwO3RoaXMuanNvbj10aGlzO3RoaXMuaWRzPTA7dGhpcy5hY2tzPXt9O2lmKHRoaXMuaW8uYXV0b0Nvbm5lY3QpdGhpcy5vcGVuKCk7dGhpcy5yZWNlaXZlQnVmZmVyPVtdO3RoaXMuc2VuZEJ1ZmZlcj1bXTt0aGlzLmNvbm5lY3RlZD1mYWxzZTt0aGlzLmRpc2Nvbm5lY3RlZD10cnVlfUVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7U29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHM9ZnVuY3Rpb24oKXtpZih0aGlzLnN1YnMpcmV0dXJuO3ZhciBpbz10aGlzLmlvO3RoaXMuc3Vicz1bb24oaW8sXCJvcGVuXCIsYmluZCh0aGlzLFwib25vcGVuXCIpKSxvbihpbyxcInBhY2tldFwiLGJpbmQodGhpcyxcIm9ucGFja2V0XCIpKSxvbihpbyxcImNsb3NlXCIsYmluZCh0aGlzLFwib25jbG9zZVwiKSldfTtTb2NrZXQucHJvdG90eXBlLm9wZW49U29ja2V0LnByb3RvdHlwZS5jb25uZWN0PWZ1bmN0aW9uKCl7aWYodGhpcy5jb25uZWN0ZWQpcmV0dXJuIHRoaXM7dGhpcy5zdWJFdmVudHMoKTt0aGlzLmlvLm9wZW4oKTtpZihcIm9wZW5cIj09dGhpcy5pby5yZWFkeVN0YXRlKXRoaXMub25vcGVuKCk7cmV0dXJuIHRoaXN9O1NvY2tldC5wcm90b3R5cGUuc2VuZD1mdW5jdGlvbigpe3ZhciBhcmdzPXRvQXJyYXkoYXJndW1lbnRzKTthcmdzLnVuc2hpZnQoXCJtZXNzYWdlXCIpO3RoaXMuZW1pdC5hcHBseSh0aGlzLGFyZ3MpO3JldHVybiB0aGlzfTtTb2NrZXQucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZXYpe2lmKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpe2VtaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiB0aGlzfXZhciBhcmdzPXRvQXJyYXkoYXJndW1lbnRzKTt2YXIgcGFyc2VyVHlwZT1wYXJzZXIuRVZFTlQ7aWYoaGFzQmluKGFyZ3MpKXtwYXJzZXJUeXBlPXBhcnNlci5CSU5BUllfRVZFTlR9dmFyIHBhY2tldD17dHlwZTpwYXJzZXJUeXBlLGRhdGE6YXJnc307aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgYXJnc1thcmdzLmxlbmd0aC0xXSl7ZGVidWcoXCJlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWRcIix0aGlzLmlkcyk7dGhpcy5hY2tzW3RoaXMuaWRzXT1hcmdzLnBvcCgpO3BhY2tldC5pZD10aGlzLmlkcysrfWlmKHRoaXMuY29ubmVjdGVkKXt0aGlzLnBhY2tldChwYWNrZXQpfWVsc2V7dGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KX1yZXR1cm4gdGhpc307U29ja2V0LnByb3RvdHlwZS5wYWNrZXQ9ZnVuY3Rpb24ocGFja2V0KXtwYWNrZXQubnNwPXRoaXMubnNwO3RoaXMuaW8ucGFja2V0KHBhY2tldCl9O1NvY2tldC5wcm90b3R5cGUub25vcGVuPWZ1bmN0aW9uKCl7ZGVidWcoXCJ0cmFuc3BvcnQgaXMgb3BlbiAtIGNvbm5lY3RpbmdcIik7aWYoXCIvXCIhPXRoaXMubnNwKXt0aGlzLnBhY2tldCh7dHlwZTpwYXJzZXIuQ09OTkVDVH0pfX07U29ja2V0LnByb3RvdHlwZS5vbmNsb3NlPWZ1bmN0aW9uKHJlYXNvbil7ZGVidWcoXCJjbG9zZSAoJXMpXCIscmVhc29uKTt0aGlzLmNvbm5lY3RlZD1mYWxzZTt0aGlzLmRpc2Nvbm5lY3RlZD10cnVlO2RlbGV0ZSB0aGlzLmlkO3RoaXMuZW1pdChcImRpc2Nvbm5lY3RcIixyZWFzb24pfTtTb2NrZXQucHJvdG90eXBlLm9ucGFja2V0PWZ1bmN0aW9uKHBhY2tldCl7aWYocGFja2V0Lm5zcCE9dGhpcy5uc3ApcmV0dXJuO3N3aXRjaChwYWNrZXQudHlwZSl7Y2FzZSBwYXJzZXIuQ09OTkVDVDp0aGlzLm9uY29ubmVjdCgpO2JyZWFrO2Nhc2UgcGFyc2VyLkVWRU5UOnRoaXMub25ldmVudChwYWNrZXQpO2JyZWFrO2Nhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDp0aGlzLm9uZXZlbnQocGFja2V0KTticmVhaztjYXNlIHBhcnNlci5BQ0s6dGhpcy5vbmFjayhwYWNrZXQpO2JyZWFrO2Nhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6dGhpcy5vbmFjayhwYWNrZXQpO2JyZWFrO2Nhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6dGhpcy5vbmRpc2Nvbm5lY3QoKTticmVhaztjYXNlIHBhcnNlci5FUlJPUjp0aGlzLmVtaXQoXCJlcnJvclwiLHBhY2tldC5kYXRhKTticmVha319O1NvY2tldC5wcm90b3R5cGUub25ldmVudD1mdW5jdGlvbihwYWNrZXQpe3ZhciBhcmdzPXBhY2tldC5kYXRhfHxbXTtkZWJ1ZyhcImVtaXR0aW5nIGV2ZW50ICVqXCIsYXJncyk7aWYobnVsbCE9cGFja2V0LmlkKXtkZWJ1ZyhcImF0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnRcIik7YXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpfWlmKHRoaXMuY29ubmVjdGVkKXtlbWl0LmFwcGx5KHRoaXMsYXJncyl9ZWxzZXt0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKX19O1NvY2tldC5wcm90b3R5cGUuYWNrPWZ1bmN0aW9uKGlkKXt2YXIgc2VsZj10aGlzO3ZhciBzZW50PWZhbHNlO3JldHVybiBmdW5jdGlvbigpe2lmKHNlbnQpcmV0dXJuO3NlbnQ9dHJ1ZTt2YXIgYXJncz10b0FycmF5KGFyZ3VtZW50cyk7ZGVidWcoXCJzZW5kaW5nIGFjayAlalwiLGFyZ3MpO3ZhciB0eXBlPWhhc0JpbihhcmdzKT9wYXJzZXIuQklOQVJZX0FDSzpwYXJzZXIuQUNLO3NlbGYucGFja2V0KHt0eXBlOnR5cGUsaWQ6aWQsZGF0YTphcmdzfSl9fTtTb2NrZXQucHJvdG90eXBlLm9uYWNrPWZ1bmN0aW9uKHBhY2tldCl7ZGVidWcoXCJjYWxsaW5nIGFjayAlcyB3aXRoICVqXCIscGFja2V0LmlkLHBhY2tldC5kYXRhKTt2YXIgZm49dGhpcy5hY2tzW3BhY2tldC5pZF07Zm4uYXBwbHkodGhpcyxwYWNrZXQuZGF0YSk7ZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdfTtTb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdD1mdW5jdGlvbigpe3RoaXMuY29ubmVjdGVkPXRydWU7dGhpcy5kaXNjb25uZWN0ZWQ9ZmFsc2U7dGhpcy5lbWl0KFwiY29ubmVjdFwiKTt0aGlzLmVtaXRCdWZmZXJlZCgpfTtTb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZD1mdW5jdGlvbigpe3ZhciBpO2ZvcihpPTA7aTx0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoO2krKyl7ZW1pdC5hcHBseSh0aGlzLHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSl9dGhpcy5yZWNlaXZlQnVmZmVyPVtdO2ZvcihpPTA7aTx0aGlzLnNlbmRCdWZmZXIubGVuZ3RoO2krKyl7dGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKX10aGlzLnNlbmRCdWZmZXI9W119O1NvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0PWZ1bmN0aW9uKCl7ZGVidWcoXCJzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpXCIsdGhpcy5uc3ApO3RoaXMuZGVzdHJveSgpO3RoaXMub25jbG9zZShcImlvIHNlcnZlciBkaXNjb25uZWN0XCIpfTtTb2NrZXQucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtpZih0aGlzLnN1YnMpe2Zvcih2YXIgaT0wO2k8dGhpcy5zdWJzLmxlbmd0aDtpKyspe3RoaXMuc3Vic1tpXS5kZXN0cm95KCl9dGhpcy5zdWJzPW51bGx9dGhpcy5pby5kZXN0cm95KHRoaXMpfTtTb2NrZXQucHJvdG90eXBlLmNsb3NlPVNvY2tldC5wcm90b3R5cGUuZGlzY29ubmVjdD1mdW5jdGlvbigpe2lmKHRoaXMuY29ubmVjdGVkKXtkZWJ1ZyhcInBlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpXCIsdGhpcy5uc3ApO3RoaXMucGFja2V0KHt0eXBlOnBhcnNlci5ESVNDT05ORUNUfSl9dGhpcy5kZXN0cm95KCk7aWYodGhpcy5jb25uZWN0ZWQpe3RoaXMub25jbG9zZShcImlvIGNsaWVudCBkaXNjb25uZWN0XCIpfXJldHVybiB0aGlzfX0se1wiLi9vblwiOjQsXCJjb21wb25lbnQtYmluZFwiOjgsXCJjb21wb25lbnQtZW1pdHRlclwiOjksZGVidWc6MTAsXCJoYXMtYmluYXJ5XCI6MzgsXCJzb2NrZXQuaW8tcGFyc2VyXCI6NDYsXCJ0by1hcnJheVwiOjUwfV0sNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIHBhcnNldXJpPV9kZXJlcV8oXCJwYXJzZXVyaVwiKTt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwic29ja2V0LmlvLWNsaWVudDp1cmxcIik7bW9kdWxlLmV4cG9ydHM9dXJsO2Z1bmN0aW9uIHVybCh1cmksbG9jKXt2YXIgb2JqPXVyaTt2YXIgbG9jPWxvY3x8Z2xvYmFsLmxvY2F0aW9uO2lmKG51bGw9PXVyaSl1cmk9bG9jLnByb3RvY29sK1wiLy9cIitsb2MuaG9zdDtpZihcInN0cmluZ1wiPT10eXBlb2YgdXJpKXtpZihcIi9cIj09dXJpLmNoYXJBdCgwKSl7aWYoXCIvXCI9PXVyaS5jaGFyQXQoMSkpe3VyaT1sb2MucHJvdG9jb2wrdXJpfWVsc2V7dXJpPWxvYy5ob3N0bmFtZSt1cml9fWlmKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpe2RlYnVnKFwicHJvdG9jb2wtbGVzcyB1cmwgJXNcIix1cmkpO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBsb2Mpe3VyaT1sb2MucHJvdG9jb2wrXCIvL1wiK3VyaX1lbHNle3VyaT1cImh0dHBzOi8vXCIrdXJpfX1kZWJ1ZyhcInBhcnNlICVzXCIsdXJpKTtvYmo9cGFyc2V1cmkodXJpKX1pZighb2JqLnBvcnQpe2lmKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKXtvYmoucG9ydD1cIjgwXCJ9ZWxzZSBpZigvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpe29iai5wb3J0PVwiNDQzXCJ9fW9iai5wYXRoPW9iai5wYXRofHxcIi9cIjtvYmouaWQ9b2JqLnByb3RvY29sK1wiOi8vXCIrb2JqLmhvc3QrXCI6XCIrb2JqLnBvcnQ7b2JqLmhyZWY9b2JqLnByb3RvY29sK1wiOi8vXCIrb2JqLmhvc3QrKGxvYyYmbG9jLnBvcnQ9PW9iai5wb3J0P1wiXCI6XCI6XCIrb2JqLnBvcnQpO3JldHVybiBvYmp9fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtkZWJ1ZzoxMCxwYXJzZXVyaTo0NH1dLDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPUJhY2tvZmY7ZnVuY3Rpb24gQmFja29mZihvcHRzKXtvcHRzPW9wdHN8fHt9O3RoaXMubXM9b3B0cy5taW58fDEwMDt0aGlzLm1heD1vcHRzLm1heHx8MWU0O3RoaXMuZmFjdG9yPW9wdHMuZmFjdG9yfHwyO3RoaXMuaml0dGVyPW9wdHMuaml0dGVyPjAmJm9wdHMuaml0dGVyPD0xP29wdHMuaml0dGVyOjA7dGhpcy5hdHRlbXB0cz0wfUJhY2tvZmYucHJvdG90eXBlLmR1cmF0aW9uPWZ1bmN0aW9uKCl7dmFyIG1zPXRoaXMubXMqTWF0aC5wb3codGhpcy5mYWN0b3IsdGhpcy5hdHRlbXB0cysrKTtpZih0aGlzLmppdHRlcil7dmFyIHJhbmQ9TWF0aC5yYW5kb20oKTt2YXIgZGV2aWF0aW9uPU1hdGguZmxvb3IocmFuZCp0aGlzLmppdHRlciptcyk7bXM9KE1hdGguZmxvb3IocmFuZCoxMCkmMSk9PTA/bXMtZGV2aWF0aW9uOm1zK2RldmlhdGlvbn1yZXR1cm4gTWF0aC5taW4obXMsdGhpcy5tYXgpfDB9O0JhY2tvZmYucHJvdG90eXBlLnJlc2V0PWZ1bmN0aW9uKCl7dGhpcy5hdHRlbXB0cz0wfTtCYWNrb2ZmLnByb3RvdHlwZS5zZXRNaW49ZnVuY3Rpb24obWluKXt0aGlzLm1zPW1pbn07QmFja29mZi5wcm90b3R5cGUuc2V0TWF4PWZ1bmN0aW9uKG1heCl7dGhpcy5tYXg9bWF4fTtCYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXI9ZnVuY3Rpb24oaml0dGVyKXt0aGlzLmppdHRlcj1qaXR0ZXJ9fSx7fV0sODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHNsaWNlPVtdLnNsaWNlO21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKG9iaixmbil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGZuKWZuPW9ialtmbl07aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZm4pdGhyb3cgbmV3IEVycm9yKFwiYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb25cIik7dmFyIGFyZ3M9c2xpY2UuY2FsbChhcmd1bWVudHMsMik7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGZuLmFwcGx5KG9iaixhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKX19fSx7fV0sOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9RW1pdHRlcjtmdW5jdGlvbiBFbWl0dGVyKG9iail7aWYob2JqKXJldHVybiBtaXhpbihvYmopfWZ1bmN0aW9uIG1peGluKG9iail7Zm9yKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpe29ialtrZXldPUVtaXR0ZXIucHJvdG90eXBlW2tleV19cmV0dXJuIG9ian1FbWl0dGVyLnByb3RvdHlwZS5vbj1FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGV2ZW50LGZuKXt0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fTsodGhpcy5fY2FsbGJhY2tzW2V2ZW50XT10aGlzLl9jYWxsYmFja3NbZXZlbnRdfHxbXSkucHVzaChmbik7cmV0dXJuIHRoaXN9O0VtaXR0ZXIucHJvdG90eXBlLm9uY2U9ZnVuY3Rpb24oZXZlbnQsZm4pe3ZhciBzZWxmPXRoaXM7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e307ZnVuY3Rpb24gb24oKXtzZWxmLm9mZihldmVudCxvbik7Zm4uYXBwbHkodGhpcyxhcmd1bWVudHMpfW9uLmZuPWZuO3RoaXMub24oZXZlbnQsb24pO3JldHVybiB0aGlzfTtFbWl0dGVyLnByb3RvdHlwZS5vZmY9RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI9RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPUVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oZXZlbnQsZm4pe3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9O2lmKDA9PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMuX2NhbGxiYWNrcz17fTtyZXR1cm4gdGhpc312YXIgY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc1tldmVudF07aWYoIWNhbGxiYWNrcylyZXR1cm4gdGhpcztpZigxPT1hcmd1bWVudHMubGVuZ3RoKXtkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtyZXR1cm4gdGhpc312YXIgY2I7Zm9yKHZhciBpPTA7aTxjYWxsYmFja3MubGVuZ3RoO2krKyl7Y2I9Y2FsbGJhY2tzW2ldO2lmKGNiPT09Zm58fGNiLmZuPT09Zm4pe2NhbGxiYWNrcy5zcGxpY2UoaSwxKTticmVha319cmV0dXJuIHRoaXN9O0VtaXR0ZXIucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZXZlbnQpe3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9O3ZhciBhcmdzPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGNhbGxiYWNrcz10aGlzLl9jYWxsYmFja3NbZXZlbnRdO2lmKGNhbGxiYWNrcyl7Y2FsbGJhY2tzPWNhbGxiYWNrcy5zbGljZSgwKTtmb3IodmFyIGk9MCxsZW49Y2FsbGJhY2tzLmxlbmd0aDtpPGxlbjsrK2kpe2NhbGxiYWNrc1tpXS5hcHBseSh0aGlzLGFyZ3MpfX1yZXR1cm4gdGhpc307RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKGV2ZW50KXt0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fTtyZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XXx8W119O0VtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycz1mdW5jdGlvbihldmVudCl7cmV0dXJuISF0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RofX0se31dLDEwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1kZWJ1ZztmdW5jdGlvbiBkZWJ1ZyhuYW1lKXtpZighZGVidWcuZW5hYmxlZChuYW1lKSlyZXR1cm4gZnVuY3Rpb24oKXt9O3JldHVybiBmdW5jdGlvbihmbXQpe2ZtdD1jb2VyY2UoZm10KTt2YXIgY3Vycj1uZXcgRGF0ZTt2YXIgbXM9Y3Vyci0oZGVidWdbbmFtZV18fGN1cnIpO2RlYnVnW25hbWVdPWN1cnI7Zm10PW5hbWUrXCIgXCIrZm10K1wiICtcIitkZWJ1Zy5odW1hbml6ZShtcyk7d2luZG93LmNvbnNvbGUmJmNvbnNvbGUubG9nJiZGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZyxjb25zb2xlLGFyZ3VtZW50cyl9fWRlYnVnLm5hbWVzPVtdO2RlYnVnLnNraXBzPVtdO2RlYnVnLmVuYWJsZT1mdW5jdGlvbihuYW1lKXt0cnl7bG9jYWxTdG9yYWdlLmRlYnVnPW5hbWV9Y2F0Y2goZSl7fXZhciBzcGxpdD0obmFtZXx8XCJcIikuc3BsaXQoL1tcXHMsXSsvKSxsZW49c3BsaXQubGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuO2krKyl7bmFtZT1zcGxpdFtpXS5yZXBsYWNlKFwiKlwiLFwiLio/XCIpO2lmKG5hbWVbMF09PT1cIi1cIil7ZGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKFwiXlwiK25hbWUuc3Vic3RyKDEpK1wiJFwiKSl9ZWxzZXtkZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrbmFtZStcIiRcIikpfX19O2RlYnVnLmRpc2FibGU9ZnVuY3Rpb24oKXtkZWJ1Zy5lbmFibGUoXCJcIil9O2RlYnVnLmh1bWFuaXplPWZ1bmN0aW9uKG1zKXt2YXIgc2VjPTFlMyxtaW49NjAqMWUzLGhvdXI9NjAqbWluO2lmKG1zPj1ob3VyKXJldHVybihtcy9ob3VyKS50b0ZpeGVkKDEpK1wiaFwiO2lmKG1zPj1taW4pcmV0dXJuKG1zL21pbikudG9GaXhlZCgxKStcIm1cIjtpZihtcz49c2VjKXJldHVybihtcy9zZWN8MCkrXCJzXCI7cmV0dXJuIG1zK1wibXNcIn07ZGVidWcuZW5hYmxlZD1mdW5jdGlvbihuYW1lKXtmb3IodmFyIGk9MCxsZW49ZGVidWcuc2tpcHMubGVuZ3RoO2k8bGVuO2krKyl7aWYoZGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSl7cmV0dXJuIGZhbHNlfX1mb3IodmFyIGk9MCxsZW49ZGVidWcubmFtZXMubGVuZ3RoO2k8bGVuO2krKyl7aWYoZGVidWcubmFtZXNbaV0udGVzdChuYW1lKSl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX07ZnVuY3Rpb24gY29lcmNlKHZhbCl7aWYodmFsIGluc3RhbmNlb2YgRXJyb3IpcmV0dXJuIHZhbC5zdGFja3x8dmFsLm1lc3NhZ2U7cmV0dXJuIHZhbH10cnl7aWYod2luZG93LmxvY2FsU3RvcmFnZSlkZWJ1Zy5lbmFibGUobG9jYWxTdG9yYWdlLmRlYnVnKX1jYXRjaChlKXt9fSx7fV0sMTE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPV9kZXJlcV8oXCIuL2xpYi9cIil9LHtcIi4vbGliL1wiOjEyfV0sMTI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPV9kZXJlcV8oXCIuL3NvY2tldFwiKTttb2R1bGUuZXhwb3J0cy5wYXJzZXI9X2RlcmVxXyhcImVuZ2luZS5pby1wYXJzZXJcIil9LHtcIi4vc29ja2V0XCI6MTMsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MjV9XSwxMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIHRyYW5zcG9ydHM9X2RlcmVxXyhcIi4vdHJhbnNwb3J0c1wiKTt2YXIgRW1pdHRlcj1fZGVyZXFfKFwiY29tcG9uZW50LWVtaXR0ZXJcIik7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcImVuZ2luZS5pby1jbGllbnQ6c29ja2V0XCIpO3ZhciBpbmRleD1fZGVyZXFfKFwiaW5kZXhvZlwiKTt2YXIgcGFyc2VyPV9kZXJlcV8oXCJlbmdpbmUuaW8tcGFyc2VyXCIpO3ZhciBwYXJzZXVyaT1fZGVyZXFfKFwicGFyc2V1cmlcIik7dmFyIHBhcnNlanNvbj1fZGVyZXFfKFwicGFyc2Vqc29uXCIpO3ZhciBwYXJzZXFzPV9kZXJlcV8oXCJwYXJzZXFzXCIpO21vZHVsZS5leHBvcnRzPVNvY2tldDtmdW5jdGlvbiBub29wKCl7fWZ1bmN0aW9uIFNvY2tldCh1cmksb3B0cyl7aWYoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSlyZXR1cm4gbmV3IFNvY2tldCh1cmksb3B0cyk7b3B0cz1vcHRzfHx7fTtpZih1cmkmJlwib2JqZWN0XCI9PXR5cGVvZiB1cmkpe29wdHM9dXJpO3VyaT1udWxsfWlmKHVyaSl7dXJpPXBhcnNldXJpKHVyaSk7b3B0cy5ob3N0PXVyaS5ob3N0O29wdHMuc2VjdXJlPXVyaS5wcm90b2NvbD09XCJodHRwc1wifHx1cmkucHJvdG9jb2w9PVwid3NzXCI7b3B0cy5wb3J0PXVyaS5wb3J0O2lmKHVyaS5xdWVyeSlvcHRzLnF1ZXJ5PXVyaS5xdWVyeX10aGlzLnNlY3VyZT1udWxsIT1vcHRzLnNlY3VyZT9vcHRzLnNlY3VyZTpnbG9iYWwubG9jYXRpb24mJlwiaHR0cHM6XCI9PWxvY2F0aW9uLnByb3RvY29sO2lmKG9wdHMuaG9zdCl7dmFyIHBpZWNlcz1vcHRzLmhvc3Quc3BsaXQoXCI6XCIpO29wdHMuaG9zdG5hbWU9cGllY2VzLnNoaWZ0KCk7aWYocGllY2VzLmxlbmd0aCl7b3B0cy5wb3J0PXBpZWNlcy5wb3AoKX1lbHNlIGlmKCFvcHRzLnBvcnQpe29wdHMucG9ydD10aGlzLnNlY3VyZT9cIjQ0M1wiOlwiODBcIn19dGhpcy5hZ2VudD1vcHRzLmFnZW50fHxmYWxzZTt0aGlzLmhvc3RuYW1lPW9wdHMuaG9zdG5hbWV8fChnbG9iYWwubG9jYXRpb24/bG9jYXRpb24uaG9zdG5hbWU6XCJsb2NhbGhvc3RcIik7dGhpcy5wb3J0PW9wdHMucG9ydHx8KGdsb2JhbC5sb2NhdGlvbiYmbG9jYXRpb24ucG9ydD9sb2NhdGlvbi5wb3J0OnRoaXMuc2VjdXJlPzQ0Mzo4MCk7dGhpcy5xdWVyeT1vcHRzLnF1ZXJ5fHx7fTtpZihcInN0cmluZ1wiPT10eXBlb2YgdGhpcy5xdWVyeSl0aGlzLnF1ZXJ5PXBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO3RoaXMudXBncmFkZT1mYWxzZSE9PW9wdHMudXBncmFkZTt0aGlzLnBhdGg9KG9wdHMucGF0aHx8XCIvZW5naW5lLmlvXCIpLnJlcGxhY2UoL1xcLyQvLFwiXCIpK1wiL1wiO3RoaXMuZm9yY2VKU09OUD0hIW9wdHMuZm9yY2VKU09OUDt0aGlzLmpzb25wPWZhbHNlIT09b3B0cy5qc29ucDt0aGlzLmZvcmNlQmFzZTY0PSEhb3B0cy5mb3JjZUJhc2U2NDt0aGlzLmVuYWJsZXNYRFI9ISFvcHRzLmVuYWJsZXNYRFI7dGhpcy50aW1lc3RhbXBQYXJhbT1vcHRzLnRpbWVzdGFtcFBhcmFtfHxcInRcIjt0aGlzLnRpbWVzdGFtcFJlcXVlc3RzPW9wdHMudGltZXN0YW1wUmVxdWVzdHM7dGhpcy50cmFuc3BvcnRzPW9wdHMudHJhbnNwb3J0c3x8W1wicG9sbGluZ1wiLFwid2Vic29ja2V0XCJdO3RoaXMucmVhZHlTdGF0ZT1cIlwiO3RoaXMud3JpdGVCdWZmZXI9W107dGhpcy5jYWxsYmFja0J1ZmZlcj1bXTt0aGlzLnBvbGljeVBvcnQ9b3B0cy5wb2xpY3lQb3J0fHw4NDM7dGhpcy5yZW1lbWJlclVwZ3JhZGU9b3B0cy5yZW1lbWJlclVwZ3JhZGV8fGZhbHNlO3RoaXMuYmluYXJ5VHlwZT1udWxsO3RoaXMub25seUJpbmFyeVVwZ3JhZGVzPW9wdHMub25seUJpbmFyeVVwZ3JhZGVzO3RoaXMucGZ4PW9wdHMucGZ4fHxudWxsO3RoaXMua2V5PW9wdHMua2V5fHxudWxsO3RoaXMucGFzc3BocmFzZT1vcHRzLnBhc3NwaHJhc2V8fG51bGw7dGhpcy5jZXJ0PW9wdHMuY2VydHx8bnVsbDt0aGlzLmNhPW9wdHMuY2F8fG51bGw7dGhpcy5jaXBoZXJzPW9wdHMuY2lwaGVyc3x8bnVsbDt0aGlzLnJlamVjdFVuYXV0aG9yaXplZD1vcHRzLnJlamVjdFVuYXV0aG9yaXplZHx8bnVsbDt0aGlzLm9wZW4oKX1Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzPWZhbHNlO0VtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7U29ja2V0LnByb3RvY29sPXBhcnNlci5wcm90b2NvbDtTb2NrZXQuU29ja2V0PVNvY2tldDtTb2NrZXQuVHJhbnNwb3J0PV9kZXJlcV8oXCIuL3RyYW5zcG9ydFwiKTtTb2NrZXQudHJhbnNwb3J0cz1fZGVyZXFfKFwiLi90cmFuc3BvcnRzXCIpO1NvY2tldC5wYXJzZXI9X2RlcmVxXyhcImVuZ2luZS5pby1wYXJzZXJcIik7U29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQ9ZnVuY3Rpb24obmFtZSl7ZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLG5hbWUpO3ZhciBxdWVyeT1jbG9uZSh0aGlzLnF1ZXJ5KTtxdWVyeS5FSU89cGFyc2VyLnByb3RvY29sO3F1ZXJ5LnRyYW5zcG9ydD1uYW1lO2lmKHRoaXMuaWQpcXVlcnkuc2lkPXRoaXMuaWQ7dmFyIHRyYW5zcG9ydD1uZXcgdHJhbnNwb3J0c1tuYW1lXSh7YWdlbnQ6dGhpcy5hZ2VudCxob3N0bmFtZTp0aGlzLmhvc3RuYW1lLHBvcnQ6dGhpcy5wb3J0LHNlY3VyZTp0aGlzLnNlY3VyZSxwYXRoOnRoaXMucGF0aCxxdWVyeTpxdWVyeSxmb3JjZUpTT05QOnRoaXMuZm9yY2VKU09OUCxqc29ucDp0aGlzLmpzb25wLGZvcmNlQmFzZTY0OnRoaXMuZm9yY2VCYXNlNjQsZW5hYmxlc1hEUjp0aGlzLmVuYWJsZXNYRFIsdGltZXN0YW1wUmVxdWVzdHM6dGhpcy50aW1lc3RhbXBSZXF1ZXN0cyx0aW1lc3RhbXBQYXJhbTp0aGlzLnRpbWVzdGFtcFBhcmFtLHBvbGljeVBvcnQ6dGhpcy5wb2xpY3lQb3J0LHNvY2tldDp0aGlzLHBmeDp0aGlzLnBmeCxrZXk6dGhpcy5rZXkscGFzc3BocmFzZTp0aGlzLnBhc3NwaHJhc2UsY2VydDp0aGlzLmNlcnQsY2E6dGhpcy5jYSxjaXBoZXJzOnRoaXMuY2lwaGVycyxyZWplY3RVbmF1dGhvcml6ZWQ6dGhpcy5yZWplY3RVbmF1dGhvcml6ZWR9KTtyZXR1cm4gdHJhbnNwb3J0fTtmdW5jdGlvbiBjbG9uZShvYmope3ZhciBvPXt9O2Zvcih2YXIgaSBpbiBvYmope2lmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSl7b1tpXT1vYmpbaV19fXJldHVybiBvfVNvY2tldC5wcm90b3R5cGUub3Blbj1mdW5jdGlvbigpe3ZhciB0cmFuc3BvcnQ7aWYodGhpcy5yZW1lbWJlclVwZ3JhZGUmJlNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MmJnRoaXMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpIT0tMSl7dHJhbnNwb3J0PVwid2Vic29ja2V0XCJ9ZWxzZSBpZigwPT10aGlzLnRyYW5zcG9ydHMubGVuZ3RoKXt2YXIgc2VsZj10aGlzO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZWxmLmVtaXQoXCJlcnJvclwiLFwiTm8gdHJhbnNwb3J0cyBhdmFpbGFibGVcIil9LDApO3JldHVybn1lbHNle3RyYW5zcG9ydD10aGlzLnRyYW5zcG9ydHNbMF19dGhpcy5yZWFkeVN0YXRlPVwib3BlbmluZ1wiO3ZhciB0cmFuc3BvcnQ7dHJ5e3RyYW5zcG9ydD10aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpfWNhdGNoKGUpe3RoaXMudHJhbnNwb3J0cy5zaGlmdCgpO3RoaXMub3BlbigpO3JldHVybn10cmFuc3BvcnQub3BlbigpO3RoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCl9O1NvY2tldC5wcm90b3R5cGUuc2V0VHJhbnNwb3J0PWZ1bmN0aW9uKHRyYW5zcG9ydCl7ZGVidWcoXCJzZXR0aW5nIHRyYW5zcG9ydCAlc1wiLHRyYW5zcG9ydC5uYW1lKTt2YXIgc2VsZj10aGlzO2lmKHRoaXMudHJhbnNwb3J0KXtkZWJ1ZyhcImNsZWFyaW5nIGV4aXN0aW5nIHRyYW5zcG9ydCAlc1wiLHRoaXMudHJhbnNwb3J0Lm5hbWUpO3RoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpfXRoaXMudHJhbnNwb3J0PXRyYW5zcG9ydDt0cmFuc3BvcnQub24oXCJkcmFpblwiLGZ1bmN0aW9uKCl7c2VsZi5vbkRyYWluKCl9KS5vbihcInBhY2tldFwiLGZ1bmN0aW9uKHBhY2tldCl7c2VsZi5vblBhY2tldChwYWNrZXQpfSkub24oXCJlcnJvclwiLGZ1bmN0aW9uKGUpe3NlbGYub25FcnJvcihlKX0pLm9uKFwiY2xvc2VcIixmdW5jdGlvbigpe3NlbGYub25DbG9zZShcInRyYW5zcG9ydCBjbG9zZVwiKX0pfTtTb2NrZXQucHJvdG90eXBlLnByb2JlPWZ1bmN0aW9uKG5hbWUpe2RlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLG5hbWUpO3ZhciB0cmFuc3BvcnQ9dGhpcy5jcmVhdGVUcmFuc3BvcnQobmFtZSx7cHJvYmU6MX0pLGZhaWxlZD1mYWxzZSxzZWxmPXRoaXM7U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2Vzcz1mYWxzZTtmdW5jdGlvbiBvblRyYW5zcG9ydE9wZW4oKXtpZihzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcyl7dmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeT0hdGhpcy5zdXBwb3J0c0JpbmFyeSYmc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7ZmFpbGVkPWZhaWxlZHx8dXBncmFkZUxvc2VzQmluYXJ5fWlmKGZhaWxlZClyZXR1cm47ZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJyxuYW1lKTt0cmFuc3BvcnQuc2VuZChbe3R5cGU6XCJwaW5nXCIsZGF0YTpcInByb2JlXCJ9XSk7dHJhbnNwb3J0Lm9uY2UoXCJwYWNrZXRcIixmdW5jdGlvbihtc2cpe2lmKGZhaWxlZClyZXR1cm47aWYoXCJwb25nXCI9PW1zZy50eXBlJiZcInByb2JlXCI9PW1zZy5kYXRhKXtkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBwb25nJyxuYW1lKTtzZWxmLnVwZ3JhZGluZz10cnVlO3NlbGYuZW1pdChcInVwZ3JhZGluZ1wiLHRyYW5zcG9ydCk7aWYoIXRyYW5zcG9ydClyZXR1cm47U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2Vzcz1cIndlYnNvY2tldFwiPT10cmFuc3BvcnQubmFtZTtkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLHNlbGYudHJhbnNwb3J0Lm5hbWUpO3NlbGYudHJhbnNwb3J0LnBhdXNlKGZ1bmN0aW9uKCl7aWYoZmFpbGVkKXJldHVybjtpZihcImNsb3NlZFwiPT1zZWxmLnJlYWR5U3RhdGUpcmV0dXJuO2RlYnVnKFwiY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0XCIpO2NsZWFudXAoKTtzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO3RyYW5zcG9ydC5zZW5kKFt7dHlwZTpcInVwZ3JhZGVcIn1dKTtzZWxmLmVtaXQoXCJ1cGdyYWRlXCIsdHJhbnNwb3J0KTt0cmFuc3BvcnQ9bnVsbDtzZWxmLnVwZ3JhZGluZz1mYWxzZTtzZWxmLmZsdXNoKCl9KX1lbHNle2RlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsbmFtZSk7dmFyIGVycj1uZXcgRXJyb3IoXCJwcm9iZSBlcnJvclwiKTtlcnIudHJhbnNwb3J0PXRyYW5zcG9ydC5uYW1lO3NlbGYuZW1pdChcInVwZ3JhZGVFcnJvclwiLGVycil9fSl9ZnVuY3Rpb24gZnJlZXplVHJhbnNwb3J0KCl7aWYoZmFpbGVkKXJldHVybjtmYWlsZWQ9dHJ1ZTtjbGVhbnVwKCk7dHJhbnNwb3J0LmNsb3NlKCk7dHJhbnNwb3J0PW51bGx9ZnVuY3Rpb24gb25lcnJvcihlcnIpe3ZhciBlcnJvcj1uZXcgRXJyb3IoXCJwcm9iZSBlcnJvcjogXCIrZXJyKTtlcnJvci50cmFuc3BvcnQ9dHJhbnNwb3J0Lm5hbWU7ZnJlZXplVHJhbnNwb3J0KCk7ZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJyxuYW1lLGVycik7c2VsZi5lbWl0KFwidXBncmFkZUVycm9yXCIsZXJyb3IpfWZ1bmN0aW9uIG9uVHJhbnNwb3J0Q2xvc2UoKXtvbmVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKX1mdW5jdGlvbiBvbmNsb3NlKCl7b25lcnJvcihcInNvY2tldCBjbG9zZWRcIil9ZnVuY3Rpb24gb251cGdyYWRlKHRvKXtpZih0cmFuc3BvcnQmJnRvLm5hbWUhPXRyYW5zcG9ydC5uYW1lKXtkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJyx0by5uYW1lLHRyYW5zcG9ydC5uYW1lKTtmcmVlemVUcmFuc3BvcnQoKX19ZnVuY3Rpb24gY2xlYW51cCgpe3RyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcIm9wZW5cIixvblRyYW5zcG9ydE9wZW4pO3RyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsb25lcnJvcik7dHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixvblRyYW5zcG9ydENsb3NlKTtzZWxmLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixvbmNsb3NlKTtzZWxmLnJlbW92ZUxpc3RlbmVyKFwidXBncmFkaW5nXCIsb251cGdyYWRlKX10cmFuc3BvcnQub25jZShcIm9wZW5cIixvblRyYW5zcG9ydE9wZW4pO3RyYW5zcG9ydC5vbmNlKFwiZXJyb3JcIixvbmVycm9yKTt0cmFuc3BvcnQub25jZShcImNsb3NlXCIsb25UcmFuc3BvcnRDbG9zZSk7dGhpcy5vbmNlKFwiY2xvc2VcIixvbmNsb3NlKTt0aGlzLm9uY2UoXCJ1cGdyYWRpbmdcIixvbnVwZ3JhZGUpO3RyYW5zcG9ydC5vcGVuKCl9O1NvY2tldC5wcm90b3R5cGUub25PcGVuPWZ1bmN0aW9uKCl7ZGVidWcoXCJzb2NrZXQgb3BlblwiKTt0aGlzLnJlYWR5U3RhdGU9XCJvcGVuXCI7U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2Vzcz1cIndlYnNvY2tldFwiPT10aGlzLnRyYW5zcG9ydC5uYW1lO3RoaXMuZW1pdChcIm9wZW5cIik7dGhpcy5mbHVzaCgpO2lmKFwib3BlblwiPT10aGlzLnJlYWR5U3RhdGUmJnRoaXMudXBncmFkZSYmdGhpcy50cmFuc3BvcnQucGF1c2Upe2RlYnVnKFwic3RhcnRpbmcgdXBncmFkZSBwcm9iZXNcIik7Zm9yKHZhciBpPTAsbD10aGlzLnVwZ3JhZGVzLmxlbmd0aDtpPGw7aSsrKXt0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pfX19O1NvY2tldC5wcm90b3R5cGUub25QYWNrZXQ9ZnVuY3Rpb24ocGFja2V0KXtpZihcIm9wZW5pbmdcIj09dGhpcy5yZWFkeVN0YXRlfHxcIm9wZW5cIj09dGhpcy5yZWFkeVN0YXRlKXtkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicscGFja2V0LnR5cGUscGFja2V0LmRhdGEpO3RoaXMuZW1pdChcInBhY2tldFwiLHBhY2tldCk7dGhpcy5lbWl0KFwiaGVhcnRiZWF0XCIpO3N3aXRjaChwYWNrZXQudHlwZSl7Y2FzZVwib3BlblwiOnRoaXMub25IYW5kc2hha2UocGFyc2Vqc29uKHBhY2tldC5kYXRhKSk7YnJlYWs7Y2FzZVwicG9uZ1wiOnRoaXMuc2V0UGluZygpO2JyZWFrO2Nhc2VcImVycm9yXCI6dmFyIGVycj1uZXcgRXJyb3IoXCJzZXJ2ZXIgZXJyb3JcIik7ZXJyLmNvZGU9cGFja2V0LmRhdGE7dGhpcy5lbWl0KFwiZXJyb3JcIixlcnIpO2JyZWFrO2Nhc2VcIm1lc3NhZ2VcIjp0aGlzLmVtaXQoXCJkYXRhXCIscGFja2V0LmRhdGEpO3RoaXMuZW1pdChcIm1lc3NhZ2VcIixwYWNrZXQuZGF0YSk7YnJlYWt9fWVsc2V7ZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsdGhpcy5yZWFkeVN0YXRlKX19O1NvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2U9ZnVuY3Rpb24oZGF0YSl7dGhpcy5lbWl0KFwiaGFuZHNoYWtlXCIsZGF0YSk7dGhpcy5pZD1kYXRhLnNpZDt0aGlzLnRyYW5zcG9ydC5xdWVyeS5zaWQ9ZGF0YS5zaWQ7dGhpcy51cGdyYWRlcz10aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO3RoaXMucGluZ0ludGVydmFsPWRhdGEucGluZ0ludGVydmFsO3RoaXMucGluZ1RpbWVvdXQ9ZGF0YS5waW5nVGltZW91dDt0aGlzLm9uT3BlbigpO2lmKFwiY2xvc2VkXCI9PXRoaXMucmVhZHlTdGF0ZSlyZXR1cm47dGhpcy5zZXRQaW5nKCk7dGhpcy5yZW1vdmVMaXN0ZW5lcihcImhlYXJ0YmVhdFwiLHRoaXMub25IZWFydGJlYXQpO3RoaXMub24oXCJoZWFydGJlYXRcIix0aGlzLm9uSGVhcnRiZWF0KX07U29ja2V0LnByb3RvdHlwZS5vbkhlYXJ0YmVhdD1mdW5jdGlvbih0aW1lb3V0KXtjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTt2YXIgc2VsZj10aGlzO3NlbGYucGluZ1RpbWVvdXRUaW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoXCJjbG9zZWRcIj09c2VsZi5yZWFkeVN0YXRlKXJldHVybjtzZWxmLm9uQ2xvc2UoXCJwaW5nIHRpbWVvdXRcIil9LHRpbWVvdXR8fHNlbGYucGluZ0ludGVydmFsK3NlbGYucGluZ1RpbWVvdXQpfTtTb2NrZXQucHJvdG90eXBlLnNldFBpbmc9ZnVuY3Rpb24oKXt2YXIgc2VsZj10aGlzO2NsZWFyVGltZW91dChzZWxmLnBpbmdJbnRlcnZhbFRpbWVyKTtzZWxmLnBpbmdJbnRlcnZhbFRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtkZWJ1ZyhcIndyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtc1wiLHNlbGYucGluZ1RpbWVvdXQpO3NlbGYucGluZygpO3NlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCl9LHNlbGYucGluZ0ludGVydmFsKX07U29ja2V0LnByb3RvdHlwZS5waW5nPWZ1bmN0aW9uKCl7dGhpcy5zZW5kUGFja2V0KFwicGluZ1wiKX07U29ja2V0LnByb3RvdHlwZS5vbkRyYWluPWZ1bmN0aW9uKCl7Zm9yKHZhciBpPTA7aTx0aGlzLnByZXZCdWZmZXJMZW47aSsrKXtpZih0aGlzLmNhbGxiYWNrQnVmZmVyW2ldKXt0aGlzLmNhbGxiYWNrQnVmZmVyW2ldKCl9fXRoaXMud3JpdGVCdWZmZXIuc3BsaWNlKDAsdGhpcy5wcmV2QnVmZmVyTGVuKTt0aGlzLmNhbGxiYWNrQnVmZmVyLnNwbGljZSgwLHRoaXMucHJldkJ1ZmZlckxlbik7dGhpcy5wcmV2QnVmZmVyTGVuPTA7aWYodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg9PTApe3RoaXMuZW1pdChcImRyYWluXCIpfWVsc2V7dGhpcy5mbHVzaCgpfX07U29ja2V0LnByb3RvdHlwZS5mbHVzaD1mdW5jdGlvbigpe2lmKFwiY2xvc2VkXCIhPXRoaXMucmVhZHlTdGF0ZSYmdGhpcy50cmFuc3BvcnQud3JpdGFibGUmJiF0aGlzLnVwZ3JhZGluZyYmdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpe2RlYnVnKFwiZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXRcIix0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7dGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTt0aGlzLnByZXZCdWZmZXJMZW49dGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7dGhpcy5lbWl0KFwiZmx1c2hcIil9fTtTb2NrZXQucHJvdG90eXBlLndyaXRlPVNvY2tldC5wcm90b3R5cGUuc2VuZD1mdW5jdGlvbihtc2csZm4pe3RoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIixtc2csZm4pO3JldHVybiB0aGlzfTtTb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQ9ZnVuY3Rpb24odHlwZSxkYXRhLGZuKXtpZihcImNsb3NpbmdcIj09dGhpcy5yZWFkeVN0YXRlfHxcImNsb3NlZFwiPT10aGlzLnJlYWR5U3RhdGUpe3JldHVybn12YXIgcGFja2V0PXt0eXBlOnR5cGUsZGF0YTpkYXRhfTt0aGlzLmVtaXQoXCJwYWNrZXRDcmVhdGVcIixwYWNrZXQpO3RoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO3RoaXMuY2FsbGJhY2tCdWZmZXIucHVzaChmbik7dGhpcy5mbHVzaCgpfTtTb2NrZXQucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7aWYoXCJvcGVuaW5nXCI9PXRoaXMucmVhZHlTdGF0ZXx8XCJvcGVuXCI9PXRoaXMucmVhZHlTdGF0ZSl7dGhpcy5yZWFkeVN0YXRlPVwiY2xvc2luZ1wiO3ZhciBzZWxmPXRoaXM7ZnVuY3Rpb24gY2xvc2UoKXtzZWxmLm9uQ2xvc2UoXCJmb3JjZWQgY2xvc2VcIik7ZGVidWcoXCJzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlXCIpO3NlbGYudHJhbnNwb3J0LmNsb3NlKCl9ZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlKCl7c2VsZi5yZW1vdmVMaXN0ZW5lcihcInVwZ3JhZGVcIixjbGVhbnVwQW5kQ2xvc2UpO3NlbGYucmVtb3ZlTGlzdGVuZXIoXCJ1cGdyYWRlRXJyb3JcIixjbGVhbnVwQW5kQ2xvc2UpO2Nsb3NlKCl9ZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKXtzZWxmLm9uY2UoXCJ1cGdyYWRlXCIsY2xlYW51cEFuZENsb3NlKTtzZWxmLm9uY2UoXCJ1cGdyYWRlRXJyb3JcIixjbGVhbnVwQW5kQ2xvc2UpfWlmKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKXt0aGlzLm9uY2UoXCJkcmFpblwiLGZ1bmN0aW9uKCl7aWYodGhpcy51cGdyYWRpbmcpe3dhaXRGb3JVcGdyYWRlKCl9ZWxzZXtjbG9zZSgpfX0pfWVsc2UgaWYodGhpcy51cGdyYWRpbmcpe3dhaXRGb3JVcGdyYWRlKCl9ZWxzZXtjbG9zZSgpfX1yZXR1cm4gdGhpc307U29ja2V0LnByb3RvdHlwZS5vbkVycm9yPWZ1bmN0aW9uKGVycil7ZGVidWcoXCJzb2NrZXQgZXJyb3IgJWpcIixlcnIpO1NvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3M9ZmFsc2U7dGhpcy5lbWl0KFwiZXJyb3JcIixlcnIpO3RoaXMub25DbG9zZShcInRyYW5zcG9ydCBlcnJvclwiLGVycil9O1NvY2tldC5wcm90b3R5cGUub25DbG9zZT1mdW5jdGlvbihyZWFzb24sZGVzYyl7aWYoXCJvcGVuaW5nXCI9PXRoaXMucmVhZHlTdGF0ZXx8XCJvcGVuXCI9PXRoaXMucmVhZHlTdGF0ZXx8XCJjbG9zaW5nXCI9PXRoaXMucmVhZHlTdGF0ZSl7ZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJyxyZWFzb24pO3ZhciBzZWxmPXRoaXM7Y2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO2NsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZWxmLndyaXRlQnVmZmVyPVtdO3NlbGYuY2FsbGJhY2tCdWZmZXI9W107c2VsZi5wcmV2QnVmZmVyTGVuPTB9LDApO3RoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycyhcImNsb3NlXCIpO3RoaXMudHJhbnNwb3J0LmNsb3NlKCk7dGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7dGhpcy5yZWFkeVN0YXRlPVwiY2xvc2VkXCI7dGhpcy5pZD1udWxsO3RoaXMuZW1pdChcImNsb3NlXCIscmVhc29uLGRlc2MpfX07U29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcz1mdW5jdGlvbih1cGdyYWRlcyl7dmFyIGZpbHRlcmVkVXBncmFkZXM9W107Zm9yKHZhciBpPTAsaj11cGdyYWRlcy5sZW5ndGg7aTxqO2krKyl7aWYofmluZGV4KHRoaXMudHJhbnNwb3J0cyx1cGdyYWRlc1tpXSkpZmlsdGVyZWRVcGdyYWRlcy5wdXNoKHVwZ3JhZGVzW2ldKX1yZXR1cm4gZmlsdGVyZWRVcGdyYWRlc319KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se1wiLi90cmFuc3BvcnRcIjoxNCxcIi4vdHJhbnNwb3J0c1wiOjE1LFwiY29tcG9uZW50LWVtaXR0ZXJcIjo5LGRlYnVnOjIyLFwiZW5naW5lLmlvLXBhcnNlclwiOjI1LGluZGV4b2Y6NDIscGFyc2Vqc29uOjM0LHBhcnNlcXM6MzUscGFyc2V1cmk6MzZ9XSwxNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHBhcnNlcj1fZGVyZXFfKFwiZW5naW5lLmlvLXBhcnNlclwiKTt2YXIgRW1pdHRlcj1fZGVyZXFfKFwiY29tcG9uZW50LWVtaXR0ZXJcIik7bW9kdWxlLmV4cG9ydHM9VHJhbnNwb3J0O2Z1bmN0aW9uIFRyYW5zcG9ydChvcHRzKXt0aGlzLnBhdGg9b3B0cy5wYXRoO3RoaXMuaG9zdG5hbWU9b3B0cy5ob3N0bmFtZTt0aGlzLnBvcnQ9b3B0cy5wb3J0O3RoaXMuc2VjdXJlPW9wdHMuc2VjdXJlO3RoaXMucXVlcnk9b3B0cy5xdWVyeTt0aGlzLnRpbWVzdGFtcFBhcmFtPW9wdHMudGltZXN0YW1wUGFyYW07dGhpcy50aW1lc3RhbXBSZXF1ZXN0cz1vcHRzLnRpbWVzdGFtcFJlcXVlc3RzO3RoaXMucmVhZHlTdGF0ZT1cIlwiO3RoaXMuYWdlbnQ9b3B0cy5hZ2VudHx8ZmFsc2U7dGhpcy5zb2NrZXQ9b3B0cy5zb2NrZXQ7dGhpcy5lbmFibGVzWERSPW9wdHMuZW5hYmxlc1hEUjt0aGlzLnBmeD1vcHRzLnBmeDt0aGlzLmtleT1vcHRzLmtleTt0aGlzLnBhc3NwaHJhc2U9b3B0cy5wYXNzcGhyYXNlO3RoaXMuY2VydD1vcHRzLmNlcnQ7dGhpcy5jYT1vcHRzLmNhO3RoaXMuY2lwaGVycz1vcHRzLmNpcGhlcnM7dGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ9b3B0cy5yZWplY3RVbmF1dGhvcml6ZWR9RW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtUcmFuc3BvcnQudGltZXN0YW1wcz0wO1RyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvcj1mdW5jdGlvbihtc2csZGVzYyl7dmFyIGVycj1uZXcgRXJyb3IobXNnKTtlcnIudHlwZT1cIlRyYW5zcG9ydEVycm9yXCI7ZXJyLmRlc2NyaXB0aW9uPWRlc2M7dGhpcy5lbWl0KFwiZXJyb3JcIixlcnIpO3JldHVybiB0aGlzfTtUcmFuc3BvcnQucHJvdG90eXBlLm9wZW49ZnVuY3Rpb24oKXtpZihcImNsb3NlZFwiPT10aGlzLnJlYWR5U3RhdGV8fFwiXCI9PXRoaXMucmVhZHlTdGF0ZSl7dGhpcy5yZWFkeVN0YXRlPVwib3BlbmluZ1wiO3RoaXMuZG9PcGVuKCl9cmV0dXJuIHRoaXN9O1RyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXtpZihcIm9wZW5pbmdcIj09dGhpcy5yZWFkeVN0YXRlfHxcIm9wZW5cIj09dGhpcy5yZWFkeVN0YXRlKXt0aGlzLmRvQ2xvc2UoKTt0aGlzLm9uQ2xvc2UoKX1yZXR1cm4gdGhpc307VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKHBhY2tldHMpe2lmKFwib3BlblwiPT10aGlzLnJlYWR5U3RhdGUpe3RoaXMud3JpdGUocGFja2V0cyl9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgbm90IG9wZW5cIil9fTtUcmFuc3BvcnQucHJvdG90eXBlLm9uT3Blbj1mdW5jdGlvbigpe3RoaXMucmVhZHlTdGF0ZT1cIm9wZW5cIjt0aGlzLndyaXRhYmxlPXRydWU7dGhpcy5lbWl0KFwib3BlblwiKX07VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24oZGF0YSl7dmFyIHBhY2tldD1wYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7dGhpcy5vblBhY2tldChwYWNrZXQpfTtUcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0PWZ1bmN0aW9uKHBhY2tldCl7dGhpcy5lbWl0KFwicGFja2V0XCIscGFja2V0KX07VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5yZWFkeVN0YXRlPVwiY2xvc2VkXCI7dGhpcy5lbWl0KFwiY2xvc2VcIil9fSx7XCJjb21wb25lbnQtZW1pdHRlclwiOjksXCJlbmdpbmUuaW8tcGFyc2VyXCI6MjV9XSwxNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIFhNTEh0dHBSZXF1ZXN0PV9kZXJlcV8oXCJ4bWxodHRwcmVxdWVzdFwiKTt2YXIgWEhSPV9kZXJlcV8oXCIuL3BvbGxpbmcteGhyXCIpO3ZhciBKU09OUD1fZGVyZXFfKFwiLi9wb2xsaW5nLWpzb25wXCIpO3ZhciB3ZWJzb2NrZXQ9X2RlcmVxXyhcIi4vd2Vic29ja2V0XCIpO2V4cG9ydHMucG9sbGluZz1wb2xsaW5nO2V4cG9ydHMud2Vic29ja2V0PXdlYnNvY2tldDtmdW5jdGlvbiBwb2xsaW5nKG9wdHMpe3ZhciB4aHI7dmFyIHhkPWZhbHNlO3ZhciB4cz1mYWxzZTt2YXIganNvbnA9ZmFsc2UhPT1vcHRzLmpzb25wO2lmKGdsb2JhbC5sb2NhdGlvbil7dmFyIGlzU1NMPVwiaHR0cHM6XCI9PWxvY2F0aW9uLnByb3RvY29sO3ZhciBwb3J0PWxvY2F0aW9uLnBvcnQ7aWYoIXBvcnQpe3BvcnQ9aXNTU0w/NDQzOjgwfXhkPW9wdHMuaG9zdG5hbWUhPWxvY2F0aW9uLmhvc3RuYW1lfHxwb3J0IT1vcHRzLnBvcnQ7eHM9b3B0cy5zZWN1cmUhPWlzU1NMfW9wdHMueGRvbWFpbj14ZDtvcHRzLnhzY2hlbWU9eHM7eGhyPW5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtpZihcIm9wZW5cImluIHhociYmIW9wdHMuZm9yY2VKU09OUCl7cmV0dXJuIG5ldyBYSFIob3B0cyl9ZWxzZXtpZighanNvbnApdGhyb3cgbmV3IEVycm9yKFwiSlNPTlAgZGlzYWJsZWRcIik7cmV0dXJuIG5ldyBKU09OUChvcHRzKX19fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtcIi4vcG9sbGluZy1qc29ucFwiOjE2LFwiLi9wb2xsaW5nLXhoclwiOjE3LFwiLi93ZWJzb2NrZXRcIjoxOSx4bWxodHRwcmVxdWVzdDoyMH1dLDE2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgUG9sbGluZz1fZGVyZXFfKFwiLi9wb2xsaW5nXCIpO3ZhciBpbmhlcml0PV9kZXJlcV8oXCJjb21wb25lbnQtaW5oZXJpdFwiKTttb2R1bGUuZXhwb3J0cz1KU09OUFBvbGxpbmc7dmFyIHJOZXdsaW5lPS9cXG4vZzt2YXIgckVzY2FwZWROZXdsaW5lPS9cXFxcbi9nO3ZhciBjYWxsYmFja3M7dmFyIGluZGV4PTA7ZnVuY3Rpb24gZW1wdHkoKXt9ZnVuY3Rpb24gSlNPTlBQb2xsaW5nKG9wdHMpe1BvbGxpbmcuY2FsbCh0aGlzLG9wdHMpO1xudGhpcy5xdWVyeT10aGlzLnF1ZXJ5fHx7fTtpZighY2FsbGJhY2tzKXtpZighZ2xvYmFsLl9fX2VpbylnbG9iYWwuX19fZWlvPVtdO2NhbGxiYWNrcz1nbG9iYWwuX19fZWlvfXRoaXMuaW5kZXg9Y2FsbGJhY2tzLmxlbmd0aDt2YXIgc2VsZj10aGlzO2NhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uKG1zZyl7c2VsZi5vbkRhdGEobXNnKX0pO3RoaXMucXVlcnkuaj10aGlzLmluZGV4O2lmKGdsb2JhbC5kb2N1bWVudCYmZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpe2dsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsZnVuY3Rpb24oKXtpZihzZWxmLnNjcmlwdClzZWxmLnNjcmlwdC5vbmVycm9yPWVtcHR5fSxmYWxzZSl9fWluaGVyaXQoSlNPTlBQb2xsaW5nLFBvbGxpbmcpO0pTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnk9ZmFsc2U7SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlPWZ1bmN0aW9uKCl7aWYodGhpcy5zY3JpcHQpe3RoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO3RoaXMuc2NyaXB0PW51bGx9aWYodGhpcy5mb3JtKXt0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO3RoaXMuZm9ybT1udWxsO3RoaXMuaWZyYW1lPW51bGx9UG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpfTtKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbD1mdW5jdGlvbigpe3ZhciBzZWxmPXRoaXM7dmFyIHNjcmlwdD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2lmKHRoaXMuc2NyaXB0KXt0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTt0aGlzLnNjcmlwdD1udWxsfXNjcmlwdC5hc3luYz10cnVlO3NjcmlwdC5zcmM9dGhpcy51cmkoKTtzY3JpcHQub25lcnJvcj1mdW5jdGlvbihlKXtzZWxmLm9uRXJyb3IoXCJqc29ucCBwb2xsIGVycm9yXCIsZSl9O3ZhciBpbnNlcnRBdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKVswXTtpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsaW5zZXJ0QXQpO3RoaXMuc2NyaXB0PXNjcmlwdDt2YXIgaXNVQWdlY2tvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJi9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoaXNVQWdlY2tvKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7dmFyIGlmcmFtZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSl9LDEwMCl9fTtKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGU9ZnVuY3Rpb24oZGF0YSxmbil7dmFyIHNlbGY9dGhpcztpZighdGhpcy5mb3JtKXt2YXIgZm9ybT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTt2YXIgYXJlYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7dmFyIGlkPXRoaXMuaWZyYW1lSWQ9XCJlaW9faWZyYW1lX1wiK3RoaXMuaW5kZXg7dmFyIGlmcmFtZTtmb3JtLmNsYXNzTmFtZT1cInNvY2tldGlvXCI7Zm9ybS5zdHlsZS5wb3NpdGlvbj1cImFic29sdXRlXCI7Zm9ybS5zdHlsZS50b3A9XCItMTAwMHB4XCI7Zm9ybS5zdHlsZS5sZWZ0PVwiLTEwMDBweFwiO2Zvcm0udGFyZ2V0PWlkO2Zvcm0ubWV0aG9kPVwiUE9TVFwiO2Zvcm0uc2V0QXR0cmlidXRlKFwiYWNjZXB0LWNoYXJzZXRcIixcInV0Zi04XCIpO2FyZWEubmFtZT1cImRcIjtmb3JtLmFwcGVuZENoaWxkKGFyZWEpO2RvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7dGhpcy5mb3JtPWZvcm07dGhpcy5hcmVhPWFyZWF9dGhpcy5mb3JtLmFjdGlvbj10aGlzLnVyaSgpO2Z1bmN0aW9uIGNvbXBsZXRlKCl7aW5pdElmcmFtZSgpO2ZuKCl9ZnVuY3Rpb24gaW5pdElmcmFtZSgpe2lmKHNlbGYuaWZyYW1lKXt0cnl7c2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKX1jYXRjaChlKXtzZWxmLm9uRXJyb3IoXCJqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yXCIsZSl9fXRyeXt2YXIgaHRtbD0nPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJytzZWxmLmlmcmFtZUlkKydcIj4nO2lmcmFtZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpfWNhdGNoKGUpe2lmcmFtZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaWZyYW1lXCIpO2lmcmFtZS5uYW1lPXNlbGYuaWZyYW1lSWQ7aWZyYW1lLnNyYz1cImphdmFzY3JpcHQ6MFwifWlmcmFtZS5pZD1zZWxmLmlmcmFtZUlkO3NlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO3NlbGYuaWZyYW1lPWlmcmFtZX1pbml0SWZyYW1lKCk7ZGF0YT1kYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLFwiXFxcXFxcblwiKTt0aGlzLmFyZWEudmFsdWU9ZGF0YS5yZXBsYWNlKHJOZXdsaW5lLFwiXFxcXG5cIik7dHJ5e3RoaXMuZm9ybS5zdWJtaXQoKX1jYXRjaChlKXt9aWYodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpe3RoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2lmKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGU9PVwiY29tcGxldGVcIil7Y29tcGxldGUoKX19fWVsc2V7dGhpcy5pZnJhbWUub25sb2FkPWNvbXBsZXRlfX19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se1wiLi9wb2xsaW5nXCI6MTgsXCJjb21wb25lbnQtaW5oZXJpdFwiOjIxfV0sMTc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBYTUxIdHRwUmVxdWVzdD1fZGVyZXFfKFwieG1saHR0cHJlcXVlc3RcIik7dmFyIFBvbGxpbmc9X2RlcmVxXyhcIi4vcG9sbGluZ1wiKTt2YXIgRW1pdHRlcj1fZGVyZXFfKFwiY29tcG9uZW50LWVtaXR0ZXJcIik7dmFyIGluaGVyaXQ9X2RlcmVxXyhcImNvbXBvbmVudC1pbmhlcml0XCIpO3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyXCIpO21vZHVsZS5leHBvcnRzPVhIUjttb2R1bGUuZXhwb3J0cy5SZXF1ZXN0PVJlcXVlc3Q7ZnVuY3Rpb24gZW1wdHkoKXt9ZnVuY3Rpb24gWEhSKG9wdHMpe1BvbGxpbmcuY2FsbCh0aGlzLG9wdHMpO2lmKGdsb2JhbC5sb2NhdGlvbil7dmFyIGlzU1NMPVwiaHR0cHM6XCI9PWxvY2F0aW9uLnByb3RvY29sO3ZhciBwb3J0PWxvY2F0aW9uLnBvcnQ7aWYoIXBvcnQpe3BvcnQ9aXNTU0w/NDQzOjgwfXRoaXMueGQ9b3B0cy5ob3N0bmFtZSE9Z2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lfHxwb3J0IT1vcHRzLnBvcnQ7dGhpcy54cz1vcHRzLnNlY3VyZSE9aXNTU0x9fWluaGVyaXQoWEhSLFBvbGxpbmcpO1hIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnk9dHJ1ZTtYSFIucHJvdG90eXBlLnJlcXVlc3Q9ZnVuY3Rpb24ob3B0cyl7b3B0cz1vcHRzfHx7fTtvcHRzLnVyaT10aGlzLnVyaSgpO29wdHMueGQ9dGhpcy54ZDtvcHRzLnhzPXRoaXMueHM7b3B0cy5hZ2VudD10aGlzLmFnZW50fHxmYWxzZTtvcHRzLnN1cHBvcnRzQmluYXJ5PXRoaXMuc3VwcG9ydHNCaW5hcnk7b3B0cy5lbmFibGVzWERSPXRoaXMuZW5hYmxlc1hEUjtvcHRzLnBmeD10aGlzLnBmeDtvcHRzLmtleT10aGlzLmtleTtvcHRzLnBhc3NwaHJhc2U9dGhpcy5wYXNzcGhyYXNlO29wdHMuY2VydD10aGlzLmNlcnQ7b3B0cy5jYT10aGlzLmNhO29wdHMuY2lwaGVycz10aGlzLmNpcGhlcnM7b3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ9dGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7cmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpfTtYSFIucHJvdG90eXBlLmRvV3JpdGU9ZnVuY3Rpb24oZGF0YSxmbil7dmFyIGlzQmluYXJ5PXR5cGVvZiBkYXRhIT09XCJzdHJpbmdcIiYmZGF0YSE9PXVuZGVmaW5lZDt2YXIgcmVxPXRoaXMucmVxdWVzdCh7bWV0aG9kOlwiUE9TVFwiLGRhdGE6ZGF0YSxpc0JpbmFyeTppc0JpbmFyeX0pO3ZhciBzZWxmPXRoaXM7cmVxLm9uKFwic3VjY2Vzc1wiLGZuKTtyZXEub24oXCJlcnJvclwiLGZ1bmN0aW9uKGVycil7c2VsZi5vbkVycm9yKFwieGhyIHBvc3QgZXJyb3JcIixlcnIpfSk7dGhpcy5zZW5kWGhyPXJlcX07WEhSLnByb3RvdHlwZS5kb1BvbGw9ZnVuY3Rpb24oKXtkZWJ1ZyhcInhociBwb2xsXCIpO3ZhciByZXE9dGhpcy5yZXF1ZXN0KCk7dmFyIHNlbGY9dGhpcztyZXEub24oXCJkYXRhXCIsZnVuY3Rpb24oZGF0YSl7c2VsZi5vbkRhdGEoZGF0YSl9KTtyZXEub24oXCJlcnJvclwiLGZ1bmN0aW9uKGVycil7c2VsZi5vbkVycm9yKFwieGhyIHBvbGwgZXJyb3JcIixlcnIpfSk7dGhpcy5wb2xsWGhyPXJlcX07ZnVuY3Rpb24gUmVxdWVzdChvcHRzKXt0aGlzLm1ldGhvZD1vcHRzLm1ldGhvZHx8XCJHRVRcIjt0aGlzLnVyaT1vcHRzLnVyaTt0aGlzLnhkPSEhb3B0cy54ZDt0aGlzLnhzPSEhb3B0cy54czt0aGlzLmFzeW5jPWZhbHNlIT09b3B0cy5hc3luYzt0aGlzLmRhdGE9dW5kZWZpbmVkIT1vcHRzLmRhdGE/b3B0cy5kYXRhOm51bGw7dGhpcy5hZ2VudD1vcHRzLmFnZW50O3RoaXMuaXNCaW5hcnk9b3B0cy5pc0JpbmFyeTt0aGlzLnN1cHBvcnRzQmluYXJ5PW9wdHMuc3VwcG9ydHNCaW5hcnk7dGhpcy5lbmFibGVzWERSPW9wdHMuZW5hYmxlc1hEUjt0aGlzLnBmeD1vcHRzLnBmeDt0aGlzLmtleT1vcHRzLmtleTt0aGlzLnBhc3NwaHJhc2U9b3B0cy5wYXNzcGhyYXNlO3RoaXMuY2VydD1vcHRzLmNlcnQ7dGhpcy5jYT1vcHRzLmNhO3RoaXMuY2lwaGVycz1vcHRzLmNpcGhlcnM7dGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ9b3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7dGhpcy5jcmVhdGUoKX1FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtSZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGU9ZnVuY3Rpb24oKXt2YXIgb3B0cz17YWdlbnQ6dGhpcy5hZ2VudCx4ZG9tYWluOnRoaXMueGQseHNjaGVtZTp0aGlzLnhzLGVuYWJsZXNYRFI6dGhpcy5lbmFibGVzWERSfTtvcHRzLnBmeD10aGlzLnBmeDtvcHRzLmtleT10aGlzLmtleTtvcHRzLnBhc3NwaHJhc2U9dGhpcy5wYXNzcGhyYXNlO29wdHMuY2VydD10aGlzLmNlcnQ7b3B0cy5jYT10aGlzLmNhO29wdHMuY2lwaGVycz10aGlzLmNpcGhlcnM7b3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ9dGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7dmFyIHhocj10aGlzLnhocj1uZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7dmFyIHNlbGY9dGhpczt0cnl7ZGVidWcoXCJ4aHIgb3BlbiAlczogJXNcIix0aGlzLm1ldGhvZCx0aGlzLnVyaSk7eGhyLm9wZW4odGhpcy5tZXRob2QsdGhpcy51cmksdGhpcy5hc3luYyk7aWYodGhpcy5zdXBwb3J0c0JpbmFyeSl7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCJ9aWYoXCJQT1NUXCI9PXRoaXMubWV0aG9kKXt0cnl7aWYodGhpcy5pc0JpbmFyeSl7eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIixcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKX1lbHNle3hoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC10eXBlXCIsXCJ0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLThcIil9fWNhdGNoKGUpe319aWYoXCJ3aXRoQ3JlZGVudGlhbHNcImluIHhocil7eGhyLndpdGhDcmVkZW50aWFscz10cnVlfWlmKHRoaXMuaGFzWERSKCkpe3hoci5vbmxvYWQ9ZnVuY3Rpb24oKXtzZWxmLm9uTG9hZCgpfTt4aHIub25lcnJvcj1mdW5jdGlvbigpe3NlbGYub25FcnJvcih4aHIucmVzcG9uc2VUZXh0KX19ZWxzZXt4aHIub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoNCE9eGhyLnJlYWR5U3RhdGUpcmV0dXJuO2lmKDIwMD09eGhyLnN0YXR1c3x8MTIyMz09eGhyLnN0YXR1cyl7c2VsZi5vbkxvYWQoKX1lbHNle3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyl9LDApfX19ZGVidWcoXCJ4aHIgZGF0YSAlc1wiLHRoaXMuZGF0YSk7eGhyLnNlbmQodGhpcy5kYXRhKX1jYXRjaChlKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2VsZi5vbkVycm9yKGUpfSwwKTtyZXR1cm59aWYoZ2xvYmFsLmRvY3VtZW50KXt0aGlzLmluZGV4PVJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1JlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF09dGhpc319O1JlcXVlc3QucHJvdG90eXBlLm9uU3VjY2Vzcz1mdW5jdGlvbigpe3RoaXMuZW1pdChcInN1Y2Nlc3NcIik7dGhpcy5jbGVhbnVwKCl9O1JlcXVlc3QucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbihkYXRhKXt0aGlzLmVtaXQoXCJkYXRhXCIsZGF0YSk7dGhpcy5vblN1Y2Nlc3MoKX07UmVxdWVzdC5wcm90b3R5cGUub25FcnJvcj1mdW5jdGlvbihlcnIpe3RoaXMuZW1pdChcImVycm9yXCIsZXJyKTt0aGlzLmNsZWFudXAodHJ1ZSl9O1JlcXVlc3QucHJvdG90eXBlLmNsZWFudXA9ZnVuY3Rpb24oZnJvbUVycm9yKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgdGhpcy54aHJ8fG51bGw9PT10aGlzLnhocil7cmV0dXJufWlmKHRoaXMuaGFzWERSKCkpe3RoaXMueGhyLm9ubG9hZD10aGlzLnhoci5vbmVycm9yPWVtcHR5fWVsc2V7dGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlPWVtcHR5fWlmKGZyb21FcnJvcil7dHJ5e3RoaXMueGhyLmFib3J0KCl9Y2F0Y2goZSl7fX1pZihnbG9iYWwuZG9jdW1lbnQpe2RlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdfXRoaXMueGhyPW51bGx9O1JlcXVlc3QucHJvdG90eXBlLm9uTG9hZD1mdW5jdGlvbigpe3ZhciBkYXRhO3RyeXt2YXIgY29udGVudFR5cGU7dHJ5e2NvbnRlbnRUeXBlPXRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIpLnNwbGl0KFwiO1wiKVswXX1jYXRjaChlKXt9aWYoY29udGVudFR5cGU9PT1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKXtkYXRhPXRoaXMueGhyLnJlc3BvbnNlfWVsc2V7aWYoIXRoaXMuc3VwcG9ydHNCaW5hcnkpe2RhdGE9dGhpcy54aHIucmVzcG9uc2VUZXh0fWVsc2V7ZGF0YT1cIm9rXCJ9fX1jYXRjaChlKXt0aGlzLm9uRXJyb3IoZSl9aWYobnVsbCE9ZGF0YSl7dGhpcy5vbkRhdGEoZGF0YSl9fTtSZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFI9ZnVuY3Rpb24oKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCYmIXRoaXMueHMmJnRoaXMuZW5hYmxlc1hEUn07UmVxdWVzdC5wcm90b3R5cGUuYWJvcnQ9ZnVuY3Rpb24oKXt0aGlzLmNsZWFudXAoKX07aWYoZ2xvYmFsLmRvY3VtZW50KXtSZXF1ZXN0LnJlcXVlc3RzQ291bnQ9MDtSZXF1ZXN0LnJlcXVlc3RzPXt9O2lmKGdsb2JhbC5hdHRhY2hFdmVudCl7Z2xvYmFsLmF0dGFjaEV2ZW50KFwib251bmxvYWRcIix1bmxvYWRIYW5kbGVyKX1lbHNlIGlmKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKXtnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLHVubG9hZEhhbmRsZXIsZmFsc2UpfX1mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCl7Zm9yKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpe2lmKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpe1JlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKX19fX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7XCIuL3BvbGxpbmdcIjoxOCxcImNvbXBvbmVudC1lbWl0dGVyXCI6OSxcImNvbXBvbmVudC1pbmhlcml0XCI6MjEsZGVidWc6MjIseG1saHR0cHJlcXVlc3Q6MjB9XSwxODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIFRyYW5zcG9ydD1fZGVyZXFfKFwiLi4vdHJhbnNwb3J0XCIpO3ZhciBwYXJzZXFzPV9kZXJlcV8oXCJwYXJzZXFzXCIpO3ZhciBwYXJzZXI9X2RlcmVxXyhcImVuZ2luZS5pby1wYXJzZXJcIik7dmFyIGluaGVyaXQ9X2RlcmVxXyhcImNvbXBvbmVudC1pbmhlcml0XCIpO3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmdcIik7bW9kdWxlLmV4cG9ydHM9UG9sbGluZzt2YXIgaGFzWEhSMj1mdW5jdGlvbigpe3ZhciBYTUxIdHRwUmVxdWVzdD1fZGVyZXFfKFwieG1saHR0cHJlcXVlc3RcIik7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Qoe3hkb21haW46ZmFsc2V9KTtyZXR1cm4gbnVsbCE9eGhyLnJlc3BvbnNlVHlwZX0oKTtmdW5jdGlvbiBQb2xsaW5nKG9wdHMpe3ZhciBmb3JjZUJhc2U2ND1vcHRzJiZvcHRzLmZvcmNlQmFzZTY0O2lmKCFoYXNYSFIyfHxmb3JjZUJhc2U2NCl7dGhpcy5zdXBwb3J0c0JpbmFyeT1mYWxzZX1UcmFuc3BvcnQuY2FsbCh0aGlzLG9wdHMpfWluaGVyaXQoUG9sbGluZyxUcmFuc3BvcnQpO1BvbGxpbmcucHJvdG90eXBlLm5hbWU9XCJwb2xsaW5nXCI7UG9sbGluZy5wcm90b3R5cGUuZG9PcGVuPWZ1bmN0aW9uKCl7dGhpcy5wb2xsKCl9O1BvbGxpbmcucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKG9uUGF1c2Upe3ZhciBwZW5kaW5nPTA7dmFyIHNlbGY9dGhpczt0aGlzLnJlYWR5U3RhdGU9XCJwYXVzaW5nXCI7ZnVuY3Rpb24gcGF1c2UoKXtkZWJ1ZyhcInBhdXNlZFwiKTtzZWxmLnJlYWR5U3RhdGU9XCJwYXVzZWRcIjtvblBhdXNlKCl9aWYodGhpcy5wb2xsaW5nfHwhdGhpcy53cml0YWJsZSl7dmFyIHRvdGFsPTA7aWYodGhpcy5wb2xsaW5nKXtkZWJ1ZyhcIndlIGFyZSBjdXJyZW50bHkgcG9sbGluZyAtIHdhaXRpbmcgdG8gcGF1c2VcIik7dG90YWwrKzt0aGlzLm9uY2UoXCJwb2xsQ29tcGxldGVcIixmdW5jdGlvbigpe2RlYnVnKFwicHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGVcIik7LS10b3RhbHx8cGF1c2UoKX0pfWlmKCF0aGlzLndyaXRhYmxlKXtkZWJ1ZyhcIndlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2VcIik7dG90YWwrKzt0aGlzLm9uY2UoXCJkcmFpblwiLGZ1bmN0aW9uKCl7ZGVidWcoXCJwcmUtcGF1c2Ugd3JpdGluZyBjb21wbGV0ZVwiKTstLXRvdGFsfHxwYXVzZSgpfSl9fWVsc2V7cGF1c2UoKX19O1BvbGxpbmcucHJvdG90eXBlLnBvbGw9ZnVuY3Rpb24oKXtkZWJ1ZyhcInBvbGxpbmdcIik7dGhpcy5wb2xsaW5nPXRydWU7dGhpcy5kb1BvbGwoKTt0aGlzLmVtaXQoXCJwb2xsXCIpfTtQb2xsaW5nLnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24oZGF0YSl7dmFyIHNlbGY9dGhpcztkZWJ1ZyhcInBvbGxpbmcgZ290IGRhdGEgJXNcIixkYXRhKTt2YXIgY2FsbGJhY2s9ZnVuY3Rpb24ocGFja2V0LGluZGV4LHRvdGFsKXtpZihcIm9wZW5pbmdcIj09c2VsZi5yZWFkeVN0YXRlKXtzZWxmLm9uT3BlbigpfWlmKFwiY2xvc2VcIj09cGFja2V0LnR5cGUpe3NlbGYub25DbG9zZSgpO3JldHVybiBmYWxzZX1zZWxmLm9uUGFja2V0KHBhY2tldCl9O3BhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSxjYWxsYmFjayk7aWYoXCJjbG9zZWRcIiE9dGhpcy5yZWFkeVN0YXRlKXt0aGlzLnBvbGxpbmc9ZmFsc2U7dGhpcy5lbWl0KFwicG9sbENvbXBsZXRlXCIpO2lmKFwib3BlblwiPT10aGlzLnJlYWR5U3RhdGUpe3RoaXMucG9sbCgpfWVsc2V7ZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJyx0aGlzLnJlYWR5U3RhdGUpfX19O1BvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2U9ZnVuY3Rpb24oKXt2YXIgc2VsZj10aGlzO2Z1bmN0aW9uIGNsb3NlKCl7ZGVidWcoXCJ3cml0aW5nIGNsb3NlIHBhY2tldFwiKTtzZWxmLndyaXRlKFt7dHlwZTpcImNsb3NlXCJ9XSl9aWYoXCJvcGVuXCI9PXRoaXMucmVhZHlTdGF0ZSl7ZGVidWcoXCJ0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmdcIik7Y2xvc2UoKX1lbHNle2RlYnVnKFwidHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlXCIpO3RoaXMub25jZShcIm9wZW5cIixjbG9zZSl9fTtQb2xsaW5nLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihwYWNrZXRzKXt2YXIgc2VsZj10aGlzO3RoaXMud3JpdGFibGU9ZmFsc2U7dmFyIGNhbGxiYWNrZm49ZnVuY3Rpb24oKXtzZWxmLndyaXRhYmxlPXRydWU7c2VsZi5lbWl0KFwiZHJhaW5cIil9O3ZhciBzZWxmPXRoaXM7cGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cyx0aGlzLnN1cHBvcnRzQmluYXJ5LGZ1bmN0aW9uKGRhdGEpe3NlbGYuZG9Xcml0ZShkYXRhLGNhbGxiYWNrZm4pfSl9O1BvbGxpbmcucHJvdG90eXBlLnVyaT1mdW5jdGlvbigpe3ZhciBxdWVyeT10aGlzLnF1ZXJ5fHx7fTt2YXIgc2NoZW1hPXRoaXMuc2VjdXJlP1wiaHR0cHNcIjpcImh0dHBcIjt2YXIgcG9ydD1cIlwiO2lmKGZhbHNlIT09dGhpcy50aW1lc3RhbXBSZXF1ZXN0cyl7cXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV09K25ldyBEYXRlK1wiLVwiK1RyYW5zcG9ydC50aW1lc3RhbXBzKyt9aWYoIXRoaXMuc3VwcG9ydHNCaW5hcnkmJiFxdWVyeS5zaWQpe3F1ZXJ5LmI2ND0xfXF1ZXJ5PXBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtpZih0aGlzLnBvcnQmJihcImh0dHBzXCI9PXNjaGVtYSYmdGhpcy5wb3J0IT00NDN8fFwiaHR0cFwiPT1zY2hlbWEmJnRoaXMucG9ydCE9ODApKXtwb3J0PVwiOlwiK3RoaXMucG9ydH1pZihxdWVyeS5sZW5ndGgpe3F1ZXJ5PVwiP1wiK3F1ZXJ5fXJldHVybiBzY2hlbWErXCI6Ly9cIit0aGlzLmhvc3RuYW1lK3BvcnQrdGhpcy5wYXRoK3F1ZXJ5fX0se1wiLi4vdHJhbnNwb3J0XCI6MTQsXCJjb21wb25lbnQtaW5oZXJpdFwiOjIxLGRlYnVnOjIyLFwiZW5naW5lLmlvLXBhcnNlclwiOjI1LHBhcnNlcXM6MzUseG1saHR0cHJlcXVlc3Q6MjB9XSwxOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIFRyYW5zcG9ydD1fZGVyZXFfKFwiLi4vdHJhbnNwb3J0XCIpO3ZhciBwYXJzZXI9X2RlcmVxXyhcImVuZ2luZS5pby1wYXJzZXJcIik7dmFyIHBhcnNlcXM9X2RlcmVxXyhcInBhcnNlcXNcIik7dmFyIGluaGVyaXQ9X2RlcmVxXyhcImNvbXBvbmVudC1pbmhlcml0XCIpO3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldFwiKTt2YXIgV2ViU29ja2V0PV9kZXJlcV8oXCJ3c1wiKTttb2R1bGUuZXhwb3J0cz1XUztmdW5jdGlvbiBXUyhvcHRzKXt2YXIgZm9yY2VCYXNlNjQ9b3B0cyYmb3B0cy5mb3JjZUJhc2U2NDtpZihmb3JjZUJhc2U2NCl7dGhpcy5zdXBwb3J0c0JpbmFyeT1mYWxzZX1UcmFuc3BvcnQuY2FsbCh0aGlzLG9wdHMpfWluaGVyaXQoV1MsVHJhbnNwb3J0KTtXUy5wcm90b3R5cGUubmFtZT1cIndlYnNvY2tldFwiO1dTLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeT10cnVlO1dTLnByb3RvdHlwZS5kb09wZW49ZnVuY3Rpb24oKXtpZighdGhpcy5jaGVjaygpKXtyZXR1cm59dmFyIHNlbGY9dGhpczt2YXIgdXJpPXRoaXMudXJpKCk7dmFyIHByb3RvY29scz12b2lkIDA7dmFyIG9wdHM9e2FnZW50OnRoaXMuYWdlbnR9O29wdHMucGZ4PXRoaXMucGZ4O29wdHMua2V5PXRoaXMua2V5O29wdHMucGFzc3BocmFzZT10aGlzLnBhc3NwaHJhc2U7b3B0cy5jZXJ0PXRoaXMuY2VydDtvcHRzLmNhPXRoaXMuY2E7b3B0cy5jaXBoZXJzPXRoaXMuY2lwaGVycztvcHRzLnJlamVjdFVuYXV0aG9yaXplZD10aGlzLnJlamVjdFVuYXV0aG9yaXplZDt0aGlzLndzPW5ldyBXZWJTb2NrZXQodXJpLHByb3RvY29scyxvcHRzKTtpZih0aGlzLndzLmJpbmFyeVR5cGU9PT11bmRlZmluZWQpe3RoaXMuc3VwcG9ydHNCaW5hcnk9ZmFsc2V9dGhpcy53cy5iaW5hcnlUeXBlPVwiYXJyYXlidWZmZXJcIjt0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCl9O1dTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycz1mdW5jdGlvbigpe3ZhciBzZWxmPXRoaXM7dGhpcy53cy5vbm9wZW49ZnVuY3Rpb24oKXtzZWxmLm9uT3BlbigpfTt0aGlzLndzLm9uY2xvc2U9ZnVuY3Rpb24oKXtzZWxmLm9uQ2xvc2UoKX07dGhpcy53cy5vbm1lc3NhZ2U9ZnVuY3Rpb24oZXYpe3NlbGYub25EYXRhKGV2LmRhdGEpfTt0aGlzLndzLm9uZXJyb3I9ZnVuY3Rpb24oZSl7c2VsZi5vbkVycm9yKFwid2Vic29ja2V0IGVycm9yXCIsZSl9fTtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiYvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpe1dTLnByb3RvdHlwZS5vbkRhdGE9ZnVuY3Rpb24oZGF0YSl7dmFyIHNlbGY9dGhpcztzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7VHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLGRhdGEpfSwwKX19V1MucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHBhY2tldHMpe3ZhciBzZWxmPXRoaXM7dGhpcy53cml0YWJsZT1mYWxzZTtmb3IodmFyIGk9MCxsPXBhY2tldHMubGVuZ3RoO2k8bDtpKyspe3BhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0c1tpXSx0aGlzLnN1cHBvcnRzQmluYXJ5LGZ1bmN0aW9uKGRhdGEpe3RyeXtzZWxmLndzLnNlbmQoZGF0YSl9Y2F0Y2goZSl7ZGVidWcoXCJ3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50XCIpfX0pfWZ1bmN0aW9uIG9uZHJhaW4oKXtzZWxmLndyaXRhYmxlPXRydWU7c2VsZi5lbWl0KFwiZHJhaW5cIil9c2V0VGltZW91dChvbmRyYWluLDApfTtXUy5wcm90b3R5cGUub25DbG9zZT1mdW5jdGlvbigpe1RyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpfTtXUy5wcm90b3R5cGUuZG9DbG9zZT1mdW5jdGlvbigpe2lmKHR5cGVvZiB0aGlzLndzIT09XCJ1bmRlZmluZWRcIil7dGhpcy53cy5jbG9zZSgpfX07V1MucHJvdG90eXBlLnVyaT1mdW5jdGlvbigpe3ZhciBxdWVyeT10aGlzLnF1ZXJ5fHx7fTt2YXIgc2NoZW1hPXRoaXMuc2VjdXJlP1wid3NzXCI6XCJ3c1wiO3ZhciBwb3J0PVwiXCI7aWYodGhpcy5wb3J0JiYoXCJ3c3NcIj09c2NoZW1hJiZ0aGlzLnBvcnQhPTQ0M3x8XCJ3c1wiPT1zY2hlbWEmJnRoaXMucG9ydCE9ODApKXtwb3J0PVwiOlwiK3RoaXMucG9ydH1pZih0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKXtxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXT0rbmV3IERhdGV9aWYoIXRoaXMuc3VwcG9ydHNCaW5hcnkpe3F1ZXJ5LmI2ND0xfXF1ZXJ5PXBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtpZihxdWVyeS5sZW5ndGgpe3F1ZXJ5PVwiP1wiK3F1ZXJ5fXJldHVybiBzY2hlbWErXCI6Ly9cIit0aGlzLmhvc3RuYW1lK3BvcnQrdGhpcy5wYXRoK3F1ZXJ5fTtXUy5wcm90b3R5cGUuY2hlY2s9ZnVuY3Rpb24oKXtyZXR1cm4hIVdlYlNvY2tldCYmIShcIl9faW5pdGlhbGl6ZVwiaW4gV2ViU29ja2V0JiZ0aGlzLm5hbWU9PT1XUy5wcm90b3R5cGUubmFtZSl9fSx7XCIuLi90cmFuc3BvcnRcIjoxNCxcImNvbXBvbmVudC1pbmhlcml0XCI6MjEsZGVidWc6MjIsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MjUscGFyc2VxczozNSx3czozN31dLDIwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgaGFzQ09SUz1fZGVyZXFfKFwiaGFzLWNvcnNcIik7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24ob3B0cyl7dmFyIHhkb21haW49b3B0cy54ZG9tYWluO3ZhciB4c2NoZW1lPW9wdHMueHNjaGVtZTt2YXIgZW5hYmxlc1hEUj1vcHRzLmVuYWJsZXNYRFI7dHJ5e2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBYTUxIdHRwUmVxdWVzdCYmKCF4ZG9tYWlufHxoYXNDT1JTKSl7cmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdH19Y2F0Y2goZSl7fXRyeXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgWERvbWFpblJlcXVlc3QmJiF4c2NoZW1lJiZlbmFibGVzWERSKXtyZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0fX1jYXRjaChlKXt9aWYoIXhkb21haW4pe3RyeXtyZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoXCJNaWNyb3NvZnQuWE1MSFRUUFwiKX1jYXRjaChlKXt9fX19LHtcImhhcy1jb3JzXCI6NDB9XSwyMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYSxiKXt2YXIgZm49ZnVuY3Rpb24oKXt9O2ZuLnByb3RvdHlwZT1iLnByb3RvdHlwZTthLnByb3RvdHlwZT1uZXcgZm47YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YX19LHt9XSwyMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7ZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1fZGVyZXFfKFwiLi9kZWJ1Z1wiKTtleHBvcnRzLmxvZz1sb2c7ZXhwb3J0cy5mb3JtYXRBcmdzPWZvcm1hdEFyZ3M7ZXhwb3J0cy5zYXZlPXNhdmU7ZXhwb3J0cy5sb2FkPWxvYWQ7ZXhwb3J0cy51c2VDb2xvcnM9dXNlQ29sb3JzO2V4cG9ydHMuY29sb3JzPVtcImxpZ2h0c2VhZ3JlZW5cIixcImZvcmVzdGdyZWVuXCIsXCJnb2xkZW5yb2RcIixcImRvZGdlcmJsdWVcIixcImRhcmtvcmNoaWRcIixcImNyaW1zb25cIl07ZnVuY3Rpb24gdXNlQ29sb3JzKCl7cmV0dXJuXCJXZWJraXRBcHBlYXJhbmNlXCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGV8fHdpbmRvdy5jb25zb2xlJiYoY29uc29sZS5maXJlYnVnfHxjb25zb2xlLmV4Y2VwdGlvbiYmY29uc29sZS50YWJsZSl8fG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pJiZwYXJzZUludChSZWdFeHAuJDEsMTApPj0zMX1leHBvcnRzLmZvcm1hdHRlcnMuaj1mdW5jdGlvbih2KXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodil9O2Z1bmN0aW9uIGZvcm1hdEFyZ3MoKXt2YXIgYXJncz1hcmd1bWVudHM7dmFyIHVzZUNvbG9ycz10aGlzLnVzZUNvbG9yczthcmdzWzBdPSh1c2VDb2xvcnM/XCIlY1wiOlwiXCIpK3RoaXMubmFtZXNwYWNlKyh1c2VDb2xvcnM/XCIgJWNcIjpcIiBcIikrYXJnc1swXSsodXNlQ29sb3JzP1wiJWMgXCI6XCIgXCIpK1wiK1wiK2V4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtpZighdXNlQ29sb3JzKXJldHVybiBhcmdzO3ZhciBjPVwiY29sb3I6IFwiK3RoaXMuY29sb3I7YXJncz1bYXJnc1swXSxjLFwiY29sb3I6IGluaGVyaXRcIl0uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsMSkpO3ZhciBpbmRleD0wO3ZhciBsYXN0Qz0wO2FyZ3NbMF0ucmVwbGFjZSgvJVthLXolXS9nLGZ1bmN0aW9uKG1hdGNoKXtpZihcIiVcIj09PW1hdGNoKXJldHVybjtpbmRleCsrO2lmKFwiJWNcIj09PW1hdGNoKXtsYXN0Qz1pbmRleH19KTthcmdzLnNwbGljZShsYXN0QywwLGMpO3JldHVybiBhcmdzfWZ1bmN0aW9uIGxvZygpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBjb25zb2xlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBjb25zb2xlLmxvZyYmRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csY29uc29sZSxhcmd1bWVudHMpfWZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcyl7dHJ5e2lmKG51bGw9PW5hbWVzcGFjZXMpe2xvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFwiZGVidWdcIil9ZWxzZXtsb2NhbFN0b3JhZ2UuZGVidWc9bmFtZXNwYWNlc319Y2F0Y2goZSl7fX1mdW5jdGlvbiBsb2FkKCl7dmFyIHI7dHJ5e3I9bG9jYWxTdG9yYWdlLmRlYnVnfWNhdGNoKGUpe31yZXR1cm4gcn1leHBvcnRzLmVuYWJsZShsb2FkKCkpfSx7XCIuL2RlYnVnXCI6MjN9XSwyMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7ZXhwb3J0cz1tb2R1bGUuZXhwb3J0cz1kZWJ1ZztleHBvcnRzLmNvZXJjZT1jb2VyY2U7ZXhwb3J0cy5kaXNhYmxlPWRpc2FibGU7ZXhwb3J0cy5lbmFibGU9ZW5hYmxlO2V4cG9ydHMuZW5hYmxlZD1lbmFibGVkO2V4cG9ydHMuaHVtYW5pemU9X2RlcmVxXyhcIm1zXCIpO2V4cG9ydHMubmFtZXM9W107ZXhwb3J0cy5za2lwcz1bXTtleHBvcnRzLmZvcm1hdHRlcnM9e307dmFyIHByZXZDb2xvcj0wO3ZhciBwcmV2VGltZTtmdW5jdGlvbiBzZWxlY3RDb2xvcigpe3JldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyVleHBvcnRzLmNvbG9ycy5sZW5ndGhdfWZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSl7ZnVuY3Rpb24gZGlzYWJsZWQoKXt9ZGlzYWJsZWQuZW5hYmxlZD1mYWxzZTtmdW5jdGlvbiBlbmFibGVkKCl7dmFyIHNlbGY9ZW5hYmxlZDt2YXIgY3Vycj0rbmV3IERhdGU7dmFyIG1zPWN1cnItKHByZXZUaW1lfHxjdXJyKTtzZWxmLmRpZmY9bXM7c2VsZi5wcmV2PXByZXZUaW1lO3NlbGYuY3Vycj1jdXJyO3ByZXZUaW1lPWN1cnI7aWYobnVsbD09c2VsZi51c2VDb2xvcnMpc2VsZi51c2VDb2xvcnM9ZXhwb3J0cy51c2VDb2xvcnMoKTtpZihudWxsPT1zZWxmLmNvbG9yJiZzZWxmLnVzZUNvbG9ycylzZWxmLmNvbG9yPXNlbGVjdENvbG9yKCk7dmFyIGFyZ3M9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTthcmdzWzBdPWV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO2lmKFwic3RyaW5nXCIhPT10eXBlb2YgYXJnc1swXSl7YXJncz1bXCIlb1wiXS5jb25jYXQoYXJncyl9dmFyIGluZGV4PTA7YXJnc1swXT1hcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLGZ1bmN0aW9uKG1hdGNoLGZvcm1hdCl7aWYobWF0Y2g9PT1cIiVcIilyZXR1cm4gbWF0Y2g7aW5kZXgrKzt2YXIgZm9ybWF0dGVyPWV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmb3JtYXR0ZXIpe3ZhciB2YWw9YXJnc1tpbmRleF07bWF0Y2g9Zm9ybWF0dGVyLmNhbGwoc2VsZix2YWwpO2FyZ3Muc3BsaWNlKGluZGV4LDEpO2luZGV4LS19cmV0dXJuIG1hdGNofSk7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncyl7YXJncz1leHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZixhcmdzKX12YXIgbG9nRm49ZW5hYmxlZC5sb2d8fGV4cG9ydHMubG9nfHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO2xvZ0ZuLmFwcGx5KHNlbGYsYXJncyl9ZW5hYmxlZC5lbmFibGVkPXRydWU7dmFyIGZuPWV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpP2VuYWJsZWQ6ZGlzYWJsZWQ7Zm4ubmFtZXNwYWNlPW5hbWVzcGFjZTtyZXR1cm4gZm59ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpe2V4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTt2YXIgc3BsaXQ9KG5hbWVzcGFjZXN8fFwiXCIpLnNwbGl0KC9bXFxzLF0rLyk7dmFyIGxlbj1zcGxpdC5sZW5ndGg7Zm9yKHZhciBpPTA7aTxsZW47aSsrKXtpZighc3BsaXRbaV0pY29udGludWU7bmFtZXNwYWNlcz1zcGxpdFtpXS5yZXBsYWNlKC9cXCovZyxcIi4qP1wiKTtpZihuYW1lc3BhY2VzWzBdPT09XCItXCIpe2V4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKFwiXlwiK25hbWVzcGFjZXMuc3Vic3RyKDEpK1wiJFwiKSl9ZWxzZXtleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIituYW1lc3BhY2VzK1wiJFwiKSl9fX1mdW5jdGlvbiBkaXNhYmxlKCl7ZXhwb3J0cy5lbmFibGUoXCJcIil9ZnVuY3Rpb24gZW5hYmxlZChuYW1lKXt2YXIgaSxsZW47Zm9yKGk9MCxsZW49ZXhwb3J0cy5za2lwcy5sZW5ndGg7aTxsZW47aSsrKXtpZihleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpe3JldHVybiBmYWxzZX19Zm9yKGk9MCxsZW49ZXhwb3J0cy5uYW1lcy5sZW5ndGg7aTxsZW47aSsrKXtpZihleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9ZnVuY3Rpb24gY29lcmNlKHZhbCl7aWYodmFsIGluc3RhbmNlb2YgRXJyb3IpcmV0dXJuIHZhbC5zdGFja3x8dmFsLm1lc3NhZ2U7cmV0dXJuIHZhbH19LHttczoyNH1dLDI0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgcz0xZTM7dmFyIG09cyo2MDt2YXIgaD1tKjYwO3ZhciBkPWgqMjQ7dmFyIHk9ZCozNjUuMjU7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24odmFsLG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc3x8e307aWYoXCJzdHJpbmdcIj09dHlwZW9mIHZhbClyZXR1cm4gcGFyc2UodmFsKTtyZXR1cm4gb3B0aW9ucy5sb25nP2xvbmcodmFsKTpzaG9ydCh2YWwpfTtmdW5jdGlvbiBwYXJzZShzdHIpe3ZhciBtYXRjaD0vXigoPzpcXGQrKT9cXC4/XFxkKykgKihtc3xzZWNvbmRzP3xzfG1pbnV0ZXM/fG18aG91cnM/fGh8ZGF5cz98ZHx5ZWFycz98eSk/JC9pLmV4ZWMoc3RyKTtpZighbWF0Y2gpcmV0dXJuO3ZhciBuPXBhcnNlRmxvYXQobWF0Y2hbMV0pO3ZhciB0eXBlPShtYXRjaFsyXXx8XCJtc1wiKS50b0xvd2VyQ2FzZSgpO3N3aXRjaCh0eXBlKXtjYXNlXCJ5ZWFyc1wiOmNhc2VcInllYXJcIjpjYXNlXCJ5XCI6cmV0dXJuIG4qeTtjYXNlXCJkYXlzXCI6Y2FzZVwiZGF5XCI6Y2FzZVwiZFwiOnJldHVybiBuKmQ7Y2FzZVwiaG91cnNcIjpjYXNlXCJob3VyXCI6Y2FzZVwiaFwiOnJldHVybiBuKmg7Y2FzZVwibWludXRlc1wiOmNhc2VcIm1pbnV0ZVwiOmNhc2VcIm1cIjpyZXR1cm4gbiptO2Nhc2VcInNlY29uZHNcIjpjYXNlXCJzZWNvbmRcIjpjYXNlXCJzXCI6cmV0dXJuIG4qcztjYXNlXCJtc1wiOnJldHVybiBufX1mdW5jdGlvbiBzaG9ydChtcyl7aWYobXM+PWQpcmV0dXJuIE1hdGgucm91bmQobXMvZCkrXCJkXCI7aWYobXM+PWgpcmV0dXJuIE1hdGgucm91bmQobXMvaCkrXCJoXCI7aWYobXM+PW0pcmV0dXJuIE1hdGgucm91bmQobXMvbSkrXCJtXCI7aWYobXM+PXMpcmV0dXJuIE1hdGgucm91bmQobXMvcykrXCJzXCI7cmV0dXJuIG1zK1wibXNcIn1mdW5jdGlvbiBsb25nKG1zKXtyZXR1cm4gcGx1cmFsKG1zLGQsXCJkYXlcIil8fHBsdXJhbChtcyxoLFwiaG91clwiKXx8cGx1cmFsKG1zLG0sXCJtaW51dGVcIil8fHBsdXJhbChtcyxzLFwic2Vjb25kXCIpfHxtcytcIiBtc1wifWZ1bmN0aW9uIHBsdXJhbChtcyxuLG5hbWUpe2lmKG1zPG4pcmV0dXJuO2lmKG1zPG4qMS41KXJldHVybiBNYXRoLmZsb29yKG1zL24pK1wiIFwiK25hbWU7cmV0dXJuIE1hdGguY2VpbChtcy9uKStcIiBcIituYW1lK1wic1wifX0se31dLDI1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIga2V5cz1fZGVyZXFfKFwiLi9rZXlzXCIpO3ZhciBoYXNCaW5hcnk9X2RlcmVxXyhcImhhcy1iaW5hcnlcIik7dmFyIHNsaWNlQnVmZmVyPV9kZXJlcV8oXCJhcnJheWJ1ZmZlci5zbGljZVwiKTt2YXIgYmFzZTY0ZW5jb2Rlcj1fZGVyZXFfKFwiYmFzZTY0LWFycmF5YnVmZmVyXCIpO3ZhciBhZnRlcj1fZGVyZXFfKFwiYWZ0ZXJcIik7dmFyIHV0Zjg9X2RlcmVxXyhcInV0ZjhcIik7dmFyIGlzQW5kcm9pZD1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO3ZhciBpc1BoYW50b21KUz0vUGhhbnRvbUpTL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTt2YXIgZG9udFNlbmRCbG9icz1pc0FuZHJvaWR8fGlzUGhhbnRvbUpTO2V4cG9ydHMucHJvdG9jb2w9Mzt2YXIgcGFja2V0cz1leHBvcnRzLnBhY2tldHM9e29wZW46MCxjbG9zZToxLHBpbmc6Mixwb25nOjMsbWVzc2FnZTo0LHVwZ3JhZGU6NSxub29wOjZ9O3ZhciBwYWNrZXRzbGlzdD1rZXlzKHBhY2tldHMpO3ZhciBlcnI9e3R5cGU6XCJlcnJvclwiLGRhdGE6XCJwYXJzZXIgZXJyb3JcIn07dmFyIEJsb2I9X2RlcmVxXyhcImJsb2JcIik7ZXhwb3J0cy5lbmNvZGVQYWNrZXQ9ZnVuY3Rpb24ocGFja2V0LHN1cHBvcnRzQmluYXJ5LHV0ZjhlbmNvZGUsY2FsbGJhY2spe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHN1cHBvcnRzQmluYXJ5KXtjYWxsYmFjaz1zdXBwb3J0c0JpbmFyeTtzdXBwb3J0c0JpbmFyeT1mYWxzZX1pZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB1dGY4ZW5jb2RlKXtjYWxsYmFjaz11dGY4ZW5jb2RlO3V0ZjhlbmNvZGU9bnVsbH12YXIgZGF0YT1wYWNrZXQuZGF0YT09PXVuZGVmaW5lZD91bmRlZmluZWQ6cGFja2V0LmRhdGEuYnVmZmVyfHxwYWNrZXQuZGF0YTtpZihnbG9iYWwuQXJyYXlCdWZmZXImJmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcil7cmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCxzdXBwb3J0c0JpbmFyeSxjYWxsYmFjayl9ZWxzZSBpZihCbG9iJiZkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2Ipe3JldHVybiBlbmNvZGVCbG9iKHBhY2tldCxzdXBwb3J0c0JpbmFyeSxjYWxsYmFjayl9aWYoZGF0YSYmZGF0YS5iYXNlNjQpe3JldHVybiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LGNhbGxiYWNrKX12YXIgZW5jb2RlZD1wYWNrZXRzW3BhY2tldC50eXBlXTtpZih1bmRlZmluZWQhPT1wYWNrZXQuZGF0YSl7ZW5jb2RlZCs9dXRmOGVuY29kZT91dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKTpTdHJpbmcocGFja2V0LmRhdGEpfXJldHVybiBjYWxsYmFjayhcIlwiK2VuY29kZWQpfTtmdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LGNhbGxiYWNrKXt2YXIgbWVzc2FnZT1cImJcIitleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdK3BhY2tldC5kYXRhLmRhdGE7cmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpfWZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCxzdXBwb3J0c0JpbmFyeSxjYWxsYmFjayl7aWYoIXN1cHBvcnRzQmluYXJ5KXtyZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LGNhbGxiYWNrKX12YXIgZGF0YT1wYWNrZXQuZGF0YTt2YXIgY29udGVudEFycmF5PW5ldyBVaW50OEFycmF5KGRhdGEpO3ZhciByZXN1bHRCdWZmZXI9bmV3IFVpbnQ4QXJyYXkoMStkYXRhLmJ5dGVMZW5ndGgpO3Jlc3VsdEJ1ZmZlclswXT1wYWNrZXRzW3BhY2tldC50eXBlXTtmb3IodmFyIGk9MDtpPGNvbnRlbnRBcnJheS5sZW5ndGg7aSsrKXtyZXN1bHRCdWZmZXJbaSsxXT1jb250ZW50QXJyYXlbaV19cmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpfWZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCxzdXBwb3J0c0JpbmFyeSxjYWxsYmFjayl7aWYoIXN1cHBvcnRzQmluYXJ5KXtyZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LGNhbGxiYWNrKX12YXIgZnI9bmV3IEZpbGVSZWFkZXI7ZnIub25sb2FkPWZ1bmN0aW9uKCl7cGFja2V0LmRhdGE9ZnIucmVzdWx0O2V4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCxzdXBwb3J0c0JpbmFyeSx0cnVlLGNhbGxiYWNrKX07cmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKX1mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCxzdXBwb3J0c0JpbmFyeSxjYWxsYmFjayl7aWYoIXN1cHBvcnRzQmluYXJ5KXtyZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LGNhbGxiYWNrKX1pZihkb250U2VuZEJsb2JzKXtyZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LHN1cHBvcnRzQmluYXJ5LGNhbGxiYWNrKX12YXIgbGVuZ3RoPW5ldyBVaW50OEFycmF5KDEpO2xlbmd0aFswXT1wYWNrZXRzW3BhY2tldC50eXBlXTt2YXIgYmxvYj1uZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlcixwYWNrZXQuZGF0YV0pO3JldHVybiBjYWxsYmFjayhibG9iKX1leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldD1mdW5jdGlvbihwYWNrZXQsY2FsbGJhY2spe3ZhciBtZXNzYWdlPVwiYlwiK2V4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07aWYoQmxvYiYmcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBCbG9iKXt2YXIgZnI9bmV3IEZpbGVSZWFkZXI7ZnIub25sb2FkPWZ1bmN0aW9uKCl7dmFyIGI2ND1mci5yZXN1bHQuc3BsaXQoXCIsXCIpWzFdO2NhbGxiYWNrKG1lc3NhZ2UrYjY0KX07cmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpfXZhciBiNjRkYXRhO3RyeXtiNjRkYXRhPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxuZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSkpfWNhdGNoKGUpe3ZhciB0eXBlZD1uZXcgVWludDhBcnJheShwYWNrZXQuZGF0YSk7dmFyIGJhc2ljPW5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8dHlwZWQubGVuZ3RoO2krKyl7YmFzaWNbaV09dHlwZWRbaV19YjY0ZGF0YT1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsYmFzaWMpfW1lc3NhZ2UrPWdsb2JhbC5idG9hKGI2NGRhdGEpO3JldHVybiBjYWxsYmFjayhtZXNzYWdlKX07ZXhwb3J0cy5kZWNvZGVQYWNrZXQ9ZnVuY3Rpb24oZGF0YSxiaW5hcnlUeXBlLHV0ZjhkZWNvZGUpe2lmKHR5cGVvZiBkYXRhPT1cInN0cmluZ1wifHxkYXRhPT09dW5kZWZpbmVkKXtpZihkYXRhLmNoYXJBdCgwKT09XCJiXCIpe3JldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSxiaW5hcnlUeXBlKX1pZih1dGY4ZGVjb2RlKXt0cnl7ZGF0YT11dGY4LmRlY29kZShkYXRhKX1jYXRjaChlKXtyZXR1cm4gZXJyfX12YXIgdHlwZT1kYXRhLmNoYXJBdCgwKTtpZihOdW1iZXIodHlwZSkhPXR5cGV8fCFwYWNrZXRzbGlzdFt0eXBlXSl7cmV0dXJuIGVycn1pZihkYXRhLmxlbmd0aD4xKXtyZXR1cm57dHlwZTpwYWNrZXRzbGlzdFt0eXBlXSxkYXRhOmRhdGEuc3Vic3RyaW5nKDEpfX1lbHNle3JldHVybnt0eXBlOnBhY2tldHNsaXN0W3R5cGVdfX19dmFyIGFzQXJyYXk9bmV3IFVpbnQ4QXJyYXkoZGF0YSk7dmFyIHR5cGU9YXNBcnJheVswXTt2YXIgcmVzdD1zbGljZUJ1ZmZlcihkYXRhLDEpO2lmKEJsb2ImJmJpbmFyeVR5cGU9PT1cImJsb2JcIil7cmVzdD1uZXcgQmxvYihbcmVzdF0pfXJldHVybnt0eXBlOnBhY2tldHNsaXN0W3R5cGVdLGRhdGE6cmVzdH19O2V4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0PWZ1bmN0aW9uKG1zZyxiaW5hcnlUeXBlKXt2YXIgdHlwZT1wYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtpZighZ2xvYmFsLkFycmF5QnVmZmVyKXtyZXR1cm57dHlwZTp0eXBlLGRhdGE6e2Jhc2U2NDp0cnVlLGRhdGE6bXNnLnN1YnN0cigxKX19fXZhciBkYXRhPWJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO2lmKGJpbmFyeVR5cGU9PT1cImJsb2JcIiYmQmxvYil7ZGF0YT1uZXcgQmxvYihbZGF0YV0pfXJldHVybnt0eXBlOnR5cGUsZGF0YTpkYXRhfX07ZXhwb3J0cy5lbmNvZGVQYXlsb2FkPWZ1bmN0aW9uKHBhY2tldHMsc3VwcG9ydHNCaW5hcnksY2FsbGJhY2spe2lmKHR5cGVvZiBzdXBwb3J0c0JpbmFyeT09XCJmdW5jdGlvblwiKXtjYWxsYmFjaz1zdXBwb3J0c0JpbmFyeTtzdXBwb3J0c0JpbmFyeT1udWxsfXZhciBpc0JpbmFyeT1oYXNCaW5hcnkocGFja2V0cyk7aWYoc3VwcG9ydHNCaW5hcnkmJmlzQmluYXJ5KXtpZihCbG9iJiYhZG9udFNlbmRCbG9icyl7cmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLGNhbGxiYWNrKX1yZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLGNhbGxiYWNrKX1pZighcGFja2V0cy5sZW5ndGgpe3JldHVybiBjYWxsYmFjayhcIjA6XCIpfWZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKXtyZXR1cm4gbWVzc2FnZS5sZW5ndGgrXCI6XCIrbWVzc2FnZX1mdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LGRvbmVDYWxsYmFjayl7ZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCFpc0JpbmFyeT9mYWxzZTpzdXBwb3J0c0JpbmFyeSx0cnVlLGZ1bmN0aW9uKG1lc3NhZ2Upe2RvbmVDYWxsYmFjayhudWxsLHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSl9KX1tYXAocGFja2V0cyxlbmNvZGVPbmUsZnVuY3Rpb24oZXJyLHJlc3VsdHMpe3JldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oXCJcIikpfSl9O2Z1bmN0aW9uIG1hcChhcnksZWFjaCxkb25lKXt2YXIgcmVzdWx0PW5ldyBBcnJheShhcnkubGVuZ3RoKTt2YXIgbmV4dD1hZnRlcihhcnkubGVuZ3RoLGRvbmUpO3ZhciBlYWNoV2l0aEluZGV4PWZ1bmN0aW9uKGksZWwsY2Ipe2VhY2goZWwsZnVuY3Rpb24oZXJyb3IsbXNnKXtyZXN1bHRbaV09bXNnO2NiKGVycm9yLHJlc3VsdCl9KX07Zm9yKHZhciBpPTA7aTxhcnkubGVuZ3RoO2krKyl7ZWFjaFdpdGhJbmRleChpLGFyeVtpXSxuZXh0KX19ZXhwb3J0cy5kZWNvZGVQYXlsb2FkPWZ1bmN0aW9uKGRhdGEsYmluYXJ5VHlwZSxjYWxsYmFjayl7aWYodHlwZW9mIGRhdGEhPVwic3RyaW5nXCIpe3JldHVybiBleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLGJpbmFyeVR5cGUsY2FsbGJhY2spfWlmKHR5cGVvZiBiaW5hcnlUeXBlPT09XCJmdW5jdGlvblwiKXtjYWxsYmFjaz1iaW5hcnlUeXBlO2JpbmFyeVR5cGU9bnVsbH12YXIgcGFja2V0O2lmKGRhdGE9PVwiXCIpe3JldHVybiBjYWxsYmFjayhlcnIsMCwxKX12YXIgbGVuZ3RoPVwiXCIsbixtc2c7Zm9yKHZhciBpPTAsbD1kYXRhLmxlbmd0aDtpPGw7aSsrKXt2YXIgY2hyPWRhdGEuY2hhckF0KGkpO2lmKFwiOlwiIT1jaHIpe2xlbmd0aCs9Y2hyfWVsc2V7aWYoXCJcIj09bGVuZ3RofHxsZW5ndGghPShuPU51bWJlcihsZW5ndGgpKSl7cmV0dXJuIGNhbGxiYWNrKGVyciwwLDEpfW1zZz1kYXRhLnN1YnN0cihpKzEsbik7aWYobGVuZ3RoIT1tc2cubGVuZ3RoKXtyZXR1cm4gY2FsbGJhY2soZXJyLDAsMSl9aWYobXNnLmxlbmd0aCl7cGFja2V0PWV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZyxiaW5hcnlUeXBlLHRydWUpO2lmKGVyci50eXBlPT1wYWNrZXQudHlwZSYmZXJyLmRhdGE9PXBhY2tldC5kYXRhKXtyZXR1cm4gY2FsbGJhY2soZXJyLDAsMSl9dmFyIHJldD1jYWxsYmFjayhwYWNrZXQsaStuLGwpO2lmKGZhbHNlPT09cmV0KXJldHVybn1pKz1uO2xlbmd0aD1cIlwifX1pZihsZW5ndGghPVwiXCIpe3JldHVybiBjYWxsYmFjayhlcnIsMCwxKX19O2V4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXI9ZnVuY3Rpb24ocGFja2V0cyxjYWxsYmFjayl7aWYoIXBhY2tldHMubGVuZ3RoKXtyZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKX1mdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LGRvbmVDYWxsYmFjayl7ZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LHRydWUsdHJ1ZSxmdW5jdGlvbihkYXRhKXtyZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsZGF0YSl9KX1tYXAocGFja2V0cyxlbmNvZGVPbmUsZnVuY3Rpb24oZXJyLGVuY29kZWRQYWNrZXRzKXt2YXIgdG90YWxMZW5ndGg9ZW5jb2RlZFBhY2tldHMucmVkdWNlKGZ1bmN0aW9uKGFjYyxwKXt2YXIgbGVuO2lmKHR5cGVvZiBwPT09XCJzdHJpbmdcIil7bGVuPXAubGVuZ3RofWVsc2V7bGVuPXAuYnl0ZUxlbmd0aH1yZXR1cm4gYWNjK2xlbi50b1N0cmluZygpLmxlbmd0aCtsZW4rMn0sMCk7dmFyIHJlc3VsdEFycmF5PW5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTt2YXIgYnVmZmVySW5kZXg9MDtlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApe3ZhciBpc1N0cmluZz10eXBlb2YgcD09PVwic3RyaW5nXCI7dmFyIGFiPXA7aWYoaXNTdHJpbmcpe3ZhciB2aWV3PW5ldyBVaW50OEFycmF5KHAubGVuZ3RoKTtmb3IodmFyIGk9MDtpPHAubGVuZ3RoO2krKyl7dmlld1tpXT1wLmNoYXJDb2RlQXQoaSl9YWI9dmlldy5idWZmZXJ9aWYoaXNTdHJpbmcpe3Jlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdPTB9ZWxzZXtyZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXT0xfXZhciBsZW5TdHI9YWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO2Zvcih2YXIgaT0wO2k8bGVuU3RyLmxlbmd0aDtpKyspe3Jlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdPXBhcnNlSW50KGxlblN0cltpXSl9cmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK109MjU1O3ZhciB2aWV3PW5ldyBVaW50OEFycmF5KGFiKTtmb3IodmFyIGk9MDtpPHZpZXcubGVuZ3RoO2krKyl7cmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK109dmlld1tpXX19KTtyZXR1cm4gY2FsbGJhY2socmVzdWx0QXJyYXkuYnVmZmVyKX0pfTtleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2I9ZnVuY3Rpb24ocGFja2V0cyxjYWxsYmFjayl7ZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCxkb25lQ2FsbGJhY2spe2V4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCx0cnVlLHRydWUsZnVuY3Rpb24oZW5jb2RlZCl7dmFyIGJpbmFyeUlkZW50aWZpZXI9bmV3IFVpbnQ4QXJyYXkoMSk7YmluYXJ5SWRlbnRpZmllclswXT0xO2lmKHR5cGVvZiBlbmNvZGVkPT09XCJzdHJpbmdcIil7dmFyIHZpZXc9bmV3IFVpbnQ4QXJyYXkoZW5jb2RlZC5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8ZW5jb2RlZC5sZW5ndGg7aSsrKXt2aWV3W2ldPWVuY29kZWQuY2hhckNvZGVBdChpKX1lbmNvZGVkPXZpZXcuYnVmZmVyO2JpbmFyeUlkZW50aWZpZXJbMF09MH12YXIgbGVuPWVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcj9lbmNvZGVkLmJ5dGVMZW5ndGg6ZW5jb2RlZC5zaXplO3ZhciBsZW5TdHI9bGVuLnRvU3RyaW5nKCk7dmFyIGxlbmd0aEFyeT1uZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoKzEpO2Zvcih2YXIgaT0wO2k8bGVuU3RyLmxlbmd0aDtpKyspe2xlbmd0aEFyeVtpXT1wYXJzZUludChsZW5TdHJbaV0pfWxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXT0yNTU7aWYoQmxvYil7dmFyIGJsb2I9bmV3IEJsb2IoW2JpbmFyeUlkZW50aWZpZXIuYnVmZmVyLGxlbmd0aEFyeS5idWZmZXIsZW5jb2RlZF0pO2RvbmVDYWxsYmFjayhudWxsLGJsb2IpfX0pfW1hcChwYWNrZXRzLGVuY29kZU9uZSxmdW5jdGlvbihlcnIscmVzdWx0cyl7cmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKX0pfTtleHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeT1mdW5jdGlvbihkYXRhLGJpbmFyeVR5cGUsY2FsbGJhY2spe2lmKHR5cGVvZiBiaW5hcnlUeXBlPT09XCJmdW5jdGlvblwiKXtjYWxsYmFjaz1iaW5hcnlUeXBlO2JpbmFyeVR5cGU9bnVsbH12YXIgYnVmZmVyVGFpbD1kYXRhO3ZhciBidWZmZXJzPVtdO3ZhciBudW1iZXJUb29Mb25nPWZhbHNlO3doaWxlKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aD4wKXt2YXIgdGFpbEFycmF5PW5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO3ZhciBpc1N0cmluZz10YWlsQXJyYXlbMF09PT0wO3ZhciBtc2dMZW5ndGg9XCJcIjtmb3IodmFyIGk9MTs7aSsrKXtpZih0YWlsQXJyYXlbaV09PTI1NSlicmVhaztpZihtc2dMZW5ndGgubGVuZ3RoPjMxMCl7bnVtYmVyVG9vTG9uZz10cnVlO2JyZWFrfW1zZ0xlbmd0aCs9dGFpbEFycmF5W2ldfWlmKG51bWJlclRvb0xvbmcpcmV0dXJuIGNhbGxiYWNrKGVyciwwLDEpO2J1ZmZlclRhaWw9c2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwyK21zZ0xlbmd0aC5sZW5ndGgpO21zZ0xlbmd0aD1wYXJzZUludChtc2dMZW5ndGgpO3ZhciBtc2c9c2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwwLG1zZ0xlbmd0aCk7aWYoaXNTdHJpbmcpe3RyeXttc2c9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50OEFycmF5KG1zZykpfWNhdGNoKGUpe3ZhciB0eXBlZD1uZXcgVWludDhBcnJheShtc2cpO21zZz1cIlwiO2Zvcih2YXIgaT0wO2k8dHlwZWQubGVuZ3RoO2krKyl7bXNnKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKX19fWJ1ZmZlcnMucHVzaChtc2cpO2J1ZmZlclRhaWw9c2xpY2VCdWZmZXIoYnVmZmVyVGFpbCxtc2dMZW5ndGgpfXZhciB0b3RhbD1idWZmZXJzLmxlbmd0aDtidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLGkpe2NhbGxiYWNrKGV4cG9ydHMuZGVjb2RlUGFja2V0KGJ1ZmZlcixiaW5hcnlUeXBlLHRydWUpLGksdG90YWwpfSl9fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtcIi4va2V5c1wiOjI2LGFmdGVyOjI3LFwiYXJyYXlidWZmZXIuc2xpY2VcIjoyOCxcImJhc2U2NC1hcnJheWJ1ZmZlclwiOjI5LGJsb2I6MzAsXCJoYXMtYmluYXJ5XCI6MzEsdXRmODozM31dLDI2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24ga2V5cyhvYmope3ZhciBhcnI9W107dmFyIGhhcz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2Zvcih2YXIgaSBpbiBvYmope2lmKGhhcy5jYWxsKG9iaixpKSl7YXJyLnB1c2goaSl9fXJldHVybiBhcnJ9fSx7fV0sMjc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPWFmdGVyO2Z1bmN0aW9uIGFmdGVyKGNvdW50LGNhbGxiYWNrLGVycl9jYil7dmFyIGJhaWw9ZmFsc2U7ZXJyX2NiPWVycl9jYnx8bm9vcDtwcm94eS5jb3VudD1jb3VudDtyZXR1cm4gY291bnQ9PT0wP2NhbGxiYWNrKCk6cHJveHk7ZnVuY3Rpb24gcHJveHkoZXJyLHJlc3VsdCl7aWYocHJveHkuY291bnQ8PTApe3Rocm93IG5ldyBFcnJvcihcImFmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lc1wiKX0tLXByb3h5LmNvdW50O2lmKGVycil7YmFpbD10cnVlO2NhbGxiYWNrKGVycik7Y2FsbGJhY2s9ZXJyX2NifWVsc2UgaWYocHJveHkuY291bnQ9PT0wJiYhYmFpbCl7Y2FsbGJhY2sobnVsbCxyZXN1bHQpfX19ZnVuY3Rpb24gbm9vcCgpe319LHt9XSwyODpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oYXJyYXlidWZmZXIsc3RhcnQsZW5kKXt2YXIgYnl0ZXM9YXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtzdGFydD1zdGFydHx8MDtlbmQ9ZW5kfHxieXRlcztpZihhcnJheWJ1ZmZlci5zbGljZSl7cmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LGVuZCl9aWYoc3RhcnQ8MCl7c3RhcnQrPWJ5dGVzfWlmKGVuZDwwKXtlbmQrPWJ5dGVzfWlmKGVuZD5ieXRlcyl7ZW5kPWJ5dGVzfWlmKHN0YXJ0Pj1ieXRlc3x8c3RhcnQ+PWVuZHx8Ynl0ZXM9PT0wKXtyZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApfXZhciBhYnY9bmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO3ZhciByZXN1bHQ9bmV3IFVpbnQ4QXJyYXkoZW5kLXN0YXJ0KTtmb3IodmFyIGk9c3RhcnQsaWk9MDtpPGVuZDtpKyssaWkrKyl7cmVzdWx0W2lpXT1hYnZbaV19cmV0dXJuIHJlc3VsdC5idWZmZXJ9fSx7fV0sMjk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihjaGFycyl7XCJ1c2Ugc3RyaWN0XCI7ZXhwb3J0cy5lbmNvZGU9ZnVuY3Rpb24oYXJyYXlidWZmZXIpe3ZhciBieXRlcz1uZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksaSxsZW49Ynl0ZXMubGVuZ3RoLGJhc2U2ND1cIlwiO2ZvcihpPTA7aTxsZW47aSs9Myl7YmFzZTY0Kz1jaGFyc1tieXRlc1tpXT4+Ml07YmFzZTY0Kz1jaGFyc1soYnl0ZXNbaV0mMyk8PDR8Ynl0ZXNbaSsxXT4+NF07YmFzZTY0Kz1jaGFyc1soYnl0ZXNbaSsxXSYxNSk8PDJ8Ynl0ZXNbaSsyXT4+Nl07YmFzZTY0Kz1jaGFyc1tieXRlc1tpKzJdJjYzXX1pZihsZW4lMz09PTIpe2Jhc2U2ND1iYXNlNjQuc3Vic3RyaW5nKDAsYmFzZTY0Lmxlbmd0aC0xKStcIj1cIn1lbHNlIGlmKGxlbiUzPT09MSl7YmFzZTY0PWJhc2U2NC5zdWJzdHJpbmcoMCxiYXNlNjQubGVuZ3RoLTIpK1wiPT1cIn1yZXR1cm4gYmFzZTY0fTtleHBvcnRzLmRlY29kZT1mdW5jdGlvbihiYXNlNjQpe3ZhciBidWZmZXJMZW5ndGg9YmFzZTY0Lmxlbmd0aCouNzUsbGVuPWJhc2U2NC5sZW5ndGgsaSxwPTAsZW5jb2RlZDEsZW5jb2RlZDIsZW5jb2RlZDMsZW5jb2RlZDQ7aWYoYmFzZTY0W2Jhc2U2NC5sZW5ndGgtMV09PT1cIj1cIil7YnVmZmVyTGVuZ3RoLS07aWYoYmFzZTY0W2Jhc2U2NC5sZW5ndGgtMl09PT1cIj1cIil7YnVmZmVyTGVuZ3RoLS19fXZhciBhcnJheWJ1ZmZlcj1uZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxieXRlcz1uZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7Zm9yKGk9MDtpPGxlbjtpKz00KXtlbmNvZGVkMT1jaGFycy5pbmRleE9mKGJhc2U2NFtpXSk7ZW5jb2RlZDI9Y2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7ZW5jb2RlZDM9Y2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7ZW5jb2RlZDQ9Y2hhcnMuaW5kZXhPZihiYXNlNjRbaSszXSk7Ynl0ZXNbcCsrXT1lbmNvZGVkMTw8MnxlbmNvZGVkMj4+NDtieXRlc1twKytdPShlbmNvZGVkMiYxNSk8PDR8ZW5jb2RlZDM+PjI7Ynl0ZXNbcCsrXT0oZW5jb2RlZDMmMyk8PDZ8ZW5jb2RlZDQmNjN9cmV0dXJuIGFycmF5YnVmZmVyfX0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKX0se31dLDMwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgQmxvYkJ1aWxkZXI9Z2xvYmFsLkJsb2JCdWlsZGVyfHxnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJ8fGdsb2JhbC5NU0Jsb2JCdWlsZGVyfHxnbG9iYWwuTW96QmxvYkJ1aWxkZXI7dmFyIGJsb2JTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXt0cnl7dmFyIGI9bmV3IEJsb2IoW1wiaGlcIl0pO3JldHVybiBiLnNpemU9PTJ9Y2F0Y2goZSl7cmV0dXJuIGZhbHNlfX0oKTt2YXIgYmxvYkJ1aWxkZXJTdXBwb3J0ZWQ9QmxvYkJ1aWxkZXImJkJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmQmJkJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO2Z1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LG9wdGlvbnMpe29wdGlvbnM9b3B0aW9uc3x8e307dmFyIGJiPW5ldyBCbG9iQnVpbGRlcjtmb3IodmFyIGk9MDtpPGFyeS5sZW5ndGg7aSsrKXtiYi5hcHBlbmQoYXJ5W2ldKX1yZXR1cm4gb3B0aW9ucy50eXBlP2JiLmdldEJsb2Iob3B0aW9ucy50eXBlKTpiYi5nZXRCbG9iKCl9bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oKXtpZihibG9iU3VwcG9ydGVkKXtyZXR1cm4gZ2xvYmFsLkJsb2J9ZWxzZSBpZihibG9iQnVpbGRlclN1cHBvcnRlZCl7cmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3J9ZWxzZXtyZXR1cm4gdW5kZWZpbmVkfX0oKX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7fV0sMzE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBpc0FycmF5PV9kZXJlcV8oXCJpc2FycmF5XCIpO21vZHVsZS5leHBvcnRzPWhhc0JpbmFyeTtmdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSl7ZnVuY3Rpb24gX2hhc0JpbmFyeShvYmope2lmKCFvYmopcmV0dXJuIGZhbHNlO2lmKGdsb2JhbC5CdWZmZXImJmdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKXx8Z2xvYmFsLkFycmF5QnVmZmVyJiZvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8Z2xvYmFsLkJsb2ImJm9iaiBpbnN0YW5jZW9mIEJsb2J8fGdsb2JhbC5GaWxlJiZvYmogaW5zdGFuY2VvZiBGaWxlKXtyZXR1cm4gdHJ1ZX1pZihpc0FycmF5KG9iaikpe2Zvcih2YXIgaT0wO2k8b2JqLmxlbmd0aDtpKyspe2lmKF9oYXNCaW5hcnkob2JqW2ldKSl7cmV0dXJuIHRydWV9fX1lbHNlIGlmKG9iaiYmXCJvYmplY3RcIj09dHlwZW9mIG9iail7aWYob2JqLnRvSlNPTil7b2JqPW9iai50b0pTT04oKX1mb3IodmFyIGtleSBpbiBvYmope2lmKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpJiZfaGFzQmluYXJ5KG9ialtrZXldKSl7cmV0dXJuIHRydWV9fX1yZXR1cm4gZmFsc2V9cmV0dXJuIF9oYXNCaW5hcnkoZGF0YSl9fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtpc2FycmF5OjMyfV0sMzI6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKGFycil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpPT1cIltvYmplY3QgQXJyYXldXCJ9fSx7fV0sMzM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpeyhmdW5jdGlvbihyb290KXt2YXIgZnJlZUV4cG9ydHM9dHlwZW9mIGV4cG9ydHM9PVwib2JqZWN0XCImJmV4cG9ydHM7dmFyIGZyZWVNb2R1bGU9dHlwZW9mIG1vZHVsZT09XCJvYmplY3RcIiYmbW9kdWxlJiZtb2R1bGUuZXhwb3J0cz09ZnJlZUV4cG9ydHMmJm1vZHVsZTt2YXIgZnJlZUdsb2JhbD10eXBlb2YgZ2xvYmFsPT1cIm9iamVjdFwiJiZnbG9iYWw7aWYoZnJlZUdsb2JhbC5nbG9iYWw9PT1mcmVlR2xvYmFsfHxmcmVlR2xvYmFsLndpbmRvdz09PWZyZWVHbG9iYWwpe3Jvb3Q9ZnJlZUdsb2JhbH12YXIgc3RyaW5nRnJvbUNoYXJDb2RlPVN0cmluZy5mcm9tQ2hhckNvZGU7ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpe3ZhciBvdXRwdXQ9W107dmFyIGNvdW50ZXI9MDt2YXIgbGVuZ3RoPXN0cmluZy5sZW5ndGg7dmFyIHZhbHVlO3ZhciBleHRyYTt3aGlsZShjb3VudGVyPGxlbmd0aCl7dmFsdWU9c3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtpZih2YWx1ZT49NTUyOTYmJnZhbHVlPD01NjMxOSYmY291bnRlcjxsZW5ndGgpe2V4dHJhPXN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7aWYoKGV4dHJhJjY0NTEyKT09NTYzMjApe291dHB1dC5wdXNoKCgodmFsdWUmMTAyMyk8PDEwKSsoZXh0cmEmMTAyMykrNjU1MzYpfWVsc2V7b3V0cHV0LnB1c2godmFsdWUpO2NvdW50ZXItLX19ZWxzZXtvdXRwdXQucHVzaCh2YWx1ZSl9fXJldHVybiBvdXRwdXR9ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSl7dmFyIGxlbmd0aD1hcnJheS5sZW5ndGg7dmFyIGluZGV4PS0xO3ZhciB2YWx1ZTt2YXIgb3V0cHV0PVwiXCI7d2hpbGUoKytpbmRleDxsZW5ndGgpe3ZhbHVlPWFycmF5W2luZGV4XTtpZih2YWx1ZT42NTUzNSl7dmFsdWUtPTY1NTM2O1xub3V0cHV0Kz1zdHJpbmdGcm9tQ2hhckNvZGUodmFsdWU+Pj4xMCYxMDIzfDU1Mjk2KTt2YWx1ZT01NjMyMHx2YWx1ZSYxMDIzfW91dHB1dCs9c3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKX1yZXR1cm4gb3V0cHV0fWZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LHNoaWZ0KXtyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludD4+c2hpZnQmNjN8MTI4KX1mdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KXtpZigoY29kZVBvaW50JjQyOTQ5NjcxNjgpPT0wKXtyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCl9dmFyIHN5bWJvbD1cIlwiO2lmKChjb2RlUG9pbnQmNDI5NDk2NTI0OCk9PTApe3N5bWJvbD1zdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50Pj42JjMxfDE5Mil9ZWxzZSBpZigoY29kZVBvaW50JjQyOTQ5MDE3NjApPT0wKXtzeW1ib2w9c3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludD4+MTImMTV8MjI0KTtzeW1ib2wrPWNyZWF0ZUJ5dGUoY29kZVBvaW50LDYpfWVsc2UgaWYoKGNvZGVQb2ludCY0MjkyODcwMTQ0KT09MCl7c3ltYm9sPXN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQ+PjE4Jjd8MjQwKTtzeW1ib2wrPWNyZWF0ZUJ5dGUoY29kZVBvaW50LDEyKTtzeW1ib2wrPWNyZWF0ZUJ5dGUoY29kZVBvaW50LDYpfXN5bWJvbCs9c3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCY2M3wxMjgpO3JldHVybiBzeW1ib2x9ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpe3ZhciBjb2RlUG9pbnRzPXVjczJkZWNvZGUoc3RyaW5nKTt2YXIgbGVuZ3RoPWNvZGVQb2ludHMubGVuZ3RoO3ZhciBpbmRleD0tMTt2YXIgY29kZVBvaW50O3ZhciBieXRlU3RyaW5nPVwiXCI7d2hpbGUoKytpbmRleDxsZW5ndGgpe2NvZGVQb2ludD1jb2RlUG9pbnRzW2luZGV4XTtieXRlU3RyaW5nKz1lbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KX1yZXR1cm4gYnl0ZVN0cmluZ31mdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpe2lmKGJ5dGVJbmRleD49Ynl0ZUNvdW50KXt0aHJvdyBFcnJvcihcIkludmFsaWQgYnl0ZSBpbmRleFwiKX12YXIgY29udGludWF0aW9uQnl0ZT1ieXRlQXJyYXlbYnl0ZUluZGV4XSYyNTU7Ynl0ZUluZGV4Kys7aWYoKGNvbnRpbnVhdGlvbkJ5dGUmMTkyKT09MTI4KXtyZXR1cm4gY29udGludWF0aW9uQnl0ZSY2M310aHJvdyBFcnJvcihcIkludmFsaWQgY29udGludWF0aW9uIGJ5dGVcIil9ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCl7dmFyIGJ5dGUxO3ZhciBieXRlMjt2YXIgYnl0ZTM7dmFyIGJ5dGU0O3ZhciBjb2RlUG9pbnQ7aWYoYnl0ZUluZGV4PmJ5dGVDb3VudCl7dGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJ5dGUgaW5kZXhcIil9aWYoYnl0ZUluZGV4PT1ieXRlQ291bnQpe3JldHVybiBmYWxzZX1ieXRlMT1ieXRlQXJyYXlbYnl0ZUluZGV4XSYyNTU7Ynl0ZUluZGV4Kys7aWYoKGJ5dGUxJjEyOCk9PTApe3JldHVybiBieXRlMX1pZigoYnl0ZTEmMjI0KT09MTkyKXt2YXIgYnl0ZTI9cmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtjb2RlUG9pbnQ9KGJ5dGUxJjMxKTw8NnxieXRlMjtpZihjb2RlUG9pbnQ+PTEyOCl7cmV0dXJuIGNvZGVQb2ludH1lbHNle3Rocm93IEVycm9yKFwiSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVwiKX19aWYoKGJ5dGUxJjI0MCk9PTIyNCl7Ynl0ZTI9cmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtieXRlMz1yZWFkQ29udGludWF0aW9uQnl0ZSgpO2NvZGVQb2ludD0oYnl0ZTEmMTUpPDwxMnxieXRlMjw8NnxieXRlMztpZihjb2RlUG9pbnQ+PTIwNDgpe3JldHVybiBjb2RlUG9pbnR9ZWxzZXt0aHJvdyBFcnJvcihcIkludmFsaWQgY29udGludWF0aW9uIGJ5dGVcIil9fWlmKChieXRlMSYyNDgpPT0yNDApe2J5dGUyPXJlYWRDb250aW51YXRpb25CeXRlKCk7Ynl0ZTM9cmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtieXRlND1yZWFkQ29udGludWF0aW9uQnl0ZSgpO2NvZGVQb2ludD0oYnl0ZTEmMTUpPDwxOHxieXRlMjw8MTJ8Ynl0ZTM8PDZ8Ynl0ZTQ7aWYoY29kZVBvaW50Pj02NTUzNiYmY29kZVBvaW50PD0xMTE0MTExKXtyZXR1cm4gY29kZVBvaW50fX10aHJvdyBFcnJvcihcIkludmFsaWQgVVRGLTggZGV0ZWN0ZWRcIil9dmFyIGJ5dGVBcnJheTt2YXIgYnl0ZUNvdW50O3ZhciBieXRlSW5kZXg7ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKXtieXRlQXJyYXk9dWNzMmRlY29kZShieXRlU3RyaW5nKTtieXRlQ291bnQ9Ynl0ZUFycmF5Lmxlbmd0aDtieXRlSW5kZXg9MDt2YXIgY29kZVBvaW50cz1bXTt2YXIgdG1wO3doaWxlKCh0bXA9ZGVjb2RlU3ltYm9sKCkpIT09ZmFsc2Upe2NvZGVQb2ludHMucHVzaCh0bXApfXJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpfXZhciB1dGY4PXt2ZXJzaW9uOlwiMi4wLjBcIixlbmNvZGU6dXRmOGVuY29kZSxkZWNvZGU6dXRmOGRlY29kZX07aWYodHlwZW9mIGRlZmluZT09XCJmdW5jdGlvblwiJiZ0eXBlb2YgZGVmaW5lLmFtZD09XCJvYmplY3RcIiYmZGVmaW5lLmFtZCl7ZGVmaW5lKGZ1bmN0aW9uKCl7cmV0dXJuIHV0Zjh9KX1lbHNlIGlmKGZyZWVFeHBvcnRzJiYhZnJlZUV4cG9ydHMubm9kZVR5cGUpe2lmKGZyZWVNb2R1bGUpe2ZyZWVNb2R1bGUuZXhwb3J0cz11dGY4fWVsc2V7dmFyIG9iamVjdD17fTt2YXIgaGFzT3duUHJvcGVydHk9b2JqZWN0Lmhhc093blByb3BlcnR5O2Zvcih2YXIga2V5IGluIHV0Zjgpe2hhc093blByb3BlcnR5LmNhbGwodXRmOCxrZXkpJiYoZnJlZUV4cG9ydHNba2V5XT11dGY4W2tleV0pfX19ZWxzZXtyb290LnV0Zjg9dXRmOH19KSh0aGlzKX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7fV0sMzQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBydmFsaWRjaGFycz0vXltcXF0sOnt9XFxzXSokLzt2YXIgcnZhbGlkZXNjYXBlPS9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7dmFyIHJ2YWxpZHRva2Vucz0vXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7dmFyIHJ2YWxpZGJyYWNlcz0vKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7dmFyIHJ0cmltTGVmdD0vXlxccysvO3ZhciBydHJpbVJpZ2h0PS9cXHMrJC87bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gcGFyc2Vqc29uKGRhdGEpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBkYXRhfHwhZGF0YSl7cmV0dXJuIG51bGx9ZGF0YT1kYXRhLnJlcGxhY2UocnRyaW1MZWZ0LFwiXCIpLnJlcGxhY2UocnRyaW1SaWdodCxcIlwiKTtpZihnbG9iYWwuSlNPTiYmSlNPTi5wYXJzZSl7cmV0dXJuIEpTT04ucGFyc2UoZGF0YSl9aWYocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLFwiQFwiKS5yZXBsYWNlKHJ2YWxpZHRva2VucyxcIl1cIikucmVwbGFjZShydmFsaWRicmFjZXMsXCJcIikpKXtyZXR1cm4gbmV3IEZ1bmN0aW9uKFwicmV0dXJuIFwiK2RhdGEpKCl9fX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7fV0sMzU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe2V4cG9ydHMuZW5jb2RlPWZ1bmN0aW9uKG9iail7dmFyIHN0cj1cIlwiO2Zvcih2YXIgaSBpbiBvYmope2lmKG9iai5oYXNPd25Qcm9wZXJ0eShpKSl7aWYoc3RyLmxlbmd0aClzdHIrPVwiJlwiO3N0cis9ZW5jb2RlVVJJQ29tcG9uZW50KGkpK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pfX1yZXR1cm4gc3RyfTtleHBvcnRzLmRlY29kZT1mdW5jdGlvbihxcyl7dmFyIHFyeT17fTt2YXIgcGFpcnM9cXMuc3BsaXQoXCImXCIpO2Zvcih2YXIgaT0wLGw9cGFpcnMubGVuZ3RoO2k8bDtpKyspe3ZhciBwYWlyPXBhaXJzW2ldLnNwbGl0KFwiPVwiKTtxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXT1kZWNvZGVVUklDb21wb25lbnQocGFpclsxXSl9cmV0dXJuIHFyeX19LHt9XSwzNjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHJlPS9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO3ZhciBwYXJ0cz1bXCJzb3VyY2VcIixcInByb3RvY29sXCIsXCJhdXRob3JpdHlcIixcInVzZXJJbmZvXCIsXCJ1c2VyXCIsXCJwYXNzd29yZFwiLFwiaG9zdFwiLFwicG9ydFwiLFwicmVsYXRpdmVcIixcInBhdGhcIixcImRpcmVjdG9yeVwiLFwiZmlsZVwiLFwicXVlcnlcIixcImFuY2hvclwiXTttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBwYXJzZXVyaShzdHIpe3ZhciBzcmM9c3RyLGI9c3RyLmluZGV4T2YoXCJbXCIpLGU9c3RyLmluZGV4T2YoXCJdXCIpO2lmKGIhPS0xJiZlIT0tMSl7c3RyPXN0ci5zdWJzdHJpbmcoMCxiKStzdHIuc3Vic3RyaW5nKGIsZSkucmVwbGFjZSgvOi9nLFwiO1wiKStzdHIuc3Vic3RyaW5nKGUsc3RyLmxlbmd0aCl9dmFyIG09cmUuZXhlYyhzdHJ8fFwiXCIpLHVyaT17fSxpPTE0O3doaWxlKGktLSl7dXJpW3BhcnRzW2ldXT1tW2ldfHxcIlwifWlmKGIhPS0xJiZlIT0tMSl7dXJpLnNvdXJjZT1zcmM7dXJpLmhvc3Q9dXJpLmhvc3Quc3Vic3RyaW5nKDEsdXJpLmhvc3QubGVuZ3RoLTEpLnJlcGxhY2UoLzsvZyxcIjpcIik7dXJpLmF1dGhvcml0eT11cmkuYXV0aG9yaXR5LnJlcGxhY2UoXCJbXCIsXCJcIikucmVwbGFjZShcIl1cIixcIlwiKS5yZXBsYWNlKC87L2csXCI6XCIpO3VyaS5pcHY2dXJpPXRydWV9cmV0dXJuIHVyaX19LHt9XSwzNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGdsb2JhbD1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3ZhciBXZWJTb2NrZXQ9Z2xvYmFsLldlYlNvY2tldHx8Z2xvYmFsLk1veldlYlNvY2tldDttb2R1bGUuZXhwb3J0cz1XZWJTb2NrZXQ/d3M6bnVsbDtmdW5jdGlvbiB3cyh1cmkscHJvdG9jb2xzLG9wdHMpe3ZhciBpbnN0YW5jZTtpZihwcm90b2NvbHMpe2luc3RhbmNlPW5ldyBXZWJTb2NrZXQodXJpLHByb3RvY29scyl9ZWxzZXtpbnN0YW5jZT1uZXcgV2ViU29ja2V0KHVyaSl9cmV0dXJuIGluc3RhbmNlfWlmKFdlYlNvY2tldCl3cy5wcm90b3R5cGU9V2ViU29ja2V0LnByb3RvdHlwZX0se31dLDM4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgaXNBcnJheT1fZGVyZXFfKFwiaXNhcnJheVwiKTttb2R1bGUuZXhwb3J0cz1oYXNCaW5hcnk7ZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpe2Z1bmN0aW9uIF9oYXNCaW5hcnkob2JqKXtpZighb2JqKXJldHVybiBmYWxzZTtpZihnbG9iYWwuQnVmZmVyJiZnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iail8fGdsb2JhbC5BcnJheUJ1ZmZlciYmb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fGdsb2JhbC5CbG9iJiZvYmogaW5zdGFuY2VvZiBCbG9ifHxnbG9iYWwuRmlsZSYmb2JqIGluc3RhbmNlb2YgRmlsZSl7cmV0dXJuIHRydWV9aWYoaXNBcnJheShvYmopKXtmb3IodmFyIGk9MDtpPG9iai5sZW5ndGg7aSsrKXtpZihfaGFzQmluYXJ5KG9ialtpXSkpe3JldHVybiB0cnVlfX19ZWxzZSBpZihvYmomJlwib2JqZWN0XCI9PXR5cGVvZiBvYmope2lmKG9iai50b0pTT04pe29iaj1vYmoudG9KU09OKCl9Zm9yKHZhciBrZXkgaW4gb2JqKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLGtleSkmJl9oYXNCaW5hcnkob2JqW2tleV0pKXtyZXR1cm4gdHJ1ZX19fXJldHVybiBmYWxzZX1yZXR1cm4gX2hhc0JpbmFyeShkYXRhKX19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se2lzYXJyYXk6Mzl9XSwzOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9X2RlcmVxXygzMil9LHt9XSw0MDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGdsb2JhbD1fZGVyZXFfKFwiZ2xvYmFsXCIpO3RyeXttb2R1bGUuZXhwb3J0cz1cIlhNTEh0dHBSZXF1ZXN0XCJpbiBnbG9iYWwmJlwid2l0aENyZWRlbnRpYWxzXCJpbiBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0fWNhdGNoKGVycil7bW9kdWxlLmV4cG9ydHM9ZmFsc2V9fSx7Z2xvYmFsOjQxfV0sNDE6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCl9LHt9XSw0MjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGluZGV4T2Y9W10uaW5kZXhPZjttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihhcnIsb2JqKXtpZihpbmRleE9mKXJldHVybiBhcnIuaW5kZXhPZihvYmopO2Zvcih2YXIgaT0wO2k8YXJyLmxlbmd0aDsrK2kpe2lmKGFycltpXT09PW9iailyZXR1cm4gaX1yZXR1cm4tMX19LHt9XSw0MzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGhhcz1PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O2V4cG9ydHMua2V5cz1PYmplY3Qua2V5c3x8ZnVuY3Rpb24ob2JqKXt2YXIga2V5cz1bXTtmb3IodmFyIGtleSBpbiBvYmope2lmKGhhcy5jYWxsKG9iaixrZXkpKXtrZXlzLnB1c2goa2V5KX19cmV0dXJuIGtleXN9O2V4cG9ydHMudmFsdWVzPWZ1bmN0aW9uKG9iail7dmFyIHZhbHM9W107Zm9yKHZhciBrZXkgaW4gb2JqKXtpZihoYXMuY2FsbChvYmosa2V5KSl7dmFscy5wdXNoKG9ialtrZXldKX19cmV0dXJuIHZhbHN9O2V4cG9ydHMubWVyZ2U9ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGtleSBpbiBiKXtpZihoYXMuY2FsbChiLGtleSkpe2Fba2V5XT1iW2tleV19fXJldHVybiBhfTtleHBvcnRzLmxlbmd0aD1mdW5jdGlvbihvYmope3JldHVybiBleHBvcnRzLmtleXMob2JqKS5sZW5ndGh9O2V4cG9ydHMuaXNFbXB0eT1mdW5jdGlvbihvYmope3JldHVybiAwPT1leHBvcnRzLmxlbmd0aChvYmopfX0se31dLDQ0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgcmU9L14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87dmFyIHBhcnRzPVtcInNvdXJjZVwiLFwicHJvdG9jb2xcIixcImF1dGhvcml0eVwiLFwidXNlckluZm9cIixcInVzZXJcIixcInBhc3N3b3JkXCIsXCJob3N0XCIsXCJwb3J0XCIsXCJyZWxhdGl2ZVwiLFwicGF0aFwiLFwiZGlyZWN0b3J5XCIsXCJmaWxlXCIsXCJxdWVyeVwiLFwiYW5jaG9yXCJdO21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIHBhcnNldXJpKHN0cil7dmFyIG09cmUuZXhlYyhzdHJ8fFwiXCIpLHVyaT17fSxpPTE0O3doaWxlKGktLSl7dXJpW3BhcnRzW2ldXT1tW2ldfHxcIlwifXJldHVybiB1cml9fSx7fV0sNDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBpc0FycmF5PV9kZXJlcV8oXCJpc2FycmF5XCIpO3ZhciBpc0J1Zj1fZGVyZXFfKFwiLi9pcy1idWZmZXJcIik7ZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldD1mdW5jdGlvbihwYWNrZXQpe3ZhciBidWZmZXJzPVtdO3ZhciBwYWNrZXREYXRhPXBhY2tldC5kYXRhO2Z1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKXtpZighZGF0YSlyZXR1cm4gZGF0YTtpZihpc0J1ZihkYXRhKSl7dmFyIHBsYWNlaG9sZGVyPXtfcGxhY2Vob2xkZXI6dHJ1ZSxudW06YnVmZmVycy5sZW5ndGh9O2J1ZmZlcnMucHVzaChkYXRhKTtyZXR1cm4gcGxhY2Vob2xkZXJ9ZWxzZSBpZihpc0FycmF5KGRhdGEpKXt2YXIgbmV3RGF0YT1uZXcgQXJyYXkoZGF0YS5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8ZGF0YS5sZW5ndGg7aSsrKXtuZXdEYXRhW2ldPV9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldKX1yZXR1cm4gbmV3RGF0YX1lbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBkYXRhJiYhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSl7dmFyIG5ld0RhdGE9e307Zm9yKHZhciBrZXkgaW4gZGF0YSl7bmV3RGF0YVtrZXldPV9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pfXJldHVybiBuZXdEYXRhfXJldHVybiBkYXRhfXZhciBwYWNrPXBhY2tldDtwYWNrLmRhdGE9X2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEpO3BhY2suYXR0YWNobWVudHM9YnVmZmVycy5sZW5ndGg7cmV0dXJue3BhY2tldDpwYWNrLGJ1ZmZlcnM6YnVmZmVyc319O2V4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQ9ZnVuY3Rpb24ocGFja2V0LGJ1ZmZlcnMpe3ZhciBjdXJQbGFjZUhvbGRlcj0wO2Z1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKXtpZihkYXRhJiZkYXRhLl9wbGFjZWhvbGRlcil7dmFyIGJ1Zj1idWZmZXJzW2RhdGEubnVtXTtyZXR1cm4gYnVmfWVsc2UgaWYoaXNBcnJheShkYXRhKSl7Zm9yKHZhciBpPTA7aTxkYXRhLmxlbmd0aDtpKyspe2RhdGFbaV09X3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pfXJldHVybiBkYXRhfWVsc2UgaWYoZGF0YSYmXCJvYmplY3RcIj09dHlwZW9mIGRhdGEpe2Zvcih2YXIga2V5IGluIGRhdGEpe2RhdGFba2V5XT1fcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKX1yZXR1cm4gZGF0YX1yZXR1cm4gZGF0YX1wYWNrZXQuZGF0YT1fcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO3BhY2tldC5hdHRhY2htZW50cz11bmRlZmluZWQ7cmV0dXJuIHBhY2tldH07ZXhwb3J0cy5yZW1vdmVCbG9icz1mdW5jdGlvbihkYXRhLGNhbGxiYWNrKXtmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLGN1cktleSxjb250YWluaW5nT2JqZWN0KXtpZighb2JqKXJldHVybiBvYmo7aWYoZ2xvYmFsLkJsb2ImJm9iaiBpbnN0YW5jZW9mIEJsb2J8fGdsb2JhbC5GaWxlJiZvYmogaW5zdGFuY2VvZiBGaWxlKXtwZW5kaW5nQmxvYnMrKzt2YXIgZmlsZVJlYWRlcj1uZXcgRmlsZVJlYWRlcjtmaWxlUmVhZGVyLm9ubG9hZD1mdW5jdGlvbigpe2lmKGNvbnRhaW5pbmdPYmplY3Qpe2NvbnRhaW5pbmdPYmplY3RbY3VyS2V5XT10aGlzLnJlc3VsdH1lbHNle2Jsb2JsZXNzRGF0YT10aGlzLnJlc3VsdH1pZighLS1wZW5kaW5nQmxvYnMpe2NhbGxiYWNrKGJsb2JsZXNzRGF0YSl9fTtmaWxlUmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKG9iail9ZWxzZSBpZihpc0FycmF5KG9iaikpe2Zvcih2YXIgaT0wO2k8b2JqLmxlbmd0aDtpKyspe19yZW1vdmVCbG9icyhvYmpbaV0saSxvYmopfX1lbHNlIGlmKG9iaiYmXCJvYmplY3RcIj09dHlwZW9mIG9iaiYmIWlzQnVmKG9iaikpe2Zvcih2YXIga2V5IGluIG9iail7X3JlbW92ZUJsb2JzKG9ialtrZXldLGtleSxvYmopfX19dmFyIHBlbmRpbmdCbG9icz0wO3ZhciBibG9ibGVzc0RhdGE9ZGF0YTtfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtpZighcGVuZGluZ0Jsb2JzKXtjYWxsYmFjayhibG9ibGVzc0RhdGEpfX19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se1wiLi9pcy1idWZmZXJcIjo0Nyxpc2FycmF5OjQ4fV0sNDY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO3ZhciBqc29uPV9kZXJlcV8oXCJqc29uM1wiKTt2YXIgaXNBcnJheT1fZGVyZXFfKFwiaXNhcnJheVwiKTt2YXIgRW1pdHRlcj1fZGVyZXFfKFwiY29tcG9uZW50LWVtaXR0ZXJcIik7dmFyIGJpbmFyeT1fZGVyZXFfKFwiLi9iaW5hcnlcIik7dmFyIGlzQnVmPV9kZXJlcV8oXCIuL2lzLWJ1ZmZlclwiKTtleHBvcnRzLnByb3RvY29sPTQ7ZXhwb3J0cy50eXBlcz1bXCJDT05ORUNUXCIsXCJESVNDT05ORUNUXCIsXCJFVkVOVFwiLFwiQklOQVJZX0VWRU5UXCIsXCJBQ0tcIixcIkJJTkFSWV9BQ0tcIixcIkVSUk9SXCJdO2V4cG9ydHMuQ09OTkVDVD0wO2V4cG9ydHMuRElTQ09OTkVDVD0xO2V4cG9ydHMuRVZFTlQ9MjtleHBvcnRzLkFDSz0zO2V4cG9ydHMuRVJST1I9NDtleHBvcnRzLkJJTkFSWV9FVkVOVD01O2V4cG9ydHMuQklOQVJZX0FDSz02O2V4cG9ydHMuRW5jb2Rlcj1FbmNvZGVyO2V4cG9ydHMuRGVjb2Rlcj1EZWNvZGVyO2Z1bmN0aW9uIEVuY29kZXIoKXt9RW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlPWZ1bmN0aW9uKG9iaixjYWxsYmFjayl7ZGVidWcoXCJlbmNvZGluZyBwYWNrZXQgJWpcIixvYmopO2lmKGV4cG9ydHMuQklOQVJZX0VWRU5UPT1vYmoudHlwZXx8ZXhwb3J0cy5CSU5BUllfQUNLPT1vYmoudHlwZSl7ZW5jb2RlQXNCaW5hcnkob2JqLGNhbGxiYWNrKX1lbHNle3ZhciBlbmNvZGluZz1lbmNvZGVBc1N0cmluZyhvYmopO2NhbGxiYWNrKFtlbmNvZGluZ10pfX07ZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKXt2YXIgc3RyPVwiXCI7dmFyIG5zcD1mYWxzZTtzdHIrPW9iai50eXBlO2lmKGV4cG9ydHMuQklOQVJZX0VWRU5UPT1vYmoudHlwZXx8ZXhwb3J0cy5CSU5BUllfQUNLPT1vYmoudHlwZSl7c3RyKz1vYmouYXR0YWNobWVudHM7c3RyKz1cIi1cIn1pZihvYmoubnNwJiZcIi9cIiE9b2JqLm5zcCl7bnNwPXRydWU7c3RyKz1vYmoubnNwfWlmKG51bGwhPW9iai5pZCl7aWYobnNwKXtzdHIrPVwiLFwiO25zcD1mYWxzZX1zdHIrPW9iai5pZH1pZihudWxsIT1vYmouZGF0YSl7aWYobnNwKXN0cis9XCIsXCI7c3RyKz1qc29uLnN0cmluZ2lmeShvYmouZGF0YSl9ZGVidWcoXCJlbmNvZGVkICVqIGFzICVzXCIsb2JqLHN0cik7cmV0dXJuIHN0cn1mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosY2FsbGJhY2spe2Z1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKXt2YXIgZGVjb25zdHJ1Y3Rpb249YmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7dmFyIHBhY2s9ZW5jb2RlQXNTdHJpbmcoZGVjb25zdHJ1Y3Rpb24ucGFja2V0KTt2YXIgYnVmZmVycz1kZWNvbnN0cnVjdGlvbi5idWZmZXJzO2J1ZmZlcnMudW5zaGlmdChwYWNrKTtjYWxsYmFjayhidWZmZXJzKX1iaW5hcnkucmVtb3ZlQmxvYnMob2JqLHdyaXRlRW5jb2RpbmcpfWZ1bmN0aW9uIERlY29kZXIoKXt0aGlzLnJlY29uc3RydWN0b3I9bnVsbH1FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtEZWNvZGVyLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24ob2JqKXt2YXIgcGFja2V0O2lmKFwic3RyaW5nXCI9PXR5cGVvZiBvYmope3BhY2tldD1kZWNvZGVTdHJpbmcob2JqKTtpZihleHBvcnRzLkJJTkFSWV9FVkVOVD09cGFja2V0LnR5cGV8fGV4cG9ydHMuQklOQVJZX0FDSz09cGFja2V0LnR5cGUpe3RoaXMucmVjb25zdHJ1Y3Rvcj1uZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO2lmKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHM9PT0wKXt0aGlzLmVtaXQoXCJkZWNvZGVkXCIscGFja2V0KX19ZWxzZXt0aGlzLmVtaXQoXCJkZWNvZGVkXCIscGFja2V0KX19ZWxzZSBpZihpc0J1ZihvYmopfHxvYmouYmFzZTY0KXtpZighdGhpcy5yZWNvbnN0cnVjdG9yKXt0aHJvdyBuZXcgRXJyb3IoXCJnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXRcIil9ZWxzZXtwYWNrZXQ9dGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7aWYocGFja2V0KXt0aGlzLnJlY29uc3RydWN0b3I9bnVsbDt0aGlzLmVtaXQoXCJkZWNvZGVkXCIscGFja2V0KX19fWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlOiBcIitvYmopfX07ZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cil7dmFyIHA9e307dmFyIGk9MDtwLnR5cGU9TnVtYmVyKHN0ci5jaGFyQXQoMCkpO2lmKG51bGw9PWV4cG9ydHMudHlwZXNbcC50eXBlXSlyZXR1cm4gZXJyb3IoKTtpZihleHBvcnRzLkJJTkFSWV9FVkVOVD09cC50eXBlfHxleHBvcnRzLkJJTkFSWV9BQ0s9PXAudHlwZSl7dmFyIGJ1Zj1cIlwiO3doaWxlKHN0ci5jaGFyQXQoKytpKSE9XCItXCIpe2J1Zis9c3RyLmNoYXJBdChpKTtpZihpKzE9PXN0ci5sZW5ndGgpYnJlYWt9aWYoYnVmIT1OdW1iZXIoYnVmKXx8c3RyLmNoYXJBdChpKSE9XCItXCIpe3Rocm93IG5ldyBFcnJvcihcIklsbGVnYWwgYXR0YWNobWVudHNcIil9cC5hdHRhY2htZW50cz1OdW1iZXIoYnVmKX1pZihcIi9cIj09c3RyLmNoYXJBdChpKzEpKXtwLm5zcD1cIlwiO3doaWxlKCsraSl7dmFyIGM9c3RyLmNoYXJBdChpKTtpZihcIixcIj09YylicmVhaztwLm5zcCs9YztpZihpKzE9PXN0ci5sZW5ndGgpYnJlYWt9fWVsc2V7cC5uc3A9XCIvXCJ9dmFyIG5leHQ9c3RyLmNoYXJBdChpKzEpO2lmKFwiXCIhPT1uZXh0JiZOdW1iZXIobmV4dCk9PW5leHQpe3AuaWQ9XCJcIjt3aGlsZSgrK2kpe3ZhciBjPXN0ci5jaGFyQXQoaSk7aWYobnVsbD09Y3x8TnVtYmVyKGMpIT1jKXstLWk7YnJlYWt9cC5pZCs9c3RyLmNoYXJBdChpKTtpZihpKzE9PXN0ci5sZW5ndGgpYnJlYWt9cC5pZD1OdW1iZXIocC5pZCl9aWYoc3RyLmNoYXJBdCgrK2kpKXt0cnl7cC5kYXRhPWpzb24ucGFyc2Uoc3RyLnN1YnN0cihpKSl9Y2F0Y2goZSl7cmV0dXJuIGVycm9yKCl9fWRlYnVnKFwiZGVjb2RlZCAlcyBhcyAlalwiLHN0cixwKTtyZXR1cm4gcH1EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95PWZ1bmN0aW9uKCl7aWYodGhpcy5yZWNvbnN0cnVjdG9yKXt0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpfX07ZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpe3RoaXMucmVjb25QYWNrPXBhY2tldDt0aGlzLmJ1ZmZlcnM9W119QmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGE9ZnVuY3Rpb24oYmluRGF0YSl7dGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7aWYodGhpcy5idWZmZXJzLmxlbmd0aD09dGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpe3ZhciBwYWNrZXQ9YmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLHRoaXMuYnVmZmVycyk7dGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7cmV0dXJuIHBhY2tldH1yZXR1cm4gbnVsbH07QmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbj1mdW5jdGlvbigpe3RoaXMucmVjb25QYWNrPW51bGw7dGhpcy5idWZmZXJzPVtdfTtmdW5jdGlvbiBlcnJvcihkYXRhKXtyZXR1cm57dHlwZTpleHBvcnRzLkVSUk9SLGRhdGE6XCJwYXJzZXIgZXJyb3JcIn19fSx7XCIuL2JpbmFyeVwiOjQ1LFwiLi9pcy1idWZmZXJcIjo0NyxcImNvbXBvbmVudC1lbWl0dGVyXCI6OSxkZWJ1ZzoxMCxpc2FycmF5OjQ4LGpzb24zOjQ5fV0sNDc6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe21vZHVsZS5leHBvcnRzPWlzQnVmO2Z1bmN0aW9uIGlzQnVmKG9iail7cmV0dXJuIGdsb2JhbC5CdWZmZXImJmdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKXx8Z2xvYmFsLkFycmF5QnVmZmVyJiZvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcn19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se31dLDQ4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1fZGVyZXFfKDMyKX0se31dLDQ5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24od2luZG93KXt2YXIgZ2V0Q2xhc3M9e30udG9TdHJpbmcsaXNQcm9wZXJ0eSxmb3JFYWNoLHVuZGVmO3ZhciBpc0xvYWRlcj10eXBlb2YgZGVmaW5lPT09XCJmdW5jdGlvblwiJiZkZWZpbmUuYW1kO3ZhciBuYXRpdmVKU09OPXR5cGVvZiBKU09OPT1cIm9iamVjdFwiJiZKU09OO3ZhciBKU09OMz10eXBlb2YgZXhwb3J0cz09XCJvYmplY3RcIiYmZXhwb3J0cyYmIWV4cG9ydHMubm9kZVR5cGUmJmV4cG9ydHM7aWYoSlNPTjMmJm5hdGl2ZUpTT04pe0pTT04zLnN0cmluZ2lmeT1uYXRpdmVKU09OLnN0cmluZ2lmeTtKU09OMy5wYXJzZT1uYXRpdmVKU09OLnBhcnNlfWVsc2V7SlNPTjM9d2luZG93LkpTT049bmF0aXZlSlNPTnx8e319dmFyIGlzRXh0ZW5kZWQ9bmV3IERhdGUoLTB4Yzc4MmI1YjgwMGNlYyk7dHJ5e2lzRXh0ZW5kZWQ9aXNFeHRlbmRlZC5nZXRVVENGdWxsWWVhcigpPT0tMTA5MjUyJiZpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCk9PT0wJiZpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKT09PTEmJmlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKT09MTAmJmlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpPT0zNyYmaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCk9PTYmJmlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCk9PTcwOH1jYXRjaChleGNlcHRpb24pe31mdW5jdGlvbiBoYXMobmFtZSl7aWYoaGFzW25hbWVdIT09dW5kZWYpe3JldHVybiBoYXNbbmFtZV19dmFyIGlzU3VwcG9ydGVkO2lmKG5hbWU9PVwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpe2lzU3VwcG9ydGVkPVwiYVwiWzBdIT1cImFcIn1lbHNlIGlmKG5hbWU9PVwianNvblwiKXtpc1N1cHBvcnRlZD1oYXMoXCJqc29uLXN0cmluZ2lmeVwiKSYmaGFzKFwianNvbi1wYXJzZVwiKX1lbHNle3ZhciB2YWx1ZSxzZXJpYWxpemVkPSd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO2lmKG5hbWU9PVwianNvbi1zdHJpbmdpZnlcIil7dmFyIHN0cmluZ2lmeT1KU09OMy5zdHJpbmdpZnksc3RyaW5naWZ5U3VwcG9ydGVkPXR5cGVvZiBzdHJpbmdpZnk9PVwiZnVuY3Rpb25cIiYmaXNFeHRlbmRlZDtpZihzdHJpbmdpZnlTdXBwb3J0ZWQpeyh2YWx1ZT1mdW5jdGlvbigpe3JldHVybiAxfSkudG9KU09OPXZhbHVlO3RyeXtzdHJpbmdpZnlTdXBwb3J0ZWQ9c3RyaW5naWZ5KDApPT09XCIwXCImJnN0cmluZ2lmeShuZXcgTnVtYmVyKT09PVwiMFwiJiZzdHJpbmdpZnkobmV3IFN0cmluZyk9PSdcIlwiJyYmc3RyaW5naWZ5KGdldENsYXNzKT09PXVuZGVmJiZzdHJpbmdpZnkodW5kZWYpPT09dW5kZWYmJnN0cmluZ2lmeSgpPT09dW5kZWYmJnN0cmluZ2lmeSh2YWx1ZSk9PT1cIjFcIiYmc3RyaW5naWZ5KFt2YWx1ZV0pPT1cIlsxXVwiJiZzdHJpbmdpZnkoW3VuZGVmXSk9PVwiW251bGxdXCImJnN0cmluZ2lmeShudWxsKT09XCJudWxsXCImJnN0cmluZ2lmeShbdW5kZWYsZ2V0Q2xhc3MsbnVsbF0pPT1cIltudWxsLG51bGwsbnVsbF1cIiYmc3RyaW5naWZ5KHthOlt2YWx1ZSx0cnVlLGZhbHNlLG51bGwsXCJcXHgwMFxcYlxcblxcZlxcciBcIl19KT09c2VyaWFsaXplZCYmc3RyaW5naWZ5KG51bGwsdmFsdWUpPT09XCIxXCImJnN0cmluZ2lmeShbMSwyXSxudWxsLDEpPT1cIltcXG4gMSxcXG4gMlxcbl1cIiYmc3RyaW5naWZ5KG5ldyBEYXRlKC04NjRlMTMpKT09J1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInJiZzdHJpbmdpZnkobmV3IERhdGUoODY0ZTEzKSk9PSdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyYmc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpPT0nXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicmJnN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpPT0nXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIid9Y2F0Y2goZXhjZXB0aW9uKXtzdHJpbmdpZnlTdXBwb3J0ZWQ9ZmFsc2V9fWlzU3VwcG9ydGVkPXN0cmluZ2lmeVN1cHBvcnRlZH1pZihuYW1lPT1cImpzb24tcGFyc2VcIil7dmFyIHBhcnNlPUpTT04zLnBhcnNlO2lmKHR5cGVvZiBwYXJzZT09XCJmdW5jdGlvblwiKXt0cnl7aWYocGFyc2UoXCIwXCIpPT09MCYmIXBhcnNlKGZhbHNlKSl7dmFsdWU9cGFyc2Uoc2VyaWFsaXplZCk7dmFyIHBhcnNlU3VwcG9ydGVkPXZhbHVlW1wiYVwiXS5sZW5ndGg9PTUmJnZhbHVlW1wiYVwiXVswXT09PTE7aWYocGFyc2VTdXBwb3J0ZWQpe3RyeXtwYXJzZVN1cHBvcnRlZD0hcGFyc2UoJ1wiICBcIicpfWNhdGNoKGV4Y2VwdGlvbil7fWlmKHBhcnNlU3VwcG9ydGVkKXt0cnl7cGFyc2VTdXBwb3J0ZWQ9cGFyc2UoXCIwMVwiKSE9PTF9Y2F0Y2goZXhjZXB0aW9uKXt9fWlmKHBhcnNlU3VwcG9ydGVkKXt0cnl7cGFyc2VTdXBwb3J0ZWQ9cGFyc2UoXCIxLlwiKSE9PTF9Y2F0Y2goZXhjZXB0aW9uKXt9fX19fWNhdGNoKGV4Y2VwdGlvbil7cGFyc2VTdXBwb3J0ZWQ9ZmFsc2V9fWlzU3VwcG9ydGVkPXBhcnNlU3VwcG9ydGVkfX1yZXR1cm4gaGFzW25hbWVdPSEhaXNTdXBwb3J0ZWR9aWYoIWhhcyhcImpzb25cIikpe3ZhciBmdW5jdGlvbkNsYXNzPVwiW29iamVjdCBGdW5jdGlvbl1cIjt2YXIgZGF0ZUNsYXNzPVwiW29iamVjdCBEYXRlXVwiO3ZhciBudW1iZXJDbGFzcz1cIltvYmplY3QgTnVtYmVyXVwiO3ZhciBzdHJpbmdDbGFzcz1cIltvYmplY3QgU3RyaW5nXVwiO3ZhciBhcnJheUNsYXNzPVwiW29iamVjdCBBcnJheV1cIjt2YXIgYm9vbGVhbkNsYXNzPVwiW29iamVjdCBCb29sZWFuXVwiO3ZhciBjaGFySW5kZXhCdWdneT1oYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7aWYoIWlzRXh0ZW5kZWQpe3ZhciBmbG9vcj1NYXRoLmZsb29yO3ZhciBNb250aHM9WzAsMzEsNTksOTAsMTIwLDE1MSwxODEsMjEyLDI0MywyNzMsMzA0LDMzNF07dmFyIGdldERheT1mdW5jdGlvbih5ZWFyLG1vbnRoKXtyZXR1cm4gTW9udGhzW21vbnRoXSszNjUqKHllYXItMTk3MCkrZmxvb3IoKHllYXItMTk2OSsobW9udGg9Kyhtb250aD4xKSkpLzQpLWZsb29yKCh5ZWFyLTE5MDErbW9udGgpLzEwMCkrZmxvb3IoKHllYXItMTYwMSttb250aCkvNDAwKX19aWYoIShpc1Byb3BlcnR5PXt9Lmhhc093blByb3BlcnR5KSl7aXNQcm9wZXJ0eT1mdW5jdGlvbihwcm9wZXJ0eSl7dmFyIG1lbWJlcnM9e30sY29uc3RydWN0b3I7aWYoKG1lbWJlcnMuX19wcm90b19fPW51bGwsbWVtYmVycy5fX3Byb3RvX189e3RvU3RyaW5nOjF9LG1lbWJlcnMpLnRvU3RyaW5nIT1nZXRDbGFzcyl7aXNQcm9wZXJ0eT1mdW5jdGlvbihwcm9wZXJ0eSl7dmFyIG9yaWdpbmFsPXRoaXMuX19wcm90b19fLHJlc3VsdD1wcm9wZXJ0eSBpbih0aGlzLl9fcHJvdG9fXz1udWxsLHRoaXMpO3RoaXMuX19wcm90b19fPW9yaWdpbmFsO3JldHVybiByZXN1bHR9fWVsc2V7Y29uc3RydWN0b3I9bWVtYmVycy5jb25zdHJ1Y3Rvcjtpc1Byb3BlcnR5PWZ1bmN0aW9uKHByb3BlcnR5KXt2YXIgcGFyZW50PSh0aGlzLmNvbnN0cnVjdG9yfHxjb25zdHJ1Y3RvcikucHJvdG90eXBlO3JldHVybiBwcm9wZXJ0eSBpbiB0aGlzJiYhKHByb3BlcnR5IGluIHBhcmVudCYmdGhpc1twcm9wZXJ0eV09PT1wYXJlbnRbcHJvcGVydHldKX19bWVtYmVycz1udWxsO3JldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcyxwcm9wZXJ0eSl9fXZhciBQcmltaXRpdmVUeXBlcz17XCJib29sZWFuXCI6MSxudW1iZXI6MSxzdHJpbmc6MSx1bmRlZmluZWQ6MX07dmFyIGlzSG9zdFR5cGU9ZnVuY3Rpb24ob2JqZWN0LHByb3BlcnR5KXt2YXIgdHlwZT10eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XTtyZXR1cm4gdHlwZT09XCJvYmplY3RcIj8hIW9iamVjdFtwcm9wZXJ0eV06IVByaW1pdGl2ZVR5cGVzW3R5cGVdfTtmb3JFYWNoPWZ1bmN0aW9uKG9iamVjdCxjYWxsYmFjayl7dmFyIHNpemU9MCxQcm9wZXJ0aWVzLG1lbWJlcnMscHJvcGVydHk7KFByb3BlcnRpZXM9ZnVuY3Rpb24oKXt0aGlzLnZhbHVlT2Y9MH0pLnByb3RvdHlwZS52YWx1ZU9mPTA7bWVtYmVycz1uZXcgUHJvcGVydGllcztmb3IocHJvcGVydHkgaW4gbWVtYmVycyl7aWYoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMscHJvcGVydHkpKXtzaXplKyt9fVByb3BlcnRpZXM9bWVtYmVycz1udWxsO2lmKCFzaXplKXttZW1iZXJzPVtcInZhbHVlT2ZcIixcInRvU3RyaW5nXCIsXCJ0b0xvY2FsZVN0cmluZ1wiLFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcImlzUHJvdG90eXBlT2ZcIixcImhhc093blByb3BlcnR5XCIsXCJjb25zdHJ1Y3RvclwiXTtmb3JFYWNoPWZ1bmN0aW9uKG9iamVjdCxjYWxsYmFjayl7dmFyIGlzRnVuY3Rpb249Z2V0Q2xhc3MuY2FsbChvYmplY3QpPT1mdW5jdGlvbkNsYXNzLHByb3BlcnR5LGxlbmd0aDt2YXIgaGFzUHJvcGVydHk9IWlzRnVuY3Rpb24mJnR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IhPVwiZnVuY3Rpb25cIiYmaXNIb3N0VHlwZShvYmplY3QsXCJoYXNPd25Qcm9wZXJ0eVwiKT9vYmplY3QuaGFzT3duUHJvcGVydHk6aXNQcm9wZXJ0eTtmb3IocHJvcGVydHkgaW4gb2JqZWN0KXtpZighKGlzRnVuY3Rpb24mJnByb3BlcnR5PT1cInByb3RvdHlwZVwiKSYmaGFzUHJvcGVydHkuY2FsbChvYmplY3QscHJvcGVydHkpKXtjYWxsYmFjayhwcm9wZXJ0eSl9fWZvcihsZW5ndGg9bWVtYmVycy5sZW5ndGg7cHJvcGVydHk9bWVtYmVyc1stLWxlbmd0aF07aGFzUHJvcGVydHkuY2FsbChvYmplY3QscHJvcGVydHkpJiZjYWxsYmFjayhwcm9wZXJ0eSkpO319ZWxzZSBpZihzaXplPT0yKXtmb3JFYWNoPWZ1bmN0aW9uKG9iamVjdCxjYWxsYmFjayl7dmFyIG1lbWJlcnM9e30saXNGdW5jdGlvbj1nZXRDbGFzcy5jYWxsKG9iamVjdCk9PWZ1bmN0aW9uQ2xhc3MscHJvcGVydHk7Zm9yKHByb3BlcnR5IGluIG9iamVjdCl7aWYoIShpc0Z1bmN0aW9uJiZwcm9wZXJ0eT09XCJwcm90b3R5cGVcIikmJiFpc1Byb3BlcnR5LmNhbGwobWVtYmVycyxwcm9wZXJ0eSkmJihtZW1iZXJzW3Byb3BlcnR5XT0xKSYmaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCxwcm9wZXJ0eSkpe2NhbGxiYWNrKHByb3BlcnR5KX19fX1lbHNle2ZvckVhY2g9ZnVuY3Rpb24ob2JqZWN0LGNhbGxiYWNrKXt2YXIgaXNGdW5jdGlvbj1nZXRDbGFzcy5jYWxsKG9iamVjdCk9PWZ1bmN0aW9uQ2xhc3MscHJvcGVydHksaXNDb25zdHJ1Y3Rvcjtmb3IocHJvcGVydHkgaW4gb2JqZWN0KXtpZighKGlzRnVuY3Rpb24mJnByb3BlcnR5PT1cInByb3RvdHlwZVwiKSYmaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCxwcm9wZXJ0eSkmJiEoaXNDb25zdHJ1Y3Rvcj1wcm9wZXJ0eT09PVwiY29uc3RydWN0b3JcIikpe2NhbGxiYWNrKHByb3BlcnR5KX19aWYoaXNDb25zdHJ1Y3Rvcnx8aXNQcm9wZXJ0eS5jYWxsKG9iamVjdCxwcm9wZXJ0eT1cImNvbnN0cnVjdG9yXCIpKXtjYWxsYmFjayhwcm9wZXJ0eSl9fX1yZXR1cm4gZm9yRWFjaChvYmplY3QsY2FsbGJhY2spfTtpZighaGFzKFwianNvbi1zdHJpbmdpZnlcIikpe3ZhciBFc2NhcGVzPXs5MjpcIlxcXFxcXFxcXCIsMzQ6J1xcXFxcIicsODpcIlxcXFxiXCIsMTI6XCJcXFxcZlwiLDEwOlwiXFxcXG5cIiwxMzpcIlxcXFxyXCIsOTpcIlxcXFx0XCJ9O3ZhciBsZWFkaW5nWmVyb2VzPVwiMDAwMDAwXCI7dmFyIHRvUGFkZGVkU3RyaW5nPWZ1bmN0aW9uKHdpZHRoLHZhbHVlKXtyZXR1cm4obGVhZGluZ1plcm9lcysodmFsdWV8fDApKS5zbGljZSgtd2lkdGgpfTt2YXIgdW5pY29kZVByZWZpeD1cIlxcXFx1MDBcIjt2YXIgcXVvdGU9ZnVuY3Rpb24odmFsdWUpe3ZhciByZXN1bHQ9J1wiJyxpbmRleD0wLGxlbmd0aD12YWx1ZS5sZW5ndGgsaXNMYXJnZT1sZW5ndGg+MTAmJmNoYXJJbmRleEJ1Z2d5LHN5bWJvbHM7aWYoaXNMYXJnZSl7c3ltYm9scz12YWx1ZS5zcGxpdChcIlwiKX1mb3IoO2luZGV4PGxlbmd0aDtpbmRleCsrKXt2YXIgY2hhckNvZGU9dmFsdWUuY2hhckNvZGVBdChpbmRleCk7c3dpdGNoKGNoYXJDb2RlKXtjYXNlIDg6Y2FzZSA5OmNhc2UgMTA6Y2FzZSAxMjpjYXNlIDEzOmNhc2UgMzQ6Y2FzZSA5MjpyZXN1bHQrPUVzY2FwZXNbY2hhckNvZGVdO2JyZWFrO2RlZmF1bHQ6aWYoY2hhckNvZGU8MzIpe3Jlc3VsdCs9dW5pY29kZVByZWZpeCt0b1BhZGRlZFN0cmluZygyLGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7YnJlYWt9cmVzdWx0Kz1pc0xhcmdlP3N5bWJvbHNbaW5kZXhdOmNoYXJJbmRleEJ1Z2d5P3ZhbHVlLmNoYXJBdChpbmRleCk6dmFsdWVbaW5kZXhdfX1yZXR1cm4gcmVzdWx0KydcIid9O3ZhciBzZXJpYWxpemU9ZnVuY3Rpb24ocHJvcGVydHksb2JqZWN0LGNhbGxiYWNrLHByb3BlcnRpZXMsd2hpdGVzcGFjZSxpbmRlbnRhdGlvbixzdGFjayl7dmFyIHZhbHVlLGNsYXNzTmFtZSx5ZWFyLG1vbnRoLGRhdGUsdGltZSxob3VycyxtaW51dGVzLHNlY29uZHMsbWlsbGlzZWNvbmRzLHJlc3VsdHMsZWxlbWVudCxpbmRleCxsZW5ndGgscHJlZml4LHJlc3VsdDt0cnl7dmFsdWU9b2JqZWN0W3Byb3BlcnR5XX1jYXRjaChleGNlcHRpb24pe31pZih0eXBlb2YgdmFsdWU9PVwib2JqZWN0XCImJnZhbHVlKXtjbGFzc05hbWU9Z2V0Q2xhc3MuY2FsbCh2YWx1ZSk7aWYoY2xhc3NOYW1lPT1kYXRlQ2xhc3MmJiFpc1Byb3BlcnR5LmNhbGwodmFsdWUsXCJ0b0pTT05cIikpe2lmKHZhbHVlPi0xLzAmJnZhbHVlPDEvMCl7aWYoZ2V0RGF5KXtkYXRlPWZsb29yKHZhbHVlLzg2NGU1KTtmb3IoeWVhcj1mbG9vcihkYXRlLzM2NS4yNDI1KSsxOTcwLTE7Z2V0RGF5KHllYXIrMSwwKTw9ZGF0ZTt5ZWFyKyspO2Zvcihtb250aD1mbG9vcigoZGF0ZS1nZXREYXkoeWVhciwwKSkvMzAuNDIpO2dldERheSh5ZWFyLG1vbnRoKzEpPD1kYXRlO21vbnRoKyspO2RhdGU9MStkYXRlLWdldERheSh5ZWFyLG1vbnRoKTt0aW1lPSh2YWx1ZSU4NjRlNSs4NjRlNSklODY0ZTU7aG91cnM9Zmxvb3IodGltZS8zNmU1KSUyNDttaW51dGVzPWZsb29yKHRpbWUvNmU0KSU2MDtzZWNvbmRzPWZsb29yKHRpbWUvMWUzKSU2MDttaWxsaXNlY29uZHM9dGltZSUxZTN9ZWxzZXt5ZWFyPXZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7bW9udGg9dmFsdWUuZ2V0VVRDTW9udGgoKTtkYXRlPXZhbHVlLmdldFVUQ0RhdGUoKTtob3Vycz12YWx1ZS5nZXRVVENIb3VycygpO21pbnV0ZXM9dmFsdWUuZ2V0VVRDTWludXRlcygpO3NlY29uZHM9dmFsdWUuZ2V0VVRDU2Vjb25kcygpO21pbGxpc2Vjb25kcz12YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKX12YWx1ZT0oeWVhcjw9MHx8eWVhcj49MWU0Pyh5ZWFyPDA/XCItXCI6XCIrXCIpK3RvUGFkZGVkU3RyaW5nKDYseWVhcjwwPy15ZWFyOnllYXIpOnRvUGFkZGVkU3RyaW5nKDQseWVhcikpK1wiLVwiK3RvUGFkZGVkU3RyaW5nKDIsbW9udGgrMSkrXCItXCIrdG9QYWRkZWRTdHJpbmcoMixkYXRlKStcIlRcIit0b1BhZGRlZFN0cmluZygyLGhvdXJzKStcIjpcIit0b1BhZGRlZFN0cmluZygyLG1pbnV0ZXMpK1wiOlwiK3RvUGFkZGVkU3RyaW5nKDIsc2Vjb25kcykrXCIuXCIrdG9QYWRkZWRTdHJpbmcoMyxtaWxsaXNlY29uZHMpK1wiWlwifWVsc2V7dmFsdWU9bnVsbH19ZWxzZSBpZih0eXBlb2YgdmFsdWUudG9KU09OPT1cImZ1bmN0aW9uXCImJihjbGFzc05hbWUhPW51bWJlckNsYXNzJiZjbGFzc05hbWUhPXN0cmluZ0NsYXNzJiZjbGFzc05hbWUhPWFycmF5Q2xhc3N8fGlzUHJvcGVydHkuY2FsbCh2YWx1ZSxcInRvSlNPTlwiKSkpe3ZhbHVlPXZhbHVlLnRvSlNPTihwcm9wZXJ0eSl9fWlmKGNhbGxiYWNrKXt2YWx1ZT1jYWxsYmFjay5jYWxsKG9iamVjdCxwcm9wZXJ0eSx2YWx1ZSl9aWYodmFsdWU9PT1udWxsKXtyZXR1cm5cIm51bGxcIn1jbGFzc05hbWU9Z2V0Q2xhc3MuY2FsbCh2YWx1ZSk7aWYoY2xhc3NOYW1lPT1ib29sZWFuQ2xhc3Mpe3JldHVyblwiXCIrdmFsdWV9ZWxzZSBpZihjbGFzc05hbWU9PW51bWJlckNsYXNzKXtyZXR1cm4gdmFsdWU+LTEvMCYmdmFsdWU8MS8wP1wiXCIrdmFsdWU6XCJudWxsXCJ9ZWxzZSBpZihjbGFzc05hbWU9PXN0cmluZ0NsYXNzKXtyZXR1cm4gcXVvdGUoXCJcIit2YWx1ZSl9aWYodHlwZW9mIHZhbHVlPT1cIm9iamVjdFwiKXtmb3IobGVuZ3RoPXN0YWNrLmxlbmd0aDtsZW5ndGgtLTspe2lmKHN0YWNrW2xlbmd0aF09PT12YWx1ZSl7dGhyb3cgVHlwZUVycm9yKCl9fXN0YWNrLnB1c2godmFsdWUpO3Jlc3VsdHM9W107cHJlZml4PWluZGVudGF0aW9uO2luZGVudGF0aW9uKz13aGl0ZXNwYWNlO2lmKGNsYXNzTmFtZT09YXJyYXlDbGFzcyl7Zm9yKGluZGV4PTAsbGVuZ3RoPXZhbHVlLmxlbmd0aDtpbmRleDxsZW5ndGg7aW5kZXgrKyl7ZWxlbWVudD1zZXJpYWxpemUoaW5kZXgsdmFsdWUsY2FsbGJhY2sscHJvcGVydGllcyx3aGl0ZXNwYWNlLGluZGVudGF0aW9uLHN0YWNrKTtyZXN1bHRzLnB1c2goZWxlbWVudD09PXVuZGVmP1wibnVsbFwiOmVsZW1lbnQpfXJlc3VsdD1yZXN1bHRzLmxlbmd0aD93aGl0ZXNwYWNlP1wiW1xcblwiK2luZGVudGF0aW9uK3Jlc3VsdHMuam9pbihcIixcXG5cIitpbmRlbnRhdGlvbikrXCJcXG5cIitwcmVmaXgrXCJdXCI6XCJbXCIrcmVzdWx0cy5qb2luKFwiLFwiKStcIl1cIjpcIltdXCJ9ZWxzZXtmb3JFYWNoKHByb3BlcnRpZXN8fHZhbHVlLGZ1bmN0aW9uKHByb3BlcnR5KXt2YXIgZWxlbWVudD1zZXJpYWxpemUocHJvcGVydHksdmFsdWUsY2FsbGJhY2sscHJvcGVydGllcyx3aGl0ZXNwYWNlLGluZGVudGF0aW9uLHN0YWNrKTtpZihlbGVtZW50IT09dW5kZWYpe3Jlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkrXCI6XCIrKHdoaXRlc3BhY2U/XCIgXCI6XCJcIikrZWxlbWVudCl9fSk7cmVzdWx0PXJlc3VsdHMubGVuZ3RoP3doaXRlc3BhY2U/XCJ7XFxuXCIraW5kZW50YXRpb24rcmVzdWx0cy5qb2luKFwiLFxcblwiK2luZGVudGF0aW9uKStcIlxcblwiK3ByZWZpeCtcIn1cIjpcIntcIityZXN1bHRzLmpvaW4oXCIsXCIpK1wifVwiOlwie31cIn1zdGFjay5wb3AoKTtyZXR1cm4gcmVzdWx0fX07SlNPTjMuc3RyaW5naWZ5PWZ1bmN0aW9uKHNvdXJjZSxmaWx0ZXIsd2lkdGgpe3ZhciB3aGl0ZXNwYWNlLGNhbGxiYWNrLHByb3BlcnRpZXMsY2xhc3NOYW1lO2lmKHR5cGVvZiBmaWx0ZXI9PVwiZnVuY3Rpb25cInx8dHlwZW9mIGZpbHRlcj09XCJvYmplY3RcIiYmZmlsdGVyKXtpZigoY2xhc3NOYW1lPWdldENsYXNzLmNhbGwoZmlsdGVyKSk9PWZ1bmN0aW9uQ2xhc3Mpe2NhbGxiYWNrPWZpbHRlcn1lbHNlIGlmKGNsYXNzTmFtZT09YXJyYXlDbGFzcyl7cHJvcGVydGllcz17fTtmb3IodmFyIGluZGV4PTAsbGVuZ3RoPWZpbHRlci5sZW5ndGgsdmFsdWU7aW5kZXg8bGVuZ3RoO3ZhbHVlPWZpbHRlcltpbmRleCsrXSwoY2xhc3NOYW1lPWdldENsYXNzLmNhbGwodmFsdWUpLGNsYXNzTmFtZT09c3RyaW5nQ2xhc3N8fGNsYXNzTmFtZT09bnVtYmVyQ2xhc3MpJiYocHJvcGVydGllc1t2YWx1ZV09MSkpO319aWYod2lkdGgpe2lmKChjbGFzc05hbWU9Z2V0Q2xhc3MuY2FsbCh3aWR0aCkpPT1udW1iZXJDbGFzcyl7aWYoKHdpZHRoLT13aWR0aCUxKT4wKXtmb3Iod2hpdGVzcGFjZT1cIlwiLHdpZHRoPjEwJiYod2lkdGg9MTApO3doaXRlc3BhY2UubGVuZ3RoPHdpZHRoO3doaXRlc3BhY2UrPVwiIFwiKTt9fWVsc2UgaWYoY2xhc3NOYW1lPT1zdHJpbmdDbGFzcyl7d2hpdGVzcGFjZT13aWR0aC5sZW5ndGg8PTEwP3dpZHRoOndpZHRoLnNsaWNlKDAsMTApfX1yZXR1cm4gc2VyaWFsaXplKFwiXCIsKHZhbHVlPXt9LHZhbHVlW1wiXCJdPXNvdXJjZSx2YWx1ZSksY2FsbGJhY2sscHJvcGVydGllcyx3aGl0ZXNwYWNlLFwiXCIsW10pfX1pZighaGFzKFwianNvbi1wYXJzZVwiKSl7dmFyIGZyb21DaGFyQ29kZT1TdHJpbmcuZnJvbUNoYXJDb2RlO3ZhciBVbmVzY2FwZXM9ezkyOlwiXFxcXFwiLDM0OidcIicsNDc6XCIvXCIsOTg6XCJcXGJcIiwxMTY6XCIgIFwiLDExMDpcIlxcblwiLDEwMjpcIlxcZlwiLDExNDpcIlxcclwifTt2YXIgSW5kZXgsU291cmNlO3ZhciBhYm9ydD1mdW5jdGlvbigpe0luZGV4PVNvdXJjZT1udWxsO3Rocm93IFN5bnRheEVycm9yKCl9O3ZhciBsZXg9ZnVuY3Rpb24oKXt2YXIgc291cmNlPVNvdXJjZSxsZW5ndGg9c291cmNlLmxlbmd0aCx2YWx1ZSxiZWdpbixwb3NpdGlvbixpc1NpZ25lZCxjaGFyQ29kZTt3aGlsZShJbmRleDxsZW5ndGgpe2NoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtzd2l0Y2goY2hhckNvZGUpe2Nhc2UgOTpjYXNlIDEwOmNhc2UgMTM6Y2FzZSAzMjpJbmRleCsrO2JyZWFrO2Nhc2UgMTIzOmNhc2UgMTI1OmNhc2UgOTE6Y2FzZSA5MzpjYXNlIDU4OmNhc2UgNDQ6dmFsdWU9Y2hhckluZGV4QnVnZ3k/c291cmNlLmNoYXJBdChJbmRleCk6c291cmNlW0luZGV4XTtJbmRleCsrO3JldHVybiB2YWx1ZTtjYXNlIDM0OmZvcih2YWx1ZT1cIkBcIixJbmRleCsrO0luZGV4PGxlbmd0aDspe2NoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtpZihjaGFyQ29kZTwzMil7YWJvcnQoKX1lbHNlIGlmKGNoYXJDb2RlPT05Mil7Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7c3dpdGNoKGNoYXJDb2RlKXtjYXNlIDkyOmNhc2UgMzQ6Y2FzZSA0NzpjYXNlIDk4OmNhc2UgMTE2OmNhc2UgMTEwOmNhc2UgMTAyOmNhc2UgMTE0OnZhbHVlKz1VbmVzY2FwZXNbY2hhckNvZGVdO0luZGV4Kys7YnJlYWs7Y2FzZSAxMTc6YmVnaW49KytJbmRleDtmb3IocG9zaXRpb249SW5kZXgrNDtJbmRleDxwb3NpdGlvbjtJbmRleCsrKXtjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChJbmRleCk7aWYoIShjaGFyQ29kZT49NDgmJmNoYXJDb2RlPD01N3x8Y2hhckNvZGU+PTk3JiZjaGFyQ29kZTw9MTAyfHxjaGFyQ29kZT49NjUmJmNoYXJDb2RlPD03MCkpe2Fib3J0KCl9fXZhbHVlKz1mcm9tQ2hhckNvZGUoXCIweFwiK3NvdXJjZS5zbGljZShiZWdpbixJbmRleCkpO2JyZWFrO2RlZmF1bHQ6YWJvcnQoKX19ZWxzZXtpZihjaGFyQ29kZT09MzQpe2JyZWFrfWNoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtiZWdpbj1JbmRleDt3aGlsZShjaGFyQ29kZT49MzImJmNoYXJDb2RlIT05MiYmY2hhckNvZGUhPTM0KXtjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KX12YWx1ZSs9c291cmNlLnNsaWNlKGJlZ2luLEluZGV4KX19aWYoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpPT0zNCl7SW5kZXgrKztyZXR1cm4gdmFsdWV9YWJvcnQoKTtkZWZhdWx0OmJlZ2luPUluZGV4O2lmKGNoYXJDb2RlPT00NSl7aXNTaWduZWQ9dHJ1ZTtjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KX1pZihjaGFyQ29kZT49NDgmJmNoYXJDb2RlPD01Nyl7aWYoY2hhckNvZGU9PTQ4JiYoY2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoSW5kZXgrMSksY2hhckNvZGU+PTQ4JiZjaGFyQ29kZTw9NTcpKXthYm9ydCgpfWlzU2lnbmVkPWZhbHNlO2Zvcig7SW5kZXg8bGVuZ3RoJiYoY2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoSW5kZXgpLGNoYXJDb2RlPj00OCYmY2hhckNvZGU8PTU3KTtJbmRleCsrKTtpZihzb3VyY2UuY2hhckNvZGVBdChJbmRleCk9PTQ2KXtwb3NpdGlvbj0rK0luZGV4O2Zvcig7cG9zaXRpb248bGVuZ3RoJiYoY2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pLGNoYXJDb2RlPj00OCYmY2hhckNvZGU8PTU3KTtwb3NpdGlvbisrKTtpZihwb3NpdGlvbj09SW5kZXgpe2Fib3J0KCl9SW5kZXg9cG9zaXRpb259Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO2lmKGNoYXJDb2RlPT0xMDF8fGNoYXJDb2RlPT02OSl7Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7aWYoY2hhckNvZGU9PTQzfHxjaGFyQ29kZT09NDUpe0luZGV4Kyt9Zm9yKHBvc2l0aW9uPUluZGV4O3Bvc2l0aW9uPGxlbmd0aCYmKGNoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSxjaGFyQ29kZT49NDgmJmNoYXJDb2RlPD01Nyk7cG9zaXRpb24rKyk7aWYocG9zaXRpb249PUluZGV4KXthYm9ydCgpfUluZGV4PXBvc2l0aW9ufXJldHVybitzb3VyY2Uuc2xpY2UoYmVnaW4sSW5kZXgpfWlmKGlzU2lnbmVkKXthYm9ydCgpfWlmKHNvdXJjZS5zbGljZShJbmRleCxJbmRleCs0KT09XCJ0cnVlXCIpe0luZGV4Kz00O3JldHVybiB0cnVlfWVsc2UgaWYoc291cmNlLnNsaWNlKEluZGV4LEluZGV4KzUpPT1cImZhbHNlXCIpe0luZGV4Kz01O3JldHVybiBmYWxzZX1lbHNlIGlmKHNvdXJjZS5zbGljZShJbmRleCxJbmRleCs0KT09XCJudWxsXCIpe0luZGV4Kz00O3JldHVybiBudWxsfWFib3J0KCl9fXJldHVyblwiJFwifTt2YXIgZ2V0PWZ1bmN0aW9uKHZhbHVlKXt2YXIgcmVzdWx0cyxoYXNNZW1iZXJzO2lmKHZhbHVlPT1cIiRcIil7YWJvcnQoKX1pZih0eXBlb2YgdmFsdWU9PVwic3RyaW5nXCIpe2lmKChjaGFySW5kZXhCdWdneT92YWx1ZS5jaGFyQXQoMCk6dmFsdWVbMF0pPT1cIkBcIil7cmV0dXJuIHZhbHVlLnNsaWNlKDEpfWlmKHZhbHVlPT1cIltcIil7cmVzdWx0cz1bXTtmb3IoOztoYXNNZW1iZXJzfHwoaGFzTWVtYmVycz10cnVlKSl7dmFsdWU9bGV4KCk7aWYodmFsdWU9PVwiXVwiKXticmVha31pZihoYXNNZW1iZXJzKXtpZih2YWx1ZT09XCIsXCIpe3ZhbHVlPWxleCgpO2lmKHZhbHVlPT1cIl1cIil7YWJvcnQoKX19ZWxzZXthYm9ydCgpfX1pZih2YWx1ZT09XCIsXCIpe2Fib3J0KCl9cmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpfXJldHVybiByZXN1bHRzfWVsc2UgaWYodmFsdWU9PVwie1wiKXtyZXN1bHRzPXt9O2Zvcig7O2hhc01lbWJlcnN8fChoYXNNZW1iZXJzPXRydWUpKXt2YWx1ZT1sZXgoKTtpZih2YWx1ZT09XCJ9XCIpe2JyZWFrfWlmKGhhc01lbWJlcnMpe2lmKHZhbHVlPT1cIixcIil7dmFsdWU9bGV4KCk7aWYodmFsdWU9PVwifVwiKXthYm9ydCgpfX1lbHNle2Fib3J0KCl9fWlmKHZhbHVlPT1cIixcInx8dHlwZW9mIHZhbHVlIT1cInN0cmluZ1wifHwoY2hhckluZGV4QnVnZ3k/dmFsdWUuY2hhckF0KDApOnZhbHVlWzBdKSE9XCJAXCJ8fGxleCgpIT1cIjpcIil7YWJvcnQoKX1yZXN1bHRzW3ZhbHVlLnNsaWNlKDEpXT1nZXQobGV4KCkpfXJldHVybiByZXN1bHRzfWFib3J0KCl9cmV0dXJuIHZhbHVlfTt2YXIgdXBkYXRlPWZ1bmN0aW9uKHNvdXJjZSxwcm9wZXJ0eSxjYWxsYmFjayl7dmFyIGVsZW1lbnQ9d2Fsayhzb3VyY2UscHJvcGVydHksY2FsbGJhY2spO2lmKGVsZW1lbnQ9PT11bmRlZil7ZGVsZXRlIHNvdXJjZVtwcm9wZXJ0eV19ZWxzZXtzb3VyY2VbcHJvcGVydHldPWVsZW1lbnR9fTt2YXIgd2Fsaz1mdW5jdGlvbihzb3VyY2UscHJvcGVydHksY2FsbGJhY2spe3ZhciB2YWx1ZT1zb3VyY2VbcHJvcGVydHldLGxlbmd0aDtpZih0eXBlb2YgdmFsdWU9PVwib2JqZWN0XCImJnZhbHVlKXtpZihnZXRDbGFzcy5jYWxsKHZhbHVlKT09YXJyYXlDbGFzcyl7Zm9yKGxlbmd0aD12YWx1ZS5sZW5ndGg7bGVuZ3RoLS07KXt1cGRhdGUodmFsdWUsbGVuZ3RoLGNhbGxiYWNrKX19ZWxzZXtmb3JFYWNoKHZhbHVlLGZ1bmN0aW9uKHByb3BlcnR5KXt1cGRhdGUodmFsdWUscHJvcGVydHksY2FsbGJhY2spfSl9fXJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSxwcm9wZXJ0eSx2YWx1ZSl9O0pTT04zLnBhcnNlPWZ1bmN0aW9uKHNvdXJjZSxjYWxsYmFjayl7dmFyIHJlc3VsdCx2YWx1ZTtJbmRleD0wO1NvdXJjZT1cIlwiK3NvdXJjZTtyZXN1bHQ9Z2V0KGxleCgpKTtpZihsZXgoKSE9XCIkXCIpe2Fib3J0KCl9SW5kZXg9U291cmNlPW51bGw7cmV0dXJuIGNhbGxiYWNrJiZnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKT09ZnVuY3Rpb25DbGFzcz93YWxrKCh2YWx1ZT17fSx2YWx1ZVtcIlwiXT1yZXN1bHQsdmFsdWUpLFwiXCIsY2FsbGJhY2spOnJlc3VsdH19fWlmKGlzTG9hZGVyKXtkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gSlNPTjN9KX19KSh0aGlzKX0se31dLDUwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz10b0FycmF5O2Z1bmN0aW9uIHRvQXJyYXkobGlzdCxpbmRleCl7dmFyIGFycmF5PVtdO2luZGV4PWluZGV4fHwwO2Zvcih2YXIgaT1pbmRleHx8MDtpPGxpc3QubGVuZ3RoO2krKyl7YXJyYXlbaS1pbmRleF09bGlzdFtpXX1yZXR1cm4gYXJyYXl9fSx7fV19LHt9LFsxXSkoMSl9KTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKVxuICAsIGVsZW1lbnQgPSByZXF1aXJlKCcuLi8uLi9lbGVtZW50JylcbiAgLCB1dGlsSGFzaCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvaGFzaCcpXG4gICwgdk9iamVjdCA9IHJlcXVpcmUoJy4uLy4uLy4uL29iamVjdCcpXG5cbi8qdGhpcyBmaWxlIGhhcyBub3RoaW5nIHRvIGRvIHdpdGggdGhlIG5ldHdvcmtkYXRhIENsYXNzXG4gIGl0IG9ubHkgcmVhZHMgb3V0IG1vZGVscyBmb3IgZWxlbWVudHMgc28geW91IGNhbiBtYWtlIGEgc3Vic2NyaXB0aW9uXG4qL1xuXG5mdW5jdGlvbiBzb3J0RmllbGQoIGZpbHRlciwgb2JqICkge1xuICBpZiggZmlsdGVyLnNvcnQgJiYgZmlsdGVyLnNvcnQuZmllbGQgKSBcbiAge1xuICAgIHZhciBzb3J0ID0geyAkOnt9IH1cbiAgICBzb3J0LiRbZmlsdGVyLnNvcnQuZmllbGRdID0gdHJ1ZVxuICAgIHV0aWwubWVyZ2UoIG9iaiwgc29ydCApXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbi8vVE9ETzogaGFzIHRvIHdvcmsgaW4gdGhlIGh1YlxudmFyIGRpc2FibGVTZWxlY3Rpb25zID0gdHJ1ZVxuXG5leHBvcnRzLnBhcnNlRGF0YSA9IGZ1bmN0aW9uKCB2YWwsIGZyb210YXJnZXRzLCBsb2dnZXIgKSB7XG5cblxuICAvL2ltcG9ydGFudCBmb3IgdW5TdWJzY3JpYmUgPz8/XG4gICAgLy8gY29uc29sZS5sb2coJ0xFVFMgUEFSU0UgREFUQSEnLmN5YW4uaW52ZXJzZSAsIHZhbCwgSlNPTi5zdHJpbmdpZnkoZnJvbXRhcmdldHMpKVxuICBcblxuICAvLyBjb25zb2xlLmxvZygnTEVUUyBQQVJTRSBEQVRBIScuY3lhbi5pbnZlcnNlICwgdmFsLCBKU09OLnN0cmluZ2lmeShmcm9tdGFyZ2V0cykpXG5cbiAgaWYoIXZhbCkgcmV0dXJuXG4gICAgLy8gY29uc29sZS5sb2coJ0xFVFMgUEFSU0UgREFUQSEyJy5jeWFuLmludmVyc2UgLCB2YWwsIEpTT04uc3RyaW5naWZ5KGZyb210YXJnZXRzKSlcblxuICB2YXIgc3Vic29iaiA9IHt9XG4gICAgLCBmID0gdmFsLl9maWx0ZXJcbiAgICAsIHRhcmdldHMgPSBmcm9tdGFyZ2V0cyB8fCB2YWwuX19zdWJcblxuICBpZiAodGFyZ2V0cykge1xuICAgIC8vIGNvbnNvbGUubG9nKCd0YXJnZXRzJywgdGFyZ2V0cylcbiAgICBpZiAoZiAmJiAhZGlzYWJsZVNlbGVjdGlvbnMpIHtcbiAgICAgIGlmKCFzdWJzb2JqWycqJ10pIHN1YnNvYmpbJyonXT1bXVxuICAgICAgc3Vic29ialsnKiddLnB1c2goW1xuICAgICAgICB1dGlsLmNsb25lKGYsIHtzdWJzT2JqOnRydWUsIGZuOnRydWUsIHR5cGU6dHJ1ZX0pXG4gICAgICAgICwgc29ydEZpZWxkKGYsIGZyb210YXJnZXRzIHx8IHsgJDogdGFyZ2V0cyB9KVxuICAgICAgXSlcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnSU0gRE9JTkcgU0VMRUNUUyBwYXJzZURhdGVsZXgnLCBzdWJzb2JqIClcbiAgICAvL1RFTVBGSVghISEhXG4gICAgZm9yKHZhciBpIGluIHN1YnNvYmpbJyonXVsxXSApIHtcbiAgICAgIC8vd2VsIGZmIGRlIGZpZWxkcyBvb2sgZG9lbiBwcm9iXG5cbiAgICAgIHN1YnNvYmpbaV0gPSBzdWJzb2JqWycqJ11bMV1baV1cbiAgICB9XG4gICAgZGVsZXRlIHN1YnNvYmpbJyonXVxuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJ3RhcmdldHMgSU0gRE9JTkcgU0VMRUNUUyBwYXJzZURhdGVsZXgnLCB0YXJnZXRzIClcblxuICAgICAgc3Vic29iaiA9IHRhcmdldHNcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdMRVRTIFBBUlNFIERBVEEhNCcuY3lhbi5pbnZlcnNlICwgdmFsLCBKU09OLnN0cmluZ2lmeShmcm9tdGFyZ2V0cykpXG5cbiAgICAvLyBjb25zb2xlLndhcm4oICdjYW50XFwndCBmaW5kIHRhcmdldCAtLSBsZXRzIGRvIHN0dWZmIScsIHZhbCAgKVxuICAgIC8vVE9ETzpndWFyZCB2b29yIGFscyBoZXQgaGV0IG5pZXQgd2lsIC0tIG1pc2NoaWVuZCBkb29yIF9zdWJzIHpvZWtlblxuXG4gICAgLy8gaWYodmFsLl9wYXRoKSB7XG4gICAgLy8gICBjb25zb2xlLmxvZyh2YWwuX3BhdGgpXG4gICAgLy8gfVxuXG4gICAgLy9ubyB0cmFnZXRzIGRvbnQgZG8gYW55dGhpbmc/XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZygnUkVTVUxUIScsIEpTT04uc3RyaW5naWZ5KHN1YnNvYmopKVxuXG4gIHJldHVybiBzdWJzb2JqXG59XG5cbmZ1bmN0aW9uIHNldEZsYWcoIG9iaiwgc3RyaW5nLCBmbGFnLCBmaWVsZCwgdmFsLCBmcm9tLCBlbGVtICkge1xuXG5cblxuICB2YXIgbm9uQ2xvdWREYXRhQmluZGluZ3NcbiAgICAsIGZyb21LZXlcblxuICAgICwgYmVUcmlwcHBpblxuXG5cbiAgaWYoIGZyb20gKSB7XG4gICAgZnJvbUtleSA9IGZyb20uX25hbWUgIT09IHZvaWQgMCA/IGZyb20uX25hbWUgOiBmcm9tXG5cbiAgICBpZiggZnJvbSBpbnN0YW5jZW9mIHZPYmplY3QpIHtcblxuICAgICAgLy90ZWdlbm92ZXIgZ2VzdGVsZGUgYmlqXG4gICAgICAvLyBpZihmcm9tLl9fdCA9PT0gNCkge1xuICAgICAgICAvLyBpZihmcm9tLl92YWwgJiYgZnJvbS5fdmFsLmNsb3VkKSB7XG4gICAgICAgICAgLy9oYWFsIGp1aXN0IGZpZWxkIHdlZ1xuICAgICAgICAvLyB9XG4gICAgICAvLyB9IFxuICAgICAgLy8gY29uc29sZS5sb2coJ0ZST00hJywgZnJvbS5fbmFtZSwgZnJvbS5fcGF0aCApXG4gICAgICBmcm9tS2V5ID0gZnJvbS5fbmFtZVxuICAgIH1cblxuICAgIGlmKGZyb20gaW5zdGFuY2VvZiBBcnJheSAmJiBmcm9tWzFdKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnYmUgdHJpcHBpbmchJywgZnJvbSlcbiAgICAgIC8vICAgZnJvbUtleSA9IGZyb21bMV0gJiYgZnJvbVsxXS5fbmFtZVxuXG4gICAgICAvLyBiZVRyaXBwcGluID0gZnJvbVswXS5fbmFtZVxuXG4gICAgfVxuXG4gIH1cblxuICB2YXIgZGQgPSBlbGVtICYmIGZyb20gJiYgKCBlbGVtLl9kIHx8IGVsZW0uY2hlY2tQYXJlbnQoJ2RhdGEnLCB0cnVlKSApXG5cbiAgLy8gaWYoYmVUcmlwcHBpbikge1xuICAvLyAgIGNvbnNvbGUubG9nKGRkLCBmcm9tS2V5LCBiZVRyaXBwcGluKVxuICAvLyB9XG5cblxuICBpZiAoZmllbGQgPT09ICdjb2xsZWN0aW9uJykge1xuICAgIHZhciBvYmoyXG5cbiAgICBpZiAoZmxhZy5maWx0ZXIgJiYgZmxhZy5maWx0ZXIudmFsIT09dHJ1ZSAmJiAhZGlzYWJsZVNlbGVjdGlvbnMpIFxuICAgIHtcbiAgICAgIC8vZGl0IG5vZyBoYW5kZWxlbiBvcCByZWZzXG4gICAgICBvYmoyID0ge31cblxuXG4gICAgICAvL0VOQUJMRSBGT1IgU0VMRUNUSU9OXG4gICAgICAvLyBpZiAoc3RyaW5nID09PSB0cnVlKSB7XG5cbiAgICAgIC8vICAgc3RyaW5nID0gJyonXG4gICAgICAvLyB9IGVsc2Uge1xuXG4gICAgICAvLyAgIHN0cmluZyA9IHN0cmluZyArICcuKidcbiAgICAgIC8vIH1cbiAgICAgIHZhciBmID0gZmxhZy5maWx0ZXIucmF3XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coICdTRVQgRkxBRycsIGFyZ3VtZW50cyApXG5cblxuICAvLyBjb25zb2xlLmxvZyggJ0ZJRUxEITonLCBmaWVsZCAsICdGUk9NOicsIGZyb20sICBzdHJpbmcuc3BsaXQoJy4nKSwgc3RyaW5nIClcblxuICAgICAgdmFyIGFyciA9IHV0aWwucGF0aChvYmosIHN0cmluZy5zcGxpdCgnLicpLCBbXSlcblxuICAgICAgYXJyLnB1c2goIFxuICAgICAgICBbZiwge1xuICAgICAgICAgICQ6IHNvcnRGaWVsZChmLG9iajIpXG4gICAgICAgIH1dXG4gICAgICApXG5cbiAgICAgIC8vb2JqLCBwYXRoLCB2YWwsIG92ZXJ3cml0ZVxuXG4gICAgICAvL1RFTVBGSVghISEhXG4gICAgICB2YXIgdGVtcCA9IHV0aWwucGF0aCggb2JqLCBzdHJpbmcuc3BsaXQoJy4nKSwge30sIHRydWUgKVxuICAgICAgZm9yKHZhciBpIGluIGFyclthcnIubGVuZ3RoLTFdWzFdICkge1xuICAgICAgICAvL3dlbCBmZiBkZSBmaWVsZHMgb29rIGRvZW4gcHJvYlxuXG4gICAgICAgIHRlbXBbaV0gPSBhcnJbYXJyLmxlbmd0aC0xXVsxXVtpXVxuICAgICAgfVxuICAgICAgYXJyID0gdGVtcFxuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coICdJTSBET0lORyBTRUxFQ1BTIENPTCBDT0whJywgYXJyIClcblxuXG4gICAgfSBlbHNlIHtcblxuICAgICAgdmFyIGYgPSBzdHJpbmcgPT09IHRydWUgPyAnJCcgOiBzdHJpbmcgKyAnLiQnXG4gICAgICAgICwgcCA9ICBmLnNwbGl0KCcuJylcblxuICAgICAgICAsIHNwZWNpYWxGaXhcblxuICAgICAgaWYoIGRkICYmIGRkWyBmcm9tS2V5IF0gKSBcbiAgICAgIHtcbiAgICAgICAgbm9uQ2xvdWREYXRhQmluZGluZ3MgPSB0cnVlXG4gICAgICAgIGlmKCBwWzBdID09PSBmcm9tS2V5ICkgXG4gICAgICAgIHtcbiAgICAgICAgICBwLnNoaWZ0KClcbiAgICAgICAgICBub25DbG91ZERhdGFCaW5kaW5ncyA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIG5vbkNsb3VkRGF0YUJpbmRpbmdzICkgXG4gICAgICB7XG4gICAgICAgIGlmKHNwZWNpYWxGaXgpIHtcbiAgICAgICAgICBvYmouc3BlY2lhbEZpeCA9IGZyb21LZXlcbiAgICAgICAgICBpZihiZVRyaXBwcGluKSB7XG4gICAgICAgICAgICBvYmouc3BlY2lhbEZpeCA9IFsgZnJvbUtleSwgYmVUcmlwcHBpbiBdXG4gICAgICAgICAgfVxuICAgICAgICAgIG9iajIgPSB1dGlsLnBhdGgob2JqLCBwICwge30pXG4gICAgICAgICAgcmVhZE1vZGVsKGZsYWcuZWxlbWVudC5fdmFsIGluc3RhbmNlb2YgZWxlbWVudCA/IGZsYWcuZWxlbWVudC5fdmFsIDogZmxhZy5lbGVtZW50Ll92YWwuYmFzZSwgb2JqMiApXG4gICAgICAgIH1cbiAgICAgIH0gXG4gICAgICBlbHNlIFxuICAgICAge1xuICAgICAgICBvYmoyID0gdXRpbC5wYXRoKG9iaiwgcCAsIHt9KVxuICAgICAgICByZWFkTW9kZWwoZmxhZy5lbGVtZW50Ll92YWwgaW5zdGFuY2VvZiBlbGVtZW50ID8gZmxhZy5lbGVtZW50Ll92YWwgOiBmbGFnLmVsZW1lbnQuX3ZhbC5iYXNlLCBvYmoyIClcbiAgICAgIH1cblxuICAgIH1cblxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICAneHh4WFgxMTEyMjIyWFh4eCcsIHN0cmluZywgb2JqICkgLy8sIGZyb21LZXksIGVsZW0uX2QsIGVsZW0uZGF0YSwgZWxlbS5jaGVja1BhcmVudCgnZGF0YScsIHRydWUpIClcblxuXG4gIH0gZWxzZSB7XG5cbiAgICBpZiggZGQgJiYgZGRbIGZyb21LZXkgXSApIFxuICAgIHtcbiAgICAgIG5vbkNsb3VkRGF0YUJpbmRpbmdzID0gdHJ1ZVxuICAgIH1cblxuICAgIGlmICggc3RyaW5nIGluc3RhbmNlb2YgQXJyYXkgKSBcbiAgICB7XG4gICAgICBmb3IgKHZhciBpIGluIHN0cmluZykgXG4gICAgICB7XG4gICAgICAgIGlmKCBub25DbG91ZERhdGFCaW5kaW5ncyApXG4gICAgICAgIHtcbiAgICAgICAgICAvL1RPRE86IHRoaXMgaXMgYSB0ZW1wZml4XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ05PTiBjbG91ZCBiaW5kaW5ncycsIHN0cmluZywgc3RyaW5nW2ldKVxuICAgICAgICAgIGlmKCBzdHJpbmdbaV0gaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCchQCFAIUAnKVxuICAgICAgICAgICAgc3RyaW5nW2ldID0gc3RyaW5nW2ldWzBdXG4gICAgICAgICAgfVxuICAgICAgICAgIHN0cmluZ1tpXSA9IHN0cmluZ1tpXS5zcGxpdCgnLicpXG4gICAgICAgICAgaWYoIHN0cmluZ1tpXVswXSA9PT0gZnJvbUtleSApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0cmluZ1tpXS5zaGlmdCgpXG4gICAgICAgICAgICB1dGlsLnBhdGgoIG9iaiwgc3RyaW5nW2ldLCB0cnVlIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgLy9UT0RPOiB0aGlzIGlzIGEgdGVtcGZpeFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdPQko6JyAsIG9iaiwgJ1NUUklOR1tpXTonLCBzdHJpbmdbaV0sICdTVFJJTkc6Jywgc3RyaW5nLCBmcm9tS2V5KVxuICAgICAgICAgICBpZiggc3RyaW5nW2ldIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnMiFAIUAhQCcpXG4gICAgICAgICAgICBzdHJpbmdbaV0gPSBzdHJpbmdbaV1bMF1cbiAgICAgICAgICB9XG4gICAgICAgICAgdXRpbC5wYXRoKG9iaiwgc3RyaW5nW2ldLnNwbGl0KCcuJyksIHRydWUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IFxuICAgIGVsc2UgaWYgKCBzdHJpbmcgIT09IHRydWUgJiYgdHlwZW9mIHN0cmluZyA9PT0gJ3N0cmluZycgKSBcbiAgICB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAgJ3h4eFhYWFh4eCcsIHN0cmluZywgb2JqICkgLy8sIGZyb21LZXksIGVsZW0uX2QsIGVsZW0uZGF0YSwgZWxlbS5jaGVja1BhcmVudCgnZGF0YScsIHRydWUpIClcblxuICAgICAgaWYoIG5vbkNsb3VkRGF0YUJpbmRpbmdzIClcbiAgICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coIG5vbkNsb3VkRGF0YUJpbmRpbmdzICwgJ05PTkNMT1VEJylcbiAgICAgICAgICBzdHJpbmcgPSBzdHJpbmcuc3BsaXQoJy4nKVxuICAgICAgICAgIGlmKCBzdHJpbmdbMF0gPT09IGZyb21LZXkgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBzdHJpbmcuc2hpZnQoKVxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJ0ZJRUxEIToyMjIyMjInLCBzdHJpbmcgKVxuXG4gICAgICAgICAgICBpZihzdHJpbmcubGVuZ3RoID4gMCkgdXRpbC5wYXRoKCBvYmosIHN0cmluZywgdHJ1ZSApXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBub25DbG91ZERhdGFCaW5kaW5ncyAsICdOT05DTE9VRCcsIHN0cmluZywgb2JqIClcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coICAneHh4eHgnLCBzdHJpbmcsIG9iaiApIC8vLCBmcm9tS2V5LCBlbGVtLl9kLCBlbGVtLmRhdGEsIGVsZW0uY2hlY2tQYXJlbnQoJ2RhdGEnLCB0cnVlKSApXG4gICAgICAgIHV0aWwucGF0aCggb2JqLCBzdHJpbmcuc3BsaXQoJy4nKSwgdHJ1ZSApXG4gICAgICB9XG4gICAgfSBcbiAgICBlbHNlIFxuICAgIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tPiAyJy5pbnZlcnNlLCBzdHJpbmcsIG9iaiwgZmxhZywgZmllbGQpXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCd4eHh4eHgnKVxuICAgICAgLy8gb2JqWydfXyNfXyddID0gdHJ1ZVxuICAgICAgLy8gb2JqID0gdHJ1ZTtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCchISEnLG9iaiwgcGFyZW50KTtcbiAgICAgIC8vIG9ialsnIyddID0gdHJ1ZTtcbiAgICB9XG4gICAgXG5cbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9yZSggb2JqLCBmbGFnLCBmaWVsZCwgdmFsLCBmcm9tLCBlbGVtICkge1xuXG4gIC8vIGNvbnNvbGUubG9nKCdTVE9SRScsIGFyZ3VtZW50cyApXG5cbiAgaWYgKGZsYWcgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZmxhZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHNldEZsYWcob2JqLCBmbGFnW2ldLl9mbGFnLmRhdGFbMl0sIGZsYWcsIGZpZWxkLCB2YWwsIGZyb20sIGVsZW0gKVxuXG4gICAgfVxuICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tPicucmVkLGZsYWcpXG5cbiAgICBzZXRGbGFnKG9iaiwgZmxhZy5fZmxhZy5kYXRhWzJdLCBmbGFnLCBmaWVsZCwgdmFsLCBmcm9tLCBlbGVtIClcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkTW9kZWwoIGVsZW0sIG9iaiwgdmFsLCBmcm9tICwgaWdub3JlZmllbGQpIHtcblxuICAvLyBjb25zb2xlLmxvZyggJ2xldHMgcmVhZCBtb2RlbCcueWVsbG93LmludmVyc2UsIHZhbCAmJiB2YWwuX3BhdGggfHwgJ25vIHZhbFBhdGgnLCBmcm9tICYmIGZyb20uX3BhdGggfHwgJ25vIGZyb21QYXRoJyAsIHZhbCwgZWxlbSwgb2JqLCB2YWwsIGZyb20gKVxuICAgIC8vaGllciBtb2V0IGhldCBnZWNvbWJpbmVlcmQgd29yZGVuIG1ldCBlZW4gdmFsdWUgd2FhciBoZXQgYWFuIGdlYmluZCBpcyFcblxuICBpZiAoZWxlbS5tb2RlbCAmJiAoZWxlbS5tb2RlbC5mbGFnc3x8ZWxlbS5tb2RlbC5zdWJzY3JpcHRpb258fGVsZW0ubW9kZWwuZmllbGQpKSB7XG4gICAgXG4gICAgLy8gaWYob2JqKSBjb25zb2xlLmxvZygnWFhYMTIxMjEyWFhYIENPTExFQ1RJT04nLCAgZWxlbS5tb2RlbC5maWVsZCAmJiBlbGVtLm1vZGVsLmZpZWxkLnZhbCApXG4gICAgLy8gY29uc29sZS5sb2coJ1NFVCBTT1JURklFTEQhIDIuMTInLCBKU09OLnN0cmluZ2lmeShvYmosZmFsc2UsMiksIGVsZW0ubW9kZWwuZmllbGQgJiYgZWxlbS5tb2RlbC5maWVsZC52YWwpXG5cbiAgICB2YXIgYSA9IG9ialxuICAgICAgLCBmaWVsZFxuICAgICAgLCBkb0l0SWdub3JlRmxhZ3NcblxuICAgICAgLy9bXCJ1c2Vyc1wiLCBcIlVfYmEzMjE1YTFiMTAzOGE3MFwiLCBcIm5hdmlnYXRpb25cIiwgXCJlcGlzb2RlXCJdIFxuICAgIC8vIGNvbnNvbGUubG9nKCAnXFxuXFxuXFxuXFxuXFxuLS0tLS0tLS0+JywgZWxlbS5tb2RlbC5maWVsZCAmJiBlbGVtLm1vZGVsLmZpZWxkLnZhbCwgZWxlbS5tb2RlbC5wYXJzaW5nICYmICFlbGVtLm1vZGVsLnBhcnNlZCAgKVxuXG4gICAgaWYoaWdub3JlZmllbGQpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdTVE9QISBpZ25vcmVmaWVsZCcsIG9iaiwgZWxlbS5tb2RlbC5maWVsZCAmJiBlbGVtLm1vZGVsLmZpZWxkLnZhbCwgZnJvbSwgZnJvbSAmJiBmcm9tLl9wYXRoKVxuICAgICAgLy8gZGVidWdnZXJcbiAgICB9XG4gICAgLy9UT0RPOiBjb21wYXJlIGFycmF5cyBcbiAgICBlbHNlIGlmKGVsZW0ubW9kZWwuZmllbGQgJiYgZWxlbS5tb2RlbC5maWVsZC52YWwgJiYgIWVsZW0ubW9kZWwucGFyc2luZyAmJiAhZWxlbS5tb2RlbFBhcnNlZCAmJiAoIHR5cGVvZiBmcm9tICE9PSAnc3RyaW5nJyB8fCBlbGVtLm1vZGVsLmZpZWxkLnZhbCA9PT0gZnJvbSAgKSAgKSB7XG4gICAgICBmaWVsZCA9IGVsZW0ubW9kZWwuZmllbGQudmFsLnNwbGl0KCcuJylcbiAgICAgIFxuICAgICAgaWYoIGVsZW0ubW9kZWwuZmllbGQudmFsID09PSBmcm9tICkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdIRVJFIElUUyBJTlRFUkVTVElORyBETycsIGVsZW0ubW9kZWwuZmllbGQudmFsICwgZnJvbSApXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGEgPSB1dGlsLnBhdGgob2JqLGZpZWxkLHt9LHRydWUpXG4gICAgICAgIGRvSXRJZ25vcmVGbGFncyA9IHRydWVcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICBpZihmcm9tICYmIGVsZW0ubW9kZWwuZmllbGQgJiYgZWxlbS5tb2RlbC5maWVsZC52YWwgIT09IGZyb20pIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMFxuICAgICAgfVxuICAgIH1cblxuICAgIGlmKGVsZW0ubW9kZWwgJiYgZWxlbS5tb2RlbC5zdWJzY3JpcHRpb24gKSB7XG5cbiAgICAgIHZhciBzdWJzID0gZWxlbS5tb2RlbC5zdWJzY3JpcHRpb24ucmF3XG4gICAgICBpZihzdWJzID09PSB0cnVlKSB7XG4gICAgICAgIGlmKGZpZWxkKSB7XG4gICAgICAgICAgaWYoZmllbGQubGVuZ3RoPjEpIHtcbiAgICAgICAgICBhID0gdXRpbC5wYXRoKG9iaixmaWVsZCx0cnVlLHRydWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ialtmaWVsZFswXV0gPSB0cnVlXG4gICAgICAgICAgICBhID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHN1YiA9IGVsZW0ubW9kZWwuc3Vic2NyaXB0aW9uLnJhd1xuICAgICAgICBpZiggdHlwZW9mIHN1YiA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgICAgdmFyIG9sZCA9IHN1YlxuICAgICAgICAgIHN1YiA9IHt9XG4gICAgICAgICAgc3ViW29sZF0gPSB0cnVlXG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5tZXJnZShhLHN1YilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpIGluIGVsZW0ubW9kZWwuZmxhZ3MpIHtcbiAgICAgIHN0b3JlKGEsIGVsZW0ubW9kZWwuZmxhZ3NbaV0sIGksIHZhbCwgZnJvbSwgZWxlbSApXG4gICAgfVxuICAgIFxuICB9XG5cbiAgaWYoICFlbGVtLm1vZGVsIHx8ICFlbGVtLm1vZGVsLmJsb2NrIHx8ICFlbGVtLm1vZGVsLmJsb2NrLnZhbCApIHtcblxuICAgIGZvciAoXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbGVtLmNoaWxkcmVuXG4gICAgICAsIGNoaWxkXG4gICAgICAsIGNoaWxkJCA9IDBcbiAgICAgICwgY2hpbGRyZW4kbGVuID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoXG4gICAgICA7IGNoaWxkJCA8IGNoaWxkcmVuJGxlblxuICAgICAgOyBjaGlsZCA9IGNoaWxkJCsrXG4gICAgKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2NoaWxkJF1cbiAgICAgIGlmICgoIWNoaWxkLm1vZGVsIHx8ICghY2hpbGQubW9kZWwuaW5oZXJpdCB8fCBjaGlsZC5tb2RlbC5pbmhlcml0LnZhbCE9PWZhbHNlKSlcbiAgICAgICAgJiYgIWNoaWxkLl9jb2wgJiYgIWNoaWxkLmRhdGEgfHwgY2hpbGQuX2Rmcm9tKSB7IC8vZGl0IGthbiBiZXRlciFcbiAgICAgICAgcmVhZE1vZGVsKGNoaWxkLCBhIHx8IG9iaiwgdmFsLCBmcm9tIClcbiAgICAgIC8vZWxlbSwgb2JqLCB2YWwsIGZyb20gLCBpZ25vcmVmaWVsZCwgZmllbGRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZihvYmpbJ19fI19fJ10pIHtcbiAgICAvLyBvYmouJCA9IHRydWVcbiAgICAvLyB1dGlsLm1lcmdlKG9iaiwgb2JqWydfXyNfXyddKVxuICAgIGRlbGV0ZSBvYmpbJ19fI19fJ11cbiAgfVxuXG4gIHJldHVybiBlbGVtLm1vZGVsICYmIGVsZW0ubW9kZWwuYmxvY2sgJiYgZWxlbS5tb2RlbC5ibG9jay52YWw9PT0nYWxsJyA/IHZvaWQgMCA6IG9ialxufVxuXG51dGlsLmRlZmluZShlbGVtZW50LCAnZ2V0TW9kZWwnLCBmdW5jdGlvbiggdmFsLCBmcm9tLCBpZ25vcmVmaWVsZCApIHtcblxuICB2YXIgc3Vic2NyaXB0aW9uID0gcmVhZE1vZGVsKCB0aGlzLCB7fSwgdmFsLCBmcm9tLCBpZ25vcmVmaWVsZCApXG5cbiAgLy8gY29uc29sZS5lcnJvcigncGFyc2VkIHN1YnNjcmlwdGlvbiEnLCBKU09OLnN0cmluZ2lmeShzdWJzY3JpcHRpb24sIGZhbHNlLCAyKSApXG4gIC8vd2Fhcm9tIGtvbXQgaWUgM3ggZXh0cmE/XG5cbiAgcmV0dXJuICF1dGlsLmVtcHR5KCBzdWJzY3JpcHRpb24gKSA/IHN1YnNjcmlwdGlvbiA6IG51bGxcbn0pIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIG9iamVjdCA9IHJlcXVpcmUoJy4uLy4uLy4uL29iamVjdCcpXG4gICwgZGF0YSA9IHJlcXVpcmUoJy4uLy4uLy4uL2RhdGEnKVxuICAsIFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcbiAgLCB2aWdvdXIgPSByZXF1aXJlKCcuLi8uLi8uLi8nKVxuICAsIF9uZXR3b3JrZGF0YSA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHZpZ291ci5OZXR3b3JrZGF0YSA9IGRhdGEubmV3KHtcbiAgICAgIG1peGVkOiA0LCAvL21pc2NoaWVuIG5pZXQgbWl4ZWRcbiAgICAgIG1lcmdlOiB0cnVlXG4gICAgfSlcbiAgLCBfc3ViID0gJ3N1YnNjcmliZSdcbiAgLCBfdW5zdWIgPSAndW4nICsgX3N1YlxuICAsIF9saXN0ZW5lciA9ICdMaXN0ZW5lcidcbiAgLCBfYWwgPSAnYWRkJyArIF9saXN0ZW5lclxuICAsIF9ybCA9ICdyZW1vdmUnICsgX2xpc3RlbmVyXG4gICwgX3Byb3RvID0gb2JqZWN0LnByb3RvdHlwZVxuICAsIF9wcm90b0FkZExpc3RlbmVyID0gX3Byb3RvW19hbF1cbiAgLCBfcHJvdG9SZW1vdmVMaXN0ZW5lciA9IF9wcm90b1tfcmxdXG4gICwgX2NoZWNrU3Vic2NyaXB0aW9uID0gZnVuY3Rpb24oIGZpZWxkLCB2YWwgKSB7XG4gICAgICB2YXIgYSA9IHRoaXNcbiAgICAgIHdoaWxlIChhICYmIGEuX190ID09PSA0KSB7XG4gICAgICAgIGlmKGEuX19ibG9jaykgcmV0dXJuXG4gICAgICAgIGEgPSBhLl92YWxcbiAgICAgIH1cbiAgICAgIC8vIGNvbnNvbGUubG9nKGZpZWxkLCBhKVxuICAgICAgaWYoKGEgaW5zdGFuY2VvZiBfbmV0d29ya2RhdGEpICYmIGFbZmllbGRdKSBhW2ZpZWxkXSh2YWwsIHRoaXMpXG4gICAgfVxuICAsIFYgPSByZXF1aXJlKCcuLi8uLi8uLi8nKVxuXG5fbmV0d29ya2RhdGEucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX3N1YnMnLCdfY29tcGxldGUnKVxuLy8nXycgKyBfc3ViLCAnXycgKyBfdW5zdWIsIHdlIGRvbnQgdXNlIHRoZXJlIG5vd1xuLy8gX3N1YnNjcmliZShfc3ViKTtcbi8vIF9zdWJzY3JpYmUoX3Vuc3ViKTtcblxuXG4vL1RPRE86IGZpeCBtYXJrISEhISEhISEhISEgbWFyazp0cnVlXG51dGlsLmRlZmluZShfbmV0d29ya2RhdGEsXG4gICdnZXQnLCBmdW5jdGlvbiggdmFsLCBzZXQsIG5vdHNlbGYsIHN0YW1wICkge1xuICAgIFxuICAgIC8vIElNIEdFVFRJTkchIFtcInVzZXJzXCIsIFwidV9iYTMyMTVhMWIxMDM4YTcwXCIsIFwibXR2RGF0YVwiLCBcIk5MXCIsIFwibmxcIiwgXCJzaG93c1wiXSB1bmRlZmluZWRcbiAgICAvL29iaiwgcGF0aCwgdmFsLCBvdmVyd3JpdGUsIHdyaXRlSGFuZGxlciwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBzZWxmLCB1aWQsIGlcbiAgICAvLyB2YXIgYmxhID0gKHZhbCBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbCA6IFN0cmluZyh2YWwpLnNwbGl0KCcuJylcbiAgICAvLyBjb25zb2xlLmxvZygnSU0gR0VUVElORyEnLCBibGEsIHZhbCwgc2V0LCB0aGlzLCB0aGlzLnBhdGgpXG5cbiAgICAvL1RPRE86IEFsd2F5cyBnaXZlIG1lIHRoZSBub24tZnJvbSBpcyBwb3NzaWJsZVxuICAgIC8vIGNvbnNvbGUud2FybignR2V0IC0tIHNlbGYgaXMgbm93IG9uIG9uIGRlZnVhbHQgc2hvdWxkIGJlY29tZSBzb21ldGhpbmcgZGlmZmVyZW50IScpXG4gICAgLy9vYmosIHBhdGgsIHZhbCwgb3ZlcndyaXRlLCB3cml0ZUhhbmRsZXIsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgc2VsZixcbiAgICAvL2NvbmRpdGlvbmFsIHNlbGZcblxuICAgIHJldHVybiB0aGlzLnBhdGhcbiAgICAgICggKHZhbCBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbCA6IFN0cmluZyh2YWwpLnNwbGl0KCcuJylcbiAgICAgICwgc2V0ICE9PSB2b2lkIDAgPyBzZXQgOiB7fVxuICAgICAgLCBmYWxzZVxuICAgICAgLCBmYWxzZVxuICAgICAgLCBmYWxzZVxuICAgICAgLCBzdGFtcCB8fCBmYWxzZSAvL3N0YW1weVxuICAgICAgLCB0cnVlXG4gICAgICAsICFub3RzZWxmXG4gICAgICApXG5cbiAgfSxcbiAgLy8gJ19jaGFuZ2V2b2JqJywgZnVuY3Rpb24odmFsLHN0YW1wKSB7XG4gIC8vICAgY29uc29sZS5lcnJvcih2YWwsc3RhbXApXG4gIC8vICAgcmV0dXJuIF9jaGFuZ2V2b2JqLmFwcGx5KHRoaXMsYXJndW1lbnRzKVxuICAvLyB9LFxuICAvLyAnX2hvb2snLCBmdW5jdGlvbih2YWwsIHBhcmFtKSB7XG4gIC8vICAgZm9yICh2YXIgaSBpbiBwYXJhbSkge1xuICAvLyAgICAgdGhpc1snXycgKyBpXSA9IHBhcmFtW2ldO1xuICAvLyAgIH1cbiAgLy8gfSwgLy9kb250IHVzZSB0aGlzIG5vdyBzbyBsZXRzIGFkZCB3aGVuIHVzZWRcbiAgX2FsLCBmdW5jdGlvbiggdmFsICkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdMRVRTIEdPIScsIF9zdWIsIHZhbCwgISF0aGlzW19zdWJdKVxuICAgIGlmKHRoaXNbX3N1Yl0pIHRoaXNbX3N1Yl0odmFsKVxuICAgIF9wcm90b0FkZExpc3RlbmVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICB9LFxuICBfcmwsIGZ1bmN0aW9uKCB2YWwsIG1hcmsgKSB7XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzW191bnN1Yl0pIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgX0wnLnJlZC5pbnZlcnNlLCBtYXJrKVxuICAgICAgdGhpc1tfdW5zdWJdKCBtYXJrIClcbiAgICB9XG4gICAgX3Byb3RvUmVtb3ZlTGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gIH1cbik7XG5cbi8vLS0tLS0tLURBVEEtLS0tLS0tLS1cbnV0aWwuZGVmaW5lKGRhdGEsIFxuICBfYWwsIGZ1bmN0aW9uKHZhbCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCcwLS0tLS0tLS0tPicsdmFsKVxuICAgIGlmKCF0aGlzLl9fYmxvY2spIF9jaGVja1N1YnNjcmlwdGlvbi5jYWxsKHRoaXMsIF9zdWIsIHZhbCk7XG4gICAgX3Byb3RvQWRkTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfSxcbiAgX3JsLCBmdW5jdGlvbih2YWwsIG1hcmspIHtcbiAgICAgLy8gY29uc29sZS5lcnJvcignMi4xIFJFTU9WRSBfTCcsIG1hcmssIHZhbCwgX3Vuc3ViKVxuICAgIGlmKCF0aGlzLl9fYmxvY2spIF9jaGVja1N1YnNjcmlwdGlvbi5jYWxsKHRoaXMsIF91bnN1YiwgbWFyayk7XG4gICAgX3Byb3RvUmVtb3ZlTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuKTtcblxuLy8tLS0tLS0tVmFsdWUtLS0tLS0tLS1cblxuLy8gdXRpbC5kZWZpbmUoVmFsdWUsIC8vdGVzdCBpcyB0aGlzIGltcGFjdHMgcGVyZm9ybWFuY2UgdG8gbXVjaFxuLy8gICBfYWwsIGZ1bmN0aW9uKHZhbCkge1xuLy8gICAgIC8vIGNvbnNvbGUubG9nKCcwLS0tLS0tLS0tPicsdmFsKVxuLy8gICAgIGlmKCF0aGlzLl9fYmxvY2spIF9jaGVja1N1YnNjcmlwdGlvbi5jYWxsKHRoaXMsIF9zdWIsIHZhbCk7XG4vLyAgICAgX3Byb3RvQWRkTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbi8vICAgfSxcbi8vICAgX3JsLCBmdW5jdGlvbih2YWwsIG1hcmspIHtcbi8vICAgICAgLy8gY29uc29sZS5lcnJvcignMi4xIFJFTU9WRSBfTCcsIG1hcmssIHZhbCwgX3Vuc3ViKVxuLy8gICAgIGlmKCF0aGlzLl9fYmxvY2spIF9jaGVja1N1YnNjcmlwdGlvbi5jYWxsKHRoaXMsIF91bnN1YiwgbWFyayk7XG4vLyAgICAgX3Byb3RvUmVtb3ZlTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbi8vICAgfVxuLy8gKTtcblxuXG5cblxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBWYWx1ZSA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlJylcbiAgLCBjb25maWcgPSByZXF1aXJlKCcuLi8uLi91dGlsL2NvbmZpZycpXG4gICwgcHJvY2VzcyA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxuICAsIHJhZiA9IHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicpXG4gICwgcG9zdHBvbmUgPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL2V2ZW50cy91dGlsJykucG9zdHBvbmVcbiAgLCB1YSA9IHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvdWEnKVxuXG5WYWx1ZS5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfbGFzdCcpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBWYWx1ZSgpXG4vL1RPRE86IC5wYXJhbXMgL3cgbGlzdGVuZXJzIVxuXG5jb25maWcuaGFzaFVybCA9IHVhLmRldmljZSA9PT0gJ3R2JyAmJiB1YS5wbGF0Zm9ybSA9PT0gJ2xnJyA/IGZhbHNlIDogIGNvbmZpZy5oYXNoVXJsXG5cbi8vIGhpc3RvcnkucHVzaFN0YXRlKHt9LCAnJywnJyApXG4vLyBoaXN0b3J5LmdvKDApXG4vLyBoaXN0b3J5LmJhY2soKVxuXG52YXIgcHN0YXRlID0gIWNvbmZpZy5oYXNoVXJsIC8vPSAhd2luZG93LkRFQlVHJCAmJiB3aW5kb3cuaGlzdG9yeSAmJiB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVcbiAgLCBjbnQgPSAwXG4gICwgdGltZWRTdGF0ZVxuICAsIHN0YXRlID0gcG9zdHBvbmUgKCBwc3RhdGUgPyBmdW5jdGlvbih2YWwpIHtcbiAgICAgIC8vbG9hZCBjdXJyZW50IHBhcmFtcyBhcyB3ZWxsXG4gICAgICAvL3NhbWUgZ29lcyBmb3IgdGhlIG90aGVyXG4gICAgICAvL3dlIGNvdWxkIGFkZCBhIGRlbGF5IGhlcmUhXG4gICAgICBocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWZcblxuICAgICAgY29uc29sZS5sb2codmFsLCAgdmFsLnJlcGxhY2UoLyAvZywgJysnKS5yZXBsYWNlKC9eI1xcLy8sICcnKS50b0xvd2VyQ2FzZSgpKVxuXG4gICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoIHt9LCB2YWwsIHZhbC5yZXBsYWNlKC8gL2csICcrJykucmVwbGFjZSgvXiNcXC8vLCAnJykudG9Mb3dlckNhc2UoKSApXG4gICAgfSA6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgZXhwb3J0cy5ibG9jayA9IHRydWVcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gJyMvJyArIHZhbC5yZXBsYWNlKC8gL2csICcrJykudG9Mb3dlckNhc2UoKVxuICAgICAgZXhwb3J0cy5ibG9jayA9IGZhbHNlXG4gICAgfSApXG4gICwgX3NldCA9IFZhbHVlLnByb3RvdHlwZS5fc2V0XG4gICwgcGFyc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghcHN0YXRlKSBcbiAgICAgIHtcbiAgICAgICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmLnNwbGl0KCcjJylcbiAgICAgICAgdmFyIHBhcmFtcyA9ICcnXG4gICAgICAgIGlmKCB1cmwgJiYgdXJsLmxlbmd0aCA9PT0gMSApIHtcbiAgICAgICAgICBwYXJhbXMgPSBxdWVyeSggdXJsWzBdIClcbiAgICAgICAgICB1cmxbMF0gPSB1cmxbMF0ucmVwbGFjZShwYXJhbXMsICcnKVxuICAgICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbiA9ICcjLycrcGFyYW1zXG4gICAgICAgICAgLy8gcmV0dXJuID0gJ3gnXG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coIHVybCwgKCB1cmwubGVuZ3RoID4gMSA/IHVybFsxXS5yZXBsYWNlKC9cXCsvZywgJyAnKSA6ICcgJyApLnNsaWNlKDEpLCBwYXJhbXMgKVxuICAgICAgICAvLyArcGFyYW1zXG4gICAgICAgIHJldHVybiAoIHVybC5sZW5ndGggPiAxID8gdXJsWzFdLnJlcGxhY2UoL1xcKy9nLCAnICcpIDogJyAnICkuc2xpY2UoMSkrcGFyYW1zXG4gICAgICB9IGVsc2UgXG4gICAgICB7XG4gICAgICAgIFxuICAgICAgICB2YXIgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgICAgaWYoIHVybCApIHtcbiAgICAgICAgICBwYXJhbXMgPSBxdWVyeSggdXJsIClcbiAgICAgICAgICB1cmwgPSB1cmwucmVwbGFjZShwYXJhbXMsICcnKVxuICAgICAgICAgIC8vIHdpbmRvdy5sb2NhdGlvbiA9ICcjLycrcGFyYW1zXG4gICAgICAgICAgLy8gcmV0dXJuID0gJ3gnXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gU3RyaW5nKHdpbmRvdy5sb2NhdGlvbi5ocmVmKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoU3RyaW5nKHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4pICsgJy8nLCAnJylcbiAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eI1xcLy8sICcnKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnICcpXG4gICAgICAgICAgICAgICB8fCAnJ1xuICAgICAgfVxuICAgIH1cbiAgLCBxdWVyeSA9IGZ1bmN0aW9uKCBzdHIgKSB7XG4gICAgICBpZighc3RyKSBzdHIgPSBwYXJzZSgpIHx8ICcnXG4gICAgICB2YXIgYXJyID0gc3RyLnNwbGl0KCc/JylcbiAgICAgICAgLCBsZW4gPSBhcnIubGVuZ3RoXG4gICAgICBzdHIgPSBsZW4gPiAxICYmIGFyclsgYXJyLmxlbmd0aCAtIDEgXSA/ICc/JythcnJbIGFyci5sZW5ndGggLSAxIF0gOiAnJ1xuICAgICAgcmV0dXJuIHN0clxuICAgIH1cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlXG5cbi8vVE9ETzogYmFjayBidG4gaGlqYWNrIChldmVudCBoaWphY2sgYWRkIHJhbmRvbSBwYXJhbSlcbi8vVE9ETzogdXNlIHJhZiBmb3IgdXBkYXRlc1xuZXhwb3J0cy52YWwgPSB7IFxuICBzdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdHIgPSBwYXJzZSgpXG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKCBxdWVyeSggc3RyICksICcnIClcbiAgfSxcbiAgcGFyYW1zOiB7XG4gICAgdmFsOiBmdW5jdGlvbigpIHsgcmV0dXJuIHF1ZXJ5KCkgfSxcbiAgICBkZWZlcjpmdW5jdGlvbiggdXBkYXRlLCBhcmdzICkge1xuXG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKSAvL21heWJlIG5vdD9cblxuICAgICAgdmFyIHZhbCA9IHRoaXMudmFsXG4gICAgICAgICwgcGFyYW1zXG4gICAgICAgICwgbmVzdGVkcGFyYW1zXG4gICAgICAgICwgY1xuXG4gICAgICBpZiggdmFsICYmIHZhbCE9PXRoaXMuX2xhc3QgKSB7XG4gICAgICAgIHRoaXMuX2xhc3QgPSB2YWxcbiAgICAgICAgcGFyYW1zID0gdmFsLnNsaWNlKDEpLnNwbGl0KCcmJylcbiAgICAgICAgbmVzdGVkcGFyYW1zID0ge31cbiAgICAgICAgZm9yKCB2YXIgaSBpbiBwYXJhbXMgKSB7XG4gICAgICAgICAgYyA9IHBhcmFtc1tpXS5zcGxpdCgnPScpXG4gICAgICAgICAgaWYoIGMubGVuZ3RoPjEgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuZXN0ZWRwYXJhbXNbY1swXV0gPSBjWzFdXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCd1cmw6IG5vIFtrZXldPVt2YWx1ZV0gZm9ybWF0IC0tIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbCA9IG5lc3RlZHBhcmFtc1xuICAgICAgfVxuICAgICAgcmFmKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKSB9KVxuICAgIH1cbiAgfSxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiggdiwgY3YgKSB7XG4gICAgcmV0dXJuIGN2XG4gIH0sXG4gIGRlZmVyOiBmdW5jdGlvbiggdXBkYXRlLCBhcmdzICkge1xuICAgIGlmKCBhcmdzWzFdICYmIGFyZ3NbMV1bMF0gPT09ICd1JyApIFxuICAgIHtcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICByYWYoIGZ1bmN0aW9uKCkge1xuICAgICAgICB1cGRhdGUoKVxuICAgICAgfSlcbiAgICB9IGVsc2UgXG4gICAge1xuICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICAgIHZhciBhID0gKCB0eXBlb2YgYXJnc1swXSA9PT0gJ3N0cmluZycgID8gYXJnc1swXSA6IGFyZ3NbMF0gJiYgYXJnc1swXS52YWwgfHwgdGhpcy52YWwgKVxuICAgICAgaWYoYSkgXG4gICAgICB7XG4gICAgICAgIGV4cG9ydHMuYmxvY2tzID0gY250XG5cbiAgICAgICAgc3RhdGUoIGEgKyB0aGlzLnBhcmFtcy52YWwgKVxuICAgICAgfVxuICAgICAgcmV0dXJuICB0cnVlXG4gICAgICAvL1RPRE86IHVwZGF0ZSggdHJ1ZSApIGJsb2NrcyBhbGwgY29uc2VjdXRpdmUgdXBkYXRlc1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cmxFdmVudChlKSB7XG4gIHZhciBzdGFtcFxuXG4gIGlmKCAhY29uZmlnLmhhc2hVcmwgfHwgZXhwb3J0cy5ibG9ja3MhPT1jbnQgKSBcbiAge1xuICAgIGNudCsrXG4gICAgc3RhbXAgPSAndScrY250XG4gICAgZXhwb3J0cy5jbGVhckNhY2hlKClcbiAgICBleHBvcnRzLnN0cmluZy5jbGVhckNhY2hlKCkgLy9tYXliZSBub3QgY2xlYXIgb24gc3RyaW5nP1xuICAgIC8vIGV4cG9ydHMuX3VwZGF0ZSggcGFyc2UoKSwgJ3VybCcgKVxuICAgIGV4cG9ydHMuc3RyaW5nLl91cGRhdGUoIGV4cG9ydHMuc3RyaW5nLnZhbCAsIHN0YW1wIClcbiAgICBleHBvcnRzLnBhcmFtcy5fdXBkYXRlKCBleHBvcnRzLnN0cmluZy52YWwsIHN0YW1wIClcbiAgICBleHBvcnRzLl91cGRhdGUoIGV4cG9ydHMuc3RyaW5nLnZhbCwgc3RhbXAgKVxuICAgIGV4cG9ydHMuX2xzdGFtcCA9IG51bGxcblxuICB9IGVsc2Uge1xuICAgIGNudCsrXG4gIH1cbn1cblxudXRpbC5kZWZpbmUoIGV4cG9ydHMsICd1cGRhdGUnLCBmdW5jdGlvbigpIHtcbiAgdXJsRXZlbnQoKVxufSlcblxudXRpbC5kZWZpbmUoIGV4cG9ydHMuc3RyaW5nLCAncmF3Jywge1xuICBnZXQ6ZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsLnJlcGxhY2UoIC8gL2csICcrJyApXG4gIH1cbn0pXG5cbmlmKCBjb25maWcuaGFzaFVybCApXG57XG4gIHdpbmRvdy5vbmhhc2hjaGFuZ2UgPSB1cmxFdmVudFxufVxuZWxzZVxue1xuICB3aW5kb3cub25wb3BzdGF0ZSA9IHVybEV2ZW50XG59XG4vL1RPRE86IGFkZCBwb3BzdGF0ZVxuXG4iLCIvKlxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbi8qXG4vKlxuICB1c2VyYWdlbnQgc25pZmZpbmcgaXMgbmV2ZXIgdXNlZCBmb3IgZmVhdHVyZSBkZXRlY3Rpb24sIGZvciBhIG11bHRpLXNjcmVlbiBhcHAgeW91IGRvIG5lZWQgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRldmljZSBhbHNvIHdoZW4gcnVubmluZyBpbiB0aGUgYnJvd3NlclxuICBoYXMgZmllbGRzIFYudWEucGxhdGZvcm0sIGRldmljZSwgYnJvd3NlciBhbmQgdmVyc2lvbi4gVGhpcyBpbXBsZW1lbnRhdGlvbiB3aGVuIGNvbXBpbGVkLCBpcyBvbmx5IDcwMCBieXRlc1xuKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4vKipcbiAqIHRlc3RcbiAqIHNlYXJjaCBmb3IgcmVnZXhwcyBpbiB0aGUgdXNlckFnZW50XG4gKiBmbiBpcyBhIG9uIHN1Y2NlcyBjYWxsYmFja1xuICogY2hlY2sgaHR0cDovL3d3dy51c2VyYWdlbnRzdHJpbmcuY29tLyB0byB0ZXN0IGZvciB1c2VyQWdlbnRzXG4gKiBAbWV0aG9kXG4gKi9cbiwgdGVzdCA9IGV4cG9ydHMudGVzdCA9IGZ1bmN0aW9uKCBfdWEsIGZuICkge1xuXG4gIGZvclxuICAoIHZhciB0ZXN0cyA9IHV0aWwuYXJnKCBhcmd1bWVudHMsIDEgKVxuICAgICAgLCBpID0gdGVzdHMubGVuZ3RoIC0gMVxuICAgICAgLCBxdWVyeSA9IHRlc3RzW2ldWzBdXG4gICAgOyBxdWVyeSAhPT0gdHJ1ZSAmJiAhbmV3IFJlZ0V4cCggcXVlcnkgKS50ZXN0KCBfdWEgKVxuICAgIDsgcXVlcnkgPSB0ZXN0c1stLWldWzBdXG4gIClcblxuICA7aWYoIGZuLnNsaWNlIHx8IGZuLmNhbGwoIHRoaXMsIHF1ZXJ5LCB0ZXN0c1tpXSApIClcbiAge1xuICAgIHRoaXNbZm5dID0gdGVzdHNbaV1bMV1cbiAgfVxuXG59XG4sIHBhcnNlID0gZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKF91YSwgb2JqKSB7XG5cbiAgaWYoICFfdWEgKVxuICB7XG4gICAgb2JqID0gZXhwb3J0c1xuICAgIF91YSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIDogJ25vIG5hdmlnYXRvcidcbiAgfVxuXG4gIF91YSA9IF91YS50b0xvd2VyQ2FzZSgpXG5cbiAgaWYoICFvYmogKSBvYmogPSB7fVxuXG4gIC8vIF91YSA9ICd3ZWJvczsgbGludXggLSBsYXJnZSBzY3JlZW4nXG5cbiAgdmFyIF9mZiA9ICdmaXJlZm94J1xuICAgICwgX2FuZHJvaWQgPSAnYW5kcm9pZCdcbiAgICAsIF9tb2JpbGUgPSAnLittb2JpbGUnXG4gICAgLCBfd2Via2l0ID0gJ3dlYmtpdCdcbiAgICAsIF9wcyA9ICdwbGF5c3RhdGlvbidcbiAgICAsIF94Ym94ID0gJ3hib3gnXG4gICAgLCBfbGludXggPSAnbGludXgnXG4gICAgLCBfY2FzdERldGVjdCA9ICdjcmtleSdcbiAgICAsIF9jaHJvbWVjYXN0ID0gJ2Nocm9tZWNhc3QnXG4gICAgLCBfdGFibGV0ID0gJ3RhYmxldCdcbiAgICAsIF93aW5kb3dzID0gJ3dpbmRvd3MnXG4gICAgLCBfcGhvbmUgPSAncGhvbmUnXG4gICAgLCBfaXBob25lVmVyc2lvblxuXG4gIHRlc3QuY2FsbFxuICAoIG9ialxuICAsIF91YVxuICAsIGZ1bmN0aW9uKCBxdWVyeSwgYXJyICkge1xuXG4gICAgICBvYmouYnJvd3NlciA9IGFyclsyXSB8fCBxdWVyeVxuXG4gICAgICB2YXIgX3YgPSBfdWEubWF0Y2hcbiAgICAgICggbmV3IFJlZ0V4cFxuICAgICAgICAoICcoKChbXFxcXC8gXXZlcnNpb258J1xuICAgICAgICArIGFyclswXVxuICAgICAgICArICcoPyEuK3ZlcnNpb24pKVtcXC8gXSl8IHJ2OikoWzAtOV17MSw0fVxcXFwuWzAtOV17MCwyfSknXG4gICAgICAgIClcbiAgICAgIClcblxuICAgICAgb2JqLnZlcnNpb24gPSBfdiA/IE51bWJlciggX3ZbNF0gKSA6IDBcbiAgICAgIG9iai5wcmVmaXggPSBhcnJbMV1cbiAgICAgIC8vVE9ETzogYWRkIHByZWZpeCBmb3Igb3BlcmEgdj4xMi4xNTtcbiAgICAgIC8vVE9ETzogd2luZG93cyBjaGVjayBmb3IgaWUgMTEgbWF5IGJlIHRvbyBnZW5lcmFsO1xuICAgIH1cbiAgLCBbIHRydWUsIF93ZWJraXQgXVxuICAsIFsgJ1xcXFwod2luZG93cycsICdtcycsICdpZScgXVxuICAsIFsgJ3NhZmFyaScsIF93ZWJraXQgXVxuICAsIFsgX2ZmLCAnTW96JyBdXG4gICwgWyAnb3BlcmEnLCAnTycgXVxuICAsIFsgJ21zaWUnLCAnbXMnLCAnaWUnIF1cbiAgLCBbICdjaHJvbWV8Y3Jpb3NcXC8nLCBfd2Via2l0LCAnY2hyb21lJyBdXG4gIClcblxuICAvKipcbiAgKiBwbGF0Zm9ybSBkZXRlY3Rpb25cbiAgKi9cbiAgdGVzdC5jYWxsXG4gICggb2JqXG4gICwgX3VhXG4gICwgJ3BsYXRmb3JtJ1xuICAsIFsgdHJ1ZSwgX3dpbmRvd3MgXVxuICAsIFsgX2xpbnV4LCBfbGludXggXVxuICAsIFsgJ2xnLnswLDN9bmV0Y2FzdCcsICdsZycgXSAvL1RPRE86cHJvcGFibHkgbmVlZCB0byBhZGQgbW9yZSFcbiAgLCBbIF9mZiArIF9tb2JpbGUsIF9mZiBdXG4gICwgWyAnbWFjIG9zIHgnLCAnbWFjJyBdXG4gICwgWyAnaXBob25lfGlwb2R8aXBhZCcsICdpb3MnIF1cbiAgLCBbIF94Ym94LCBfeGJveCBdXG4gICwgWyBfcHMsIF9wcyBdXG4gICwgWyBfYW5kcm9pZCwgX2FuZHJvaWQgXVxuICAsIFsgX3dpbmRvd3MsIF93aW5kb3dzIF1cbiAgLCBbIF9jYXN0RGV0ZWN0LCBfY2hyb21lY2FzdCBdXG4gICwgWyAnc21hcnQtdHY7fDtzYW1zdW5nO3NtYXJ0dHYnLCAnc2Ftc3VuZycgXSAvL1NtYXJ0VFYyMDEzXG4gIClcblxuICAvKipcbiAgKiBkZXZpY2UgZGV0ZWN0aW9uXG4gICovXG4gIHRlc3QuY2FsbFxuICAoIG9ialxuICAsIF91YVxuICAsICdkZXZpY2UnXG4gICwgWyB0cnVlLCAnZGVza3RvcCcgXVxuICAsIFsgX3dpbmRvd3MgKyAnLit0b3VjaHxpcGFkfCcgKyBfYW5kcm9pZCwgIF90YWJsZXQgXVxuICAsIFsgJ2lwaG9uZXwoJyArIF9hbmRyb2lkICsgX21vYmlsZSArICcpfCgnICsgX2ZmICsgX21vYmlsZSArICcpfCcgKyBfd2luZG93cyArICcgcGhvbmV8aWVtb2JpbGUnXG4gICAgLCBfcGhvbmVcbiAgICBdXG4gICwgWyBfeGJveCArICd8JyArIF9wcywgJ2NvbnNvbGUnIF1cbiAgLCBbICd0dnxzbWFydHR2fGdvb2dsZXR2fGFwcGxldHZ8aGJidHZ8cG92X3R2fG5ldGNhc3QudHZ8d2Vib3MuK2xhcmdlJywgJ3R2JyBdXG4gICwgWyBfY2FzdERldGVjdCwgX2Nocm9tZWNhc3QgXVxuICAsIFsgJ2FtYXpvbi1maXJlb3MnLCBfdGFibGV0IF1cbiAgKVxuXG4gIC8vVE9ETzogYW1hem9uIGZpcmV0diBhbmQgcGhvbmVcbiAgICAvLyBhbGVydCh3aW5kb3cuaW5uZXJXaWR0aCp3aW5kb3cuaW5uZXJIZWlnaHQgKyAgJyAgJysgNDE0ICogNzM2KVxuICBcbiAgLy80MTQgw5cgNzM2XG4gIHZhciBpcGhvbmU2cGx1cyA9IDQxNCAqIDczNlxuICBpZlxuICAoIG9iai5wbGF0Zm9ybSA9PT0gX2FuZHJvaWRcbiAgICAmJiAhdXRpbC5pc05vZGVcbiAgICAmJiBvYmouZGV2aWNlID09PSBfcGhvbmVcbiAgICAmJiB3aW5kb3cuaW5uZXJXaWR0aCp3aW5kb3cuaW5uZXJIZWlnaHQgPiBpcGhvbmU2cGx1c1xuICAgIC8vICYmIH5fdWEuaW5kZXhPZignY3Jvc3N3YWxrJylcbiAgKVxuICB7XG4gICAgb2JqLmRldmljZSA9ICd0YWJsZXQnXG4gIH1cblxuICByZXR1cm4gb2JqXG59XG5cbmlmKCAhdXRpbC5pc05vZGUgKSBcbnsgXG4gIHBhcnNlKClcbiAgLy9UT0RPOiB0aGlzIGlzIHZlcnkgdWdseSwgdHJ5IHRvIGZpbmQgYSBiZXR0ZXIgc29sdXRpb25cbiAgaWYoIHdpbmRvdy5fX3VhX18gKSBcbiAge1xuICAgIGZvciggdmFyIGZpZWxkIGluIHdpbmRvdy5fX3VhX18gKVxuICAgIHtcbiAgICAgIGV4cG9ydHNbZmllbGRdID0gd2luZG93Ll9fdWFfX1tmaWVsZF1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBwcm9wXG4gKiByZS13cml0ZXMganMgcHJvcGVydGllcyB0byB0aGVpciBjc3MgY291bnRlcnBhcnRcbiAqIGUuZy4gd2Via2l0VHJhbnNmb3JtIC0tPiAtd2Via2l0LXRyYW5zZm9ybVxuICogbm93IGl0cyBjb21tZW50ZWQgc2luY2UgaXRzIG5vdCBuZXNzZWNhcnkgeWV0XG4gKiBAbWV0aG9kXG4gKi9cbi8vIHRoaXMucHJvcCA9IGZ1bmN0aW9uKHN0cikge1xuLy8gIHJldHVybiBzdHIucmVwbGFjZSh0aGlzLnByZWZpeCwnLScrdGhpcy5wcmVmaXgrJy0nKS50b0xvd2VyQ2FzZSgpO1xuLy8gfVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyICBkYXRhID0gcmVxdWlyZSgnLi8nKVxuICAsIGJhc2UgPSByZXF1aXJlKCcuLi9iYXNlJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgZmxhZ3MgPSByZXF1aXJlKCcuLi92YWx1ZS9mbGFncy9kYXRhJylcbiAgLCB2T2JqZWN0ID0gcmVxdWlyZSgnLi4vb2JqZWN0JylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZCggZnVuY3Rpb24oYmFzZSwgZXh0ZW5zaW9ucywgbW9kZWxibGFja2xpc3QpIHtcblxuICAvLyB2YXIgX2JsYWNrbGlzdCA9IHV0aWwuYWRkKFsnZmxhZ3MnLCAncmVmJywgJ3BhcnNlJywgJ3BhcnNpbmcnXSwgbW9kZWxibGFja2xpc3QpLFxuICAgIHZhciBfY29tcGFyZSA9IHV0aWwuY29tcGFyZUFycmF5cyxcbiAgICBtZXRob2RzID0ge1xuICAgICAgX2RVcGRhdGU6IGZ1bmN0aW9uKG9iaiwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBpbnN0YW5jZXMsIGFyZ3gxLCBhcmd4MiApIHtcbiAgICAgICAgLy8gaWYod2luZG93LmhlcmUpIGNvbnNvbGUubG9nKCdYJyxzdGFtcClcbiAgICAgICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgICAgICAvLyRuZGF0YVxuICAgICAgICAgIC8vVE9ETzogdmVyeSBkaXJ0eSBmaXggZ2V0IHJpZCBvZiB0aGlzIVxuICAgICAgICAgIGlmKCBvYmogPT09ICckbmRhdGEnICl7XG4gICAgICAgICAgICB2YWwgPSBmcm9tXG4gICAgICAgICAgICBzdGFtcCA9IHJlbW92ZVxuICAgICAgICAgICAgZnJvbSA9IGFkZGVkXG4gICAgICAgICAgICByZW1vdmUgPSBvbGR2YWxcbiAgICAgICAgICAgIGFkZGVkID0gaW5zdGFuY2VzXG4gICAgICAgICAgICBvbGR2YWwgPSBhcmd4MVxuICAgICAgICAgICAgaW5zdGFuY2VzID0gYXJneDJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCchQCMhQCMhQCMhQCNAISMhQCMhQCMhQCMnLnJlZC5pbnZlcnNlKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHZhciBub24gPSAwXG4gICAgICAgICAgLy8gICAsIGNudCA9IDBcbiAgICAgICAgICAvLyBmb3IoIHZhciBpIGluIGFyZ3VtZW50cyApIFxuICAgICAgICAgIC8vIHtcbiAgICAgICAgICAvLyAgIGNudCsrXG4gICAgICAgICAgLy8gICBpZighYXJndW1lbnRzW2ldKSB7XG4gICAgICAgICAgLy8gICAgIG5vbisrXG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gICBjb25zb2xlLmxvZyggYXJndW1lbnRzW2ldIClcbiAgICAgICAgICAvLyB9XG4gICAgICAgICAgLy8gaWYobm9uID09PSBjbnQpIHtcbiAgICAgICAgICAvLyAgIGFsZXJ0KCdubyBhcmdzJylcbiAgICAgICAgICAvLyAgIHJldHVybiB0cnVlXG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLl9kICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMucGFyZW50O1xuICAgICAgICAgICAgd2hpbGUgKCF0aGlzLl9kICYmIHApIHtcbiAgICAgICAgICAgICAgaWYgKHAuX2QpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdTRVQgREFUQScpXG4gICAgICAgICAgICAgICAgdGhpcy5fZFNldChwLl9kLCB0cnVlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gcC5wYXJlbnQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHQgPSB0aGlzLFxuICAgICAgICAgICAgbW9kZWwgPSB0Lm1vZGVsLFxuICAgICAgICAgICAgZiA9IG1vZGVsLmZsYWdzLFxuXG4gICAgICAgICAgICAvLyBmID0gbW9kZWwgPyBtb2RlbC5mbGFncyA6IGZhbHNlIGJlIGNhcmVmdWxsIHdpdGggdXBkYXRlcyBpbiB2YWx1ZXMgdGhhdCBoYXZlIGRhdGFcblxuICAgICAgICAgICAgcGF0aCA9IHQuX2QgJiYgdC5fZC5fcGF0aCB8fCBbXSxcbiAgICAgICAgICAgIG5hbWUgPSAoZnJvbSB8fCAoZnJvbSA9ICh0Ll9kICYmIHQuX2QuX3VwZGF0ZU9yaWdpbikpICYmICEoZnJvbSA9PT0gdC5fZCAmJiAoZnJvbSA9IGZhbHNlKSkpICYmIGZyb20udXBkYXRlUGF0aCxcbiAgICAgICAgICAgIGZyb21QYXRoID0gZnJvbSAmJiBmcm9tLl9wYXRoLFxuICAgICAgICAgICAgbWV0aG9kID0gZnVuY3Rpb24oaSwgZmllbGQpIHtcblxuICAgICAgICAgICAgICB2YXIgc2VsZWN0LCBwYXNzLCBmciwgbGZpZWxkO1xuICAgICAgICAgICAgICAvLyBpZiggZmllbGQuX2ZsYWdbMl0uX190KSB7XG4gICAgICAgICAgICAgIC8vbXVsdGlwbGUgZmxhZ3MhXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0ZMQUcnLmludmVyc2UsIG5hbWUsIGZpZWxkLl9mbGFnKVxuICAgICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgICAgaWYoIWZpZWxkLl9mbGFnLmRhdGEpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdOTyBEQVRBIEZMQUcnLCBuYW1lLCBmaWVsZC5fZmxhZywgdmFsLCBvYmosIHJlbW92ZSwgYWRkZWQsIG9sZHZhbClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkLl9mbGFnLmRhdGFbMl07XG5cbiAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdEQVRBIFVQREFURScubWFnZW50YS5pbnZlcnNlLFxuICAgICAgICAgICAgICAgLy8gICAgICAnb2JqOicsIG9ialxuICAgICAgICAgICAgICAgLy8gICAgLCAndmFsOicsIHZhbFxuICAgICAgICAgICAgICAgLy8gICAgLCAnc3RhbXA6Jywgc3RhbXBcbiAgICAgICAgICAgICAgIC8vICAgICwgJ2Zyb206JywgZnJvbVxuICAgICAgICAgICAgICAgLy8gICAgLCAncmVtb3ZlOicsIHJlbW92ZVxuICAgICAgICAgICAgICAgLy8gICAgLCAnYWRkZWQ6JywgYWRkZWRcbiAgICAgICAgICAgICAgIC8vICAgICwgJ2ZpZWxkOicsIGZpZWxkXG4gICAgICAgICAgICAgICAvLyAgKVxuICAgICAgICAgICAgICAvLyB2YXIgdGVzdCA9IChpPT09J3RleHQnICYmIGZpZWxkID09PSAncmVhbC5kdXJhdGlvbicpXG4gICAgICAgICAgICAgIC8vIGlmKHRlc3QpIGNvbnNvbGUubG9nKGZpZWxkLGkpXG4gICAgICAgICAgICAgIC8vIGlmKHRlc3QpIHBhc3MgPSB0cnVlXG5cbiAgICAgICAgICAgICAgaWYgKGkgPT09ICdjb2xsZWN0aW9uJyAmJiB0Ll9jb2xGaWx0ZXIpIHJldHVyblxuICAgICAgICAgICAgICAvL2lmIG5vdCBvd24gY29sZmlsdGVyIC0tPiBoYW5kbGUgeW91cnNlbGYhO1xuICAgICAgICAgICAgICAvLyBpZiBkYXRhIGhhcyBjaGFuZ2VkIGNoYW5nZSBjb2xmaWx0ZXIgYWRuIHNlbmQgdXBkYXRlXG4gICAgICAgICAgICAgIC8vYmUgY2FyZWZ1bGwgL3cgY2hhbmdlcyE7IHRvbyBjcnVkZVxuXG4gICAgICAgICAgICAgIGlmIChmaWVsZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdQQVNTJy5pbnZlcnNlLG5hbWUpXG4gICAgICAgICAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZmllbGQucG9wKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobmFtZSwnPz8/JylcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+JyxmaWVsZCwgZmllbGQucG9wKVxuXG4gICAgICAgICAgICAgICAgZmllbGQgPSBmaWVsZC5jb25jYXQoKTtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSBmaWVsZC5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFsZmllbGQgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3QgPSB1dGlsLmdldCh0Ll9kLCBmaWVsZFtqXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3QgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgIGxmaWVsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGZpZWxkW2pdID0gZmllbGRbal0uc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRE8gRE8hJy5pbnZlcnNlLG5hbWUsIHQuX2QgJiYgdC5fZC5fdXBkYXRlT3JpZ2luKVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobmFtZSwgcGF0aCwgc2VsZWN0LCBvYmosIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgaW5zdGFuY2VzKVxuXG4gICAgICAgICAgICAgICAgZmllbGQgPSBmaWVsZC5zcGxpdCgnLicpXG5cbiAgICAgICAgICAgICAgICBzZWxlY3QgPSB1dGlsLmdldCh0Ll9kLCBmaWVsZClcblxuICAgICAgICAgICAgICAgIGlmKCFzZWxlY3QgJiYgdC5fZCAmJiB0Ll9kLmZyb20gJiYgZmllbGQgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTk8gU0VMRUNUJy5yZWQuaW52ZXJzZSwgdC5fZCApXG4gICAgICAgICAgICAgICAgICBzZWxlY3QgPSB1dGlsLmdldCh0Ll9kLmZyb20sIGZpZWxkKVxuICAgICAgICAgICAgICAgICAgLy8gaWYoc2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgICAvLyAgIC8vIGNvbnNvbGUubG9nKCdGT1VORCBTRUxFQ1QnLmdyZWVuLmludmVyc2UsIHNlbGVjdClcbiAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB9IFxuXG4gICAgICAgICAgICAgICAgaWYoc2VsZWN0ICYmIGZyb20gJiYgZnJvbS5fX3QgPT09IDQpIGxmaWVsZCA9IHRydWUgLy90ZXN0IGRpdCBvZiBoZXQgYWxsZXMgc2xvdyBtYWFrdFxuXG4gICAgICAgICAgICAgICAgLy8gaWYodGVzdCYmc2VsZWN0KSBjb25zb2xlLmxvZyhzZWxlY3QuX3ZhbClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghcGFzcyAmJiBmcm9tKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndGVzdGluZy4uLi4/JywgbmFtZSwgZnJvbSwgc2VsZWN0LCBsZmllbGQpXG4gICAgICAgICAgICAgICAgLy8gaWYodGVzdCkgY29uc29sZS5sb2cobmFtZSwgc2VsZWN0LCBsZmllbGQsIGZyb20pO1xuXG4gICAgICAgICAgICAgICAgZnIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHZhciBmcm9tRnJvbVxuXG4gICAgICAgICAgICAgICAgaWYgKCBmcm9tID09PSBzZWxlY3QgfHwgKCBmcm9tRnJvbSA9IGZyb20uZnJvbSApID09PSBzZWxlY3QgKSB7XG4gICAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHQuX2QuX2ZpbHRlciAmJiBzZWxlY3QgJiYgc2VsZWN0Ll9hbmNlc3Rvcihmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy9maWVsZCBvb2sgdm9vciBhcnJheXMhO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsZmllbGQpIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZ290IGxmaWVsZCEhISEnKVxuXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG4gPSAwOyBuIDwgZmllbGQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAobmFtZSAmJiBfY29tcGFyZShuYW1lLCBmaWVsZFtuXSkgfHwgZmllbGRbbl1bMF0gPT09IG5hbWVbMF0gJiYgdXRpbC5nZXQodmFsLCBmaWVsZFtuXS5jb25jYXQoKS5zaGlmdCgpKSkgXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKF9jb21wYXJlKHBhdGguY29uY2F0KGZpZWxkW25dKSwgZnJvbVBhdGgpIHx8IF9jb21wYXJlKGZpZWxkW25dLCBmcm9tUGF0aCkpKSBcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0hFUkU/Jy5jeWFuLmludmVyc2UsICdcXG5cXG5cXG4nLCBzZWxlY3QuZnJvbS5yYXcsICd2YWw6J1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAsIHZhbCwgJ2ZpZWxkOicsIGZpZWxkLCAnZm4nLCBmaWVsZFtuXSwgJ246JywgbiwgJ2NoZWNrIGZpZWxkOicsIHZhbCAmJiB2YWxbZmllbGRbbl1dLCAncmVmOicsIHZhbC5mcm9tKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NvbWluZyB0cnVnaCcsIHNlbGVjdCAmJiBmcm9tLl92YWwgIT09IG51bGwgJiYgdmFsLCBmaWVsZFtuXVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAsIHNlbGVjdCAmJiBmcm9tLl92YWwgIT09IG51bGwgJiYgdmFsICYmICggdmFsW2ZpZWxkW25dXSB8fCB2YWwuX190ID09PSA0ICYmIHZhbC5mcm9tW2ZpZWxkW25dXSApIClcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVE9ETzogbmVlZCB0byBhZGQgbW9yZSBnYXVyZGluZyBmb3IgdmFsLiRwYXRoIGNoZWNrIGlmIHRoaXMgaXMgY2xvdWQgYW5kIHJlZlxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzZWxlY3QgJiYgZnJvbS5fdmFsICE9PSBudWxsICYmIHZhbCAmJiAodmFsW2ZpZWxkW25dXSB8fCB2YWwuJHBhdGggfHwgdmFsLl9fdCA9PT0gNCkgJiYgKHNlbGVjdC5fYW5jZXN0b3IoZnJvbSkgfHwgc2VsZWN0LmZyb20uX2FuY2VzdG9yKCBmcm9tRnJvbSApICApKSAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmFsLCBmaWVsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICctLS0nLCBzZWxlY3QsIHZhbCwgZmllbGQsIGZyb20sICdmcm9tUGF0aDonICwgZnJvbVBhdGggKVxuXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbD09PW51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBpZihERUJVRyQpIHQuX2QuREVCVUckbG9nKCdkYXRhL2Jhc2UgLS0tPiBFUlJPUiB2YWwgaXMgbnVsbCAgLS0tPicrdC5fZC5fcmVtb3ZlZCApXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZih2YWwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1xcblxcblxcbiB1bmRlZmluZWQgd2hhdCB0byBkbyBub3c/JywgYXJndW1lbnRzLHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwYXNzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZSAmJiBfY29tcGFyZShuYW1lLCBmaWVsZCkgfHwgZmllbGRbMF0gPT09IG5hbWUgJiYgbmFtZVswXSAmJiB1dGlsLmdldCh2YWwsIGZpZWxkLmNvbmNhdCgpLnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwYXRoICYmIChfY29tcGFyZShwYXRoLmNvbmNhdChmaWVsZCksIGZyb21QYXRoKSB8fCBfY29tcGFyZShmaWVsZCwgZnJvbVBhdGgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgIGZyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VsZWN0ICYmICh2YWxbZmllbGRbMF1dKSAmJiBzZWxlY3QuX2FuY2VzdG9yICYmIHNlbGVjdC5fYW5jZXN0b3IoZnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWwsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoIHQuX19jaGVja0tleXNfXyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbGV0cyBjaGVja2ogdGhlIGtleXMhJylcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggZmllbGQsIG5hbWUsIHZhbCwgcGF0aCwgc2VsZWN0LCB2YWxbZmllbGRbMF1dLCBmcm9tLCB0aGlzIClcbiAgICAgICAgICAgICAgICAgICAgICBmb3IoIHZhciBrZXkkIGluIHQuX19jaGVja0tleXNfXyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCBmaWVsZCA9PT0gdC5fX2NoZWNrS2V5c19fW2tleSRdIHx8IGZpZWxkWzBdID09PSB0Ll9fY2hlY2tLZXlzX19ba2V5JF0gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdtYXliZT8/ISFAIyFAJywgaSwgdC5fX2NoZWNrS2V5c19fW2tleSRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbCwgZmllbGRbMF0sIGZyb20pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1BBU1M+Pj4+Pj4+Pj4/Jy5tYWdlbnRhLmludmVyc2UsIHBhc3MgPyAnT0shJy5ncmVlbi5pbnZlcnNlIDogJ05PIScucmVkLmludmVyc2UgIFxuICAgICAgICAgICAgICAvLyAgICwgJ3ZhbDonLmJsdWUsIHZhbFxuICAgICAgICAgICAgICAvLyAgICwgJ29iai5fcGF0aDonLmJsdWUsIG9iaiAmJiBvYmouX3BhdGhcbiAgICAgICAgICAgICAgLy8gICAsICdmaWVsZDonLmJsdWUsIGZpZWxkXG4gICAgICAgICAgICAgIC8vICAgLCAnZnJvbVBhdGg6Jy5ibHVlLCBmcm9tUGF0aFxuICAgICAgICAgICAgICAvLyAgICwgJ2Zyb206Jy5ibHVlLCBmcm9tXG4gICAgICAgICAgICAgIC8vICAgLCAnc2VsZWN0Jy5ibHVlLCBzZWxlY3RcbiAgICAgICAgICAgICAgLy8gICApXG5cbiAgICAgICAgICAgICAgLy8gaWYoISBwYXNzICYmIClcblxuICAgICAgICAgICAgICAvLyBwYXNzID0gdHJ1ZVxuXG4gICAgICAgICAgICAgIC8vfHwgcmVtb3ZlIFxuXG4gICAgICAgICAgICAgIGlmIChwYXNzIHx8IHJlbW92ZSB8fCAoaW5zdGFuY2VzIHx8IHJlbW92ZSB8fCBzZWxlY3QgIT09IHZvaWQgMCkgJiYgKCAhZnIgfHwgcmVtb3ZlID09PSAxKSkge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3VwZGF0aW5nIScuY3lhbi5pbnZlcnNlLCBpLCB2YWwsIGluc3RhbmNlcywgcmVtb3ZlLCBzZWxlY3QsIGZyLCBmcm9tKVxuICAgICAgICAgICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgICAgICAgICAgLy9zdGFtcCBtZWVnZXZlbj8/Pz9cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJ0ZST00hISEhIScuZ3JlZW4uaW52ZXJzZSwgZnJvbSApXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sXG4gICAgICAgICAgICAgICAgdFtpXS5fdXBkYXRlKHZhbCwgZmFsc2UsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgIWluc3RhbmNlcywgdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgICAgICAvL2FkZCBhZHZhbmNlZCBtb2RlbHMgKGxpa2Ugb24gd2Vic2l0ZSlcbiAgICAgICAgICAgIC8vbm90IHRlc3RlZCBhbmQgc3RpbGwgcHJldHR5IGJyb2tlblxuICAgICAgICAgICB2YXIgcGFyc2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fZCkge1xuICAgICAgICAgICAgICB2YXIgdCA9IHRoaXMsIGFcbiAgICAgICAgICAgICAgLy9pZiBhZGRlZCBvciBmaXJzdCBydW5cbiAgICAgICAgICAgICAgdC5tb2RlbC52YWwgLy9zZXQgX2NhbGxlclxuICAgICAgICAgICAgICAvLyBpZiAobW9kZWwuZmllbGQpIGNvbnNvbGUubG9nKCc/Pz8/JywgdGhpcy5maWVsZCwgbW9kZWwuZmllbGQpXG5cbiAgICAgICAgICAgICAgaWYgKG1vZGVsLmZpZWxkKSBhID0gdXRpbC5nZXQodC5fZCwgbW9kZWwuZmllbGQudmFsKVxuICAgICAgICAgICAgICBpZiAobW9kZWwuX3ZhbCkgYSA9IG1vZGVsLl92YWwuY2FsbCh0LCBhIHx8IHQuX2QpIHx8IGFcbiAgICAgICAgICAgICAgaWYgKGEgJiYgdC5fZCAhPT0gYSkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnBhcnNpbmcgPSB0cnVlXG4gICAgICAgICAgICAgICAgaWYobW9kZWwuZmllbGQpIHRoaXMubW9kZWxQYXJzZWQgPSBtb2RlbC5maWVsZC52YWxcbiAgICAgICAgICAgICAgICB0aGlzLl9kU2V0KGEpXG4gICAgICAgICAgICAgICAgbW9kZWwucGFyc2luZyA9IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyc2VyLmNhbGwodClcbiAgICAgICAgICBpZiAoaW5zdGFuY2VzKSB0LmVhY2hJbnN0YW5jZShwYXJzZXIsICdtb2RlbCcpXG4gICAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICBpZiAoZiAmJiAoaW5zdGFuY2VzIHx8IHQuX2QpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpIGluIGYpIHtcbiAgICAgICAgICAgICAgaWYgKCFmW2ldLl9fdCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gZltpXS5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmIChtZXRob2QoaSwgZltpXVtqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1ldGhvZChpLCBmW2ldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgaWYodGhpcy5tb2RlbC5jb21wbGV0ZSkgdGhpcy5tb2RlbC5jb21wbGV0ZS5fdmFsLmNhbGwodGhpcyxkYXRhKVxuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBfZFNldDogZnVuY3Rpb24odmFsLCBkZnJvbSkge1xuXG5cbiAgICAgICAgLy8gaWYodmFsKSB7XG4gICAgICAgIC8vICAgY29uc29sZS5sb2coJ19Ec2V0Jy5jeWFuLmludmVyc2UsIHZhbC5fcGF0aCwgZGZyb20pXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gaWYodGhpcy5tb2RlbC5fZmxhZyAmJiB0aGlzLm1vZGVsLl9mbGFnLnByb2Nlc3MgJiYgIXRoaXMuX19wcm9jZXNzaW5nKSB7XG4gICAgICAgIC8vICAgY29uc29sZS5sb2coJ29vMicpXG4gICAgICAgIC8vICAgdGhpcy5tb2RlbC5fdXBkYXRlKClcbiAgICAgICAgLy8gICByZXR1cm5cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmKHRoaXMubW9kZWwuX2ZsYWcgJiYgdGhpcy5tb2RlbC5fZmxhZy5kZWZlciAgJiYgIXRoaXMuX19wcm9jZXNzaW5nKSB7XG4gICAgICAgICAgdGhpcy5fX3BGbGFnID0gWyB2YWwsIGRmcm9tIF1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIC8vZGZyb20gbW9ldCBuaWV0IG5vZyBlZW4gc3Vic2NyaWJlIGRvZW4hIC0tIGFscyBoZXQgZ29lZCBpcyBpcyB6biBwYXJlbnQgYWwgc3Vic2NyaWJlZFxuXG4gICAgICAgIGlmICh0aGlzLl9kICYmIHRoaXMuX2QuX190KSB0aGlzLl9kLnJlbW92ZUxpc3RlbmVyKHRydWUsIHRoaXMpXG4gICAgICAgIHRoaXMuX2QgPSB2YWxcbiAgICAgICAgaWYgKGRmcm9tKSB0aGlzLl9kZnJvbSA9IHRydWVcbiAgICAgICAgdGhpcy5fZExpc3RlbigpXG5cblxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgICB9LFxuICAgICAgX2RMaXN0ZW46IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0hFRUVFRUUnLCB0aGlzLm1vZGVsKVxuXG4gICAgICAgIC8vIGlmKHRoaXMubW9kZWwuX2ZsYWcgJiYgdGhpcy5tb2RlbC5fZmxhZy5wcm9jZXNzICYmICF0aGlzLl9fcHJvY2Vzc2luZykge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCdvbzInKVxuICAgICAgICAvLyAgIHRoaXMubW9kZWwuX3VwZGF0ZSgpXG4gICAgICAgIC8vICAgcmV0dXJuXG4gICAgICAgIC8vIH1cblxuICAgICAgICAvL2hpZXIgZ2FhbiB3ZSBzIGZmdGplcyB3ZXJrZW4gbWV0IGVhY2hcblxuICAgICAgICAvLyB0aGlzLl9kZnJvbSA9IHRydWU7XG4gICAgICAgIHZhciBfdGhpc1xuXG4gICAgICAgIGlmICh0aGlzLm1vZGVsICYmIHRoaXMuX2QgJiYgdGhpcy5fZCBpbnN0YW5jZW9mIHZPYmplY3QpIFxuICAgICAgICB7IC8vdGhpcyBtb2RlbCBtYXliZSBub3QgbmVzc2VjYXJ5P1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tPicuY3lhbi5pbnZlcnNlLCB0aGlzLl9kIClcblxuICAgICAgICAgIHRoaXMuX2QuYWRkTGlzdGVuZXIoW3RoaXMuX2RVcGRhdGUsIHRoaXNdKVxuXG4gICAgICAgICAgX3RoaXMgPSB0aGlzXG4gICAgICAgICAgXG4gICAgICAgICAgLy9oaWVyIGZpbHRlcmVuIG9wIGNsb3VkRGF0YSAtLS0gb29rIHdlcmtlbiB2YW51aXQgcmVtb3ZlISEhXG4gICAgICAgICAgICAvL25ldmVyIGRvIGZvciBjbG91ZCBkYXRhXG4gICAgICAgICBcbiAgICAgICAgICBpZiggIXRoaXMuX2QuY2xvdWQgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2QuZWFjaChcbiAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgIF90aGlzLl9fY2hlY2tLZXlzX18gPSB0cnVlXG5cbiAgICAgICAgICAgICAgICBpZih0aGlzLl9fdCA9PT0gNCApIHRoaXMuYWRkTGlzdGVuZXIoWyBfdGhpcy5fZFVwZGF0ZSwgX3RoaXMsICckbmRhdGEnLCB0aGlzIF0pIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vZXZlbnR1ZWVsIC52YWwgZ2VicnVpa2VuIHZvb3IgVmFsdWVzICphd2VzanVtZSFcbiAgICAgICAgICAvL2V2ZW50dWVlbCBoaWVyIGRpbmdlbiBhZGRlbiBhYW4gbW9kZWxcblxuICAgICAgICB9IFxuICAgICAgICBlbHNlIGlmKCB0aGlzLm1vZGVsICYmIHRoaXMuX2QgKSBcbiAgICAgICAge1xuICAgICAgICAgIGZvciggdmFyIGtleSBpbiB0aGlzLl9kICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYoIXRoaXMuX19jaGVja0tleXNfXyB8fCB0aGlzLl9fY2hlY2tLZXlzX18gPT09IHRydWUpIHRoaXMuX19jaGVja0tleXNfXyA9IFtdXG4gICAgICAgICAgICBpZiggdGhpcy5fZFtrZXldIGluc3RhbmNlb2Ygdk9iamVjdCApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmKCF0aGlzLl9fY2hlY2tLZXlzX18ucHVzaCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3h4eHh4eCcsIHRoaXMsIHRoaXMuX19jaGVja0tleXNfXywga2V5LCB0aGlzLl9kKVxuICAgICAgICAgICAgICAgIGRlYnVnZ2VyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fX2NoZWNrS2V5c19fLnB1c2goIGtleSApXG4gICAgICAgICAgICAgIHRoaXMuX2Rba2V5XS5hZGRMaXN0ZW5lcihbIHRoaXMuX2RVcGRhdGUsIHRoaXMsICckbmRhdGEnLCBrZXkgXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVwZGF0ZURhdGE6IGZ1bmN0aW9uKGluc3RhbmNlcykge1xuXG4gICAgICAgIGlmKHRoaXMubW9kZWwuX2ZsYWcgJiYgdGhpcy5tb2RlbC5fZmxhZy5kZWZlciAmJiAhdGhpcy5fX3Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnb28yJylcbiAgICAgICAgICB0aGlzLl9fcEZsYWdVID0gWyBpbnN0YW5jZXMgXVxuICAgICAgICAgIHRoaXMubW9kZWwuX3VwZGF0ZSgpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJyFET0lUIHVwZGF0ZURhdGEnLmN5YW4uaW52ZXJzZSlcblxuICAgICAgICB0aGlzLl9kVXBkYXRlKHRoaXMuX2QsIHZvaWQgMCwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBpbnN0YW5jZXMpXG4gICAgICB9XG4gICAgfSxcbiAgICBleHRlbmQgPSBmdW5jdGlvbihpKSB7XG4gICAgICBiYXNlLmV4dGVuZCh7XG4gICAgICAgIG5hbWU6IGksXG4gICAgICAgIHR5cGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogKGV4dGVuc2lvbnMgJiYgZXh0ZW5zaW9uc1tpXSkgPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBtZXRob2RzW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgZXh0ZW5zaW9uc1tpXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9IDogbWV0aG9kc1tpXVxuICAgICAgfSk7XG4gICAgfTtcbiAgZm9yICh2YXIgaSBpbiBtZXRob2RzKSB7XG4gICAgZXh0ZW5kKGkpXG4gIH1cbiAgYmFzZS5leHRlbmQoe1xuICAgIG5hbWU6ICdtb2RlbCcsXG4gICAgY2FjaGU6IGZhbHNlLFxuICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG5cbiAgICAgIGlmKHRoaXMuX19wRmxhZyB8fCB0aGlzLl9fcEZsYWdVKSB7XG4gICAgICAgIC8qXG4gICAgICAgIFRPRE86IHRlc3QgZGVmZXIgYmV0dGVyISEhXG4gICAgICAgIHRoaXMuX19wRmxhZyA9IFsgdmFsIF1cbiAgICAgICAgdGhpcy5fX3BGbGFnVSA9IFsgdHJ1ZSBdXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuX19wcm9jZXNzaW5nID0gdHJ1ZVxuICAgICAgICB0aGlzLm1vZGVsLnBhcnNpbmcgPSBmYWxzZVxuICAgICAgICBpZih0aGlzLl9fcEZsYWcpIHtcbiAgICAgICAgICB0aGlzLl9kU2V0LmFwcGx5KHRoaXMsdGhpcy5fX3BGbGFnKVxuICAgICAgICB9XG4gICAgICAgIC8vc3Vic2NyaWJlIGhlbGVtYWFsIGZ1Y2tlZCBtZXQgZmllbGQgZXJiaWpcbiAgICAgICAgaWYodGhpcy5fX3BGbGFnVSkge1xuICAgICAgICAgIHRoaXMudXBkYXRlRGF0YS5hcHBseSh0aGlzLHRoaXMuX19wRmxhZ1UpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3BGbGFnVSA9IG51bGxcbiAgICAgICAgdGhpcy5fX3BGbGFnID0gbnVsbFxuICAgICAgICB0aGlzLl9fcHJvY2Vzc2luZyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYodmFsLmZpZWxkICYmIHZhbC5maWVsZC52YWwgIT09IHRoaXMubW9kZWxQYXJzZWQpIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLm1vZGVsUGFyc2VkICYmIHRoaXMubW9kZWxQYXJzZWQuc3BsaXQoJy4nKVxuICAgICAgICAgICwgcGFyZW50XG4gICAgICAgIHRoaXMubW9kZWxQYXJzZWQgPSBudWxsXG4gICAgICAgIGlmKHRoaXMuX2QpIHtcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9kXG4gICAgICAgICAgaWYoYSkge1xuICAgICAgICAgICAgZm9yKHZhciBpID0gYS5sZW5ndGgtMTsgaSA+PTAgOyBpLS0pIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHBhcmVudCkge1xuICAgICAgICAgICAgICB0aGlzLl9kU2V0KHBhcmVudClcbiAgICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhKHRydWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGF0YSh0cnVlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vZGVsUGFyc2VkID0gbnVsbFxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmKCB0aGlzLl9kIClcbiAgICAgIHtcbiAgICAgICAgaWYgKCB0aGlzLl9kLl9fdCApICBcbiAgICAgICAge1xuICAgICAgICAgIHRoaXMuX2QucmVtb3ZlTGlzdGVuZXIoIHZvaWQgMCwgdGhpcyApXG5cbiAgICAgICAgICBpZiggIXRoaXMuX2QuY2xvdWQgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgICAgIHRoaXMuX2QuZWFjaChcbiAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgIC8vIF90aGlzLl9fY2hlY2tLZXlzX18gPSB0cnVlXG4gICAgICAgICAgICAgICAgaWYodGhpcy5fX3QgPT09IDQgKSB0aGlzLnJlbW92ZUxpc3RlbmVyKCB2b2lkIDAsIF90aGlzICkgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKCB0aGlzLl9fY2hlY2tLZXlzX18pIFxuICAgICAgICB7XG4gICAgICAgICAgZm9yKCB2YXIga2V5JCBpbiB0aGlzLl9fY2hlY2tLZXlzX18gKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiggdGhpcy5fZFt0aGlzLl9fY2hlY2tLZXlzX19ba2V5JF1dIGluc3RhbmNlb2Ygdk9iamVjdCApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRoaXMuX2RbdGhpcy5fX2NoZWNrS2V5c19fW2tleSRdXS5yZW1vdmVMaXN0ZW5lciggdm9pZCAwLCB0aGlzIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcGFyZW50OiBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAvLyAgIGlmKCBwYXJlbnQuZGF0YSAmJiAoIXBhcmVudC5wYXJlbnQgfHwgcGFyZW50LnBhcmVudC5kYXRhIT09cGFyZW50LmRhdGEpICkge1xuXG4gICAgLy8gICAgIGNvbnNvbGUuZXJyb3IoJ1dURj8nKVxuXG4gICAgLy8gICAgIHRoaXMuZGF0YSA9IHBhcmVudC5kYXRhXG4gICAgLy8gICB9XG4gICAgLy8gfVxuICB9LCB7XG4gICAgbmFtZTogJ2RhdGEnLFxuICAgIHR5cGU6IGZhbHNlLFxuICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCc/Jyx2YWwpXG4gICAgICBpZiggdGhpcy5fZCA9PT0gdmFsICkgcmV0dXJuXG5cbiAgICAgIC8vIGlmKCF0aGlzLm1vZGVsKSB0aGlzLm1vZGVsID0ge30gLy9kaXQgbWV0IGhldCBub29pdCBzZXR0ZW4gdmFuIGZtb2RlbCBzY2hlZWwgb3Agc2hvdyBhbCAzLzkgc3Vic2NyaXB0aW9uc1xuICAgICAgLy9udSBub2cgc2hhcmVkIHN1YnMgbWFrZW4gLS0gJ3Nob3dzJyAob29rIG1ldGVlbiBwcm9jZXNzKSBlbiBkYW4gd29yZCB0aGV0IGFscyBoZXQgZ29lZCBpcyBub2cgZWVuIHN0dWsgbWluZGVyXG4gICAgXG4gICAgICAvLyB0aGlzLm1vZGVsID0ge30gLy9wYXMgb3AgbWV0IGRlemVcbiAgICAgIC8vIGNvbnNvbGUubG9nKCc/MicpXG5cbiAgICAgIGlmKCB0aGlzLm1vZGVsLl9mbGFnICYmIHRoaXMubW9kZWwuX2ZsYWcuZGVmZXIgKSB7XG4gICAgICAgIHRoaXMuX19wRmxhZyA9IFsgdmFsIF1cbiAgICAgICAgdGhpcy5fX3BGbGFnVSA9IFsgdHJ1ZSBdXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCchQCMhQCMhQCMgT09PTycucmVkKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gY29uc29sZS5lcnJvcignISEhISFNT0RFTCAtLSBkaXQgbW9ldCB6b3ZlZWwgbW9nZWxpamsgZ2VyZWR1Y2VkJywgdGhpcy5tb2RlbClcblxuICAgICAgdGhpcy5tb2RlbC5wYXJzaW5nID0gZmFsc2VcbiAgICAgIHRoaXMuX2RTZXQodmFsKVxuXG4gICAgICAvL3N1YnNjcmliZSBoZWxlbWFhbCBmdWNrZWQgbWV0IGZpZWxkIGVyYmlqXG4gICAgICB0aGlzLnVwZGF0ZURhdGEodHJ1ZSlcblxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kXG4gICAgfVxuICB9KVxufSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBNYXJjdXMgQmVzamVzLCBtYXJjdXNAdmlnb3VyLmlvXG4gKi9cbnZhciBkYXRhID0gcmVxdWlyZSgnLi8nKSxcbiAgY250ID0gMCxcbiAgaGFuZGxlVGVzdCA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odGVzdCwgc3Vic09iaikge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2hhbmRsZVRlc3QhJywgdGVzdClcbiAgICBpZiAodGVzdCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh0ZXN0KTtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB2YXIga2V5ID0ga2V5c1swXVxuICAgICAgICAgICwgdmFsY2hlY2sgPSBoYW5kbGVGaWVsZChrZXksIHRlc3Rba2V5XSwgc3Vic09iailcbiAgICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN1YnNPYmouX2NoZWNrID0gZnVuY3Rpb24oZG9jKXtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVEVTVElORycsIHRlc3QsIGRvYyAmJiBkb2MucmF3KVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdjaGVja2luZyBmb3Iga2V5Jywga2V5KVxuICAgICAgICAgIHZhciB2YWwgPSBnZXRWYWx1ZShkb2MpXG4gICAgICAgICAgcmV0dXJuIHZhbGNoZWNrKHZhbClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGxpc3QgPSBbXSxcbiAgICAgICAgICBrZXk7XG4gICAgICAgIGZvciAodmFyIGsgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGsgPCBsOyBrKyspIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2tdO1xuICAgICAgICAgIGxpc3QucHVzaChoYW5kbGVGaWVsZChrZXksIHRlc3Rba2V5XSwgc3Vic09iaikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdWJzT2JqLl9jaGVjayA9IG1ha2VBTkQobGlzdCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdWJzT2JqLl9jaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZ2V0VmFsdWUoZG9jKSA9PT0gdGVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuZnVuY3Rpb24gaGFuZGxlRmllbGQoa2V5LCB2YWx1ZSwgc3Vic09iaikge1xuICAvLyBjb25zb2xlLndhcm4oJ2hhbmRsZUZpZWxkIFsnLCBrZXksICddIHZhbHVlJywgdmFsdWUpXG4gIHZhciBjaGVjaztcbiAgc3dpdGNoIChrZXkpIHtcbiAgICBjYXNlICckbm90JzpcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICB2YXIgZm9sbG93ID0gaGFuZGxlVGVzdCh2YWx1ZSwgc3Vic09iaik7XG4gICAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGZvbGxvdyhkb2MpID09PSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGRvYyAhPT0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmUnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYyAhPT0gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGFuZCc6XG4gICAgICB2YXIgbGlzdCA9IG1ha2VMaXN0KHZhbHVlLCBzdWJzT2JqKTtcbiAgICAgIGNoZWNrID0gbWFrZUFORChsaXN0KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuYW5kJzpcbiAgICAgIHZhciBsaXN0ID0gbWFrZUxpc3QodmFsdWUsIHN1YnNPYmopO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0W2ldKGRvYykgPT09IGZhbHNlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG9yJzpcbiAgICAgIHZhciBsaXN0ID0gbWFrZUxpc3QodmFsdWUsIHN1YnNPYmopO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0W2ldKGRvYykpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbm9yJzpcbiAgICAgIHZhciBsaXN0ID0gbWFrZUxpc3QodmFsdWUsIHN1YnNPYmopO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGlmIChsaXN0W2ldKGRvYykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckZXZlcnknOlxuICAgICAgc3Vic09iai5zZXQoJyQnLCB7fSk7XG4gICAgICAvLyBzdWJzT2JqLiQgPSB7XG4gICAgICAvLyAgIF91cDogc3Vic09ialxuICAgICAgLy8gfTtcbiAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBzdWJzT2JqLiQpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgaWYgKGRvYyAmJiBkb2MuX190IDwgMykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgIGRvYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFmb2xsb3codGhpcykpIHJldHVybiAhKHJlc3VsdCA9IGZhbHNlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuZXZlcnknOlxuICAgICAgc3Vic09iai5zZXQoJyQnLCB7fSk7XG4gICAgICAvLyBzdWJzT2JqLiQgPSB7XG4gICAgICAvLyAgIF91cDogc3Vic09ialxuICAgICAgLy8gfTtcbiAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBzdWJzT2JqLiQpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgaWYgKGRvYyAmJiBkb2MuX190IDwgMykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBkb2MuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghZm9sbG93KHRoaXMpKSByZXR1cm4gcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJCc6XG4gICAgY2FzZSAnJHNvbWUnOlxuICAgICAgc3Vic09iai5zZXQoJyQnLCB7fSk7XG4gICAgICAvLyBzdWJzT2JqLiQgPSB7XG4gICAgICAvLyAgIF91cDogc3Vic09ialxuICAgICAgLy8gfTtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICB2YXIgZm9sbG93ID0gaGFuZGxlVGVzdCh2YWx1ZSwgc3Vic09iai4kKTtcbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICBpZiAoZG9jICYmIGRvYy5fX3QgPCAzKSB7XG4gICAgICAgICAgICB2YXIgZm91bmQ7XG4gICAgICAgICAgICBkb2MuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKGZvbGxvdyh0aGlzKSkgcmV0dXJuIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kIHx8IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgIGlmIChkb2MgJiYgZG9jLl9fdCA8IDMpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZDtcbiAgICAgICAgICAgIGRvYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gdmFsdWUpIHJldHVybiBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmb3VuZCB8fCBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBzdWJzT2JqLiQuX2NoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgcmV0dXJuIGRvYyA9PT0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbnNvbWUnOlxuICAgICAgc3Vic09iai5zZXQoJyQnLCB7fSk7XG4gICAgICAvLyBzdWJzT2JqLiQgPSB7XG4gICAgICAvLyAgIF91cDogc3Vic09ialxuICAgICAgLy8gfTtcbiAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBzdWJzT2JqLiQpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgaWYgKGRvYyAmJiBkb2MuX190IDwgMykge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgIGRvYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGZvbGxvdyh0aGlzKSkgcmV0dXJuICEocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbHQnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2J1cmsgbHQnLCBkb2MsIHZhbHVlKVxuICAgICAgICByZXR1cm4gZG9jIDwgdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGx0ZSc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jIDw9IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRndCc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jID4gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGd0ZSc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jID49IHZhbHVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRjb250YWlucyc6XG4gICAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKHZhbHVlLCAnaScpO1xuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnRlc3QoZG9jKTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmNvbnRhaW5zJzpcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAodmFsdWUsICdpJyk7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gIXJlZ2V4LnRlc3QoZG9jKTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckY29udGFpbnNhbGwnOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5jb250YWluc2FsbCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICckaGFzJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MgJiYgZG9jW3ZhbHVlXSAhPT0gdm9pZCAwO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuaGFzJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiAhZG9jIHx8IGRvY1t2YWx1ZV0gPT09IHZvaWQgMDtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckZXhpc3RzJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiAoZG9jICE9PSB2b2lkIDAgJiYgZG9jICE9PSBudWxsKSA9PT0gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGluJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRvYyA9PT0gdmFsdWVbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmluJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGRvYyA9PT0gdmFsdWVbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckcmVnZXgnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRlc3QoZG9jKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgdmFyIGRzdWJzT2JqID0gc3Vic09ialtrZXldO1xuXG4gICAgICAgIGlmIChkc3Vic09iaikge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhbHJlYWR5IG1hZGUgdGhhdCBkc3Vic09iaiB3aXRoIGtleScsIGtleSk7XG4gICAgICAgICAgLy8gZHN1YnNPYmouX3VwID0gc3Vic09ialxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN1YnNPYmouc2V0KGtleSwge30pO1xuICAgICAgICAgIGRzdWJzT2JqID0gc3Vic09ialtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBkc3Vic09iaik7XG5cbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVEVTVElORzogY2hlY2sgT0JKRUNUJywgZG9jICYmIGRvYy5yYXcgfHwgZG9jLCAnZm9yIGZpZWxkJywga2V5KVxuICAgICAgICAgIGRvYyA9IGdldEZpZWxkKGRvYywga2V5KVxuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3d1cHMnLCBkb2MgJiYgZG9jLnJhdyB8fCBkb2MpXG4gICAgICAgICAgcmV0dXJuIGZvbGxvdyhkb2MpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICBkb2MgPSBnZXRGaWVsZChkb2MsIGtleSlcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBkb2MgPSBnZXRWYWx1ZShkb2MpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1RFU1RJTkc6IGNoZWNrIFZBTFVFJywgZG9jICYmIGRvYy5yYXcgfHwgZG9jLCB2YWx1ZSwgZG9jID09PSB2YWx1ZSlcbiAgICAgICAgICByZXR1cm4gZG9jID09PSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgc3Vic09iai5zZXQoa2V5LCB7fSk7XG4gICAgICAgIHN1YnNPYmpba2V5XS5fY2hlY2sgPSBjaGVja1xuICAgICAgICAvLyBzdWJzT2JqW2tleV0gPSB7XG4gICAgICAgIC8vICAgX3VwOiBzdWJzT2JqLFxuICAgICAgICAvLyAgIF9jaGVjazogZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIC8vICAgICByZXR1cm4gZG9jID09PSB2YWx1ZTtcbiAgICAgICAgLy8gICB9XG4gICAgICAgIC8vIH07XG4gICAgICB9XG5cbiAgfVxuICByZXR1cm4gc3Vic09iaiA/IHN1YnNPYmouX2NoZWNrID0gY2hlY2sgOiBjaGVjaztcbn1cblxuZnVuY3Rpb24gbWFrZUxpc3QoYXJyLCBzdWJzT2JqKSB7XG4gIHZhciBsaXN0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGxpc3QucHVzaChoYW5kbGVUZXN0KGFycltpXSwgc3Vic09iaikpO1xuICB9XG4gIHJldHVybiBsaXN0O1xufVxuXG5mdW5jdGlvbiBtYWtlQU5EKGxpc3QsIHN1YnNPYmopIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGRvYykge1xuICAgIHZhciB2YWwgPSBnZXRWYWx1ZShkb2MpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChsaXN0W2ldKHZhbCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSh0aGluZyl7XG4gIHZhciB2YWwgPSB0aGluZyAmJiB0aGluZy5mcm9tICYmIHRoaW5nLmZyb20udmFsXG4gIHJldHVybiB2YWwgIT09IHZvaWQgMCA/IHZhbCA6IHRoaW5nXG4gIFxufVxuZnVuY3Rpb24gZ2V0RmllbGQodGhpbmcsIGZpZWxkKXtcbiAgLy8gY29uc29sZS5lcnJvcignZ2V0RmllbGQgZmllbGQnLCBmaWVsZCwgJ2Zyb20nLCB0aGluZyAmJiB0aGluZy5yYXcgfHwgdGhpbmcpXG4gIHRoaW5nID0gZ2V0VmFsdWUodGhpbmcpXG4gIHJldHVybiB0aGluZyA/IGdldFZhbHVlKHRoaW5nW2ZpZWxkXSkgOiB2b2lkIDBcbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgViA9IHJlcXVpcmUoJ3ZpZ291ci1qcycpLFxuICBvYmplY3QgPSByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0JyksXG4gIHV0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBWLkRhdGEgPSBvYmplY3QubmV3KCk7XG5leHBvcnRzLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ19fc3ViJywnX19ibG9jaycpO1xudXRpbC5kZWZpbmUoZXhwb3J0cywgJ19ob29rJywgZnVuY3Rpb24odmFsLCBvYmopIHtcbiAgaWYgKG9iai5zdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLl9fc3ViID0gb2JqLnN1YnNjcmlwdGlvbjtcbiAgICBkZWxldGUgb2JqLnN1YnNjcmlwdGlvbjtcbiAgfVxuICBpZihvYmouYmxvY2spIHtcbiAgICB0aGlzLl9fYmxvY2sgPSB0cnVlXG4gICAgZGVsZXRlIG9iai5ibG9ja1xuICB9XG59KTtcblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogTWFyY3VzIEJlc2plcywgbWFyY3VzQHZpZ291ci5pb1xuICovXG5cbnZhciBjb25kaXRpb25zID0gcmVxdWlyZSgnLi9jb25kaXRpb25zJylcbiAgLCB1dGlsSGFzaCA9IHJlcXVpcmUoJy4uL3V0aWwvaGFzaCcpXG4gICwgVk9iamVjdCA9IHJlcXVpcmUoJy4uL29iamVjdCcpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIFNlbGVjdGlvblxuICogQ2xhc3MgZXh0ZW50aW9uIGZvciBzZWxlY3Rpb24gLyBmaWx0ZXJpbmcgZnVuY3Rpb25hbGl0eVxuICogQENsYXNzXG4gKi9cblxuZXhwb3J0cy5TdWJzT2JqID0gVk9iamVjdC5uZXcoKVxuZXhwb3J0cy5TdWJzT2JqLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goICdfcm9vdCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX2NoZWNrJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdfc29ydCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX3VpZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGZ1bmN0aW9uKGJhc2Upe1xuXG4gIGJhc2UucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCggJ19maWx0ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ191aWQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ19oYXNoJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdfaW5kZXhDYWNoZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX3N1YnNjbnQnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcblxuICB2YXIgX3VwZGF0ZSA9IGJhc2UucHJvdG90eXBlLl91cGRhdGVcbiAgICAsIF9ob29rID0gYmFzZS5wcm90b3R5cGUuX2hvb2tcbiAgICAsIF9yZW1vdmUgPSBiYXNlLnByb3RvdHlwZS5yZW1vdmVcblxuICB1dGlsLmRlZmluZSggYmFzZVxuICAgICwgJ3JlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbFxuICAgICAgICBpZih0aGlzLl9maWx0ZXIgJiYgKGwgPSB0aGlzLmxlbmd0aCkpe1xuICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsOyBpKyspXG4gICAgICAgICAgICBkZWxldGUgdGhpc1tpXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVtb3ZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAsICdmaWx0ZXInLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbHRlclxuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCduZXcgZmlsdGVyIFxcbiBmcm9tIC0tLT4nLCB0aGlzLl9maWx0ZXIsICdcXG4gdG8gLS0tLT4nXG4gICAgICAgICAgLy8gICAgICAgICAgICAsIHZhbFxuICAgICAgICAgIC8vICAgICAgICAgICAgKVxuICAgICAgICAgIHRoaXMuX2ZpbHRlciA9IHZhbCAvL21vZXQgb29rIHdlcmtlbiBhbHMgZGF0YSBub2cgZ2VlbiBzZWxlY3Rpb24gaXNcbiAgICAgICAgICB0aGlzLl9idWlsZCh1bmRlZmluZWQsIHRydWUpXG4gICAgICAgICAgX3VwZGF0ZS5jYWxsKCB0aGlzLCB2b2lkIDAsIHRoaXMuc3RhbXAoKSwgdm9pZCAwLCBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICwgZmFsc2UsIHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICwgJ19ob29rJywgZnVuY3Rpb24odmFsLCBmaWx0ZXIpIHtcbiAgICAgICAgaWYgKF9ob29rKSB7XG4gICAgICAgICAgX2hvb2suY2FsbCh0aGlzLCB2YWwsIGZpbHRlcilcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuZW1wdHkoZmlsdGVyKSAmJiB2YWwpIHtcbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpc1xuICAgICAgICAgIHNlbGVjdGlvbi5fc3Vic2NudCA9IDBcbiAgICAgICAgICBzZWxlY3Rpb24uX2ZpbHRlciA9IGZpbHRlclxuXG4gICAgICAgICAgc2VsZWN0aW9uLl9oYXNoID0gdXRpbEhhc2godmFsLl9wYXRoICsgSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICBbIGZpbHRlci5jb25kaXRpb25cbiAgICAgICAgICAgICwgZmlsdGVyLnJhbmdlXG4gICAgICAgICAgICAsIGZpbHRlci5zb3J0XG4gICAgICAgICAgICBdKVxuICAgICAgICAgIClcbiAgICAgICAgICAvLyFvbmx5IG5lc3NlY2FyeSBzZXJ2ZXJzaWRlIVxuICAgICAgICAgIGlmICghc2VsZWN0aW9uLl91aWQpIHNlbGVjdGlvbi5fdWlkID0gc2VsZWN0aW9uLl9oYXNoXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgLCAnX2J1aWxkJywgZnVuY3Rpb24odmFsLCBub3VwZGF0ZSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpc1xuICAgICAgICBcbiAgICAgICAgaWYgKCF2YWwpIHZhbCA9IHNlbGVjdGlvbi5fdmFsXG4gICAgICAgIGlmKCF2YWwpIHJldHVyblxuICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCkgc2VsZWN0aW9uLl9jbGVhcigpIFxuXG4gICAgICAgIHZhciBsaXN0ID0gW11cbiAgICAgICAgICAsIGl0ZW1zSGFuZGxlciA9IHRoaXMuX2l0ZW1zSGFuZGxlclxuICAgICAgICAgICwgZmlsdGVyID0gc2VsZWN0aW9uLl9maWx0ZXJcbiAgICAgICAgICAsIHN1YnNPYmogPSBmaWx0ZXIuc3Vic09iaiB8fCBuZXcgZXhwb3J0cy5TdWJzT2JqKHt9LCBzZWxlY3Rpb24pXG4gICAgICAgICAgLCBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuICAgICAgICAgICwgc29ydCwgaXRlbVxuXG4gICAgICAgIGlmICh2YWwuX190ID09PSA0ICYmICF2YWwuX2ZpbHRlcikge1xuICAgICAgICAgIHZhbCA9IHZhbC5mcm9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbHRlci5zb3J0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIuc29ydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZpbHRlci5zb3J0ID0ge1xuICAgICAgICAgICAgICBmaWVsZDogZmlsdGVyLnNvcnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgc29ydCA9IGZpbHRlci5zb3J0XG4gICAgICAgICAgaWYgKCFzb3J0LmZuKSB7XG4gICAgICAgICAgICBpZiAoIXNvcnQudHlwZSkgc29ydC50eXBlID0gJ3N0cmluZydcbiAgICAgICAgICAgIHNvcnQuZm4gPSBzb3J0TWFrZXJzW3NvcnQudHlwZV0oc29ydClcbiAgICAgICAgICB9XG4gICAgICAgICAgc3Vic09iai5wYXRoKHNvcnQuZmllbGQuc3BsaXQoJy4nKSwge30pLnNldCgnX3NvcnQnLCB0cnVlKVxuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdidWlsZGluZz8hJylcbiAgICAgICAgaWYgKGZpbHRlci5jb25kaXRpb24pIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZm91bmQgY29uZGl0aW9uJywgZmlsdGVyLmNvbmRpdGlvbilcbiAgICAgICAgICB2YXIgcGNudCA9IDBcbiAgICAgICAgICAgICwgcmNudCA9IDBcbiAgICAgICAgICB2YXIgY2hlY2sgPSBmaWx0ZXIuY2hlY2sgXG4gICAgICAgICAgICAgICAgIHx8ICggZmlsdGVyLmNoZWNrID0gY29uZGl0aW9ucyggZmlsdGVyLmNvbmRpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsIHN1YnNPYmpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgZmlsdGVyLnN1YnNPYmogPSBzdWJzT2JqXG4gICAgICAgICAgdmFsLmVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXNcbiAgICAgICAgICAgIGlmIChpdGVtc0hhbmRsZXIpIGl0ZW1zSGFuZGxlcihpdGVtLCBzdWJzT2JqLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICBpZiAoY2hlY2soaXRlbSkpIHtcbiAgICAgICAgICAgICAgcGNudCsrXG4gICAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3Rpb24uX2hhcyhpdGVtKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLSA+IHJlbW92ZWQgZnJvbSBzZWxlY3Rpb24gYnkgY29uZGl0aW9uOidcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgLCBpdGVtLnJhd1xuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIHVuc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICAgIGlmKCFub3VwZGF0ZSl7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZS5jYWxsKHNlbGVjdGlvbiwgaXRlbSwgc3RhbXAsIHNlbGVjdGlvbiwgaXRlbSwgZmFsc2UsIG51bGwpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmNudCsrXG4gICAgICAgICAgICB9IGVsc2UgeyBcbiAgICAgICAgICAgICAgcmNudCsrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmFuIGNvbmRpdGlvbjogcGFzc2VkOicsIHBjbnQsICdyZWplY3RzOicsIHJjbnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoaXRlbXNIYW5kbGVyKSBpdGVtc0hhbmRsZXIodGhpcywgc3Vic09iaiwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgbGlzdC5wdXNoKHRoaXMpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbHRlci5zdWJzT2JqID0gc3Vic09ialxuXG4gICAgICAgIGlmIChzb3J0ICYmIGxpc3QubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGxpc3Quc29ydChmaWx0ZXIuc29ydC5mbilcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpLCBpdGVtXG5cbiAgICAgICAgdmFyIHJhbmdlID0gZmlsdGVyLnJhbmdlXG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgIGlmICghKHJhbmdlIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgICAgICByYW5nZSA9IGZpbHRlci5yYW5nZSA9IFswLCBmaWx0ZXIucmFuZ2VdXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaXN0Lmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIG5ld2xpc3QgPSBsaXN0LnNwbGljZShyYW5nZVswXSwgcmFuZ2VbMV0pXG4gICAgICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aDsgaXRlbSA9IGxpc3RbLS1pXTspIHtcbiAgICAgICAgICAgICAgaWYoc2VsZWN0aW9uLl9oYXMoaXRlbSkgIT09IHZvaWQgMCl7XG4gICAgICAgICAgICAgICAgdW5zdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAvLyBpZighbm91cGRhdGUpe1xuICAgICAgICAgICAgICAgIC8vICAgX3VwZGF0ZS5jYWxsKHNlbGVjdGlvbiwgaXRlbSwgc3RhbXAsIHNlbGVjdGlvbiwgaXRlbSwgZmFsc2VcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgICwgbnVsbFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGlzdCA9IG5ld2xpc3RcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGgsIGl0ZW07IGl0ZW0gPSBsaXN0Wy0taV07KSB7XG4gICAgICAgICAgc2VsZWN0aW9uW2ldID0gaXRlbVxuICAgICAgICAgIHZhciBpc25ldyA9IHNlbGVjdGlvbi5faGFzKGl0ZW0pID09PSB2b2lkIDBcbiAgICAgICAgICBzdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbiwgaSlcbiAgICAgICAgICAvLyBpZiAoaXNuZXcpIHtcbiAgICAgICAgICAvLyAgIGlmKCFub3VwZGF0ZSl7XG4gICAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdkb2luZyB1cGRhdGUgd2lja2VkcycpXG4gICAgICAgICAgLy8gICAgIF91cGRhdGUuY2FsbChzZWxlY3Rpb24sIGl0ZW0sIHN0YW1wLCBzZWxlY3Rpb24sIGZhbHNlLCBpdGVtLCBudWxsKSAgXG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIHNlbGVjdGlvbi5sZW5ndGggPSBsaXN0Lmxlbmd0aFxuICAgICAgfVxuICAgICwgJ191cGRhdGUnLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpIHtcblxuICAgICAgICBpZiAodGhpcy5fZmlsdGVyKSB7XG4gICAgICAgICAgIC8vIGlmKHdpbmRvdy5oZXJlKSBjb25zb2xlLmxvZygnaHVwcyBfdXBkYXRlIG9uIHNlbGVjdGlvbiEnKVxuXG4gICAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXNcbiAgICAgICAgICAgICwgdXBhdGggPSBzZWxlY3Rpb24udXBkYXRlUGF0aFxuXG4gICAgICAgICAgaWYgKHVwYXRoWzBdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHZhciBzaG9ydHBhdGggPSB1cGF0aC5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgLCBpdGVtcmVtb3ZlID0gc2hvcnRwYXRoICYmIHJlbW92ZVxuICAgICAgICAgICAgICAsIGl0ZW0gPSBpdGVtcmVtb3ZlID8gc2VsZWN0aW9uLl9sZnJvbSA6IHNlbGVjdGlvbi52YWxbdXBhdGhbMF1dXG4gICAgICAgICAgICAgICwgcmVsZXZhbnRcblxuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5fdmFsLl9maWx0ZXIpIHtcbiAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5fdmFsLl9oYXMoaXRlbSkgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uX2hhcyhpdGVtKSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX2NoZWNrSXRlbShpdGVtLCBmYWxzZSwgdmFsLCBzdGFtcClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBoaW50ID0gaXRlbXJlbW92ZSA/IGZhbHNlIDogKHNob3J0cGF0aCAmJiBhZGRlZCkgPyB2b2lkIDAgOiB1cGF0aFxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLl9jaGVja0l0ZW0oaXRlbSwgaGludCwgdmFsLCBzdGFtcCkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF91cGRhdGUuYXBwbHkoc2VsZWN0aW9uLCBhcmd1bWVudHMpIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaGl0IG9uIHNlbGVjdGlvbiBpdHNlbGY/IScpXG4gICAgICAgICAgICBpZiAoIWZyb20pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1xcbj4+Pj4+PiBoaXQgb24gc2VsZWN0aW9uIGl0c2VsZiAoVi5EYXRhKScpXG4gICAgICAgICAgICAgIGlmIChyZW1vdmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCkgc2VsZWN0aW9uLl9jbGVhcigpICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLl9idWlsZCgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBfdXBkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgIC8vIGlmKHdpbmRvdy5oZXJlKSBjb25zb2xlLmxvZygnaHVwcyBfdXBkYXRlIG9uIHNlbGVjdGlvbiEnLHRoaXMpXG4gICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTRUxFQ1QnLCB0aGlzLCBhcmd1bWVudHMsIHRoaXMuX3BhdGgpXG4gICAgICAgICAgcmV0dXJuIF91cGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLCAnX2hhcycsIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgdmFyIGluZGV4Q2FjaGUgPSBpdGVtLl9pbmRleENhY2hlXG4gICAgICAgICAgLCB1aWQgPSB0aGlzLl91aWRcbiAgICAgICAgICAsIGljXG5cbiAgICAgICAgaWYgKGluZGV4Q2FjaGUgJiYgdWlkICYmIChpYyA9IGluZGV4Q2FjaGVbdWlkXSkpIHtcbiAgICAgICAgICByZXR1cm4gaWNbMF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICwgJ19jbGVhcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICAgICAgc2VsZi5lYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICBzZWxmW2ZdID0gdm9pZCAwXG4gICAgICAgICAgZGVsZXRlIHNlbGZbZl1cbiAgICAgICAgfSlcbiAgICAgICAgc2VsZi5sZW5ndGggPSAwXG4gICAgICB9XG4gICAgLCAnX2NoZWNrSXRlbScsIGZ1bmN0aW9uKGl0ZW0sIGhpbnQsIHZhbCwgc3RhbXApIHtcbiAgICAgICAgaWYoIWl0ZW0pIHsgcmV0dXJuIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ19jaGVja0l0ZW0hJywgaXRlbS5yYXcsIGhpbnQpXG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzXG4gICAgICAgICAgLCBmcm9tID0gaXRlbVxuICAgICAgICAgICwgZmlsdGVyID0gc2VsZWN0aW9uLl9maWx0ZXJcbiAgICAgICAgICAsIHNvcnQgPSBmaWx0ZXIuc29ydFxuICAgICAgICAgICwgcmFuZ2UgPSBmaWx0ZXIucmFuZ2VcbiAgICAgICAgICAsIHJhbmdlZCA9IHJhbmdlICYmICEoICByYW5nZVswXSA9PT0gMCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByYW5nZVsxXSA+PSBzZWxlY3Rpb24uX3ZhbC5sZW5ndGggXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgc2VsZWN0aW9uLmxlbmd0aCA8IHJhbmdlWzFdIC0gcmFuZ2VbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgLCByZW1vdmVkID0gaGludCA9PT0gZmFsc2UgfHwgaXRlbS5fcmVtb3ZlZFxuICAgICAgICAgICwgYWRkZWQsIGluZGV4LCBpc2luXG4gICAgICAgICAgLCByZXN1bHQgPSBpc2luID0gKGluZGV4ID0gc2VsZWN0aW9uLl9oYXMoaXRlbSkpICE9PSB2b2lkIDBcblxuICAgICAgICB2YXIgY2hlY2sgPSBmaWx0ZXIuY2hlY2tcbiAgICAgICAgICAsIHBhc3MgPSByZW1vdmVkIFxuICAgICAgICAgICAgICAgICAgID8gZmFsc2UgXG4gICAgICAgICAgICAgICAgICAgOiAoIXJhbmdlZCAmJiBoaW50ID09PSAxKSBcbiAgICAgICAgICAgICAgICAgICAgID8gaXNpbiBcbiAgICAgICAgICAgICAgICAgICAgIDogIWNoZWNrIHx8IGNoZWNrKGl0ZW0pXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT0gY2hlY2tpdGVtIGluJywgc2VsZWN0aW9uLl9wYXRoKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaXRlbXdleCcsIGl0ZW0uX3ZhbCAmJiBpdGVtLl92YWwucmF3KVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnaXNpbicsIGlzaW4sICdwYXNzJywgcGFzcywgJ3Jlc3VsdCcsIHJlc3VsdClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0gY2hlY2tlZCBpdGVtJywgcGFzcylcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZWQ/JywgcmVtb3ZlZClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3JhbmdlZD8gKHBhc3MgPT0gYWxyZWFkeSBpbiknLCAoIXJhbmdlZCAmJiBoaW50ID09PSAxKSwgaXNpbilcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29rIHRpbWUgZm9yIGNoZWNraW5nJywgY2hlY2spXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb25kaXRpb25zJywgZmlsdGVyLmNvbmRpdGlvbilcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NoZWNrPycsIGNoZWNrICYmIGNoZWNrKGl0ZW0pKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tLScpXG4gICAgICAgIFxuICAgICAgICBpZiAoaXNpbiAhPT0gcGFzcykge1xuICAgICAgICAgIGlmIChpc2luKSB7XG4gICAgICAgICAgICByZXN1bHQgPSAxXG4gICAgICAgICAgICB1bnN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmVtb3ZlZCA9IGl0ZW1cbiAgICAgICAgICAgIHZhciBtYXJrXG4gICAgICAgICAgICB3aGlsZSAobWFyayA9IHNlbGVjdGlvblsrK2luZGV4XSkge1xuICAgICAgICAgICAgICBzZWxlY3Rpb25baW5kZXggLSAxXSA9IG1hcmtcbiAgICAgICAgICAgICAgc3RvcmVJbmRleChtYXJrLCBzZWxlY3Rpb24sIGluZGV4IC0gMSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGVuZCA9IGluZGV4IC0gMVxuICAgICAgICAgICAgc2VsZWN0aW9uW2VuZF0gPSBudWxsXG4gICAgICAgICAgICBkZWxldGUgc2VsZWN0aW9uW2VuZF1cblxuICAgICAgICAgICAgdmFyIHJlcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAocmFuZ2VkKSB7XG4gICAgICAgICAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLl92YWwuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgIGlmICggIHNlbGVjdGlvbi5faGFzKHRoaXMpID09PSB2b2lkIDAgXG4gICAgICAgICAgICAgICAgICAgICAmJiAoIXNlbGVjdGlvbltlbmRdIHx8IHNvcnQuZm4odGhpcywgc2VsZWN0aW9uW2VuZF0pIDwgMCkgXG4gICAgICAgICAgICAgICAgICAgICAmJiAoIWNoZWNrIHx8IGNoZWNrKHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gc2VsZWN0aW9uW2VuZF0gPSB0aGlzXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX3ZhbC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCBzZWxlY3Rpb24uX2hhcyh0aGlzKSA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICAgICAgICAgJiYgKCFjaGVjayB8fCBjaGVjayh0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQgPSBzZWxlY3Rpb25bZW5kXSA9IHRoaXNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbi5sZW5ndGgtLVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc3RvcmVJbmRleChyZXBsYWNlbWVudCwgc2VsZWN0aW9uLCBpbmRleCAtIDEpXG4gICAgICAgICAgICAgIGFkZGVkID0gcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5ld2luZGV4XG4gICAgICAgICAgICBpZiAoc29ydCkge1xuICAgICAgICAgICAgICB2YXIgc29ydGZuID0gc29ydC5mblxuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChzb3J0Zm4oaXRlbSwgdGhpcykgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdpbmRleCA9IGZcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChuZXdpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgICAgIG5ld2luZGV4ID0gTnVtYmVyKG5ld2luZGV4KVxuICAgICAgICAgICAgICAgIHN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uLCBuZXdpbmRleClcbiAgICAgICAgICAgICAgICBhZGRlZCA9IGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICByZW1vdmVkID0gc2VsZWN0aW9uW3NlbGVjdGlvbi5sZW5ndGggLSAxXVxuICAgICAgICAgICAgICAgICAgdW5zdG9yZUluZGV4KHJlbW92ZWQsIHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhpcy5sZW5ndGgrK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3Rpb24ubGVuZ3RoIC0gMlxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+PSBuZXdpbmRleCkge1xuICAgICAgICAgICAgICAgICAgc3RvcmVJbmRleChzZWxlY3Rpb25baW5kZXhdLCBzZWxlY3Rpb24sIGluZGV4ICsgMSlcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbltpbmRleCArIDFdID0gc2VsZWN0aW9uW2luZGV4LS1dXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltuZXdpbmRleF0gPSBpdGVtXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IDFcbiAgICAgICAgICAgICAgICBuZXdpbmRleCA9IHNlbGVjdGlvbi5sZW5ndGgrK1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltuZXdpbmRleF0gPSBpdGVtXG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24sIG5ld2luZGV4KVxuICAgICAgICAgICAgICAgIGFkZGVkID0gaXRlbVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFyYW5nZWQpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgICBuZXdpbmRleCA9IHNlbGVjdGlvbi5sZW5ndGgrK1xuICAgICAgICAgICAgICBzZWxlY3Rpb25bbmV3aW5kZXhdID0gaXRlbVxuICAgICAgICAgICAgICBzdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbiwgbmV3aW5kZXgpXG4gICAgICAgICAgICAgIGFkZGVkID0gaXRlbVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc2luICYmIHNvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnPz8/Jywgc29ydCwgc29ydC5maWVsZCwgaGludClcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpc2luICsgc29ydCEgcmVzb3J0PycpXG4gICAgICAgICAgaWYgKGhpbnQgJiYgaGludC5sZW5ndGggJiYgc29ydC5maWVsZCkge1xuICAgICAgICAgICAgaWYgKH5zb3J0LmZpZWxkLmluZGV4T2YoJy4nKSkge1xuICAgICAgICAgICAgICB2YXIgc29ydHBhdGggPSBzb3J0LmZpZWxkLnNwbGl0KCcuJylcbiAgICAgICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVBcnJheXMoaGludC5zbGljZSgxKSwgc29ydHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaGludFsxXSAhPT0gc29ydC5maWVsZCkgcmV0dXJuIHJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnNvbGUubG9nKCc/JylcblxuICAgICAgICAgIHZhciBuZXdpbmRleFxuICAgICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgICAgIGlmIChmICE9IGluZGV4KSB7XG4gICAgICAgICAgICAgIHZhciBzID0gc29ydC5mbihpdGVtLCB0aGlzKVxuICAgICAgICAgICAgICBpZiAocyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZiA9PSBpbmRleCArIDEpIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgICAgbmV3aW5kZXggPSBmIDwgaW5kZXggPyBmIDogZiAtIDFcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGYgPj0gaW5kZXggKyAxICYmIHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGYgPiBpbmRleCkge1xuICAgICAgICAgICAgICAgIG5ld2luZGV4ID0gZlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ25ld2luZGV4JywgbmV3aW5kZXgpXG4gICAgICAgICAgaWYgKG5ld2luZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IDFcbiAgICAgICAgICAgIHZhciB0bXBcbiAgICAgICAgICAgIGlmIChpbmRleCA+IG5ld2luZGV4KSB7XG4gICAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IG5ld2luZGV4KSB7XG4gICAgICAgICAgICAgICAgdG1wID0gc2VsZWN0aW9uW2luZGV4XSA9IHNlbGVjdGlvblstLWluZGV4XVxuICAgICAgICAgICAgICAgIGlmICh0bXApIHN0b3JlSW5kZXgodG1wLCBzZWxlY3Rpb24sIGluZGV4ICsgMSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4IDwgbmV3aW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBzZWxlY3Rpb25baW5kZXhdID0gc2VsZWN0aW9uWysraW5kZXhdXG4gICAgICAgICAgICAgICAgaWYgKHRtcCkgc3RvcmVJbmRleCh0bXAsIHNlbGVjdGlvbiwgaW5kZXggLSAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3Rpb25bbmV3aW5kZXhdID0gaXRlbVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBlbmQgPSBzZWxlY3Rpb24ubGVuZ3RoIC0gMVxuXG4gICAgICAgICAgaWYgKCAgcmFuZ2VkIFxuICAgICAgICAgICAgICYmIChuZXdpbmRleCA9PSBlbmQgfHwgbmV3aW5kZXggPT09IHZvaWQgMCBcbiAgICAgICAgICAgICAmJiBpbmRleCA9PSBlbmQpXG4gICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB2YXIgcmVwbGFjZWRcbiAgICAgICAgICAgIHNlbGVjdGlvbi5fdmFsLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICggIHNlbGVjdGlvbi5faGFzKHRoaXMpID09PSB2b2lkIDAgXG4gICAgICAgICAgICAgICAgICYmIHNvcnQuZm4odGhpcywgaXRlbSkgPT09IC0xIFxuICAgICAgICAgICAgICAgICAmJiAoIWNoZWNrIHx8IGNoZWNrKHRoaXMpKVxuICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcGxhY2VkKSByZXBsYWNlZCA9IGl0ZW1cbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25bZW5kXSA9IGl0ZW0gPSB0aGlzXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBzdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbiwgZW5kKVxuICAgICAgICAgICAgaWYgKHJlcGxhY2VkKSB7XG4gICAgICAgICAgICAgIHVuc3RvcmVJbmRleChyZXBsYWNlZCwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgICByZW1vdmVkID0gcmVwbGFjZWRcbiAgICAgICAgICAgICAgYWRkZWQgPSBpdGVtXG4gICAgICAgICAgICAgIHJlc3VsdCA9IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKG5ld2luZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uLCBOdW1iZXIobmV3aW5kZXgpKVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQgPT09IDEpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygndXBkYXRlIGZyb20gX2NoZWNrSXRlbSEnKVxuICAgICAgICAgIHNlbGVjdGlvbi5fX3VwZGF0ZSh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmVkLCBhZGRlZClcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICB9XG4gICAgKVxuXG59KVxuXG52YXIgc3RvcmVJbmRleCA9IGV4cG9ydHMuc3RvcmVJbmRleCA9IGZ1bmN0aW9uKGl0ZW0sIHNlbGVjdGlvbiwgaW5kZXgpIHtcbiAgLy8gY29uc29sZS5sb2coJ3N0b3JlSW5kZXghIGl0ZW0nLCBpdGVtLl9uYW1lLCAnQCcsIGluZGV4KVxuICB2YXIgaW5kZXhDYWNoZSA9IGl0ZW0uX2luZGV4Q2FjaGVcbiAgICAsIGljXG4gIGlmIChpbmRleENhY2hlKSB7XG4gICAgaWMgPSBpbmRleENhY2hlW3NlbGVjdGlvbi5fdWlkXVxuICAgIGlmIChpYykge1xuICAgICAgaWNbMV0gPSBpY1swXVxuICAgICAgaWNbMF0gPSBpbmRleFxuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleENhY2hlW3NlbGVjdGlvbi5fdWlkXSA9IFtpbmRleF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXRlbS5faW5kZXhDYWNoZSA9IHt9XG4gICAgaXRlbS5faW5kZXhDYWNoZVtzZWxlY3Rpb24uX3VpZF0gPSBbaW5kZXhdXG4gIH1cbn1cblxudmFyIHVuc3RvcmVJbmRleCA9IGV4cG9ydHMudW5zdG9yZUluZGV4ID0gZnVuY3Rpb24oaXRlbSwgc2VsZWN0aW9uKSB7XG4gIHZhciBpbmRleENhY2hlID0gaXRlbS5faW5kZXhDYWNoZVxuICBpZiAoaW5kZXhDYWNoZSkge1xuICAgIHZhciBpYyA9IGluZGV4Q2FjaGVbc2VsZWN0aW9uLl91aWRdXG4gICAgaWNbMV0gPSBpY1swXVxuICAgIGljWzBdID0gdm9pZCAwXG4gIH1cbn1cblxudmFyIHNvcnRNYWtlcnMgPSB7XG4gIG51bWJlcjogZnVuY3Rpb24oc29ydCkge1xuICAgIHZhciBmaWVsZCA9IHNvcnQuZmllbGRcbiAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgdmFyIHZhID0gYVtmaWVsZF0gJiYgYVtmaWVsZF0udmFsXG4gICAgICAgICwgdmIgPSBiW2ZpZWxkXSAmJiBiW2ZpZWxkXS52YWxcbiAgICAgIGlmICh2YSA9PT0gdm9pZCAwIHx8IHZiID09PSB2b2lkIDApIHtcbiAgICAgICAgcmV0dXJuIHZhID09PSB2YiBcbiAgICAgICAgICAgICAgID8gMCBcbiAgICAgICAgICAgICAgIDogdmEgPT09IHZvaWQgMCBcbiAgICAgICAgICAgICAgICAgPyAxIFxuICAgICAgICAgICAgICAgICA6IC0xXG4gICAgICB9XG4gICAgICByZXR1cm4gc29ydC5vcmRlciBcbiAgICAgICAgICAgICA/ICh2YSAtIHZiKSAqIC0xIFxuICAgICAgICAgICAgIDogdmEgLSB2YlxuICAgIH1cbiAgfSxcbiAgc3RyaW5nOiBmdW5jdGlvbihzb3J0KSB7XG4gICAgdmFyIGZpZWxkID0gc29ydC5maWVsZFxuICAgIGlmICh+ZmllbGQuaW5kZXhPZignLicpKSB7XG4gICAgICB2YXIgcGF0aCA9IGZpZWxkLnNwbGl0KCcuJylcbiAgICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGEgPSBnZXREb3RGaWVsZFZhbChhLCBwYXRoKVxuICAgICAgICBiID0gZ2V0RG90RmllbGRWYWwoYiwgcGF0aClcbiAgICAgICAgaWYgKGEgPT09IHZvaWQgMCB8fCBiID09PSB2b2lkIDApIHtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiBcbiAgICAgICAgICAgICAgICAgPyAwIFxuICAgICAgICAgICAgICAgICA6IGEgPT09IHZvaWQgMCBcbiAgICAgICAgICAgICAgICAgICA/IDEgXG4gICAgICAgICAgICAgICAgICAgOiAtMVxuICAgICAgICB9XG4gICAgICAgIHZhciByZSA9IGEgPiBiIFxuICAgICAgICAgICAgICAgICA/IDEgXG4gICAgICAgICAgICAgICAgIDogYSA9PT0gYiBcbiAgICAgICAgICAgICAgICAgICA/IDAgXG4gICAgICAgICAgICAgICAgICAgOiAtMVxuICAgICAgICByZXR1cm4gc29ydC5vcmRlciA/IHJlICogLTEgOiByZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBhID0gZ2V0RmllbGRWYWwoYSwgZmllbGQpXG4gICAgICAgIGIgPSBnZXRGaWVsZFZhbChiLCBmaWVsZClcbiAgICAgICAgdmFyIHdlYWtBID0gYSA9PT0gdm9pZCAwIHx8IGEgPT09IG51bGxcbiAgICAgICAgICAsIHdlYWtCID0gYiA9PT0gdm9pZCAwIHx8IGIgPT09IG51bGxcbiAgICAgICAgaWYgKHdlYWtBIHx8IHdlYWtCKSB7XG4gICAgICAgICAgcmV0dXJuIGEgPT09IGIgPyAwIDogd2Vha0EgPyAxIDogLTFcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmUgPSBhID4gYiBcbiAgICAgICAgICAgICAgICAgPyAxIFxuICAgICAgICAgICAgICAgICA6IGEgPT09IGIgXG4gICAgICAgICAgICAgICAgICAgPyAwIFxuICAgICAgICAgICAgICAgICAgIDogLTFcbiAgICAgICAgcmV0dXJuIHNvcnQub3JkZXIgPyByZSAqIC0xIDogcmVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RmllbGRWYWwob2JqLCBmaWVsZCkge1xuICB2YXIgdiA9IG9iai52YWxcbiAgcmV0dXJuIHYgJiYgdltmaWVsZF0gJiYgdltmaWVsZF0udmFsXG59XG5cbmZ1bmN0aW9uIGdldERvdEZpZWxkVmFsKG9iaiwgZmllbGQpIHtcbiAgdmFyIHYgPSBvYmoucGF0aChmaWVsZClcbiAgcmV0dXJuIHYgJiYgdi52YWxcbn1cblxuZnVuY3Rpb24gcHV0U29ydChwYXRoKSB7XG4gIHZhciBvYmogPSBwYXJ0ID0ge31cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHBhcnQgPSBwYXJ0W3BhdGhbaV1dID0ge1xuICAgICAgX3VwOiBwYXJ0XG4gICAgfVxuICB9XG4gIHBhcnQuX3NvcnQgPSB0cnVlXG4gIHJldHVybiBvYmpcbn1cbiIsIi8vViBvbmx5IHVzZWQgYXMgYSByZWZlcmVuY2Ugbm93Li4uXG4iLCIvKlxuY29sb3JzLmpzXG5cbkNvcHlyaWdodCAoYykgMjAxMFxuXG5NYXJhayBTcXVpcmVzXG5BbGV4aXMgU2VsbGllciAoY2xvdWRoZWFkKVxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG5cbiovXG5cbnZhciBpc0hlYWRsZXNzID0gZmFsc2U7XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICBpc0hlYWRsZXNzID0gdHJ1ZTtcbn1cblxuaWYgKCFpc0hlYWRsZXNzKSB7XG4gIHZhciBleHBvcnRzID0ge307XG4gIHZhciBtb2R1bGUgPSB7fTtcbiAgdmFyIGNvbG9ycyA9IGV4cG9ydHM7XG4gIGV4cG9ydHMubW9kZSA9IFwiYnJvd3NlclwiO1xufSBlbHNlIHtcbiAgZXhwb3J0cy5tb2RlID0gXCJjb25zb2xlXCI7XG59XG5cbi8vXG4vLyBQcm90b3R5cGVzIHRoZSBzdHJpbmcgb2JqZWN0IHRvIGhhdmUgYWRkaXRpb25hbCBtZXRob2QgY2FsbHMgdGhhdCBhZGQgdGVybWluYWwgY29sb3JzXG4vL1xudmFyIGFkZFByb3BlcnR5ID0gZnVuY3Rpb24gKGNvbG9yLCBmdW5jKSB7XG4gIGV4cG9ydHNbY29sb3JdID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KHN0cik7XG4gIH07XG4gIFN0cmluZy5wcm90b3R5cGUuX19kZWZpbmVHZXR0ZXJfXyhjb2xvciwgZnVuYyk7XG59O1xuXG5mdW5jdGlvbiBzdHlsaXplKHN0ciwgc3R5bGUpIHtcblxuICB2YXIgc3R5bGVzO1xuXG4gIGlmIChleHBvcnRzLm1vZGUgPT09ICdjb25zb2xlJykge1xuICAgIHN0eWxlcyA9IHtcbiAgICAgIC8vc3R5bGVzXG4gICAgICAnYm9sZCcgICAgICA6IFsnXFx4MUJbMW0nLCAgJ1xceDFCWzIybSddLFxuICAgICAgJ2l0YWxpYycgICAgOiBbJ1xceDFCWzNtJywgICdcXHgxQlsyM20nXSxcbiAgICAgICd1bmRlcmxpbmUnIDogWydcXHgxQls0bScsICAnXFx4MUJbMjRtJ10sXG4gICAgICAnaW52ZXJzZScgICA6IFsnXFx4MUJbN20nLCAgJ1xceDFCWzI3bSddLFxuICAgICAgJ3N0cmlrZXRocm91Z2gnIDogWydcXHgxQls5bScsICAnXFx4MUJbMjltJ10sXG4gICAgICAvL3RleHQgY29sb3JzXG4gICAgICAvL2dyYXlzY2FsZVxuICAgICAgJ3doaXRlJyAgICAgOiBbJ1xceDFCWzM3bScsICdcXHgxQlszOW0nXSxcbiAgICAgICdncmV5JyAgICAgIDogWydcXHgxQls5MG0nLCAnXFx4MUJbMzltJ10sXG4gICAgICAnYmxhY2snICAgICA6IFsnXFx4MUJbMzBtJywgJ1xceDFCWzM5bSddLFxuICAgICAgLy9jb2xvcnNcbiAgICAgICdibHVlJyAgICAgIDogWydcXHgxQlszNG0nLCAnXFx4MUJbMzltJ10sXG4gICAgICAnY3lhbicgICAgICA6IFsnXFx4MUJbMzZtJywgJ1xceDFCWzM5bSddLFxuICAgICAgJ2dyZWVuJyAgICAgOiBbJ1xceDFCWzMybScsICdcXHgxQlszOW0nXSxcbiAgICAgICdtYWdlbnRhJyAgIDogWydcXHgxQlszNW0nLCAnXFx4MUJbMzltJ10sXG4gICAgICAncmVkJyAgICAgICA6IFsnXFx4MUJbMzFtJywgJ1xceDFCWzM5bSddLFxuICAgICAgJ3llbGxvdycgICAgOiBbJ1xceDFCWzMzbScsICdcXHgxQlszOW0nXSxcbiAgICAgIC8vYmFja2dyb3VuZCBjb2xvcnNcbiAgICAgIC8vZ3JheXNjYWxlXG4gICAgICAnd2hpdGVCRycgICAgIDogWydcXHgxQls0N20nLCAnXFx4MUJbNDltJ10sXG4gICAgICAnZ3JleUJHJyAgICAgIDogWydcXHgxQls0OTs1OzhtJywgJ1xceDFCWzQ5bSddLFxuICAgICAgJ2JsYWNrQkcnICAgICA6IFsnXFx4MUJbNDBtJywgJ1xceDFCWzQ5bSddLFxuICAgICAgLy9jb2xvcnNcbiAgICAgICdibHVlQkcnICAgICAgOiBbJ1xceDFCWzQ0bScsICdcXHgxQls0OW0nXSxcbiAgICAgICdjeWFuQkcnICAgICAgOiBbJ1xceDFCWzQ2bScsICdcXHgxQls0OW0nXSxcbiAgICAgICdncmVlbkJHJyAgICAgOiBbJ1xceDFCWzQybScsICdcXHgxQls0OW0nXSxcbiAgICAgICdtYWdlbnRhQkcnICAgOiBbJ1xceDFCWzQ1bScsICdcXHgxQls0OW0nXSxcbiAgICAgICdyZWRCRycgICAgICAgOiBbJ1xceDFCWzQxbScsICdcXHgxQls0OW0nXSxcbiAgICAgICd5ZWxsb3dCRycgICAgOiBbJ1xceDFCWzQzbScsICdcXHgxQls0OW0nXVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZXhwb3J0cy5tb2RlID09PSAnYnJvd3NlcicpIHtcbiAgICBzdHlsZXMgPSB7XG4gICAgICAvL3N0eWxlc1xuICAgICAgJ2JvbGQnICAgICAgOiBbJzxiPicsICAnPC9iPiddLFxuICAgICAgJ2l0YWxpYycgICAgOiBbJzxpPicsICAnPC9pPiddLFxuICAgICAgJ3VuZGVybGluZScgOiBbJzx1PicsICAnPC91PiddLFxuICAgICAgJ2ludmVyc2UnICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpibGFjaztjb2xvcjp3aGl0ZTtcIj4nLCAgJzwvc3Bhbj4nXSxcbiAgICAgICdzdHJpa2V0aHJvdWdoJyA6IFsnPGRlbD4nLCAgJzwvZGVsPiddLFxuICAgICAgLy90ZXh0IGNvbG9yc1xuICAgICAgLy9ncmF5c2NhbGVcbiAgICAgICd3aGl0ZScgICAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOndoaXRlO1wiPicsICAgJzwvc3Bhbj4nXSxcbiAgICAgICdncmV5JyAgICAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOmdyYXk7XCI+JywgICAgJzwvc3Bhbj4nXSxcbiAgICAgICdibGFjaycgICAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOmJsYWNrO1wiPicsICAgJzwvc3Bhbj4nXSxcbiAgICAgIC8vY29sb3JzXG4gICAgICAnYmx1ZScgICAgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjpibHVlO1wiPicsICAgICc8L3NwYW4+J10sXG4gICAgICAnY3lhbicgICAgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjpjeWFuO1wiPicsICAgICc8L3NwYW4+J10sXG4gICAgICAnZ3JlZW4nICAgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjpncmVlbjtcIj4nLCAgICc8L3NwYW4+J10sXG4gICAgICAnbWFnZW50YScgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjptYWdlbnRhO1wiPicsICc8L3NwYW4+J10sXG4gICAgICAncmVkJyAgICAgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjpyZWQ7XCI+JywgICAgICc8L3NwYW4+J10sXG4gICAgICAneWVsbG93JyAgICA6IFsnPHNwYW4gc3R5bGU9XCJjb2xvcjp5ZWxsb3c7XCI+JywgICc8L3NwYW4+J10sXG4gICAgICAvL2JhY2tncm91bmQgY29sb3JzXG4gICAgICAvL2dyYXlzY2FsZVxuICAgICAgJ3doaXRlQkcnICAgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOndoaXRlO1wiPicsICAgJzwvc3Bhbj4nXSxcbiAgICAgICdncmV5QkcnICAgICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpncmF5O1wiPicsICAgICc8L3NwYW4+J10sXG4gICAgICAnYmxhY2tCRycgICAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6YmxhY2s7XCI+JywgICAnPC9zcGFuPiddLFxuICAgICAgLy9jb2xvcnNcbiAgICAgICdibHVlQkcnICAgICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpibHVlO1wiPicsICAgICc8L3NwYW4+J10sXG4gICAgICAnY3lhbkJHJyAgICAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6Y3lhbjtcIj4nLCAgICAnPC9zcGFuPiddLFxuICAgICAgJ2dyZWVuQkcnICAgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOmdyZWVuO1wiPicsICAgJzwvc3Bhbj4nXSxcbiAgICAgICdtYWdlbnRhQkcnICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjptYWdlbnRhO1wiPicsICc8L3NwYW4+J10sXG4gICAgICAncmVkQkcnICAgICAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6cmVkO1wiPicsICAgICAnPC9zcGFuPiddLFxuICAgICAgJ3llbGxvd0JHJyAgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOnllbGxvdztcIj4nLCAgJzwvc3Bhbj4nXVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZXhwb3J0cy5tb2RlID09PSAnbm9uZScpIHtcbiAgICByZXR1cm4gc3RyICsgJyc7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS5sb2coJ3Vuc3VwcG9ydGVkIG1vZGUsIHRyeSBcImJyb3dzZXJcIiwgXCJjb25zb2xlXCIgb3IgXCJub25lXCInKTtcbiAgfVxuICByZXR1cm4gc3R5bGVzW3N0eWxlXVswXSArIHN0ciArIHN0eWxlc1tzdHlsZV1bMV07XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGhlbWUodGhlbWUpIHtcblxuICAvL1xuICAvLyBSZW1hcms6IFRoaXMgaXMgYSBsaXN0IG9mIG1ldGhvZHMgdGhhdCBleGlzdFxuICAvLyBvbiBTdHJpbmcgdGhhdCB5b3Ugc2hvdWxkIG5vdCBvdmVyd3JpdGUuXG4gIC8vXG4gIHZhciBzdHJpbmdQcm90b3R5cGVCbGFja2xpc3QgPSBbXG4gICAgJ19fZGVmaW5lR2V0dGVyX18nLCAnX19kZWZpbmVTZXR0ZXJfXycsICdfX2xvb2t1cEdldHRlcl9fJywgJ19fbG9va3VwU2V0dGVyX18nLCAnY2hhckF0JywgJ2NvbnN0cnVjdG9yJyxcbiAgICAnaGFzT3duUHJvcGVydHknLCAnaXNQcm90b3R5cGVPZicsICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICd0b0xvY2FsZVN0cmluZycsICd0b1N0cmluZycsICd2YWx1ZU9mJywgJ2NoYXJDb2RlQXQnLFxuICAgICdpbmRleE9mJywgJ2xhc3RJbmRleG9mJywgJ2xlbmd0aCcsICdsb2NhbGVDb21wYXJlJywgJ21hdGNoJywgJ3JlcGxhY2UnLCAnc2VhcmNoJywgJ3NsaWNlJywgJ3NwbGl0JywgJ3N1YnN0cmluZycsXG4gICAgJ3RvTG9jYWxlTG93ZXJDYXNlJywgJ3RvTG9jYWxlVXBwZXJDYXNlJywgJ3RvTG93ZXJDYXNlJywgJ3RvVXBwZXJDYXNlJywgJ3RyaW0nLCAndHJpbUxlZnQnLCAndHJpbVJpZ2h0J1xuICBdO1xuXG4gIE9iamVjdC5rZXlzKHRoZW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgaWYgKHN0cmluZ1Byb3RvdHlwZUJsYWNrbGlzdC5pbmRleE9mKHByb3ApICE9PSAtMSkge1xuICAgICAgY29uc29sZS5sb2coJ3dhcm46ICcucmVkICsgKCdTdHJpbmcucHJvdG90eXBlJyArIHByb3ApLm1hZ2VudGEgKyAnIGlzIHByb2JhYmx5IHNvbWV0aGluZyB5b3UgZG9uXFwndCB3YW50IHRvIG92ZXJyaWRlLiBJZ25vcmluZyBzdHlsZSBuYW1lJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZih0aGVtZVtwcm9wXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGFkZFByb3BlcnR5KHByb3AsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0c1t0aGVtZVtwcm9wXV0odGhpcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIGFkZFByb3BlcnR5KHByb3AsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgcmV0ID0gdGhpcztcbiAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoZW1lW3Byb3BdLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICByZXQgPSBleHBvcnRzW3RoZW1lW3Byb3BdW3RdXShyZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5cbi8vXG4vLyBJdGVyYXRlIHRocm91Z2ggYWxsIGRlZmF1bHQgc3R5bGVzIGFuZCBjb2xvcnNcbi8vXG52YXIgeCA9IFsnYm9sZCcsICd1bmRlcmxpbmUnLCAnc3RyaWtldGhyb3VnaCcsICdpdGFsaWMnLCAnaW52ZXJzZScsICdncmV5JywgJ2JsYWNrJywgJ3llbGxvdycsICdyZWQnLCAnZ3JlZW4nLCAnYmx1ZScsICd3aGl0ZScsICdjeWFuJywgJ21hZ2VudGEnLCAnZ3JleUJHJywgJ2JsYWNrQkcnLCAneWVsbG93QkcnLCAncmVkQkcnLCAnZ3JlZW5CRycsICdibHVlQkcnLCAnd2hpdGVCRycsICdjeWFuQkcnLCAnbWFnZW50YUJHJ107XG54LmZvckVhY2goZnVuY3Rpb24gKHN0eWxlKSB7XG5cbiAgLy8gX19kZWZpbmVHZXR0ZXJfXyBhdCB0aGUgbGVhc3Qgd29ya3MgaW4gbW9yZSBicm93c2Vyc1xuICAvLyBodHRwOi8vcm9iZXJ0bnltYW4uY29tL2phdmFzY3JpcHQvamF2YXNjcmlwdC1nZXR0ZXJzLXNldHRlcnMuaHRtbFxuICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgb25seSB3b3JrcyBpbiBDaHJvbWVcbiAgYWRkUHJvcGVydHkoc3R5bGUsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3R5bGl6ZSh0aGlzLCBzdHlsZSk7XG4gIH0pO1xufSk7XG5cbmZ1bmN0aW9uIHNlcXVlbmNlcihtYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIWlzSGVhZGxlc3MpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoLyggKS8sICckMScpO1xuICAgIH1cbiAgICB2YXIgZXhwbG9kZWQgPSB0aGlzLnNwbGl0KFwiXCIpLCBpID0gMDtcbiAgICBleHBsb2RlZCA9IGV4cGxvZGVkLm1hcChtYXApO1xuICAgIHJldHVybiBleHBsb2RlZC5qb2luKFwiXCIpO1xuICB9O1xufVxuXG52YXIgcmFpbmJvd01hcCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByYWluYm93Q29sb3JzID0gWydyZWQnLCAneWVsbG93JywgJ2dyZWVuJywgJ2JsdWUnLCAnbWFnZW50YSddOyAvL1JvWSBHIEJpVlxuICByZXR1cm4gZnVuY3Rpb24gKGxldHRlciwgaSwgZXhwbG9kZWQpIHtcbiAgICBpZiAobGV0dGVyID09PSBcIiBcIikge1xuICAgICAgcmV0dXJuIGxldHRlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN0eWxpemUobGV0dGVyLCByYWluYm93Q29sb3JzW2krKyAlIHJhaW5ib3dDb2xvcnMubGVuZ3RoXSk7XG4gICAgfVxuICB9O1xufSkoKTtcblxuZXhwb3J0cy50aGVtZXMgPSB7fTtcblxuZXhwb3J0cy5hZGRTZXF1ZW5jZXIgPSBmdW5jdGlvbiAobmFtZSwgbWFwKSB7XG4gIGFkZFByb3BlcnR5KG5hbWUsIHNlcXVlbmNlcihtYXApKTtcbn07XG5cbmV4cG9ydHMuYWRkU2VxdWVuY2VyKCdyYWluYm93JywgcmFpbmJvd01hcCk7XG5leHBvcnRzLmFkZFNlcXVlbmNlcignemVicmEnLCBmdW5jdGlvbiAobGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICByZXR1cm4gaSAlIDIgPT09IDAgPyBsZXR0ZXIgOiBsZXR0ZXIuaW52ZXJzZTtcbn0pO1xuXG5leHBvcnRzLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gIGlmICh0eXBlb2YgdGhlbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGV4cG9ydHMudGhlbWVzW3RoZW1lXSA9IHJlcXVpcmUodGhlbWUpO1xuICAgICAgYXBwbHlUaGVtZShleHBvcnRzLnRoZW1lc1t0aGVtZV0pO1xuICAgICAgcmV0dXJuIGV4cG9ydHMudGhlbWVzW3RoZW1lXTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGVycik7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhcHBseVRoZW1lKHRoZW1lKTtcbiAgfVxufTtcblxuXG5hZGRQcm9wZXJ0eSgnc3RyaXBDb2xvcnMnLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAoXCJcIiArIHRoaXMpLnJlcGxhY2UoL1xceDFCXFxbXFxkK20vZywgJycpO1xufSk7XG5cbi8vIHBsZWFzZSBub1xuZnVuY3Rpb24gemFsZ28odGV4dCwgb3B0aW9ucykge1xuICB2YXIgc291bCA9IHtcbiAgICBcInVwXCIgOiBbXG4gICAgICAnzI0nLCAnzI4nLCAnzIQnLCAnzIUnLFxuICAgICAgJ8y/JywgJ8yRJywgJ8yGJywgJ8yQJyxcbiAgICAgICfNkicsICfNlycsICfNkScsICfMhycsXG4gICAgICAnzIgnLCAnzIonLCAnzYInLCAnzJMnLFxuICAgICAgJ8yIJywgJ82KJywgJ82LJywgJ82MJyxcbiAgICAgICfMgycsICfMgicsICfMjCcsICfNkCcsXG4gICAgICAnzIAnLCAnzIEnLCAnzIsnLCAnzI8nLFxuICAgICAgJ8ySJywgJ8yTJywgJ8yUJywgJ8y9JyxcbiAgICAgICfMiScsICfNoycsICfNpCcsICfNpScsXG4gICAgICAnzaYnLCAnzacnLCAnzagnLCAnzaknLFxuICAgICAgJ82qJywgJ82rJywgJ82sJywgJ82tJyxcbiAgICAgICfNricsICfNrycsICfMvicsICfNmycsXG4gICAgICAnzYYnLCAnzJonXG4gICAgXSxcbiAgICBcImRvd25cIiA6IFtcbiAgICAgICfMlicsICfMlycsICfMmCcsICfMmScsXG4gICAgICAnzJwnLCAnzJ0nLCAnzJ4nLCAnzJ8nLFxuICAgICAgJ8ygJywgJ8ykJywgJ8ylJywgJ8ymJyxcbiAgICAgICfMqScsICfMqicsICfMqycsICfMrCcsXG4gICAgICAnzK0nLCAnzK4nLCAnzK8nLCAnzLAnLFxuICAgICAgJ8yxJywgJ8yyJywgJ8yzJywgJ8y5JyxcbiAgICAgICfMuicsICfMuycsICfMvCcsICfNhScsXG4gICAgICAnzYcnLCAnzYgnLCAnzYknLCAnzY0nLFxuICAgICAgJ82OJywgJ82TJywgJ82UJywgJ82VJyxcbiAgICAgICfNlicsICfNmScsICfNmicsICfMoydcbiAgICBdLFxuICAgIFwibWlkXCIgOiBbXG4gICAgICAnzJUnLCAnzJsnLCAnzIAnLCAnzIEnLFxuICAgICAgJ82YJywgJ8yhJywgJ8yiJywgJ8ynJyxcbiAgICAgICfMqCcsICfMtCcsICfMtScsICfMticsXG4gICAgICAnzZwnLCAnzZ0nLCAnzZ4nLFxuICAgICAgJ82fJywgJ82gJywgJ82iJywgJ8y4JyxcbiAgICAgICfMtycsICfNoScsICcg0oknXG4gICAgXVxuICB9LFxuICBhbGwgPSBbXS5jb25jYXQoc291bC51cCwgc291bC5kb3duLCBzb3VsLm1pZCksXG4gIHphbGdvID0ge307XG5cbiAgZnVuY3Rpb24gcmFuZG9tTnVtYmVyKHJhbmdlKSB7XG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiByYW5nZSk7XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBmdW5jdGlvbiBpc19jaGFyKGNoYXJhY3Rlcikge1xuICAgIHZhciBib29sID0gZmFsc2U7XG4gICAgYWxsLmZpbHRlcihmdW5jdGlvbiAoaSkge1xuICAgICAgYm9vbCA9IChpID09PSBjaGFyYWN0ZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiBib29sO1xuICB9XG5cbiAgZnVuY3Rpb24gaGVDb21lcyh0ZXh0LCBvcHRpb25zKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnLCBjb3VudHMsIGw7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9uc1tcInVwXCJdID0gb3B0aW9uc1tcInVwXCJdIHx8IHRydWU7XG4gICAgb3B0aW9uc1tcIm1pZFwiXSA9IG9wdGlvbnNbXCJtaWRcIl0gfHwgdHJ1ZTtcbiAgICBvcHRpb25zW1wiZG93blwiXSA9IG9wdGlvbnNbXCJkb3duXCJdIHx8IHRydWU7XG4gICAgb3B0aW9uc1tcInNpemVcIl0gPSBvcHRpb25zW1wic2l6ZVwiXSB8fCBcIm1heGlcIjtcbiAgICB0ZXh0ID0gdGV4dC5zcGxpdCgnJyk7XG4gICAgZm9yIChsIGluIHRleHQpIHtcbiAgICAgIGlmIChpc19jaGFyKGwpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcmVzdWx0ICsgdGV4dFtsXTtcbiAgICAgIGNvdW50cyA9IHtcInVwXCIgOiAwLCBcImRvd25cIiA6IDAsIFwibWlkXCIgOiAwfTtcbiAgICAgIHN3aXRjaCAob3B0aW9ucy5zaXplKSB7XG4gICAgICBjYXNlICdtaW5pJzpcbiAgICAgICAgY291bnRzLnVwID0gcmFuZG9tTnVtYmVyKDgpO1xuICAgICAgICBjb3VudHMubWluID0gcmFuZG9tTnVtYmVyKDIpO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtYXhpJzpcbiAgICAgICAgY291bnRzLnVwID0gcmFuZG9tTnVtYmVyKDE2KSArIDM7XG4gICAgICAgIGNvdW50cy5taW4gPSByYW5kb21OdW1iZXIoNCkgKyAxO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig2NCkgKyAzO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvdW50cy51cCA9IHJhbmRvbU51bWJlcig4KSArIDE7XG4gICAgICAgIGNvdW50cy5taWQgPSByYW5kb21OdW1iZXIoNikgLyAyO1xuICAgICAgICBjb3VudHMuZG93biA9IHJhbmRvbU51bWJlcig4KSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJyID0gW1widXBcIiwgXCJtaWRcIiwgXCJkb3duXCJdO1xuICAgICAgZm9yICh2YXIgZCBpbiBhcnIpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gYXJyW2RdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPD0gY291bnRzW2luZGV4XTsgaSsrKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbnNbaW5kZXhdKSB7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgKyBzb3VsW2luZGV4XVtyYW5kb21OdW1iZXIoc291bFtpbmRleF0ubGVuZ3RoKV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhlQ29tZXModGV4dCk7XG59XG5cblxuLy8gZG9uJ3Qgc3VtbW9uIHphbGdvXG5hZGRQcm9wZXJ0eSgnemFsZ28nLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB6YWxnbyh0aGlzKTtcbn0pO1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9ICByZXF1aXJlKCcuL2xpYi8nKTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlanNvbiA9IHJlcXVpcmUoJ3BhcnNlanNvbicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogTm9vcCBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fVxuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0ID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcbiAgICAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0KSB7XG4gICAgdmFyIHBpZWNlcyA9IG9wdHMuaG9zdC5zcGxpdCgnOicpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwaWVjZXMuc2hpZnQoKTtcbiAgICBpZiAocGllY2VzLmxlbmd0aCkge1xuICAgICAgb3B0cy5wb3J0ID0gcGllY2VzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoIW9wdHMucG9ydCkge1xuICAgICAgLy8gaWYgbm8gcG9ydCBpcyBzcGVjaWZpZWQgbWFudWFsbHksIHVzZSB0aGUgcHJvdG9jb2wgZGVmYXVsdFxuICAgICAgb3B0cy5wb3J0ID0gdGhpcy5zZWN1cmUgPyAnNDQzJyA6ICc4MCc7XG4gICAgfVxuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cbiAgICAgICBsb2NhdGlvbi5wb3J0IDpcbiAgICAgICAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5qc29ucCA9IGZhbHNlICE9PSBvcHRzLmpzb25wO1xuICB0aGlzLmZvcmNlQmFzZTY0ID0gISFvcHRzLmZvcmNlQmFzZTY0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSAhIW9wdHMuZW5hYmxlc1hEUjtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlciA9IFtdO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLmJpbmFyeVR5cGUgPSBudWxsO1xuICB0aGlzLm9ubHlCaW5hcnlVcGdyYWRlcyA9IG9wdHMub25seUJpbmFyeVVwZ3JhZGVzO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4IHx8IG51bGw7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXkgfHwgbnVsbDtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlIHx8IG51bGw7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydCB8fCBudWxsO1xuICB0aGlzLmNhID0gb3B0cy5jYSB8fCBudWxsO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnMgfHwgbnVsbDtcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCB8fCBudWxsO1xuXG4gIHRoaXMub3BlbigpO1xufVxuXG5Tb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7IC8vIHRoaXMgaXMgYW4gaW50XG5cbi8qKlxuICogRXhwb3NlIGRlcHMgZm9yIGxlZ2FjeSBjb21wYXRpYmlsaXR5XG4gKiBhbmQgc3RhbmRhbG9uZSBicm93c2VyIGFjY2Vzcy5cbiAqL1xuXG5Tb2NrZXQuU29ja2V0ID0gU29ja2V0O1xuU29ja2V0LlRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0Jyk7XG5Tb2NrZXQudHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xuU29ja2V0LnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRyYW5zcG9ydCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgZGVidWcoJ2NyZWF0aW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHF1ZXJ5ID0gY2xvbmUodGhpcy5xdWVyeSk7XG5cbiAgLy8gYXBwZW5kIGVuZ2luZS5pbyBwcm90b2NvbCBpZGVudGlmaWVyXG4gIHF1ZXJ5LkVJTyA9IHBhcnNlci5wcm90b2NvbDtcblxuICAvLyB0cmFuc3BvcnQgbmFtZVxuICBxdWVyeS50cmFuc3BvcnQgPSBuYW1lO1xuXG4gIC8vIHNlc3Npb24gaWQgaWYgd2UgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAodGhpcy5pZCkgcXVlcnkuc2lkID0gdGhpcy5pZDtcblxuICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydHNbbmFtZV0oe1xuICAgIGFnZW50OiB0aGlzLmFnZW50LFxuICAgIGhvc3RuYW1lOiB0aGlzLmhvc3RuYW1lLFxuICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICBzZWN1cmU6IHRoaXMuc2VjdXJlLFxuICAgIHBhdGg6IHRoaXMucGF0aCxcbiAgICBxdWVyeTogcXVlcnksXG4gICAgZm9yY2VKU09OUDogdGhpcy5mb3JjZUpTT05QLFxuICAgIGpzb25wOiB0aGlzLmpzb25wLFxuICAgIGZvcmNlQmFzZTY0OiB0aGlzLmZvcmNlQmFzZTY0LFxuICAgIGVuYWJsZXNYRFI6IHRoaXMuZW5hYmxlc1hEUixcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG4gICAgc29ja2V0OiB0aGlzLFxuICAgIHBmeDogdGhpcy5wZngsXG4gICAga2V5OiB0aGlzLmtleSxcbiAgICBwYXNzcGhyYXNlOiB0aGlzLnBhc3NwaHJhc2UsXG4gICAgY2VydDogdGhpcy5jZXJ0LFxuICAgIGNhOiB0aGlzLmNhLFxuICAgIGNpcGhlcnM6IHRoaXMuY2lwaGVycyxcbiAgICByZWplY3RVbmF1dGhvcml6ZWQ6IHRoaXMucmVqZWN0VW5hdXRob3JpemVkXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2UgaWYgKDAgPT0gdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xuICAgIC8vIEVtaXQgZXJyb3Igb24gbmV4dCB0aWNrIHNvIGl0IGNhbiBiZSBsaXN0ZW5lZCB0b1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5lbWl0KCdlcnJvcicsICdObyB0cmFuc3BvcnRzIGF2YWlsYWJsZScpO1xuICAgIH0sIDApO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIFJldHJ5IHdpdGggdGhlIG5leHQgdHJhbnNwb3J0IGlmIHRoZSB0cmFuc3BvcnQgaXMgZGlzYWJsZWQgKGpzb25wOiBmYWxzZSlcbiAgdmFyIHRyYW5zcG9ydDtcbiAgdHJ5IHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7XG4gICAgdGhpcy5vcGVuKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpe1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG4gICAgLCBmYWlsZWQgPSBmYWxzZVxuICAgICwgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PSBtc2cudHlwZSAmJiAncHJvYmUnID09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSByZXR1cm47XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pe1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwKCl7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gIHRoaXMub25PcGVuKCk7XG4gIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgaWYgICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHB1YmxpY1xuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByZXZCdWZmZXJMZW47IGkrKykge1xuICAgIGlmICh0aGlzLmNhbGxiYWNrQnVmZmVyW2ldKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrQnVmZmVyW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA9PSAwKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIGZuKSB7XG4gIGlmICgnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlci5wdXNoKGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zaW5nJztcblxuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgc2VsZi5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICAgIGRlYnVnKCdzb2NrZXQgY2xvc2luZyAtIHRlbGxpbmcgdHJhbnNwb3J0IHRvIGNsb3NlJyk7XG4gICAgICBzZWxmLnRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBBbmRDbG9zZSgpIHtcbiAgICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd2FpdEZvclVwZ3JhZGUoKSB7XG4gICAgICAvLyB3YWl0IGZvciB1cGdyYWRlIHRvIGZpbmlzaCBzaW5jZSB3ZSBjYW4ndCBzZW5kIHBhY2tldHMgd2hpbGUgcGF1c2luZyBhIHRyYW5zcG9ydFxuICAgICAgc2VsZi5vbmNlKCd1cGdyYWRlJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICAgIHNlbGYub25jZSgndXBncmFkZUVycm9yJywgY2xlYW51cEFuZENsb3NlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICAgICAgd2FpdEZvclVwZ3JhZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudXBncmFkaW5nKSB7XG4gICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgZXJyb3JcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gIGRlYnVnKCdzb2NrZXQgZXJyb3IgJWonLCBlcnIpO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLm9uQ2xvc2UoJ3RyYW5zcG9ydCBlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAocmVhc29uLCBkZXNjKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBpbiBuZXh0IHRpY2ssIHNvIGRldmVsb3BlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgIHNlbGYuY2FsbGJhY2tCdWZmZXIgPSBbXTtcbiAgICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gICAgfSwgMCk7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQSBjb3VudGVyIHVzZWQgdG8gcHJldmVudCBjb2xsaXNpb25zIGluIHRoZSB0aW1lc3RhbXBzIHVzZWRcbiAqIGZvciBjYWNoZSBidXN0aW5nLlxuICovXG5cblRyYW5zcG9ydC50aW1lc3RhbXBzID0gMDtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuICB2YXIgeHMgPSBmYWxzZTtcbiAgdmFyIGpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB4cyA9IG9wdHMuc2VjdXJlICE9IGlzU1NMO1xuICB9XG5cbiAgb3B0cy54ZG9tYWluID0geGQ7XG4gIG9wdHMueHNjaGVtZSA9IHhzO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghanNvbnApIHRocm93IG5ldyBFcnJvcignSlNPTlAgZGlzYWJsZWQnKTtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG4vKipcbiAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG5cbnZhciByTmV3bGluZSA9IC9cXG4vZztcbnZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG5cbi8qKlxuICogQ2FsbGJhY2tzIGNvdW50LlxuICovXG5cbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7IH1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcbiAgICBjYWxsYmFja3MgPSBnbG9iYWwuX19fZWlvO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuICB0aGlzLmluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgIHNlbGYub25EYXRhKG1zZyk7XG4gIH0pO1xuXG4gIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcbiAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICAgIHRoaXMuaWZyYW1lID0gbnVsbDtcbiAgfVxuXG4gIFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG5cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7XG4gICAgdGhpcy5zY3JpcHQgPSBudWxsO1xuICB9XG5cbiAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgc2NyaXB0LnNyYyA9IHRoaXMudXJpKCk7XG4gIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsIGVycm9yJyxlKTtcbiAgfTtcblxuICB2YXIgaW5zZXJ0QXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF07XG4gIGluc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaW5zZXJ0QXQpO1xuICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcblxuICB2YXIgaXNVQWdlY2tvID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvciAmJiAvZ2Vja28vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICBcbiAgaWYgKGlzVUFnZWNrbykge1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgIH0sIDEwMCk7XG4gIH1cbn07XG5cbi8qKlxuICogV3JpdGVzIHdpdGggYSBoaWRkZW4gaWZyYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGZuKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXRoaXMuZm9ybSkge1xuICAgIHZhciBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgIHZhciBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICB2YXIgaWQgPSB0aGlzLmlmcmFtZUlkID0gJ2Vpb19pZnJhbWVfJyArIHRoaXMuaW5kZXg7XG4gICAgdmFyIGlmcmFtZTtcblxuICAgIGZvcm0uY2xhc3NOYW1lID0gJ3NvY2tldGlvJztcbiAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBmb3JtLnN0eWxlLnRvcCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnN0eWxlLmxlZnQgPSAnLTEwMDBweCc7XG4gICAgZm9ybS50YXJnZXQgPSBpZDtcbiAgICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgICBmb3JtLnNldEF0dHJpYnV0ZSgnYWNjZXB0LWNoYXJzZXQnLCAndXRmLTgnKTtcbiAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuXG4gICAgdGhpcy5mb3JtID0gZm9ybTtcbiAgICB0aGlzLmFyZWEgPSBhcmVhO1xuICB9XG5cbiAgdGhpcy5mb3JtLmFjdGlvbiA9IHRoaXMudXJpKCk7XG5cbiAgZnVuY3Rpb24gY29tcGxldGUgKCkge1xuICAgIGluaXRJZnJhbWUoKTtcbiAgICBmbigpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdElmcmFtZSAoKSB7XG4gICAgaWYgKHNlbGYuaWZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gaWU2IGR5bmFtaWMgaWZyYW1lcyB3aXRoIHRhcmdldD1cIlwiIHN1cHBvcnQgKHRoYW5rcyBDaHJpcyBMYW1iYWNoZXIpXG4gICAgICB2YXIgaHRtbCA9ICc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInKyBzZWxmLmlmcmFtZUlkICsnXCI+JztcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBpZnJhbWUubmFtZSA9IHNlbGYuaWZyYW1lSWQ7XG4gICAgICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6MCc7XG4gICAgfVxuXG4gICAgaWZyYW1lLmlkID0gc2VsZi5pZnJhbWVJZDtcblxuICAgIHNlbGYuZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHNlbGYuaWZyYW1lID0gaWZyYW1lO1xuICB9XG5cbiAgaW5pdElmcmFtZSgpO1xuXG4gIC8vIGVzY2FwZSBcXG4gdG8gcHJldmVudCBpdCBmcm9tIGJlaW5nIGNvbnZlcnRlZCBpbnRvIFxcclxcbiBieSBzb21lIFVBc1xuICAvLyBkb3VibGUgZXNjYXBpbmcgaXMgcmVxdWlyZWQgZm9yIGVzY2FwZWQgbmV3IGxpbmVzIGJlY2F1c2UgdW5lc2NhcGluZyBvZiBuZXcgbGluZXMgY2FuIGJlIGRvbmUgc2FmZWx5IG9uIHNlcnZlci1zaWRlXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UockVzY2FwZWROZXdsaW5lLCAnXFxcXFxcbicpO1xuICB0aGlzLmFyZWEudmFsdWUgPSBkYXRhLnJlcGxhY2Uock5ld2xpbmUsICdcXFxcbicpO1xuXG4gIHRyeSB7XG4gICAgdGhpcy5mb3JtLnN1Ym1pdCgpO1xuICB9IGNhdGNoKGUpIHt9XG5cbiAgaWYgKHRoaXMuaWZyYW1lLmF0dGFjaEV2ZW50KSB7XG4gICAgdGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLmlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaWZyYW1lLm9ubG9hZCA9IGNvbXBsZXRlO1xuICB9XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgICB0aGlzLnhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChYSFIsIFBvbGxpbmcpO1xuXG4vKipcbiAqIFhIUiBzdXBwb3J0cyBiaW5hcnlcbiAqL1xuXG5YSFIucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihvcHRzKXtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIG9wdHMudXJpID0gdGhpcy51cmkoKTtcbiAgb3B0cy54ZCA9IHRoaXMueGQ7XG4gIG9wdHMueHMgPSB0aGlzLnhzO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIG9wdHMuZW5hYmxlc1hEUiA9IHRoaXMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KG9wdHMpO1xufTtcblxuLyoqXG4gKiBTZW5kcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIHRvIHNlbmQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGZuKXtcbiAgdmFyIGlzQmluYXJ5ID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnICYmIGRhdGEgIT09IHVuZGVmaW5lZDtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCh7IG1ldGhvZDogJ1BPU1QnLCBkYXRhOiBkYXRhLCBpc0JpbmFyeTogaXNCaW5hcnkgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdzdWNjZXNzJywgZm4pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb3N0IGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMuc2VuZFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogU3RhcnRzIGEgcG9sbCBjeWNsZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvUG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCd4aHIgcG9sbCcpO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmVxLm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgc2VsZi5vbkRhdGEoZGF0YSk7XG4gIH0pO1xuICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3hociBwb2xsIGVycm9yJywgZXJyKTtcbiAgfSk7XG4gIHRoaXMucG9sbFhociA9IHJlcTtcbn07XG5cbi8qKlxuICogUmVxdWVzdCBjb25zdHJ1Y3RvclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFJlcXVlc3Qob3B0cyl7XG4gIHRoaXMubWV0aG9kID0gb3B0cy5tZXRob2QgfHwgJ0dFVCc7XG4gIHRoaXMudXJpID0gb3B0cy51cmk7XG4gIHRoaXMueGQgPSAhIW9wdHMueGQ7XG4gIHRoaXMueHMgPSAhIW9wdHMueHM7XG4gIHRoaXMuYXN5bmMgPSBmYWxzZSAhPT0gb3B0cy5hc3luYztcbiAgdGhpcy5kYXRhID0gdW5kZWZpbmVkICE9IG9wdHMuZGF0YSA/IG9wdHMuZGF0YSA6IG51bGw7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50O1xuICB0aGlzLmlzQmluYXJ5ID0gb3B0cy5pc0JpbmFyeTtcbiAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IG9wdHMuc3VwcG9ydHNCaW5hcnk7XG4gIHRoaXMuZW5hYmxlc1hEUiA9IG9wdHMuZW5hYmxlc1hEUjtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgdGhpcy5wZnggPSBvcHRzLnBmeDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleTtcbiAgdGhpcy5wYXNzcGhyYXNlID0gb3B0cy5wYXNzcGhyYXNlO1xuICB0aGlzLmNlcnQgPSBvcHRzLmNlcnQ7XG4gIHRoaXMuY2EgPSBvcHRzLmNhO1xuICB0aGlzLmNpcGhlcnMgPSBvcHRzLmNpcGhlcnM7XG4gIHRoaXMucmVqZWN0VW5hdXRob3JpemVkID0gb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdGhpcy5jcmVhdGUoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIENyZWF0ZXMgdGhlIFhIUiBvYmplY3QgYW5kIHNlbmRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBvcHRzID0geyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCwgeHNjaGVtZTogdGhpcy54cywgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSIH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHZhciB4aHIgPSB0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICBpZiAodGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgICAgLy8gVGhpcyBoYXMgdG8gYmUgZG9uZSBhZnRlciBvcGVuIGJlY2F1c2UgRmlyZWZveCBpcyBzdHVwaWRcbiAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTMyMTY5MDMvZ2V0LWJpbmFyeS1kYXRhLXdpdGgteG1saHR0cHJlcXVlc3QtaW4tYS1maXJlZm94LWV4dGVuc2lvblxuICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgfVxuXG4gICAgaWYgKCdQT1NUJyA9PSB0aGlzLm1ldGhvZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgfTtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgICAgc2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGlmICg0ICE9IHhoci5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgICAgIGlmICgyMDAgPT0geGhyLnN0YXR1cyB8fCAxMjIzID09IHhoci5zdGF0dXMpIHtcbiAgICAgICAgICBzZWxmLm9uTG9hZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKHRydWUpO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgaG91c2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cCA9IGZ1bmN0aW9uKGZyb21FcnJvcil7XG4gIGlmICgndW5kZWZpbmVkJyA9PSB0eXBlb2YgdGhpcy54aHIgfHwgbnVsbCA9PT0gdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8geG1saHR0cHJlcXVlc3RcbiAgaWYgKHRoaXMuaGFzWERSKCkpIHtcbiAgICB0aGlzLnhoci5vbmxvYWQgPSB0aGlzLnhoci5vbmVycm9yID0gZW1wdHk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZW1wdHk7XG4gIH1cblxuICBpZiAoZnJvbUVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMueGhyLmFib3J0KCk7XG4gICAgfSBjYXRjaChlKSB7fVxuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIGRlbGV0ZSBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdO1xuICB9XG5cbiAgdGhpcy54aHIgPSBudWxsO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBsb2FkLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uTG9hZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBkYXRhO1xuICB0cnkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB0cnkge1xuICAgICAgY29udGVudFR5cGUgPSB0aGlzLnhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJykuc3BsaXQoJzsnKVswXTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpIHtcbiAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgIGRhdGEgPSB0aGlzLnhoci5yZXNwb25zZVRleHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gJ29rJztcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLm9uRXJyb3IoZSk7XG4gIH1cbiAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgIHRoaXMub25EYXRhKGRhdGEpO1xuICB9XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGl0IGhhcyBYRG9tYWluUmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5oYXNYRFIgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgIXRoaXMueHMgJiYgdGhpcy5lbmFibGVzWERSO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBBYm9ydHMgcGVuZGluZyByZXF1ZXN0cyB3aGVuIHVubG9hZGluZyB0aGUgd2luZG93LiBUaGlzIGlzIG5lZWRlZCB0byBwcmV2ZW50XG4gKiBtZW1vcnkgbGVha3MgKGUuZy4gd2hlbiB1c2luZyBJRSkgYW5kIHRvIGVuc3VyZSB0aGF0IG5vIHNwdXJpb3VzIGVycm9yIGlzXG4gKiBlbWl0dGVkLlxuICovXG5cbmlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgUmVxdWVzdC5yZXF1ZXN0c0NvdW50ID0gMDtcbiAgUmVxdWVzdC5yZXF1ZXN0cyA9IHt9O1xuICBpZiAoZ2xvYmFsLmF0dGFjaEV2ZW50KSB7XG4gICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbnVubG9hZCcsIHVubG9hZEhhbmRsZXIpO1xuICB9IGVsc2UgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHVubG9hZEhhbmRsZXIsIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi90cmFuc3BvcnQnKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6cG9sbGluZycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxuLyoqXG4gKiBJcyBYSFIyIHN1cHBvcnRlZD9cbiAqL1xuXG52YXIgaGFzWEhSMiA9IChmdW5jdGlvbigpIHtcbiAgdmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKTtcbiAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCh7IHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKG9uUGF1c2Upe1xuICB2YXIgcGVuZGluZyA9IDA7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UoKXtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UoKXtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9ICtuZXcgRGF0ZSArICctJyArIFRyYW5zcG9ydC50aW1lc3RhbXBzKys7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgdGhpcy5ob3N0bmFtZSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBgd3NgIGV4cG9zZXMgYSBXZWJTb2NrZXQtY29tcGF0aWJsZSBpbnRlcmZhY2UgaW5cbiAqIE5vZGUsIG9yIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG4gKiBpbiB0aGUgYnJvd3Nlci5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gV1Mob3B0cyl7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcbiAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50IH07XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIG9wdHMucGZ4ID0gdGhpcy5wZng7XG4gIG9wdHMua2V5ID0gdGhpcy5rZXk7XG4gIG9wdHMucGFzc3BocmFzZSA9IHRoaXMucGFzc3BocmFzZTtcbiAgb3B0cy5jZXJ0ID0gdGhpcy5jZXJ0O1xuICBvcHRzLmNhID0gdGhpcy5jYTtcbiAgb3B0cy5jaXBoZXJzID0gdGhpcy5jaXBoZXJzO1xuICBvcHRzLnJlamVjdFVuYXV0aG9yaXplZCA9IHRoaXMucmVqZWN0VW5hdXRob3JpemVkO1xuXG4gIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzLCBvcHRzKTtcblxuICBpZiAodGhpcy53cy5iaW5hcnlUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG59O1xuXG4vKipcbiAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBzb2NrZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy53cy5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25PcGVuKCk7XG4gIH07XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCk7XG4gIH07XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpe1xuICAgIHNlbGYub25EYXRhKGV2LmRhdGEpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ3dlYnNvY2tldCBlcnJvcicsIGUpO1xuICB9O1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgb25EYXRhYCB0byB1c2UgYSB0aW1lciBvbiBpT1MuXG4gKiBTZWU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21sb3VnaHJhbi8yMDUyMDA2XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3JcbiAgJiYgL2lQYWR8aVBob25lfGlQb2QvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gIFdTLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEuY2FsbChzZWxmLCBkYXRhKTtcbiAgICB9LCAwKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBXcml0ZXMgZGF0YSB0byBzb2NrZXQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2YgcGFja2V0cy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgLy8gZW5jb2RlUGFja2V0IGVmZmljaWVudCBhcyBpdCB1c2VzIFdTIGZyYW1pbmdcbiAgLy8gbm8gbmVlZCBmb3IgZW5jb2RlUGF5bG9hZFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhY2tldHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXRzW2ldLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAvL1NvbWV0aW1lcyB0aGUgd2Vic29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkIGJ1dCB0aGUgYnJvd3NlciBkaWRuJ3RcbiAgICAgIC8vaGF2ZSBhIGNoYW5jZSBvZiBpbmZvcm1pbmcgdXMgYWJvdXQgaXQgeWV0LCBpbiB0aGF0IGNhc2Ugc2VuZCB3aWxsXG4gICAgICAvL3Rocm93IGFuIGVycm9yXG4gICAgICB0cnkge1xuICAgICAgICBzZWxmLndzLnNlbmQoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgZGVidWcoJ3dlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnQnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9XG4gIC8vIGZha2UgZHJhaW5cbiAgLy8gZGVmZXIgdG8gbmV4dCB0aWNrIHRvIGFsbG93IFNvY2tldCB0byBjbGVhciB3cml0ZUJ1ZmZlclxuICBzZXRUaW1lb3V0KG9uZHJhaW4sIDApO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24oKXtcbiAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIENsb3NlcyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBpZiAodHlwZW9mIHRoaXMud3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLnVyaSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBxdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG4gIHZhciBzY2hlbWEgPSB0aGlzLnNlY3VyZSA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ3dzcycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA0NDMpXG4gICAgfHwgKCd3cycgPT0gc2NoZW1hICYmIHRoaXMucG9ydCAhPSA4MCkpKSB7XG4gICAgcG9ydCA9ICc6JyArIHRoaXMucG9ydDtcbiAgfVxuXG4gIC8vIGFwcGVuZCB0aW1lc3RhbXAgdG8gVVJJXG4gIGlmICh0aGlzLnRpbWVzdGFtcFJlcXVlc3RzKSB7XG4gICAgcXVlcnlbdGhpcy50aW1lc3RhbXBQYXJhbV0gPSArbmV3IERhdGU7XG4gIH1cblxuICAvLyBjb21tdW5pY2F0ZSBiaW5hcnkgc3VwcG9ydCBjYXBhYmlsaXRpZXNcbiAgaWYgKCF0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIHByZXBlbmQgPyB0byBxdWVyeVxuICBpZiAocXVlcnkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSAnPycgKyBxdWVyeTtcbiAgfVxuXG4gIHJldHVybiBzY2hlbWEgKyAnOi8vJyArIHRoaXMuaG9zdG5hbWUgKyBwb3J0ICsgdGhpcy5wYXRoICsgcXVlcnk7XG59O1xuXG4vKipcbiAqIEZlYXR1cmUgZGV0ZWN0aW9uIGZvciBXZWJTb2NrZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciB0aGlzIHRyYW5zcG9ydCBpcyBhdmFpbGFibGUuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAhIVdlYlNvY2tldCAmJiAhKCdfX2luaXRpYWxpemUnIGluIFdlYlNvY2tldCAmJiB0aGlzLm5hbWUgPT09IFdTLnByb3RvdHlwZS5uYW1lKTtcbn07XG4iLCIvLyBicm93c2VyIHNoaW0gZm9yIHhtbGh0dHByZXF1ZXN0IG1vZHVsZVxudmFyIGhhc0NPUlMgPSByZXF1aXJlKCdoYXMtY29ycycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgdmFyIHhkb21haW4gPSBvcHRzLnhkb21haW47XG5cbiAgLy8gc2NoZW1lIG11c3QgYmUgc2FtZSB3aGVuIHVzaWduIFhEb21haW5SZXF1ZXN0XG4gIC8vIGh0dHA6Ly9ibG9ncy5tc2RuLmNvbS9iL2llaW50ZXJuYWxzL2FyY2hpdmUvMjAxMC8wNS8xMy94ZG9tYWlucmVxdWVzdC1yZXN0cmljdGlvbnMtbGltaXRhdGlvbnMtYW5kLXdvcmthcm91bmRzLmFzcHhcbiAgdmFyIHhzY2hlbWUgPSBvcHRzLnhzY2hlbWU7XG5cbiAgLy8gWERvbWFpblJlcXVlc3QgaGFzIGEgZmxvdyBvZiBub3Qgc2VuZGluZyBjb29raWUsIHRoZXJlZm9yZSBpdCBzaG91bGQgYmUgZGlzYWJsZWQgYXMgYSBkZWZhdWx0LlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXV0b21hdHRpYy9lbmdpbmUuaW8tY2xpZW50L3B1bGwvMjE3XG4gIHZhciBlbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICAvLyBVc2UgWERvbWFpblJlcXVlc3QgZm9yIElFOCBpZiBlbmFibGVzWERSIGlzIHRydWVcbiAgLy8gYmVjYXVzZSBsb2FkaW5nIGJhciBrZWVwcyBmbGFzaGluZyB3aGVuIHVzaW5nIGpzb25wLXBvbGxpbmdcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3l1amlvc2FrYS9zb2NrZS5pby1pZTgtbG9hZGluZy1leGFtcGxlXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYRG9tYWluUmVxdWVzdCAmJiAheHNjaGVtZSAmJiBlbmFibGVzWERSKSB7XG4gICAgICByZXR1cm4gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2goZSkgeyB9XG4gIH1cbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07IiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gVGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgsXG4gIC8vIHdoZXJlIHRoZSBgY29uc29sZS5sb2dgIGZ1bmN0aW9uIGRvZXNuJ3QgaGF2ZSAnYXBwbHknXG4gIHJldHVybiAnb2JqZWN0JyA9PSB0eXBlb2YgY29uc29sZVxuICAgICYmICdmdW5jdGlvbicgPT0gdHlwZW9mIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsb2NhbFN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBsb2NhbFN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1zfHNlY29uZHM/fHN8bWludXRlcz98bXxob3Vycz98aHxkYXlzP3xkfHllYXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBoYXNCaW5hcnkgPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbnZhciBhZnRlciA9IHJlcXVpcmUoJ2FmdGVyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgaW4gUGhhbnRvbUpTLlxuICogVXBsb2FkaW5nIGEgQmxvYiB3aXRoIFBoYW50b21KUyBkb2VzIG5vdCB3b3JrIGNvcnJlY3RseSwgYXMgcmVwb3J0ZWQgaGVyZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcml5YS9waGFudG9tanMvaXNzdWVzLzExMzk1XG4gKiBAdHlwZSBib29sZWFuXG4gKi9cbnZhciBpc1BoYW50b21KUyA9IC9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIFdoZW4gdHJ1ZSwgYXZvaWRzIHVzaW5nIEJsb2JzIHRvIGVuY29kZSBwYXlsb2Fkcy5cbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGRvbnRTZW5kQmxvYnMgPSBpc0FuZHJvaWQgfHwgaXNQaGFudG9tSlM7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIHV0ZjhlbmNvZGUpIHtcbiAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgdXRmOGVuY29kZSA9IG51bGw7XG4gIH1cblxuICB2YXIgZGF0YSA9IChwYWNrZXQuZGF0YSA9PT0gdW5kZWZpbmVkKVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiBwYWNrZXQuZGF0YS5idWZmZXIgfHwgcGFja2V0LmRhdGE7XG5cbiAgaWYgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKEJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIGdsb2JhbC5CbG9iKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gbWlnaHQgYmUgYW4gb2JqZWN0IHdpdGggeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIGlmIChkYXRhICYmIGRhdGEuYmFzZTY0KSB7XG4gICAgcmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKSA6IFN0cmluZyhwYWNrZXQuZGF0YSk7XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcblxufTtcblxuZnVuY3Rpb24gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgLy8gcGFja2V0IGRhdGEgaXMgYW4gb2JqZWN0IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBkYXRhQXNCYXNlNjRTdHJpbmcgfVxuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0gKyBwYWNrZXQuZGF0YS5kYXRhO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChkb250U2VuZEJsb2JzKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBpc0JpbmFyeSA9IGhhc0JpbmFyeShwYWNrZXRzKTtcblxuICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaXNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhZG9udFNlbmRCbG9icykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYihwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQXJyYXlCdWZmZXIocGFja2V0cywgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSB7XG4gICAgcmV0dXJuIG1lc3NhZ2UubGVuZ3RoICsgJzonICsgbWVzc2FnZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgIWlzQmluYXJ5ID8gZmFsc2UgOiBzdXBwb3J0c0JpbmFyeSwgdHJ1ZSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnXG4gICAgLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmICgnOicgIT0gY2hyKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJycgPT0gbGVuZ3RoIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgaSArPSBuO1xuICAgICAgbGVuZ3RoID0gJyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCAhPSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHZhciBudW1iZXJUb29Mb25nID0gZmFsc2U7XG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG5cbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcblxuICAgICAgaWYgKG1zZ0xlbmd0aC5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgbnVtYmVyVG9vTG9uZyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cblxuICAgIGlmKG51bWJlclRvb0xvbmcpIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuXG4gICAgYnVmZmVyVGFpbCA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDIgKyBtc2dMZW5ndGgubGVuZ3RoKTtcbiAgICBtc2dMZW5ndGggPSBwYXJzZUludChtc2dMZW5ndGgpO1xuXG4gICAgdmFyIG1zZyA9IHNsaWNlQnVmZmVyKGJ1ZmZlclRhaWwsIDAsIG1zZ0xlbmd0aCk7XG4gICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBtc2cgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KG1zZykpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB0byB0eXBlZCBhcnJheXNcbiAgICAgICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkobXNnKTtcbiAgICAgICAgbXNnID0gJyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBtc2cgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0eXBlZFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG4iLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKGNoYXJzKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO1xuICAgICAgZW5jb2RlZDIgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtcbiAgICAgIGVuY29kZWQzID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7XG4gICAgICBlbmNvZGVkNCA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKTtcbiIsIi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBiID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYi5zaXplID09IDI7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYkJ1aWxkZXJTdXBwb3J0ZWQgPSBCbG9iQnVpbGRlclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBiYi5hcHBlbmQoYXJ5W2ldKTtcbiAgfVxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJsb2I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuIiwiXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIGlmIChvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLyohIGh0dHA6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4wLjAgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXTtcblx0XHR2YXIgY291bnRlciA9IDA7XG5cdFx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvLyBUYWtlbiBmcm9tIGh0dHA6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblxuXHRcdC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGNvZGVQb2ludHMubWFwKGZ1bmN0aW9uKHgpIHtcblx0XHQvLyBcdHJldHVybiAnVSsnICsgeC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0XHQvLyB9KSkpO1xuXG5cdFx0dmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cdFx0dmFyIGJ5dGVTdHJpbmcgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0Y29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG5cdFx0XHRieXRlU3RyaW5nICs9IGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnl0ZVN0cmluZztcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuXHRcdGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0dmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHRpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG5cdFx0XHRyZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdH1cblxuXHRmdW5jdGlvbiBkZWNvZGVTeW1ib2woKSB7XG5cdFx0dmFyIGJ5dGUxO1xuXHRcdHZhciBieXRlMjtcblx0XHR2YXIgYnl0ZTM7XG5cdFx0dmFyIGJ5dGU0O1xuXHRcdHZhciBjb2RlUG9pbnQ7XG5cblx0XHRpZiAoYnl0ZUluZGV4ID4gYnl0ZUNvdW50KSB7XG5cdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ5dGVJbmRleCA9PSBieXRlQ291bnQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBSZWFkIGZpcnN0IGJ5dGVcblx0XHRieXRlMSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG5cdFx0XHRyZXR1cm4gYnl0ZTE7XG5cdFx0fVxuXG5cdFx0Ly8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcblx0XHRcdHZhciBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciB1dGY4ID0ge1xuXHRcdCd2ZXJzaW9uJzogJzIuMC4wJyxcblx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0fSk7XG5cdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdXRmOCkge1xuXHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdH1cblxufSh0aGlzKSk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnZ2xvYmFsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKlxuICogTG9naWMgYm9ycm93ZWQgZnJvbSBNb2Rlcm5penI6XG4gKlxuICogICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9jb3JzLmpzXG4gKi9cblxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAnWE1MSHR0cFJlcXVlc3QnIGluIGdsb2JhbCAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuIiwiXG4vKipcbiAqIFJldHVybnMgYHRoaXNgLiBFeGVjdXRlIHRoaXMgd2l0aG91dCBhIFwiY29udGV4dFwiIChpLmUuIHdpdGhvdXQgaXQgYmVpbmdcbiAqIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgbGVmdC1oYW5kIHNpZGUpLCBhbmQgYHRoaXNgIHBvaW50cyB0byB0aGVcbiAqIFwiZ2xvYmFsXCIgc2NvcGUgb2YgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiLyoqXG4gKiBKU09OIHBhcnNlLlxuICpcbiAqIEBzZWUgQmFzZWQgb24galF1ZXJ5I3BhcnNlSlNPTiAoTUlUKSBhbmQgSlNPTjJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBydmFsaWRjaGFycyA9IC9eW1xcXSw6e31cXHNdKiQvO1xudmFyIHJ2YWxpZGVzY2FwZSA9IC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2c7XG52YXIgcnZhbGlkdG9rZW5zID0gL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nO1xudmFyIHJ2YWxpZGJyYWNlcyA9IC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZztcbnZhciBydHJpbUxlZnQgPSAvXlxccysvO1xudmFyIHJ0cmltUmlnaHQgPSAvXFxzKyQvO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlanNvbihkYXRhKSB7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgZGF0YSB8fCAhZGF0YSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZGF0YSA9IGRhdGEucmVwbGFjZShydHJpbUxlZnQsICcnKS5yZXBsYWNlKHJ0cmltUmlnaHQsICcnKTtcblxuICAvLyBBdHRlbXB0IHRvIHBhcnNlIHVzaW5nIHRoZSBuYXRpdmUgSlNPTiBwYXJzZXIgZmlyc3RcbiAgaWYgKGdsb2JhbC5KU09OICYmIEpTT04ucGFyc2UpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcbiAgfVxuXG4gIGlmIChydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsICdAJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZHRva2VucywgJ10nKVxuICAgICAgLnJlcGxhY2UocnZhbGlkYnJhY2VzLCAnJykpKSB7XG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oJ3JldHVybiAnICsgZGF0YSkpKCk7XG4gIH1cbn07IiwiLyoqXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHFzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcbiAgdmFyIHFyeSA9IHt9O1xuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgfVxuICByZXR1cm4gcXJ5O1xufTtcbiIsIi8qKlxuICogUGFyc2VzIGFuIFVSSVxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG52YXIgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0JywgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICAgIHZhciBzcmMgPSBzdHIsXG4gICAgICAgIGIgPSBzdHIuaW5kZXhPZignWycpLFxuICAgICAgICBlID0gc3RyLmluZGV4T2YoJ10nKTtcblxuICAgIGlmIChiICE9IC0xICYmIGUgIT0gLTEpIHtcbiAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBiKSArIHN0ci5zdWJzdHJpbmcoYiwgZSkucmVwbGFjZSgvOi9nLCAnOycpICsgc3RyLnN1YnN0cmluZyhlLCBzdHIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKSxcbiAgICAgICAgdXJpID0ge30sXG4gICAgICAgIGkgPSAxNDtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfVxuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICB1cmkuc291cmNlID0gc3JjO1xuICAgICAgICB1cmkuaG9zdCA9IHVyaS5ob3N0LnN1YnN0cmluZygxLCB1cmkuaG9zdC5sZW5ndGggLSAxKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5hdXRob3JpdHkgPSB1cmkuYXV0aG9yaXR5LnJlcGxhY2UoJ1snLCAnJykucmVwbGFjZSgnXScsICcnKS5yZXBsYWNlKC87L2csICc6Jyk7XG4gICAgICAgIHVyaS5pcHY2dXJpID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJpO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuXG4vKipcbiAqIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0ID8gd3MgOiBudWxsO1xuXG4vKipcbiAqIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgdGhpcmQgYG9wdHNgIG9wdGlvbnMgb2JqZWN0IGdldHMgaWdub3JlZCBpbiB3ZWIgYnJvd3NlcnMsIHNpbmNlIGl0J3NcbiAqIG5vbi1zdGFuZGFyZCwgYW5kIHRocm93cyBhIFR5cGVFcnJvciBpZiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZWluYXJvcy93cy9pc3N1ZXMvMjI3XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIChvcHRpb25hbClcbiAqIEBwYXJhbSB7T2JqZWN0KSBvcHRzIChvcHRpb25hbClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gd3ModXJpLCBwcm90b2NvbHMsIG9wdHMpIHtcbiAgdmFyIGluc3RhbmNlO1xuICBpZiAocHJvdG9jb2xzKSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBXZWJTb2NrZXQodXJpKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmlmIChXZWJTb2NrZXQpIHdzLnByb3RvdHlwZSA9IFdlYlNvY2tldC5wcm90b3R5cGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvY29yZS5qcycpXG5yZXF1aXJlKCcuL2xpYi9kb25lLmpzJylcbnJlcXVpcmUoJy4vbGliL2VzNi1leHRlbnNpb25zLmpzJylcbnJlcXVpcmUoJy4vbGliL25vZGUtZXh0ZW5zaW9ucy5qcycpIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5mdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJylcbiAgdmFyIHN0YXRlID0gbnVsbFxuICB2YXIgdmFsdWUgPSBudWxsXG4gIHZhciBkZWZlcnJlZHMgPSBbXVxuICB2YXIgc2VsZiA9IHRoaXNcblxuICB0aGlzLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgIHJldHVybiBuZXcgc2VsZi5jb25zdHJ1Y3RvcihmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGhhbmRsZShuZXcgSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0KSlcbiAgICB9KVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlKGRlZmVycmVkKSB7XG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICBkZWZlcnJlZHMucHVzaChkZWZlcnJlZClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBhc2FwKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNiID0gc3RhdGUgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWRcbiAgICAgIGlmIChjYiA9PT0gbnVsbCkge1xuICAgICAgICAoc3RhdGUgPyBkZWZlcnJlZC5yZXNvbHZlIDogZGVmZXJyZWQucmVqZWN0KSh2YWx1ZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgcmV0XG4gICAgICB0cnkge1xuICAgICAgICByZXQgPSBjYih2YWx1ZSlcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGRlZmVycmVkLnJlamVjdChlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGRlZmVycmVkLnJlc29sdmUocmV0KVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKG5ld1ZhbHVlKSB7XG4gICAgdHJ5IHsgLy9Qcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIHByb21pc2UgY2Fubm90IGJlIHJlc29sdmVkIHdpdGggaXRzZWxmLicpXG4gICAgICBpZiAobmV3VmFsdWUgJiYgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICB2YXIgdGhlbiA9IG5ld1ZhbHVlLnRoZW5cbiAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZG9SZXNvbHZlKHRoZW4uYmluZChuZXdWYWx1ZSksIHJlc29sdmUsIHJlamVjdClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3RhdGUgPSB0cnVlXG4gICAgICB2YWx1ZSA9IG5ld1ZhbHVlXG4gICAgICBmaW5hbGUoKVxuICAgIH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdChuZXdWYWx1ZSkge1xuICAgIHN0YXRlID0gZmFsc2VcbiAgICB2YWx1ZSA9IG5ld1ZhbHVlXG4gICAgZmluYWxlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmFsZSgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVmZXJyZWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKVxuICAgICAgaGFuZGxlKGRlZmVycmVkc1tpXSlcbiAgICBkZWZlcnJlZHMgPSBudWxsXG4gIH1cblxuICBkb1Jlc29sdmUoZm4sIHJlc29sdmUsIHJlamVjdClcbn1cblxuXG5mdW5jdGlvbiBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3Qpe1xuICB0aGlzLm9uRnVsZmlsbGVkID0gdHlwZW9mIG9uRnVsZmlsbGVkID09PSAnZnVuY3Rpb24nID8gb25GdWxmaWxsZWQgOiBudWxsXG4gIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGxcbiAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZVxuICB0aGlzLnJlamVjdCA9IHJlamVjdFxufVxuXG4vKipcbiAqIFRha2UgYSBwb3RlbnRpYWxseSBtaXNiZWhhdmluZyByZXNvbHZlciBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlXG4gKiBvbkZ1bGZpbGxlZCBhbmQgb25SZWplY3RlZCBhcmUgb25seSBjYWxsZWQgb25jZS5cbiAqXG4gKiBNYWtlcyBubyBndWFyYW50ZWVzIGFib3V0IGFzeW5jaHJvbnkuXG4gKi9cbmZ1bmN0aW9uIGRvUmVzb2x2ZShmbiwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBmbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmIChkb25lKSByZXR1cm5cbiAgICAgIGRvbmUgPSB0cnVlXG4gICAgICBvbkZ1bGZpbGxlZCh2YWx1ZSlcbiAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgICBkb25lID0gdHJ1ZVxuICAgICAgb25SZWplY3RlZChyZWFzb24pXG4gICAgfSlcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuXG4gICAgZG9uZSA9IHRydWVcbiAgICBvblJlamVjdGVkKGV4KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJylcbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZVxuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB2YXIgc2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRoZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXNcbiAgc2VsZi50aGVuKG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGVyclxuICAgIH0pXG4gIH0pXG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vL1RoaXMgZmlsZSBjb250YWlucyB0aGUgRVM2IGV4dGVuc2lvbnMgdG8gdGhlIGNvcmUgUHJvbWlzZXMvQSsgQVBJXG5cbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi9jb3JlLmpzJylcbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZVxuXG4vKiBTdGF0aWMgRnVuY3Rpb25zICovXG5cbmZ1bmN0aW9uIFZhbHVlUHJvbWlzZSh2YWx1ZSkge1xuICB0aGlzLnRoZW4gPSBmdW5jdGlvbiAob25GdWxmaWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIG9uRnVsZmlsbGVkICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpc1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXNvbHZlKG9uRnVsZmlsbGVkKHZhbHVlKSlcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICByZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblZhbHVlUHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlLnByb3RvdHlwZVxuXG52YXIgVFJVRSA9IG5ldyBWYWx1ZVByb21pc2UodHJ1ZSlcbnZhciBGQUxTRSA9IG5ldyBWYWx1ZVByb21pc2UoZmFsc2UpXG52YXIgTlVMTCA9IG5ldyBWYWx1ZVByb21pc2UobnVsbClcbnZhciBVTkRFRklORUQgPSBuZXcgVmFsdWVQcm9taXNlKHVuZGVmaW5lZClcbnZhciBaRVJPID0gbmV3IFZhbHVlUHJvbWlzZSgwKVxudmFyIEVNUFRZU1RSSU5HID0gbmV3IFZhbHVlUHJvbWlzZSgnJylcblxuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiB2YWx1ZVxuXG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIE5VTExcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBVTkRFRklORURcbiAgaWYgKHZhbHVlID09PSB0cnVlKSByZXR1cm4gVFJVRVxuICBpZiAodmFsdWUgPT09IGZhbHNlKSByZXR1cm4gRkFMU0VcbiAgaWYgKHZhbHVlID09PSAwKSByZXR1cm4gWkVST1xuICBpZiAodmFsdWUgPT09ICcnKSByZXR1cm4gRU1QVFlTVFJJTkdcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHRoZW4gPSB2YWx1ZS50aGVuXG4gICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHRoZW4uYmluZCh2YWx1ZSkpXG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChleClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ldyBWYWx1ZVByb21pc2UodmFsdWUpXG59XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24gKGFycikge1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFycilcblxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pXG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoXG4gICAgZnVuY3Rpb24gcmVzKGksIHZhbCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHZhbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICB2YXIgdGhlbiA9IHZhbC50aGVuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGVuLmNhbGwodmFsLCBmdW5jdGlvbiAodmFsKSB7IHJlcyhpLCB2YWwpIH0sIHJlamVjdClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdzW2ldID0gdmFsXG4gICAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICAgIHJlc29sdmUoYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIHJlamVjdChleClcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXMoaSwgYXJnc1tpXSlcbiAgICB9XG4gIH0pXG59XG5cblByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IFxuICAgIHJlamVjdCh2YWx1ZSk7XG4gIH0pO1xufVxuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IFxuICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH0pXG4gIH0pO1xufVxuXG4vKiBQcm90b3R5cGUgTWV0aG9kcyAqL1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBmaWxlIGNvbnRhaW5zIHRoZW4vcHJvbWlzZSBzcGVjaWZpYyBleHRlbnNpb25zIHRoYXQgYXJlIG9ubHkgdXNlZnVsIGZvciBub2RlLmpzIGludGVyb3BcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKVxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJylcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlXG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxuUHJvbWlzZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoZm4sIGFyZ3VtZW50Q291bnQpIHtcbiAgYXJndW1lbnRDb3VudCA9IGFyZ3VtZW50Q291bnQgfHwgSW5maW5pdHlcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXNcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgd2hpbGUgKGFyZ3MubGVuZ3RoICYmIGFyZ3MubGVuZ3RoID4gYXJndW1lbnRDb3VudCkge1xuICAgICAgICBhcmdzLnBvcCgpXG4gICAgICB9XG4gICAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpXG4gICAgICAgIGVsc2UgcmVzb2x2ZShyZXMpXG4gICAgICB9KVxuICAgICAgdmFyIHJlcyA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpXG4gICAgICBpZiAocmVzICYmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcmVzID09PSAnZnVuY3Rpb24nKSAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVzb2x2ZShyZXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuUHJvbWlzZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpXG4gICAgdmFyIGNhbGxiYWNrID0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJyA/IGFyZ3MucG9wKCkgOiBudWxsXG4gICAgdmFyIGN0eCA9IHRoaXNcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykubm9kZWlmeShjYWxsYmFjaywgY3R4KVxuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHJlamVjdChleCkgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBleClcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuUHJvbWlzZS5wcm90b3R5cGUubm9kZWlmeSA9IGZ1bmN0aW9uIChjYWxsYmFjaywgY3R4KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHRoaXNcblxuICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGN0eCwgbnVsbCwgdmFsdWUpXG4gICAgfSlcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGVycilcbiAgICB9KVxuICB9KVxufVxuIiwiXG4vLyBVc2UgdGhlIGZhc3Rlc3QgcG9zc2libGUgbWVhbnMgdG8gZXhlY3V0ZSBhIHRhc2sgaW4gYSBmdXR1cmUgdHVyblxuLy8gb2YgdGhlIGV2ZW50IGxvb3AuXG5cbi8vIGxpbmtlZCBsaXN0IG9mIHRhc2tzIChzaW5nbGUsIHdpdGggaGVhZCBub2RlKVxudmFyIGhlYWQgPSB7dGFzazogdm9pZCAwLCBuZXh0OiBudWxsfTtcbnZhciB0YWlsID0gaGVhZDtcbnZhciBmbHVzaGluZyA9IGZhbHNlO1xudmFyIHJlcXVlc3RGbHVzaCA9IHZvaWQgMDtcbnZhciBpc05vZGVKUyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6IHRydWUgKi9cblxuICAgIHdoaWxlIChoZWFkLm5leHQpIHtcbiAgICAgICAgaGVhZCA9IGhlYWQubmV4dDtcbiAgICAgICAgdmFyIHRhc2sgPSBoZWFkLnRhc2s7XG4gICAgICAgIGhlYWQudGFzayA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGRvbWFpbiA9IGhlYWQuZG9tYWluO1xuXG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGhlYWQuZG9tYWluID0gdm9pZCAwO1xuICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzaygpO1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChpc05vZGVKUykge1xuICAgICAgICAgICAgICAgIC8vIEluIG5vZGUsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIGNvbnNpZGVyZWQgZmF0YWwgZXJyb3JzLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gc3luY2hyb25vdXNseSB0byBpbnRlcnJ1cHQgZmx1c2hpbmchXG5cbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgY29udGludWF0aW9uIGlmIHRoZSB1bmNhdWdodCBleGNlcHRpb24gaXMgc3VwcHJlc3NlZFxuICAgICAgICAgICAgICAgIC8vIGxpc3RlbmluZyBcInVuY2F1Z2h0RXhjZXB0aW9uXCIgZXZlbnRzIChhcyBkb21haW5zIGRvZXMpLlxuICAgICAgICAgICAgICAgIC8vIENvbnRpbnVlIGluIG5leHQgZXZlbnQgdG8gYXZvaWQgdGljayByZWN1cnNpb24uXG4gICAgICAgICAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5lbnRlcigpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IGU7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gYnJvd3NlcnMsIHVuY2F1Z2h0IGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC5cbiAgICAgICAgICAgICAgICAvLyBSZS10aHJvdyB0aGVtIGFzeW5jaHJvbm91c2x5IHRvIGF2b2lkIHNsb3ctZG93bnMuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZsdXNoaW5nID0gZmFsc2U7XG59XG5cbmlmICh0eXBlb2YgcHJvY2VzcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLm5leHRUaWNrKSB7XG4gICAgLy8gTm9kZS5qcyBiZWZvcmUgMC45LiBOb3RlIHRoYXQgc29tZSBmYWtlLU5vZGUgZW52aXJvbm1lbnRzLCBsaWtlIHRoZVxuICAgIC8vIE1vY2hhIHRlc3QgcnVubmVyLCBpbnRyb2R1Y2UgYSBgcHJvY2Vzc2AgZ2xvYmFsIHdpdGhvdXQgYSBgbmV4dFRpY2tgLlxuICAgIGlzTm9kZUpTID0gdHJ1ZTtcblxuICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gICAgfTtcblxufSBlbHNlIGlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAvLyBJbiBJRTEwLCBOb2RlLmpzIDAuOSssIG9yIGh0dHBzOi8vZ2l0aHViLmNvbS9Ob2JsZUpTL3NldEltbWVkaWF0ZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCA9IHNldEltbWVkaWF0ZS5iaW5kKHdpbmRvdywgZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShmbHVzaCk7XG4gICAgICAgIH07XG4gICAgfVxuXG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIG1vZGVybiBicm93c2Vyc1xuICAgIC8vIGh0dHA6Ly93d3cubm9uYmxvY2tpbmcuaW8vMjAxMS8wNi93aW5kb3duZXh0dGljay5odG1sXG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZsdXNoO1xuICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbiAgICB9O1xuXG59IGVsc2Uge1xuICAgIC8vIG9sZCBicm93c2Vyc1xuICAgIHJlcXVlc3RGbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2V0VGltZW91dChmbHVzaCwgMCk7XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gYXNhcCh0YXNrKSB7XG4gICAgdGFpbCA9IHRhaWwubmV4dCA9IHtcbiAgICAgICAgdGFzazogdGFzayxcbiAgICAgICAgZG9tYWluOiBpc05vZGVKUyAmJiBwcm9jZXNzLmRvbWFpbixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICAgIGZsdXNoaW5nID0gdHJ1ZTtcbiAgICAgICAgcmVxdWVzdEZsdXNoKCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhc2FwO1xuXG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIGlvO1xuXG4gIGlmIChvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHwgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4KSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG5cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCdvYmplY3QtY29tcG9uZW50Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIEJhY2tvZmYgPSByZXF1aXJlKCdiYWNrbzInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnJhbmRvbWl6YXRpb25GYWN0b3Iob3B0cy5yYW5kb21pemF0aW9uRmFjdG9yIHx8IDAuNSk7XG4gIHRoaXMuYmFja29mZiA9IG5ldyBCYWNrb2ZmKHtcbiAgICBtaW46IHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKSxcbiAgICBtYXg6IHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxcbiAgICBqaXR0ZXI6IHRoaXMucmFuZG9taXphdGlvbkZhY3RvcigpXG4gIH0pO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMuYXV0b0Nvbm5lY3QgPSBvcHRzLmF1dG9Db25uZWN0ICE9PSBmYWxzZTtcbiAgaWYgKHRoaXMuYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG4vKipcbiAqIFVwZGF0ZSBgc29ja2V0LmlkYCBvZiBhbGwgc29ja2V0c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZVNvY2tldElkcyA9IGZ1bmN0aW9uKCl7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICB0aGlzLm5zcHNbbnNwXS5pZCA9IHRoaXMuZW5naW5lLmlkO1xuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWluKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk1hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3IgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvcjtcbiAgdGhpcy5fcmFuZG9taXphdGlvbkZhY3RvciA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0Sml0dGVyKHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHRoaXMuYmFja29mZiAmJiB0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29ubmVjdGlvbiB0aW1lb3V0LiBgZmFsc2VgIHRvIGRpc2FibGVcbiAqXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fdGltZW91dDtcbiAgdGhpcy5fdGltZW91dCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdHJ5aW5nIHRvIHJlY29ubmVjdCBpZiByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBhbmQgd2UgaGF2ZSBub3RcbiAqIHN0YXJ0ZWQgcmVjb25uZWN0aW5nIHlldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm1heWJlUmVjb25uZWN0T25PcGVuID0gZnVuY3Rpb24oKSB7XG4gIC8vIE9ubHkgdHJ5IHRvIHJlY29ubmVjdCBpZiBpdCdzIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIGNvbm5lY3RpbmdcbiAgaWYgKCF0aGlzLnJlY29ubmVjdGluZyAmJiB0aGlzLl9yZWNvbm5lY3Rpb24gJiYgdGhpcy5iYWNrb2ZmLmF0dGVtcHRzID09PSAwKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB0aGlzLnNraXBSZWNvbm5lY3QgPSBmYWxzZTtcblxuICAvLyBlbWl0IGBvcGVuYFxuICB2YXIgb3BlblN1YiA9IG9uKHNvY2tldCwgJ29wZW4nLCBmdW5jdGlvbigpIHtcbiAgICBzZWxmLm9ub3BlbigpO1xuICAgIGZuICYmIGZuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfZXJyb3JgXG4gIHZhciBlcnJvclN1YiA9IG9uKHNvY2tldCwgJ2Vycm9yJywgZnVuY3Rpb24oZGF0YSl7XG4gICAgZGVidWcoJ2Nvbm5lY3RfZXJyb3InKTtcbiAgICBzZWxmLmNsZWFudXAoKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfZXJyb3InLCBkYXRhKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gZXJyb3InKTtcbiAgICAgIGVyci5kYXRhID0gZGF0YTtcbiAgICAgIGZuKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9ubHkgZG8gdGhpcyBpZiB0aGVyZSBpcyBubyBmbiB0byBoYW5kbGUgdGhlIGVycm9yXG4gICAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X3RpbWVvdXRgXG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fdGltZW91dCkge1xuICAgIHZhciB0aW1lb3V0ID0gdGhpcy5fdGltZW91dDtcbiAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHdpbGwgdGltZW91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuXG4gICAgLy8gc2V0IHRpbWVyXG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcbiAgICAgIG9wZW5TdWIuZGVzdHJveSgpO1xuICAgICAgc29ja2V0LmNsb3NlKCk7XG4gICAgICBzb2NrZXQuZW1pdCgnZXJyb3InLCAndGltZW91dCcpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X3RpbWVvdXQnLCB0aW1lb3V0KTtcbiAgICB9LCB0aW1lb3V0KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB0aGlzLnN1YnMucHVzaChvcGVuU3ViKTtcbiAgdGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnb3BlbicpO1xuXG4gIC8vIGNsZWFyIG9sZCBzdWJzXG4gIHRoaXMuY2xlYW51cCgpO1xuXG4gIC8vIG1hcmsgYXMgb3BlblxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xuXG4gIC8vIGFkZCBuZXcgc3Vic1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2RhdGEnLCBiaW5kKHRoaXMsICdvbmRhdGEnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbih0aGlzLmRlY29kZXIsICdkZWNvZGVkJywgYmluZCh0aGlzLCAnb25kZWNvZGVkJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZXJyb3InLCBiaW5kKHRoaXMsICdvbmVycm9yJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkID0gZnVuY3Rpb24ocGFja2V0KSB7XG4gIHRoaXMuZW1pdCgncGFja2V0JywgcGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc29ja2V0IGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICBkZWJ1ZygnZXJyb3InLCBlcnIpO1xuICB0aGlzLmVtaXRBbGwoJ2Vycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBzb2NrZXQgZm9yIHRoZSBnaXZlbiBgbnNwYC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnNvY2tldCA9IGZ1bmN0aW9uKG5zcCl7XG4gIHZhciBzb2NrZXQgPSB0aGlzLm5zcHNbbnNwXTtcbiAgaWYgKCFzb2NrZXQpIHtcbiAgICBzb2NrZXQgPSBuZXcgU29ja2V0KHRoaXMsIG5zcCk7XG4gICAgdGhpcy5uc3BzW25zcF0gPSBzb2NrZXQ7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNvY2tldC5vbignY29ubmVjdCcsIGZ1bmN0aW9uKCl7XG4gICAgICBzb2NrZXQuaWQgPSBzZWxmLmVuZ2luZS5pZDtcbiAgICAgIGlmICghfmluZGV4T2Yoc2VsZi5jb25uZWN0ZWQsIHNvY2tldCkpIHtcbiAgICAgICAgc2VsZi5jb25uZWN0ZWQucHVzaChzb2NrZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzb2NrZXQ7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc29ja2V0IGNsb3NlLlxuICpcbiAqIEBwYXJhbSB7U29ja2V0fSBzb2NrZXRcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oc29ja2V0KXtcbiAgdmFyIGluZGV4ID0gaW5kZXhPZih0aGlzLmNvbm5lY3RlZCwgc29ja2V0KTtcbiAgaWYgKH5pbmRleCkgdGhpcy5jb25uZWN0ZWQuc3BsaWNlKGluZGV4LCAxKTtcbiAgaWYgKHRoaXMuY29ubmVjdGVkLmxlbmd0aCkgcmV0dXJuO1xuXG4gIHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKXtcbiAgdmFyIHN1YjtcbiAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSBzdWIuZGVzdHJveSgpO1xuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbmdpbmUgJiYgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcgfHwgdGhpcy5za2lwUmVjb25uZWN0KSByZXR1cm4gdGhpcztcblxuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKHRoaXMuYmFja29mZi5hdHRlbXB0cyA+PSB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmJhY2tvZmYuZHVyYXRpb24oKTtcbiAgICBkZWJ1Zygnd2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0JywgZGVsYXkpO1xuXG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5iYWNrb2ZmLmF0dGVtcHRzKTtcblxuICAgICAgLy8gY2hlY2sgYWdhaW4gZm9yIHRoZSBjYXNlIHNvY2tldCBjbG9zZWQgaW4gYWJvdmUgZXZlbnRzXG4gICAgICBpZiAoc2VsZi5za2lwUmVjb25uZWN0KSByZXR1cm47XG5cbiAgICAgIHNlbGYub3BlbihmdW5jdGlvbihlcnIpe1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBhdHRlbXB0IGVycm9yJyk7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdCgpO1xuICAgICAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2Vycm9yJywgZXJyLmRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3Qgc3VjY2VzcycpO1xuICAgICAgICAgIHNlbGYub25yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgZGVsYXkpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhdHRlbXB0ID0gdGhpcy5iYWNrb2ZmLmF0dGVtcHRzO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgdGhpcy51cGRhdGVTb2NrZXRJZHMoKTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldChpbywgbnNwKXtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIGlmICh0aGlzLmlvLmF1dG9Db25uZWN0KSB0aGlzLm9wZW4oKTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnN1YnMpIHJldHVybjtcblxuICB2YXIgaW8gPSB0aGlzLmlvO1xuICB0aGlzLnN1YnMgPSBbXG4gICAgb24oaW8sICdvcGVuJywgYmluZCh0aGlzLCAnb25vcGVuJykpLFxuICAgIG9uKGlvLCAncGFja2V0JywgYmluZCh0aGlzLCAnb25wYWNrZXQnKSksXG4gICAgb24oaW8sICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSlcbiAgXTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPVxuU29ja2V0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnN1YkV2ZW50cygpO1xuICB0aGlzLmlvLm9wZW4oKTsgLy8gZW5zdXJlIG9wZW5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLmlvLnJlYWR5U3RhdGUpIHRoaXMub25vcGVuKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oKXtcbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIGFyZ3MudW5zaGlmdCgnbWVzc2FnZScpO1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBgZW1pdGAuXG4gKiBJZiB0aGUgZXZlbnQgaXMgaW4gYGV2ZW50c2AsIGl0J3MgZW1pdHRlZCBub3JtYWxseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgbmFtZVxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2KXtcbiAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldikpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgdmFyIHBhcnNlclR5cGUgPSBwYXJzZXIuRVZFTlQ7IC8vIGRlZmF1bHRcbiAgaWYgKGhhc0JpbihhcmdzKSkgeyBwYXJzZXJUeXBlID0gcGFyc2VyLkJJTkFSWV9FVkVOVDsgfSAvLyBiaW5hcnlcbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogcGFyc2VyVHlwZSwgZGF0YTogYXJncyB9O1xuXG4gIC8vIGV2ZW50IGFjayBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdKSB7XG4gICAgZGVidWcoJ2VtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZCcsIHRoaXMuaWRzKTtcbiAgICB0aGlzLmFja3NbdGhpcy5pZHNdID0gYXJncy5wb3AoKTtcbiAgICBwYWNrZXQuaWQgPSB0aGlzLmlkcysrO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgdGhpcy5wYWNrZXQocGFja2V0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgcGFja2V0Lm5zcCA9IHRoaXMubnNwO1xuICB0aGlzLmlvLnBhY2tldChwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgZGVsZXRlIHRoaXMuaWQ7XG4gIHRoaXMuZW1pdCgnZGlzY29ubmVjdCcsIHJlYXNvbik7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIHNvY2tldCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGlmIChwYWNrZXQubnNwICE9IHRoaXMubnNwKSByZXR1cm47XG5cbiAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgIGNhc2UgcGFyc2VyLkNPTk5FQ1Q6XG4gICAgICB0aGlzLm9uY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5CSU5BUllfQUNLOlxuICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5ESVNDT05ORUNUOlxuICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVJST1I6XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgcGFja2V0LmRhdGEpO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmV2ZW50ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgdmFyIGFyZ3MgPSBwYWNrZXQuZGF0YSB8fCBbXTtcbiAgZGVidWcoJ2VtaXR0aW5nIGV2ZW50ICVqJywgYXJncyk7XG5cbiAgaWYgKG51bGwgIT0gcGFja2V0LmlkKSB7XG4gICAgZGVidWcoJ2F0dGFjaGluZyBhY2sgY2FsbGJhY2sgdG8gZXZlbnQnKTtcbiAgICBhcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSk7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpO1xuICB9XG59O1xuXG4vKipcbiAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5hY2sgPSBmdW5jdGlvbihpZCl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNlbnQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgLy8gcHJldmVudCBkb3VibGUgY2FsbGJhY2tzXG4gICAgaWYgKHNlbnQpIHJldHVybjtcbiAgICBzZW50ID0gdHJ1ZTtcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICBkZWJ1Zygnc2VuZGluZyBhY2sgJWonLCBhcmdzKTtcblxuICAgIHZhciB0eXBlID0gaGFzQmluKGFyZ3MpID8gcGFyc2VyLkJJTkFSWV9BQ0sgOiBwYXJzZXIuQUNLO1xuICAgIHNlbGYucGFja2V0KHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBpZDogaWQsXG4gICAgICBkYXRhOiBhcmdzXG4gICAgfSk7XG4gIH07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGFja25vd2xlZ2VtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25hY2sgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBkZWJ1ZygnY2FsbGluZyBhY2sgJXMgd2l0aCAlaicsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICB2YXIgZm4gPSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbiAgZm4uYXBwbHkodGhpcywgcGFja2V0LmRhdGEpO1xuICBkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Nvbm5lY3QnKTtcbiAgdGhpcy5lbWl0QnVmZmVyZWQoKTtcbn07XG5cbi8qKlxuICogRW1pdCBidWZmZXJlZCBldmVudHMgKHJlY2VpdmVkIGFuZCBlbWl0dGVkKS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXRCdWZmZXJlZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBpO1xuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5yZWNlaXZlQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCB0aGlzLnJlY2VpdmVCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMucmVjZWl2ZUJ1ZmZlciA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnNlbmRCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pO1xuICB9XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgZGlzY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdzZXJ2ZXIgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgdGhpcy5vbmNsb3NlKCdpbyBzZXJ2ZXIgZGlzY29ubmVjdCcpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBmb3JjZWQgY2xpZW50L3NlcnZlciBzaWRlIGRpc2Nvbm5lY3Rpb25zLFxuICogdGhpcyBtZXRob2QgZW5zdXJlcyB0aGUgbWFuYWdlciBzdG9wcyB0cmFja2luZyB1cyBhbmRcbiAqIHRoYXQgcmVjb25uZWN0aW9ucyBkb24ndCBnZXQgdHJpZ2dlcmVkIGZvciB0aGlzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZS5cbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5zdWJzKSB7XG4gICAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnN1YnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMuc3VicyA9IG51bGw7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICAgIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG4gIH1cblxuICAvLyByZW1vdmUgc29ja2V0IGZyb20gcG9vbFxuICB0aGlzLmRlc3Ryb3koKTtcblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAvLyBmaXJlIGV2ZW50c1xuICAgIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsKHVyaSwgbG9jKXtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICB2YXIgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3Q7XG5cbiAgLy8gcmVsYXRpdmUgcGF0aCBzdXBwb3J0XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgaWYgKCcvJyA9PSB1cmkuY2hhckF0KDApKSB7XG4gICAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMSkpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3RuYW1lICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIG9iai5ob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBvYmouaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG4iLCJcbi8qKlxuICogRXhwb3NlIGBCYWNrb2ZmYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhY2tvZmY7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBiYWNrb2ZmIHRpbWVyIHdpdGggYG9wdHNgLlxuICpcbiAqIC0gYG1pbmAgaW5pdGlhbCB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyBbMTAwXVxuICogLSBgbWF4YCBtYXggdGltZW91dCBbMTAwMDBdXG4gKiAtIGBqaXR0ZXJgIFswXVxuICogLSBgZmFjdG9yYCBbMl1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBCYWNrb2ZmKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMubXMgPSBvcHRzLm1pbiB8fCAxMDA7XG4gIHRoaXMubWF4ID0gb3B0cy5tYXggfHwgMTAwMDA7XG4gIHRoaXMuZmFjdG9yID0gb3B0cy5mYWN0b3IgfHwgMjtcbiAgdGhpcy5qaXR0ZXIgPSBvcHRzLmppdHRlciA+IDAgJiYgb3B0cy5qaXR0ZXIgPD0gMSA/IG9wdHMuaml0dGVyIDogMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBiYWNrb2ZmIGR1cmF0aW9uLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuZHVyYXRpb24gPSBmdW5jdGlvbigpe1xuICB2YXIgbXMgPSB0aGlzLm1zICogTWF0aC5wb3codGhpcy5mYWN0b3IsIHRoaXMuYXR0ZW1wdHMrKyk7XG4gIGlmICh0aGlzLmppdHRlcikge1xuICAgIHZhciByYW5kID0gIE1hdGgucmFuZG9tKCk7XG4gICAgdmFyIGRldmlhdGlvbiA9IE1hdGguZmxvb3IocmFuZCAqIHRoaXMuaml0dGVyICogbXMpO1xuICAgIG1zID0gKE1hdGguZmxvb3IocmFuZCAqIDEwKSAmIDEpID09IDAgID8gbXMgLSBkZXZpYXRpb24gOiBtcyArIGRldmlhdGlvbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4obXMsIHRoaXMubWF4KSB8IDA7XG59O1xuXG4vKipcbiAqIFJlc2V0IHRoZSBudW1iZXIgb2YgYXR0ZW1wdHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIG1pbmltdW0gZHVyYXRpb25cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldE1pbiA9IGZ1bmN0aW9uKG1pbil7XG4gIHRoaXMubXMgPSBtaW47XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWF4aW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWF4ID0gZnVuY3Rpb24obWF4KXtcbiAgdGhpcy5tYXggPSBtYXg7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgaml0dGVyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRKaXR0ZXIgPSBmdW5jdGlvbihqaXR0ZXIpe1xuICB0aGlzLmppdHRlciA9IGppdHRlcjtcbn07XG5cbiIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7VHlwZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZSkge1xuICBpZiAoIWRlYnVnLmVuYWJsZWQobmFtZSkpIHJldHVybiBmdW5jdGlvbigpe307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZtdCl7XG4gICAgZm10ID0gY29lcmNlKGZtdCk7XG5cbiAgICB2YXIgY3VyciA9IG5ldyBEYXRlO1xuICAgIHZhciBtcyA9IGN1cnIgLSAoZGVidWdbbmFtZV0gfHwgY3Vycik7XG4gICAgZGVidWdbbmFtZV0gPSBjdXJyO1xuXG4gICAgZm10ID0gbmFtZVxuICAgICAgKyAnICdcbiAgICAgICsgZm10XG4gICAgICArICcgKycgKyBkZWJ1Zy5odW1hbml6ZShtcyk7XG5cbiAgICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOFxuICAgIC8vIHdoZXJlIGBjb25zb2xlLmxvZ2AgZG9lc24ndCBoYXZlICdhcHBseSdcbiAgICB3aW5kb3cuY29uc29sZVxuICAgICAgJiYgY29uc29sZS5sb2dcbiAgICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcy5cbiAqL1xuXG5kZWJ1Zy5uYW1lcyA9IFtdO1xuZGVidWcuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmRlYnVnLmVuYWJsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UuZGVidWcgPSBuYW1lO1xuICB9IGNhdGNoKGUpe31cblxuICB2YXIgc3BsaXQgPSAobmFtZSB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKVxuICAgICwgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYW1lID0gc3BsaXRbaV0ucmVwbGFjZSgnKicsICcuKj8nKTtcbiAgICBpZiAobmFtZVswXSA9PT0gJy0nKSB7XG4gICAgICBkZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZS5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZSArICckJykpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmRlYnVnLmRpc2FibGUgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zy5lbmFibGUoJycpO1xufTtcblxuLyoqXG4gKiBIdW1hbml6ZSB0aGUgZ2l2ZW4gYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZGVidWcuaHVtYW5pemUgPSBmdW5jdGlvbihtcykge1xuICB2YXIgc2VjID0gMTAwMFxuICAgICwgbWluID0gNjAgKiAxMDAwXG4gICAgLCBob3VyID0gNjAgKiBtaW47XG5cbiAgaWYgKG1zID49IGhvdXIpIHJldHVybiAobXMgLyBob3VyKS50b0ZpeGVkKDEpICsgJ2gnO1xuICBpZiAobXMgPj0gbWluKSByZXR1cm4gKG1zIC8gbWluKS50b0ZpeGVkKDEpICsgJ20nO1xuICBpZiAobXMgPj0gc2VjKSByZXR1cm4gKG1zIC8gc2VjIHwgMCkgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZW5hYmxlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGRlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGRlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuLy8gcGVyc2lzdFxuXG50cnkge1xuICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkgZGVidWcuZW5hYmxlKGxvY2FsU3RvcmFnZS5kZWJ1Zyk7XG59IGNhdGNoKGUpe31cbiIsIlxuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIF9oYXNCaW5hcnkob2JqKSB7XG4gICAgaWYgKCFvYmopIHJldHVybiBmYWxzZTtcblxuICAgIGlmICggKGdsb2JhbC5CdWZmZXIgJiYgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgICBpZiAob2JqLnRvSlNPTikge1xuICAgICAgICBvYmogPSBvYmoudG9KU09OKCk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgX2hhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBfaGFzQmluYXJ5KGRhdGEpO1xufVxuIiwiXG4vKipcbiAqIEhPUCByZWYuXG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUmV0dXJuIG93biBrZXlzIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmope1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gb3duIHZhbHVlcyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbihvYmope1xuICB2YXIgdmFscyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFscy5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG4vKipcbiAqIE1lcmdlIGBiYCBpbnRvIGBhYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oYSwgYil7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhcy5jYWxsKGIsIGtleSkpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFJldHVybiBsZW5ndGggb2YgYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBleHBvcnRzLmtleXMob2JqKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiAwID09IGV4cG9ydHMubGVuZ3RoKG9iaik7XG59OyIsIi8qKlxuICogUGFyc2VzIGFuIFVSSVxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG52YXIgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0J1xuICAsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJylcbiAgICAsIHVyaSA9IHt9XG4gICAgLCBpID0gMTQ7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICB9XG5cbiAgcmV0dXJuIHVyaTtcbn07XG4iLCIvKmdsb2JhbCBCbG9iLEZpbGUqL1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYnVmZmVycyA9IFtdO1xuICB2YXIgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuXG4gIGZ1bmN0aW9uIF9kZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSByZXR1cm4gZGF0YTtcblxuICAgIGlmIChpc0J1ZihkYXRhKSkge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgIHJldHVybiBwbGFjZWhvbGRlcjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXdEYXRhW2ldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHBhY2sgPSBwYWNrZXQ7XG4gIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhKTtcbiAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgcmV0dXJuIHtwYWNrZXQ6IHBhY2ssIGJ1ZmZlcnM6IGJ1ZmZlcnN9O1xufTtcblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuICBmdW5jdGlvbiBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YSkge1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBlbHNlIGlmIChkYXRhICYmICdvYmplY3QnID09IHR5cGVvZiBkYXRhKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhKTtcbiAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gIHJldHVybiBwYWNrZXQ7XG59O1xuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IHJlbW92ZXMgQmxvYnMgb3IgRmlsZXMgZnJvbSBkYXRhIHZpYVxuICogRmlsZVJlYWRlcidzIHJlYWRBc0FycmF5QnVmZmVyIG1ldGhvZC4gVXNlZCBiZWZvcmUgZW5jb2RpbmdcbiAqIGRhdGEgYXMgbXNncGFjay4gQ2FsbHMgY2FsbGJhY2sgd2l0aCB0aGUgYmxvYmxlc3MgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMucmVtb3ZlQmxvYnMgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBfcmVtb3ZlQmxvYnMob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmopKSB7IC8vIGhhbmRsZSBhcnJheVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgX3JlbW92ZUJsb2JzKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICBfcmVtb3ZlQmxvYnMoYmxvYmxlc3NEYXRhKTtcbiAgaWYgKCFwZW5kaW5nQmxvYnMpIHtcbiAgICBjYWxsYmFjayhibG9ibGVzc0RhdGEpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGpzb24gPSByZXF1aXJlKCdqc29uMycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcbnZhciBpc0J1ZiA9IHJlcXVpcmUoJy4vaXMtYnVmZmVyJyk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudHlwZXMgPSBbXG4gICdDT05ORUNUJyxcbiAgJ0RJU0NPTk5FQ1QnLFxuICAnRVZFTlQnLFxuICAnQklOQVJZX0VWRU5UJyxcbiAgJ0FDSycsXG4gICdCSU5BUllfQUNLJyxcbiAgJ0VSUk9SJ1xuXTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkNPTk5FQ1QgPSAwO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBkaXNjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRElTQ09OTkVDVCA9IDE7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGV2ZW50YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVZFTlQgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBhY2tgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5BQ0sgPSAzO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBlcnJvcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVSUk9SID0gNDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSAnYmluYXJ5IGV2ZW50J1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfRVZFTlQgPSA1O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBiaW5hcnkgYWNrYC4gRm9yIGFja3Mgd2l0aCBiaW5hcnkgYXJndW1lbnRzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5CSU5BUllfQUNLID0gNjtcblxuLyoqXG4gKiBFbmNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2RlcjtcblxuLyoqXG4gKiBEZWNvZGVyIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbmNvZGVyKCkge31cblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBuc3AgPSBmYWxzZTtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHN0ciArPSBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG4gICAgc3RyICs9ICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG4gICAgbnNwID0gdHJ1ZTtcbiAgICBzdHIgKz0gb2JqLm5zcDtcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBpZiAobnNwKSB7XG4gICAgICBzdHIgKz0gJywnO1xuICAgICAgbnNwID0gZmFsc2U7XG4gICAgfVxuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuICAgIHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIERlY29kZXIoKSB7XG4gIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYCB3aXRoIERlY29kZXIuXG4gKi9cblxuRW1pdHRlcihEZWNvZGVyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogRGVjb2RlcyBhbiBlY29kZWQgcGFja2V0IHN0cmluZyBpbnRvIHBhY2tldCBKU09OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBwYWNrZXQ7XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2Ygb2JqKSB7XG4gICAgcGFja2V0ID0gZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHBhY2tldC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwYWNrZXQudHlwZSkgeyAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcblxuICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IucmVjb25QYWNrLmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoaXNCdWYob2JqKSB8fCBvYmouYmFzZTY0KSB7IC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgIGlmIChwYWNrZXQpIHsgLy8gcmVjZWl2ZWQgZmluYWwgYnVmZmVyXG4gICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlOiAnICsgb2JqKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIHAgPSB7fTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGxvb2sgdXAgdHlwZVxuICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICB2YXIgYnVmID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgIGJ1ZiArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPSAnLScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBhdHRhY2htZW50cycpO1xuICAgIH1cbiAgICBwLmF0dGFjaG1lbnRzID0gTnVtYmVyKGJ1Zik7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHRyeSB7XG4gICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIERlYWxsb2NhdGVzIGEgcGFyc2VyJ3MgcmVzb3VyY2VzXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufTtcblxuZnVuY3Rpb24gZXJyb3IoZGF0YSl7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXhwb3J0cy5FUlJPUixcbiAgICBkYXRhOiAncGFyc2VyIGVycm9yJ1xuICB9O1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGlzQnVmO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNCdWYob2JqKSB7XG4gIHJldHVybiAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cbiIsIi8qISBKU09OIHYzLjIuNiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDEzLCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKHdpbmRvdykge1xuICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICB2YXIgZ2V0Q2xhc3MgPSB7fS50b1N0cmluZywgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIERldGVjdCBuYXRpdmUgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgbmF0aXZlSlNPTiA9IHR5cGVvZiBKU09OID09IFwib2JqZWN0XCIgJiYgSlNPTjtcblxuICAvLyBTZXQgdXAgdGhlIEpTT04gMyBuYW1lc3BhY2UsIHByZWZlcnJpbmcgdGhlIENvbW1vbkpTIGBleHBvcnRzYCBvYmplY3QgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICB2YXIgSlNPTjMgPSB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICBpZiAoSlNPTjMgJiYgbmF0aXZlSlNPTikge1xuICAgIC8vIEV4cGxpY2l0bHkgZGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBpbiBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgSlNPTjMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgSlNPTjMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzLCBKYXZhU2NyaXB0IGVuZ2luZXMsIGFuZCBhc3luY2hyb25vdXMgbW9kdWxlXG4gICAgLy8gbG9hZGVycywgdXNpbmcgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGlmIGF2YWlsYWJsZS5cbiAgICBKU09OMyA9IHdpbmRvdy5KU09OID0gbmF0aXZlSlNPTiB8fCB7fTtcbiAgfVxuXG4gIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gIHRyeSB7XG4gICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgfVxuXG4gICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICB2YXIgc3RyaW5naWZ5ID0gSlNPTjMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgfVxuICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICB2YXIgcGFyc2UgPSBKU09OMy5wYXJzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuICAgIHZhciBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIjtcbiAgICB2YXIgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiO1xuICAgIHZhciBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCI7XG4gICAgdmFyIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgdmFyIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgaWYgKCEoaXNQcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5KSkge1xuICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWw6IEEgc2V0IG9mIHByaW1pdGl2ZSB0eXBlcyB1c2VkIGJ5IGBpc0hvc3RUeXBlYC5cbiAgICB2YXIgUHJpbWl0aXZlVHlwZXMgPSB7XG4gICAgICAnYm9vbGVhbic6IDEsXG4gICAgICAnbnVtYmVyJzogMSxcbiAgICAgICdzdHJpbmcnOiAxLFxuICAgICAgJ3VuZGVmaW5lZCc6IDFcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgdGhlIGdpdmVuIG9iamVjdCBgcHJvcGVydHlgIHZhbHVlIGlzIGFcbiAgICAvLyBub24tcHJpbWl0aXZlLlxuICAgIHZhciBpc0hvc3RUeXBlID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0JyA/ICEhb2JqZWN0W3Byb3BlcnR5XSA6ICFQcmltaXRpdmVUeXBlc1t0eXBlXTtcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gJ2Z1bmN0aW9uJyAmJiBpc0hvc3RUeXBlKG9iamVjdCwgJ2hhc093blByb3BlcnR5JykgPyBvYmplY3QuaGFzT3duUHJvcGVydHkgOiBpc1Byb3BlcnR5O1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCBpc0xhcmdlID0gbGVuZ3RoID4gMTAgJiYgY2hhckluZGV4QnVnZ3ksIHN5bWJvbHM7XG4gICAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgICAgc3ltYm9scyA9IHZhbHVlLnNwbGl0KFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBpc0xhcmdlID8gc3ltYm9sc1tpbmRleF0gOiBjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdChpbmRleCkgOiB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgIEpTT04zLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZmlsdGVyID09IFwib2JqZWN0XCIgJiYgZmlsdGVyKSB7XG4gICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgIDM0OiAnXCInLFxuICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbihzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgIEpTT04zLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0odGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5XG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXVxuXG4gICAgaW5kZXggPSBpbmRleCB8fCAwXG5cbiAgICBmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbn1cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBvYmplY3QgPSByZXF1aXJlKCcuLycpO1xuXG51dGlsLmRlZmluZShvYmplY3QsXG4gIC8qKlxuICAgKiBWLk9iamVjdCdzIGVxdWl2YWxlbnQgdG8gQXJyYXkucHVzaCgpXG4gICAqIEBtZXRob2QgcHVzaFxuICAgKiBAcGFyYW0gIHtBcmd1bWVudHN9ICBUaGUgaXRlbShzKSB0byBhZGQgdG8gdGhlIGFycmF5XG4gICAqIEByZXR1cm4ge051bWJlcn0gICAgIFRoZSBuZXcgbGVuZ3RoIG9mIHRoZSBhcnJheVxuICAgKi9cbiAgJ3B1c2gnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fX3QgPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0aGlzLl9wdXNoKGFyZ3VtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfVxuICB9LFxuICAnX3B1c2gnLCBmdW5jdGlvbih2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSkge1xuICAgIC8vYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbVxuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5zZXQoKHRoaXMubGVuZ3RoIC0gMSksIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tKTtcbiAgICByZXR1cm4gdGhpc1t0aGlzLmxlbmd0aCAtIDFdO1xuICB9LFxuICAvKipcbiAgICogVi5PYmplY3QncyBlcXVpdmFsZW50IHRvIEFycmF5LnBvcCgpXG4gICAqIEBtZXRob2QgcG9wXG4gICAqIEByZXR1cm4geyp9ICBUaGUgcmVtb3ZlZCBhcnJheSBpdGVtXG4gICAqL1xuICAncG9wJywgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX190ID09PSAxKSB7XG4gICAgICB2YXIgbCA9IHRoaXMubGVuZ3RoXG4gICAgICBpZihsICE9PSAwKXtcbiAgICAgICAgdCA9IHRoaXNbbCAtIDFdO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICB0LnJlbW92ZSgpO1xuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHQ7IC8vcHJldHR5IHdlaXJkIHNpbmNlIHRoaXMgb2JqZWN0IGFsd2F5cyBoYXMgdmFsdWUgbnVsbDtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBWLk9iamVjdCdzIGVxdWl2YWxlbnQgdG8gQXJyYXkuc3BsaWNlKClcbiAgICogQG1ldGhvZCBzcGxpY2VcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICBpbmRleCAgIEFuIGludGVnZXIgdGhhdCBzcGVjaWZpZXMgYXQgd2hhdCBwb3NpdGlvbiB0byBhZGQvcmVtb3ZlIGl0ZW1zLCBVc2UgbmVnYXRpdmUgdmFsdWVzIHRvIHNwZWNpZnkgdGhlIHBvc2l0aW9uIGZyb20gdGhlIGVuZCBvZiB0aGUgYXJyYXlcbiAgICogQHBhcmFtICB7TnVtYmVyfSAgICBob3dtYW55IFRoZSBudW1iZXIgb2YgaXRlbXMgdG8gYmUgcmVtb3ZlZC4gSWYgc2V0IHRvIDAsIG5vIGl0ZW1zIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBAcGFyYW0gIHtBcmd1bWVudHN9ICAgICAgICAgVGhlIG5ldyBpdGVtKHMpIHRvIGJlIGFkZGVkIHRvIHRoZSBhcnJheVxuICAgKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgQSBuZXcgYXJyYXkgY29udGFpbmluZyB0aGUgcmVtb3ZlZCBpdGVtcywgaWYgYW55XG4gICAqL1xuICAnc3BsaWNlJywgZnVuY3Rpb24oaW5kZXgsIGhvd21hbnkpIHsgLy9jYW4gYmVjb21lIHNob3J0ZXI7XG4gICAgaWYgKGluZGV4ID4gLTEgJiYgdGhpcy5fX3QgPT09IDEpIHsgLy9ob3cgbWFueSBhbmQgLWkgYXJlIGlnbm9yZWRcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGgsIHNoaWZ0OyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChzaGlmdCkge1xuICAgICAgICAgIGlmIChpID09PSBsIC0gMSkge1xuICAgICAgICAgICAgLy8gdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gdGhpc1tpICsgMV07XG4gICAgICAgICAgICB0aGlzW2ldLl9uYW1lID0gaTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGkgPT09IGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gbCAtIDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgICAgICAgdGhpc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgdGhpc1tpXSA9IHRoaXNbaSArIDFdO1xuICAgICAgICAgICAgICB0aGlzW2ldLl9uYW1lID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBBZGRzIHZhbHVlIHRvIGFycmF5IGlmIGl0IGlzIG5vdCBjb250YWluZWQgaW4gYXJyYXksIGV4ZWN1dGVzIGhhbmRsZXIgb24gZW5jb3VudGVyaW5nIHZhbCBpbiBhcnJheVxuICAgKiBAbWV0aG9kIGluY2x1ZGVcbiAgICogQHBhcmFtICB7Kn0gICAgICAgICB2YWwgICAgICAgVmFsdWUgdG8gYWRkXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgW2hhbmRsZXJdIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZW5jb3VudGVyaW5nIHZhbCBpbiBhcnJheVxuICAgKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICBUcnVlL2ZhbHNlXG4gICAqL1xuICAnaW5jbHVkZScsIGZ1bmN0aW9uKHZhbCwgaGFuZGxlciwgYXJyKSB7XG4gICAgcmV0dXJuIHV0aWwuaW5jbHVkZSh0aGlzLCB2YWwsIGhhbmRsZXIsIGFycik7XG4gIH0sXG4gICdjb25jYXQnLCBmdW5jdGlvbih2YWwpIHsgXG5cbiAgICAvLyBpZighdmFsKSB7XG4gICAgLy8gICByZXR1cm5cbiAgICAvLyB9XG4gICAgXG4gICAgdmFyIGFyciA9IHRoaXNcbiAgICB2YXIgbGwgPSBhcnIubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgYXJyLl9wdXNoKHZhbFtpXSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgYXJyLl91cGRhdGUodmFsKTtcbiAgICByZXR1cm4gYXJyO1xuICB9LFxuICAnbW92ZUl0ZW0nLCBmdW5jdGlvbihmcm9tLCB0bykgeyB2YXIgYXJyID0gdGhpc1xuICAgIGlmKHRvID09PSB2b2lkIDApIHRvID0gYXJyLmxlbmd0aCAtIDFcbiAgICBpZihmcm9tID09PSB0bykgcmV0dXJuXG4gICAgdmFyIG1vdmVyID0gYXJyW2Zyb21dXG4gICAgaWYoIW1vdmVyKSByZXR1cm5cbiAgICB2YXIgc3RlcCA9IGZyb20gPCB0byA/IDEgOiAtMVxuICAgIGRvIHtcbiAgICAgIGFycltmcm9tXSA9IG51bGxcbiAgICAgIGFyci5zZXQoZnJvbSwgYXJyW2Zyb20gKyBzdGVwXSwgdHJ1ZSlcbiAgICAgIGZyb20gKz0gc3RlcFxuICAgIH0gd2hpbGUoZnJvbSAhPT0gdG8pXG4gICAgYXJyW3RvXSA9IG51bGxcbiAgICBhcnIuc2V0KHRvLCBtb3ZlciwgdHJ1ZSlcbiAgfVxuKVxuIiwiXG5cbnZhciBWT2JqZWN0ID0gcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdCcpLmluamVjdChcbiAgICByZXF1aXJlKCd2aWdvdXItanMvdmFsdWUvbGVuZ3RoJylcbiAgKSxcbiAgdXRpbCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsJyksXG4gIHVpZCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2lkJylcblxudmFyIFNBTUVQQVRIID0gJ2NvdWxkIG5vdCBjcmVhdGUgY29tcG91bmQgb2YgdHdvIE9iamVjdHMgd2l0aCB0aGUgc2FtZSBwYXRoJ1xuXG4vLyBmdW5jdGlvbiBDb21wb3VuZCh2YWwpe1xuLy8gICB2YXIgY29tcG91bmQgPSB0aGlzXG4vLyAgIGNvbXBvdW5kLiRzb3VyY2VzID0gbmV3IFNvdXJjZUxpc3QoY29tcG91bmQsIHZhbClcbi8vICAgdGhpcy5fX3QgPSAyXG4vLyB9XG5cbi8vIHZhciBEYXRhID0gcmVxdWlyZSgndmlnb3VyLWpzL2RhdGEnKVxuXG52YXIgQ29tcG91bmQgPSBWT2JqZWN0Lm5ldyh2b2lkIDAsIGZ1bmN0aW9uKHZhbCl7XG4gIHZhciBjb21wb3VuZCA9IHRoaXNcbiAgY29tcG91bmQuJHNvdXJjZXMgPSBuZXcgU291cmNlTGlzdChjb21wb3VuZCwgdmFsKVxuICB0aGlzLl9fdCA9IDJcbiAgcmV0dXJuIGZhbHNlXG59KVxudXRpbC5kZWZpbmUoQ29tcG91bmQsICdfY2xhc3MnLCBWT2JqZWN0KVxuXG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG91bmRcbi8vIENvbXBvdW5kLnByb3RvdHlwZSA9IG5ldyBWT2JqZWN0KClcblxuQ29tcG91bmQucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaChcbiAgJyRzb3VyY2VzJ1xuKVxuXG51dGlsLmRlZmluZSggQ29tcG91bmQsXG4gICdfYWJzb3JiJywgZnVuY3Rpb24gX2Fic29yYihlbnRyeSkge1xuICAgIHZhciBjb21wb3VuZCA9IHRoaXNcbiAgICB2YXIgc291cmNlID0gZW50cnkuc291cmNlXG4gICAgdmFyIHByZWZpeCA9IGVudHJ5Lm5hbWVcbiAgICBcbiAgICB2YXIgZW5kcG9pbnQgPSBzb3VyY2VcbiAgICB3aGlsZShlbmRwb2ludCAmJiBlbmRwb2ludC5fX3QgPT09IDQgJiYgIWVuZHBvaW50Ll9maWx0ZXIpIHtcbiAgICAgIGVuZHBvaW50ID0gZW5kcG9pbnQuX3ZhbFxuICAgIH1cbiAgICBlbnRyeS5lbmRwb2ludCA9IGVuZHBvaW50XG4gICAgXG4gICAgaWYoZW5kcG9pbnQpIHtcbiAgICAgIGVuZHBvaW50LmVhY2goZnVuY3Rpb24gYWJzb3JiRWFjaCgpe1xuICAgICAgICBjb21wb3VuZC5zZXQocHJlZml4ICsgJy0nICt0aGlzLl9uYW1lLCB0aGlzKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb21wb3VuZC5lYWNoKGZ1bmN0aW9uIGNsZWFuT2xkKCl7XG4gICAgICB2YXIgcG9pbnRlciA9IHRoaXNcbiAgICAgIHZhciBwb2ludGVkID0gcG9pbnRlci5fdmFsXG5cbiAgICAgIC8vIHNraXAgY2xlYW51cCBjaGVjayBvbiBjb25zdHJ1Y3Rpb25cbiAgICAgIGlmKCFjb21wb3VuZC4kc291cmNlcykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB3YXkgdG8gY2hlY2sgaWYgdGhpbmcgaXMgc3RpbGwgaW4gYW4gZW5wb2ludFxuICAgICAgLy8gZ2V0IHRoZSBlbmRwb2ludCB0aGUgaXRlbSBzaG91bGQgYmUgaW5cbiAgICAgIHZhciBzb3VyY2VuYW1lID0gcG9pbnRlci5fbmFtZS5zcGxpdCgnLScpWzBdXG4gICAgICB2YXIgZXAgPSBjb21wb3VuZC4kc291cmNlc1tzb3VyY2VuYW1lXS5lbmRwb2ludFxuICAgICAgdmFyIG9rXG4gICAgICBlcC5lYWNoKGZ1bmN0aW9uIG9rQ2hlY2soKXtcbiAgICAgICAgaWYodGhpcyA9PT0gcG9pbnRlZCkge1xuICAgICAgICAgIHJldHVybiBvayA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmKCFvaykge1xuICAgICAgICBwb2ludGVyLnJlbW92ZSgpXG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgJ19hZGRDb21wb3VuZExpc3RlbmVyJywgZnVuY3Rpb24gX2FkZENvbXBvdW5kTGlzdGVuZXIoZW50cnkpIHtcbiAgICB2YXIgY29tcG91bmQgPSB0aGlzXG4gICAgZW50cnkuc291cmNlLm9uKGZ1bmN0aW9uIGNvbXBvdW5kTGlzdGVuZXIoKXtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdjaGFuZ2UgaW4gc291cmNlLCBydW4gYWJzb3JiIG9uJywgZW50cnksIFxuICAgICAgLy8gICAnXFxudmFsJywgYXJndW1lbnRzWzBdLFxuICAgICAgLy8gICAnXFxuc3RhbXAnLCBhcmd1bWVudHNbMV1cbiAgICAgIC8vIClcbiAgICAgIGNvbXBvdW5kLl9hYnNvcmIoZW50cnkpXG4gICAgfSlcbiAgfVxuKVxuXG5mdW5jdGlvbiBTb3VyY2VMaXN0KGNvbXBvdW5kLCB2YWwpIHtcbiAgdmFyIHNvdXJjZWxpc3QgPSB0aGlzXG4gIHNvdXJjZWxpc3QuX3BhcmVudCA9IGNvbXBvdW5kXG4gIGlmKHZhbCl7XG4gICAgaWYoISh2YWwgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgIHZhbCA9IFt2YWxdXG4gICAgfVxuICAgIHRoaXMucHVzaC5hcHBseSh0aGlzLCB2YWwpXG4gIH1cbn1cblxuU291cmNlTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2hTb3VyY2UoKXtcbiAgdmFyIHNvdXJjZWxpc3QgPSB0aGlzXG4gIHZhciBjb21wb3VuZCA9IHNvdXJjZWxpc3QuX3BhcmVudFxuXG4gIC8vIGNvbnNvbGUubG9nKCdwdXNoIGRhdCBzb3VyY2VzJywgYXJndW1lbnRzLmxlbmd0aClcbiAgdmFyIGFsID0gYXJndW1lbnRzLmxlbmd0aFxuICBmb3IodmFyIGkgPSAwLCBzb3VyY2U7IHNvdXJjZSA9IGFyZ3VtZW50c1tpXSA7IGkrKyl7XG5cbiAgICB2YXIgc291cmNlbmFtZSA9IHVpZCgpXG5cbiAgICAvLyBjb25zb2xlLmxvZygnU09VUkNFTkFNRSBJUycsIHNvdXJjZW5hbWUpXG5cbiAgICB2YXIgZW50cnkgPSBzb3VyY2VsaXN0W3NvdXJjZW5hbWVdID0ge1xuICAgICAgbmFtZTogc291cmNlbmFtZSxcbiAgICAgIHNvdXJjZTogc291cmNlXG4gICAgfVxuXG4gICAgY29tcG91bmQuX2Fic29yYihlbnRyeSlcbiAgICBjb21wb3VuZC5fYWRkQ29tcG91bmRMaXN0ZW5lcihlbnRyeSlcblxuICB9XG59XG5cblxuXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuXG4vKipcbiAqIEZsYWdzIGFyZSBzcGVjaWFsIHByb3BlcnRpZXMgd2hlcmUgYSBmdW5jdGlvbiBpcyBjYWxsZWRcbiAqIGRpZmZlcmVudCBmcm9tIG9wZXJhdG9ycyBzaW5jZSBmbGFncyBtYXkgaGF2ZSBub3RoaW5nIHRvIGRvIHdpdGggdmFsdWUgY2FsY3VsYXRpb25cbiAqIGV4dGVuZHMgZGVmYXVsdCBzZXQgZnJvbSBWLk9iamVjdFxuICogQHByb3BlcnR5XG4gKi9cbi8qKlxuICogQWRkcyBuZXcgZmxhZ3MgdG8gVi5PYmplY3RcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgb2JqZWN0IFYuT2JqZWN0IHRvIGV4dGVuZCBmbGFncyB0b1xuICogQHBhcmFtICB7RnVuY3Rpb259IFtzZXRdICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbihvYmplY3QsIHNldCkge1xuICBcbiAgLy9tdWx0aXBsZSBmbGFncyBcbiAgXG4gIC8vIGFic3RyYWN0IGZsYWdzIGFycmF5IGF3YXkhXG4gIC8vIFxuICAvLyBmbGFncyBvYmplY3QgLS0+IGZpZWxkXG4gIC8vIFxuICAvLyBjaGVjayAvdyBjYXNlc1xuICAvLyBjaGVjayAvdyBwYXJlbnRcbiAgLy8gZmxhZzQgaXMgZHluYW1pYyBoYXMgc3RhY2sgYXMgb3B0aW9uXG4gIFxuICB2YXIgX3Byb3RvID0gb2JqZWN0LnByb3RvdHlwZVxuICAgICwgX2NvbnZlcnQgPSBfcHJvdG8uY29udmVydFxuICAgICwgX3NldCA9IF9wcm90by5fc2V0XG4gICAgLCBfcmVtb3ZlID0gX3Byb3RvLl9yZW1vdmVcbiAgICAsIF9jaGVjayA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgIHZhciBmO1xuICAgICAgZm9yICh2YXIgaSBpbiBvYmplY3QuZmxhZ3MuZHluYW1pYykge1xuICAgICAgICBmID0gb2JqZWN0LmZsYWdzLmR5bmFtaWNbaV0obmFtZSlcbiAgICAgICAgaWYoZikgYnJlYWtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmXG4gICAgfVxuICAgICwgY2hlY2tJZkZsYWdPdmVyd3JpdGUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGZvcih2YXIgaSBpbiB2YWwpIHtcbiAgICAgICAgaWYob2JqZWN0LmZsYWdzW2ldIHx8IF9jaGVjayhpKSkgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgaWYgKCFzZXQpIHNldCA9IF9wcm90by5zZXRcblxuICBfcHJvdG8uX2JsYWNrbGlzdC5wdXNoKCdfZmxhZycpO1xuICB1dGlsLmRlZmluZShvYmplY3QsXG4gICAgLyoqXG4gICAgICogW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBtZXRob2QgY29udmVydFxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdmFsIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJ2NvbnZlcnQnLCBmdW5jdGlvbih2YWwpIHtcblxuICAgICAgLy9oaWVyIG9vayB3ZWVyIGZvclxuICAgICAgdmFyIG9iaiA9IF9jb252ZXJ0LmNhbGwodGhpcywgdmFsKTtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ0kgU0hPVUxEIEJFIENPTlZFUlRJTkchJywgdmFsLCBvYmosIHRoaXMuX2ZsYWcpXG5cblxuXG5cblxuICAgICAgaWYgKHRoaXMuX2ZsYWcgJiYgKCF2YWwgfHwgIXV0aWwuaXNPYmoodmFsKSB8fCB2YWwudmFsIHx8IGNoZWNrSWZGbGFnT3ZlcndyaXRlKHZhbCkgKSkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdJIFNIT1VMRCBCRSBDT05WRVJUSU5HISBzdGVwIDInKVxuXG4gICAgICAgIC8vZmYgdXNlVmFsIGdlYnJ1aWtlblxuXG4gICAgICAgIGZvcih2YXIgaSBpbiB0aGlzLl9mbGFnKSB7XG4gICAgICAgICAgdmFyIGZsYWcgPSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgaWYgKCFmbGFnWzRdIHx8ICFmbGFnWzRdLnN0YWNrKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDT05WRVJUIE5FRURTIEZJWCcucmVkLmJvbGQuaW52ZXJzZSlcblxuICAgICAgICAgICAgaWYgKG9iaiA9PT0gZmxhZ1sxXSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnMiBDT05WRVJUIE5FRURTIEZJWCcucmVkLmJvbGQuaW52ZXJzZSlcbiAgICAgICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob2JqLnZhbCA9PT0gZmxhZ1sxXSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnMyBDT05WRVJUIE5FRURTIEZJWCcucmVkLmJvbGQuaW52ZXJzZSlcbiAgICAgICAgICAgICAgZGVsZXRlIG9iai52YWw7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgb2JqW2ZsYWdbMF1dID0gZmxhZ1syXVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vc3RpbGwgaGF2ZSB0byB0YWtlIGNhcmUgb2YgdGhpcyBzaXR1YXRpb25cbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3RyeWluZyBjb252ZXJ0IGEgc3RhY2stZHluYW1pYyBmbGFnJywgZmxhZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0NPTlZFUlRFRCAtLS0tPicsb2JqKVxuXG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICBAcHJvcGVydHkgX19mbGFnc19fXG4gICAgKi9cbiAgICAnX19mbGFnc19fJywge30sXG4gICAgLyoqXG4gICAgICogW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBtZXRob2QgcmVtb3ZlXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBmcm9tICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdXBkYXRlIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YW1wICBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICdfcmVtb3ZlJywgZnVuY3Rpb24oZnJvbSwgdXBkYXRlLCBzdGFtcCkge1xuXG4gICAgICBpZih0aGlzLl9mbGFnKSB7XG4gICAgICAgIGZvcih2YXIgaSBpbiB0aGlzLl9mbGFnKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coaSwgdGhpcy5fZmxhZylcbiAgICAgICAgICB2YXIgZmxhZyA9IHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICAvL2ZvciBcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnX3JlbW92ZScpXG4gICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIC8vZGl0IG1vZXQgd2VsIGZmIGx1a2tlblxuICAgICAgICAgICAgaWYgKG9iamVjdC5mbGFnc1tmbGFnWzBdXSkge1xuICAgICAgICAgICAgICBvYmplY3QuZmxhZ3NbZmxhZ1swXV0ucmVtb3ZlICYmIG9iamVjdC5mbGFnc1tmbGFnWzBdXS5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZsYWdbNF0ucmVtb3ZlLmNhbGwodGhpcywgZmxhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ZsYWcgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIF9yZW1vdmUuY2FsbCh0aGlzLCBmcm9tLCB1cGRhdGUsIHN0YW1wKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAbWV0aG9kIF9zZXRcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHZhbCAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YW1wICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZyb20gICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHJlbW92ZSAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vdXBkYXRlIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAnX3NldCcsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgbm91cGRhdGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdtYWtlIF9zZXQnLHRoaXMuX25hbWUsdmFsKTtcbiAgICAgIF9zZXQuY2FsbCh0aGlzLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIG5vdXBkYXRlKVxuXG4gICAgICAvL2ZsYWcgbW9ldCBkdXMgb29rIG1lZXIgZWVuIGNvcGllZCB2YWx1ZSB3b3JkZW5cblxuICAgICAgLy8gY29uc29sZS5sb2coJ19zZXQnLCB0aGlzLl9mbGFnLCB2YWwpXG5cblxuICAgICAgaWYodGhpcy5fZmxhZykge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvdmVyd3JpdGU+Py0tLS0nLCB0aGlzLl9mbGFnLCB2YWwpXG5cbiAgICAgICAgZm9yKHZhciBpIGluIHRoaXMuX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgZmxhZyA9IHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgdmFyIHNldEZsID0gb2JqZWN0LmZsYWdzW2ZsYWdbMF1dIHx8IGZsYWdbNF1cbiAgICAgICAgICAgIC8vd2hhdCB0byBkbyB3aXRoIHJlc2V0P1xuICAgICAgICAgICAgLy9jaGFuZ2UgZml4ZW4gYmlqIGNhc2VzP1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnMiBvdmVyd3JpdGU+Py0tLS0nLCBmbGFnLCB0aGlzLl92YWwsIHRoaXMuX3ZhbCAhPT0gZmxhZ1sxXSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZhbCAhPT0gZmxhZ1sxXSAmJiBzZXRGbC51c2VWYWwpIHtcblxuICAgICAgICAgICAgICAvLyBudSBmZiBoaWVyIG9vayBub2chXG5cbiAgICAgICAgICAgICAgaWYgKG9iamVjdC5mbGFnc1tmbGFnWzBdXSkge1xuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSBmbGFnIG5vcm1hbCcsZmxhZywgZmxhZ1s0XSwgaSwgdGhpcylcblxuICAgICAgICAgICAgICAgIG9iamVjdC5mbGFnc1tmbGFnWzBdXS5yZW1vdmUgJiYgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpXG4gICAgICAgICAgICAgICAgLy9pZiB0aGlzIGVtcHR5XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIHRoaXMuX2ZsYWc7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICAgICAgICBpZih1dGlsLmVtcHR5KHRoaXMuX2ZsYWcpKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aGlzLl91cGRhdGUoKVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFmbGFnWzVdKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSBmbGFnIC93IGZsYWdbNF0gYW5kIG5vdCBmbGFnWzVdJyxmbGFnLCBmbGFnWzRdLCBpKVxuICAgICAgICAgICAgICAgIGZsYWdbNF0ucmVtb3ZlLmNhbGwodGhpcywgZmxhZyk7XG4gICAgICAgICAgICAgICAgLy8gaWYodGhpcy4pXG4gICAgICAgICAgICAgICAgLy9kZWxldGUgdGhpcy5fZmxhZztcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgICAgICAgIGlmKHV0aWwuZW1wdHkodGhpcy5fZmxhZykpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdC5mbGFnc1tmbGFnWzBdXSAmJiBvYmplY3QuZmxhZ3NbZmxhZ1swXV0ucmVzZXQgJiYgZmxhZ1szXSAhPT0gdGhpcykge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdSRVNFVFRJTkcgLS0gaW5nbm9yZSAvdyBhIGNsZWFyIScsZmxhZ1swXSkgXG4gICAgICAgICAgICAgIG9iamVjdC5mbGFnc1tmbGFnWzBdXS5zZXQuY2FsbCh0aGlzLCBmbGFnWzJdLCBzdGFtcCwgdHJ1ZSwgdGhpcy5fbmFtZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sXG4gICAgLyoqXG4gICAgICogW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBtZXRob2Qgc2V0XG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBuYW1lICAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB2YWwgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB2b2JqICAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFtcCAgICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBub3VwZGF0ZSBbZGVzY3JpcHRpb25dXG4gICAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJ3NldCcsIGZ1bmN0aW9uKG5hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlKSB7XG4gICAgICB2YXIgZmwgPSBvYmplY3QuZmxhZ3NbbmFtZV0gfHwgX2NoZWNrKG5hbWUpXG4gICAgICAgICwgclxuICAgICAgICAsIHNhbWVcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lLCB2YWwsIHZvYmopXG5cbiAgICAgIGlmIChmbCkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXQ+Py0tLS0nLCBuYW1lLCB2YWwsIHRoaXMuX2ZsYWcpXG4gICAgICAgXG4gICAgICBpZih2YWw9PT1mYWxzZSkge1xuICAgICAgICAgIC8vc3RhY2sgLS0gYWxsZSBmbGFncyBuYW1lIHByb3ZpZGVuIVxuICAgICAgICAgIHZhciBpID0gZmwuc3RhY2t8fG5hbWUgXG4gICAgICAgICAgICAsIGZsYWcgPSB0aGlzLl9mbGFnICYmIHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICBpZihmbGFnICYmIGZsLnJlbW92ZSkge1xuICAgICAgICAgICAgdmFyIGQgPSBmbC5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnLCBuYW1lKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBGTEFHIEZST00gRkFMU0UnLmludmVyc2UsIGZsLCBuYW1lLCB2YWwsIHN0YW1wLCB0aGlzKVxuICAgICAgICAgICAgaWYoIWQpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICAgICAgaWYodXRpbC5lbXB0eSh0aGlzLl9mbGFnKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmbGFnIGlzIGVtcHR5LCBkZWxldGUnKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IFxuICAgICAgICAgIHIgPSB0cnVlXG4gICAgICAgICAgLy8gaWYodGhpcy5fZmxhZylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgaWYodGhpcy5fZmxhZykge1xuICAgICAgICAgIC8vY2hlY2sgaWYgbmVlZCB0byByZW1vdmUhIC0tIG9ubHkgaW4gY2FzZVxuICAgICAgICAgIGZvcih2YXIgaSBpbiB0aGlzLl9mbGFnKSB7XG4gICAgICAgICAgICB2YXIgZmxhZyA9IHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICAgIGlmIChmbGFnICYmIGZsLnJlbW92ZSkge1xuXG4gICAgICAgICAgICAgIGlmKCFmbC5zdGFjayAmJiBuYW1lID09PSBmbGFnWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4nLGZsYWdbMF0pXG4gICAgICAgICAgICAgICAgaWYodmFsIT09ZmxhZ1syXSkge1xuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZSBmbGFnISAtLS0+IG92ZXJ3cml0ZSBieW15c2VsZiAtLS0+JywgZmxhZ1swXSwgIHNldEZsLCAnYnk6JyAsbmFtZSwgZmwsIHZhbCwgZmxhZ1syXSlcbiAgICAgICAgICAgICAgICAgIGZsLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBzYW1lID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFmbC5zdGFjayB8fCBmbC5zdGFjayAhPT0gZmxhZ1swXSkge1xuXG4gICAgICAgICAgICAgICAgLy90aGlzLl9mbGFnXG5cbiAgICAgICAgICAgICAgICAvL2lmIHZhbDp0cnVlIFxuICAgICAgICAgICAgICAgIC8vZ28gY2hlY2sgaWYgeW91IG5lZWQgdG8gcmVtb3ZlIG1vZm9zXG5cbiAgICAgICAgICAgICAgICB2YXIgc2V0RmwgPSBvYmplY3QuZmxhZ3NbZmxhZ1swXV0gfHwgZmxhZ1s0XVxuXG4gICAgICAgICAgICAgICAgaWYoc2V0RmwudXNlVmFsICYmIGZsLnVzZVZhbCkge1xuXG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIGZsYWchIC0tIGNsZWFybHkgaGFzIHNvbWUgdXNlVmFsJywgZmxhZ1swXSwgIHNldEZsLCAnYnk6JyAsbmFtZSwgZmwpXG5cbiAgICAgICAgICAgICAgICAgIHNldEZsLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICAgICAgICAgIGlmKHV0aWwuZW1wdHkodGhpcy5fZmxhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZsYWcgaXMgZW1wdHksIGRlbGV0ZScpXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIGZsYWchJywgZmxhZywgZmxhZ1swXSwgZmxhZ1s0XSwgIG9iamVjdC5mbGFnc1tmbGFnWzBdXSAgLCBmbCwgbmFtZSkgLy9jaGVjayBpZiBpdCBuZWVkcyB0byBiZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgLy8gdmFyIGZsIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vZmwgPSBvYmplY3QuZmxhZ3NbbmFtZV0gfHwgX2NoZWNrKG5hbWUpXG4gICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAvL2hpZXIgaWV0cyBtZWUgZG9lbiB3ZWVyIHpvZWtlbiBuYWFyIGZsYWcgc2V0XG5cblxuICAgICAgICAgICAgICAgIC8vZG8gdGhlIHNwZWNpYWwgY2hlY2sgaWYgdmFsdWUgaXMgdGlnaHQgdG8gZmxhZyBjaGVjayAoZm9yIGJvdGghIGZsLnZhbHVlKVxuXG4gICAgICAgICAgICAgICAgLy8gZmwucmVtb3ZlLmNhbGwodGhpcywgZmxhZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgaWYoIXNhbWUpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU0VUIEZMQUcnLmludmVyc2UsIG5hbWUsIHZhbCwgc3RhbXAsIHRoaXMpXG4gICAgICAgICAgZmwuc2V0LmNhbGwodGhpcywgdmFsLCBzdGFtcCwgZmFsc2UsIG5hbWUpO1xuICAgICAgICAgIHIgPSB0cnVlIC8vbmlldCBhbHRpamQgd2FhciBvZmNvdXJzZSFcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tJylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRkxBRyBJUyBTQU1FJy5yZWQuaW52ZXJzZSwgbmFtZSwgdmFsLCBzdGFtcCwgdGhpcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgICB0aGlzW25hbWVdICYmIHRoaXNbbmFtZV0ucmVtb3ZlKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByID0gc2V0LmNhbGwodGhpcywgbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSk7XG4gIG9iamVjdC5mbGFncyA9IF9wcm90by5fX2ZsYWdzX187XG4gIHV0aWwuZGVmaW5lKG9iamVjdC5mbGFncywgJ2R5bmFtaWMnLCB7fSk7XG59KSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgaGFzaCA9IHJlcXVpcmUoJy4uL3V0aWwvaGFzaCcpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZnVuY3Rpb24oYmFzZSkge1xuICBiYXNlLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ19faHAnKVxuICB1dGlsLmRlZmluZSggYmFzZVxuICAsICdfaGFzaHBhdGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2hwIHx8ICh0aGlzLl9faHAgPSBoYXNoKHRoaXMuX3BhdGgudG9TdHJpbmcoKSkpXG4gICAgICB9XG4gICAgfVxuICApXG59KSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgdmlnb3VyID0gcmVxdWlyZSgnLi4vJylcbiAgLCBpbmplY3QgPSByZXF1aXJlKCcuLi91dGlsL2luamVjdCcpXG4vKipcbiAqIFYuT2JqZWN0cyBhcmUgdXNlZCBpbnN0ZWFkIG9mIG5vcm1hbCBvYmplY3RzIGluIHZpZ291ciBsaXN0ZW5lcnMgYXJlIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHJlbW92ZWRcbiAqIHR5cGU6IF9fdCA6IDEgPSBhcnJheSAsIDIgPSBvYmplY3QgLCAzID0gaGFzIGZpZWxkIChjYW4gbmV2ZXIgYmUgYW4gYXJyYXkpICwgNCA9IGZpZWxkIHJlZiB0byBvdGhlciBWLk9iamVjdFxuICogbm90ZSB5b3UgY2FuIG1ha2UgYW4gb2JqZWN0IG91dCBvZiBhIGZpZWxkIG9yIGZpZWxkIHJlZiB0aGUgdHlwZSB3aWxsIGJlIDMgb3IgNCB0aG91Z2ghXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSAgeyp9ICAgICAgW3ZhbF0gICAgVmFsdWVcbiAqIEBwYXJhbSAge09iamVjdH0gW3BhcmVudF0gUGFyZW50b2JqZWN0XG4gKi9cbnZhciBvYmplY3QgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB2aWdvdXIuT2JqZWN0ID0gZnVuY3Rpb24odmFsLCBob29rLCBwYXJlbnQpIHtcbiAgaWYgKHBhcmVudCkgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIGlmIChob29rICYmIHRoaXMuX2hvb2spIHRoaXMuX2hvb2sodmFsLCBob29rKVxuICBpZiAodmFsICE9PSB2b2lkIDApIHRoaXMudmFsID0gdmFsXG59XG5vYmplY3QuaW5qZWN0ID0gaW5qZWN0XG4vKipcbiAqIFVzZWQgdG8gc2V0IC52YWxcbiAqIEBtZXRob2QgX3NldFxuICogQHBhcmFtICB7Kn0gICAgICAgICAgICAgIHZhbCAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICBbc3RhbXAgPSBuZXcgc3RhbXBdICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtPYmplY3R8Qm9vbGVhbn0gW2Zyb21dICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFtub3VwZGF0ZV0gICAgICAgICAgIFdoZW4gdHJ1ZSwgbm8gdXBkYXRlc1xuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFthZGRdICAgICAgICAgICAgICAgIFdoZW4gdHJ1ZSwgdGhpcyBpcyBhbiBhZGRcbiAqL1xudmFyIF9zZXQgPSBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCBub3VwZGF0ZSwgYWRkKSB7XG5cbiAgaWYodmFsPT09bnVsbCkge1xuICAgIGlmICghc3RhbXApIHN0YW1wID0gdGhpcy5zdGFtcCgpXG4gICAgdGhpcy5yZW1vdmUoZmFsc2UsIGZhbHNlLCBmYWxzZSwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKVxuICB9XG5cbiAgaWYgKCF0aGlzLl9fdCB8fCB0aGlzLl9fdCA8IDMgfHwgKCB2YWwgIT09IHRoaXMuX3ZhbCB8fCB0aGlzLl9pZ25vcmVWYWx1ZSApICkge1xuXG4gICAgLy8gY29uc29sZS5lcnJvcih0aGlzKVxuICAgIGlmKCF0aGlzLnN0YW1wKSB7XG4gICAgICAvL21vZXQgYWxsZW1hYWwgZXZlbnQgZW1pdHRlcnMgd29yZGVuIChvbignZXJyb3InKSlcbiAgICAgIC8vdGhpcy5fdXBkYXRlKCdlcnJvcicpIGVuIGFuZGVycyBWLmRlYnVnLmVycm9yLl91cGRhdGUoICdvYmplY3QnIClcbiAgICAgIGNvbnNvbGUuZXJyb3IoICdFUlJPUiBpbiB2aWdvdXItanMvb2JqZWN0LCAgT0JKRUNUIG5vIC5zdGFtcCcsIHRoaXMgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFzdGFtcCkgc3RhbXAgPSB0aGlzLnN0YW1wKClcblxuICAgIHZhciBvbGR2YWwgPSB0aGlzLl92YWxcbiAgICAgICwgbmVzdGVkdmFsXG4gICAgICAsIG5vc2V0XG4gICAgICAsIGlzU2V0XG4gICAgICAsIGlzQXJyYXlcbiAgICAgICwgdmFsSXNTZXRcblxuICAgIGlmICh0aGlzLl9jaGFuZ2V2b2JqIFxuICAgICAgJiYgKCh0aGlzLl9fdCA8IDQgJiYgdmFsIGluc3RhbmNlb2Ygb2JqZWN0KSBcbiAgICAgIHx8IHRoaXMuX190ID09PSA0ICYmICgoIXRoaXMuX21peGVkfHx0aGlzLl9taXhlZD09PTQpIHx8IHZhbCBpbnN0YW5jZW9mIEFycmF5IFxuICAgICAgICB8fCAodmFsIGluc3RhbmNlb2YgT2JqZWN0IFxuICAgICAgICAgICYmICh2YWwgaW5zdGFuY2VvZiBvYmplY3QgfHwgdmFsLnZhbCkpKSkpIHsgLy90cnkgdG8gbWFrZSB0aGlzIHNob3J0ZXJcbiAgICAgICAgIHRoaXMuX2NoYW5nZXZvYmoodmFsLCBzdGFtcClcbiAgICAgICAgIGlmKHRoaXMuX21peGVkPT09NCkgdGhpcy5fdmFsID0gbnVsbFxuICAgIH1cblxuICAgIGlmICh2aWdvdXIuQmFzZSAmJiAodmFsIGluc3RhbmNlb2Ygdmlnb3VyLkJhc2UpKSB7XG4gICAgICB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHN0YW1wKVxuICAgICAgdGhpcy5fX3QgPSA1XG4gICAgICB0aGlzLl92YWwgPSB2YWxcbiAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIG9iamVjdCkge1xuICAgICAgaWYgKCh0aGlzLl9fdCA8IDMgJiYgIXRoaXMuX21peGVkKSB8fCB0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgICB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCBmYWxzZSwgdm9pZCAwLCBzdGFtcCkgLy9jaGVjayBpZiAybmQgcGFyYW0gdHJ1ZSBpcyBhYnNvbHV0ZWx5IG5lc3NlY2FyeSAoZWxzZSBpdCB3aWxsIGJlIHJlbW92ZWQpXG4gICAgICB9XG4gICAgICB0aGlzLl92YWwgPSB2YWxcbiAgICAgIHRoaXMuX190ID0gNFxuICAgICAgaWYgKHRoaXMuX3NldHZvYmopIHRoaXMuX3NldHZvYmoodmFsKVxuICAgIH0gZWxzZSB7XG5cbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QgJiYgdHlwZW9mIHZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICB0aGlzLl92YWwgPSB2b2lkIDBcbiAgICAgICAgICB0aGlzLl9fdCA9IDFcbiAgICAgICAgICB0aGlzLmxlbmd0aCA9IHZhbC5sZW5ndGhcbiAgICAgICAgICBub3NldCA9IHRoaXMucmVtb3ZlKHRydWUsIHRydWUsIHZhbCwgZmFsc2UsIHN0YW1wKVxuICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zZXQoaSwgdmFsW2ldLCBmYWxzZSwgc3RhbXAsIG5vdXBkYXRlLCB0cnVlKSAmJiBub3NldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgbm9zZXQgPSB0cnVlXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBub3NldCA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgLy9ub3JtYWwgb2JqZWN0XG5cbiAgICAgICAgICBpZiAodmFsLmNsZWFyKSB7XG4gICAgICAgICAgICBub3NldCA9IHRoaXMucmVtb3ZlKHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSwgc3RhbXApXG4gICAgICAgICAgICBkZWxldGUgdmFsLmNsZWFyXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX190ID09PSAxKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9taXhlZCAhPT0gMSAmJiB0aGlzLl9taXhlZCE9PTQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHN0YW1wKSAvL29tbWl0aW5nIHN0YW1wIGNhbiBiZSBhIHByb2JsZW1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc0FycmF5ID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9tZXJnZSAmJiAoIXRoaXMuX21peGVkIHx8IHRoaXMuX190ID09PSAyKSkge1xuICAgICAgICAgICAgICBub3NldCA9IHRoaXMucmVtb3ZlKHRydWUsIHRydWUsIHZhbCwgZmFsc2UsIHN0YW1wKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsLnZhbCAmJiB1dGlsLmlzT2JqKHZhbC52YWwpKSB7XG4gICAgICAgICAgICB2YWxJc1NldCA9IHRydWVcbiAgICAgICAgICAgIHRoaXMuXyRzZXRWYWwoIG5ldyB0aGlzLl9jbGFzcyh2YWwudmFsLCBmYWxzZSwgdGhpcyksIHN0YW1wLCBmcm9tLCB0cnVlKVxuICAgICAgICAgICAgdGhpcy5fdmFsLl9jb250YWluZWQgPSB0cnVlXG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbWl4ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3ZhbCA9IHZvaWQgMCAvL3RoaXMgbWVzc2VzIHVwIHByb3BlcnR5IHVwZGF0ZXMhISAoeW91cmkpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFpc0FycmF5KSB0aGlzLl9fdCA9IDJcblxuICAgICAgICAgIGZvciAodmFyIGogaW4gdmFsKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuY2hlY2tBcnJheSh0aGlzLl9ibGFja2xpc3QsIGopKSB7XG4gICAgICAgICAgICAgIGlmIChqID09PSAndmFsJykge1xuICAgICAgICAgICAgICAgIGlmKCF2YWxJc1NldCkgaXNTZXQgPSB0aGlzLl8kc2V0VmFsKCB2YWwudmFsLCBzdGFtcCwgZnJvbSwgdHJ1ZSApXG4gICAgICAgICAgICAgICAgbmVzdGVkdmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2RvIG5vdCBhbHdheXMgaWdub3JlIHVwZGF0ZXMgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zZXQoaiwgdmFsW2pdLCBmYWxzZSwgc3RhbXAsIG5vdXBkYXRlLCB0cnVlKSAmJiBub3NldCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgIG5vc2V0ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBub3NldCA9IGZhbHNlIC8vdGhpcyBpcyB0aGUgcGxhY2Ugd2hlcmUgc2V0IGlzIHBhc3NlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoKHRoaXMuX190IDwgMyAmJiAhdGhpcy5fbWl4ZWQpIHx8IHRoaXMuX190ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBzdGFtcClcbiAgICAgICAgICBpZiAodGhpcy5fX3QgPT09IDEpIGRlbGV0ZSB0aGlzLmxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgPT09IHRoaXMuX3ZhbCAmJiAhdGhpcy5faWdub3JlVmFsdWUgKSB7XG4gICAgICAgICAgLy9tYXliZSB1c2Ugc3RhbXAgZm9yIGlnbm9yZVZhbHVlIGFzIHdlbGw/XG4gICAgICAgICAgaWYgKG5vc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5fX3QgPSAzXG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fdmFsID0gdmFsXG4gICAgICAgICAgdGhpcy5fX3QgPSAzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lc3RlZHZhbCkge1xuXG4gICAgICBpZiAodGhpcy5fc2V0ICYmIChpc1NldCAhPT0gZmFsc2UgfHwgbm9zZXQgPT09IGZhbHNlKSkge1xuICAgICAgICB0aGlzLl9zZXQodmFsLCBzdGFtcCwgZnJvbSwgZmFsc2UsIG5vdXBkYXRlLCBhZGQsIG9sZHZhbClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NldCkge1xuICAgICAgaWYgKCFub3NldCkge1xuICAgICAgICB0aGlzLl9zZXQodmFsLCBzdGFtcCwgZnJvbSwgZmFsc2UsIG5vdXBkYXRlLCBhZGQsIG9sZHZhbClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmKHdpbmRvdy5zbXV0KSBjb25zb2xlLmxvZygnITEnLGFyZ3VtZW50cylcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYod2luZG93LnNtdXQpIGNvbnNvbGUubG9nKCchMScsYXJndW1lbnRzKVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbn0sXG4vKipcbiAqIHN0YW1wXG4gKiBwYWludCB0aGUgc2V0IG9yaWdpblxuICogQG1ldGhvZFxuICovXG5fc3RhbXAgPSAwLFxuX3BhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcywgbGlzdCkge1xuICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxLCBwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChwYXJhbXMgJiYgcGFyYW1zW2xpc3RbaV1dIT09dm9pZCAwKSB7XG4gICAgICBwID0gJ18nICsgbGlzdFtpXVxuICAgICAgdXRpbC5kZWZpbmUodGhpcywgcCwgcGFyYW1zW2xpc3RbaV1dKVxuICAgIH1cbiAgfVxufVxuLyoqXG4qIEdlbmVyYXRlcyB1bmlxdWUgc3RhbXBcbiogQG1ldGhvZCBzdGFtcFxuKiBAcmV0dXJuIHtOdW1iZXJ9IFJldHVybnMgc3RhbXBcbiovXG5leHBvcnRzLnN0YW1wID0gZnVuY3Rpb24oKSB7XG4vL2lmIHN0YW1wID4geCByZXNldCA/XG5yZXR1cm4gX3N0YW1wKytcbn1cblxuZXhwb3J0cy5zZXQgPSBfc2V0XG5cbi8vIG9iamVjdFV0aWxzLmV4dGVuZChleHBvcnRzKTsgIFxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGNvbnN0cnVjdG9yIGJhc2VkIG9uIGEgVi5PYmplY3RcbiAqIFBhcmFtcyBjYW4gYmUgcGFzc2VkXG4gKiBNaXhlZCBjcmVhdGVzIG1peGVkIHR5cGVzIGZvciB0aGUgbmV3IGNsYXNzIGkuZSBoYXZpbmcgYSBzdHJpbmcgYW5kIHByb3BlcnRpZXNcbiAqIEBtZXRob2QgbmV3XG4gKiBAcGFyYW0gIHtPYmplY3R9IHBhcmFtcyBQYXJhbWV0ZXJzb2JqZWN0XG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBSZXR1cm5zIFYuT2JqZWN0XG4gKi9cbi8vIHdpbmRvdy5jbnQgPSAwXG4vLyBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuLy8gICB3aW5kb3cuc211dCA9IHRydWVcbi8vIH0sMjAwMClcblxub2JqZWN0Lm5ldyA9IGZ1bmN0aW9uKHBhcmFtcywgY29uc3RydWN0b3IpIHtcbiAgdmFyIHZPYmogPSBmdW5jdGlvbih2YWwsIGhvb2ssIHBhcmVudCkge1xuICAgICAgaWYgKHBhcmVudCkgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gICAgICB2YXIgY29ucmVzdWx0XG4gICAgICBpZiAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgY29ucmVzdWx0ID0gY29uc3RydWN0b3IuYXBwbHkodGhpcyxhcmd1bWVudHMpXG4gICAgICB9XG4gICAgICBpZiAoaG9vayAmJiB0aGlzLl9ob29rKSB0aGlzLl9ob29rKHZhbCwgaG9vaylcbiAgICAgIGlmICh0aGlzLl9vbkNvbnN0cnVjdCkgdGhpcy5fb25Db25zdHJ1Y3QodmFsLCBob29rKVxuXG4gICAgICBpZih2YWwgIT09IHZvaWQgMCAmJiBjb25yZXN1bHQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudmFsID0gdmFsXG4gICAgICB9XG4gICAgfSxcbiAgICBwcm90byA9IHZPYmoucHJvdG90eXBlID0gbmV3IHRoaXMoKVxuICB2T2JqLm5ldyA9IG9iamVjdC5uZXdcbiAgdk9iai5pbmplY3QgPSBpbmplY3QgLy9ub3QgaGFuZGVsZWQgd2VsbCB5ZXRcbiAgdXRpbC5kZWZpbmUodk9iaiwgJ19ibGFja2xpc3QnLCBwcm90by5fYmxhY2tsaXN0LmNvbmNhdCgpKVxuICBfcGFyYW1zLmNhbGwodk9iaiwgcGFyYW1zLCBbJ21peGVkJywgJ21lcmdlJ10pXG4gIHV0aWwuZGVmaW5lKHZPYmosICdfY2xhc3MnLCB2T2JqKVxuICByZXR1cm4gdk9ialxufVxuXG51dGlsLmRlZmluZShvYmplY3QsXG5cbi8vICdfc2V0LCBzZXQgLCAnXG5cbiAnXyRzZXRWYWwnLCBfc2V0LFxuXG4vKipcbiAqIEl0ZW1zIGluIHRoZSBibGFja2xpc3Qgc2tpcHBlZCBpbiBlYWNoIGZ1bmN0aW9uXG4gKiBAbWV0aG9kIF9ibGFja2xpc3RcbiAqL1xuJ19ibGFja2xpc3QnLCBbJ18nLCAnX18nLCAnX190JywgJ192YWwnLCAnbGVuZ3RoJywgJ19uYW1lJywgJ19wYXJlbnQnLCAnX2NvbnRhaW5lZCcsICdfcmVtb3ZlZCcsJ2V4dGVuc2lvbnMnLCAnX19jYWNoZWRQYXRoJywgJ19pZ25vcmVWYWx1ZScsICdfaW5kZXhDYWNoZSddLFxuLyoqXG4gKiBSZXBsYWNlcyBkZWZhdWx0IGNvbnN0cnVjdG9yIHByb3BlcnR5ICxuZWNlc3NhcnkgZm9yIGNsYXNzZXMgbWFkZSB3aXRoIFYuT2JqZWN0Lm5ld1xuICogQGNvbnN0cnVjdG9yIF9jbGFzc1xuICovXG4nX2NsYXNzJywgb2JqZWN0LFxuLyoqXG4gKiBTdGFtcCBpcyBhIG1ldGhvZCBvZiBWT2JqZWN0IHNvIHRoYXQgaXQgY2FuIGJlIGV4dGVuZGVkIGluIHN1YmNsYXNzZXNcbiAqIEByZXR1cm4geyp9IGEgdW5pcXVlIGlkZW50aWZpZXIgZm9yIGEgbXV0YXRpb25cbiAqL1xuJ3N0YW1wJywgb2JqZWN0LnN0YW1wLFxuLyoqXG4gKiBVc2VkIHRvIGdldCAudmFsIHdoaWNoIHJldHVybnMgZmllbGQgdmFsdWVzIGkuZS4gYSBzdHJpbmdcbiAqIEBtZXRob2QgX2dldFxuICogQHJldHVybiB7Kn0gUmV0dXJucyB2YWx1ZVxuICovXG4nX2dldCcsIGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHR5cGUgPSBzZWxmLl9fdFxuICAgICwgdmFsXG5cbiAgaWYgKHR5cGUgPCAzKSB7XG4gICAgcmV0dXJuIHNlbGZcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBzZWxmLl92YWxcbiAgICByZXR1cm4gKHR5cGUgIT09IDQpID8gdmFsIDogdmFsICYmIHZhbC5fZ2V0KClcbiAgfVxufSxcbi8qKlxuICogVXNlZCB0byBnZXQgLnZhbCB3aGljaCByZXR1cm5zIGZpZWxkIHZhbHVlcyBpLmUuIGEgc3RyaW5nXG4gKiBTZXQgY3JlYXRlcyBpbnN0YW5jZXMgb2YgdGhlIF9jbGFzcyBmb3IgbmVzdGVkIHByb3BlcnRpZXNcbiAqIEBwcm9wZXJ0eVxuICovXG4ndmFsJywge1xuICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgIC8vIHdpbmRvdy5jbnQrK1xuICAgIC8vIGlmKHdpbmRvdy5zbXV0KSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKHdpbmRvdy5jbnQsICd3aGF0cyBoYXBwZW5pbmcnLCB0aGlzLl9wYXRoLCB0aGlzLl9wcm9wICYmIHRoaXMuX3Byb3AubmFtZSwgdGhpcywgdGhpcy5fdXBkYXRlT3JpZ2luKVxuICAgIC8vIH1cbiAgICByZXR1cm4gdGhpcy5fJHNldFZhbCh2YWwpXG4gIH0sXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldCgpXG4gIH1cbn0sXG4vKipcbiAqIEFkZCBhIHByb3BlcnR5IHRvIGEgb2JqZWN0XG4gKiBAbWV0aG9kIHNldFxuICogQHBhcmFtICB7U3RyaW5nfSAgbmFtZSAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHsqfSAgICAgICB2YWwgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge0Jvb2xlYW59IFt2b2JqXSAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7TnVtYmVyfSAgW3N0YW1wID0gbmV3IHN0YW1wXSBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtCb29sZWFufSBbbm91cGRhdGVdICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG4nc2V0JywgZnVuY3Rpb24oIG5hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tICkge1xuXG4gIC8vZnVuY3Rpb24oIG5hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tICkgXG5cbiAgLy8gY29uc29sZS5sb2cobmFtZSwgc3RhbXApXG5cbiAgZnJvbSA9IGZyb20gJiYgdGhpc1xuICBpZiAoIXZvYmogJiYgKHRoaXNbbmFtZV0gaW5zdGFuY2VvZiBvYmplY3QpKSB7XG4gICAgaWYgKHRoaXMuXyRzZXRWYWwuY2FsbCh0aGlzW25hbWVdLCB2YWwsIHN0YW1wLCBmcm9tLCBub3VwZGF0ZSkgPT09IGZhbHNlICYmIHN0YW1wKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZvYmopIHtcbiAgICAgIGlmKHRoaXNbbmFtZV0pIHRoaXNbbmFtZV0ucmVtb3ZlKClcbiAgICAgIHRoaXNbbmFtZV0gPSB2YWxcbiAgICAgIHRoaXNbbmFtZV0uX25hbWUgPSBuYW1lXG4gICAgICB0aGlzW25hbWVdLl9wYXJlbnQgPSB0aGlzXG4gICAgICBpZighbm91cGRhdGUpIHZhbC5fdXBkYXRlKHZhbCwgc3RhbXAgfHwgdGhpcy5zdGFtcCgpLCBmcm9tLCB2b2lkIDAsIHRydWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbbmFtZV0gPSBuZXcgdGhpcy5fY2xhc3Modm9pZCAwLCBmYWxzZSwgdGhpcylcbiAgICAgIHRoaXNbbmFtZV0uX25hbWUgPSBuYW1lXG4gICAgICB0aGlzLl8kc2V0VmFsLmNhbGwodGhpc1tuYW1lXSwgdmFsLCBzdGFtcCwgZnJvbSwgbm91cGRhdGUsIHRydWUpXG4gICAgfVxuICAgIGlmICh0aGlzLl9fdCA9PT0gMSAmJiB0aGlzLl9zZXRBcnJheUl0ZW0pIHtcbiAgICAgIHRoaXMuX3NldEFycmF5SXRlbSggdGhpc1tuYW1lXSwgdmFsIClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn0sXG4vKipcbiAqIFJlbW92ZXMgYSBWLk9iamVjdCBpbmNsdWRpbmcgYWxsIG5lc3RlZCBmaWVsZHMgYW5kIHZhbHVlc1xuICogQG1ldGhvZCByZW1vdmVcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBbbmVzdGVkXSAgICAgICAgICAgICBXaGVuIHRydWUgcmVtb3ZlIG5lc3RlZCBvYmplY3RzXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgW2JsXSAgICAgICAgICAgICAgICAgV2hlbiB0cnVlIGRvZXNuJ3QgcmVtb3ZlIGJsYWNrbGlzdGVkIGl0ZW1zXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgW25vdF0gICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Qm9vbGVhbnxPYmplY3R9IFtmcm9tXSAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICBbc3RhbXAgPSBuZXcgc3RhbXBdICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgW25vdXBkYXRlXSAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xuIC8vICAgIHRoaXMucmVtb3ZlKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSlcblxuJ3JlbW92ZScsIGZ1bmN0aW9uKG5lc3RlZCwgYmwsIG5vdCwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKSB7IC8vbm8gdXBkYXRlIGZpcnN0ID4gKGV4dGVuZGVkIGluIHNlbGVjdGlvbi5qcylcbiAgaWYgKCFuZXN0ZWQpIHRoaXMuX3JlbW92ZWQgPSB0cnVlXG4gIHZhciByLCBpLCBvbGR2YWxcbiAgaWYgKCFzdGFtcCkgc3RhbXAgPSB0aGlzLnN0YW1wKClcbiAgLy8gY29uc29sZS5sb2coJ1NUQVJUJyxzdGFtcCx0aGlzLl9uYW1lKTtcbiAgaWYgKCFuZXN0ZWQpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICB0aGlzLl9wYXJlbnRbdGhpcy5fbmFtZV0gPSBudWxsXG4gICAgICBkZWxldGUgdGhpcy5fcGFyZW50W3RoaXMuX25hbWVdXG4gICAgfVxuICAgIGlmICh0aGlzLl92YWwgIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHRoaXMuX3ZhbCBpbnN0YW5jZW9mIG9iamVjdCAmJiB0aGlzLl92YWwuX2NvbnRhaW5lZCkge1xuICAgICAgICB0aGlzLl92YWwucmVtb3ZlKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZyb20gfHwgdGhpcywgc3RhbXAsIG5vdXBkYXRlKVxuICAgICAgfVxuICAgICAgb2xkdmFsID0gdGhpcy5fdmFsXG4gICAgICB0aGlzLl92YWwgPSBudWxsXG4gICAgfVxuICB9XG4gIGZvciAoaSBpbiB0aGlzKSB7XG4gICAgaWYgKCghbm90IHx8ICFub3RbaV0pICYmICF1dGlsLmNoZWNrQXJyYXkodGhpcy5fYmxhY2tsaXN0LCBpKSkge1xuICAgICAgaWYgKHRoaXNbaV0gaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgICAgciA9IGZhbHNlXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdERUxFVEUnLHN0YW1wLGksdGhpc1tpXSk7XG4gICAgICAgIHRoaXNbaV0ucmVtb3ZlKGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZyb20gfHwgdGhpcywgc3RhbXAsIG5vdXBkYXRlKVxuICAgICAgfVxuICAgICAgdGhpc1tpXSA9IG51bGxcbiAgICAgIGRlbGV0ZSB0aGlzW2ldIC8vZGVsZXRlIGlzIHByZXR0eSBuYXN0eSBmb3IgcGVyZm9ybWFuY2VcbiAgICB9XG4gIH1cbiAgaWYgKCFuZXN0ZWQpIHtcbiAgICBpZiAodGhpcy5fcmVtb3ZlKSB7XG4gICAgICAvL3JcbiAgICAgIHRoaXMuX3JlbW92ZShmcm9tLCBub3VwZGF0ZSA/IGZhbHNlIDogZnJvbSAvKnx8ciovICwgc3RhbXAsIG9sZHZhbCk7XG4gICAgICBpZiAoIWJsKSB7XG4gICAgICAgIGZvciAodmFyIGogaW4gdGhpcykge1xuICAgICAgICAgIGlmICh0aGlzW2pdICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmIChqICE9PSAnX3BhcmVudCcgJiYgdGhpc1tqXSBpbnN0YW5jZW9mIG9iamVjdCAmJiB0aGlzW2pdLl9jb250YWluZWQpIHtcbiAgICAgICAgICAgICAgdGhpc1tqXS5yZW1vdmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpc1tqXSA9IG51bGxcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2pdXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3JlbW92ZWQgPSB0cnVlXG4gIH1cbiAgcmV0dXJuIHJcbn0pXG5cblxuLy8tLS0tdGhpcyBoYXMgdG8gYmUgaW5pdGlhbGl6ZWQgYWZ0ZXIgZGVmaW5pbmcgdGhlIGJsYWNrbGlzdCBwcm9wZXJ0eTtcbmV4cG9ydHMubGlzdGVuID0gcmVxdWlyZSgnLi9saXN0ZW4nKVxucmVxdWlyZSgnLi9hcnJheScpXG5yZXF1aXJlKCcuL3V0aWwnKSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG4gICwgdk9iamVjdCA9IHJlcXVpcmUoJy4vJylcbiAgLCBWID0gcmVxdWlyZSgnLi4vJylcbiAgLy9UT0RPOiB0aGlzIGlzIGEgdGVtcCBmaXggdG8gZW11bGF0ZSBvbiBuZXh0IHRpY2tcbiAgLCByYWYgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vcmFmJylcbiAgLCBQcm9taXNlID0gcmVxdWlyZSgncHJvbWlzZScpXG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lciggb2JqLCBmbiwgbWFyaywgb3JpZ2luYWwgKSB7XG4gIC8vdmFsLCBtYXJrLCBza2lwY2hlY2ssIGlnbm9yZXZhbCwgb3JnaW5hbFxuICBpZiggbWFyayApIFxuICB7XG4gICAgLy8gY29uc29sZS5sb2coJ2hleSBnb3Qgb3JnaW5hbCEnLCBvcmlnaW5hbClcbiAgICAvL24oIHZhbCwgbWFyaywgc2tpcGNoZWNrLCBpZ25vcmV2YWwsIG9yaWdpbmFsIClcbiAgICBvYmouYWRkTGlzdGVuZXIoWyBmbiwgbWFyayBdLCB0cnVlLCBmYWxzZSwgZmFsc2UsIG9yaWdpbmFsICApXG4gIH0gXG4gIGVsc2UgXG4gIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2hleSBnb3Qgb3JnaW5hbCEnLCBvcmlnaW5hbClcblxuICAgIG9iai5hZGRMaXN0ZW5lciggZm4sIGZhbHNlLCBmYWxzZSwgZmFsc2UsIG9yaWdpbmFsIClcbiAgfVxufVxuXG4vKlxuICBfdXBkYXRlIGNhbGxzIGxpc3RlbmVycyBvbiBhIGdpdmVuIE9iamVjdCAobGlzdGVuZXJzIGluY2x1ZGUgbGlua2luZyBmaWVsZHMgaW4gb3RoZXIgVi5PYmplY3RzKVxuICBWLk9iamVjdC5fdXBkYXRlIGNhbiBiZSBtb2RpZmllZCB0byBjaGFuZ2UgdXBkYXRlIGJlaGF2aW9yOlxuICAgIC0gc3RhbmRhcmQ6IHVwZGF0ZSBPYmplY3QgYW5kIGl0J3MgcGFyZW50cyAvIGFuY2VzdG9ycyByZWN1cnNpdmVseS5cbiAgICAtIHBhcmVudE9ubHk6IHVwZGF0ZSBPYmplY3QgYW5kIG9ubHkgaXRzIGRpcmVjdCBwYXJlbnQuXG4gICAgLSBqdXN0IF91cGRhdGU6IHVwZGF0ZSBvbmx5IHRoZSBPYmplY3QuXG4qL1xudmFyIF91cGRhdGUgPSBleHBvcnRzLl91cGRhdGUgPSBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIHRlc3QpIHtcblxuICAvLyBpZih3aW5kb3cuaGVyZSkgY29uc29sZS5sb2coJ1VQREFURSEnLHRoaXMuX3BhdGgpXG5cbiAgdmFyIF9sID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgLCBpXG4gICAgLCBsaXN0ZW5lclxuXG4gIGlmIChfbCkge1xuICAgIGZvciAoaSA9IF9sLmxlbmd0aDsgbGlzdGVuZXIgPSBfbFstLWldOykgeyAvL29yZGVyIGlzIGlycmVsZXZhbnRcbiAgICAgIGlmIChsaXN0ZW5lciBpbnN0YW5jZW9mIHZPYmplY3QpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndXBkYXRlPz8/Pz8nLCBsaXN0ZW5lci5fcGF0aCwgdGhpcy5fcGF0aCwgZnJvbSlcblxuICAgICAgICAvLyBpZiAoZnJvbSkge1xuICAgICAgICBsaXN0ZW5lci5fbGZyb20gPSBmcm9tIHx8IHRoaXNcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgbGlzdGVuZXIuX3VwZGF0ZSh2YWwsIHN0YW1wLCBmYWxzZSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKVxuXG4gICAgICAgIGlmIChsaXN0ZW5lcikgbGlzdGVuZXIuX2xmcm9tID0gbnVsbFxuXG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVyWzBdKSB7XG4gICAgICAgIGlmKCF0ZXN0IHx8ICF0ZXN0KGxpc3RlbmVyKSkge1xuICAgICAgICAgIGlmIChsaXN0ZW5lci5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBsID0gbGlzdGVuZXIubGVuZ3RoIC0gMlxuICAgICAgICAgICAgICAsIGwyID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgICAgICAsIGEgPSBbXSwgaiA9IC0xXG4gICAgICAgICAgICAgICwgbGEgPSBsICsgbDJcbiAgICAgICAgICAgICAgOyBqIDwgbGFcbiAgICAgICAgICAgICAgOyBhWysral0gPSBqIDwgbFxuICAgICAgICAgICAgICAgID8gbGlzdGVuZXJbaiArIDJdXG4gICAgICAgICAgICAgICAgOiBqID09PSBsID8gdGhpcyA6IGFyZ3VtZW50c1tqIC0gbCAtIDFdXG4gICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIGxpc3RlbmVyWzBdLmFwcGx5KGxpc3RlbmVyWzFdLCBhKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaXN0ZW5lclswXS5jYWxsKGxpc3RlbmVyWzFdLCB0aGlzLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG4vLyB1dGlsLmRlZmluZSh2T2JqZWN0LCBcbi8vICAgJ19ub2RlUGF0aF8nLCBmdW5jdGlvbigpIHtcbi8vICAgICBpZih0aGlzLl9jYWxsZXIpIHtcblxuLy8gICAgICAgdmFyIGFyciA9IFtdXG4vLyAgICAgICB2YXIgcCA9IHRoaXMuX2NhbGxlclxuXG4vLyAgICAgICB3aGlsZShwKSB7XG4vLyAgICAgICAgIGFyci5wdXNoKCBwLl9uYW1lIHx8IHAuX25vZGUgJiYgcC5fbm9kZS5jbGFzc05hbWUgKVxuLy8gICAgICAgICBwID0gcC5fbm9kZSAmJiBwLnBhcmVudFxuLy8gICAgICAgfVxuLy8gICAgICAgYXJyLnJldmVyc2UoKVxuLy8gICAgICAgcmV0dXJuIGFyclxuXG5cbi8vICAgICB9XG4vLyAgIH1cblxuLy8gKVxuXG5cbnZPYmplY3QucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX2xpc3RlbmVycycsICdfbGlzdGVucycsICdfbGZyb20nLCAnX2xpc3Rlbk1hcCcpO1xuXG51dGlsLmRlZmluZSh2T2JqZWN0LFxuICAvKipcbiAgICogX3NldFxuICAgKiBpcyBjYWxsZWQgd2hlbiBhIHZhbHVlIGlzIHNldFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX3NldCcsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgbm91cGRhdGUsIGFkZGVkLCBvbGR2YWwpIHtcbiAgICBpZiAoIW5vdXBkYXRlKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9wYXRoLCB2YWwpXG4gICAgICB0aGlzLl91cGRhdGUodmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKTtcbiAgICB9XG4gIH0sXG5cbiAgJ2lzJywgZnVuY3Rpb24gKHZhbCwgY2IsIG5leHRUaWNrICkge1xuXG4gICAgLy9vbiByZW1vdmFsIG9mIHByb21pc2UgcmVtb3ZlIGxpc3RlbmVyXG5cbiAgICBpZighY2IgfHwgKCB0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICBuZXh0VGljayA9IGNiXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdteSBtb2ZvJywgbmV4dFRpY2spXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oIHJlc29sdmUsIHJlamVjdCApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJzMxMjEyMzEyMzIxMycsIHZhbClcbiAgICAgICAgX3RoaXMuaXMoIHZhbCwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzb2x2ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH0sIG5leHRUaWNrKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5lcnJvcignbGV6emdvJylcbiAgICAgIHZhciBjYnggPSBuZXh0VGljayA/IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICAgICAgICAsIF90aGlzID0gdGhpc1xuICAgICAgICByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgY2IuY2FsbChfdGhpcylcbiAgICAgICAgfSlcbiAgICAgIH0gOiBjYlxuICAgICAgLy9UT0RPOiBhZGQgb3JpZ2luYWwgaWYgaXRzIG5vdCBcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCctLS0tLS0tLS0tLS0tLScsIHZhbClcblxuICAgICAgaWYodmFsPT09J2xvYWRlZCcpIHtcbiAgICAgICAgaWYodGhpcy4kbG9hZGVkIHx8IHRoaXMuZnJvbS4kbG9hZGVkKSB7XG4gICAgICAgICAgY2J4LmNhbGwodGhpcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9uY2UoJ2xvYWRlZCcsIGNieClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJldFxuICAgICAgICAvLyB2YXIgaWdub3JlXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJzEhQCNAIyEhQCMnLCByZXQsIHZhbClcblxuICAgICAgICBpZih0aGlzLnZhbCA9PSB2YWwgKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignMiFAI0AjISFAIycsIHJldCwgdmFsKVxuXG4gICAgICAgICAgcmV0dXJuIGNieC5jYWxsKHRoaXMpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignIUAjeHh4eHgxMjEyMTIxMjEyMjExMkAjISFAIycsIHJldCwgdmFsKVxuXG4gICAgICAgICAgcmV0ID0gKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpICYmIHZhbC5jYWxsKHRoaXMpXG4gICAgICAgICAgLy8gaWdub3JlID0gdHJ1ZVxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJzIyMjIyMjIyMjIhQCNAIyEhQCMnLCByZXQsIHZhbClcbiAgICAgICAgfVxuICAgICAgICBpZihyZXQpIHtcbiAgICAgICAgICBpZiggcmV0IGluc3RhbmNlb2YgUHJvbWlzZSApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3Byb21pc2UnKVxuICAgICAgICAgICAgcmV0dXJuIHJldFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnPz8/PyEhIScpXG4gICAgICAgICAgICByZXR1cm4gY2J4LmNhbGwodGhpcylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignMjIyMjIhQCFAIyFAIycsIHZhbClcbiAgICAgICAgICBpZih0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2UodmFsLCBjYngpXG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vbmNlKHtcbiAgICAgICAgICAgICAgJHZhbDogdmFsXG4gICAgICAgICAgICB9LCBjYngpXG4gICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICB9LFxuICAvKipcbiAgICogX191cGRhdGVcbiAgICogY2FsbHMgbGlzdGVuZXJzIGF0dGFjaGVkIHRvIHRoZSBPYmplY3RcbiAgICogdHlwZXMgLS0gZnVuY3Rpb24gb3IgVi5PYmplY3RcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ19fdXBkYXRlJywgX3VwZGF0ZSxcbiAgLyoqXG4gICAqIF91cGRhdGVcbiAgICogZXNjYWxhdGVzIGFuIHVwZGF0ZSB1cCBpdCdzIHN0cnVjdHVyZSBhbmQgY2FsbHMgX191cGRhdGUgdG8gY2FsbCBsaXN0ZW5lcnNcbiAgICogdHlwZXMgLS0gZnVuY3Rpb24gb3IgVi5PYmplY3RcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ191cGRhdGUnLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIHRlc3QpIHsgLy9oZXJlIHlvdSBjYW4gc2VlIGlmIGl0cyBhbiB1cGRhdGUgZnJvbSBhbm90aGVyIG9iamVjdCAoZnJvbSlcbiAgICAvLyBjb25zb2xlLmxvZygnVi5PYmplY3QgT0cgX3VwZGF0ZScsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbClcbiAgICB2YXIgY3VyciA9IHRoaXMsXG4gICAgcyA9IHRydWVcblxuICAgIHdoaWxlIChjdXJyKSB7XG4gICAgICAvLyB2YXIgcCA9IGN1cnIuX3BhdGhcbiAgICAgIC8vIF91cGRhdGUgW1wiY2xpZW50c1wiLCBcIlZfMnB4Y2V3djNnNGtcIl0gXG4gICAgICAvLyBjb25zb2xlLmxvZygnX3VwZGF0ZScsIHAsIHZhbCwgZnJvbSB8fCAoKCFzICYmIHRoaXMpID8gdGhpcyA6IHZvaWQgMCwgdGhpcykgKVxuXG4gICAgICAvL1RPRE8gMTAgZG91YmxlIGNoZWNrIHRoaXNcbiAgICAgIGN1cnIuX191cGRhdGUodmFsLCBzdGFtcCwgZnJvbSB8fCAocyE9PXRydWUpID8gdGhpcyA6IGZhbHNlICwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCB0ZXN0KVxuICAgICAgY3VyciA9IGZyb20gPyBmYWxzZSA6IGN1cnIuX3BhcmVudFxuICAgICAgcyA9IGZhbHNlXG4gICAgICBpZiAocmVtb3ZlKSByZW1vdmUgPSAxXG4gICAgfVxuICB9LFxuICAvKipcbiAgICogX3JlbW92ZVxuICAgKiBjYWxsZWQgb24gcmVtb3ZlXG4gICAqIEBtZXRob2RcbiAgICovXG4gICdfcmVtb3ZlJywgZnVuY3Rpb24oZnJvbSwgdXBkYXRlLCBzdGFtcCwgb2xkdmFsKSB7XG4gICAgaWYgKHVwZGF0ZSAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZShudWxsLCBzdGFtcCwgZnJvbSwgdHJ1ZSwgZmFsc2UsIG9sZHZhbCk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoKTtcbiAgICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5zLFxuICAgICAgaSwgbGlzdGVuZXI7XG4gICAgaWYgKF9sKSB7XG4gICAgICAvL29wdGltaXplIGxhdGVyXG4gICAgICAvL3RoaXMsdGhpcyBpcyB3ZWlyZCB0byBhbHdheXMgdXNlIHRoaXMuLi5cbiAgICAgIGZvciAoaSA9IF9sLmxlbmd0aCAtIDE7IGkgPj0gMDsgX2xbaS0tXS5yZW1vdmVMaXN0ZW5lcih0aGlzLCB2b2lkIDAsIGZhbHNlLCB0cnVlKSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogX3NldHZvYmpcbiAgICogaWYgYSB2YWx1ZSBpcyBzZXQgdG8gYSBWLk9iamVjdFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX3NldHZvYmonLCBmdW5jdGlvbih2YWwpIHtcbiAgICB2YWwuYWRkTGlzdGVuZXIodGhpcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBfY2hhbmdldm9ialxuICAgKiBpZiBhIHZhbHVlIGlzIGNoYW5nZWQgZnJvbSBhIFYuT2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICovXG4gICdfY2hhbmdldm9iaicsIGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICh0aGlzLl9fdCA9PT0gNCkge1xuICAgICAgdmFyIF9sID0gdGhpcy5fbGlzdGVucyxcbiAgICAgICAgX3ZhbCA9IHRoaXMuX3ZhbCxcbiAgICAgICAgaTtcbiAgICAgIGlmIChfbCkge1xuICAgICAgICBmb3IgKGkgPSBfbC5sZW5ndGg7IGkgPj0gMDsgX2xbLS1pXSAmJiBfbFtpXS5yZW1vdmVMaXN0ZW5lcih0aGlzLCB0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoX3ZhbCBpbnN0YW5jZW9mIHZPYmplY3QgJiYgX3ZhbC5fY29udGFpbmVkKSB7XG4gICAgICAgIF92YWwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogYWRkTGlzdGVuZXJcbiAgICogYWRkcyBhIGxpc3RlbmVyIHRvIGFuIG9iamVjdCBjYW4gYmUgYSBmdW5jdGlvbiBvciBWLk9iamVjdFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnYWRkTGlzdGVuZXInLCBmdW5jdGlvbiggdmFsLCBtYXJrLCBza2lwY2hlY2ssIGlnbm9yZXZhbCwgb3JpZ2luYWwgKSB7XG4gICAgdmFyIF9sID0gdGhpcy5fbGlzdGVuZXJzIHx8ICh0aGlzLl9saXN0ZW5lcnMgPSBbXSksXG4gICAgICB0YXJnZXQsIGc7XG5cbiAgICBpZihvcmlnaW5hbCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ09SR0lOQUwhJywgb3JpZ2luYWwpXG4gICAgICBpZighdGhpcy5fbGlzdGVuTWFwKSB7XG4gICAgICAgIHRoaXMuX2xpc3Rlbk1hcCA9IFtdXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9tb3JlIHNwZWVkIHZvb3IgY2hlY2thcnJheVxuICAgIGlmIChtYXJrKSB7XG4gICAgICBnID0gdXRpbC5jaGVja0FycmF5KF9sLCB2YWxbMV0sIDEpO1xuICAgICAgaWYgKGcgPT09IGZhbHNlXG4gICAgICAgIHx8ICFpZ25vcmV2YWwgJiYgdXRpbC5jaGVja0FycmF5KF9sLCB2YWxbMF0sIDApID09PSBmYWxzZVxuICAgICAgICB8fCAobWFyayAhPT0gdHJ1ZSAmJiBtYXJrLmNhbGwodGhpcywgX2xbZ10sIF9sLCBnLCB2YWwpID09PSB0cnVlKSkge1xuICAgICAgICBcbiAgICAgICAgLy9UT0RPOiBmaXggdGhpcyB1bHRyYSBkaXJ0eSBzdHVmZlxuICAgICAgICBpZiggb3JpZ2luYWwgJiYgdmFsICE9PSBvcmdpbmFsICkge1xuICAgICAgICAgIHRoaXMuX2xpc3Rlbk1hcC5wdXNoKFsgb3JnaW5hbCwgdmFsIF0pXG4gICAgICAgIH1cblxuICAgICAgICBfbC5wdXNoKHZhbCk7XG4gICAgICB9IGVsc2UgIHtcbiAgICAgICAgIHJldHVybiBfbFtnXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCF2YWwuX190IHx8ICF1dGlsLmNoZWNrQXJyYXkoX2wsIHZhbCkpIHtcblxuICAgICAgaWYoIG9yaWdpbmFsICYmIHZhbCAhPT0gb3JpZ2luYWwgKSB7XG4gICAgICAgIHRoaXMuX2xpc3Rlbk1hcC5wdXNoKFsgb3JpZ2luYWwsIHZhbCBdKVxuICAgICAgfVxuXG4gICAgICBfbC5wdXNoKHZhbCk7XG4gICAgfVxuICAgIGlmIChtYXJrIHx8IHZhbCBpbnN0YW5jZW9mIHZPYmplY3QpIHtcbiAgICAgIHRhcmdldCA9IG1hcmsgPyB2YWxbMV0gOiB2YWw7XG4gICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2Ygdk9iamVjdCkge1xuICAgICAgICBfbGkgPSB0YXJnZXQuX2xpc3RlbnMgfHwgKHRhcmdldC5fbGlzdGVucyA9IFtdKTtcbiAgICAgICAgaWYgKHNraXBjaGVjayB8fCAhdXRpbC5jaGVja0FycmF5KF9saSwgdGhpcykpIHtcblxuICAgICAgICAgIGlmKCBvcmlnaW5hbCAmJiB2YWwgIT09IG9yaWdpbmFsICkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuTWFwLnB1c2goWyBvcmlnaW5hbCwgdmFsIF0pXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2xpLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICAnb25jZScsIGZ1bmN0aW9uKCB2YWwsIG1ldGhvZCwgbWFyayApIHtcblxuICAgIC8vdmFsLCBtYXJrLCBza2lwY2hlY2ssIGlnbm9yZXZhbCwgb3JnaW5hbFxuXG4gICAgLy9UT0RPOnVuaWZ5IC93IG9uXG4gICAgdmFyIG12YWxcblxuICAgIHZhciBsaXN0ZW4gPSBmdW5jdGlvbigpIHtcbiAgICAgIFxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lciggbXZhbCwgbWFyayApXG4gICAgICAvLyB0aGlzLnJlbW92ZUxpc3RlbmVyKCBsaXN0ZW4gKVxuXG4gICAgICBtdmFsLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgLy9vcmlnaW5hbCBwZXJoYXBzPz8/P1xuICAgIH1cblxuICAgIGlmKCBtZXRob2QgKSB7XG4gICAgICBtdmFsID0gbWV0aG9kXG4gICAgICB0aGlzLm9uKCB2YWwsIGxpc3RlbiwgZmFsc2UsIG12YWwgKSAvL2RlemUgZm4gbW9ldCB3ZWwgZ2VyZW1vdmVkIHdvcmRlbiBnZWJldXJkIG51IG5pZXQhXG4gICAgfSBlbHNlIHtcbiAgICAgIG12YWwgPSB2YWxcbiAgICAgIHRoaXMub24oIGxpc3RlbiwgZmFsc2UsIGZhbHNlLCBtdmFsIClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpc1xuXG4gIH0sXG4gICdvbicsIGZ1bmN0aW9uKCB2YWwsIG1ldGhvZCwgbWFyaywgb3JpZ2luYWwgKSB7XG4gICAgICAvKipcbiAgICAgICAgKiB2YWwgY2FuIGJlIGEgY29uZGl0aW9uIG9yIGEgY29tcGFyaXNvbiBvciBhIG1ldGhvZFxuICAgICAgKiovXG4gICAgICBpZiggVi5CYXNlICYmIG1ldGhvZCBpbnN0YW5jZW9mIFYuQmFzZSApIFxuICAgICAge1xuICAgICAgICBtYXJrID0gbWV0aG9kIC8vbWFrZSBleGNlcHRpb24gZm9yIHZhbHVlcyFcbiAgICAgICAgbWV0aG9kID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZighb3JpZ2luYWwpIHtcbiAgICAgICAgb3JpZ2luYWwgPSBtZXRob2RcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXQgb3JpZ2luYWwhJywgb3JpZ2luYWwsIG1ldGhvZCApXG4gICAgICB9XG5cbiAgICAgIGlmKCAhbWV0aG9kICkgXG4gICAgICB7XG4gICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgdmFsLCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICB9XG4gICAgICBlbHNlIFxuICAgICAge1xuICAgICAgICBpZiggdXRpbC5pc09iaiggdmFsICkgKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gY29uc29sZS53YXJuKCd0aGlzIHdpbGwgYmVjb21lIGEgY29uZGl0aW9uIGxhdGVyIG9uIGZvciBub3cgaXRzIG5vdCBzdXBwb3J0ZWQhLCBjb25kaXRpb25zIHdpbGwgYmUgdXNlZCBldmV5cndoZXJlJylcbiAgICAgICAgICAvL0hhcyB0byBiZWNvbWUgYSBjb25kaXRpb25cbiAgICAgICAgICBpZih2YWwuJHZhbCkge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCApIHtcbiAgICAgICAgICAgICAgaWYoIHRoaXMudmFsID09PSB2YWwuJHZhbCApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3RoaXMgd2lsbCBiZWNvbWUgYSBjb25kaXRpb24gbGF0ZXIgb24gZm9yIG5vdyBpdHMgbm90IHN1cHBvcnRlZCEsIGNvbmRpdGlvbnMgd2lsbCBiZSB1c2VkIGV2ZXlyd2hlcmUnKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvL0hhcyB0byBiZWNvbWUgYSBjb25kaXRpb25cblxuXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiggdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyApXG4gICAgICAgIHtcbiAgICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIGZ1bmN0aW9uKCBudmFsICkge1xuICAgICAgICAgICAgaWYoIHZhbC5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBcbiAgICAgICAge1xuXG4gICAgICAgICAgaWYoIHV0aWwuaXNPYmooIG1ldGhvZCApIClcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIG1hcmsgPSB2YWxcblxuICAgICAgICAgICAgY29uc29sZS53YXJuKCd1bnRlc3RlZCAtLSBhZGQgYXMgbWFyaycpXG4gICAgICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIGZ1bmN0aW9uKCBudmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsICkge1xuICAgICAgICAgICAgICBpZiggcmVtb3ZlICkgLy9tb3JlIGNoZWNrc1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtYXJrLCBvcmlnaW5hbCApXG5cblxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCB2YWwgPT09ICdyZW1vdmUnIClcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvL3ZhbCwgc3RhbXAsIGZhbHNlLCByZW1vdmUsIGFkZGVkLCBvbGR2YWxcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKSB7XG4gICAgICAgICAgICAgIGlmKCByZW1vdmUgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9UT0RPOiBpbiByZWRvIHRoaXMgd2lsbCBiZSBkb25lIGRpZmZlcmVudGx5IChldmVudCB0eXBlcyBhcmUgc3BlY2lhbCBkb25lKVxuICAgICAgICAgIGVsc2UgaWYoIHZhbCA9PT0gJ2xvYWRlZCcgKSB7XG4gICAgICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIGZ1bmN0aW9uKCBudmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsICkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggYWRkZWQgKSAvL3dlcmt0IG5pZXQhO1xuICAgICAgICAgICAgICAvL19fZnJvbW1ldGhvZFxuXG4gICAgICAgICAgICAgIGlmKCB0aGlzLiRsb2FkZWQgfHwgdGhpcy5mcm9tLiRsb2FkZWQgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiggdmFsID09PSAnYWRkZWQnIClcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIGZ1bmN0aW9uKCBudmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsICkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggYWRkZWQgKSAvL3dlcmt0IG5pZXQhO1xuICAgICAgICAgICAgICBpZiggYWRkZWQgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiggdmFsID09PSAnc2VsZicgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBhZGRlZCApIC8vd2Vya3QgbmlldCE7XG5cbiAgICAgICAgICAgICAgLy9UT0RPOiBwdXQgb24gaW4gYSBkaWZmZXJlbnQgZmlsZVxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnU0hPVUxEIERPIFNFTEYhJywgYXJndW1lbnRzLCBmcm9tICkgLy96byB3cm9uZyFcblxuICAgICAgICAgICAgICBpZiggdGhpcy5fdmFsID09PSBudmFsIFxuICAgICAgICAgICAgICB8fCAhdmFsICYmIHRoaXMuX3VwZGF0ZU9yaWdpbj09PXRoaXMgLy9wcmV0dHkgc2xvdyBjaGVjayAsIGl0cyB0aGVyZSB0byBjaGVjayB3aGVuIHNvbWVvbmUgY2FsbCAudXBkYXRlIGZvciBleGFtcGxlXG4gICAgICAgICAgICAgICkgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwgKSB7XG4gICAgICAgICAgICAgIGlmKCBudmFsID09PSB2YWwgfHwgdGhpcy52YWwgPT09IHZhbCB8fCB0aGlzLl92YWwgPT09IHZhbCApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gIC8qKlxuICAgKiByZW1vdmVMaXN0ZW5lclxuICAgKiBpZiBubyB2YWwgcmVtb3ZlcyBhbGwgbGlzdGVuZXJzXG4gICAqIG1hcmsgY2hlY2tzIGluIGFycmF5IG9uIHBvc2l0aW9uIDEgZm9yIHVuaXF1ZW5lc3NcbiAgICogcmVtb3ZlIGlzIHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCBtYXJrXG4gICAqIEBtZXRob2RcbiAgICovXG4gICdyZW1vdmVMaXN0ZW5lcicsIGZ1bmN0aW9uKHZhbCwgbWFyaywgcmVtb3ZlLCBub2JyZWFrKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3JlbW92ZUxpc3RlbmVyIScsIHRoaXMuX3BhdGgsIHRoaXMuX2xpc3RlbmVycyAmJiB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoXG4gICAgLy8gICAsICdcXG5tYXJrOlxcbicsIG1hcmsgJiYgbWFyay5yYXdcbiAgICAvLyAgICwgJ1xcbnZhbDpcXG4nLCB2YWwgJiYgdmFsLm5hbWVcbiAgICAvLyAgICwgJ1xcbnZhbDpcXG4nLCB2YWxcbiAgICAvLyApXG4gICAgdmFyIF9sID0gdGhpcy5fbGlzdGVuZXJzLFxuICAgICAgaTtcbiAgICBpZiAoX2wpIHtcbiAgICAgIGZvciAoaSA9IF9sLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIC8vbWF5YmUgY2hlY2tpbmcgbWFyayBhbGwgdGhlIHRpbWUgaXMgdG9vIHNsb3c/XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IF9sW2ldXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoIW1hcmsgJiYgIXZhbClcbiAgICAgICAgICB8fCAodmFsICYmIGxpc3RlbmVyID09PSB2YWwpIC8vZmFsc2Ugdm9vciBtYXJrXG4gICAgICAgICAgfHwgKG1hcmshPT1mYWxzZSAmJiAoKGxpc3RlbmVyIGluc3RhbmNlb2YgQXJyYXkpICYmICgobWFyayAmJiBsaXN0ZW5lclsxXSA9PT0gbWFyayAmJiAoIXZhbHx8bGlzdGVuZXJbMF09PT12YWwpKSB8fCB2YWwgJiYgbGlzdGVuZXJbMV0gPT09IHZhbCkpXG4gICAgICAgICAgICAmJiAoIXJlbW92ZVxuICAgICAgICAgICAgICB8fCAocmVtb3ZlID09PSB0cnVlICAvL2RpdCBtb2V0IGxhdGVyIHdlZyBpcyBkYW4gYWxsZWVuIGVlbiBmdW5jdGllIGlzIG51IG92ZXJib2RpZyAoY2hlY2sgYm92ZW4pXG4gICAgICAgICAgICAgICAgPyBsaXN0ZW5lclswXSA9PT0gdmFsXG4gICAgICAgICAgICAgICAgOiByZW1vdmUuY2FsbCh0aGlzLCBsaXN0ZW5lciwgbWFyaykpKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ21hcmsuX2xpc3RlbnM/JywgISEobWFyayAmJiBtYXJrLl9saXN0ZW5zKVxuICAgICAgICAgIC8vICAgICAsICdcXG5pcyB2T2JqZWN0PycsIGxpc3RlbmVyIGluc3RhbmNlb2Ygdk9iamVjdFxuICAgICAgICAgIC8vICAgICAsICdcXG5pcyBtYXJrZWQ/JywgbGlzdGVuZXIgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgIC8vICAgKVxuICAgICAgICAgIHZhciBmb2N1cyA9IG1hcmtcbiAgICAgICAgICAgID8gbWFya1xuICAgICAgICAgICAgOiBsaXN0ZW5lciBpbnN0YW5jZW9mIHZPYmplY3RcbiAgICAgICAgICAgICAgPyBsaXN0ZW5lclxuICAgICAgICAgICAgICA6IGxpc3RlbmVyIGluc3RhbmNlb2YgQXJyYXlcbiAgICAgICAgICAgICAgICA/IGxpc3RlbmVyWzFdXG4gICAgICAgICAgICAgICAgOiBmYWxzZVxuICAgICAgICAgIHZhciBsaXN0ZW5zID0gZm9jdXMgJiYgZm9jdXMuX2xpc3RlbnNcbiAgICAgICAgICBpZihsaXN0ZW5zKXtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IGxpc3RlbnMubGVuZ3RoLTEgOyBqID49IDAgOyBqLS0pe1xuICAgICAgICAgICAgICBpZihsaXN0ZW5zW2pdID09PSB0aGlzKXtcbiAgICAgICAgICAgICAgICBsaXN0ZW5zLnNwbGljZShqLCAxKVxuICAgICAgICAgICAgICAgIGlmKGxpc3RlbnMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgZm9jdXMuX2xpc3RlbnMgPSBudWxsXG4gICAgICAgICAgICAgICAgaWYoZm9jdXMuX190ID09PSA0ICYmIGxpc3RlbmVyLl92YWwgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5fdmFsID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBfbC5zcGxpY2UoaSwgMSlcbiAgICAgICAgICBpZiAoX2wubGVuZ3RoID09PSAwKSB0aGlzLl9saXN0ZW5lcnMgPSBudWxsO1xuICAgICAgICAgIGlmICh2YWwgJiYgIW5vYnJlYWspIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy9UT0RPOiB0aGlzIGhhcyB0byBiZSByZWZhY3RvcmVkIEFTQVAhIGRvIHdoZW4gbmV3IGRlc2lnbiBwaGFzZSBmb3Igdm9iamVjdCtiYXNlIGlzIGdvaW5nIGRvd25cbiAgICAgIGlmKCB0aGlzLl9saXN0ZW5NYXAgJiYgdmFsICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaW0gaGVyZSEnLCB2YWwpXG4gICAgICAgIHZhciBwaXZcbiAgICAgICAgZm9yKHZhciBpID0gMCwgX2xlbiA9IHRoaXMuX2xpc3Rlbk1hcC5sZW5ndGg7IGkgPCBfbGVuOyBpKysgKSB7XG4gICAgICAgICAgaWYoIHRoaXMuX2xpc3Rlbk1hcFtpXVswXSA9PT0gdmFsICkge1xuICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdoZXkgaXRzIHRoZSBsaXN0ZW5tYXAhJywgdmFsKVxuICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoIHRoaXMuX2xpc3Rlbk1hcFtpXVsxXSApXG4gICAgICAgICAgICAgcGl2ID0gaVxuICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiggcGl2ICE9PSB2b2lkIDAgKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuTWFwLnNwbGljZShwaXYsIDEpXG4gICAgICAgICAgaWYodGhpcy5fbGlzdGVuTWFwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuTWFwID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfSk7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIFZPYmplY3QgPSByZXF1aXJlKCcuLycpLFxuICBWID0gcmVxdWlyZSgnLi4vJylcbiAgX2MgPSB1dGlsLmNoZWNrQXJyYXlcblxuLyoqXG4gKiBHZXRzL3NldHMgVk9iamVjdCBvcmlnaW5cbiAqIEluIGEgY2hhaW4gb2YgVi5PYmplY3RzIGUuZy4geC52YWwgPSB5LCB5LnZhbCA9IHogLS0tPiB4LmZyb20gcmV0dXJucyB6O1xuICogQG1ldGhvZCBmcm9tXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbnZhciBfY29yZVNldCA9IFZPYmplY3Quc2V0LFxuICBfZnJvbSA9IHRoaXMuZnJvbSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB2YWwgPSBvYmosXG4gICAgICBsYXN0O1xuXG4gICAgd2hpbGUgKHZhbCBpbnN0YW5jZW9mIFZPYmplY3QpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHZhbClcbiAgICAgIGlmKHZhbC5fZmlsdGVyKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0lTIFNFTEVDSVRPTicsIHZhbClcbiAgICAgIH1cbiAgICAgIGxhc3QgPSB2YWw7XG4gICAgICB2YWwgPSB2YWwuX3ZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGxhc3QgIT09IG9iaiA/IGxhc3QgOiBmYWxzZTtcbiAgfSxcbiAgX2xhc3RMRnJvbSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHdoaWxlIChvYmogJiYgb2JqLl9fdCA9PT0gNCkge1xuICAgICAgaWYgKG9iai5fbGZyb20pIHtcbiAgICAgICAgcmV0dXJuIG9iai5fbGZyb207XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBvYmouX3ZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHBhdGhcbiAgICogQG1ldGhvZCBfdXBkYXRlUGF0aFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgIHRpbGwgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgUmV0dXJucyBwYXRoXG4gICAqL1xuICBfdXBkYXRlUGF0aCA9IGZ1bmN0aW9uKHRpbGwsIHN0YXJ0KSB7XG4gICAgdmFyIHBhcmVudCA9IHRoaXMsXG4gICAgICBsZnJvbSxcbiAgICAgIHBhdGggPSBbXTsgLy9yZWR1Y2UgYW1vdW50IG9mIG5ldyBhcnJheXNcbiAgICB3aGlsZSAocGFyZW50ICYmIChwYXJlbnQuX25hbWUgIT09IHZvaWQgMCB8fCBzdGFydCkpIHtcbiAgICAgIGxmcm9tID0gcGFyZW50Ll9sZnJvbSB8fCBfbGFzdExGcm9tKHBhcmVudClcbiAgICAgIGlmIChsZnJvbSkge1xuICAgICAgICB2YXIgYSA9IF91cGRhdGVQYXRoLmNhbGwobGZyb20pLFxuICAgICAgICAgIGMgPSBwYXJlbnQuZnJvbS5fbmFtZTtcbiAgICAgICAgdXRpbC5hZGQoYSwgcGF0aCk7XG4gICAgICAgIHBhdGggPSBhO1xuICAgICAgICBpZiAoYykge1xuICAgICAgICAgIGMgPSBhLmluZGV4T2YoYyk7XG4gICAgICAgICAgYS5zcGxpY2UoYywgYS5sZW5ndGggLSBjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcmVudCAhPT0gdGlsbCkge1xuICAgICAgICBwYXRoLnB1c2gocGFyZW50Ll9uYW1lKTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJy0tLS0tPicscGF0aClcbiAgICByZXR1cm4gdGlsbCA/IHBhdGgucmV2ZXJzZSgpIDogcGF0aDtcbiAgfVxuXG51dGlsLmRlZmluZShWT2JqZWN0LFxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgbGlua2VkIGNvbnRhaW5lcnMsIHVzZXMgc2xpY2Ugb24gYXJyYXlzXG4gICAqIFJlbW92ZXMgYWxsIF9saXN0ZW5lcnNcbiAgICogQG1ldGhvZCBkZXN0cm95XG4gICAqL1xuICAgJ3RvU3RyaW5nJywgZnVuY3Rpb24oIGNvbXByZXNzZWQgKSB7XG4gICAgICByZXR1cm4gY29tcHJlc3NlZCBcbiAgICAgICAgICAgICA/IEpTT04uc3RyaW5naWZ5KCB0aGlzLnJhdyApIFxuICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoIHRoaXMucmF3LCBmYWxzZSwgMiApXG4gICB9LFxuICAgJ3JlZmVyZW5jZUxldmVsJywgZnVuY3Rpb24obGlua2VkKSB7XG4gICAgICB2YXIgbGluayA9IHRoaXNcbiAgICAgIHZhciBjbnQgPSAwXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKGxpbmssIGxpbmsuX190KVxuXG4gICAgICB3aGlsZShsaW5rICYmIGxpbmsuX190KSB7XG4gICAgICAgIGlmKGxpbms9PT1saW5rZWQpIHtcbiAgICAgICAgICByZXR1cm4gY250XG4gICAgICAgIH1cbiAgICAgICAgbGluayA9IGxpbmsuX3ZhbFxuICAgICAgICBjbnQrK1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICB9LFxuICAnZGVzdHJveScsIGZ1bmN0aW9uKG5lc3RlZCwgYmwsIG5vdCwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKSB7XG4gICAgaWYoIXN0YW1wKVxuICAgICAgc3RhbXAgPSB0aGlzLnN0YW1wKClcblxuICAgIHRoaXMuX3JlbW92ZWQgPSB0cnVlXG4gICAgdGhpcy5kZXN0cm95UmVmZXJlbmNlcyhuZXN0ZWQsIGJsLCBub3QsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSlcbiAgICB0aGlzLnJlbW92ZShuZXN0ZWQsIGJsLCBub3QsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSlcbiAgfSxcbiAgJ2Rlc3Ryb3lSZWZlcmVuY2VzJywgZnVuY3Rpb24obmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpIHtcbiAgICBpZighc3RhbXApXG4gICAgICBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuXG4gICAgdmFyIF9sID0gdGhpcy5fbGlzdGVuZXJzXG4gICAgICAsIHBhcmVudFxuICAgICAgLy8gLCBpdGVtXG4gICAgaWYgKF9sKSB7XG4gICAgICBmb3IgKHZhciBpID0gX2wubGVuZ3RoLCByZWY7IHJlZiA9IF9sWy0taV07KSB7XG4gICAgICAgIC8vIGlmKGxpc3RlbmVyIGluc3RhbmNlb2YgQXJyYXkpe1xuICAgICAgICAvLyAgIGlmKGxpc3RlbmVyKVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIHJlZiA9ICBpbnN0YW5jZW9mIEFycmF5ID8gX2xbaV1bMV0gOiBfbFtpXTtcbiAgICAgICAgaWYgKHJlZiBpbnN0YW5jZW9mIFZPYmplY3QpIHtcbiAgICAgICAgICBwYXJlbnQgPSByZWYuX3BhcmVudDtcbiAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5fX3QgPT09IDEpIHtcbiAgICAgICAgICAgIHBhcmVudC5zcGxpY2UocmVmLl9uYW1lLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVmLnJlbW92ZShuZXN0ZWQsIGJsLCBub3QsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUGVyZm9ybXMgcGFzc2VkIGZ1bmN0aW9uIG9uIGVhY2ggaXRlbS5cbiAgICogU2tpcHMgaXRlbXMgaW4gdGhlIGJsYWNrbGlzdC5cbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gIGZuICAgZnVuY3Rpb24gdG8gcGVyZm9ybSBvbiBlYWNoXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgZGVlcCBJZiB0cnVlLCByZXBlYXRzIGVhY2htZXRob2Qgb24gbmVzdGVkIGZpZWxkc1xuICAgKiBAcGFyYW0gIHtBcmd1bWVudHN9IGFyZyAgQXJndW1lbnRzIHRvIHBhc3MgdG8gdGhlIGZ1bmN0aW9uXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnZWFjaCcsIGZ1bmN0aW9uKGZuLCBkZWVwLCBhcmcpIHtcbiAgICAvL3RyeSB0byBtYWtlIHRoaXMgYSBsb3Qgc2hvcnRlclxuICAgIHZhciBpLCBpdGVtO1xuICAgIGlmIChhcmcgIT09IHZvaWQgMCkge1xuICAgICAgYXJnID0gdXRpbC5hcmcoYXJndW1lbnRzLCAyKTtcbiAgICAgIGZvciAoaSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghX2ModGhpcy5fYmxhY2tsaXN0LCBpKSkge1xuICAgICAgICAgIGl0ZW0gPSB0aGlzW2ldO1xuICAgICAgICAgIGlmIChmbi5hcHBseShpdGVtLCBhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRlZXAgJiYgKGl0ZW0uX190ICE9PSA0IHx8IGl0ZW0uX2NvbnRhaW5lZCkpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLmVhY2guYXBwbHkoaXRlbSwgYXJnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKCFfYyh0aGlzLl9ibGFja2xpc3QsIGkpKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgaWYgKGZuLmNhbGwoaXRlbSwgaSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVlcCAmJiAoaXRlbS5fX3QgIT09IDQgfHwgaXRlbS5fY29udGFpbmVkKSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZWFjaChmbiwgZGVlcCwgYXJnKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZWFsIHBhdGhcbiAgICogQGF0dHJpYnV0ZSBfcGF0aFxuICAgKi9cbiAgICAnX3BhdGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gdGhpc1xuICAgICAgICAgICwgcGF0aCA9IFtdXG5cbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQuX25hbWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHBhdGgucHVzaChwYXJlbnQuX25hbWUpO1xuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgJ19jYWNoZWRQYXRoJywge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jYWNoZWRQYXRoIHx8ICh0aGlzLl9fY2FjaGVkUGF0aCA9IHRoaXMuX3BhdGguam9pbignLicpKVxuICAgICAgfVxuICAgIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB1cGRhdGUgcGF0aFxuICAgKiBAYXR0cmlidXRlIHVwZGF0ZVBhdGhcbiAgICovXG4gICd1cGRhdGVQYXRoJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYSA9IF91cGRhdGVQYXRoLmNhbGwodGhpcywgdGhpcywgdHJ1ZSksXG4gICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lO1xuICAgICAgbmFtZSAhPT0gdm9pZCAwICYmIGEudW5zaGlmdChuYW1lKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleXMgb2YgYW4gb2JqZWN0XG4gICAqIEBhdHRyaWJ1dGUga2V5c1xuICAgKi9cbiAgJ2tleXMnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpLCBhcnIgPSBbXTtcbiAgICAgIGZvciAoaSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghX2ModGhpcy5fYmxhY2tsaXN0LCBpKSkge1xuICAgICAgICAgIGFyci5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgQW5jZXN0b3JcbiAgICogYWxzbyByZXR1cm4gdHJ1ZSB3aGVuIG9iamVjdCBpcyBvYmplY3QgdG8gYmUgY29tcGFyZWQgdG9cbiAgICogQGF0dHJpYnV0ZSBrZXlzXG4gICAqL1xuICAvL3QuX2QgPT09IGZyb20uX3BhcmVudCB8fCB0Ll9kID09PSBmcm9tXG4gICdfYW5jZXN0b3InLCBmdW5jdGlvbihvYmopIHtcbiAgICAvLyBjb25zb2xlLmxvZygnQU5DRVNUT1InLnJlZC5pbnZlcnNlLCBvYmosIHRoaXMpXG4gICAgdmFyIHAgPSB0aGlzXG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGlmIChvYmogPT09IHApIHJldHVybiB0cnVlXG4gICAgICBwID0gcC5fcGFyZW50XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogR2V0IGEgZmllbGQgYXQgZmlyc3Qgb2NjdXJlbmNlIGluIHRoZSBwYXJlbnQgY2hhaW5cbiAgICogQG1ldGhvZCBjaGVja1BhcmVudFxuICAgKiBAcGFyYW0gIHtTdHJpbmd9ICBmaWVsZCBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IGdldCAgIFdoZW4gdHJ1ZSByZXR1cm5zIGZvdW5kIGluc3RlYWQgb2YgY3VycmVudFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnY2hlY2tQYXJlbnQnLCB1dGlsLmNoZWNrUGFyZW50RmFjdG9yeSgnX3BhcmVudCcpLFxuICAvKipcbiAgICogUmV0dXJucyBhIG5vcm1hbCBvYmplY3QsIGFuZCBrZWVwcyBsaW5rcyB0byBWLk9iamVjdHNcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0gIHsqfSAgICAgIFt2YWxdIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnY29udmVydCcsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBvYmogPSB7fSwgbCA9IDBcbiAgICBpZiAoIXZhbCB8fCB2YWwudmFsKSBvYmoudmFsID0gdGhpcy5fdmFsXG4gICAgaWYgKHRoaXMuX190ID09PSAxKSB7XG4gICAgICBvYmogPSBbXVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGwrK1xuICAgICAgICBvYmpbaV0gPSB0aGlzW2ldLmNvbnZlcnQoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICBpZiAoIXZhbCB8fCB2YWxbaV0hPT12b2lkIDApIHtcbiAgICAgICAgICBsKytcbiAgICAgICAgICBvYmpbaV0gPSB0aGlzLmNvbnZlcnQoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAodmFsKSB7XG4gICAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgICBpZiAob2JqW2ldID09PSB2b2lkIDApIG9ialtpXSA9IHZvaWQgMFxuICAgICAgICBsKytcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsICYmICghdmFsIHx8IHZhbC52YWwpKSBvYmogPSBvYmoudmFsXG4gICAgcmV0dXJuIG9ialxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBhIG5vcm1hbCBvYmplY3RcbiAgICogQGF0dHJpYnV0ZSByYXdcbiAgICovXG4gICdyYXcnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgdHlwZSA9IHNlbGYuX2ZpbHRlciA/IDIgOiBzZWxmLl9fdCxcbiAgICAgICAgb2JqLCBpLCBsO1xuICAgICAgaWYgKHR5cGUgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYuX3ZhbCAmJiBzZWxmLl92YWwucmF3O1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAzKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnZhbDsgLy93aGVuIHRoZSB0eXBlIGlzIG1peGVkIGFsd2F5cyB1c2VzIHZhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IDEpIHtcbiAgICAgICAgICBvYmogPSBbXTtcbiAgICAgICAgICBmb3IgKGkgPSAtMSwgbCA9IHNlbGYubGVuZ3RoIC0gMTsgaSA8IGw7IHNlbGZbKytpXSAmJiBvYmoucHVzaChzZWxmW2ldLnJhdykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaiA9IHt9O1xuICAgICAgICAgIGZvciAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICBpZiAoIV9jKHNlbGYuX2JsYWNrbGlzdCwgaSkgJiYgc2VsZltpXSkge1xuICAgICAgICAgICAgICBvYmpbaV0gPSBzZWxmW2ldLnJhdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzL3NldHMgb2JqZWN0IG9yaWdpblxuICAgKiBJbiBhIGNoYWluIG9mIFYuT2JqZWN0cyBlLmcuIHgudmFsID0geSwgeS52YWwgPSB6IC0tLT4geC5mcm9tIHJldHVybnMgejtcbiAgICogQGF0dHJpYnV0ZSBmcm9tXG4gICAqL1xuICAnZnJvbScsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIGZvdW5kID0gX2Zyb20odGhpcylcbiAgICAgIF9jb3JlU2V0LmNhbGwoZm91bmQgfHwgdGhpcywgdmFsKVxuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfZnJvbSh0aGlzKSB8fCB0aGlzXG4gICAgfVxuICB9LFxuICAvKipcbiAgICogTWVyZ2UgYW55IG9iamVjdCBpbnRvIGFub3RoZXIgb2JqZWN0XG4gICAqIFNoYWxsb3cgZm9yIGEgc2hhbGxvdyBtZXJnZVxuICAgKiBAbWV0aG9kIG1lcmdlXG4gICAqIEBwYXJhbSAge09iamVjdH0gIG9iaiAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gc2hhbGxvdyAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICBzdGFtcCAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59IG5vdXBkYXRlIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ21lcmdlJywgZnVuY3Rpb24gbWVyZ2UoIG9iaiwgc2hhbGxvdywgc3RhbXAsIG5vdXBkYXRlLCBibG9jaywgc29ydGVkLCBkZWZlclVwZGF0ZXMgKSB7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnTUVSR0UtLS0tPicsIG9iaiApXG5cbiAgICB2YXIgbWVyZ2VBcnJheSA9IHRoaXMuX21lcmdlQXJyYXlcbiAgICAgICwgclxuICAgICAgLCBpXG4gICAgICAsIHN0b3BcbiAgICAgICwgcnRcbiAgICAgICwgY29ialxuICAgICAgLCB0b2JqXG4gICAgICAsIHRvcExldmVsXG5cbiAgICBpZighZGVmZXJVcGRhdGVzKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnTk8gZGVmZXJVcGRhdGVzJy55ZWxsb3cuaW52ZXJzZSlcbiAgICAgIHRvcExldmVsID0gdHJ1ZVxuICAgICAgZGVmZXJVcGRhdGVzID0gW11cbiAgICB9XG4gICAgLy9GSVhNRTogbWFrZSBpdCBiZXR0ZXIgbG9uZyBuYW1lcyBldGMsIGNvZGUgZm9ybWF0dGluZ1xuXG4gICAgaWYgKCAhc3RhbXAgKSBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuXG4gICAgaWYgKCB0aGlzLl9fdCA9PT0gMSApIHtcbiAgICAgIGlmIChtZXJnZUFycmF5KSB7XG4gICAgICAgIG1lcmdlQXJyYXkoIG9iaiwgc3RhbXAsIG5vdXBkYXRlICkgLy9oaWVyIG1vZXQgb29rIGZmIGRlZmVyVXBkYXRlc1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiBvYmopIHtcbiAgICAgICAgICBjb2JqID0gb2JqW2pdXG4gICAgICAgICAgdG9iaiA9IHRoaXNbal1cbiAgICAgICAgICBpZiAoKGogPSBOdW1iZXIoaikpID4gLTEpIHtcbiAgICAgICAgICAgIHIgPSB0cnVlXG4gICAgICAgICAgICBpZiAodG9iaikge1xuICAgICAgICAgICAgICB0b2JqLm1lcmdlKGNvYmosIGZhbHNlLCBzdGFtcCwgdHJ1ZSwgYmxvY2ssIHNvcnRlZCwgZGVmZXJVcGRhdGVzIClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChqID4gdGhpcy5sZW5ndGggLSAxKSB0aGlzLmxlbmd0aCA9IGogKyAxXG4gICAgICAgICAgICAgIHRoaXMuc2V0KGosIGNvYmosIGZhbHNlLCBzdGFtcCwgdHJ1ZSwgdHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpIGluIG9iaikge1xuICAgICAgICBzdG9wID0gdHJ1ZVxuICAgICAgICBjb2JqID0gb2JqW2ldXG4gICAgICAgIHRvYmogPSB0aGlzW2ldXG4gICAgICAgIGlmIChpICE9PSAndmFsJyAmJiAhX2ModGhpcy5fYmxhY2tsaXN0LCBpKSkge1xuICAgICAgICAgIGlmICghc2hhbGxvdyAmJiB0b2JqICYmIHV0aWwuaXNPYmooY29iaikpIHsgLy9jb2JqIGluc3RhbmNlb2YgT2JqZWN0ICYmICh0eXBlb2YgY29iaiAhPT0gJ2Z1bmN0aW9uJykgJiYgY29iai5fX3QgIT09IDMpXG4gICAgICAgICAgICBpZiAoY29iai5jbGVhcikge1xuICAgICAgICAgICAgICBfY29yZVNldC5jYWxsKHRvYmosIGNvYmosIHN0YW1wLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgICAgICAgciA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignLS0tLSBtZXJnZSAvdyB1cGRhdGUgdGhhdHMgbW9zIGRlZiB3cm9uZyEnLCBpLCBkZWZlclVwZGF0ZXMpXG4gICAgICAgICAgICAgIC8vZGVmZXJVcGRhdGVzXG5cbiAgICAgICAgICAgICAgcnQgPSB0b2JqLm1lcmdlKGNvYmosIGZhbHNlLCBzdGFtcCwgdHJ1ZSwgYmxvY2ssIHNvcnRlZCwgZGVmZXJVcGRhdGVzIClcbiAgICAgICAgICAgICAgaWYgKHIgIT09IHRydWUpIHIgPSBydFxuXG4gICAgICAgICAgICAgIGlmICghcnQpIFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJzAwMDAnKVxuICAgICAgICAgICAgICAgIG9ialtpXSA9IHZvaWQgMFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHRvYmogJiYgdG9iai5fdmFsID09PSBjb2JqKSB7IC8vY2hhbmdlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gMCBhbmQgZmFsc2UsIG5vdyBhbHNvIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gMSBhbmQgJzEnXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0gMiB1cGRhdGUgdGhhdHMgbW9zIGRlZiB3cm9uZyEnLCBpKVxuXG4gICAgICAgICAgICAgIGlmIChyICE9PSB0cnVlKSByID0gZmFsc2VcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJz8/Pz8/Pz8nKVxuICAgICAgICAgICAgICBvYmpbaV0gPSB2b2lkIDBcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tIDMgdXBkYXRlIHRoYXRzIG1vcyBkZWYgd3JvbmchJywgaSlcbiAgICAgICAgICAgICAgaWYoY29iaj09PW51bGwgJiYgdGhpc1tpXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbaV0ucmVtb3ZlKCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB2b2lkIDAsIHN0YW1wIClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnIT8nLmJvbGQsIGksIHRoaXNbaV0pXG4gICAgICAgICAgICAgICAgLy9uYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0KCBpLCBjb2JqLCBmYWxzZSwgc3RhbXAsIHRydWUgKVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcheHh4eD8nLCBpKVxuICAgICAgICAgICAgICAgIGlmKHRoaXNbaV0gJiYgdGhpc1tpXS5fbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncHVzaCBwdXNoJy5ncmVlbiwgIEpTT04uc3RyaW5naWZ5KG9iaikgKVxuICAgICAgICAgICAgICAgICAgZGVmZXJVcGRhdGVzLnB1c2goIFt0aGlzW2ldLCBjb2JqXSApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vYWRkIGRpdCBuYWFyIGxpc3RcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXIpIHIgPSBydDtcblxuICAgICAgICAgICAgICAvLyBjb25zb2xlLndhcm4ociwgcnQpXG5cbiAgICAgICAgICAgICAgaWYgKCFydCkgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvL1RPRE86IFRFTVAgRklYIERPTlQgS05PVyBJRiBUSElTIFdPUktTIVxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/Pz8/MjIyMjInKVxuICAgICAgICAgICAgICAgIC8vIG9ialtpXSA9IHZvaWQgMFxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybignY2FudCBiZSByaWdodCEnKVxuICAgICAgICAgICAgICAgIC8vU1VQRVIgQ0FSRUZVTEwgV0lUSCBUSElTIFIgVEhJTkchISEhIVxuICAgICAgICAgICAgICAgIHIgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChvYmoudmFsKSB7XG4gICAgICAgIHJ0ID0gX2NvcmVTZXQuY2FsbCh0aGlzLCBvYmoudmFsLCBzdGFtcCwgZmFsc2UsIHRydWUpXG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgIHIgPSBydFxuICAgICAgICB9XG4gICAgICAgIGlmICghcnQpIHtcbiAgICAgICAgICBvYmoudmFsID0gdm9pZCAwXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIXN0b3ApIHtcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgciA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByID0gKHIgIT09IGZhbHNlKSB8fCByXG4gICAgfVxuXG4gICAgaWYgKHIpIHtcbiAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgLy8gYWxlcnQobm91cGRhdGUpXG4gICAgICAgIGlmIChub3VwZGF0ZSkge1xuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJyEhPz8/Pz8/Pz8/Pz8gTk9VUERBVEUnLmJsdWUsIEpTT04uc3RyaW5naWZ5KG9iaikpXG5cbiAgICAgICAgICBpZih0b3BMZXZlbCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1VQREFURT4/Jy5tYWdlbnRhLmludmVyc2UsIG9iaiwgSlNPTi5zdHJpbmdpZnkoIG9iaiApLCBub3VwZGF0ZSwgc3RhbXApXG4gICAgICAgICAgICB0aGlzLl91cGRhdGUob2JqLCBzdGFtcClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fdXBkYXRlKG9iaiwgc3RhbXApXG4gICAgICAgICAgICBkZWZlclVwZGF0ZXMucHVzaChbIHRoaXMsIG9iaiBdKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnMlVQREFURT4/Jy5jeWFuLmludmVyc2UsIHRvcExldmVsLCBkZWZlclVwZGF0ZXMsIG9iaiwgbm91cGRhdGUsIHN0YW1wKVxuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlKCBvYmosIHN0YW1wIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgIFxuXG4gICAgaWYodG9wTGV2ZWwgJiYgZGVmZXJVcGRhdGVzKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyggJ2RlZmVyZWQgdXBkYWNlJywgdG9wTGV2ZWwsIGRlZmVyVXBkYXRlcylcbiAgICAgIGZvcih2YXIgZGYgaW4gZGVmZXJVcGRhdGVzKSB7XG4gICAgICAgIGlmKCBkZWZlclVwZGF0ZXNbZGZdWzBdICYmIGRlZmVyVXBkYXRlc1tkZl1bMF0uX191cGRhdGUgKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0RFRkVSRUQhISEhJy5jeWFuLmludmVyc2UsIGRmLCBkZWZlclVwZGF0ZXNbZGZdWzFdLCBzdGFtcCApXG4gICAgICAgICAgZGVmZXJVcGRhdGVzW2RmXVswXS5fX3VwZGF0ZSggZGVmZXJVcGRhdGVzW2RmXVsxXSwgc3RhbXAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByXG4gIH0sXG4gIC8qKlxuICAgKiBDb3BpZXMgYW4gb2JqZWN0IGFuZCByZXR1cm5zIGEgbmV3IG9uZSwgY2FuIGFsc28gcGFzcyBhIG1lcmdlIG9iamVjdFxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgICAgIG9iaiAgICAgICBPYmplY3QgdG8gY29weVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICBbc2hhbGxvd10gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtBcnJheXxPYmplY3R9ICBbbGlzdF0gICAgVGFrZXMgYW55IG9iamVjdCB3aXRoIC5sZW5ndGhcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgW3BhcmVudF0gIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdjbG9uZScsIGZ1bmN0aW9uKG9iaiwgc2hhbGxvdywgbGlzdCwgcGFyZW50KSB7IC8vc3VwcG9ydCBzaGFsbG93ITsgY2hlY2sgb2JqIGNvcHkgb25seSB3aGF0IGlzIG5lc3NlY2FyeSBhZGRlZCBtYWtlc2hvcnQgLCBtYWRlIHBhcmVudCBzaG9ydGVyXG4gICAgdmFyIGNvcHkgPSBuZXcgdGhpcy5fY2xhc3MoKSxcbiAgICAgIF92YWwgPSB0aGlzLl92YWwsXG4gICAgICBpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGNvcHkuX3BhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgY29weS5fX3QgPSB0aGlzLl9fdDtcbiAgICBpZiAodGhpcy5fX3QgPT09IDEpIHtcbiAgICAgIGNvcHkubGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChsaXN0KSB7XG4gICAgICAvL2xpc3RcbiAgICAgIGZvciAodmFyIGogPSBsaXN0Lmxlbmd0aCAtIDEsIGl0ZW07IGogPj0gMDsgai0tKSB7XG4gICAgICAgIGl0ZW0gPSBsaXN0W2pdO1xuXG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgQXJyYXkgJiYgdGhpc1tpdGVtWzBdXSkge1xuICAgICAgICAgIGlmKGl0ZW1bMV0gPT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvcHlbaXRlbVswXV0gPSB1dGlsLmNsb25lKHRoaXNbaXRlbVswXV0sIGZhbHNlLCB0cnVlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3B5W2l0ZW1bMF1dID0gaXRlbVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpc1tpdGVtXSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGl0ZW0pXG4gICAgICAgICAgY29weVtpdGVtXSA9IHRoaXNbaXRlbV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKF92YWwgJiYgKF92YWwgaW5zdGFuY2VvZiBWT2JqZWN0ICYmIF92YWwuX2NvbnRhaW5lZCkpIHtcbiAgICAgIGNvcHkudmFsID0gX3ZhbC5jbG9uZShjb3B5LCBmYWxzZSwgbGlzdCwgY29weSk7XG4gICAgICBjb3B5Ll92YWwuX2NvbnRhaW5lZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIFZPYmplY3Quc2V0LmNhbGwoY29weSwgX3ZhbCwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChpIGluIHRoaXMpIHtcbiAgICAgIGlmICghX2ModGhpcy5fYmxhY2tsaXN0LCBpKSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhpKVxuICAgICAgICBpZiAoIXNoYWxsb3cpIHtcbiAgICAgICAgICBpZiAodGhpc1tpXSBpbnN0YW5jZW9mIFZPYmplY3QpIHtcbiAgICAgICAgICAgIC8vZnVuY3Rpb24oIG5hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tIClcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tPjEnLCBpLCB0aGlzW2ldLmNsb25lKHZvaWQgMCwgZmFsc2UsIGxpc3QsIGNvcHkpKVxuICAgICAgICAgICAgLy9zdGFtcCB2b2lkIDBcbiAgICAgICAgICAgIGNvcHkuc2V0KGksIHRoaXNbaV0uY2xvbmUodm9pZCAwLCBmYWxzZSwgbGlzdCwgY29weSksIHRydWUsIGZhbHNlLCB0cnVlKVxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLT4yJywgaSwgdXRpbC5jbG9uZSh0aGlzW2ldKSlcblxuICAgICAgICAgICAgY29weVtpXSA9IHV0aWwuY2xvbmUodGhpc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vZnVuY3Rpb24oIG5hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tIClcbiAgICAgICAgICBjb3B5LnNldChpLCB0aGlzW2ldLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvYmogIT09IHZvaWQgMCkge1xuICAgICAgaWYgKHV0aWwuaXNPYmoob2JqKSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnTUVSR0UtLS0tLT4nLCBvYmosIHNoYWxsb3cpXG4gICAgICAgIGNvcHkubWVyZ2Uob2JqLCBzaGFsbG93KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFZPYmplY3Quc2V0LmNhbGwoY29weSwgb2JqLCBmYWxzZSwgZmFsc2UsIHRydWUpXG4gICAgICB9XG4gICAgfVxuICAgIGNvcHkuX190ID0gdGhpcy5fX3Q7XG4gICAgcmV0dXJuIGNvcHk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIG9iamVjdCBvbiB0aGUgZW5kIG9mIGEgZGVmaW5lZCBwYXRoXG4gICAqIEBtZXRob2QgcGF0aFxuICAgKiBAcGFyYW0gIHtBcnJheX0gICAgIHBhdGggICAgICAgICAgIEFycmF5IG9mIGZpZWxkcyBpbiBwYXRoXG4gICAqIEBwYXJhbSAgeyp9ICAgICAgICAgW3ZhbF0gICAgICAgICAgV2hlbiBkZWZpbmVkLCB2YWwgd2lsbCBiZSBzZXQgb24gZW5kcG9pbnQgb2YgcGF0aCBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgW292ZXJ3cml0ZV0gICAgSWYgdHJ1ZSwgdmFsIFdJTEwgb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlIG9uIGVuZHBvaW50IG9mIHBhdGggd2hlbiBhbHJlYWR5IGRlZmluZWRcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICBbd3JpdGVIYW5kbGVyXSBDYWxsYmFjayBvbiB3cml0ZVxuICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdCBvbiB0aGUgZW5kIG9mIGEgZGVmaW5lZCBwYXRoXG4gICAqL1xuICAncGF0aCcsIGZ1bmN0aW9uKHBhdGgsIHZhbCwgb3ZlcndyaXRlLCB3cml0ZUhhbmRsZXIsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgc2VsZikge1xuICAgIGlmKCEocGF0aCBpbnN0YW5jZW9mIEFycmF5KSkgcGF0aCA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICByZXR1cm4gdXRpbC5wYXRoKHRoaXMsIHBhdGgsIHZhbCwgb3ZlcndyaXRlLCB3cml0ZUhhbmRsZXIsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgc2VsZik7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXRzIG9iamVjdCBmcm9tIHNwZWNpZmllZCBwYXRoLiBXaGVuIHBhdGggaXMgYSBzdHJpbmcgY2hlY2tzIGZvciAnZG90bm90YXRpb24nLlxuICAgKiBAbWV0aG9kIGdldFxuICAgKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IHBhdGggRGVmaW5lcyBmaWVsZCB7c3RyaW5nfSBvciBwYXRoIHthcnJheXwnZG90LW5vdGF0aW9uJ31cbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgIG9ialtwYXRoXXxuZXN0ZWQgb2JqZWN0L3ZhbHVlXG4gICAqL1xuICAnZ2V0JywgZnVuY3Rpb24ocGF0aCwgc2VsZikgeyAvL2dldCBkb2VzIG5vdCBuZWVkIGFuIGFycmF5IGFzIHBhdGhcbiAgICByZXR1cm4gdXRpbC5nZXQodGhpcywgcGF0aCwgc2VsZik7XG4gIH0sXG5cbiAgLy8odmFsLCBzdGFtcCwgZnJvbSwgbm91cGRhdGUsIGFkZClcbiAgLy8gJyRzZXQnLCBmdW5jdGlvbiggdmFsLCBzdGFtcCwgZnJvbSwgdXBkYXRlICkgeyAvL2dldCBkb2VzIG5vdCBuZWVkIGFuIGFycmF5IGFzIHBhdGhcblxuICAvLyAgIHJldHVybiBWT2JqZWN0LnNldC5jYWxsKCB0aGlzLCB2YWwsIHN0YW1wLCBmcm9tLCAhdXBkYXRlIClcbiAgICBcbiAgLy8gICAgICdfc2V0JywgZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBub3VwZGF0ZSwgYWRkZWQsIG9sZHZhbCkge1xuICAvLyAgIGlmICghbm91cGRhdGUpIHtcbiAgLy8gICAgICh2YWwsIHN0YW1wLCBmcm9tLCBub3VwZGF0ZSwgYWRkKVxuICAvLyAgICAgLy8gY29uc29sZS5sb2codGhpcy5fcGF0aCwgdmFsKVxuICAvLyAgICAgdGhpcy5fdXBkYXRlKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCk7XG4gIC8vICAgfVxuICAgIFxuXG4gIC8vIH0sXG4gIC8qKlxuICAgKiBDaGVjayBpZiBvYmogaXMgZW1wdHkgZXhjbHVkZSBmaWVsZCBuYW1lcyBwYXNzZWQgdG8gbGlzdFxuICAgKiBAbWV0aG9kIGVtcHR5XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IFRydWUvZmFsc2VcbiAgICovXG4gICdlbXB0eScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHV0aWwuZW1wdHkodGhpcywgdGhpcy5fYmxhY2tsaXN0KTtcbiAgICB9XG4gIH0sXG4gICckZW1wdHknLCBmdW5jdGlvbiggZXhjbHVkZXMsIHVwZGF0ZSApIHtcbiAgICAgIC8vZ2V0IGRvZXMgbm90IG5lZWQgYW4gYXJyYXkgYXMgcGF0aFxuICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgdGhpcy5lYWNoKCBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICBpZiggXG4gICAgICAgICAgICAhZXhjbHVkZXMgXG4gICAgICAgICAgICAgIHx8IHR5cGVvZiBleGNsdWRlcyA9PT0gJ3N0cmluZycgIFxuICAgICAgICAgICAgICAgICA/IGtleSAhPT0gZXhjbHVkZXMgXG4gICAgICAgICAgICAgICAgIDogIXV0aWwuY2hlY2tBcnJheSggZXhjbHVkZXMsIGtleSApIFxuICAgICAgICAgIClcbiAgICAgICAge1xuICAgICAgICAgIGlmKCB0aGlzLnJlbW92ZSApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUgKVxuICAgICAgICAgIH0gXG4gICAgICAgICAgZWxzZSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLndhcm4oICckZW1wdHkgbm9uLXZPYmplY3Qgb2JqZWN0LnV0aWwgcmVtb3ZlJywgdGhpcywga2V5IClcbiAgICAgICAgICAgIF90aGlzW2tleV0gPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIFxuICAgICAgaWYoIHRoaXMuY2xlYXJDYWNoZSApIHRoaXMuY2xlYXJDYWNoZSgpXG5cbiAgICAgIGlmKCB1cGRhdGUgKVxuICAgICAge1xuICAgICAgICB0aGlzLl91cGRhdGUoJ2VtcHR5JylcbiAgICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFYuT2JqZWN0IGZyb20gd2hpY2ggdGhlIGN1cnJlbnQgdXBkYXRlIG9yaWdpbmF0ZWQuXG4gICAqIEBtZXRob2QgX3VwZGF0ZU9yaWdpblxuICAgKiBAcmV0dXJuIHtWLk9iamVjdH0gb3JpZ2luIG9mIHRoZSB1cGRhdGVcbiAgICovXG4gICdfdXBkYXRlT3JpZ2luJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFyayA9IHRoaXM7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdnZXQgVVBEQVRFIE9SSUdJTicsIHRoaXMuX3BhdGgsIHRoaXMuX2xmcm9tKVxuICAgICAgd2hpbGUgKG1hcmsuX2xmcm9tKSB7XG5cbiAgICAgICAgLy9pZiBWLkNsb3VkRGF0YVxuICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoICdfdXBkYXRlIHRoYXQgb3JpZ2luIScsIG1hcmsuX3BhdGggKVxuICAgICAgICBtYXJrID0gbWFyay5fbGZyb207XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFyaztcbiAgICB9XG4gIH0sXG4gICdfb3JpZ2luJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFyayA9IHRoaXM7XG4gICAgICB3aGlsZSAobWFyayAmJiBtYXJrLl9fdCA9PT0gNCkge1xuICAgICAgICBtYXJrID0gbWFyay5fdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcms7XG4gICAgfVxuICB9XG4pXG5cblxuLy9hZGQgZmluZFxuXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLycpXG4gICwgYWpheFxuICAsIFBBQ0tBR0UgPSAnL3BhY2thZ2UuanNvbidcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24oIGNhbGxiYWNrLCBwYXJhbXMsIHBhY2thZ2VGaWxlLCBub1JlcGxhY2UgKSB7XG5cbiAgcGFja2FnZUZpbGUgPSBwYWNrYWdlRmlsZSB8fCAoIHV0aWwuaXNOb2RlID8ge30gOiB3aW5kb3cucGFja2FnZSApXG5cbiAgdmFyIG9iaiA9IHt9XG4gICAgLCByZXEgPSBtb2R1bGUuZXhwb3J0c1xuICAgICwgY2IgPSBjYWxsYmFjayAmJiBmdW5jdGlvbiggcGNrZyApIHtcblxuICAgICAgb2JqID0gcGNrZy52aWdvdXJcbiAgICAgIHJlcS5wYXJzZSggb2JqLCBwYWNrYWdlRmlsZSwgcmVxLl9jaGVja3MgKVxuXG4gICAgICBpZighbm9SZXBsYWNlKSBtb2R1bGUuZXhwb3J0cyA9IG9ialxuICAgICAgY2FsbGJhY2sob2JqKVxuICAgIH1cblxuICAvL2RlZmF1bHQgb3B0aW9uIGFkZCBtb3JlIVxuICBpZighcGFyYW1zKSB7XG4gICAgZXhwb3J0cy5vcHRpb25zLnZhbChvYmosIGNiLCBmYWxzZSwgcGFja2FnZUZpbGUgKVxuICB9IGVsc2UgaWYoZXhwb3J0cy5vcHRpb25zW3BhcmFtc10pIHtcbiAgICBleHBvcnRzLm9wdGlvbnNbcGFyYW1zXShvYmosIGNiLCBmYWxzZSwgcGFja2FnZUZpbGUgKVxuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMub3B0aW9ucy52YWwob2JqLCBjYiwgcGFyYW1zLCBwYWNrYWdlRmlsZSApXG4gIH1cbiAgcmV0dXJuIG9ialxufVxuXG5pZih1dGlsLmlzTm9kZSkge1xuICBleHBvcnRzLm9wdGlvbnMgPSB7XG4gICAgdmFsOmZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrLCBwYXJhbXMsIHBja2cgKSB7XG4gICAgICBjYWxsYmFjayggcGNrZyApXG4gICAgfVxuICB9XG59IGVsc2Uge1xuICBhamF4ID0gcmVxdWlyZSggJy4uLy4uL2Jyb3dzZXIvbmV0d29yay9hamF4JyApXG4gIGV4cG9ydHMub3B0aW9ucyA9IHtcbiAgICB2YWw6ZnVuY3Rpb24ob2JqLCBjYWxsYmFjaywgcGFyYW1zKSB7XG4gICAgICBpZiggIXdpbmRvdy5wYWNrYWdlICkge1xuICAgICAgICB2YXIgZG9tYWluID0gIXdpbmRvdy5jb3Jkb3ZhICYmIFN0cmluZyh3aW5kb3cubG9jYXRpb24pXG4gICAgICAgICAgICAubWF0Y2goL2h0dHBzPzpcXC9cXC8oW15cXC9dKykvKVxuXG4gICAgICAgIGlmKGRvbWFpbikgZG9tYWluID0gZG9tYWluWzBdXG4gICAgICAgICBcbiAgICAgICAgYWpheCh7XG4gICAgICAgICAgdXJsOnBhcmFtcyAmJiBwYXJhbXMudXJsID8gcGFyYW1zLnVybCA6IGRvbWFpbitQQUNLQUdFLFxuICAgICAgICAgIGZhbGxiYWNrOiBbXG4gICAgICAgICAgICAgIHsgdXJsOiBQQUNLQUdFIH0gLy9mb3IgdGVzdGluZ1xuICAgICAgICAgICAgLCBwYXJhbXMgJiYgcGFyYW1zLmZhbGxiYWNrID8gcGFyYW1zLmZhbGxiYWNrIDogeyB1cmw6IF9fZGlybmFtZStQQUNLQUdFIH1cbiAgICAgICAgICAgICwgeyB1cmw6ICcuLi8nK1BBQ0tBR0UgfVxuICAgICAgICAgICAgLCB7IHVybDogJy4uLy4uLycrUEFDS0FHRSB9XG4gICAgICAgICAgICAsIHsgdXJsOiAnLi4vLi4vLi4vJytQQUNLQUdFIH1cbiAgICAgICAgICBdLFxuICAgICAgICAgIGNvbXBsZXRlOmZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5wYWNrYWdlID0gZGF0YVxuICAgICAgICAgICAgaWYoY2FsbGJhY2spIGNhbGxiYWNrKGRhdGEpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKHdpbmRvdy5wYWNrYWdlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmluamVjdCA9IGZ1bmN0aW9uKCkge1xuICBleHBvcnRzLl9jaGVja3MgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gIHJldHVybiBleHBvcnRzXG59XG5cbmV4cG9ydHMubG9vcCA9IGZ1bmN0aW9uKG9iaiwgb3B0aW9uLCBwY2tndmFsLCBtZXJnZSwgZm4sIHBhcmFtcyApIHtcbiAgaWYoZm4pIHtcbiAgICB2YXIgdmFsID0gb3B0aW9uKG9iaixwY2tndmFsLG1lcmdlLCBwYXJhbXMpXG4gICAgaWYodmFsKSB7IHV0aWwubWVyZ2Uob2JqLHZhbCkgfVxuICB9IGVsc2Uge1xuICAgIGZvcih2YXIgaCBpbiBvYmpbb3B0aW9uXSkge1xuICAgICAgaWYoKHBja2d2YWw9PT1oKSkge1xuICAgICAgICB1dGlsLm1lcmdlKG9iaixtZXJnZVtoXSlcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKCBvYmosIHBja2csIG9wdGlvbnMsIHBhcmFtcyApIHtcbiBpZighKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICBvcHRpb25zID0gW29wdGlvbnNdXG4gfVxuXG4gZm9yKHZhciBpIGluIG9wdGlvbnMpIHtcbiAgICBmb3IodmFyIGNoZWNrIGluIG9wdGlvbnNbaV0pIHtcbiAgICAgIHZhciBwY2tndmFsID0gdXRpbC5nZXQocGNrZyxjaGVjaylcbiAgICAgICAgLCBvcHRpb24gPSBvcHRpb25zW2ldW2NoZWNrXVxuXG4gICAgICBleHBvcnRzLmxvb3Aob2JqLCBvcHRpb24sIHBja2d2YWwsIG9ialtvcHRpb25zW2ldW2NoZWNrXV0sIHR5cGVvZiBvcHRpb24gPT09ICdmdW5jdGlvbicscGFyYW1zKVxuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqXG59XG4iLCJ2YXIgdWEgPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL3VhJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vJylcbiAgLCBEYXRhID0gcmVxdWlyZSgnLi4vLi4vZGF0YScpLmluamVjdChyZXF1aXJlKCcuLi8uLi9kYXRhL3NlbGVjdGlvbicpKVxuLypcbnNlbGVjdGlvbiFcblxuKi9cbmJsYSA9IGV4cG9ydHNcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uKG9iaiwgcGNrZ3ZhbCwgbWVyZ2UsIHBhcmFtcykge1xuICB2YXIgX3VhID0gdWFcblxuICBpZihwYXJhbXMgJiYgcGFyYW1zLnVhKSB7XG4gICAgX3VhID0gdWEucGFyc2UocGFyYW1zLnVhLnRvTG93ZXJDYXNlKCkse30pXG4gIH1cblxuICAvLyBjb25zb2xlLmxvZygnSEVSRSEnLG9iaixwY2tndmFsLG1lcmdlKVxuICB2YXIgY29uZFxuICAgICwgdWFjbG9uZSA9IG5ldyBEYXRhKHtibGE6dXRpbC5jbG9uZShfdWEpfSlcblxuICBpZihvYmoudWEpIHtcbiAgICBmb3IodmFyIGkgaW4gb2JqLnVhKSB7XG4gICAgICBpZihfdWEucGxhdGZvcm09PT1pfHxfdWEuZGV2aWNlPT09aXx8X3VhLmJyb3dzZXI9PT1pKSB7XG4gICAgICAgIHJldHVybiBvYmoudWFbaV1cbiAgICAgIH0gZWxzZSBpZihvYmoudWFbaV0uY29uZGl0aW9uKSB7XG4gICAgICAgIGlmKCFjb25kKSB7XG4gICAgICAgICAgY29uZCA9IG5ldyBEYXRhKHVhY2xvbmUsIG9iai51YVtpXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25kLmZpbHRlciA9IG9iai51YVtpXVxuICAgICAgICB9XG4gICAgICAgIGlmKGNvbmQubGVuZ3RoKSB7XG4gICAgICAgICAgZGVsZXRlIG9iai51YVtpXS5jb25kaXRpb25cbiAgICAgICAgICBjb25kLnJlbW92ZSgpXG4gICAgICAgICAgcmV0dXJuIG9iai51YVtpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cblxuICAvL2JsYWJsYVxuXG4gIC8vIGNvbnNvbGUubG9nKCdTVUJPQko/Pz8nLG9iailcblxuXG4gIGRlbGV0ZSBvYmouc3Vic09ialxuXG4gIGlmKGNvbmQpIGNvbmQucmVtb3ZlKClcbn1cblxuIiwidmFyIGRlYnVnID0gZXhwb3J0c1xuXG5ERUJVRyQgPSBkZWJ1Z1xuXG4vKlxuICBjb25zb2xlLmxvZygndXRpbC90ZXN0IFxcblxcbmlmIHlvdSB3YW50IHRvIGNoZWNrIG1lbW9yeSB1c2FnZSBzdGFydCBjaHJvbWUgdXNpbmc6IFxcblxcbiBvcGVuIC1hIEdvb2dsZVxcXFwgQ2hyb21lIC0tYXJncyAtLWVuYWJsZS1tZW1vcnktaW5mbyBcXG4nKVxuKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vJylcbiAgLCBpc05vZGUgPSB1dGlsLmlzTm9kZSAvL2hhcyB0byBiZWNvbWUgcGFydCBvZiB1dGlsXG4gICwgViA9IHJlcXVpcmUoJy4uLy4uLycpXG4gICwgbG9nID0gZGVidWcubG9nID0gcmVxdWlyZSgnLi9sb2cnKVxuICAsIGRlYnVnbG9nID0gbG9nLmxvZ2dlcignREVCVUckJywgJ3JhaW5ib3cnKVxuXG5kZWJ1Zy5wZXJmID0gZGVidWcucGVyZm9ybWFuY2UgPSByZXF1aXJlKCcuL3BlcmZvcm1hbmNlJylcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuaWYoIWlzTm9kZSkge1xuICBkZWJ1Zy5jYXNlcyA9IHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvY2FzZXMvJylcbiAgZXhwb3J0cy5ib2R5ID0gZG9jdW1lbnQuYm9keS5iYXNlXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgJ2RvbWFpbicsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy9kZWJ1Z2dlciAtLS0gY2FuIGdvIGF3YXkgd2l0aCBhIHRyYW5zZm9ybVxuICAgICAgcmV0dXJuIFN0cmluZyh3aW5kb3cubG9jYXRpb24pXG4gICAgICAgIC5tYXRjaCgvaHR0cHM/OlxcL1xcLyhbXlxcL10rKS8pWzFdXG4gICAgICAgIC5yZXBsYWNlKC86LisvLCAnJylcbiAgICB9XG4gIH0pXG5cbn0gZWxzZSB7XG4gIHZhciBERUJVRyA9IHByb2Nlc3MuZW52LkRFQlVHXG4gIGlmKERFQlVHKXtcbiAgICB2YXIgbGV2ZWxzID0gREVCVUcuc3BsaXQoJywnKVxuICAgIGZvcih2YXIgbCBpbiBsZXZlbHMpe1xuICAgICAgdmFyIHR3byA9IGxldmVsc1tsXS5zcGxpdCgnOicpXG4gICAgICBERUJVRyQubGV2ZWxbdHdvWzBdXSA9IHR3b1sxXSA/IE51bWJlcih0d29bMV0pIDogM1xuICAgIH1cbiAgfVxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5leHBvcnRzLmludCA9IGZ1bmN0aW9uKHJhbmQsIGZuKSB7XG4gIGZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgcmFuZCA9IHJhbmR8fDEwMDBcbiAgICByZXR1cm4gfn4oTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKnJhbmQpKVxuICB9XG4gIHJldHVybiBmbiA/IGZ1bmMoKSA6IGZ1bmNcbn1cblxuZXhwb3J0cy50ZXh0ID0gZnVuY3Rpb24gKGxlbmd0aCwgZm4sIHN0ciwgbm9saW5lcywgc3RyaWN0KSB7XG4gIGlmIChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLnRleHQoXG4gICAgICAgIE1hdGgucm91bmQoTWF0aC5yYW5kb20oKSAqIGxlbmd0aCkgKyAxLCBmYWxzZSwgc3RyLCBub2xpbmVzLCBzdHJpY3RcbiAgICAgIClcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIHMgPSBbJy4nLCAnLicsICcuJywgJzsnLCAnLCddXG4gICAgICAsIGIgPSBbJ2FiJywgJ2FibGUnLCAnem8nLCAneCcsICdsYXgnLCAnYnVyJywgJ3JlbScsICdsdXInLCAnZnVyJywgJ2p1cicsICdsZXgnLCAncmV4JywgJ3d1cmQnLFxuICAgICAgICAnc2h1cicsICdidXJuJywgJ2hlcHMnLCAnYScsICdpJywgJ3knLCAndScsICdlJywgJ3AnLCAnbCcsICdzcGx1cmYnXVxuICAgICAgLCBvdXRwdXQgPSAnJ1xuICAgICAgLCBub3NwYWNlID0gMFxuXG4gICAgaWYgKHN0cikgYiA9IHN0clxuXG4gICAgc3RyID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGJbTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogKGIubGVuZ3RoIC0gMSkpXVxuICAgIH1cbiAgICBpZiAoIWxlbmd0aCkgbGVuZ3RoID0gfn4gKE1hdGgucmFuZG9tKCkgKiAxMDEpXG4gICAgZm9yICh2YXIgaSA9IDAsIGc7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCAhc3RyaWN0ICYmICghb3V0cHV0W291dHB1dC5sZW5ndGggLSAxXVxuICAgICAgICB8fCBvdXRwdXRbb3V0cHV0Lmxlbmd0aCAtIDJdID09PSAnLidcbiAgICAgICAgfHwgb3V0cHV0W291dHB1dC5sZW5ndGggLSAyXSA9PT0gJ1xcbicpXG4gICAgICApIHtcbiAgICAgICAgZyA9IHN0cigpXG4gICAgICAgIG91dHB1dCArPSBnWzBdLnRvVXBwZXJDYXNlKCkgKyBnLnNsaWNlKDEpXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb3V0cHV0ICs9IHN0cigpXG4gICAgICB9XG4gICAgICBub3NwYWNlKytcbiAgICAgIGlmICghc3RyaWN0ICYmIH5+KE1hdGgucmFuZG9tKCkgKiAobm9zcGFjZSAvIDIpKSkge1xuICAgICAgICB2YXIgYnIgPSBmYWxzZVxuICAgICAgICAgICwgdlxuICAgICAgICBpZiAoIW5vbGluZXMgJiYgfn4oTWF0aC5yYW5kb20oKSAqIDIxKSA+IDE3KSB7XG4gICAgICAgICAgdiA9IHNbfn4oTWF0aC5yYW5kb20oKSAqIChzLmxlbmd0aCAtIDEpKV1cbiAgICAgICAgICBvdXRwdXQgKz0gdlxuICAgICAgICAgIGlmICh2ID09PSAnLicgJiYgfn4oTWF0aC5yYW5kb20oKSAqIDExKSA+IDYpIHtcbiAgICAgICAgICAgIGJyID0gdHJ1ZVxuICAgICAgICAgICAgb3V0cHV0ICs9ICdcXG4nXG4gICAgICAgICAgICBpZiAofn4oTWF0aC5yYW5kb20oKSAqIDExKSA+IDcpIG91dHB1dCArPSAnXFxuJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFicikgb3V0cHV0ICs9ICcgJ1xuICAgICAgICBub3NwYWNlID0gMFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cbn1cblxuZXhwb3J0cy5kYXRhID0gZnVuY3Rpb24gKHBvcHVsYXRlLCBsZXZlbCwgb2JqLCBjbnQsIHByZXYpIHtcbiAgaWYgKCFvYmopIG9iaiA9IHt9XG4gIGlmICghY250KSBjbnQgPSAwXG4gIGlmICghbGV2ZWwpIGxldmVsID0gMFxuICBmb3IgKHZhciBpIGluIHBvcHVsYXRlKSB7XG4gICAgaWYgKChwb3B1bGF0ZVtpXSBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgICYmIHBvcHVsYXRlW2ldLmxlbmd0aCAmJiBwb3B1bGF0ZVtpXS52YWxcbiAgICApIHtcbiAgICAgIGlmIChwb3B1bGF0ZSAmJiBwb3B1bGF0ZVtpXSkge1xuICAgICAgICBvYmpbaV0gPSBbXVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvcHVsYXRlW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgb2JqW2ldW2pdID0gdHlwZW9mIHBvcHVsYXRlW2ldLnZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBwb3B1bGF0ZVtpXS52YWwoKVxuICAgICAgICAgICAgOiBleHBvcnRzLmRhdGEocG9wdWxhdGVbaV0udmFsLCAobGV2ZWwgKyAxKSwgZmFsc2UsIGogKyAxLCBvYmopXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoKHBvcHVsYXRlW2ldIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgJiYgKHR5cGVvZiBwb3B1bGF0ZVtpXSAhPT0gJ2Z1bmN0aW9uJylcbiAgICApIHtcbiAgICAgIG9ialtpXSA9IGV4cG9ydHMuZGF0YShwb3B1bGF0ZVtpXSwgKGxldmVsICsgMSksIG9ialtpXSwgZmFsc2UsIGNudCwgb2JqKVxuICAgIH1cbiAgICBlbHNlIGlmIChwb3B1bGF0ZSAmJiBwb3B1bGF0ZVtpXSkge1xuICAgICAgb2JqW2ldID0gKHR5cGVvZiBwb3B1bGF0ZVtpXSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gcG9wdWxhdGVbaV0uY2FsbChvYmosIGNudCwgcHJldilcbiAgICAgIDogcG9wdWxhdGVbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZGVidWcuZG93bmxvYWQgPSBmdW5jdGlvbihmaWxlbmFtZSwgdGV4dCkge1xuICB2YXIgcG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBwb20uc2V0QXR0cmlidXRlKCdocmVmJywgJ2RhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PXV0Zi04LCcgKyBlbmNvZGVVUklDb21wb25lbnQodGV4dCkpO1xuICBwb20uc2V0QXR0cmlidXRlKCdkb3dubG9hZCcsIGZpbGVuYW1lKTtcbiAgcG9tLmNsaWNrKCk7XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kZWJ1Zy5yZW1vdGUgPSBmdW5jdGlvbihpZCkge1xuICB2YXIgZmlsZXJlZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpXG4gIGZpbGVyZWYuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvamF2YXNjcmlwdFwiKVxuICBmaWxlcmVmLnNldEF0dHJpYnV0ZShcInNyY1wiLCAnaHR0cDovL2pzY29uc29sZS5jb20vcmVtb3RlLmpzPycraWQpXG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChmaWxlcmVmKVxufVxuXG5kZWJ1Zy5maW5kU2NyaXB0ID0gZnVuY3Rpb24obm9kZSxuYW1lLHN0cmljdCkge1xuXG4gIHZhciBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2Rlc1xuICAgICwgZXh0ZW5zaW9uID0gbmFtZS5tYXRjaCgvXFwuKFthLXpBLVowLTldezEsMzB9KSQvKVsxXVxuICAgICwgcmVnRXhwID0gIXN0cmljdCAmJiBuZXcgUmVnRXhwKG5hbWUrJyQnKVxuICAgICwgZmllbGQgPSBleHRlbnNpb24gPT09ICdqcycgPyAnc3JjJyA6ICdocmVmJ1xuXG4gIGZvcih2YXIgaSBpbiBjaGlsZHJlbikge1xuXG4gICAgaWYoc3RyaWN0ID8gY2hpbGRyZW5baV1bZmllbGRdPT09bmFtZSA6IHJlZ0V4cC50ZXN0KGNoaWxkcmVuW2ldW2ZpZWxkXSkpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbltpXVxuICAgIH1cblxuICB9XG5cbiAgLy8gY29uc29sZS5sb2coJ25vdGZvdW5kJywgbmFtZSlcbn1cblxuZnVuY3Rpb24gcHJvbXB0eSAobXNnLCB2YWx1ZSwgY2IpIHtcbiAgICB2YXIgZGlhbG9nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgICAgICAsIHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwicFwiKVxuICAgICAgICAsIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpXG4gICAgICAgICwgb2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpXG4gICAgICAgICwgY2FuY2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKVxuICAgIHAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobXNnKSlcbiAgICBpbnB1dC50eXBlID0gXCJ0ZXh0XCJcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlXG4gICAgaW5wdXQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIlxuICAgIG9rLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiT0tcIikpXG4gICAgY2FuY2VsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQ2FuY2VsXCIpKVxuICAgIG9rLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBoaWRlRGlhbG9nKClcbiAgICAgICAgY2IoaW5wdXQudmFsdWUpXG4gICAgfSlcbiAgICBjYW5jZWwuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGVEaWFsb2coKVxuICAgICAgICBjYihudWxsKVxuICAgIH0pXG4gICAgZGlhbG9nLmFwcGVuZENoaWxkKHApXG4gICAgZGlhbG9nLmFwcGVuZENoaWxkKGlucHV0KVxuICAgIGRpYWxvZy5hcHBlbmRDaGlsZChvaylcbiAgICBkaWFsb2cuYXBwZW5kQ2hpbGQoY2FuY2VsKVxuICAgIGRpYWxvZy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIlxuICAgIGRpYWxvZy5zdHlsZS50b3AgPSAyNSArIFwicHhcIlxuICAgIGRpYWxvZy5zdHlsZS5sZWZ0ID0gNTAgKyBcInB4XCJcbiAgICBkaWFsb2cuc3R5bGUuekluZGV4ID0gMTAwMFxuICAgIGRpYWxvZy5zdHlsZS5mb250U2l6ZSA9ICAyNCArICdweCdcbiAgICBkaWFsb2cuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gXCJ3aGl0ZVwiXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaWFsb2cpXG4gICAgZnVuY3Rpb24gaGlkZURpYWxvZygpIHtcbiAgICAgICAgZGlhbG9nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZGlhbG9nKVxuICAgIH1cbn1cblxuZGVidWcubmF0aXZlID0gZnVuY3Rpb24oZGVmLCBwYXJzZSwgY2IsIGZpbGUpIHtcbiAgaWYoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXYnKSkge1xuICAgIHZhciBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBlbGVtLmlkID0gJ2RldidcbiAgICBlbGVtLnN0eWxlLnpJbmRleCA9IDk5OTk5OTlcbiAgICBlbGVtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJ1xuICAgIGVsZW0uc3R5bGUubGVmdCA9ICcycHgnXG4gICAgZWxlbS5zdHlsZS50b3AgPSAnODBweCdcbiAgICBlbGVtLnN0eWxlLnBhZGRpbmcgPSAnMTVweCdcbiAgICBlbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDUwLDUwLDUwLDAuOCknXG4gICAgZWxlbS5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNTAlJ1xuICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKCkge1xuICAgICAgcHJvbXB0eSgnSVAnLCBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGV2aXAnKSB8fCBkZWYgfHwgJ2h0dHA6Ly8xMC4wLjEuMjo4MDgwJywgZnVuY3Rpb24gKGlwKSB7XG4gICAgICAgIGlmIChpcCkge1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCdkZXZpcCcsaXApXG4gICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGFsZXJ0KCd4JylcbiAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnZGV2aXAnKVxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtKVxuICB9XG5cbiAgaWYoIWZpbGUpIHtcbiAgICBmaWxlID0gJ2J1aWxkJ1xuICB9XG5cbiAgaWYoIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkZXZpcCcpICkge1xuICAgIERFQlVHJC5yZW1vdGVSZXNvdXJjZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGV2aXAnKSsnL2J1bmRsZS5jc3MnLGZpbGUrJy5jc3MnLGZhbHNlKVxuICAgIGlmKERFQlVHJC5yZW1vdGVSZXNvdXJjZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGV2aXAnKSsnL2J1bmRsZS5qcycsZmlsZSsnLmpzJyxmYWxzZSkpIHtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXYnKS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDI1NSwwLDAuOCknXG4gICAgICBpZihjYikgY2IobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2RldmlwJykpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gXG4gIH1cbn1cblxuLy9oaWVyIHJlbW90ZXJlc291cmNlIGdlYnJ1aWtlblxuZGVidWcucmVtb3RlUmVzb3VyY2UgPSBmdW5jdGlvbihzcmMsIHJlcGxhY2UsIHN0cmljdCkge1xuICBjb25zb2xlLmxvZygncmVtb3RlIHJlc291cmNlJyxzcmMpXG4gIHZhciBzdHJpY3QgPSBzdHJpY3QgIT09IHZvaWQgMCA/IHN0cmljdCA6IHRydWVcbiAgICAsIGV4dGVuc2lvbiA9IHNyYy5tYXRjaCgvXFwuKFthLXpBLVowLTldezEsMzB9KSQvKVsxXVxuICAgICwgZmlsZXJlZiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZXh0ZW5zaW9uPT09J2pzJyA/ICdzY3JpcHQnIDogJ2xpbmsnKVxuICAgICwgaGVhZCA9ICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF1cbiAgICAsIGJvZHkgPSBkb2N1bWVudC5ib2R5XG4gICAgLCBmb3VuZFxuICAgICwgZmlsZVNyY1xuXG4gIGlmKCFyZXBsYWNlKSB7XG4gICAgc3RyaWN0ID0gZmFsc2VcbiAgICByZXBsYWNlID0gc3JjLm1hdGNoKGV4dGVuc2lvbj09PSdqcydcbiAgICAgID8gLyhcXC8pKFthLXpBLVowLTktXyskXSl7MCwzMH1cXC5qcyQvXG4gICAgICA6IC8oXFwvKShbYS16QS1aMC05LV8rJF0pezAsMzB9XFwuY3NzJC9cbiAgICApWzBdLnNsaWNlKDEpXG5cblxuICB9XG5cbiAgZmlsZVNyYyA9IHNyYysnPycrIH5+KE1hdGgucmFuZG9tKCkqOTk5OTk5OSlcblxuICBpZihleHRlbnNpb249PT0nanMnKSB7XG4gICAgZmlsZXJlZi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dC9qYXZhc2NyaXB0XCIpXG4gICAgZmlsZXJlZi5zZXRBdHRyaWJ1dGUoXCJzcmNcIiwgZmlsZVNyYylcbiAgfSBlbHNlIHtcbiAgICBmaWxlcmVmLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2Nzc1wiKVxuICAgIGZpbGVyZWYuc2V0QXR0cmlidXRlKFwicmVsXCIsIFwic3R5bGVzaGVldFwiKVxuICAgIGZpbGVyZWYuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBmaWxlU3JjKVxuICAgIGZpbGVyZWYuc2V0QXR0cmlidXRlKFwiaWRcIiwgZmlsZVNyYylcbiAgfVxuXG4gIGZvdW5kID0gZGVidWcuZmluZFNjcmlwdChoZWFkLHJlcGxhY2Usc3RyaWN0KVxuXG4gIGlmKCFmb3VuZCkge1xuICAgICAgY29uc29sZS5sb2coYm9keSwgZm91bmQsICchQCFAIyFAI0pTJylcblxuICAgIGZvdW5kID0gZGVidWcuZmluZFNjcmlwdChib2R5LHJlcGxhY2Usc3RyaWN0KVxuICB9XG4gIGlmKGZvdW5kKSB7XG5cbiAgICBjb25zb2xlLmxvZygncmVtb3RlIHJlc291cmNlIGZvdW5kOicsZm91bmQsIGZvdW5kLnNyYyAsIGZpbGVTcmMsIHNyYylcblxuICAgIHZhciBwYXJlbnQgPSBmb3VuZC5wYXJlbnROb2RlXG4gICAgaWYoU3RyaW5nKGZvdW5kLnNyYykuaW5kZXhPZihzcmMpPi0xKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoZm91bmQpXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGZpbGVyZWYpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuIiwidmFyIGRlYnVnID0gcmVxdWlyZSgnLi8nKSBcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vJykgXG4gICwgaXNOb2RlID0gdXRpbC5pc05vZGUgLy9oYXMgdG8gYmVjb21lIHBhcnQgb2YgdXRpbFxuICAsIFYgPSByZXF1aXJlKCcuLi8uLi8nKVxuICAsIHJlcGxcbiAgLCBjb2xvcnNcbiAgLCBvcmlnQ29uc29sZSA9IGNvbnNvbGVcbiAgLCBjb2xvcnMgPSB7XG4gICAgICBncmVlbjonIzU2ZGI2OCcsXG4gICAgICByZWQ6JyNmZjAwMDAnLFxuICAgICAgZ3JleTonI2NjYycsXG4gICAgICB5ZWxsb3c6JyNlMGU2N2MnLFxuICAgICAgY3lhbjonIzAwZmZmZicsXG4gICAgICBtYWdlbnRhOicjZmYwMGZmJyxcbiAgICAgIGJsdWU6JyMxMTExZmYnLFxuICAgICAgd2hpdGU6JyNmZmYnXG4gICAgfVxuICAsIHN0eWxlcyA9IHtcbiAgICAgIGJvbGQ6J2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1zaXplOjE2cHg7bGluZS1oZWlnaHQ6MTVweCcsXG4gICAgICB1bmRlcmxpbmU6J2JvcmRlci1ib3R0b206MXB4IHNvbGlkJyxcbiAgICAgIGl0YWxpYzonZm9udC1zdHlsZTppdGFsaWMnLFxuICAgICAgaW52ZXJzZTpmdW5jdGlvbihjb2xvcikge1xuICAgICAgICBpZihjb2xvcikge1xuICAgICAgICAgIHJldHVybiBjb2xvcisnO2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjVweDtsaW5lLWhlaWdodDoyMHB4J1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAnY29sb3I6Jytjb2xvcnMud2hpdGUrJztiYWNrZ3JvdW5kLWNvbG9yOiMzMzM7cGFkZGluZzo1cHg7bGluZS1oZWlnaHQ6MjBweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuZGVidWcubGV2ZWwgPSBcbnsgREVCVUckOiBJbmZpbml0eVxuLCB0ZXN0OjJcbn1cblxuXG5cbi8qXG5ib2xkXG5pdGFsaWNcbnVuZGVybGluZVxuaW52ZXJzZVxueWVsbG93XG5jeWFuXG53aGl0ZVxubWFnZW50YVxuZ3JlZW5cbnJlZFxuZ3JleVxuYmx1ZVxucmFpbmJvd1xuemVicmFcbnJhbmRvbVxuKi9cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGxvZ09iamVjdFxuICAsIHBhcnNlT2JqZWN0XG4gICwgTE9HXG4gICwgSU5GT1xuICAsIEVSUk9SXG4gICwgREVUQUlMXG5cbmlmICghaXNOb2RlKSB7IFxuXG4gIExPRyA9ICc6J1xuICBJTkZPID0gJzo6J1xuICBFUlJPUiA9ICdFUlJFWCEnXG4gIERFVEFJTCA9ICc6OjonXG5cbiAgLy8gY29uc29sZSA9IHt9XG4gIGZ1bmN0aW9uIGxvZ2xpbmsoaSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGksIGFyZ3VtZW50cylcbiAgICAgIC8vIGNvbnNvbGUubG9nKG5ldyBFcnJvcigpLnN0YWNrKVxuXG4gICAgICBvcmlnQ29uc29sZVtpXS5hcHBseShvcmlnQ29uc29sZSwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIC8vIGZvcih2YXIgaSBpbiBvcmlnQ29uc29sZSkge1xuICAvLyAgIGlmKGkgIT09ICdsb2cnKSBjb25zb2xlW2ldID0gbG9nbGluayhpKVxuICAvLyB9XG5cbiAgdmFyIENvbG9yID0gZnVuY3Rpb24odmFsLGNvZGUscykge1xuICAgIHRoaXMuY29sb3IgPSAgKHMgPyBjb2RlIDogJ2NvbG9yOiAnK2NvZGUpKyc7J1xuICAgIHRoaXMudmFsID0gbmV3IFN0cmluZygnJWMnK3ZhbClcbiAgfVxuICBcbiAgLy8gY29uc29sZS5sb2cgPSBmdW5jdGlvbigpIHtcblxuICAvLyAgIHZhciBuZXh0ID0gZmFsc2VcblxuICAvLyAgIGZvcih2YXIgaT0wLCBhcmcsIHJhcmdzPVtdLCBhcmdzID0gYXJndW1lbnRzLGxlbiA9IGFyZ3MubGVuZ3RoO2k8bGVuO2krKykge1xuICAvLyAgICAgYXJnID0gYXJnc1tpXVxuICAvLyAgICAgaWYoYXJnIGluc3RhbmNlb2YgQ29sb3IpIHtcbiAgLy8gICAgICAgaWYocmFyZ3MubGVuZ3RoKXtcbiAgLy8gICAgICAgICBuZXh0ID0gdXRpbC5hcmcoYXJncywgaSlcbiAgLy8gICAgICAgICBicmVha1xuICAvLyAgICAgICB9ZWxzZXtcbiAgLy8gICAgICAgICByYXJncy5wdXNoKGFyZy52YWwudmFsdWVPZigpLCBhcmcuY29sb3IpXG4gIC8vICAgICAgIH1cbiAgLy8gICAgICAgLy8gbG9nZ2VyKGFyZy52YWwudmFsdWVPZigpLCBhcmcuY29sb3IpXG4gIC8vICAgICB9IGVsc2Uge1xuICAvLyAgICAgICByYXJncy5wdXNoKGFyZylcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgLy8gbG9nZ2VyKCdub3cgbG9nJywgcmFyZ3MpXG4gIC8vICAgaWYocmFyZ3MubGVuZ3RoKSBsb2dnZXIuYXBwbHkob3JpZ0NvbnNvbGUscmFyZ3MpXG4gIC8vICAgLy8gbG9nZ2VyKCduZXh0JywgbmV4dClcbiAgLy8gICBpZihuZXh0Lmxlbmd0aCkgY29uc29sZS5sb2cuYXBwbHkobnVsbCxuZXh0KVxuXG4gIC8vIH1cblxuICBmdW5jdGlvbiBjb2xvcihpLCBDbGFzcywgc3R5bGUpIHtcbiAgICB1dGlsLmRlZmluZShDbGFzcyB8fCBTdHJpbmcsaSx7XG4gICAgICBnZXQ6ZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKENsYXNzKSB7XG4gICAgICAgICAgaWYodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gc3R5bGUodGhpcy5jb2xvcilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb2xvcis9KHN0eWxlfHwoJ2NvbG9yOicrY29sb3JzW2ldKSkrJzsnXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHMgPSBjb2xvcnNbaV1cbiAgICAgICAgICBpZihzdHlsZSkge1xuICAgICAgICAgICAgaWYodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHMgPSBzdHlsZSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzPXN0eWxlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcyxzLHN0eWxlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uIGxvZ2dlcigpIHtcblxuXG4gIC8vICAgb3JpZ0NvbnNvbGUubG9nLmFwcGx5KG9yaWdDb25zb2xlLGFyZ3VtZW50cylcblxuXG4gIC8vIH1cblxuICAvLyBmb3IodmFyIGkgaW4gY29sb3JzKSB7IGNvbG9yKGkpIH1cbiAgLy8gZm9yKHZhciBpIGluIHN0eWxlcykgeyBjb2xvcihpLCBmYWxzZSwgc3R5bGVzW2ldKSB9ICBcbiAgLy8gZm9yKHZhciBpIGluIGNvbG9ycykgeyBjb2xvcihpLCBDb2xvcikgfVxuICAvLyBmb3IodmFyIGkgaW4gc3R5bGVzKSB7IGNvbG9yKGksIENvbG9yLCBzdHlsZXNbaV0pIH0gIFxuXG4gIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHJldHVybiBvYmpcbiAgICB2YXIgc3RyID0gJydcbiAgICBmb3IodmFyIGkgaW4gb2JqKSB7XG4gICAgICBzdHIgKz0gaSArICcgOiAnICsgKHR5cGVvZiBvYmpbaV0gPT09ICdzdHJpbmcnIFxuICAgICAgICA/ICBvYmpbaV0gXG4gICAgICAgIDogSlNPTi5zdHJpbmdpZnkob2JqW2ldLGZhbHNlLDIpKSBcbiAgICAgICsgJ1xcbidcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5pbnZlcnNlLmdyZWVuXG4gIH1cbiAgXG4gIGxvZ09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGNvbnNvbGUubG9nKHBhcnNlT2JqZWN0KG9iaikpXG4gIH1cbiAgXG59IGVsc2Uge1xuICByZXBsID0gcmVxdWlyZSgncmVwbCcpXG4gIGNvbG9ycyA9IHJlcXVpcmUoJ2NvbG9ycycpXG5cbiAgTE9HID0gJ2xvZyAgJy5ncmV5XG4gIElORk8gPSAnaW5mbyAnLmdyZWVuXG4gIEVSUk9SID0gJ2Vycm9yJy5yZWRcbiAgREVUQUlMID0gJy0tLS0tJy5ncmV5XG5cbiAgZGVidWcucmVwbCA9IGZ1bmN0aW9uKCkge1xuICAgIHJlcGwuc3RhcnQoJz4nKVxuICAgIHJldHVybiBkZWJ1Z1xuICB9XG4gIGlmKHJlcGwuY29udGV4dCkgcmVwbC5jb250ZXh0LkRFQlVHJCA9IERFQlVHJFxuXG4gIGNvbnNvbGUuZ3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZygnXFxuX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXycuZ3JleSlcbiAgfSAgICAgIFxuICBjb25zb2xlLmdyb3VwRW5kID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coJ19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19cXG4nLmdyZXkpXG4gIH1cbiAgdmFyIG5fdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKVxuICBwYXJzZU9iamVjdCA9IGZ1bmN0aW9uKG9iail7XG4gICAgcmV0dXJuIG5fdXRpbC5pbnNwZWN0KG9iaix7Y29sb3JzOnRydWUsIGRlcHRoOiA1MH0pXG4gIH1cbiAgbG9nT2JqZWN0ID0gZnVuY3Rpb24ob2JqKXtcbiAgICBjb25zb2xlLmxvZyhwYXJzZU9iamVjdChvYmopKVxuICB9XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnV0aWwuZGVmaW5lKE9iamVjdCwnREVCVUckbG9nJywgZnVuY3Rpb24obXNnLHMpIHtcbiAgaWYoY29uc29sZS5ncm91cCkgY29uc29sZS5ncm91cCgpXG4gIGlmKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgbXNnID0gbXNnXG4gIH0gZWxzZSB7XG4gICAgbXNnID0gZmFsc2VcbiAgfVxuICB2YXIgaCA9ICdKU09OICcrKG1zZ3x8JyBub3JtYWwnKVxuICBkZWJ1Zy5sb2cuaGVhZGVyKGgpXG4gIGlmKGRlYnVnLmxldmVsLnRlc3Q+MSkgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkodGhpcyxmYWxzZSwyKSlcbiAgaWYocykge1xuICAgIGNvbnNvbGUubG9nKCdcXG4nKVxuICAgIGRlYnVnLmxvZy5mbi5hcHBseSh0aGlzLHV0aWwuYXJnKGFyZ3VtZW50cywxKSkgXG4gIH1cbiAgLy8gZGVidWcubG9nLmVuZChoKVxuICBpZihjb25zb2xlLmdyb3VwKSBjb25zb2xlLmdyb3VwRW5kKClcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMsZmFsc2UsMilcbn0pXG5cbmlmKCFpc05vZGUgJiYgbG9jYWxTdG9yYWdlKSB7XG4gIHV0aWwuZGVmaW5lKGxvY2FsU3RvcmFnZSwnREVCVUckbG9nJywgZnVuY3Rpb24obXNnLHMpIHtcbiAgICBpZihjb25zb2xlLmdyb3VwKSBjb25zb2xlLmdyb3VwKClcbiAgICBpZih0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgICAgbXNnID0gbXNnXG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyA9IGZhbHNlXG4gICAgfVxuICAgIHZhciBoID0gJ2xvY2FsU3RvcmFnZSAnKyhtc2d8fCcgbm9ybWFsJylcbiAgICBkZWJ1Zy5sb2cuaGVhZGVyKGgpXG5cbiAgICB2YXIgb2JqID0ge31cbiAgICBmb3IodmFyIGkgaW4gdGhpcykge1xuICAgICAgLy8gY29uc29sZS5sb2coaSwgdGhpcylcbiAgICAgICB0cnkgeyBvYmpbaV0gPUpTT04ucGFyc2UodGhpc1tpXSkgfSBjYXRjaChlKXtcbiAgICAgICAgb2JqW2ldID0gdGhpc1tpXVxuICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZygpXG5cbiAgICBpZihkZWJ1Zy5sZXZlbC50ZXN0PjEpIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG9iaixmYWxzZSwyKSlcbiAgICBpZihzKSB7XG4gICAgICBjb25zb2xlLmxvZygnXFxuJylcbiAgICAgIGRlYnVnLmxvZy5mbi5hcHBseSh0aGlzLHV0aWwuYXJnKGFyZ3VtZW50cywxKSkgXG4gICAgfVxuICAgIC8vIGRlYnVnLmxvZy5lbmQoaClcbiAgICBpZihjb25zb2xlLmdyb3VwKSBjb25zb2xlLmdyb3VwRW5kKClcbiAgICByZXR1cm4gb2JqXG4gIH0pXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBsb2cgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB7XG4gIHN0YWNrOiBmYWxzZSxcbiAgaTpmdW5jdGlvbihucikge1xuICAgIG5yID0gdGhpcy5pbmRlbnRcbiAgICB2YXIgc3RyID0gJydcbiAgICBmb3IodmFyIGkgaW4gbnIpIHtcbiAgICAgIHN0cis9JyAgJ1xuICAgIH1cbiAgICByZXR1cm4gc3RyXG4gIH0sXG4gIHBhcnNlOiBwYXJzZU9iamVjdCxcbiAgb2JqZWN0OiBsb2dPYmplY3QsXG4gIGRlZmF1bHQ6IGZ1bmN0aW9uKGxhYmVsLCBsZXZlbCl7XG4gICAgaWYobGFiZWwgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICBmb3IodmFyIGwgaW4gbGFiZWwpXG4gICAgICAgIHNldERlZmF1bHQobCwgbGFiZWxbbF0pXG4gICAgZWxzZVxuICAgICAgc2V0RGVmYXVsdChsYWJlbCwgbGV2ZWwpXG4gIH0sXG4gIGxvZ2dlcjpmdW5jdGlvbihsYWJlbCwgY29sb3IsIGxldmVsKXtcbiAgICBsb2cuZGVmYXVsdChsYWJlbCwgbGV2ZWwgfHwgMSlcbiAgICBcbiAgICBmdW5jdGlvbiBsb2dnZXIoKXtcbiAgICAgIHZhciBsZXZlbCA9IGRlYnVnLmxldmVsLmdsb2JhbCAhPT0gdW5kZWZpbmVkID8gZGVidWcubGV2ZWwuZ2xvYmFsIDogZGVidWcubGV2ZWxbbGFiZWxdXG4gICAgICBpZihsZXZlbCA+IDIpIHtcbi8vICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkobnVsbCwgW2xhYmVsW2NvbG9yXS5ib2xkLCBMT0ddLmNvbmNhdCh1dGlsLmFyZyhhcmd1bWVudHMpKSlcbiAgICAgICAgaWYobG9nLnN0YWNrKSBjb25zb2xlLmxvZyhzbWFsbFN0YWNrKGxvZy5zdGFjaykuZ3JleSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsb2dnZXIuaW5mbyA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgbGV2ZWwgPSBkZWJ1Zy5sZXZlbC5nbG9iYWwgIT09IHVuZGVmaW5lZCA/IGRlYnVnLmxldmVsLmdsb2JhbCA6IGRlYnVnLmxldmVsW2xhYmVsXVxuICAgICAgaWYobGV2ZWwgPiAxKSB7XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KG51bGwsIFtsYWJlbFtjb2xvcl0uYm9sZCwgSU5GT10uY29uY2F0KHV0aWwuYXJnKGFyZ3VtZW50cykpKVxuICAgICAgICBpZihsb2cuc3RhY2spIGNvbnNvbGUubG9nKHNtYWxsU3RhY2sobG9nLnN0YWNrKS5ncmV5KVxuICAgICAgfVxuICAgICAgICBcbiAgICB9XG4gICAgbG9nZ2VyLmVycm9yID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBsZXZlbCA9IGRlYnVnLmxldmVsLmdsb2JhbCAhPT0gdW5kZWZpbmVkID8gZGVidWcubGV2ZWwuZ2xvYmFsIDogZGVidWcubGV2ZWxbbGFiZWxdXG4gICAgICBpZihsZXZlbCA+IDApIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkobnVsbCwgW2xhYmVsW2NvbG9yXS5ib2xkLCBFUlJPUl0uY29uY2F0KHV0aWwuYXJnKGFyZ3VtZW50cykpKVxuICAgICAgICBpZihsb2cuc3RhY2spIGNvbnNvbGUubG9nKHNtYWxsU3RhY2sobG9nLnN0YWNrKS5ncmV5KVxuICAgICAgfVxuICAgIH1cbiAgICBsb2dnZXIuZGV0YWlsID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBsZXZlbCA9IGRlYnVnLmxldmVsLmdsb2JhbCAhPT0gdW5kZWZpbmVkID8gZGVidWcubGV2ZWwuZ2xvYmFsIDogZGVidWcubGV2ZWxbbGFiZWxdXG4gICAgICBpZihsZXZlbCA+IDMpIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkobnVsbCwgW2xhYmVsW2NvbG9yXS5ib2xkLCBERVRBSUxdLmNvbmNhdCh1dGlsLmFyZyhhcmd1bWVudHMpKSlcbiAgICAgICAgaWYobG9nLnN0YWNrKSBjb25zb2xlLmxvZyhzbWFsbFN0YWNrKGxvZy5zdGFjaykuZ3JleSlcbiAgICAgIH0gICAgICBcbiAgICB9XG4gICAgbG9nZ2VyLnBhcnNlID0gcGFyc2VPYmplY3RcbiAgICByZXR1cm4gbG9nZ2VyXG4gIH0sXG4gIGxhYmVsOiBmdW5jdGlvbihsYWJlbCwgc3R5bGUsIGxvZyl7XG4gICAgICBpZihpc05vZGUpIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkobnVsbCwgbG9nKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoIG51bGxcbiAgICAgICAgICAsIFsnJWMgJytsYWJlbCsnICcsIHN0eWxlXS5jb25jYXQobG9nKVxuICAgICAgICApXG4gICAgICB9XG4gIH0sXG4gIGhlYWRlcjpmdW5jdGlvbihtc2cpIHtcbiAgICB0aGlzLl9saCA9IG1zZ1xuICAgIGNvbnNvbGUubG9nKG1zZy5pbnZlcnNlKVxuICB9LFxuICBoZWFkZXIyOmZ1bmN0aW9uKG1zZykge1xuICAgIHRoaXMuX2xoID0gbXNnXG4gICAgY29uc29sZS5sb2cobXNnLmdyZXkuaW52ZXJzZSlcbiAgfSxcbiAgZW5kOmZ1bmN0aW9uKG1zZykge1xuICAgIGNvbnNvbGUubG9nKCgnZW5kIFsnK21zZysnXScpLmdyZXkuaW52ZXJzZSlcbiAgfSxcbiAgbGV2ZWw6ZnVuY3Rpb24obGV2ZWwsZmllbGQpIHtcbiAgICBpZihsZXZlbCA+PSBkZWJ1Zy5sZXZlbC50ZXN0IFxuICAgICAgfHwgIGRlYnVnLmxldmVsW2xldmVsXSBcbiAgICAgIHx8IGZpZWxkICYmIGRlYnVnLmxldmVsW2xldmVsXT49ZmllbGQgKSBcbiAgICAgIGNvbnNvbGUubG9nLmFwcGx5KHRoaXMsdXRpbC5hcmcoYXJndW1lbnRzLDEpKVxuICB9LFxuICBmbjpmdW5jdGlvbihhcmcpIHtcbiAgICBkZWJ1Zy5sb2cuaW5kZW50KytcbiAgICBpZih0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhcmcuY2FsbCh0aGlzLHV0aWwuYXJnKGFyZ3VtZW50cywxKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYXJndW1lbnRzKVxuLy8gICAgICAgY29uc29sZS5sb2cuYXBwbHkodGhpcyxhcmd1bWVudHMpXG4gICAgfVxuICAgIGRlYnVnLmxvZy5pbmRlbnQtLVxuICB9LFxuICBpbmRlbnQ6MFxufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gc21hbGxTdGFjayhsaW5lcyl7XG4gIGlmKCFsaW5lcykgbGluZXMgPSAxXG4gIHZhciBzdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrLnNwbGl0KCdcXG4nKVxuICAgICwgbCA9IDNcbiAgICAsIHJlc3VsdCA9IFtdXG4gICAgLCBlbmRcblxuICB3aGlsZShsaW5lcy0tKXtcbiAgICBsaW5lID0gc3RhY2tbbCsrXVxuICAgIGVuZCA9IGxpbmVbbGluZS5sZW5ndGgtMV0gPT09ICcpJyA/IGxpbmUubGVuZ3RoLTEgOiBsaW5lLmxlbmd0aFxuICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UobGluZS5pbmRleE9mKCcvJyksIGVuZCkpXG4gIH1cblxuICByZXR1cm4gcmVzdWx0LmpvaW4oJ1xcbicpLmdyZXlcbiAgXG59XG5cbmZ1bmN0aW9uIHNldERlZmF1bHQobGFiZWwsIGxldmVsKXtcbiAgaWYoZGVidWcubGV2ZWxbbGFiZWxdID09PSB2b2lkIDApIGRlYnVnLmxldmVsW2xhYmVsXSA9IGxldmVsXG59XG5cbnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4vLyAgIGNvbnNvbGUubG9nKCdsb2cgbGV2ZWxzOlxcbicsIGxvZy5wYXJzZShkZWJ1Zy5sZXZlbCkpXG59LDApXG5cbi8vTG9jYWxzdG9yYWdlXG5cbi8qXG52YXIgbG9jYWxTdG9yYWdlU3BhY2UgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgYWxsU3RyaW5ncyA9ICcnO1xuICAgICAgICBmb3IodmFyIGtleSBpbiB3aW5kb3cubG9jYWxTdG9yYWdlKXtcbiAgICAgICAgICAgIGlmKHdpbmRvdy5sb2NhbFN0b3JhZ2UuaGFzT3duUHJvcGVydHkoa2V5KSl7XG4gICAgICAgICAgICAgICAgYWxsU3RyaW5ncyArPSB3aW5kb3cubG9jYWxTdG9yYWdlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFsbFN0cmluZ3MgPyAzICsgKChhbGxTdHJpbmdzLmxlbmd0aCoxNikvKDgqMTAyNCkpICsgJyBLQicgOiAnRW1wdHkgKDAgS0IpJztcbiAgICB9O1xuXG4qL1xuXG51dGlsLmRlZmluZShkZWJ1ZywnbG9jYWxTdG9yYWdlU2l6ZScsIHtcbiAgZ2V0OmZ1bmN0aW9uKCkge1xuICB2YXIgdG90YWwgPSAwXG4gIGZvcih2YXIgeCBpbiBsb2NhbFN0b3JhZ2UpIHtcbiAgICB2YXIga2J5dGVzID0gKCgoeC5sZW5ndGgrbG9jYWxTdG9yYWdlW3hdLmxlbmd0aCkpLygxMDI0KSlcbiAgICB0b3RhbCs9a2J5dGVzXG4gICAgLy8gY29uc29sZS5sb2coKHgrXCI6XCIra2J5dGVzLnRvRml4ZWQoMTApK1wiIEtCXCIpLmdyZXkpXG4gIH1cbiAgY29uc29sZS5sb2coJ0xPQ0FMIFNUT1JBR0UgU0laRSBUT1RBTCcuaW52ZXJzZS5ncmVlbiwgKHRvdGFsLzEwMjQpLnRvRml4ZWQoNSkrJyBNQicpXG4gIHJldHVybiB0b3RhbCoxMDI0XG59XG59KVxuXG51dGlsLmRlZmluZShkZWJ1ZywnbG9jYWxTdG9yYWdlS2V5c1NpemUnLCB7XG4gIGdldDpmdW5jdGlvbigpIHtcbiAgdmFyIHRvdGFsID0gMFxuICBmb3IodmFyIHggaW4gbG9jYWxTdG9yYWdlKSB7XG4gICAgdmFyIGtieXRlcyA9ICgoKHgubGVuZ3RoKSkvKDEwMjQpKVxuICAgIHRvdGFsKz1rYnl0ZXNcbiAgICAvLyBjb25zb2xlLmxvZygoeCtcIjpcIitrYnl0ZXMudG9GaXhlZCgxMCkrXCIgS0JcIikuZ3JleSlcbiAgfVxuICBjb25zb2xlLmxvZygnTE9DQUwgU1RPUkFHRSBLRVkgU0laRSBUT1RBTCcuaW52ZXJzZS5ncmVlbiwgKHRvdGFsLzEwMjQpLnRvRml4ZWQoNSkrJyBNQicpXG4gIHJldHVybiB0b3RhbCoxMDI0XG59XG59KVxuXG5cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vJykgXG4gICwgZGVidWcgPSByZXF1aXJlKCcuLycpIFxuICAsIGlzTm9kZSA9IHV0aWwuaXNOb2RlIC8vaGFzIHRvIGJlY29tZSBwYXJ0IG9mIHV0aWxcbiAgLCBvc1xuXG5pZiAoaXNOb2RlKSB7IFxuICBvcyA9IHJlcXVpcmUoJ29zJylcbn0gZWxzZSB7XG4gIGNvbnNvbGUubG9nKCdERUJVRyBcXG5cXG5pZiB5b3Ugd2FudCB0byBjaGVjayBtZW1vcnkgdXNhZ2Ugc3RhcnQgY2hyb21lIHVzaW5nOiBcXG5cXG4gb3BlbiAtYSBHb29nbGVcXFxcIENocm9tZSAtLWFyZ3MgLS1lbmFibGUtbWVtb3J5LWluZm8gLS1qcy1mbGFncz1cIi0tZXhwb3NlLWdjXCJcXG4nLmdyZXkpXG59XG5cbmZ1bmN0aW9uIF90ZXN0KG1ldGhvZCwgbmFtZSwgY29tcGxldGUsIGNhbGwsIGFyZ3MsIG5vbG9nKSB7XG4gIHZhciBzdGFydCA9IGV4cG9ydHMubm93KClcbiAgICAsIG1lbW9yeXN0YXJ0ID0gZXhwb3J0cy5tZW1vcnkoKVxuICAgICwgbWVtb3J5ZW5kXG4gICAgLCBtZW1cbiAgICAsIHRpbWVcbiAgICAsIGVuZFxuICAgICwgc3ViIFxuICBpZiAoIW5hbWUpIG5hbWUgPSAnVEVTVCBQRVJGT1JNQU5DRSdcbiAgaWYgKGNhbGwpIHtcbiAgICBzdWIgPSBtZXRob2QuYXBwbHkoY2FsbCwgYXJncylcbiAgfSBcbiAgZWxzZSB7XG4gICAgc3ViID0gbWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpXG4gIH1cbiAgZW5kID0gZXhwb3J0cy5ub3coKVxuICBtZW1vcnllbmQgPSBleHBvcnRzLm1lbW9yeSgpXG4gIG1lbSA9IChtZW1vcnllbmQgLSBtZW1vcnlzdGFydClcbiAgdGltZSA9IGVuZCAtIHN0YXJ0IC0gKHN1YiB8fCAwKVxuICBpZiAoY29tcGxldGUpIHtcbiAgICBjb21wbGV0ZSgoKHRpbWUpIC8gMTAwMCksIChtZW1vcnllbmQgLSBtZW1vcnlzdGFydCkpXG4gIH0gXG4gIGVsc2UgaWYgKCFub2xvZykge1xuICAgIGlmKGRlYnVnLmxldmVsLnRlc3Q+MCkge1xuICAgICAgY29uc29sZS5sb2coIFxuICAgICAgICBuYW1lLmludmVyc2UgLCAnXFxucGFyc2UgdGltZTogJyBcbiAgICAgICAgKyAoKGVuZCAtIHN0YXJ0KSAvIDEwMDApIFxuICAgICAgICArICcgc2VjJyArIChtZW0gPyAnXFxubWVtb3J5IHVzZWQgKGFwcHJveGltYXRlKTogJyBcbiAgICAgICAgKyBtZW0gKyAnIGJ5dGVzJyA6ICcnKVxuICAgICAgKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGltZVxufVxuXG5cblxudmFyIG9sZENoZWNrID0gW11cbmRlYnVnLmNvdW50TmV3TGlzdGVuZXJzID0gZnVuY3Rpb24oIG9iaiwgYW1vdW50ICkge1xuICBcbiAgYW1vdW50ID0ge3ZhbDowfVxuXG4gIHZhciBjaGVja25vdyA9IFtdXG5cbiAgZGVidWcuY291bnRMaXN0ZW5lcnMoIG9iaiwgYW1vdW50LCBjaGVja25vdyApIFxuXG4gIHZhciBuZXdsaXN0bmVycyA9IFtdXG5cbiAgZm9yKCB2YXIgaSBpbiBjaGVja25vdyApIHtcblxuICAgIGlmKCB1dGlsLmNoZWNrQXJyYXkoIG9sZENoZWNrLCBjaGVja25vd1tpXSApID09PSBmYWxzZSApIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGNoZWNrbm93W2ldKVxuICAgICAgLy8gaWYoIHR5cGVvZiBjaGVja25vd1tpXSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGNoZWNrbm93W2ldID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnbGV0cyBwdXNoJylcbiAgICAgICAgLy8gaWYoIXV0aWwuZW1wdHkoY2hlY2tub3dbaV0pKSB7XG4gICAgICAgIG5ld2xpc3RuZXJzLnB1c2goIGNoZWNrbm93W2ldIClcbiAgICAgICAgLy8gfVxuICAgICAgLy8gfVxuICAgIH1cbiAgfVxuXG4gIG9sZENoZWNrID0gY2hlY2tub3dcblxuICByZXR1cm4ge1xuICAgIGFtb3VudDogYW1vdW50LnZhbFxuICAsIG5ld2NoZWNrczogbmV3bGlzdG5lcnNcbiAgfVxuXG59XG5cblxuZGVidWcuY291bnRMaXN0ZW5lcnMgPSBmdW5jdGlvbihvYmosIGFtb3VudCwgY2hlY2tlZCkge1xuICB2YXIgYW1vdW50IFxuICAgICwgY2hlY2tlZCBcblxuICBpZighY2hlY2tlZCkge1xuICAgIGNoZWNrZWQgPSBbXVxuICB9XG5cbiAgaWYodXRpbC5jaGVja0FycmF5KGNoZWNrZWQsIG9iaikhPT1mYWxzZSB8fCAhb2JqKSB7XG4gICAgcmV0dXJuIGFtb3VudC52YWxcbiAgfVxuICBjaGVja2VkLnB1c2gob2JqKVxuXG4gIGlmKCFhbW91bnQpIGFtb3VudCA9IHt2YWw6MH1cbiAgaWYob2JqLl9saXN0ZW5lcnMpIHtcbiAgICBhbW91bnQudmFsKz1vYmouX2xpc3RlbmVycy5sZW5ndGhcbiAgfVxuXG4gIGlmKCFvYmouZWFjaCkge1xuXG4gICAgaWYob2JqIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICBmb3IodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmKG9ialtpXSAmJiAoIG9ialtpXS5fX3QgfHwgb2JqW2ldLl9mcm9tIHx8IG9iai5fZnJvbSAmJiBpID09PSdjbG91ZCcpICkgZGVidWcuY291bnRMaXN0ZW5lcnMob2JqW2ldLGFtb3VudCxjaGVja2VkKVxuICAgICAgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuXG4gICAgb2JqLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgZGVidWcuY291bnRMaXN0ZW5lcnModGhpcyxhbW91bnQsY2hlY2tlZClcbiAgICB9KVxuXG4gIH1cblxuICByZXR1cm4gYW1vdW50LnZhbFxufVxuXG5kZWJ1Zy5jb3VudFN1YnMgPSBmdW5jdGlvbihvYmosIGFtb3VudCwga2V5KSB7XG4gIHZhciBhbW91bnQgXG4gIGlmKCFhbW91bnQpIGFtb3VudCA9IHt2YWw6MH1cbiAgaWYob2JqLl9zdWJzKSB7XG4gICAgY29uc29sZS5sb2coJyEhISEhU1VCJywgb2JqLl9wYXRoLCBvYmouX3N1YnMpXG4gICAgYW1vdW50LnZhbCs9b2JqLl9zdWJzLmxlbmd0aFxuICB9XG4gICAgXG4gIGlmKCFvYmouZWFjaCkge1xuICAgIGNvbnNvbGUubG9nKCdubyBFQUNIIScsIGtleSlcbiAgfVxuICAvLyBjb25zb2xlLmxvZyhvYmosIG9iai5fc3VicylcbiAgb2JqLmVhY2goZnVuY3Rpb24oaSkge1xuICAgIGRlYnVnLmNvdW50U3Vicyh0aGlzLGFtb3VudCxpKVxuICB9KVxuICByZXR1cm4gYW1vdW50LnZhbFxufVxuXG5mdW5jdGlvbiBfZG9uZShwYXJhbXMsIHRpbWUsIG1lbSkge1xuICBpZiAocGFyYW1zLmNvbXBsZXRlKSB7XG4gICAgcGFyYW1zLmNvbXBsZXRlKHRpbWUsIG1lbSwgcGFyYW1zLCBleHBvcnRzLmF2ZXJhZ2UodGltZSlbMF0sIGV4cG9ydHMuYXZlcmFnZSh0aW1lKVsxXSlcbiAgfSBlbHNlIHtcbiAgICBpZihkZWJ1Zy5sZXZlbC50ZXN0PjApIHtcbiAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICBwYXJhbXMubmFtZS5pbnZlcnNlIFxuICAgICAgICAsICcgbj0nICsgcGFyYW1zLmxvb3AgXG4gICAgICAgICsgJ1xcbnBhcnNlIHRpbWU6JyBcbiAgICAgICAgKyAocGFyYW1zLmV4dGVuc2l2ZSBcbiAgICAgICAgICA/ICgnIFxcblxcbicgKyB0aW1lLmpvaW4oJyBzZWNcXG4nKSArICcgc2VjXFxuXFxuJykgXG4gICAgICAgICAgOiAnJykgXG4gICAgICAgICsgJ2F2ZXJhZ2U6ICcgKyBleHBvcnRzLmF2ZXJhZ2UodGltZSlbMV0gXG4gICAgICAgICsgJyBzZWNcXG50b3RhbDogJyBcbiAgICAgICAgKyBleHBvcnRzLmF2ZXJhZ2UodGltZSlbMF0gKyAnIHNlYycpXG4gICAgfVxuICAgIC8vKyhtZW0ubGVuZ3RoPjAgPyAnXFxubWVtb3J5IHVzZWQgKGFwcHJveGltYXRlKTogJyttZW0rJyBrYicgOiAnJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24gKHBhcmFtcywgZm4pIHtcbiAgaWYgKGZuICYmIHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIF90ZXN0KGZuLCBwYXJhbXMpXG4gIH0gXG4gIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gX3Rlc3QocGFyYW1zKVxuICB9IFxuICBlbHNlIGlmIChwYXJhbXMgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBpZighcGFyYW1zLm5hbWUpIHBhcmFtcy5uYW1lID0gJ3BlcmZvcm1hbmNlIHRlc3QnXG5cbiAgICBpZiAocGFyYW1zLmxvb3ApIHtcbiAgICAgIC8vdGVzdGluZyBtZW1vcnkgaW4gbG9vcCBpcyBoYXJkIHNpbmNlIHRoZSBnYyBhbG1vc3QgbmV2ZXIgbWFrZXMgaXQgYmVmb3JlIG5leHQgaXRlcmF0aW9uO1xuICAgICAgdmFyIHRpbWUgPSBbXVxuICAgICAgICAsIG1lbSA9IFtdXG4gICAgICAgICwgY2FsbGJhY2sgPSBmdW5jdGlvbiAoX3RpbWUsIG1lbW9yeSkge1xuICAgICAgICAgIHRpbWUucHVzaChfdGltZSlcbiAgICAgICAgICBpZiAobWVtb3J5KSBtZW0ucHVzaChtZW1vcnkpXG4gICAgICAgIH1cblxuICAgICAgaWYocGFyYW1zLmludGVydmFsKSB7XG4gICAgICAgIHZhciBjbnQgPSAwXG4gICAgICAgICAgLCBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBjbnQrK1xuICAgICAgICAgICAgICBpZihjbnQ9PT1wYXJhbXMubG9vcC0xKSB7XG4gICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgIF9kb25lKHBhcmFtcywgdGltZSwgbWVtKSBcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGVzdChwYXJhbXMubWV0aG9kLCBmYWxzZSwgY2FsbGJhY2spXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0scGFyYW1zLmludGVydmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHBhcmFtcy5sb29wOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgX3Rlc3QocGFyYW1zLm1ldGhvZCwgZmFsc2UsIGNhbGxiYWNrKVxuICAgICAgICB9XG4gICAgICAgIF9kb25lKHBhcmFtcywgdGltZSwgbWVtKSBcbiAgICAgIH0gXG4gICAgICByZXR1cm4gZXhwb3J0cy5hdmVyYWdlKHRpbWUpXG4gICAgfSBcbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBfdGVzdChwYXJhbXMubWV0aG9kXG4gICAgICAgICwgcGFyYW1zLm5hbWVcbiAgICAgICAgLCBwYXJhbXMuY29tcGxldGVcbiAgICAgICAgLCBwYXJhbXMuY2FsbFxuICAgICAgICAsIHBhcmFtcy5hcmdzXG4gICAgICAgICwgcGFyYW1zLm5vbG9nKVxuICAgIH1cbiAgfVxufVxuXG5pZihkZWJ1Zy5sb2cpIGRlYnVnLmxvZy5kZWZhdWx0KCd0ZXN0JywgNClcblxuZXhwb3J0cy5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc05vZGVcbiAgICA/IHByb2Nlc3MuaHJ0aW1lKClbMF0gKiAxMDAwICsgcHJvY2Vzcy5ocnRpbWUoKVsxXSAqIDAuMDAwMDAxIFxuICAgIDogKHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93IFxuICAgICAgPyB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkgXG4gICAgICA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpKVxufVxuXG5leHBvcnRzLm1lbW9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzTm9kZSBcbiAgICA/IHByb2Nlc3MubWVtb3J5VXNhZ2UoKS5oZWFwVXNlZCBcbiAgICA6ICh3aW5kb3cgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5tZW1vcnkgXG4gICAgICA/IHdpbmRvdy5wZXJmb3JtYW5jZS5tZW1vcnkudXNlZEpTSGVhcFNpemUgKiAwLjAwMDk3NjU2MiBcbiAgICAgIDogMClcbn1cblxuZXhwb3J0cy5hdmVyYWdlID0gZnVuY3Rpb24gKGFycmF5KSB7XG4gIHZhciBudW1iZXIgPSAwXG4gIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG51bWJlciArPSBhcnJheVtpXVxuICB9XG4gIHJldHVybiBbbnVtYmVyLCBudW1iZXIgLyBhcnJheS5sZW5ndGhdXG59XG4iLCJ2YXIgZyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gd2luZG93XG4gICAgICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICA/IGdsb2JhbFxuICAgICAgICAgIDogZmFsc2VcbiAgLCBoYXNMUyA9IHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnXG4gICwgaGFzUFIgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCdcblxudmFyIEcgPSBtb2R1bGUuZXhwb3J0cyA9IFxuICB7IHNlc3Npb246IGZ1bmN0aW9uKGtleSwgdmFsKXtcbiAgICAgIHJldHVybiBnZXRTZXQoZywga2V5LCB2YWwpXG4gICAgfVxuICAsIGVudjogZnVuY3Rpb24oa2V5LCB2YWwpe1xuICAgICAgaWYoaGFzTFMpXG4gICAgICAgIHJldHVybiBnZXRTZXQobG9jYWxTdG9yYWdlLCBrZXksIHZhbCwgJ2dldEl0ZW0nLCAnc2V0SXRlbScpXG4gICAgICBlbHNlIGlmKGhhc1BSKVxuICAgICAgICByZXR1cm4gZ2V0U2V0KHByb2Nlc3MuZW52LCBrZXksIHZhbClcbiAgICB9XG4gIH1cblxuZnVuY3Rpb24gZ2V0U2V0KHRoaW5nLCBrZXksIHZhbCwgZ2V0dGVyLCBzZXR0ZXIpe1xuICBpZighdGhpbmcpXG4gICAgcmV0dXJuXG5cbiAgaWYodmFsID09PSB2b2lkIDApe1xuICAgIGlmKGdldHRlcilcbiAgICAgIHJldHVybiB0aGluZ1tnZXR0ZXJdKGtleSlcbiAgICBlbHNlXG4gICAgICByZXR1cm4gdGhpbmdba2V5XVxuICB9ZWxzZXtcbiAgICBpZihzZXR0ZXIpe1xuICAgICAgdGhpbmdbc2V0dGVyXShrZXksIHZhbClcbiAgICAgIHJldHVybiB2YWxcbiAgICB9ZWxzZXtcbiAgICAgIHJldHVybiB0aGluZ1trZXldID0gdmFsXG4gICAgfVxuICB9XG59IiwiLy9jaGVjayB0aGlzIGZvciBtb3JlIGNvbXByZXNzaW9uIGh0dHA6Ly93d3cuaHRtbGdvb2RpZXMuY29tL2h0bWw1L2NsaWVudC9vcHRpbWl6aW5nLXdlYnNvY2tldHMtYmFuZHdpZHRoLmh0bWwjZmJpZD02UVp4OG5hcHUyMFxuXG4vKlxudmFyIGNyY1RhYmxlXG4gICwgY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgY3JjVGFibGUgPSBbXVxuICAgICAgZm9yICh2YXIgYywgbiA9IDAsIGs7IG4gPCAyNTY7IGMgPSArK24pIHtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IDg7IGsrKywgYyA9ICgoYyAmIDEpID8gKCgweEVEQjg4MzIwKSBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpKTtcbiAgICAgICAgY3JjVGFibGVbbl0gPSBjXG4gICAgICB9XG4gICAgICByZXR1cm4gY3JjVGFibGVcbiAgICB9XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgZm9yICh2YXIgdGFiID0gY3JjVGFibGUgfHwgY3JlYXRlKCksIGNyYyA9IC0xLCBpID0gMCwgbCA9IHN0ci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRhYlsoY3JjIF4gc3RyLmNoYXJDb2RlQXQoaSkpICYgMHhGRl1cbiAgfVxuICByZXR1cm4gZXhwb3J0cy5lbmNvZGUoKChjcmMgXiAoLTEpKSA+Pj4gMCkpXG59XG5cblxuKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oa2V5LCBzZWVkKSB7XG4gIHZhciByZW1haW5kZXIsIGJ5dGVzLCBoMSwgaDFiLCBjMSwgYzFiLCBjMiwgYzJiLCBrMSwgaTtcbiAgc2VlZCA9IDFcblxuICByZW1haW5kZXIgPSBrZXkubGVuZ3RoICYgMzsgLy8ga2V5Lmxlbmd0aCAlIDRcbiAgYnl0ZXMgPSBrZXkubGVuZ3RoIC0gcmVtYWluZGVyO1xuICBoMSA9IHNlZWQ7XG4gIGMxID0gMHhjYzllMmQ1MTtcbiAgYzIgPSAweDFiODczNTkzO1xuICBpID0gMDtcbiAgXG4gIHdoaWxlIChpIDwgYnl0ZXMpIHtcbiAgICAgIGsxID0gXG4gICAgICAgICgoa2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmKSkgfFxuICAgICAgICAoKGtleS5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCA4KSB8XG4gICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDE2KSB8XG4gICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDI0KTtcbiAgICArK2k7XG4gICAgXG4gICAgazEgPSAoKCgoazEgJiAweGZmZmYpICogYzEpICsgKCgoKGsxID4+PiAxNikgKiBjMSkgJiAweGZmZmYpIDw8IDE2KSkpICYgMHhmZmZmZmZmZjtcbiAgICBrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KTtcbiAgICBrMSA9ICgoKChrMSAmIDB4ZmZmZikgKiBjMikgKyAoKCgoazEgPj4+IDE2KSAqIGMyKSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuXG4gICAgaDEgXj0gazE7XG4gICAgICAgIGgxID0gKGgxIDw8IDEzKSB8IChoMSA+Pj4gMTkpO1xuICAgIGgxYiA9ICgoKChoMSAmIDB4ZmZmZikgKiA1KSArICgoKChoMSA+Pj4gMTYpICogNSkgJiAweGZmZmYpIDw8IDE2KSkpICYgMHhmZmZmZmZmZjtcbiAgICBoMSA9ICgoKGgxYiAmIDB4ZmZmZikgKyAweDZiNjQpICsgKCgoKGgxYiA+Pj4gMTYpICsgMHhlNjU0KSAmIDB4ZmZmZikgPDwgMTYpKTtcbiAgfVxuICBcbiAgazEgPSAwO1xuICBcbiAgc3dpdGNoIChyZW1haW5kZXIpIHtcbiAgICBjYXNlIDM6IGsxIF49IChrZXkuY2hhckNvZGVBdChpICsgMikgJiAweGZmKSA8PCAxNjtcbiAgICBjYXNlIDI6IGsxIF49IChrZXkuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4O1xuICAgIGNhc2UgMTogazEgXj0gKGtleS5jaGFyQ29kZUF0KGkpICYgMHhmZik7XG4gICAgXG4gICAgazEgPSAoKChrMSAmIDB4ZmZmZikgKiBjMSkgKyAoKCgoazEgPj4+IDE2KSAqIGMxKSAmIDB4ZmZmZikgPDwgMTYpKSAmIDB4ZmZmZmZmZmY7XG4gICAgazEgPSAoazEgPDwgMTUpIHwgKGsxID4+PiAxNyk7XG4gICAgazEgPSAoKChrMSAmIDB4ZmZmZikgKiBjMikgKyAoKCgoazEgPj4+IDE2KSAqIGMyKSAmIDB4ZmZmZikgPDwgMTYpKSAmIDB4ZmZmZmZmZmY7XG4gICAgaDEgXj0gazE7XG4gIH1cbiAgXG4gIGgxIF49IGtleS5sZW5ndGg7XG5cbiAgaDEgXj0gaDEgPj4+IDE2O1xuICBoMSA9ICgoKGgxICYgMHhmZmZmKSAqIDB4ODVlYmNhNmIpICsgKCgoKGgxID4+PiAxNikgKiAweDg1ZWJjYTZiKSAmIDB4ZmZmZikgPDwgMTYpKSAmIDB4ZmZmZmZmZmY7XG4gIGgxIF49IGgxID4+PiAxMztcbiAgaDEgPSAoKCgoaDEgJiAweGZmZmYpICogMHhjMmIyYWUzNSkgKyAoKCgoaDEgPj4+IDE2KSAqIDB4YzJiMmFlMzUpICYgMHhmZmZmKSA8PCAxNikpKSAmIDB4ZmZmZmZmZmY7XG4gIGgxIF49IGgxID4+PiAxNjtcblxuICByZXR1cm4gKGgxID4+PiAwKS50b1N0cmluZygzNilcbn1cblxuLy8gZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oIHN0ciApXG4vLyB7XG4vLyAgIHZhciBGTlYxXzMyQV9JTklUID0gMHg4MTFjOWRjNTtcbi8vICAgdmFyIGh2YWwgPSBGTlYxXzMyQV9JTklUO1xuLy8gICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kgKVxuLy8gICB7XG4vLyAgICAgaHZhbCBePSBzdHIuY2hhckNvZGVBdChpKTtcbi8vICAgICBodmFsICs9IChodmFsIDw8IDEpICsgKGh2YWwgPDwgNCkgKyAoaHZhbCA8PCA3KSArIChodmFsIDw8IDgpICsgKGh2YWwgPDwgMjQpO1xuLy8gICB9XG4vLyAgIHJldHVybiBodmFsID4+PiAwO1xuLy8gfVxuXG4vKipcbiAqIEVuY29kZSB0byBiYXNlIDYyICh1cmwgc2F2ZSlcbiovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIGMgKGEsIGIpIHtcbiAgYiA9IGIgfHwgXCJcIlxuICByZXR1cm4gfn4gYSBcbiAgICAgICA/IGMoYSAvIDYyLCBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYSAlPSA2MikgPiA5IFxuICAgICAgICAgID8gYSA+IDM1ID8gMjkgOiA4NyBcbiAgICAgICAgICA6IDQ4KSArIGEpICsgYikgXG4gICAgICAgOiBiXG59XG5cbi8qKlxuICogZGVjb2RlIGJhc2UgNjJcbiovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XG4gIGZvciAoYiA9IGMgPSAwOyBkID0gYS5jaGFyQ29kZUF0KGMrKyk7IGIgPSBiICogNjIgKyBkIC0gWyAsIDQ4LCAyOSwgODddW2QgPj4gNV0pO1xuICByZXR1cm4gYlxufVxuXG5cbi8vIGV4cG9ydHMuZGVjb2RlNjRcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaWQocHJlLCBsZXZlbCl7XG4gIHZhciByID0gcm5kKClcbiAgaWYobGV2ZWwpIFxuICAgIHdoaWxlKGxldmVsLS0pe1xuICAgICAgciArPSBybmQoKVxuICAgIH1cbiAgcmV0dXJuIHByZSA/IHByZSArIHIgOiByXG59XG5cbmZ1bmN0aW9uIHJuZCgpe1xuICByZXR1cm4gTnVtYmVyKFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKSkudG9TdHJpbmcoMzYpXG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xucmVxdWlyZSgnLi9vYmplY3QnKSAvL3RoZXNlIHRoaW5ncyBhZGQgZXh0cmEgbWV0aG9kcyB0byB1dGlsIGZvciByZWFkYWJpbGl0eSBpbiBhIHNlcGVyYXRlIG1vZHVsZVxucmVxdWlyZSgnLi9wcm9wJylcblxuXG5leHBvcnRzLmlzTm9kZSA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykgPyB0cnVlIDogZmFsc2VcblxuLyoqXG4gKiBBZGQgaXMgc2ltaWxhciB0byAucHVzaCBpdCByZXR1cm5zIHRoZSBhcnJheSBpbnN0ZWFkIG9mIGxlbmd0aFxuICogQ2FuIGJlIGV4dGVuZGVkIHRvIHN1cHBvcnQgbW9yZSB0eXBlcyBlLmcuIGFkZCBhbiBvYmplY3QgdG8gYW5vdGhlclxuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSAge0FycmF5fSAgb2JqIFRhcmdldFxuICogQHBhcmFtICB7T2JqZWN0fSBhZGQgT2JqZWN0IHRvIGFkZFxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0cy5hZGQgPSBmdW5jdGlvbiAob2JqLCBhZGQpIHtcbiAgaWYgKGFkZCkgb2JqLnB1c2guYXBwbHkob2JqLCBhZGQpO1xuICByZXR1cm4gb2JqXG59XG5cbi8qKlxuICogRmluZHMgaXRlbXMgaW4gYW4gYXJyYXlcbiAqIEBtZXRob2QgY2hlY2tBcnJheVxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fSAgICAgICAgICAgICAgICAgbGlzdCAgRGVmaW5lcyB0aGUgbGlzdCB3aGVyZSB5b3Ugd2FudCB0byBzZWFyY2ggdGhyb3VnaCwgb25seSB1c2VzIC5sZW5ndGggZmllbGRcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgIHZhbCAgIERlZmluZXMgdGhlIHZhbHVlIHlvdSB3YW50IHRvIHNlYXJjaCBmb3JcbiAqIEBwYXJhbSAge0Jvb2xlYW58U3RyaW5nfE51bWJlcn0gICAgICAgIFtpbmRleF0gV2hlbiBpbmRleCBpcyB0cnVlIHJldHVybiB0aGUgaW5kZXggaW5zdGVhZCBvZiB0cnVlIG9yIGZhbHNlLCB3aGVuIGluZGV4IGFuZCBpbmRleCAhPT0gdHJ1ZSBpbmRleCBpcyB1c2VkIGFzIGEgZmllbGQgaW4gb2JqZWN0cyBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgICAgICAgICAgICAgICAgIFtmaWVsZF0gV2hlbiBmaWVsZCByZXR1cm4gZmllbGQgaW5zdGVhZCBvZiBpbmRleCBvciB0cnVlXG4gKiBAcmV0dXJuIHsqfVxuICovXG5leHBvcnRzLmNoZWNrQXJyYXkgPSBmdW5jdGlvbiAobGlzdCwgdmFsLCBpbmRleCwgZmllbGQpIHtcbiAgdmFyIGFyciA9IGluZGV4IGluc3RhbmNlb2YgQXJyYXlcbiAgaWYoIWxpc3QpIHJldHVybiBmYWxzZVxuICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoLCB0OyBpIDwgbDsgaSsrKSB7XG4gICAgdCA9IGxpc3RbaV1cbiAgICBpZiAoaW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgaWYgKGluZGV4ID09PSB0cnVlKSB7XG4gICAgICAgIGlmICh0ID09PSB2YWwpIHJldHVybiBpXG4gICAgICB9IGVsc2UgaWYgKGFyciA/IGV4cG9ydHMucGF0aCh0LGluZGV4KT09PXZhbCA6IHRbaW5kZXhdID09PSB2YWwpIHJldHVybiBmaWVsZCA/IHQgOiBpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0ID09PSB2YWwpIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFBhc3MgYXJndW1lbnRzIChhcmd1bWVudHMpIGFuZCByZXR1cm4gYSBuZXcgYXJyYXksIHdoZW4gaW5kZXggcmV0dXJuIGEgbmV3IGFycmF5IHNsaWNlZCBmcm9tIGluZGV4XG4gKiBAbWV0aG9kIGFyZ1xuICogQHBhcmFtICB7QXJndW1lbnRzfSBhcmdzICAgICAgICBBcmd1bWVudHNcbiAqIEBwYXJhbSAge051bWJlcn0gICAgW2luZGV4ID0gMF0gV2hlbiBpbmRleCByZXR1cm4gYSBuZXcgYXJyYXkgc2xpY2VkIGZyb20gaW5kZXhcbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5leHBvcnRzLmFyZyA9IGZ1bmN0aW9uIChhcmdzLCBpbmRleCkge1xuICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywgIWluZGV4ID8gMCA6IGluZGV4KVxufVxuXG4vKipcbiAqIENoZWNrIGlmIG9iaiBpcyBlbXB0eSBleGNsdWRlIGZpZWxkIG5hbWVzIHBhc3NlZCB0byBsaXN0XG4gKiBAbWV0aG9kIGVtcHR5XG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgIG9iaiAgT2JqZWN0XG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9IGxpc3QgVGFrZXMgYW55IG9iamVjdCB3aXRoIC5sZW5ndGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICBUcnVlL2ZhbHNlXG4gKi9cbmV4cG9ydHMuZW1wdHkgPSBmdW5jdGlvbiAob2JqLCBsaXN0KSB7XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKCFsaXN0IHx8ICF0aGlzLmNoZWNrQXJyYXkobGlzdCwgaSkpIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydHMuaW5qZWN0ID0gcmVxdWlyZSgnLi9pbmplY3QnKVxuIiwiXG52YXIgViA9IHJlcXVpcmUoJy4uLycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4vJylcblxudmFyICRURVNUXG5pZighdXRpbC5pc05vZGUpIHtcbiAgJFRFU1QgPSB3aW5kb3cuJFRFU1Rcbn1cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZ1bmN0aW9uKGV4dGVuZCkge1xuXG4gIHZhciBhcmdzID0gYXJndW1lbnRzXG5cbiAgaWYoYXJnc1swXSYmYXJnc1swXS4kVEVTVCkge1xuICAgICAkVEVTVCA9IHdpbmRvdy4kVEVTVCA9IHRydWVcbiAgfVxuXG4gIGlmKCAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicpIHx8IChWLkJhc2UgJiYgKHRoaXMgaW5zdGFuY2VvZiBWLkJhc2UpKSB8fCB0eXBlb2YgdGhpcyA9PT0gJ29iamVjdCcpIHtcbiAgICBpZigoVi5CYXNlIFxuICAgICAgICAmJiAodGhpcz09PVYuQmFzZSBcbiAgICAgICAgfHwgKHRoaXMucHJvdG90eXBlIGluc3RhbmNlb2YgVi5CYXNlKVxuICAgICAgICB8fCAodGhpcyBpbnN0YW5jZW9mIFYuQmFzZSkpXG4gICAgICApKSB7IFxuICAgICAgYXJncyA9IHV0aWwuYXJnKGFyZ3MpXG4gICAgICBhcmdzLnVuc2hpZnQodGhpcylcbiAgICAgIGV4dGVuZCA9IHRoaXNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluamVjdC5hcHBseSh0aGlzLGFyZ3MpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICBtYWtlRXh0ZW5kKGV4dGVuZCwgYXJnc1tpXSlcbiAgfVxuICByZXR1cm4gZXh0ZW5kXG59XG5cbmZ1bmN0aW9uIG1ha2VFeHRlbmQoZXh0ZW5kLCBtb2R1bGUpIHtcbiAgaWYoJFRFU1QpIGNvbnNvbGUubG9nKCc5JywgbW9kdWxlLCBleHRlbmQpXG4gIGlmKG1vZHVsZS5leHRlbmQpIHtcbiAgICBpZigkVEVTVCkgY29uc29sZS5sb2coJzkuMScsIGV4dGVuZClcbiAgICAgbW9kdWxlLmV4dGVuZChleHRlbmQpXG4gIH0gZWxzZSBpZihtb2R1bGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBhcnIgPSBtb2R1bGUuY29uY2F0KClcbiAgICAgICwgbW9kID0gYXJyWzBdXG4gICAgYXJyWzBdID0gZXh0ZW5kXG4gICAgIGlmKCRURVNUKSBjb25zb2xlLmxvZygnOS4yJylcbiAgICBtb2QuZXh0ZW5kLmFwcGx5KG1vZCxhcnIpXG4gIH0gXG59IFxuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmKCRURVNUKSBjb25zb2xlLmxvZygnNScpXG4gIC8vZG8gc3BlY2lhbCBzdHVmZiB2b29yIGJsYWNrbGlzdFxuICAvLyBDdXN0b20ucHJvdG90eXBlID0gbmV3IHRoaXMoKSAvL2xpZ2h0ZXJcbiAgdmFyIEN1c3RvbVxuICAgICwgZXh0ZW5kUmVzaWR1ZSA9IFtdXG4gICAgLCBBc3BlY3RzID0gW3RoaXNdXG5cbiAgZm9yICh2YXIgaSA9IDAsIEFzcGVjdCwgYXJncyA9IGFyZ3VtZW50cywgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIFxuICAgIEFzcGVjdCA9IGFyZ3NbaV1cblxuICAgIGlmKHR5cGVvZiBBc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmKCFDdXN0b20pIHtcbiAgICAgICAgQ3VzdG9tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IEFzcGVjdHMubGVuZ3RoOyBqIDwgbGVuOyAgaisrKSB7XG4gICAgICAgICAgICBBc3BlY3RzW2pdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaW5oZXJpdHMoIEN1c3RvbSwgdGhpcyApXG4gICAgICB9XG4gICAgICBBc3BlY3RzLnB1c2goQXNwZWN0KVxuICAgICAgZm9yICh2YXIgbWV0aG9kJCBpbiBBc3BlY3QucHJvdG90eXBlKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChBc3BlY3QucHJvdG90eXBlLCBtZXRob2QkKSkge1xuICAgICAgICBpZiAobWV0aG9kJCA9PT0gJ2NvbnN0cnVjdG9yJykgY29udGludWVcbiAgICAgICAgQ3VzdG9tLnByb3RvdHlwZVttZXRob2QkXSA9IEFzcGVjdC5wcm90b3R5cGVbbWV0aG9kJF1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoJFRFU1QpIGNvbnNvbGUubG9nKCc2JylcbiAgICAgIGlmKEN1c3RvbSkge1xuICAgICAgICAgICAgICBpZigkVEVTVCkgY29uc29sZS5sb2coJzcnKVxuXG4gICAgICAgbWFrZUV4dGVuZChDdXN0b20gLCBBc3BlY3QpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZigkVEVTVCkgY29uc29sZS5sb2coJzgnKVxuICAgICAgICBleHRlbmRSZXNpZHVlLnB1c2goQXNwZWN0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmKCFDdXN0b20pIEN1c3RvbSA9IHRoaXNcbiAgXG4gIGZvcih2YXIgaiBpbiBleHRlbmRSZXNpZHVlKSB7XG4gICAgLy8gY29uc29sZS5sb2coJzguJytqLCBleHRlbmRSZXNpZHVlW2pdLCBDdXN0b20pXG4gICAgbWFrZUV4dGVuZChDdXN0b20sZXh0ZW5kUmVzaWR1ZVtqXSlcbiAgfVxuXG4gIHJldHVybiBDdXN0b21cbn1cblxuZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZVxuICAgICggc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICwgeyBjb25zdHJ1Y3RvcjogXG4gICAgICAgIHsgdmFsdWU6IGN0b3JcbiAgICAgICAgLCBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAsIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApXG59XG5cbi8qXG4gRGl0IG1vZXQgd29yZGVuIGdlYWRkIHZvb3IgVi5PYmplY3RzXG4vKlxuICBvYmplY3QubmV3ID0gZnVuY3Rpb24ocGFyYW1zLCBjb25zdHJ1Y3Rvcikge1xuICB2YXIgdk9iaiA9IGZ1bmN0aW9uKHZhbCwgaG9vaywgcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50KSB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgICAgIGlmIChob29rICYmIHRoaXMuX2hvb2spIHRoaXMuX2hvb2sodmFsLCBob29rKVxuICAgICAgaWYgKHRoaXMuX29uQ29uc3RydWN0KSB0aGlzLl9vbkNvbnN0cnVjdCh2YWwsIGhvb2spXG4gICAgICBpZiAodmFsICE9PSB2b2lkIDApIHRoaXMudmFsID0gdmFsXG4gICAgICAvLyBjb25zb2xlLmxvZyhjb25zdHJ1Y3RvcilcbiAgICAgIGlmKGNvbnN0cnVjdG9yKSBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cykgIFxuICAgIH0sXG4gICAgcHJvdG8gPSB2T2JqLnByb3RvdHlwZSA9IG5ldyB0aGlzKClcbiAgdk9iai5uZXcgPSBvYmplY3QubmV3XG4gIHV0aWwuZGVmaW5lKHZPYmosICdfYmxhY2tsaXN0JywgcHJvdG8uX2JsYWNrbGlzdC5jb25jYXQoKSlcbiAgX3BhcmFtcy5jYWxsKHZPYmosIHBhcmFtcywgWydtaXhlZCcsICdtZXJnZSddKVxuICB1dGlsLmRlZmluZSh2T2JqLCAnX2NsYXNzJywgdk9iailcbiAgcmV0dXJuIHZPYmpcbn1cblxudmVlbCBkaW5nZW4gd2Vya2VuIGFscyBleHRlbnNpb24gbmlldCBhbHMgbG9zc2UgY2xhc3MgLS0gXG5cbiovXG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcmVxdWlyZSgnLi8nKVxuICAsIHZpZ291ciA9IHJlcXVpcmUoJy4uLycpIC8vb25seSBoZXJlIHRvIGJlIGFibGUgdG8gdXNlIHV0aWwgd2l0aG91dCB2aWdvdXIuT2JqZWN0IG1heWJlIHJlZmFjdG9yIHRoaXMgYXdheT9cbiAgLCBET1QgPSAnLidcblxuLyoqXG4gKiBsb29rdXBcbiAqIHBvbHlmaWxsIGlmIF9fbG9va3VwU2V0dGVyX18gZG9lcyBub3QgZXhpc3Q7XG4gKi9cbmV4cG9ydHMubG9va3VwID0gT2JqZWN0Ll9fbG9va3VwU2V0dGVyX18gfHwgZnVuY3Rpb24gKGkpIHtcbiAgdmFyIHQgPSB0aGlzXG4gICAgLCBhXG4gIHdoaWxlICh0KSB7XG4gICAgYSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgaSlcbiAgICBpZiAoYSAmJiBhLnNldCkgcmV0dXJuIHRydWVcbiAgICB0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogVXNlZCB0byBzZXQgYSB2YWwgdG8gYW4gZmllbGQgb24gYSBvYmplY3QsIHdoZXRoZXIgaXQgaXMgYSB2aWdvdXIuT2JqZWN0IG9yIGEgcmVndWxhciBvYmplY3RcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqICAgRGVmaW5lcyB0YXJnZXQgT2JqZWN0XG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGQgVGFyZ2V0IGZpZWxkXG4gKiBAcGFyYW0geyp9ICAgICAgdmFsICAgVmFsdWUgdG8gc2V0XG4gKiBAdG9kbyAgICAgICAgICAgICAgICAgTW92ZSB0aGlzIGZ1bmN0aW9uIHRvIGEgZGlmZmVyZW50IG1vZHVsZSAoZS5nLiAnY29udmVuaWVuY2UnIG1vZHVsZSlcbiAqL1xuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbiAob2JqLCBmaWVsZCwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUpIHtcbiAgcmV0dXJuICh2aWdvdXIuT2JqZWN0ICYmIChvYmogaW5zdGFuY2VvZiB2aWdvdXIuT2JqZWN0KSlcbiAgICA/IG9iai5zZXQoZmllbGQsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlKVxuICAgIDogKG9ialtmaWVsZF0gPSB2YWwpXG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIG9iamVjdCBvbiB0aGUgZW5kIG9mIGEgZGVmaW5lZCBwYXRoXG4gKiBAbWV0aG9kIHBhdGhcbiAqIEBleGFtcGxlXG4gKiAvLyByZXR1cm5zIG9iai5hLmIuY1xuICogdmFyIG9iaiA9IHsgYTogeyBiOiB7IGM6IDEgfX19XG4gKiBWLnV0aWwub2JqZWN0LnBhdGgob2JqLFsnYScsJ2InLCdjJ10pXG4gKiBAcGFyYW0gIHtPYmplY3R9ICAgIG9iaiAgICAgICAgICAgIE9iamVjdCB0byBzZWFyY2hcbiAqIEBwYXJhbSAge0FycmF5fSAgICAgcGF0aCAgICAgICAgICAgQXJyYXkgb2YgZmllbGRzIGluIHBhdGhcbiAqIEBwYXJhbSAgeyp9ICAgICAgICAgW3ZhbF0gICAgICAgICAgV2hlbiBkZWZpbmVkLCB2YWwgd2lsbCBiZSBzZXQgb24gZW5kcG9pbnQgb2YgcGF0aCBpZiBub3QgYWxyZWFkeSBkZWZpbmVkXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgIFtvdmVyd3JpdGVdICAgIElmIHRydWUsIHZhbCBXSUxMIG92ZXJ3cml0ZSBleGlzdGluZyB2YWx1ZSBvbiBlbmRwb2ludCBvZiBwYXRoIHdoZW4gYWxyZWFkeSBkZWZpbmVkXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gIFt3cml0ZUhhbmRsZXJdIENhbGxiYWNrIG9uIHdyaXRlXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgIFtub3VwZGF0ZV0gICAgIFdoZW4gdHJ1ZSwgdXBkYXRlcyB3aWxsIGJlIHNraXBwZWQgb24gd3JpdGVcbiAqIEBwYXJhbSAge051bWJlcn0gICAgW2kgPSAwXSAgICAgICAgU3RhcnRpbmcgcG9pbnQgZm9yIHNlYXJjaGluZyB0aHJvdWdoIHBhdGhcbiAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IG9uIHRoZSBlbmQgb2YgYSBkZWZpbmVkIHBhdGhcbiAqL1xuXG5leHBvcnRzLnBhdGggPSBmdW5jdGlvbiAoIG9iaiwgcGF0aCwgdmFsLCBvdmVyd3JpdGUsIHdyaXRlSGFuZGxlciwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBzZWxmLCB1aWQsIGkgKSB7XG4gIGlmICghaSkgaSA9IDBcblxuICB2YXIgZmllbGQgPSBwYXRoW2ldXG4gICAgLCByZXN1bHRcbiAgICAsIGNcbiAgICAsIHRhcmdldCA9ICghc2VsZiAmJiBvYmogJiYgb2JqLl9fdCA9PT0gNCkgPyBvYmouZnJvbVtmaWVsZF0gOiBvYmogJiYgb2JqW2ZpZWxkXVxuICAgICwgbCA9IGkgPCBwYXRoLmxlbmd0aCAtIDFcblxuICAvLyBpZihmaWVsZCA9PT0gdm9pZCAwKSB7XG4gIC8vICAgdGhyb3cgbmV3IEVycm9yKCdwYXRoIG11c3Qgbm90IGNvbnRhaW4gdW5kZWZpbmVkJylcbiAgLy8gfVxuXG4gIGlmIChsICYmICEodGFyZ2V0IGluc3RhbmNlb2YgT2JqZWN0KSkgdGFyZ2V0ID0gdm9pZCAwXG5cbiAgaWYgKCh2YWwgIT09IHZvaWQgMCkgJiYgKHRhcmdldCA9PT0gdm9pZCAwIHx8ICghbCAmJiBvdmVyd3JpdGUpKSkge1xuICAgIGMgPSB0cnVlXG4gICAgZXhwb3J0cy5zZXQob2JqLCBmaWVsZCwgbCA/IHt9IDogdmFsLCBsID8gZmFsc2UgOiB2b2JqLCBzdGFtcCwgbm91cGRhdGUpXG4gICAgdGFyZ2V0ID0gb2JqW2ZpZWxkXVxuICB9XG5cbiAgaWYgKGwpIHtcbiAgICByZXN1bHQgPSB0YXJnZXRcbiAgICAgID8gdGhpcy5wYXRoKHRhcmdldCwgcGF0aCwgdmFsLCBvdmVyd3JpdGUsIHdyaXRlSGFuZGxlciwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBzZWxmLCB1aWQsICsraSlcbiAgICAgIDogdGFyZ2V0XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKCFzZWxmICYmIHRhcmdldCAmJiB0YXJnZXQuX190ID09PSA0KSA/IHRhcmdldC5mcm9tIDogdGFyZ2V0O1xuICAgIGlmIChjICYmIHdyaXRlSGFuZGxlcikgd3JpdGVIYW5kbGVyKHJlc3VsdClcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBBZGRzIHBhdGggdXNpbmcgJ2RvdC1ub3RhdGlvbidcbiAqIEBtZXRob2QgZG90RmllbGRcbiAqIEBleGFtcGxlXG4gKiAvLyByZXR1cm5zIGJsdXI6e2Q6e2E6e3M6e319fX1cbiAqIHZhciBibHVyID0ge307XG4gKiBWLnV0aWwub2JqZWN0LmRvdEZpZWxkKGJsdXIsJ2QuYS5zJyk7XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiAgIE9iamVjdCB3aGVyZSBmaWVsZCB3aWxsIGJlIGFkZGVkXG4gKiBAcGFyYW0gIHtTdHJpbmd9IGZpZWxkIFN0cmluZyB1c2luZyAnZG90LW5vdGF0aW9uJ1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICBSZXR1cm5zIGZpZWxkXG4gKi9cbmV4cG9ydHMuZG90RmllbGQgPSBmdW5jdGlvbiAob2JqLCBmaWVsZCkge1xuICBpZiAofmZpZWxkLmluZGV4T2YoRE9UKSkge1xuICAgIHZhciBwYXRoID0gZmllbGQuc3BsaXQoRE9UKVxuICAgICAgLCBmaXJzdCA9IHBhdGguc2hpZnQoKVxuICAgICAgLCB2YWwgPSB7fVxuICAgIHRoaXMucGF0aCh2YWwsIHBhdGgsIG9ialtmaWVsZF0pXG4gICAgZGVsZXRlIG9ialtmaWVsZF1cbiAgICBvYmpbZmlyc3RdID0gdmFsXG4gICAgZmllbGQgPSBmaXJzdFxuICB9XG4gIHJldHVybiBmaWVsZFxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0d28gbGlzdHMgY29udGFpbiBpZGVudGljYWwgY29udGVudFxuICogQG1ldGhvZCBjb21wYXJlQXJyYXlzXG4gKiBAcGFyYW0gIHtBcnJheXxPYmplY3R9IGEgICAgICAgICBUYWtlcyBhbnkgb2JqZWN0IHdpdGggLmxlbmd0aFxuICogQHBhcmFtICB7QXJyYXl8T2JqZWN0fSBiICAgICAgICAgVGFrZXMgYW55IG9iamVjdFxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICBrZXlzICAgICAgdXNlIE9iamVjdC5rZXlzIGZvciBiXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgIFRydWUvZmFsc2VcbiAqIEB0b2RvICAgICAgICAgICAgICAgICAgTWF5YmUgY2hhbmdlIHRpdGxlID0+IGNvbXBhcmVMaXN0c1xuICovXG5leHBvcnRzLmNvbXBhcmVBcnJheXMgPSBmdW5jdGlvbihhLCBiLCBrZXlzKSB7XG4gIHZhciBibCA9IGtleXMgPyBPYmplY3Qua2V5cyhiKS5sZW5ndGggOiBiLmxlbmd0aFxuICBpZiAoYS5sZW5ndGggIT09IGJsKSByZXR1cm4gZmFsc2VcbiAgZm9yICh2YXIgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoYVtpXSAhPSBiW2ldKSByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEdldHMgb2JqZWN0IGZyb20gc3BlY2lmaWVkIHBhdGguIFdoZW4gcGF0aCBpcyBhIHN0cmluZyBjaGVja3MgZm9yICdkb3Rub3RhdGlvbicuXG4gKiBAbWV0aG9kIGdldFxuICogQGV4YW1wbGVcbiAqIC8vIHJldHVybnMgJ2ZvbydcbiAqIHZhciBhID0ge2I6e2M6J2Zvbyd9fVxuICogVi51dGlsLm9iamVjdC5nZXQoYSwnYi5jJylcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgb2JqICBEZWZpbmVzIG9iamVjdCBvciBWLlZhbHVlXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9IHBhdGggRGVmaW5lcyBmaWVsZCB7c3RyaW5nfSBvciBwYXRoIHthcnJheXwnZG90LW5vdGF0aW9uJ31cbiAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgICBvYmpbcGF0aF18bmVzdGVkIG9iamVjdC92YWx1ZVxuICovXG5leHBvcnRzLmdldCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIHNlbGYpIHtcbiAgLy9UT0RPOiBtYWtlIG9uZSBpbnRlcmZhY2UgZm9yIGdldFxuXG4gIGlmICghb2JqIHx8ICFwYXRoKSByZXR1cm5cbiAgaWYgKCFzZWxmICYmIG9iai5fX3QgPT09IDQgJiYgIW9iai5fZmlsdGVyKSBvYmogPSBvYmouZnJvbVxuICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgaWYgKH5wYXRoLmluZGV4T2YoRE9UKSkge1xuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoRE9UKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKCFzZWxmICYmIG9ialtwYXRoXSAmJiBvYmpbcGF0aF0uZnJvbSkgfHwgb2JqW3BhdGhdXG4gICAgfVxuICB9XG4gIC8vc2VsZiBpcyB0b28gZmFyIGF3YXkgaW4gdGhlIGFyZ3VtZW50c1xuICByZXR1cm4gdGhpcy5wYXRoKG9iaiwgcGF0aCwgdm9pZCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHNlbGYpXG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBhbiBvYmplY3QgYW5kIG5vdCBhIGZ1bmN0aW9uICwgVi5PYmplY3Qgb3IgVi5CYXNlXG4gKiBAbWV0aG9kIGlzT2JqXG4gKiBAcGFyYW0gIHtPYmplY3R9ICBvYmogT2JqZWN0IHRvIGluc3BlY3RcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICBUcnVlL0ZhbHNlXG4gKi9cbmV4cG9ydHMuaXNPYmogPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiAob2JqIGluc3RhbmNlb2YgT2JqZWN0XG4gICAgJiYgdHlwZW9mIG9iaiAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICghdmlnb3VyLk9iamVjdCB8fCAhKG9iaiBpbnN0YW5jZW9mIHZpZ291ci5PYmplY3QpKVxuICAgICYmICghdmlnb3VyLkJhc2UgfHwgIShvYmogaW5zdGFuY2VvZiB2aWdvdXIuQmFzZSkpKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgbmV3IG9iamVjdCB3aXRoIHRoZSBzYW1lIHZhbHVlICwgdGFrZXMgY3VzdG9tIG9iamVjdHMgaW50byBhY2NvdW50IChuZXcgb2JqLmNvbnN0cnVjdG9yKCkpXG4gKiBAbWV0aG9kIGNsb25lXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iaiBPYmplY3QgdG8gY2xvbmVcbiAqIEByZXR1cm4ge09iamVjdH0gICAgIFJldHVybnMgY2xvbmVcbiAqL1xuZXhwb3J0cy5jbG9uZSA9IGZ1bmN0aW9uIChvYmosIGV4Y2x1ZGUsIHNoYWxsb3cpIHtcbiAgaWYgKHRoaXMuaXNPYmoob2JqKSkge1xuICAgIHZhciBjb3B5ID0gbmV3IG9iai5jb25zdHJ1Y3RvcigpXG4gICAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICAgIGlmKCFleGNsdWRlIHx8ICFleGNsdWRlW2ldKVxuICAgICAgICBjb3B5W2ldID0gIXNoYWxsb3dcbiAgICAgICAgICA/IHRoaXMuY2xvbmUob2JqW2ldLCBleGNsdWRlKVxuICAgICAgICAgIDogb2JqW2ldXG4gICAgfVxuICAgIHJldHVybiBjb3B5XG4gIH1cbiAgcmV0dXJuIG9ialxufTtcblxuLyoqXG4gKiBNZXJnZXMgb2JqZWN0IGIgaW50byBvYmplY3QgYSBhbmQgcmV0dXJucyBvYmplY3QgYVxuICogQG1ldGhvZCBtZXJnZVxuICogQHBhcmFtICB7T2JqZWN0fSBhIE9iamVjdCBhXG4gKiBAcGFyYW0gIHtPYmplY3R9IGIgT2JqZWN0IGJcbiAqIEByZXR1cm4ge09iamVjdH0gICBPYmplY3QgYVxuICovXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24gKGEsIGIsIG5vcmVmcywgb3ZlcndyaXRlKSB7XG4gIGZvciAodmFyIGkgaW4gYikge1xuICAgIHZhciBhaXNvYmogPSB1dGlsLmlzT2JqKGFbaV0pXG4gICAgICAsIGJpc29iaiA9IHV0aWwuaXNPYmooYltpXSlcblxuICAgIGlmIChhaXNvYmogJiYgYmlzb2JqKSB7XG4gICAgICB1dGlsLm1lcmdlKGFbaV0sIGJbaV0sIG5vcmVmcywgb3ZlcndyaXRlKVxuICAgIH0gZWxzZSBpZighbm9yZWZzIHx8ICFiaXNvYmope1xuICAgICAgaWYoIG92ZXJ3cml0ZSA9PT0gdm9pZCAwXG4gICAgICAgfHwgIShpIGluIGEpXG4gICAgICAgfHwgdHlwZW9mIG92ZXJ3cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBvdmVyd3JpdGUoYVtpXSwgYltpXSlcbiAgICAgICAgKXtcbiAgICAgICAgYVtpXSA9IGJbaV1cbiAgICAgIH1cblxuICAgIH1lbHNle1xuICAgICAgYVtpXSA9IGJbaV0gaW5zdGFuY2VvZiBBcnJheSA/IFtdIDoge31cbiAgICAgIHV0aWwubWVyZ2UoYVtpXSwgYltpXSwgbm9yZWZzLCBvdmVyd3JpdGUpXG4gICAgfVxuICB9XG4gIHJldHVybiBhXG59XG5cbi8vIGV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKGEsIGIsIGJGcm9tLCBqKSB7XG4vLyAgIHZhciBzYW1lID0gdHJ1ZTtcbi8vICAgaWYoYiBpbnN0YW5jZW9mIE9iamVjdCkge1xuLy8gICAgIGZvcih2YXIgaSBpbiBiKSB7XG4vLyAgICAgICBpZihhW2ldIT09dm9pZCAwKSB7XG4vLyAgICAgICAgIGlmKGV4cG9ydHMucmVzb2x2ZShhW2ldLGJbaV0sYkZyb20gPyBiRnJvbVtpXSA6IGJbaV0saSkpIHtcbi8vICAgICAgICAgICBpZihiRnJvbSkge1xuLy8gICAgICAgICAgICAgZGVsZXRlIGJGcm9tW2ldXG4vLyAgICAgICAgICAgfVxuLy8gICAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICAgIHNhbWUgPSBmYWxzZVxuLy8gICAgICAgICB9XG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICBzYW1lID0gZmFsc2Vcbi8vICAgICAgIH1cbi8vICAgICB9XG4vLyAgICAgaWYoc2FtZSkge1xuLy8gICAgICAgaWYoIShiRnJvbSYmaiE9PXZvaWQgMCkpIHJldHVybiB0cnVlXG4vLyAgICAgICBkZWxldGUgYkZyb21bal1cbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIHNhbWU7XG4vLyAgIH0gZWxzZSB7XG4vLyAgICAgaWYoYT09Yikge1xuLy8gICAgICAgaWYoYkZyb20mJmohPT12b2lkIDApIHtcbi8vICAgICAgICAgZGVsZXRlIGJGcm9tW2pdXG4vLyAgICAgICB9XG4vLyAgICAgICByZXR1cm4gdHJ1ZVxuLy8gICAgIH1cbi8vICAgfVxuLy8gfVxuXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbihhLCBiLCBiRnJvbSwgaikge1xuICAvLyBjb25zb2xlLmxvZygnbG9scmVzb2x2ZVxcbicsYkZyb20pXG4gIHZhciBzYW1lID0gdHJ1ZTtcbiAgaWYoYiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGZvcih2YXIgaSBpbiBiKSB7XG4gICAgICBpZihhW2ldIT09dm9pZCAwKSB7XG4gICAgICAgIGlmKGV4cG9ydHMucmVzb2x2ZShhW2ldLGJbaV0sKGJGcm9tIT09dm9pZCAwICYmIGJGcm9tIT09bnVsbCkgPyBiRnJvbVtpXSA6IGJbaV0saSkpIHtcbiAgICAgICAgICBpZihiRnJvbSE9PXZvaWQgMCAmJiBiRnJvbSE9PW51bGwpIHtcbiAgICAgICAgICAgIGlmKGJGcm9tW2ldPT09bnVsbCkge1xuICAgICAgICAgICAgICBzYW1lID0gZmFsc2VcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBiRnJvbVtpXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzYW1lID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2FtZSA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmKHNhbWUpIHtcbiAgICAgIGlmKCEoYkZyb20mJmohPT12b2lkIDApKSByZXR1cm4gdHJ1ZVxuICAgICAgZGVsZXRlIGJGcm9tW2pdXG4gICAgfVxuICAgIHJldHVybiBzYW1lO1xuICB9IGVsc2Uge1xuICAgIGlmKGE9PWIpIHtcbiAgICAgIGlmKGJGcm9tJiZqIT09dm9pZCAwKSB7XG4gICAgICAgIGRlbGV0ZSBiRnJvbVtqXVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIHZhbHVlIHRvIGFycmF5IGlmIGl0IGlzIG5vdCBjb250YWluZWQgaW4gYXJyYXksIGV4ZWN1dGVzIGhhbmRsZXIgb24gZW5jb3VudGVyaW5nIHZhbCBpbiBhcnJheVxuICogQG1ldGhvZCBpbmNsdWRlXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgb2JqICAgICAgIFRha2VzIGFueSBvYmplY3Qgd2l0aCAubGVuZ3RoXG4gKiBAcGFyYW0gIHsqfSAgICAgICAgICAgICAgdmFsICAgICAgIFZhbHVlIHRvIGFkZFxuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgIFtoYW5kbGVyXSBGdW5jdGlvbiB0byBleGVjdXRlIG9uIGVuY291bnRlcmluZyB2YWwgaW4gYXJyYXlcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBhcnIgICAgICAgSW5jbHVkZSBlbGVtZW50cyBvZiB2YWwgc2VwYXJhdGVseSByYXRoZXIgdGhhbiBpbmNsdWRpbmcgdmFsIGl0c2VsZlxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICBUcnVlL2ZhbHNlXG4gKi9cbmV4cG9ydHMuaW5jbHVkZSA9IGZ1bmN0aW9uIChvYmosIHZhbCwgaGFuZGxlciwgYXJyKSB7XG5cbiAgaWYoYXJyICYmIHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIHJldCA9IGZhbHNlXG4gICAgZm9yKHZhciBpID0gMCAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmV0ID0gZXhwb3J0cy5pbmNsdWRlKG9iaiwgdmFsW2ldLCBoYW5kbGVyKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICB2YXIgaSA9IDBcbiAgICAsIGwgPSBvYmoubGVuZ3RoXG4gICAgLCBmaWVsZFxuICAgICwgY2hlY2tcblxuICBpZiAob2JqLl9fdCA9PT0gMSkge1xuICAgIGZvciAoO2kgPCBsOyBpKyspIHtcbiAgICAgIGZpZWxkID0gY2hlY2sgPSBvYmpbaV1cbiAgICAgIGlmIChjaGVjay5fX3QgPT09IDQpIGNoZWNrID0gY2hlY2suZnJvbVxuICAgICAgaWYgKGNoZWNrID09PSB2YWwgfHwgY2hlY2sudmFsID09PSB2YWwpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIGhhbmRsZXIoZmllbGQpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBvYmoucHVzaCh2YWwpXG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIGZvciAoO2kgPCBsOyBpKyspIHtcbiAgICAgIGlmIChvYmpbaV0gPT09IHZhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgb2JqLnB1c2godmFsKVxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZXhwb3J0cy5jaGFuZ2VUeXBlID0gZnVuY3Rpb24oIG9iaiApIHtcbiAgdmFyIHJlc3VsdFxuICBpZihvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJlc3VsdCA9IHt9XG4gICAgZm9yKHZhciBpPTAsbGVuPW9iai5sZW5ndGg7aTxsZW47aSsrKSB7XG4gICAgICByZXN1bHRbaV09b2JqW2ldXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IFtdXG4gICAgZm9yKHZhciBpIGluIG9iaikge1xuICAgICAgcmVzdWx0LnB1c2gob2JqW2ldKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogRW5zdXJlcyBhIHZhbHVlIGlzIG5vdCBvciBjb250YWlucyBubyBWLk9iamVjdHMsIG9ubHkgdGhlaXIgXCJyYXdcIiB2ZXJzaW9uc1xuICogVGhpcyBuZWVkcyB0byBiZSB1bmlmaWVkIHdpdGggY29udmVydCwgb3IgYXQgbGVhc3QgZ2V0IGEgYmV0dGVyIG5hbWUuXG4gKiBAbWV0aG9kIHJhd1xuICogQHBhcmFtICB7Kn0gICB2YWwgICB0aGUgdmFsdWUgdG8gYmUgcHJvY2Vzc2VkXG4gKiBAcmV0dXJuIHsqfSAgICAgICAgIHRoZSBwcm9jZXNzZWQgdmFsdWVcbiAqL1xuZXhwb3J0cy5yYXcgPSBmdW5jdGlvbiggdmFsLCBycGFyYW1zICkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIHZpZ291ci5PYmplY3QpIHtcbiAgICAgIHJldHVybiB2YWwucmF3XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHRcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICByZXN1bHQgPSBbXVxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICByZXN1bHRbaV0gPSB0aGlzLnJhdyh2YWxbaV0sIHJwYXJhbXMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHt9XG4gICAgICAgIGZvciAodmFyIGYgaW4gdmFsKSB7XG4gICAgICAgICAgcmVzdWx0W2ZdID0gdGhpcy5yYXcodmFsW2ZdLCBycGFyYW1zKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWxcbiAgfVxufVxuXG4vL2FkZCBsZXZlbCBhbmQgc3RvcHMgZm9yIGNlcnRhaW4gYnJhbmNoZXNcbmV4cG9ydHMud2FsayA9IGZ1bmN0aW9uKG9iaiwgZm4gKSB7XG4gIGZvcih2YXIgaSBpbiBvYmopIHtcbiAgICBpZihvYmpbaV0gaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGlmKCFmbihpLCBvYmpbaV0sIG9iaiwgdHJ1ZSkpIHtcbiAgICAgICAgaWYoZXhwb3J0cy53YWxrKG9ialtpXSwgZm4pKSByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYoZm4oaSwgb2JqW2ldLCBvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuY2hlY2tQYXJlbnRGYWN0b3J5ID0gZnVuY3Rpb24oIHBhcmVudEZpZWxkICkge1xuICByZXR1cm4gZnVuY3Rpb24oZmllbGQsIGdldCwgbGlua3MsIG1hdGNoKSB7XG4gICAgaWYoZ2V0JiZnZXQhPT10cnVlKSB7XG4gICAgICBtYXRjaCA9IGdldFxuICAgICAgZ2V0ID0gZmFsc2VcbiAgICB9XG4gICAgdmFyIGZpZWxkcyA9IGZpZWxkIGluc3RhbmNlb2Ygdmlnb3VyLk9iamVjdCA/IGZhbHNlIDogZmllbGQsXG4gICAgICBjdXJyID0gdGhpcyxcbiAgICAgIGZvdW5kO1xuICAgIHdoaWxlIChjdXJyKSB7XG4gICAgICBmb3VuZCA9IGZpZWxkcyA9PT0gZmFsc2UgPyBjdXJyID09PSBmaWVsZCA6IGV4cG9ydHMuZ2V0KGN1cnIsIGZpZWxkcywgIWxpbmtzKTtcbiAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICBpZihtYXRjaCkge1xuICAgICAgICAgIGlmKG1hdGNoID09PSBmb3VuZCB8fCAoZm91bmQgaW5zdGFuY2VvZiB2aWdvdXIuT2JqZWN0KSAmJiBmb3VuZC52YWwgPT09IG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gIWdldCAmJiBmaWVsZHMgPyBjdXJyIDogZm91bmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiAhZ2V0ICYmIGZpZWxkcyA/IGN1cnIgOiBmb3VuZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY3VyciA9IGN1cnJbcGFyZW50RmllbGRdO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmRpc2pvaW4gPSBmdW5jdGlvbiBkaXNqb2luKGEsIGIsIGNoZWNrKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdkaXNqb2luIScpXG4gIHZhciBmbmNoZWNrID0gdHlwZW9mIGNoZWNrID09PSAnZnVuY3Rpb24nXG4gIFxuICBhID0gZ2V0RW5kcG9pbnQoYSlcbiAgYiA9IGdldEVuZHBvaW50KGIpXG5cbiAgYS5lYWNoKGZ1bmN0aW9uKCl7XG4gICAgdmFyIGl0ZW1fYSA9IHRoaXNcbiAgICB2YXIgaXRlbV9hX2Zyb20gPSBpdGVtX2EuZnJvbVxuICAgIHZhciByZW1vdmVcbiAgICBiLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIHZhciBpdGVtX2IgPSB0aGlzXG4gICAgICB2YXIgaXRlbV9iX2Zyb20gPSBpdGVtX2IuZnJvbVxuICAgICAgXG4gICAgICBcbiAgICAgIGlmKGZuY2hlY2spe1xuICAgICAgICByZW1vdmUgPSBjaGVjayhpdGVtX2FfZnJvbSwgaXRlbV9iX2Zyb20pXG4gICAgICB9IGVsc2UgaWYoY2hlY2sgPT09IHRydWUpe1xuICAgICAgICByZW1vdmUgPSBpdGVtX2FfZnJvbSA9PT0gaXRlbV9iX2Zyb21cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdjb21wYXJlIGEnLCBpdGVtX2FfZnJvbS5yYXcsICd0byBiJywgaXRlbV9iX2Zyb20ucmF3KVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnZmllbGQnLCBjaGVjaylcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2E6JywgaXRlbV9hX2Zyb21bY2hlY2tdLnZhbClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2I6JywgaXRlbV9iX2Zyb21bY2hlY2tdLnZhbClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NhbWU6JywgaXRlbV9hX2Zyb21bY2hlY2tdLnZhbCA9PT0gaXRlbV9iX2Zyb21bY2hlY2tdLnZhbClcblxuICAgICAgICByZW1vdmUgPSBpdGVtX2FfZnJvbVtjaGVja10gJiYgaXRlbV9iX2Zyb21bY2hlY2tdICYmXG4gICAgICAgICAgaXRlbV9hX2Zyb21bY2hlY2tdLnZhbCA9PT0gaXRlbV9iX2Zyb21bY2hlY2tdLnZhbFxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZVxuICAgIH0pXG4gICAgaWYocmVtb3ZlKXtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdZRVMgQ0hFQ0sgUkVNT1ZFJylcbiAgICAgIC8vIFRPRE86IFxuICAgICAgaXRlbV9hLnJlbW92ZSgpXG4gICAgfVxuICB9KVxuXG59XG5cbmZ1bmN0aW9uIGdldEVuZHBvaW50KG9iail7XG4gIHdoaWxlKG9iaiAmJiBvYmouX190ID09PSA0ICYmICFvYmouX2ZpbHRlcil7XG4gICAgb2JqID0gb2JqLl92YWxcbiAgfVxuICByZXR1cm4gb2JqXG59XG4iLCIvL3Byb2Nlc3Nlc1xudmFyIHZPYmplY3QgPSByZXF1aXJlKCcuLi9vYmplY3QnKVxuXG4vLyBjb25zb2xlLmxvZygnaW5pdCBwcm9jZXNzIScpXG5cbm1vZHVsZS5leHBvcnRzID0ge31cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcmVxdWlyZSgnLi8nKVxuICAsIFYgPSByZXF1aXJlKCcuLi8nKVxuLyoqXG4gKiBTZXRzdG9yZXMgYXJlIHVzZWQgdG8gYXZvaWQgdXBkYXRlcyB0cm91Z2hvdXQgcHJvdG90eXBlIGNoYWlucyBmb3IgY2hhbmdlcyBvZiBmaWVsZHMgb24gb2JqZWN0c1xuICogSXQgdXNlcyB0d28gZmllbGRzXG4gKiAgIC5fXyB0byBpbmRpY2F0ZSBvd24gdmFsdWVzIGZvciBwaWVjZXMgb2YgYW4gb2JqZWN0IGluaGVyaXRlZCB0cm91Z2ggdGhlIHByb3RvdHlwZSBjaGFpblxuICogICAuXyBpcyB0aGUgcmVmZW5jZSBiYWNrIHRvIHRoZSBvYmplY3RzIGFzIHN0ZSBpbiB0aGUgcHJvdG90eXBlXG4gKiBAY29uc3RydWN0b3Igc2V0c3RvcmVcbiAqL1xuZXhwb3J0cy5zZXRzdG9yZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICF0aGlzLl9fICkgdGhpcy5fXyA9IHt9XG59XG5cbi8vVE9ETzogcmVjb25zdHJ1Y3QgdmFsdWUgdXNpbmcgcGllY2VzIG9mIG9iamVjdHMgaW4gX19cblxuZXhwb3J0cy5nZXRTdG9yZSA9IGZ1bmN0aW9uKCBuYW1lICkge1xuICByZXR1cm4gdGhpcy5fXyBcbiAgICAgICAgICA/ICggdGhpcy5fX1tuYW1lXSAhPT0gdm9pZCAwIFxuICAgICAgICAgICAgPyB0aGlzLl9fW25hbWVdIFxuICAgICAgICAgICAgOiB0aGlzLl9bbmFtZV1cbiAgICAgICAgICAgICkgXG4gICAgICAgICAgOiB0aGlzLl8gJiYgdGhpcy5fW25hbWVdXG59XG5cbmZ1bmN0aW9uIGV4dGVuc2lvbnMoIGV4dGVuZCwgZm4sIGJhc2UsIGFyZ3MsIGV4dGVuZGVkICkge1xuICAgIFxuICBpZih3aW5kb3cuJFRFU1QpIHtcbiAgICBjb25zb2xlLmxvZygxMiwgZXh0ZW5kKVxuICB9XG5cbiAgaWYoICFleHRlbmQuZXh0ZW5zaW9ucyApIFxuICB7XG4gICAgaWYoYmFzZSkge1xuICAgICAgZXh0ZW5kLmV4dGVuc2lvbnMgPSBbXVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhleHRlbmQpXG4gICAgICBpZihWLk9iamVjdCAmJiBleHRlbmQgaW5zdGFuY2VvZiBWLk9iamVjdCApIHtcbiAgICAgICAgdXRpbC5kZWZpbmUoIGV4dGVuZCwgJ2V4dGVuc2lvbnMnLFtdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9nZWJydWlrIGRlemUgZXh0ZW5zaW9uIHN0eWxvXG4gICAgICAgIHV0aWwuZGVmaW5lKCBleHRlbmQsICdleHRlbnNpb25zJyx7dmFsOltdLCBzZXRDbGFzczp0cnVlfSApXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gY29uc29sZS5sb2coICdFWFRFTkQnLnJlZCwgZXh0ZW5kLmV4dGVuc2lvbnMsIGJhc2UsIGZuLCB0aGlzLCBleHRlbmRlZCApXG5cbiAgaWYoIHV0aWwuY2hlY2tBcnJheSggZXh0ZW5kLmV4dGVuc2lvbnMsIHRoaXMgKT09PWZhbHNlICkgXG4gIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnRVhURU5EIC0yJy5yZWQsIHRoaXMgKVxuXG4gICAgaWYoICFleHRlbmRlZCApIGV4dGVuZC5leHRlbnNpb25zID0gWyB0aGlzIF0uY29uY2F0KCBleHRlbmQuZXh0ZW5zaW9ucyApIFxuXG4gICAgICAvLyBjb25zb2xlLmxvZyggJ0VYVEVORCAtMycucmVkLCBleHRlbmQuZXh0ZW5zaW9ucyApXG4gICAgICAvL3NvbWV0aGluIHdlaXJkIVxuXG4gICAgLy8gY29uc29sZS5sb2coICdFWFRFTkQgLTMnLnJlZCwgdGhpcywgZXh0ZW5kLCBleHRlbmQuZXh0ZW5zaW9ucy5sZW5ndGggKVxuXG4gICAgdmFyIG15QXJncyA9IHV0aWwuYXJnKCBhcmdzIClcbiAgICBpZiggYmFzZSAmJiAhZXh0ZW5kZWQgKSB7XG4gICAgICBteUFyZ3NbMF0gPSBiYXNlXG4gICAgfVxuICAgIGlmKHdpbmRvdy4kVEVTVCkgY29uc29sZS5lcnJvcignPz94eHg/JywgbXlBcmdzLCBmbiwgdGhpcylcbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkoIHRoaXMsIG15QXJncyApIC8vdGhpcyBpcyB0aGUgYXBwLCBleHRlbmQgaXMgdGhlIGV4dGVuc2lvbiBcbiAgICBpZih3aW5kb3cuJFRFU1QsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH0gZWxzZSB7XG4gICAgaWYod2luZG93LiRURVNUKSBjb25zb2xlLmVycm9yKCc/Pz8nKVxuICB9XG5cbn1cblxuZXhwb3J0cy5leHRlbmQgPSBmdW5jdGlvbigpIHtcblxuXG4gIHZhciBleHRlbmRBcnJheSA9IHV0aWwuYXJnKCBhcmd1bWVudHMgKVxuXG4gIHJldHVybiBmdW5jdGlvbihleHRlbmQpIHtcblxuICAgIGlmKHdpbmRvdy4kVEVTVCkgY29uc29sZS5sb2coJzEwIC0tLT4nLCBleHRlbmQpXG5cbiAgICB2YXIgYmFzZVxuICAgICAgLCBwcm90b1xuXG4gICAgaWYoIHR5cGVvZiBleHRlbmQgPT09ICdmdW5jdGlvbicgKSBcbiAgICB7XG4gICAgICBpZiggVi5CYXNlICYmICggZXh0ZW5kLnByb3RvdHlwZSBpbnN0YW5jZW9mIFYuQmFzZSApICkge1xuICAgICAgICBiYXNlID0gZXh0ZW5kLmJhc2VcbiAgICAgICAgcHJvdG8gPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm90byA9IGV4dGVuZC5wcm90b3R5cGVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoIFYuQmFzZSAmJiAoIGV4dGVuZCBpbnN0YW5jZW9mIFYuQmFzZSApICkgXG4gICAge1xuICAgICAgcHJvdG8gPSBleHRlbmRcbiAgICB9XG5cbiAgICBmb3JcbiAgICAoIFxuICAgICAgdmFyIGZuXG4gICAgICAgICwgcmV0XG4gICAgICAgICwgYXJncyA9IHV0aWwuYXJnKCBhcmd1bWVudHMgKVxuICAgICAgICAsIGV4dGVuZEFyclxuICAgICAgICAsIHhBcmdcbiAgICAgICAgLCBpID0gMFxuICAgICAgICAsIGxlbiA9IGV4dGVuZEFycmF5Lmxlbmd0aFxuICAgICAgICA7IGkgPCBsZW5cbiAgICAgICAgOyBpICsrIFxuICAgICkgXG4gICAgeyAgICBcbiAgICAgIGlmKGV4dGVuZEFycmF5W2ldIGluc3RhbmNlb2YgQXJyYXkpIFxuICAgICAge1xuICAgICAgICBleHRlbmRBcnIgPSBleHRlbmRBcnJheVtpXVswXVxuICAgICAgICB4QXJnID0gdXRpbC5hcmcoZXh0ZW5kQXJyYXlbaV0sMSlcbiAgICAgICAgeEFyZy51bnNoaWZ0KGV4dGVuZClcbiAgICAgIH0gZWxzZSBcbiAgICAgIHtcbiAgICAgICAgeEFyZyA9IGFyZ3NcbiAgICAgICAgZXh0ZW5kQXJyID0gZXh0ZW5kQXJyYXlbaV1cbiAgICAgIH1cblxuICAgICAgaWYod2luZG93LiRURVNUKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCcxMScsICBleHRlbmRBcnIuZXh0ZW5kID8gIGV4dGVuZEFyciA6IHRoaXMsIGJhc2UgfHwgcHJvdG8gIClcbiAgICAgIH1cblxuICAgICAgcmV0ID0gZXh0ZW5zaW9ucy5jYWxsIFxuICAgICAgKCBleHRlbmRBcnIuZXh0ZW5kID8gIGV4dGVuZEFyciA6IHRoaXMgXG4gICAgICAsIGJhc2UgfHwgcHJvdG8gfHwgZXh0ZW5kXG4gICAgICAsIGV4dGVuZEFyci5leHRlbmQgfHwgIGV4dGVuZEFyclxuICAgICAgLCBiYXNlXG4gICAgICAsIHhBcmdcbiAgICAgICwgZXh0ZW5kQXJyLmV4dGVuZCA/IHRydWUgOiBmYWxzZSBcbiAgICAgICkgXG4gICAgICB8fCBleHRlbmRcblxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxufVxuXG4vKipcbiAqIEFkZCBpcyB1c2VkIGFzIGEgc2hvcnRjdXQgbWV0aG9kIGZvciBPYmplY3QuZGVmaW5lUHJvcGVydHkgYW5kIGV4dGVuZHMgc2V0c3RvcmUgZnVuY3Rpb25hbGl0eSB0byBub3JtYWwgcHJvdG90eXBlc1xuICogQG1ldGhvZCBhZGRcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgICAgb2JqICBXaGVuIG9iaiBpcyBhIGNvbnN0cnVjdG9yIGl0IHNlbGVjdHMgb2JqLnByb3RvdHlwZSwgd2hlbiBvYmogaXMgYSBub3JtYWwgb2JqZWN0IHRoaXMgaXMgdXNlZCBpbnN0ZWFkXG4gKiBAcGFyYW0gIHtTdHJpbmd8QXJyYXl9ICAgIG5hbWUgV2hlbiBuYW1lIGlzIGEgc3RyaW5nIGl0IGFkZHMgdGhlIG5hbWUgZm9yIHRoZSBvYmplY3QsIHdoZW4gbmFtZSBpcyBhIGFycmF5IGRvIHRoZSBzYW1lIHNldHRpbmcgZm9yIGVhY2ggbmFtZVxuICogQHBhcmFtICB7T2JqZWN0fEZ1bmN0aW9ufSB2YWwgIFdoZW4gdmFsIGlzIGFuIG9iamVjdCAsIHVzZSB0aGlzIG9iamVjdCBmb3IgT2JqZWN0LmRlZmluZVByb3BlcnR5IHdpdGggZGVmYXVsdCBmb3IgZW51bW1lcmFibGU6ZmFsc2UsIHdoZW4gb2JqZWN0IGlzIGVtcHR5IGFkZHMge3ZhbHVlOnt9LGVubnVtZXJhYmxlOmZhbHNlfSwgd2hlbiB2YWwgaXMgYSBmdW5jdGlvbiBpdCBhdXRvbWF0aWNhbGx5IHdyYXBzIGEgcHJvcGVydHkgZGVmaW5pdGlvbiBvYmplY3Qgd2l0aCB7dmFsdWU6IHZhbCAsIGVudW1tZXJhYmxlOmZhbHNlfSwgd2hlbiB2YWwgaXMgbm90IGEgZnVuY3Rpb24gYW5kIG5vdCBhbiBvYmplY3QgKGJvb2xlYW4sIHN0cmluZywgbnVtYmVyKSBhZGRzIHNwZWNpYWwgc2V0c3RvcmUgdmFsdWVcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgICAgICAgW3NldF0gIEFkZHMgY3VzdG9tIHNldHRlcnMgdG8gYSBzZXRzdG9yZSBvYmplY3QsIHdoZW4gc2V0IGlzIGEgc3RyaW5nIHRoZSBhZGQgZnVuY3Rpb25zIGludGVycHJldHMgdGhlIGFyZ3VtZW50cyBhcyBuYW1lIDogcHJvcGVydHkgZGVmaW5pdGlvbiBwYWlyc1xuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgICBbZ2V0XSAgQWRkcyBjdXN0b20gZ2V0dGVycyB0byBhIHNldHN0b3JlIG9iamVjdFxuICogQFxuICovXG5leHBvcnRzLmRlZmluZSA9IGZ1bmN0aW9uIChvYmosIG5hbWUsIHZhbCwgc2V0LCBnZXQsIGlkKSB7XG4gIGlmICh0eXBlb2Ygc2V0ID09PSAnc3RyaW5nJykge1xuICAgIHZhciBfYXJncyA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICBmb3IgKHZhciBpID0gMSwgbCA9IF9hcmdzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMikge1xuICAgICAgZXhwb3J0cy5kZWZpbmUob2JqLCBfYXJnc1tpXSwgX2FyZ3NbaSArIDFdKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAobmFtZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGV4cG9ydHMuZGVmaW5lKG9iaiwgbmFtZVtpXSwgdmFsKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyB8fCB2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB2YWwgPSB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdmFsIHx8ICggISh2YWwgaW5zdGFuY2VvZiBPYmplY3QpIHx8IHZhbC5zZXRDbGFzcyAgKSkge1xuXG4gICAgICAgIGlmKCB2YWwgJiYgdmFsLnNldENsYXNzICkge1xuICAgICAgICAgIHZhbCA9IHZhbC52YWxcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcm90byA9IG9iai5wcm90b3R5cGUgfHwgb2JqXG5cblxuICAgICAgICAvL1xuXG4gICAgICAgIC8vVE9ETzogbm90IGEgZ29vZCBzb2x1dGlvbiAtLSBoYXMgdG8gcmVkZWZpbmUgY29uc3RhbnRseSAoIHRvbyBoZWF2eSApXG4gICAgICAgIC8vIGlmKCBwcm90byAhPT0gb2JqLnByb3RvdHlwZSAmJiBwcm90by5fICkge1xuICAgICAgICAvLyAgICAvL1RPRE86IHRoaXMgY2FuIGdvIGNvbXBsZXRlbHkgd3Jvbmcgd2hlbiB5b3UgZXhwZWN0IGluaGVyaXRhbmNlIG5vdCB0byBicmVhayB3aGVuIG1ha2luZyBhIG5ldyBjbGFzcyFcbiAgICAgICAgLy8gICAgaWYoIHByb3RvLmNvbnN0cnVjdG9yLnByb3RvdHlwZS5fID09PSBwcm90by5fICkge1xuICAgICAgICAvLyAgICAgICB2YXIgb2xkID0gcHJvdG8uX1xuICAgICAgICAvLyAgICAgICBwcm90by5fID0ge31cbiAgICAgICAgLy8gICAgICAgZm9yKHZhciBrZXkgaW4gb2xkKSB7XG4gICAgICAgIC8vICAgICAgICAgcHJvdG8uX1trZXldID0gb2xkW2tleV1cbiAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAvLyAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgXG4gICAgICAgIC8vbWF5YmUgbWFrZSBpbnRvIGEgbWV0aG9kXG4gICAgICAgIGlmKCBpZCkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdERUZJTkUhIERPIElUJy5yZWQuaW52ZXJzZSwgbmFtZSwgaWQsIHByb3RvKVxuICAgICAgICAgIGlmICghcHJvdG8uX18pIHByb3RvLl9fID0ge31cbiAgICAgICAgICBwcm90by5fX1tuYW1lXSA9IHZhbFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghcHJvdG8uXykgcHJvdG8uXyA9IHt9XG4gICAgICAgICAgcHJvdG8uX1tuYW1lXSA9IHZhbFxuICAgICAgICB9XG5cblxuXG4gICAgICBcblxuICAgICAgICAvL2lmIHByb3RvIGlzIG5vdCBhIHByb3RvdHlwZSAoaG93IHRvIGNoZWNrPykgdGhlbiB1c2UgX18gcGVyaGFwcz9cblxuICAgICAgICAvL21vZXQgaGllciBuaWV0IGFsdGlqZCB6ZSBlaWd1aCB3b3JkZW4gZ2VtYWFrdD9cblxuICAgICAgIC8vZGVmYXVsdCBkaXQgaXMgZWlnZW5saWprIGhldCBlbmlnZSBkYXQgbWlzIGdhYXRcblxuICAgICAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIGV4cG9ydHMuc2V0c3RvcmUuY2FsbCh0aGlzKVxuICAgICAgICAgICAgICAvL1RPRE86IGZpeCBjbG9zdXJlIGZvciB2YWxcbiAgICAgICAgICAgICAgaWYgKHZhbCB8fCB2YWwgPT09IDAgfHwgdmFsID09PSBmYWxzZSkgdGhpcy5fX1tuYW1lXSA9IHZhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICwgd3NldCA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgICB2YWwgPSBzZXQuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgICBzZXR0ZXIuY2FsbCh0aGlzLCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICwgZ2V0dGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHBvcnRzLmdldFN0b3JlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLCB3Z2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBwcm9wID0gZ2V0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgIHJldHVybiBnZXQuY2FsbCh0aGlzLCBwcm9wKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB2YWwgPSB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgIGdldDogZ2V0ID8gd2dldCA6IGdldHRlcixcbiAgICAgICAgICBzZXQ6IHNldCA/IHdzZXQgOiBzZXR0ZXJcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKCF2YWwuZW51bWVyYWJsZSkge1xuICAgICAgICBpZiAodXRpbC5lbXB0eSh2YWwpKSB2YWwudmFsdWUgPSB7fVxuICAgICAgICB2YWwuY29uZmlndXJhYmxlID0gdHJ1ZVxuICAgICAgICB2YWwuZW51bWVyYWJsZSA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmoucHJvdG90eXBlIHx8IG9iaiwgbmFtZSwgdmFsKVxuXG4gICAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLnByb3RvdHlwZSB8fCBvYmosIG5hbWUsIHZhbClcbiAgICAgIC8vbWF5ZWIgZG8gYm90aD9cbiAgICB9XG4gIH1cbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgYmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKVxuICAsIFZhbHVlID0gcmVxdWlyZSgnLi8nKVxuICAsIG9iamVjdFNldCA9IHJlcXVpcmUoJy4uL29iamVjdCcpLnNldFxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLy8gLCByYWYgPSByZXF1aXJlKCcuLi9icm93c2VyL2FuaW1hdGlvbi9yYWYnKVxuXG5leHBvcnRzLmNsb25lbGlzdCA9IFtcbiAgWyAnX2Jhc2UnLCBmYWxzZSBdLCAnX2NhbGxlcicsICdfcHJvcCcsICdfbmFtZScsICdfc2tpcCdcbl1cblxuZnVuY3Rpb24gcmVzb2x2ZUxpc3RlbmVyKCBsaXN0ZW5lciwgdmFsLCBwcm9wLCBpbnN0YW5jZSApIHtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgaWYgKCBsaXN0ZW5lci5fYmluZCA9PT0gaW5zdGFuY2UgJiYgbGlzdGVuZXIuX190ID09PSA0ICkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2JpbmQgcmVzb2x2ZScucmVkLmJvbGQsIHZhbCApXG4gICAgICBsaXN0ZW5lci52YWwgPSB2YWxcbiAgICB9XG4gICAgZWxzZSBpZiAoIWxpc3RlbmVyLl9iaW5kICkgeyBcblxuICAgICAgaWYoIGxpc3RlbmVyLl9fdCA9PT0gNCAmJiBsaXN0ZW5lci5fdmFsID09PSBwcm9wIClcbiAgICAgIHtcbiAgICAgICAgLy8gbGlzdGVuZXIudmFsID0gXG4gICAgICAgIGxpc3RlbmVyLnZhbCA9IHZhbFxuICAgICAgICBjb25zb2xlLmxvZygnLS0tLS0tLS0tLScsIGxpc3RlbmVyLl9fdCApXG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1bHRpbWF0ZSB1Z2x5IScpXG4gICAgICAgIHZhbC5hZGRMaXN0ZW5lcihsaXN0ZW5lcikgLy9kaXQgZml4ZWQgIFxuICAgICAgfVxuXG4gICAgICAvL1RPRE86IGltcGxlbWVudCB0aGlzIGxhdGVyXG4gICAgICAvLyBpZiggbGlzdGVuZXIgaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgIC8vICAgdmFyIG1hcmsgPSBsaXN0ZW5lclsxXVxuICAgICAgLy8gICBpZiggbWFyayApIHtcbiAgICAgIC8vICAgICBpZiggbWFyayA9PT0gcHJvcC5fYmFzZSB8fCBtYXJrID09PSBpbnN0YW5jZSB8fCBpbnN0YW5jZSBpbnN0YW5jZW9mIG1hcmsuX2NsYXNzICkge1xuICAgICAgLy8gICAgICAgLy9UT0RPOiBwcm9wYWJseSBuZWVkIHRvIGNoZWNrIGZvciBpbmhlcml0YW5jZSAoIG1hcmsgaW5zdGFuY2Ugb2YgcHJvcC5fYmFzZSlcbiAgICAgIC8vICAgICAgIC8vIGNvbnNvbGUubG9nKCdtYXJrIHJlc29sdmUnLmdyZWVuLmludmVyc2UsIGxpc3RlbmVyKVxuICAgICAgLy8gICAgICAgLy8gdmFsLmFkZExpc3RlbmVyKFsgbGlzdGVuZXJbMF0gLCBpbnN0YW5jZSBdLCB0cnVlKVxuICAgICAgLy8gICAgIH1cbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuXG4gICAgICBcbiAgICAgIC8vIHZhbC5hZGRMaXN0ZW5lcihfbGlzdGVuZXJzW2ldKVxuICAgIH1cbiAgfVxufVxuXG4vLyBmdW5jdGlvbiByZXNvbHZlTGlzdGVuZXIoICkge1xuXG4vLyB9XG5cbi8qKlxuICogVi52YWx1ZS5iYXNlLnR5cGVcbiAqIERlZmluZXMgdGhlIGJhc2UgdHlwZSB1c2VkIGluIFYuVmFsdWVcbiAqIEB0eXBlXG4gKi9cbmV4cG9ydHMudHlwZSA9IHtcbiAgdHlwZTogVmFsdWUsXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoYXQgdGhpcyB0eXBlIHdpbGwgZG8gb24gY3JlYXRpb24uXG4gICAqIEBtZXRob2QgY3JlYXRlXG4gICAqIEBwYXJhbSAgeyp9IHZhbCAgICAgICAgICAgICAgVmFsdWVcbiAgICogQHBhcmFtICB7W3R5cGVdfSAgW3Byb3BdICAgICBbZGVzY3JpcHRpb25dIC8vV09SRFQgTklFVCBHRUJSVUlLVFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICBbc2V0dGluZ3NdIFNldHRpbmdvYmplY3RcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gW25vdXBkYXRlXSBXaGVuIHRydWUsIGRvZXNuJ3QgdXBkYXRlIHRoZSBWLlZhbHVlXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgUmV0dXJucyB0aGUgVi5WYWx1ZVxuICAgKi9cbiAgY3JlYXRlOiBmdW5jdGlvbih2YWwsIHByb3AsIHNldHRpbmdzLCBub3VwZGF0ZSkge1xuICAgIHZhciB2ID0gbmV3IFZhbHVlKClcbiAgICB2Ll9iYXNlID0gdGhpc1xuICAgIHYuX2NhbGxlciA9IHYuX2Jhc2VcbiAgICB2Ll9wcm9wID0gc2V0dGluZ3NcbiAgICAvLyBjb25zb2xlLmxvZygnc2V0JylcbiAgICBvYmplY3RTZXQuY2FsbCh2LCB2YWwsIGZhbHNlLCBmYWxzZSwgdHJ1ZSlcbiAgICAvLyBjb25zb2xlLmxvZygnZG9uZSBzZXR0aW5nJylcbiAgICBpZiAodGhpcy5fY2xhc3MpIHRoaXMuX2NsYXNzLnByb3RvdHlwZS5fW3NldHRpbmdzLm5hbWVdID0gdlxuICAgIGlmIChzZXR0aW5ncy5zZXQpIHtcbiAgICAgIGlmICghc2V0dGluZ3MuX3ZzZXQpIHtcbiAgICAgICAgc2V0dGluZ3MuX3ZzZXQgPSBmdW5jdGlvbihzdGFtcCwgZnJvbSwgcmVtb3ZlLCBjdmFsKSB7XG4gICAgICAgICAgLy8gdmFyIHQgPSB0aGlzXG4gICAgICAgICAgLy8gdC5fX3MgPSB0cnVlXG4gICAgICAgICAgLy8gaWYoIXQuX3MpIHtcbiAgICAgICAgICAgIC8vIHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0lNIEhFUkU/JylcbiAgICAgICAgICAgICAgLy8gdC5fX3MgPSBudWxsXG4gICAgICAgICAgICAgIHNldHRpbmdzLnNldC5jYWxsKFxuICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxlclxuICAgICAgICAgICAgICAgIHx8IHRoaXMuX2Jhc2VcbiAgICAgICAgICAgICAgICB8fCB0aGlzLCB0aGlzLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBjdmFsXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIC8vIH0pXG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbm91cGRhdGUpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1VQREFURSBjcmVhdGlvbicpXG4gICAgICAgIHYuX3VwZGF0ZSh2YWwpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2XG4gIH0sXG4gIC8qKlxuICAgKiBEZWZpbmVzIHdoYXQgdGhpcyB0eXBlIHdpbGwgZG8gb24gc2V0LlxuICAgKiBAbWV0aG9kIHNldFxuICAgKiBAcGFyYW0gIHsqfSAgICAgIHZhbCAgICAgIFZhbHVlXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcCAgICAgUHJvcGVydGllc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzIFNldHRpbmdzb2JqZWN0XG4gICAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgUmV0dXJucyB2YWx1ZVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbih2YWwsIHByb3AsIHNldHRpbmdzKSB7XG5cbiAgICBpZighcHJvcCkgcmV0dXJuXG4gICAgLy8gY29uc29sZS5sb2coJ1NFVCBGVU4hJylcbiAgICBwcm9wLl9jYWxsZXIgPSB0aGlzXG4gICAgLy9kZXplIGJpbmQgem91IGFsbGVlbiBtb2V0ZW4gd2Vya2VuIHZvb3IgYWxzIGplIGlldHMgb3AgaGV0IGV4YWN0IGdvZWRlIG1vbW1lbnQgY2hhbmdlZCFcblxuICAgIHByb3AuX2JpbmQgPSBmYWxzZVxuICAgIGlmICh0aGlzICE9PSBwcm9wLl9iYXNlKSB7XG4gICAgICB2YXIgX2xpc3RlbmVycyA9IHByb3AuX2xpc3RlbmVyc1xuICAgICAgICAsIF9iID0gcHJvcC5fYmFzZVxuICAgICAgICAsIGlcbiAgICAgICAgLCBfdGhpcyA9IHRoaXNcblxuICAgICAgdXRpbC5zZXRzdG9yZS5jYWxsKHRoaXMpXG4gICAgICBleHBvcnRzLmNsb25lbGlzdFswXVsxXSA9IHRoaXMgLy9iZWV0amUgZGlydHkuLi5cblxuICAgICAgLy9jbG9uZSBpcyBhbHdheXMgdXNlZCB0byBnZXQgcmlkIG9mIGZsYWdzXG4gICAgICBpZiAodmFsICE9PSB2b2lkIDAgJiYgIXZhbC5jbGVhcikge1xuICAgICAgICB2YWwgPSBwcm9wLmNsb25lKHZhbCwgZmFsc2UsIGV4cG9ydHMuY2xvbmVsaXN0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYocHJvcC5fZmxhZykge1xuICAgICAgICAvLyAgIHZhbHVlLmZsYWdzW3Byb3AuX2ZsYWdbMF1dLnJlbW92ZSAmJiB2YWx1ZS5mbGFnc1twcm9wLl9mbGFnWzBdXS5yZW1vdmUuY2FsbCh0aGlzLHByb3AuX2ZsYWcpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy9saXN0ZW5lciBvbiBuZXN0ZWQgY2hpbGQgb24gcGFyZW50XG5cbiAgICAgICAgIC8vLS0tPiAgbmV3IHdpZHRoIGZvciB0aGlzIG9uZVxuICAgICAgICAgLy8gLS0tPiAgaGV5IGEgbGlzdGVuZXIgb24gbWUgL3cgYSBiaW5kIG9uIG15IGluc3RhbmNlIVxuICAgICAgICAgLy8gIC0tLS0+IGFkZCBsaXN0ZW5lciB0byBtZSAobGlzdGVuZXIgb24gY2xhc3MgcHJvcClcbiAgICAgICAgIC8vICAgLS0tLS0+IGhleSBsZXRzIHJlc2V0IHRoaXMgbGl0dGxlIGd1eXMgd2lkdGhcbiAgICAgICAgIC8vICAgIC0tLS0tLT4gIGxldHMgYWRkIExpc3RlbmVyXG4gICAgICAgICAvLyAgICAgLS0tLS0tLS0+ICBkb3VibGUgbGlzdGVuZXJzIG9uIHRoaXMgb25lXG4gICAgICAgIHZhciB2ID0gbmV3IFZhbHVlKClcbiAgICAgICAgdi5fYmFzZSA9IHRoaXNcbiAgICAgICAgdi5fcHJvcCA9IHNldHRpbmdzXG4gICAgICAgIHYuX2NhbGxlciA9IHRoaXNcblxuICAgICAgICAvLyBjbGVhbiBGTEFHUyBmcm9tIG5vZGUhXG4gICAgICAgIGlmKHZhbCkgZGVsZXRlIHZhbC5jbGVhclxuICAgICAgICB2LnZhbCA9IHZhbFxuICAgICAgICB2YWwgPSB2XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX19bc2V0dGluZ3MubmFtZV0gPSB2YWxcblxuICAgICAgaWYoIHRoaXMuX2NsYXNzICkgdGhpcy5fY2xhc3MucHJvdG90eXBlLl9bc2V0dGluZ3MubmFtZV0gPSB2YWxcblxuICAgICAgLy8gZm9yIGVhY2ggZmllbGQgKG9ubHkgMSBsZXZlbCBkZWVwIGZvciBub3cpXG4gICAgICBwcm9wLmVhY2hcbiAgICAgICggXG4gICAgICAgIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZXNvbHZlJywgcHJvcC5fcHJvcC5uYW1lLCBrZXkpXG4gICAgICAgICAgIGlmKCB0aGlzLl9saXN0ZW5lcnMgKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVMaXN0ZW5lciggdGhpcy5fbGlzdGVuZXJzW2ldLCB2YWxba2V5XSwgcHJvcCwgX3RoaXMgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9UT0RPOiBjaGVjayBpZiB0aGlzIGlzIG5lc3NlY2FyeVxuICAgICAgICAgICAgaWYodmFsW2tleV0udmFsICE9PSB0aGlzLnZhbClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmFsW2tleV0pIFxuICAgICAgICAgICAgICAvLyB2YWxba2V5XS5fdXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcblxuICAgICAgaWYoIF9saXN0ZW5lcnMgKSB7XG5cbiAgICAgICAgZm9yIChpID0gX2xpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHJlc29sdmVMaXN0ZW5lciggX2xpc3RlbmVyc1tpXSwgdmFsLCBwcm9wLCBfdGhpcyApXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICB2YWwgPSBudWxsXG4gICAgICAvLyBjb25zb2xlLmxvZygnVVBEQUNFIC0tLS0nLnllbGxvdylcbiAgICAgIHRoaXNbc2V0dGluZ3MubmFtZV0uX3VwZGF0ZSh2YWwpXG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICAvKipcbiAgIERlZmluZXMgd2hhdCB0aGlzIHR5cGUgd2lsbCBkbyBvbiBnZXQuXG4gICAqIEBtZXRob2QgZ2V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcCAgICAgUHJvcGVydGllc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHNldHRpbmdzIFNldHRpbmdvYmplY3RcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICovXG4gIGdldDogZnVuY3Rpb24ocHJvcCwgc2V0dGluZ3MpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnR0VUVElORyEnLCBwcm9wLCBzZXR0aW5ncy5uYW1lKVxuICAgIGlmIChwcm9wKSBwcm9wLl9jYWxsZXIgPSB0aGlzXG4gICAgaWYgKHNldHRpbmdzLmdldCkgcmV0dXJuIHNldHRpbmdzLmdldC5jYWxsKHRoaXMsIHByb3ApXG4gICAgcmV0dXJuIHByb3BcbiAgfVxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBmbGFncyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSxcbiAgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JyksXG4gIG93bk1vZGVsID0gZnVuY3Rpb24oYmFzZSkge1xuICAgIGlmICghYmFzZS5fXyB8fCAhYmFzZS5fXy5tb2RlbCkgeyAvL21heWJlIGEgdXRpbGl0eT8gdXNlIGl0IGF0IGRpZmZlcmVudCBzcG90cyBsaWtlIHNldHRpbmdzXG4gICAgICBiYXNlLm1vZGVsID0ge307XG4gICAgICBpZiAoIWJhc2UuXy5tb2RlbCkge1xuICAgICAgICBiYXNlLl9kTGlzdGVuKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYXNlLm1vZGVsO1xuICB9O1xuLyoqXG4gKiBkYXRhXG4gKiBkYXRhIGFkZHMgYSByZWZlcmVuY2UgdG8gdGhlIGRhdGEgcHJvcGVydHkgb2YgdGhlIGN1cnJlbnQgYmFzZSBjbGFzcztcbiAqIGlmIHRoZXJlIGlzIG5vdCBfYmFzZS5tb2RlbCB1c2UgZGF0YS5iYXNlLmV4dGVuZChiYXNlQ2xhc3MpO1xuICogQGZsYWdcbiAqL1xuZmxhZ3MuZGF0YSA9IHtcbiAgdXNlVmFsOnRydWUsIC8vKHJlc2V0Pz8/KVxuICBzZXQ6IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIHJlc2V0KSB7XG5cbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wLm5hbWUnKSxcbiAgICAgIG5hbWUgPSBjdXJyZW50Ll9wcm9wLm5hbWUsXG4gICAgICBiYXNlID0gY3VycmVudC5fYmFzZSxcbiAgICAgIG1vZGVsID0gb3duTW9kZWwoYmFzZSk7XG4gICAgaWYgKG1vZGVsLmZsYWdzICYmIG1vZGVsLmZsYWdzW25hbWVdKSB7XG4gICAgICBpZiAoIShtb2RlbC5mbGFnc1tuYW1lXSBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICBtb2RlbC5mbGFnc1tuYW1lXSA9IFttb2RlbC5mbGFnc1tuYW1lXV07XG4gICAgICB9XG4gICAgICBpZiAoIXV0aWwuY2hlY2tBcnJheShtb2RlbC5mbGFnc1tuYW1lXSwgdGhpcykpIHtcbiAgICAgICAgbW9kZWwuZmxhZ3NbbmFtZV0ucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFiYXNlLm1vZGVsLmZsYWdzKSB7XG4gICAgICAgIGJhc2UubW9kZWwuZmxhZ3MgPSB7fTtcbiAgICAgIH1cbiAgICAgIGJhc2UubW9kZWwuZmxhZ3NbbmFtZV0gPSB0aGlzO1xuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdMRVpaIFNFVCBJVCEnLCB2YWwsIHN0YW1wLCByZXNldCwgY3VycmVudClcblxuICAgIHZhciBnZXREYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX2Q7XG4gICAgICBpZiAoZGF0YSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoZGF0YSA9PT0gdm9pZCAwICYmIHBhcmVudCkge1xuXG4gICAgICAgICAgLy8gaWYocGFyZW50Lm1vZGVsICYmICghcGFyZW50Lm1vZGVsLmluaGVyaXQgfHwgcGFyZW50Lm1vZGVsLmluaGVyaXQudmFsIT09ZmFsc2UpKSB7XG4gICAgICAgICAgLy8gICByZXR1cm4gZGF0YVxuICAgICAgICAgIC8vIH1cblxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3NldCBpdCAvdyBwYXJlbnQhJywgdGhpcy5uYW1lLCBwYXJlbnQubmFtZSlcblxuICAgICAgICAgIGlmIChwYXJlbnQuX2QpIHtcblxuICAgICAgICAgICAgaWYocGFyZW50Lm1vZGVsICYmIHBhcmVudC5tb2RlbC5maWVsZCAmJiBwYXJlbnQubW9kZWwuZmllbGQudmFsICE9PSBwYXJlbnQubW9kZWxQYXJzZWQpIHtcbiAgICAgICAgICAgICAgcGFyZW50Ll9kID0gcGFyZW50Ll9kW3BhcmVudC5tb2RlbC5maWVsZC52YWxdIHx8IHBhcmVudC5fZC5mcm9tW3BhcmVudC5tb2RlbC5maWVsZC52YWxdXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2hldCBoZXkgaXRzIHBhcmVudCBtb2RlbCcsIHBhcmVudC5tb2RlbC5maWVsZC52YWwpXG4gICAgICAgICAgICAgIC8vIHBhcmVudC5tb2RlbCA9IHt9XG4gICAgICAgICAgICAgIHBhcmVudC5tb2RlbFBhcnNlZCA9IHBhcmVudC5tb2RlbC5maWVsZC52YWxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYocGFyKVxuXG4gICAgICAgICAgICBpZih0aGlzLm1vZGVsJiZ0aGlzLm1vZGVsLmZpZWxkICYmIHRoaXMubW9kZWxQYXJzZWQgIT09IHRoaXMubW9kZWwuZmllbGQudmFsKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2hleSBoZXkgaGV5ISBpIGdvdCBhIG1vZGVsIG15c2VsZiEnLCB0aGlzLm1vZGVsLmZpZWxkLnZhbCwgcGFyZW50Ll9kLmtleXMsIHBhcmVudC5fZClcblxuICAgICAgICAgICAgICBkYXRhID0gdGhpcy5fZFNldChwYXJlbnQuX2RbdGhpcy5tb2RlbC5maWVsZC52YWxdIHx8IHBhcmVudC5fZC5mcm9tW3RoaXMubW9kZWwuZmllbGQudmFsXSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIC8vIHRoaXMubW9kZWwgPSB7fVxuICAgICAgICAgICAgICB0aGlzLm1vZGVsUGFyc2VkID0gdGhpcy5tb2RlbC5maWVsZC52YWxcbiAgICAgICAgICAgICAgLy8gdGhpcy5tb2RlbC5wYXJzZWQgPSB0aGlzLm1vZGVsLmZpZWxkLnZhbFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RTZXQocGFyZW50Ll9kLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvLyBpZihwYXJlbnQubW9kZWwgJiYgcGFyZW50Lm1vZGVsLmZpZWxkKSB7XG4gICAgICAgICAgICAvLyAgIGNvbnNvbGUuZXJyb3IoJ2l0IGlzIGEgZmllbGQhJywgcGFyZW50Lm1vZGVsLmZpZWxkLnZhbClcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50Lm5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LmJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIHZhciB2ID0gdmFsLnZhbCB8fCB2YWw7XG4gICAgICB0aGlzLl92YWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXREYXRhLmNhbGwodGhpcyk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tPicsdixkYXRhKVxuICAgICAgICByZXR1cm4gZGF0YSAmJiB2LmNhbGwodGhpcywgZGF0YSk7XG4gICAgICB9O1xuICAgICAgdmFsID0gdmFsLmxpc3RlbiB8fCB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl92YWwgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXREYXRhLmNhbGwodGhpcyksXG4gICAgICAgICAgcmV0O1xuICAgICAgICBkYXRhID0gdmFsID09PSB0cnVlID8gZGF0YSA6IHV0aWwuZ2V0KGRhdGEsIHZhbCk7XG4gICAgICAgIGlmIChkYXRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICByZXQgPSBkYXRhLl9fdCAmJiAhZGF0YS5fZmlsdGVyICYmIGRhdGEudmFsO1xuICAgICAgICAgIGlmICghcmV0ICYmIHJldCAhPT0gMCAmJiByZXQgIT09ICcnKSB7IC8vd2VpcmRcbiAgICAgICAgICAgIHJldCA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZighdGhpcy5fZmxhZykgdGhpcy5fZmxhZyA9IHt9XG5cbiAgICAvLyB0aGlzLl9fbHZhbCA9IGZhbHNlXG4gICAgLy8gY3VycmVudC5fY2FsbGVyLnNldFNldHRpbmcoe1xuICAgIC8vICAgbmFtZTogbmFtZSxcbiAgICAvLyAgIHBhcmVudDogZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKCchQCMhQCMhQCMnKVxuICAgIC8vICAgICB0aGlzLnVwZGF0ZURhdGEoKVxuICAgIC8vICAgfVxuICAgIC8vIH0pO1xuXG4gICAgdGhpcy5fZmxhZy5kYXRhID0gWydkYXRhJywgdGhpcy5fdmFsLCB2YWwsIG5hbWVdO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AubmFtZScpLFxuICAgICAgbW9kZWwgPSBvd25Nb2RlbChjdXJyZW50Ll9iYXNlKSxcbiAgICAgIHQgPSB0aGlzO1xuICAgIGlmIChtb2RlbCAmJiBtb2RlbC5mbGFncykge1xuICAgICAgZm9yICh2YXIgaSBpbiBtb2RlbC5mbGFncykge1xuICAgICAgICBpZiAoaSA9PT0gY3VycmVudC5fcHJvcC5uYW1lKSB7XG4gICAgICAgICAgdmFyIGl0ZW0gPSBtb2RlbC5mbGFnc1tpXTtcbiAgICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIG9iamVjdCB8fCBpdGVtLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgbW9kZWwuZmxhZ3NbaV0gPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlIG1vZGVsLmZsYWdzW2ldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbC5mbGFnc1tpXS5zcGxpY2UodXRpbC5jaGVja0FycmF5KGl0ZW0sIHQpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fdXBkYXRlKCkgLy9wYXMgaGllcm1lZSBvcCFcbiAgICAvLyB2YXIgdCA9IHRoaXNcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgLy9kZXplIHBhcyB1aXR2b2VyZW4gbmFkYXQgYWxsZSBrbGFhciBpcyEgZGl0IGlzIGRpcnR5IVxuICAgICAgdC5fdXBkYXRlKClcbiAgICB9LDApXG4gIH1cbn07IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHZhbHVlID0gcmVxdWlyZSgnLi4vJyksXG4gICAgYmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKSxcbiAgICBmbGFncyA9IHJlcXVpcmUoJy4uLy4uL29iamVjdC9mbGFncycpO1xuICAgIFxuICAgIGJhc2UuY2xvbmVsaXN0LnB1c2goWydfZmxhZycsIHRydWVdKTsgLy90cnVlIGNsb25lIVxuICAgIGZsYWdzLmV4dGVuZCh2YWx1ZSk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB2YWx1ZS5mbGFnczsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZmxhZ3MgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJylcbiAgLCB2YWx1ZSA9IHJlcXVpcmUoJy4uLycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIHZPYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKVxuXG5cbi8vdG9kbyBhZGQgZWxlbWVudCBzaWduYXR1cmUgaW4gZnJvbSBzbyBpdCBjYW4gdHJhdmVsIHRyb3VnaCB1cGRhdGVzIC0tLSBpZiBwYXJlbnQgKG5lZWQgbGVzcyBmdW5reSB0aGluZ3MpXG5cbi8qKlxuICogcGFyZW50XG4gKiBwYXJlbnQgbWFrZXMgaXQgcG9zc2libGUgdG8gYWRkIGxpc3RlbmVycyB0byBwYXJlbnQgcHJvcGVydGllc1xuICogdXNpbmcgbXVsdGlwbGUgcGFyZW50IHByb3BlcnRpZXMgaW4gb25lIHByb3BlcnR5IGlzIHN0aWxsIHZlcnkgd3JvbmdcbiAqIEBmbGFnXG4gKi9cbnZhbHVlLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ19wYXJlbnRTdG9yZScpXG5cbmZ1bmN0aW9uIGJhc2VSZXNldChiYXNlLG5hbWUpIHtcbiAgaWYoYmFzZSAmJiBiYXNlLm5vZGUpIHtcbiAgICBpZihuYW1lPT09J3gnIHx8IG5hbWUgPT09J3knKSBiYXNlLmNsZWFuQ29vcmRpbmF0ZXMobmFtZSlcbiAgICBpZihiYXNlW25hbWVdKSB7XG4gICAgICBiYXNlW25hbWVdLl9wcm9wLl92c2V0LmNhbGwoYmFzZVtuYW1lXSlcbiAgICB9XG4gIH1cbn1cblxuXG4vLyB3aW5kb3cucGNoZWNrID0gMFxuXG4vLyB3aW5kb3cucHByb3BzID0ge31cblxuLy9iYXNlLHZzZXQsdCx0eXBlLG1wYXJlbnQsZmJhc2UsIHYsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdHJ1ZSwgZmlyc3RTa2lwXG5mdW5jdGlvbiBjaGVja2VyKHZzZXQsIHQsIHR5cGUsIG1wYXJlbnQsIGZiYXNlLCB2LCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIGZpcnN0LCBmaXJzdFNraXAsIHApIHtcbiAgaWYocCYmKHRoaXMucGFyZW50IGluc3RhbmNlb2YgbXBhcmVudCkgfHwgICghcCAmJiB0aGlzLnBhcmVudD09PW1wYXJlbnQpIHx8IGZpcnN0U2tpcCApIHtcblxuICAgIC8vIHBjaGVjaysrXG5cbiAgICB2YXIgc1xuICAgICAgLCBiYXNlID0gdGhpcy5fZnJvbS5iYXNlLm5vZGUgJiYgdGhpcy5fZnJvbS5iYXNlXG4gICAgICAsIG5hbWUgPSB0Ll9wcm9wLm5hbWVcblxuICAgIC8vIGlmKCF3aW5kb3cucHByb3BzW25hbWVdKSB3aW5kb3cucHByb3BzW25hbWVdID0gMFxuXG4gICAgLy8gd2luZG93LnBwcm9wc1tuYW1lXSsrXG5cblxuICAgIHQuX2NhbGxlciA9IHRoaXNcblxuICAgIC8vZ2F1cmQgdm9vciBjaGFuZ2VzIC0tIGlmIG5vIGNoYW5nZSAtLSBkbyBub3RoaW5nXG4gICAgdnNldC5jYWxsKHQsIHN0YW1wLCBmcm9tLCByZW1vdmUsIHZhbClcblxuICAgIGlmKGJhc2UmJmJhc2VbbmFtZV0mJmJhc2VbbmFtZSsnX19wJ10hPT1zdGFtcCkge1xuICAgICAgdC5fY2FsbGVyID0gYmFzZVxuICAgICAgdC5fY2FsbGVyW25hbWUrJ19fcCddID0gc3RhbXBcbiAgICAgIHZzZXQuY2FsbCh0LCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCB2YWwpXG4gICAgICB0Ll9jYWxsZXIgPSB0aGlzXG4gICAgICBzPXRydWVcbiAgICB9XG5cbiAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5vZGUpXG4gICAgZm9yKHZhciBpIGluIHQuX2xpc3RlbmVycykge1xuICAgICAgaWYodC5fbGlzdGVuZXJzW2ldLnBvcCAmJiB0Ll9saXN0ZW5lcnNbaV1bMl09PT0ncGFyZW50Jykge1xuICAgICAgICBpZih0Ll9saXN0ZW5lcnNbaV1bMV0uX2xzdGFtcD09PXN0YW1wKSB7XG4gICAgICAgICAgdC5fbGlzdGVuZXJzW2ldWzFdLl9sc3RhbXA9bnVsbFxuICAgICAgICB9XG4gICAgICAgIHQuX2xpc3RlbmVyc1tpXVswXS5jYWxsKHQuX2xpc3RlbmVyc1tpXVsxXSwgdHlwZSwgdGhpcywgYmFzZSwgdiwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCB0cnVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vcmVzZXQgdGhpcy5fZnJvbS5iYXNlW3QuX3Byb3AubmFtZV09PT10XG4gICAgaWYocykgYmFzZVJlc2V0KGJhc2UsIG5hbWUpXG5cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIYW5kbGVyKHR5cGUsbXBhcmVudCxmYmFzZSx2LCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsZmlyc3RTa2lwLGluaGVyaXQpIHtcblxuICB2YXIgdCA9IHRoaXNcblxuICB0aGlzLl9wYXJlbnRTdG9yZVswXSA9IG1wYXJlbnRcblxuICB0aGlzLl91cGRhdGUodmFsLCBmcm9tID8gdGhpcy5zdGFtcCgpIDogc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgZmFsc2UsIGZhbHNlLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgdnNldCA9ICB0aGlzLmNoZWNrUGFyZW50KCdfcHJvcC5fdnNldCcsIHRydWUpXG4gICAgICAsIGJhc2UgPSB0aGlzLmNoZWNrUGFyZW50KCdfYmFzZScsIHRydWUpXG4gICAgICAsIGNvbXBsZXhQYXJlbnQgPSB0cnVlXG4gICAgICAsIHBcblxuICAgIGlmKCAobXBhcmVudD09PWJhc2UucGFyZW50ICYmIGZyb20pICApIHtcbiAgICAgIHAgPSB0cnVlXG4gICAgfVxuXG4gICAgY2hlY2tlci5jYWxsKGJhc2UsdnNldCx0LHR5cGUsbXBhcmVudCxmYmFzZSwgdiwgdmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdHJ1ZSwgZmlyc3RTa2lwKVxuXG4gICAgYmFzZS5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7XG4gICAgIGNoZWNrZXIuY2FsbCh0aGlzLCB2c2V0LCB0LHR5cGUsIG1wYXJlbnQsZmJhc2UsIHYsIHZhbCwgc3RhbXAsIGZhbHNlLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIGZhbHNlLCBwKVxuICAgIH0sIHQuX3Byb3AubmFtZSlcblxuICAgIHZPYmplY3QucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0aGlzLCB2YWwsIHN0YW1wLCBmYWxzZSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBmdW5jdGlvbihsKSB7XG4gICAgICByZXR1cm4gbFsyXT09PSdwYXJlbnQnXG4gICAgfSlcblxuICAgIGlmKCFpbmhlcml0ICYmIHYuX2NhbGxlciAmJiBtcGFyZW50IT09di5fY2FsbGVyKSB7XG4gICAgICB1cGRhdGVIYW5kbGVyLmNhbGwodGhpcyx0eXBlLHYuX2NhbGxlcixmYmFzZSwgdiwgdmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCxmaXJzdFNraXAsdHJ1ZSlcbiAgICB9XG5cbiAgfSlcbn1cblxuZnVuY3Rpb24gX3BhcmVudChwYXJlbnQsIG5vdXBkYXRlLCBwcm9wLCBmbGFnLCByZXNldCkge1xuXG4gIC8vIGNvbnNvbGUubG9nKCdfcGFyZW50IGNhbGwnLmN5YW4uaW52ZXJzZSwgZmxhZylcblxuICB2YXIgX2xwYXJlbnQgPSBwcm9wLl9wYXJlbnRTdG9yZVswXVxuICAgICwgcG5hbWUgPSBmbGFnWzJdICAgLy9mbGFncy5wYXJlbnQudmFsXG4gICAgLCBwcHJvcCA9IHBhcmVudFtwbmFtZV1cbiAgICAsIGZiYXNlID0gdGhpcy5fZnJvbS5iYXNlXG4gICAgLCBuZXdQXG4gICAgLCBiYXNlU2V0XG5cbiAgaWYgKCFwcHJvcCkgcmV0dXJuXG5cbiAgLy8gY29uc29sZS5sb2coJ0FERCBMSVNURU5FUiBUTyBQQVJFTlQnKVxuXG4gIHBwcm9wLmFkZExpc3RlbmVyKFxuICAgIFsgdXBkYXRlSGFuZGxlclxuICAgICwgcHJvcFxuICAgICwgJ3BhcmVudCdcbiAgICAsIHBhcmVudFxuICAgICwgdGhpcyAvL2ZiYXNlXG4gIF0sIGZ1bmN0aW9uKGwsbGlzdGVuZXJzLGluZGV4KSB7XG5cbiAgICBpZihsWzNdIT09cGFyZW50ICYmICBfbHBhcmVudCE9PXBhcmVudCAmJiBsWzRdIT09ZmJhc2UpIHtcbiAgICAgIHByb3AuX3BhcmVudFN0b3JlWzBdID0gcGFyZW50XG4gICAgICBsWzRdID0gZmJhc2VcbiAgICAgIG5ld1AgPSB0cnVlIC8vaG9lIGRlemUgc21hcnQgYWZ2YW5nZW4/XG4gICAgfVxuICB9LCBmYWxzZSwgdHJ1ZSlcblxuICAvLyBpZihyZXNldCkge1xuICAvLyAgIGZvcih2YXIgaSBpbiBwcHJvcC5fbGlzdGVuZXJzKSB7XG4gIC8vICAgICBpZihwcHJvcC5fbGlzdGVuZXJzW2ldLnBvcCAmJiBwcHJvcC5fbGlzdGVuZXJzW2ldWzFdPT09ZmJhc2VbcHJvcC5fcHJvcC5uYW1lXSkge1xuICAvLyAgICAgICBpZihwcHJvcCE9PXBhcmVudC5fZnJvbS5iYXNlW3BuYW1lXSkge1xuICAvLyAgICAgICAgIHBwcm9wLl9saXN0ZW5lcnMuc3BsaWNlKGksMSlcbiAgLy8gICAgICAgICBicmVhaztcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gfVxuXG4gIGlmIChuZXdQIHx8ICghX2xwYXJlbnQgfHwgKF9scGFyZW50ICE9PSBwYXJlbnQgJiYgX2xwYXJlbnRbcG5hbWVdICE9PSBwcHJvcCkgKSApIHtcbiAgICBwcm9wLl9wYXJlbnRTdG9yZVswXSA9IHBhcmVudFxuICAgIGlmICghbm91cGRhdGUpIHtcbiAgICAgIHByb3AuX2NhbGxlciA9IChiYXNlU2V0ID0gZmJhc2Uubm9kZSAmJiBmYmFzZSB8fCBwcm9wLl9iYXNlKVxuICAgICAgcHJvcC5fcHJvcC5fdnNldC5jYWxsKHByb3AsIHByb3ApXG4gICAgICBwcm9wLl9jYWxsZXIgPSB0aGlzXG4gICAgICB1cGRhdGVIYW5kbGVyLmNhbGwocHJvcCwncGFyZW50JyxwYXJlbnQsZmJhc2UscHByb3AsZmFsc2Usdk9iamVjdC5zdGFtcCgpLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLHRydWUsdHJ1ZSlcbiAgICAgIGJhc2VSZXNldChiYXNlU2V0LHByb3AuX3Byb3AubmFtZSlcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gX2luaXQodmFsLCBmbGFnLCByZXNldCkge1xuICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRcbiAgLy8gY29uc29sZS5sb2coJ3RyeSBwYXJlbnQnLCBmbGFnLCBwYXJlbnQpXG4gIGlmIChwYXJlbnQpIF9wYXJlbnQuY2FsbCh0aGlzLCBwYXJlbnQsIHRydWUsIHZhbCwgZmxhZywgcmVzZXQpXG59XG5cbmZ1bmN0aW9uIF92YWwodmFsKSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB2YWwuY2hlY2tQYXJlbnQoJ19wYXJlbnRTdG9yZS4wJywgdHJ1ZSlcbiAgLy9mbGFncy5wYXJlbnQudmFsXG4gIGlmKHBhcmVudCAmJiAhdmFsLl9mbGFnLnBhcmVudCkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ05PIFBBUkVOVCBGTEFHIScpXG4gICAgcmV0dXJuXG4gIH1cbiAgLy8gY29uc29sZS5sb2coJy0tLS0+Jyx2YWwuX2ZsYWcucGFyZW50WzJdKVxuICBpZiAocGFyZW50ICkgcmV0dXJuIHBhcmVudFt2YWwuX2ZsYWcucGFyZW50WzJdXS52YWxcbn1cblxuZmxhZ3MucGFyZW50ID1cbnsgcmVzZXQ6IHRydWVcbiwgdXNlVmFsOiB0cnVlXG4sIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQpIHtcbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wLm5hbWUnKSxcbiAgICAgIG5hbWUgPSBjdXJyZW50Ll9wcm9wLm5hbWVcbiAgICAvL2ZsYWdzLnBhcmVudC52YWxcbiAgICBpZighdGhpcy5fZmxhZykgdGhpcy5fZmxhZyA9IHt9XG5cbiAgICAgIC8vb3ZlcndyaXRpbmcgcHJldmlvdXMgcGFyZW50XG4gICAgICAvL1xuICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgUEFSRU5ULS0tLT4nKVxuICAgIHRoaXMuX2ZsYWcucGFyZW50ID0gWydwYXJlbnQnLCBfdmFsLCB2YWwsIHRoaXNdXG4gICAgaWYgKCFjdXJyZW50Ll9wYXJlbnRTdG9yZSkgY3VycmVudC5fcGFyZW50U3RvcmUgPSBbZmFsc2VdXG5cbiAgICAvLyBjb25zb2xlLmxvZygnR09UUyBQQVJFTlRTVE9SRSEnLCByZXNldCwgY3VycmVudC5fcGFyZW50U3RvcmUsIHRoaXMuX2ZsYWcucGFyZW50KVxuXG4gICAgY3VycmVudC5fcGFyZW50U3RvcmUucHVzaCh0aGlzKVxuICAgIC8vc2V0UGFyZW50IHNldHRpbmdzXG4gICAgLy8gY29uc29sZS5sb2coJy0tLT4gQ1JFQVRFIFNFVFRJTkcnLnllbGxvdy5pbnZlcnNlKVxuICAgIGN1cnJlbnQuX2NhbGxlci5zZXRTZXR0aW5nKHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBwYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0+IFNFVCBTRVRUSU5HJy55ZWxsb3cuaW52ZXJzZSlcblxuICAgICAgICBmb3IgKHZhciBzdG9yZSA9IHRoaXNbbmFtZV0uX3BhcmVudFN0b3JlLCBpID0gc3RvcmUgPyBzdG9yZS5sZW5ndGggLSAxIDogMDsgaSA+IDA7IGktLSkge1xuICAgICAgICAgIGlmKHN0b3JlW2ldLl9mbGFnLnBhcmVudCkge1xuICAgICAgICAgICAgX3BhcmVudC5jYWxsKHRoaXMsIHBhcmVudCwgZmFsc2UsIHRoaXNbbmFtZV0sIHN0b3JlW2ldLl9mbGFnLnBhcmVudClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignMiBOTyBQQVJFTlQgRkxBRyEnKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vdHJ5IHRvIG1pbmltaXplIHZhbCBjYWx1bGF0aW9uc1xuICAgIHRoaXMuX3ZhbCA9IF92YWxcbiAgICB0aGlzLl9za2lwID0gdHJ1ZVxuICAgIC8vb25Jbml0IChpZiBpdCBhbHJlYWR5IGhhcyBzb21lIHBhcmVudHMpXG4gICAgX2luaXQuY2FsbChjdXJyZW50Ll9iYXNlLCBjdXJyZW50LCB0aGlzLl9mbGFnLnBhcmVudCwgcmVzZXQpXG4gICAgLy9yZUF0dGFjaCBsaXN0ZW5lcnMgZm9yIGluc3RhbmNlc1xuICAgIGN1cnJlbnQuX2Jhc2UuZWFjaEluc3RhbmNlKF9pbml0LCBuYW1lLCBjdXJyZW50LCB0aGlzLl9mbGFnLnBhcmVudClcbiAgfVxuLCByZW1vdmU6IGZ1bmN0aW9uKGZsYWcpIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdSRU1PVkUgUEFSRU5UJy5jeWFuLmludmVyc2UpXG5cbiAgICB2YXIgY3VycmVudCA9IHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wLm5hbWUnKSxcbiAgICAgIGJhc2UgPSBjdXJyZW50Ll9iYXNlLFxuICAgICAgbGlzdGVucyA9IGN1cnJlbnQuX2xpc3RlbnMsXG4gICAgICBuYW1lID0gY3VycmVudC5fcHJvcC5uYW1lLFxuICAgICAgdmFsID0gZmxhZ1syXSwgIC8vZmxhZ3MucGFyZW50LnZhbFxuICAgICAgcGFyZW50U3RvcmUgPSBjdXJyZW50Ll9wYXJlbnRTdG9yZSxcbiAgICAgIHJlbW92ZWxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudFxuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudFt2YWxdKSB7XG4gICAgICAgICAgaWYgKGxpc3RlbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuY2hlY2tBcnJheShsaXN0ZW5zLCBwYXJlbnRbdmFsXSkpIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBMSVNURU5FUiEnLCBwYXJlbnRbdmFsXSwgbGlzdGVucy5sZW5ndGgsIHBhcmVudFt2YWxdLl9saXN0ZW5lcnMubGVuZ3RoLCBwYXJlbnRbdmFsXS5fbGlzdGVuZXJzICwgY3VycmVudClcblxuXG4gICAgICAgICAgICAgIC8vbW9yZSBzcGVjaWZpYyBvbmx5IHJlbW92ZSBpZiB2YWwgbWF0Y2hlcyAtLS0gc3RvcmUgZnVuY3Rpb25cbiAgICAgICAgICAgICAgcGFyZW50W3ZhbF0ucmVtb3ZlTGlzdGVuZXIoIGZhbHNlLCBjdXJyZW50IClcblxuICAgICAgICAgICAgICAvL21hcmsgPSBmYWxzZVxuXG5cbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBMSVNURU5FUiEgLS0gcmVzdWx0IC0tIG5vIHVwZGF0ZT8nLCBsaXN0ZW5zLmxlbmd0aClcblxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgdGhpcy5fdmFsID0gMFxuXG4gICAgaWYgKGxpc3RlbnMgJiYgIXJlbW92ZWxpc3RlbmVyLmNhbGwoYmFzZSkpIHtcbiAgICAgIGJhc2UuZWFjaEluc3RhbmNlKHJlbW92ZWxpc3RlbmVyLCBuYW1lKVxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdQQVJFTlRTVE9SRScsIHBhcmVudFN0b3JlLCBjdXJyZW50KVxuICAgIHBhcmVudFN0b3JlLnNwbGljZSh1dGlsLmNoZWNrQXJyYXkocGFyZW50U3RvcmUsIHRoaXMsIHRydWUpLCAxKVxuXG4gICAgaWYgKHBhcmVudFN0b3JlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4gUkVNT1ZFIFNFVFRJTkcnLnllbGxvdy5pbnZlcnNlLCBwYXJlbnRTdG9yZSlcbiAgICAgIGJhc2UucmVtb3ZlU2V0dGluZyhuYW1lLCAncGFyZW50JykgLy9mZiBjb3JpZ2VyZW4gdm9vciBhbmRlcmUgcGFyZW50IHNldHRpbmdzISEhIG9wIGFuZGVyZSBmaWVsZHNcbiAgICAgIC8vZGl0IG1hYWt0IGhldCBoZWxlbWFhbCBrYXBvdCFcbiAgICAgIC8vIGNvbnNvbGUud2FybignUkVNT1ZFIFBBUkVOVFNUT1JFIScpXG4gICAgICBjdXJyZW50Ll9wYXJlbnRTdG9yZSA9IG51bGxcbiAgICB9XG4gIH1cbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbi8vVE9ETzogZmxhZ3Mgb24gdGhlIGJhc2lzIG9mIHBhdGggKCBzaW1pbGFpciB0byBjYXNlcyApXG5cbi8vVE9ETzogbWFrZSBWYWx1ZSBmbGFncyBtb3JlIGluamVjdGFibGVcbnZhciBmbGFncyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggJy4vJyApXG4gICwgcHJvY2Vzc2VzID0gcmVxdWlyZSggJy4uLy4uL3V0aWwvcHJvY2VzcycgKVxuICAsIFZhbHVlID0gcmVxdWlyZSggJy4uLycgKVxuICAsIHV0aWwgPSByZXF1aXJlKCAnLi4vLi4vdXRpbCcgKVxuICAsIGFqYXggPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL25ldHdvcmsvYWpheCcpXG4gICwgdk9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpXG5cbi8vVE9ETzogbWF5YmUgYWRkIHByb21pc2VcblxuZXhwb3J0cy5jcmVhdGUgPSBmdW5jdGlvbiggZmxhZywgc2V0dGluZ3MsIENvbnN0cnVjdG9yLCBleHRlbmRmbGFncyApIHtcblxuICBpZiggIWV4dGVuZGZsYWdzICkgZXh0ZW5kZmxhZ3MgPSBmbGFnc1xuICBpZiggIUNvbnN0cnVjdG9yICkgQ29uc3RydWN0b3IgPSBWYWx1ZVxuXG4gIHZhciB0ZW1wU3RvcmUgPSAnX190ZW1wJytmbGFnKydfXydcbiAgICAsIGluUHJvZ3Jlc3MgPSAgJ19faW5wcm9ncmVzcycrZmxhZysnX18nXG4gICAgLCBvcmlnVXBkYXRlID0gQ29uc3RydWN0b3IucHJvdG90eXBlLl91cGRhdGVcbiAgICAsIG9uY2UgPSBzZXR0aW5ncyAmJiBzZXR0aW5ncy5vbmNlXG4gICAgLCBkZWZlck1ldGhvZCA9IHNldHRpbmdzICYmIHNldHRpbmdzLmRlZmVyTWV0aG9kXG4gICAgLCBvcmlnU2V0XG4gICAgLCBvcmlnUmVtb3ZlXG4gICAgLCBkZWZlcmZsYWcgPSBcbiAgICAgIHsgcmVzZXQ6IHRydWVcbiAgICAgICwgc2V0OiBmdW5jdGlvbiggdmFsLCBzdGFtcCwgcmVzZXQgKSB7XG4gICAgICAgICAgaWYoICF0aGlzLl9mbGFnICkgdGhpcy5fZmxhZyA9IHt9XG4gICAgICAgICAgdGhpcy5fZmxhZ1tmbGFnXSA9IFsgZmxhZywgZmFsc2UsIHZhbCwgdGhpcyBdXG4gICAgICAgIH1cbiAgICAgICwgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZGVmZXIgPSB0aGlzLl9mbGFnICYmIHRoaXMuX2ZsYWdbZmxhZ11cbiAgICAgICAgICAgICwgdm9ialxuXG4gICAgICAgICAgaWYoIGRlZmVyICYmIGRlZmVyWzFdIClcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIC8vIGlmKCBkZWZlck1ldGhvZCApIFxuICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAvLyB2b2JqID0gZGVmZXJNZXRob2QuY2FsbCggX3RoaXMsIGFyciwgZGVmZXJbMl0sIF90aGlzW3RlbXBTdG9yZV0sIG9yaWdVcGRhdGUsIENvbnN0cnVjdG9yIClcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIGlmKCkge1xuICAgICAgICAgICAgICB2b2JqID0gdHlwZW9mIGRlZmVyWzJdID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgID8gcHJvY2Vzc2VzW2RlZmVyWzJdXVxuICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIGRlZmVyWzJdICE9PSAnZnVuY3Rpb24nICYmIGRlZmVyWzJdXG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIGlmKCB2b2JqICYmIHZvYmoucmVtb3ZlTGlzdGVuZXIgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2b2JqLnJlbW92ZUxpc3RlbmVyKCBkZWZlclsxXSApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKCB2b2JqICYmIHZvYmogIT09IHRydWUgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBmb3IoIHZhciB2b2JqJCBpbiB2b2JqIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZvYmoucmVtb3ZlTGlzdGVuZXIoIHZvYmpbdm9iaiRdIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG5cbiAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaFxuICAoIHRlbXBTdG9yZVxuICAsIGluUHJvZ3Jlc3NcbiAgLCAnX2hpc3RvcnknXG4gIC8vICwgJ19pbml0aWFsaXNlZCdcbiAgKVxuXG4gIGlmKCBkZWZlck1ldGhvZCApIHtcbiAgICBzZXR0aW5ncy5kZWZlck1ldGhvZCA9IG51bGxcbiAgfVxuXG4gICBpZiggb25jZSApIHtcbiAgICBzZXR0aW5ncy5vbmNlID0gbnVsbFxuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goIG9uY2UgKVxuICB9XG5cbiAgaWYoIHNldHRpbmdzICkge1xuICAgIGZvciggdmFyIGtleSBpbiBzZXR0aW5ncyApXG4gICAge1xuICAgICAgaWYoIGtleSA9PT0gJ3NldCcgKVxuICAgICAge1xuICAgICAgICBvcmlnU2V0ID0gZGVmZXJmbGFnLnNldFxuICAgICAgICBkZWZlcmZsYWcuc2V0ID0gZnVuY3Rpb24oIHZhbCwgc3RhbXAsIHJlc2V0ICkge1xuICAgICAgICAgIHNldHRpbmdzLnNldC5jYWxsKCB0aGlzLCBvcmlnU2V0LCBhcmd1bWVudHMgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmKCBrZXkgPT09ICdyZW1vdmUnIClcbiAgICAgIHtcbiAgICAgICAgb3JpZ1JlbW92ZSA9IGRlZmVyZmxhZy5yZW1vdmVcbiAgICAgICAgZGVmZXJmbGFnLnJlbW92ZSA9IGZ1bmN0aW9uKCB2YWwsIHN0YW1wLCByZXNldCApIHtcbiAgICAgICAgICBzZXR0aW5ncy5yZW1vdmUuY2FsbCggdGhpcywgb3JpZ1JlbW92ZSwgYXJndW1lbnRzIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZWxzZSBcbiAgICAgIHtcbiAgICAgICAgZGVmZXJmbGFnW2tleV0gPSBzZXR0aW5nc1trZXldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZXh0ZW5kZmxhZ3NbZmxhZ10gPSBkZWZlcmZsYWdcblxuICAvL2V4dGVuZCB1cGRhdGVcbiAgdXRpbC5kZWZpbmVcbiAgKCBDb25zdHJ1Y3RvclxuICAsICdfdXBkYXRlJ1xuICAsIGZ1bmN0aW9uKCB2YWwsIHN0YW1wICkge1xuXG5cblxuICAgICAgaWYoICggdGhpcy5fZmxhZyAmJiB0aGlzLl9mbGFnW2ZsYWddICkgJiYgKCAhb25jZSB8fCAhdGhpc1tvbmNlXSApICkgLy8mJiAhdGhpcy5faW5pdGlhbGlzZWQgXG4gICAgICB7XG5cbiAgICAgICAgLy8gdGhpcy5jbGVhckNhY2hlKClcblxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdfdXBkYWNlJywgdmFsLCB0aGlzLl9wYXRoKVxuXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoICckRUVFRUUxJywgdGhpcy5fcGF0aClcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9wYXRoLCB2YWwsIHN0YW1wKVxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAgICAgLCBkZWZlciA9IF90aGlzLl9mbGFnICYmIF90aGlzLl9mbGFnW2ZsYWddXG4gICAgICAgICAgLCB0ZW1wZGVmZXIgPSBfdGhpc1t0ZW1wU3RvcmVdXG4gICAgICAgICAgLCBhZGRcbiAgICAgICAgICAsIGFyclxuICAgICAgICAgICwgdm9ialxuICAgICAgICAgICwgcmVjdXJcbiAgICAgICAgICAsIGZuXG5cbiAgICAgICAgaWYoICF0ZW1wZGVmZXIgKVxuICAgICAgICB7XG4gICAgICAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IHRlbXBkZWZlciA9IFtdXG4gICAgICAgICAgYWRkID0gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vVE9ETzogZml4IGNhY2hpbmcgc3RhbXAsIG1vc3QgZWZmaWNpZW50IGJ1dCBtYXkgYnJlYWsgdGhpbmdzIC93IGluc3RhbmNlcyBldGNcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc3RhbXAgY2FoY2luZycsIHRoaXMuX3BhdGgpXG5cbiAgICAgICAgICBpZiggc3RhbXAgJiYgdGVtcGRlZmVyWzBdWzFdICE9PSBzdGFtcCApXG4gICAgICAgICAge1xuXG4gICAgICAgICAgICAvLyB0ZW1wZGVmZXIucHVzaCh1dGlsLmFyZyggYXJndW1lbnRzICkpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc3RhbXAgY2FoY2luZyBwYXNzJyAsIHRoaXMuX3BhdGgsIHRlbXBkZWZlcilcbiAgICAgICAgICAgIC8vIHRlbXBkZWZlclswXVswXSA9IHZhbFxuICAgICAgICAgICAgLy8gdGVtcGRlZmVyWzBdWzFdID0gc3RhbXBcbiAgICAgICAgICAgIHZhciBhcmcgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gICAgICAgICAgICBmb3IodmFyIGkgaW4gYXJnKSB7XG4gICAgICAgICAgICAgIHRlbXBkZWZlclswXVtpXSA9IGFyZ1tpXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ191cGRhY2UgMycsIHZhbCwgdGhpcy5fcGF0aClcblxuICAgICAgICAgLy8gaWYodGhpcy5fbmFtZSA9PT0gJyR0ZXN0JykgY29uc29sZS5sb2coJ3N0b3AgaXRzJylcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGFyciA9IHV0aWwuYXJnKCBhcmd1bWVudHMgKVxuXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ191cGRhY2UgMicsIHZhbCwgdGhpcy5fcGF0aClcblxuICAgICAgICB0ZW1wZGVmZXIucHVzaCggYXJyIClcblxuICAgICAgICBpZiggYWRkIClcbiAgICAgICAge1xuICAgICAgICAgIC8vIGlmKHRoaXMuX25hbWUgPT09ICckdGVzdCcpIGNvbnNvbGUuZXJyb3IoJ2RvIGl0IDEnKVxuXG4gICAgICAgICAgaWYoIGRlZmVyTWV0aG9kICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgdm9iaiA9IGRlZmVyTWV0aG9kLmNhbGwoIF90aGlzLCBhcnIsIGRlZmVyWzJdLCB0ZW1wU3RvcmUsIG9yaWdVcGRhdGUsIENvbnN0cnVjdG9yLCBpblByb2dyZXNzIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2b2JqID0gdHlwZW9mIGRlZmVyWzJdID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgPyBwcm9jZXNzZXNbZGVmZXJbMl1dXG4gICAgICAgICAgICAgICA6IGRlZmVyWzJdXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoIHZvYmogKVxuICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaGV5aG8yISEhISEnLCB2YWwsdGhpcy5fcGF0aClcblxuICAgICAgICAgIFxuICAgICAgICAgICAgLy9UT0RPOiByZXBsYWNlIHdpdGggYSBzdGFuZGFyZCBmdW5jdGlvbiwgbG9zZSB0aGUgZXh0cmEgY2xvc3VyZSFcbiAgICAgICAgICAgIHJlY3VyID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgaWYoIG9uY2UgKSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIF90aGlzW29uY2VdID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vZGl0IG9vayBrdW5uZW4gbWVlZ2V2ZW5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdMRVRTIFRSWScpXG5cbiAgICAgICAgICAgICAgLy9UT0RPOiB1c2luZyBhIGNsb3N1cmUgaGVyZSBtYXkgbm90IGJlIG5lc3NlY2FyeSBhbnltb3JlLCB1c2UgYW5vdGhlciBpZGVudGlmaWVyXG4gICAgICAgICAgICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGVtcGRlZmVyLmxlbmd0aDsgaSsrICkgeyAvL2xlbmd0aCBuZWVkcyB0byB1cGRhdGVcbiAgICAgICAgICAgICAgICAvLyBfdGhpcy5fY2FsbGVyID0gdGVtcGRlZmVyW2ldLnNwbGljZSggdGVtcGRlZmVyW2ldLmxlbmd0aC0xLCAxIClcbiAgICAgICAgICAgICAgICAvLyB0ZW1wZGVmZXJbaV1bMV0gPSB0aGlzLnN0YW1wKClcbiAgICAgICAgICAgICAgICAvLyB0cnl7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdMRVRTIFRSWSBnbyBnbyBnbycsdmFsLCBpLCB0ZW1wZGVmZXJbaV0pXG4gICAgICAgICAgICAgICAgICAvLyB2YXIgc3RhbXB4ID0gdGVtcGRlZmVyW2ldWzFdXG4gICAgICAgICAgICAgICAgICAgIC8vICwgdmFseCA9IHRlbXBkZWZlcltpXVswXVxuXG4gICAgICAgICAgICAgICAgICBvcmlnVXBkYXRlLmFwcGx5KCBfdGhpcywgdGVtcGRlZmVyW2ldICkgIFxuXG4gICAgICAgICAgICAgICAgICAvLyBpZiggKHRlbXBkZWZlcltpXVsxXSAmJiB0ZW1wZGVmZXJbaV1bMV0hPT1zdGFtcHgpIHx8ICh0ZW1wZGVmZXJbaV1bMF0gJiYgdGVtcGRlZmVyW2ldWzBdIT09dmFseCkgKSB7XG4gICAgICAgICAgICAgICAgICAvLyAgIGNvbnNvbGUud2FybignZGVmZXIgbmV3IHVwZGF0ZSB3aXRoaW4gdGhlIGxvb3Agbm93IGl0IGZpcmVzISAtLSBiZSBjYXJlZnVsbCBtYXkgYnJlYWsnKVxuICAgICAgICAgICAgICAgICAgLy8gICB2YXIgcmVmID0gdGVtcGRlZmVyW2ldXG4gICAgICAgICAgICAgICAgICAvLyAgIC8vIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyBcbiAgICAgICAgICAgICAgICAgIC8vICAgICBfdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgICAgICAgICAgIC8vICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuICAgICAgICAgICAgICAgICAgLy8gICAgIF90aGlzW2luUHJvZ3Jlc3NdID0gbnVsbFxuICAgICAgICAgICAgICAgICAgLy8gICAgIF90aGlzLmNsZWFyUmVmZXJlbmNlc0NhY2hlKClcbiAgICAgICAgICAgICAgICAgIC8vICAgICAvLyBjb25zb2xlLmxvZygnPz8/Pz8nLHJlZilcbiAgICAgICAgICAgICAgICAgIC8vICAgICBfdGhpcy5fdXBkYXRlLmFwcGx5KCBfdGhpcywgcmVmICkgXG4gICAgICAgICAgICAgICAgICAvLyAgIC8vIH0gLDEwMCkgXG4gICAgICAgICAgICAgICAgICAvLyAgIC8vIGFsZXJ0KCduZXcgdXBkYXRlIHNldCB3aXRoaW4gbG9vcCEnKVxuXG4gICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgLy8gfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3IoJ1dBJywgZSl9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvL2xpc3RlbmVyIGdldHMgcmVtb3ZlZCBidXQgb3JkZXIgaXMgZGlmZmVyZW50XG4gICAgICAgICAgICAgIGlmKCB0aGlzLnJlbW92ZUxpc3RlbmVyICkgdGhpcy5yZW1vdmVMaXN0ZW5lciggcmVjdXIgKVxuXG4gICAgICAgICAgICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKCB0eXBlb2Ygdm9iaiA9PT0gJ2Z1bmN0aW9uJyApXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgaWYoICFfdGhpc1tpblByb2dyZXNzXSApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZuID0gZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgaWYoIHZhbCE9PXRydWUgJiYgX3RoaXNbaW5Qcm9ncmVzc10gKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzW2luUHJvZ3Jlc3NdKClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIF90aGlzW2luUHJvZ3Jlc3NdID0gbnVsbFxuICAgICAgICAgICAgICAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfdGhpc1tpblByb2dyZXNzXSA9IHJlY3VyXG5cbiAgICAgICAgICAgICAgICBpZiggdm9iai5jYWxsKCB0aGlzLCBmbiAsIGFyciwgdGVtcGRlZmVyICkgPT09IHRydWUgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4gICAgICAgICAgICAgICAgICBfdGhpc1tpblByb2dyZXNzXSA9IG51bGxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gZWxzZVxuICAgICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCAnPycgKVxuICAgICAgICAgICAgICAgIC8vICAgLy9UT0RPOiBjaGVjayBpZiB0aGlzIGlzIHRoZSBiZXN0IHdheSwgKHVwZGF0aW5nIHJlY3VyLCBvciBtYXllYiBqdXN0IHVzZSB0aGUgc2FtZSByZWN1cilcbiAgICAgICAgICAgICAgICAvLyAgIF90aGlzLl9kZWZlcmlucHJvZ3Jlc3MgPSByZWN1clxuICAgICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoIHZvYmogPT09IHRydWUgKVxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgIGlmKCB0aGlzLnZhbCB8fCB0aGlzLnZhbCA9PT0gMCApXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcmlnVXBkYXRlLmFwcGx5KCBfdGhpcywgYXJyIClcbiAgICAgICAgICAgICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuICAgICAgICAgICAgICB9ICBcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvciggJ25vIHZhbHVlISBmcm9tIGRlZmVyIHR5cGU6JywgZmxhZylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiggIXZvYmouYWRkTGlzdGVuZXIgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBmb3IoIHZhciB2b2JqJCBpbiB2b2JqIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZvYmpbdm9iaiRdLmFkZExpc3RlbmVyKCByZWN1ciApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICB2b2JqLmFkZExpc3RlbmVyKCByZWN1ciApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRlZmVyWzFdID0gcmVjdXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyggZmxhZywgb25jZSwgJ3Nob3VsZCBkbyBvcmlnIHVwZGF0ZSBiaXRjaGVzIScsIGFyZ3VtZW50cywgdGhpcyApXG4gICAgICAgIG9yaWdVcGRhdGUuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICB9XG5cbiAgICB9XG4gIClcblxufSBcblxuLy9UT0RPOiBpbmplY3RhYmxlXG4vL1RPRE86X3RlbXBkZWZlciBob2VmdCBuaWV0IGFsdGlqZCBtYWFrIGNyZWF0ZSAtLSB1cGRhdGUgdHlwZSBmbGFnXG4vL2Fsd2F5cyB1cGRhdGUgbWV0aG9kXG4vLyBleHBvcnRzLmNyZWF0ZSggJ2ZvcmNlJywgXG4vLyB7IGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUgKSB7XG4vLyAgICAgdmFyIF90aGlzID0gdGhpc1xuLy8gICAgIC8vZGl0IHppdCBuYXR1dXJsaWprIGRpZXBlciFcbi8vICAgICBfdGhpcy5fc2tpcCA9IHRydWUgLy9tYXliZSBjaGVjayBpZiBpdCBybHkgZ2V0cyByZXNldD9cbi8vICAgICBfdGhpcy5faWdub3JlVmFsdWUgPSB0cnVlXG4vLyAgICAgX3RoaXMuY2xlYXJDYWNoZSgpXG4vLyAgICAgX3RoaXNbIHRlbXBTdG9yZSBdID0gbnVsbFxuLy8gICAgIHVwZGF0ZS5hcHBseSggX3RoaXMsIGFyZ3MgKVxuLy8gICB9ICBcbi8vIH0pXG4vL2RlemUgbW9ldCBub2cgd2F0IGRpZXBlclxuXG4vLyBleHBvcnRzLmNyZWF0ZSggJ2hpc3RvcnknLCBcbi8vIHsgZGVmZXJNZXRob2Q6IGZ1bmN0aW9uKCBhcmdzLCB2b2JqLCB0ZW1wU3RvcmUsIHVwZGF0ZSwgQ29uc3RydWN0b3IgKSB7XG4vLyAgICAgLy92b2JqIG9wdGlvbiB2b29yIGZsYWdcbi8vICAgICBpZighdGhpcy5faGlzdG9yeSkgdGhpcy5faGlzdG9yeSA9IFtdXG5cbi8vICAgICB0aGlzLl9oaXN0b3J5LnVuc2hpZnQoIGFyZ3MgKVxuLy8gICAgIHRoaXNbdGVtcFN0b3JlXSA9IG51bGwgLy90b3RhbCBjb250cm9sISAob2xkIGluY2x1ZGluZyBhcmd1bWVudHMpXG5cbi8vICAgICAvL2FsbHJpZ2h0IHRoYXQgd29ya3MgdGhpcy5jbGVhckNhY2hlKCkgLy9jYWNoZSBkaW5nZW4gYWRkZW5cbi8vICAgICB1cGRhdGUuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuLy8gICB9XG4vLyB9KVxuXG4vLyBleHBvcnRzLmNyZWF0ZSggJyR0eXBlJywgXG4vLyB7IGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUgKSB7XG4vLyAgICAgdmFyIF90aGlzID0gdGhpc1xuLy8gICAgICAgLCBoYXZlVG9VcGRhdGVcblxuLy8gICAgIC8vYXJyYXlzIGV0Y1xuLy8gICAgIF90aGlzLmNsZWFyQ2FjaGUoKVxuXG4vLyAgICAgaWYoIHZvYmogPT09IHRydWUgKVxuLy8gICAgIHtcbi8vICAgICAgIGlmKCBfdGhpcy52YWwgKSBoYXZlVG9VcGRhdGUgPSB0cnVlXG4vLyAgICAgfVxuLy8gICAgIGVsc2UgaWYoIHZvYmogPT09ICdzdHJpbmcnIClcbi8vICAgICB7XG4vLyAgICAgICBpZiggdHlwZW9mIF90aGlzLnZhbCA9PT0gJ3N0cmluZycgKSBoYXZlVG9VcGRhdGUgPSB0cnVlXG4vLyAgICAgfVxuLy8gICAgIGVsc2UgaWYoIHZvYmogPT09ICdudW1iZXInIClcbi8vICAgICB7XG4vLyAgICAgICBpZiggdHlwZW9mIF90aGlzLnZhbCA9PT0gJ251bWJlcicgKSBoYXZlVG9VcGRhdGUgPSB0cnVlXG4vLyAgICAgfVxuLy8gICAgIGVsc2UgaWYoIHR5cGVvZiB2b2JqID09PSAnZnVuY3Rpb24nIClcbi8vICAgICB7XG4vLyAgICAgICBpZiggdm9iai5hcHBseSggX3RoaXMsIGFyZ3MgKSApIGhhdmVUb1VwZGF0ZSA9IHRydWVcbi8vICAgICB9XG5cbi8vICAgICBpZiggaGF2ZVRvVXBkYXRlICkge1xuLy8gICAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcbi8vICAgICAgIHVwZGF0ZS5hcHBseSggX3RoaXMsIGFyZ3MgKVxuLy8gICAgIH1cbi8vICAgfSAgXG4vLyB9KVxuXG5leHBvcnRzLmNyZWF0ZSggJyRidWJibGUnLCB7IFxuICBkZWZlck1ldGhvZDogZnVuY3Rpb24oIGFyZ3MsIHZvYmosIHRlbXBTdG9yZSwgdXBkYXRlICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICB2YXIgZG9VcGRhdGVcbiAgICB2YXIgcmVmZXJlbmNlc1xuICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG5cbiAgICBpZiggdm9iaiApIHtcbiAgICAgIGlmKHJlZmVyZW5jZXMgPSB2b2JqLnJlZmVyZW5jZXMpIHtcbiAgICAgICAgaWYocmVmZXJlbmNlcyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIGlmKHJlZmVyZW5jZXMuJGx0ZSBcbiAgICAgICAgICAgICYmIF90aGlzLnJlZmVyZW5jZUxldmVsKF90aGlzLl91cGRhdGVPcmlnaW4pIDw9IHJlZmVyZW5jZXMuJGx0ZSBcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRvVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmKHJlZmVyZW5jZXMgPiAtMSkge1xuICAgICAgICAgIC8vYWxzbyBtYXhpbXVtIGZvciBleGFtcGxlXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcihfdGhpcy5fcGF0aCwgX3RoaXMucmVmZXJlbmNlTGV2ZWwoX3RoaXMuX3VwZGF0ZU9yaWdpbiksICd1T3JpZ2luUGF0aCcsIF90aGlzLl91cGRhdGVPcmlnaW4uX3BhdGgsICcuX3ZhbCcsX3RoaXMuX3ZhbC5fcGF0aCwgICdjbG91ZCcsICEhX3RoaXMuX3ZhbC5jbG91ZClcbiAgICAgICAgICBpZiggX3RoaXMucmVmZXJlbmNlTGV2ZWwoX3RoaXMuX3VwZGF0ZU9yaWdpbikgPT09IHJlZmVyZW5jZXMgKSB7XG4gICAgICAgICAgICBkb1VwZGF0ZSA9IHRydWVcbiAgICAgICAgICB9IFxuICAgICAgICB9IFxuICAgICAgICAvLyBlbHNlIGlmKHJlZmVyZW5jZXMgPT09IHRydWUpIHtcbiAgICAgICAgLy8gICAvL29ubHkgaWYgcmVmZmVyZW5jZVxuICAgICAgICAvLyAgIGlmKF90aGlzLnJlZmVyZW5jZUxldmVsKF90aGlzLl91cGRhdGVPcmlnaW4pIT09ZmFsc2UpIHtcbiAgICAgICAgLy8gICAgIGRvVXBkYXRlID0gdHJ1ZVxuICAgICAgICAvLyAgIH0gXG4gICAgICAgIFxuICAgICAgICAvLyB9XG5cbiAgICAgIH0gZWxzZSBpZiggdm9iaiAmJiB2b2JqLnNlbGYgPT09IHRydWUgKXtcblxuICAgICAgICAgIGlmKCBhcmdzWzJdID09PSB2b2lkIDAgfHwgdGhpcy5fdmFsID09PSBhcmdzWzBdIHx8ICFhcmdzWzBdICYmIHRoaXMuX3VwZGF0ZU9yaWdpbj09PXRoaXMpIHtcbiAgICAgICAgICAgIGRvVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoZG9VcGRhdGUpIHsgIFxuICAgICAgICAgIHVwZGF0ZS5hcHBseShfdGhpcywgYXJncylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5jbGVhclJlZmVyZW5jZXNDYWNoZSgpXG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlLmFwcGx5KF90aGlzLCBhcmdzKVxuICAgICAgfVxuXG4gICBcbiAgfSAgXG59KVxuXG5leHBvcnRzLmNyZWF0ZSggJ2RlZmVyJyApXG5cbi8vVE9ETzogdk9iaiBmbGFnICggYWNjZXNzYWJsZSB0cm91Z2ggb2JqZWN0W2ZsYWddIClcblxuVmFsdWUub3BlcmF0b3JzLnJlc3BvbnNlRGF0YSA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gb3BlcmF0b3I9PT1mYWxzZSA/IHZhbCA6IG9wZXJhdG9yXG59XG5cbi8vdm9iaiBwYXJzZXIhXG5cbmV4cG9ydHMuY3JlYXRlKCAnYWpheCcsIFxueyByZW1vdmU6IGZ1bmN0aW9uKCByZW1vdmUsIGFyZ3MgKSB7XG4gICAgLy9UT0RPOiBhamF4IGNhbGwgc3RvcFxuICAgIHJlbW92ZS5hcHBseSggdGhpcywgYXJncyApXG4gIH1cbiwgc2V0OmZ1bmN0aW9uKCBzZXQsIGFyZ3MpIHtcbi8vICAgICBjb25zb2xlLmxvZygnc2V0IGFqYXggZGVmZXInKVxuICAgIGlmKCAhIHRoaXMubG9hZGluZyApIHtcbiAgICAgIC8vbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb21cbiAgICAgIHRoaXMuc2V0KCAnbG9hZGluZycsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUgKVxuICAgIH1cbiAgICBzZXQuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICB9XG4sIGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUsIENvbnN0cnVjdG9yICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMgIFxuXG4gICAgcmV0dXJuIHZvYmogJiYgZnVuY3Rpb24oIHVwZGF0ZSwgYXJncyApIHtcblxuICAgICAgdmFyIG9yaWd1ID0gdXBkYXRlXG5cbiAgICAgIHVwZGF0ZSA9IGZ1bmN0aW9uKCB0eXBlLCBraWxsICkge1xuICAgICAgICBfdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgX3RoaXMuX3NraXAgPSB0cnVlXG4gICAgICAgIF90aGlzLl9pZ25vcmVWYWx1ZSA9IHRydWVcbiAgICAgICAgaWYoIHR5cGUgKSB7XG4gICAgICAgICAgYXJnc1swXSA9IHR5cGVcbiAgICAgICAgICBpZighICggX3RoaXMuX3ZhbCBpbnN0YW5jZW9mIHZPYmplY3QgKSApIHtcbiAgICAgICAgICAgIF90aGlzLnZhbCA9IHR5cGVcbiAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIGlmKCBfdGhpcy5sb2FkaW5nICkgX3RoaXMubG9hZGluZy52YWwgPSBmYWxzZVxuICAgICAgICBvcmlndSgga2lsbCApXG4gICAgICAgIF90aGlzLl9pZ25vcmVWYWx1ZSA9IG51bGxcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGVvZiB2b2JqID09PSAnb2JqZWN0JyApXG4gICAgICB7XG4gICAgICAgIHZhciBwYXJhbXMgPSB2b2JqXG4gICAgICAgIHZvYmogPSB7fVxuICAgICAgICBmb3IoIHZhciBrZXkgaW4gcGFyYW1zICkge1xuICAgICAgICAgIGlmKCBrZXkgPT09ICdkZWZlcicgKSB7XG4gICAgICAgICAgICB2b2JqW2tleV0gPSBwYXJhbXNba2V5XVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZighdm9ialtrZXldKSB7XG4gICAgICAgICAgICAgIGlmKCBrZXkgIT09ICdjb21wbGV0ZScgJiYga2V5ICE9PSAnZXJyb3InICYmIHR5cGVvZiBwYXJhbXNba2V5XSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICAgICAgICB2b2JqWyBrZXkgXSA9IHBhcmFtc1sga2V5IF0uY2FsbCggX3RoaXMsIHZvYmosIGFyZ3NbMF0sIGFyZ3MgKVxuICAgICAgICAgICAgICAgIGlmKCAhdm9ialtrZXldICkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdm9ialtrZXldID0gcGFyYW1zW2tleV1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmKCB2b2JqW2tleV0gaW5zdGFuY2VvZiB2T2JqZWN0ICkge1xuICAgICAgICAgICAgICAgIHZvYmpba2V5XSA9IHZvYmpba2V5XS52YWwgLy9jdXN0b20gZ2V0IG9yIHJhd1xuICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggdHlwZW9mIHZvYmogPT09ICdmdW5jdGlvbicgKSBcbiAgICAgIHtcbiAgICAgICAgdm9iaiA9IHZvYmouY2FsbCggX3RoaXMsIHZvYmosIGFyZ3NbMF0sIGFyZ3MgKVxuICAgICAgICBpZighdm9iaikgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgaWYoIHR5cGVvZiB2b2JqID09PSAnc3RyaW5nJyApIFxuICAgICAge1xuICAgICAgICB2b2JqID0geyB1cmw6IHZvYmogfVxuICAgICAgfVxuXG4gICAgICBpZiggdm9iai51cmwgaW5zdGFuY2VvZiB2T2JqZWN0ICkge1xuICAgICAgICB2b2JqLnVybCA9IHZvYmoudXJsLnZhbFxuICAgICAgfVxuXG4gICAgICBpZiggIXZvYmogfHwgISggdm9iai51cmwgfHwgdm9iai5hcGkgKSApIFxuICAgICAge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGxldGUgPSB2b2JqLmNvbXBsZXRlXG4gICAgICAgICwgZXJyb3IgPSB2b2JqLmVycm9yXG5cbiAgICAgIHZvYmouY29tcGxldGUgPSBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgaWYoIHZvYmouZGVmZXIgKSBcbiAgICAgICAge1xuICAgICAgICAgIHZvYmouZGVmZXIuY2FsbCggX3RoaXMsIHVwZGF0ZSwgYXJncywgbnVsbCwgZGF0YSwgdm9iaiApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgaWYoIV90aGlzLnJlc3BvbnNlRGF0YSkge1xuICAgICAgICAgICAgX3RoaXMuc2V0KCAncmVzcG9uc2VEYXRhJywgZGF0YSApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VEYXRhLm1lcmdlKCBkYXRhIClcbiAgICAgICAgICB9XG4gICAgICAgICAgO2NvbXBsZXRlICYmIGNvbXBsZXRlKCBkYXRhIClcbiAgICAgICAgICB1cGRhdGUoICdzdWNjZXNzJyApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdm9iai5lcnJvciA9IGZ1bmN0aW9uKCBlcnIgKSB7XG4gICAgICAgIGlmKCB2b2JqLmRlZmVyICkgXG4gICAgICAgIHtcbiAgICAgICAgICB2b2JqLmRlZmVyLmNhbGwoIF90aGlzLCB1cGRhdGUsIGFyZ3MsIGVyciwgdm9iaiApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICB7XG4gICAgICAgICAgaWYoIF90aGlzLnJlc3BvbnNlRGF0YSApXG4gICAgICAgICAgeyBcbiAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlRGF0YS5lYWNoKCBmdW5jdGlvbigga2V5ICkge1xuICAgICAgICAgICAgICBpZiggIUNvbnN0cnVjdG9yLm9wZXJhdG9yc1trZXldICYmICFDb25zdHJ1Y3Rvci5mbGFnc1trZXldIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuc2V0KCAncmVzcG9uc2VEYXRhJyAsIHZvaWQgMCApXG4gICAgICAgICAgaWYoIGVycm9yICkgZXJyb3IoIGRhdGEgKVxuICAgICAgICAgIHVwZGF0ZSggJ2Vycm9yJyApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIF90aGlzLmxvYWRpbmcgKSB7XG4gICAgICAgIC8vVE9ETzpjb3JyZWN0IHJlc3BvbnNlcyBtYW5hZ2VtZXQgLS0gcHJldHR5IGVhc3kgdG9kb1xuICAgICAgICBfdGhpcy5sb2FkaW5nLnZhbCA9IHRydWVcbiAgICAgIH1cblxuICAgICAgYWpheCggdm9iaiApIC8vVE9ETzogbGV0IGl0IHJldHVybiBhIHByb21pc2VcbiAgICB9ICBcbiAgfVxufSlcblxuLy90ZW1wIGFyZ3MgXG5cbi8vVE9ETzogZGl0IGxhdGVyIHZlcnZhbmdlbiBtZXQgbG9jYWwgZmxhZ3MgKGFwaSlcbi8vVE9ETzogdW5pZnkgYWpheCBoaWVybWVlIHZvb3Igb25jc2l0ZW50IGVycm9yIGhhbmRlbGluZyAtLSBvZiBleHRlbnNpb24gb3AgYWpheFxuZXhwb3J0cy5jcmVhdGUoICdhcGlEZWZlcicsIFxueyByZW1vdmU6IGZ1bmN0aW9uKCByZW1vdmUsIGFyZ3MgKSB7XG4gICAgLy9UT0RPOiBhamF4IGNhbGwgc3RvcFxuICAgIHJlbW92ZS5hcHBseSggdGhpcywgYXJncyApXG4gIH1cbiwgc2V0OmZ1bmN0aW9uKCBzZXQsIGFyZ3MpIHtcbiAgICBpZighIHRoaXMubG9hZGluZyApIHtcbiAgICAgIHRoaXMuc2V0KCAnbG9hZGluZycsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUgKVxuICAgIH1cbiAgICBzZXQuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICB9XG4sIGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUsIENvbnN0cnVjdG9yLCBpblByb2dyZXNzICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMgIFxuICAgXG4gICAgcmV0dXJuIHZvYmogJiYgZnVuY3Rpb24oIHVwZGF0ZSwgYXJncyApIHtcblxuICAgICAgaWYoICFhcmdzWzBdIHx8IGFyZ3NbMF0uYXBpRGVmZXIgKSByZXR1cm4gdHJ1ZVxuXG4gICAgICB2YXIgd3JhcHBlZFVwZGF0ZSA9IGZ1bmN0aW9uKCB2YWwsIGtpbGwgKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignRE8gRE8gRE8nLCB2YWwsIF90aGlzLCB0ZW1wU3RvcmUsIF90aGlzW3RlbXBTdG9yZV0pXG5cbiAgICAgICAgLy8gX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcbiAgICAgICAgICAgXG4gICAgICAgIC8vIF90aGlzW2luUHJvZ3Jlc3NdID0gbnVsbFxuXG5cbiAgICAgICAgX3RoaXMubG9hZGluZy52YWwgPSBmYWxzZVxuICAgICAgICBpZiggdmFsICYmIHZhbCE9PXRydWUgKSBcbiAgICAgICAge1xuICAgICAgICAgIF90aGlzLnZhbCA9IGFyZ3NbMF0gPSB2YWxcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdXBkYXRlKCB2YWwgKSAvL3ZhbCAtLSB2YWxcbiAgICAgICAgICB9IGNhdGNoKCBlcnIgKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCAnREVFUEVSIEVSUk9SIElOIEFQSSBERUZFUiAsIFNPTUVUSElORyBXUk9ORyAvdyB0aGlzIEFQSScsIHZhbCApXG4gICAgICAgICAgICAvL2Jlc3QgZXhhbXBsZSBpcyBmYWNlYm9vayBsb2dpbiB0cnVlIGFuZCBnb25lIGJ1dCBvbmx5IHdlaCB0aGUgLmxvYWRpbmcgaXMgdGhlcmVcbiAgICAgICAgICAgIC8vbW9zdCBiZSBhIHZlcnkgZGVlcCBpc3N1ZXMgaSBnZXVzcy4uLiBoYXJkIHRvIHJlY3JlYXRlIFxuICAgICAgICAgICAgX3RoaXMudHlwZSA9IGVyclxuXG4gICAgICAgICAgICAvL3RoaXMgaXMgd3JvbmcgbWlzc2VzIF90aGlzIGNhbGwgYW5kIG90aGVyIGFyZ3NcbiAgICAgICAgICAgIHVwZGF0ZSggJ2Vycm9yJyApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RoaXMuY2xlYXJDYWNoZSgpXG4gICAgICAgICAgX3RoaXMuX3ZhbCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBcbiAgICAgICAge1xuICAgICAgICAgIC8vdGhpcyBpcyB3cm9uZyBtaXNzZXMgX3RoaXMgY2FsbCBhbmQgb3RoZXIgYXJnc1xuICAgICAgICAgIHVwZGF0ZSggdmFsIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBfdGhpcy5sb2FkaW5nLnZhbCA9IHRydWVcbiAgICAgIHZhciBhcGkgPSBfdGhpcy5jaGVja1BhcmVudCggJ2FwaScsIHRydWUgKVxuXG4gICAgICBpZiggYXBpICYmIGFwaS52YWwgIT09IHRydWUgKSBcbiAgICAgIHtcblxuICAgICAgICBhcGkub25jZShmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgIGlmKCB2YWwgPT09ICdlcnJvcicgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhckNhY2hlKCkgLy9oaWVyIGZmIGVlbiBmdW5jdGllIHZvb3IgbWFrZW4hXG4gICAgICAgICAgICBfdGhpcy52YWwgPSBhcmdzWzBdID0gJ2Vycm9yJ1xuICAgICAgICAgICAgX3RoaXMudHlwZSA9IHRoaXMudHlwZSB8fCAnYXBpJ1xuICAgICAgICAgICAgX3RoaXMubG9hZGluZy52YWwgPSBmYWxzZVxuICAgICAgICAgICAgd3JhcHBlZFVwZGF0ZSgpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIHZhbCA9PT0gdHJ1ZSApXG4gICAgICAgICAge1xuICAgICAgICAgICAgdm9iai5jYWxsKCBfdGhpcywgd3JhcHBlZFVwZGF0ZSwgYXJncyApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBhcGkudmFsID0gdHJ1ZVxuICAgICAgfSBcbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgdm9iai5jYWxsKCBfdGhpcywgd3JhcHBlZFVwZGF0ZSwgYXJncyApXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuXG5leHBvcnRzLmNyZWF0ZSggJ2luaXQnLCBcbnsgc2V0OiBmdW5jdGlvbiggc2V0LCBhcmdzICkge1xuICAgIGlmKCAhdGhpcy5pbml0aWFsaXNlZCApXG4gICAge1xuICAgICAgc2V0LmFwcGx5KCB0aGlzLCBhcmdzICkgLy9uaWV0IG5vZGlnIVxuICAgIH1cbiAgfVxuLCByZW1vdmU6IGZ1bmN0aW9uKCByZW1vdmUsIGFyZ3MgKSB7XG4gICAgcmVtb3ZlLmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgICB0aGlzLmluaXRpYWxpc2VkID0gbnVsbFxuICB9XG4sIG9uY2U6ICdpbml0aWFsaXNlZCdcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1xuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGZsYWdzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpO1xuXG4vKipcbiAqIHNlbGZcbiAqIEBmbGFnXG4gKi9cbmZsYWdzLnNlbGYgPSB7XG4gIHJlc2V0OiB0cnVlLFxuICB1c2VWYWw6dHJ1ZSxcbiAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AubmFtZScpXG4gICAgaWYgKGN1cnJlbnQuX2Jhc2UgJiYgY3VycmVudC5fYmFzZVt2YWxdKSB7XG4gICAgICBjdXJyZW50Ll9iYXNlW3ZhbF0uYWRkTGlzdGVuZXIodGhpcylcbiAgICAgIHRoaXMuX3ZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpc1t2YWxdICYmIHRoaXNbdmFsXS52YWxcbiAgICAgIH1cbiAgICAgIGlmKCF0aGlzLl9mbGFnKSAgdGhpcy5fZmxhZyA9IHt9XG4gICAgICB0aGlzLl9mbGFnLnNlbGYgPSBbJ3NlbGYnLCB0aGlzLl92YWwsIHZhbCwgdGhpc11cbiAgICB9XG4gIH1cbn07XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciBmbGFncyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKVxuLyoqXG4gKiBsaXN0ZW5cbiAqIGFkZHMgbGlzdGVuZXJzIHRvIGEgVi5WYWx1ZVxuICogQHByb3BlcnR5XG4gKiovXG5mbGFncy5saXN0ZW4gPSB7XG4gIHJlc2V0OnRydWUsXG4gIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQpIHtcbiAgICBpZighdmFsKVxuICAgIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ25vIHZhbCBpbiBmbGFncyBsaXN0ZW4hJylcbi8vICAgICAgIGRlYnVnZ2VyXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYoIXRoaXMuX2ZsYWcpIHRoaXMuX2ZsYWcgPSB7fVxuICAgIC8vZXZlbnR1ZWVsIG1lcmdlbiFcbiAgICAgIFxuICAgIC8vIGNvbnNvbGUubG9nKCdsaXN0ZW4nLmN5YW4uaW52ZXJzZSwgcmVzZXQsIHZhbClcbiAgICAvL2lmIHJlc2V0IG1ha2Ugc3VyZSBpdHMgcmVzZXR0ZWQgY29ycmVjdGx5IVxuICAgIHRoaXMuX2ZsYWcubGlzdGVuID0gWydsaXN0ZW4nLCBmYWxzZSwgdmFsLCB0aGlzIF0gXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBmb3IgKHZhciBpID0gdmFsLmxlbmd0aCAtIDE7IGkgPj0gMDsgdmFsW2ktLV0uYWRkTGlzdGVuZXIodGhpcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvL29rXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAvLyB2YWwuYWRkTGlzdGVuZXIoZnVuY3Rpb24oKSB7XG4gICAgICAvLyAgIGNvbnNvbGUubG9nKCdUUk9VR0ggTElTVEVOISEhIScubWFnZW50YS5pbnZlcnNlLCB2YWwuX3BhdGgpXG4gICAgICAvLyAgIC8vIF90aGlzLl91cGRhdGUuYXBwbHkoX3RoaXMsIGFyZ3VtZW50cylcbiAgICAgIC8vIH0pIFxuICAgICAgdmFsLmFkZExpc3RlbmVyKHRoaXMpIC8vZGl0IG1vZXQgYmV0ZXIgKHJlbW92ZSBsaXN0ZW5lciBpZiBwb3NzaWJsZSlcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTpmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLl9mbGFnJiZ0aGlzLl9mbGFnLmxpc3Rlbikge1xuICAgICAgdmFyIHZhbCA9IHRoaXMuX2ZsYWcubGlzdGVuWzJdXG4gICAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHZhbC5sZW5ndGggLSAxOyBpID49IDA7IHZhbFtpLS1dLnJlbW92ZUxpc3RlbmVyKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbC5yZW1vdmVMaXN0ZW5lcih0aGlzKSAvL2RpdCBtb2V0IGJldGVyIChyZW1vdmUgbGlzdGVuZXIgaWYgcG9zc2libGUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgb2JqZWN0ID0gcmVxdWlyZSggJy4uL29iamVjdCcgKVxuICAsIHV0aWwgPSByZXF1aXJlKCAnLi4vdXRpbCcgKVxuICAsIHZpZ291ciA9IHJlcXVpcmUoICcuLi8nIClcblxuLyoqXG4gKiB2aWdvdXIuVmFsdWVcbiAqIHYgdmFsdWVzIGFyZSBvcHRpbWl6ZWQgZm9yIHVzZSBpbiBjb21iaW5hdGlvbiAvdyBpbnN0YW5jZXMgb2Ygdmlnb3VyQmFzZSwgaGF2ZSBvcGVyYXRvcnMgYW5kIHN1cHBvcnQgbWV0aG9kIHZhbHVlc1xuICogQENsYXNzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHZpZ291ci5WYWx1ZSA9IG9iamVjdC5uZXcoXG57IG1peGVkOiB0cnVlXG4sIG1lcmdlOiB0cnVlXG59KVxuXG4vL3BhcmVudCBwcm9ibGVtc1xuXG52YXIgX2dldE9wZXJhdG9yID0gZnVuY3Rpb24oIHZhbCwgZm9yY2UsIGksIHQsIGJpbmQsIG9wZXJhdG9ycyApIHtcbiAgdmFyIGYgPSB0W2ldLl9nZXQoYmluZCwgZm9yY2UsIHZhbCk7XG4gIGlmIChmICE9PSB2b2lkIDAgJiYgZiAhPT0gbnVsbCkge1xuICAgIHZhbCA9IG9wZXJhdG9yc1tpXSh2YWwgfHwgKCh0eXBlb2YgZiA9PT0gJ3N0cmluZycpID8gJycgOiAwKSwgZik7XG4gIH1cbiAgcmV0dXJuIHZhbDtcbn07XG5cbmV4cG9ydHMucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX2xzdGFtcCcsICdfY2xlYXJDYWNoZScsICdfbHZhbCcsICdfX2x2YWwnLCdfX19sdmFsJywgJ19iYXNlJywgJ19jYWxsZXInLCAnX2JpbmQnLCAnX3Byb3AnLCAnX2luc3RhbmNlcycsICdfc2tpcCcsICdfb3ZlcndyaXRlJylcbi8vX2NhbGxlciBzdGFtcCBmb3IgZ2V0IGZvciBsdmFscyAobGFzdCB2YWx1ZXMpXG51dGlsLmRlZmluZShleHBvcnRzLFxuICAnY2xlYXJDYWNoZScsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX19fbHZhbCA9IG51bGxcbiAgICB0aGlzLl9fbHZhbCA9IG51bGxcbiAgICB0aGlzLl9sdmFsID0gbnVsbCBcbiAgfSxcbiAgJ2NsZWFyUmVmZXJlbmNlc0NhY2hlJywgZnVuY3Rpb24oKSB7XG4gICAgZnJvbSA9IHRoaXMuX3ZhbFxuICAgIHdoaWxlKGZyb20pIHtcbiAgICAgIGlmKGZyb20uY2xlYXJDYWNoZSkgZnJvbS5jbGVhckNhY2hlKClcbiAgICAgIGlmKGZyb20gJiYgZnJvbS5fdmFsKSB7XG4gICAgICAgIGZyb20gPSBmcm9tLl92YWxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyb20gPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAnaWdub3JlQ2FjaGUnLCB7IGdldDpmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0ID0gdGhpc1xuICAgICAgd2hpbGUodCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaG9lIHppdCBoZXQ/PycsdCApXG4gICAgICAgIGlmKCB0Ll9wcm9wICYmIHQuX3Byb3AuY2FjaGUgPT09IGZhbHNlICkgcmV0dXJuIHRydWVcbiAgICAgICAgdCA9IHQuX3BhcmVudFxuICAgICAgfSBcbiAgICB9IFxuICB9LFxuICAvKipcbiAgICogVXNlZCB0byBnZXQgLnZhbCB3aGljaCBjYWxjdWxhdGVzIGEgY29uc3RydWN0ZWQgdmFsdWVcbiAgICogX2JpbmQgaXMgdmVyeSBpbXBvcnRhbnQgYmluZHMgbGlzdGVuZXJzIHRvIHNwZWNpZmljIGluc3RhbmNlc1xuICAgKiBAbWV0aG9kIF9nZXRcbiAgICogQHBhcmFtICB7W3R5cGVdfSBiaW5kICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZm9yY2UgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICAnX2dldCcsIGZ1bmN0aW9uKGJpbmQsIGZvcmNlLCBjdXJyZW50VmFsKSB7XG5cbiAgICBpZih0aGlzLl9jbGVhckNhY2hlKSB7XG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdfZ2V0Jyx0aGlzLl9uYW1lLCB0aGlzLl92YWwsdGhpcyk7XG4gICAgaWYgKHRoaXMuX292ZXJ3cml0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX292ZXJ3cml0ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9sdmFsICYmIHRoaXMuX2x2YWwgIT09IDAgfHwgZm9yY2UpIHtcbiAgICAgIHZhciB2YWwgPSB0aGlzLl92YWwsXG4gICAgICAgIG5vbHZhbCxcbiAgICAgICAgb3BlcmF0b3JzID0gdGhpcy5vcGVyYXRvcnM7XG5cbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBvYmplY3QpIHtcbiAgICAgICAgdmFsID0gdmFsLl9nZXQodGhpcy5fYmluZCB8fCBiaW5kLCBmb3JjZSwgY3VycmVudFZhbCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnUklHSFQgSEVSRScsIGN1cnJlbnRWYWwpXG4gICAgICAgIHZhciBhID0gdGhpcztcbiAgICAgICAgaWYgKCFiaW5kKSB7XG4gICAgICAgICAgd2hpbGUgKGEuX3BhcmVudCAmJiAhYS5fY2FsbGVyKSB7XG4gICAgICAgICAgICBhID0gYS5fcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YWwgPSB2YWwuY2FsbChiaW5kIHx8IGEuX2NhbGxlciB8fCBhLl9iYXNlIHx8IHRoaXMsIHRoaXMsIGN1cnJlbnRWYWwpOyAvL2lmIGN1cnJlbnR2YWwgZWxzZSBzb21ldGhpbmcgZWxzZTtcbiAgICAgICAgbm9sdmFsID0gdHJ1ZTtcbiAgICAgICAgLy9mb3IgZnVuY3Rpb25zIHlvdSBuZWVkIHRvIGNsZWFyIF9sdmFsIHNpbmNlIHlvdSBuZXZlciBrbm93IGlmIHRoZXJlIGlzIHNvbWV0aGluZyBpbiB0aGUgZnVuY3Rpb24gdXBkYXRlZFxuICAgICAgfVxuICAgICAgaWYgKG9wZXJhdG9ycykge1xuICAgICAgICBpZiAodGhpcy5fX3QgPT09IDEgJiYgb3BlcmF0b3JzW3RoaXMuX25hbWVdKSB7IFxuICAgICAgICAgIC8vb3BlcmF0b3IgaXMgYW4gYXJyYXlcbiAgICAgICAgICB2YWwgPSAwOyAvL3N0cmluZ1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBsID0gdGhpcy5sZW5ndGg7IGogPCBsOyBqKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzW2pdKSB7XG4gICAgICAgICAgICAgIHZqID0gdGhpc1tqXS5fZ2V0KGJpbmQsIGZhbHNlLCAoY3VycmVudFZhbCB8fCAwKSArIHZhbCk7XG4gICAgICAgICAgICAgIGlmICghdmopIHtcbiAgICAgICAgICAgICAgICB2aiA9IDA7IC8vc3RyaW5nXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2aiA9PT0gJ3N0cmluZycgJiYgdmFsID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsID0gJyc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsICs9IHZqOyAvL29ubHkgYWRkIG5vIG9wZXJhdG9yIHN0dWZmXG4gICAgICAgICAgICAgIGlmICghdGhpc1tqXS5fbHZhbCkge1xuICAgICAgICAgICAgICAgIG5vbHZhbCA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9hbHNvIGFkZCBiZWZvcmVcbiAgICAgICAgICB2YXIgb3JkZXJlZDtcbiAgICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMpIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRvcnNbaV0pIHtcbiAgICAgICAgICAgICAgaWYgKCFvcGVyYXRvcnNbaV0ub3JkZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXNbaV0uX2xzdGFtcCAhPT0gdGhpcy5fbHN0YW1wICYmIHRoaXNbaV0uX190ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICBmb3JjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbCA9IF9nZXRPcGVyYXRvcih2YWwsIGZvcmNlLCBpLCB0aGlzLCBiaW5kLCBvcGVyYXRvcnMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9sdmFsICYmICF0aGlzW2ldLl9sdmFsKSB7XG4gICAgICAgICAgICAgICAgICBub2x2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob3JkZXJlZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCFvcmRlcmVkLnBvcCkge1xuICAgICAgICAgICAgICAgICAgICBvcmRlcmVkID0gW29yZGVyZWRdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIG8gPSBvcGVyYXRvcnNbaV0ub3JkZXIsXG4gICAgICAgICAgICAgICAgICAgIG9sID0gb3JkZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaCA9IDA7IGggIT09IHRydWUgJiYgaCA8PSBvbDsgaCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoID09PSBvbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChvIDwgb3BlcmF0b3JzW29yZGVyZWRbaF1dLm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IG9yZGVyZWRbaF07XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkW29sXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkLnB1c2goYSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaCA9PT0gb2wgJiYgbyA+IG9wZXJhdG9yc1tvcmRlcmVkW2hdXS5vcmRlcikge1xuICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWQucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICBoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBvcmRlcmVkID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy9zaG9ydGVyXG4gICAgICAgICAgaWYgKG9yZGVyZWQpIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG9yZGVyZWQpO1xuICAgICAgICAgICAgdmFyIHg7XG4gICAgICAgICAgICBpID0gb3JkZXJlZC5wb3AgPyAoeCA9IDEpICYmIG9yZGVyZWRbMF0gOiBvcmRlcmVkO1xuICAgICAgICAgICAgd2hpbGUgKGkgJiYgdGhpc1tpXSkge1xuICAgICAgICAgICAgICBpZiAoIWZvcmNlICYmIHRoaXNbaV0uX2xzdGFtcCAhPT0gdGhpcy5fbHN0YW1wICYmIHRoaXNbaV0uX190ID09PSAxKSBmb3JjZSA9IHRydWVcbiAgICAgICAgICAgICAgdmFsID0gX2dldE9wZXJhdG9yKHZhbCwgZm9yY2UsIGksIHRoaXMsIGJpbmQsIG9wZXJhdG9ycyk7XG4gICAgICAgICAgICAgIGlmICghbm9sdmFsICYmICF0aGlzW2ldLl9sdmFsKSBub2x2YWwgPSB0cnVlXG4gICAgICAgICAgICAgIGkgPSBvcmRlcmVkW3grK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW5vbHZhbCAmJiAhZm9yY2UpIHtcbiAgICAgICAgdGhpcy5fbHZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5fX2x2YWwgPSB2YWw7XG4gICAgICB9IGVsc2UgaWYgKCEodGhpcy5fYmFzZSAmJiB0aGlzLl9iYXNlLmluc3RhbmNlcykpIHtcbiAgICAgICAgdGhpcy5fX2x2YWwgPSB2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2x2YWw7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRmlyZXMgYWxsIGxpc3RlbmVyc1xuICAgKiBAbWV0aG9kIHVwZGF0ZVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGluc3RhbmNlICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBub2luc3RhbmNlcyBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhbXAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGZyb20gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSByZW1vdmUgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gYWRkZWQgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICd1cGRhdGUnLFxuICBmdW5jdGlvbihpbnN0YW5jZSwgbm9pbnN0YW5jZXMsIGluc3RhbmNlc1VwZGF0ZXMsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkKSB7XG4gICAgLy9pcyB0aGlzIHJlYWxseSBuZXNzZWNhcnk/XG4gICAgdGhpcy5fdXBkYXRlLmNhbGwoIHRoaXMsIHZvaWQgMCwgc3RhbXAgfHwgdGhpcy5zdGFtcCgpLCBmcm9tLCByZW1vdmUsIGZhbHNlLCBmYWxzZSwgbm9pbnN0YW5jZXMsIGluc3RhbmNlLCBpbnN0YW5jZXNVcGRhdGVzICApOyAvL3RoaXMudmFsXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBFeHRlbmRzIHZpZ291ck9iamVjdC5fdXBkYXRlXG4gICAqIEFkZHMgbG9hZHMgb2Ygc3R1ZmYgdG8gb3B0aW1pemUgdXBkYXRlcyBmb3IgY2FsY3VsYXRpb25zXG4gICAqIEBtZXRob2QgX3VwZGF0ZVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHZhbCAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFtcCAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZnJvbSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHJlbW92ZSAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBhZGRlZCAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gbm9pbnN0YW5jZXMgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGluc3RhbmNlICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnX3VwZGF0ZScsXG4gIGZ1bmN0aW9uKCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIG5vaW5zdGFuY2VzLCBpbnN0YW5jZSwgaW5zdGFuY2VzVXBkYXRlcyApIHtcblxuICAgIHZhciB0ID0gdGhpcyxcbiAgICAgIGJhc2UgPSB0Ll9iYXNlO1xuXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIGV4cG9ydHMgJiYgIXQuX2JpbmQpIFxuICAgIHtcbiAgICAgIGlmICh2YWwuX2NhbGxlcikge1xuICAgICAgICB0Ll9iaW5kID0gdmFsLl9jYWxsZXI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCAoIXQuX2xzdGFtcCkgfHwgdC5fbHN0YW1wICE9PSBzdGFtcCAgKSB7XG5cbiAgICAvLyB2YXIgb3BlcmF0b3JzID0gdC5vcGVyYXRvcnNcbiAgICAvLyB2YXIgbHZhbCBcbiAgICAvLyB2YXIgY2FsY1ZhbFxuICAgIC8vIHZhciBwYXNzVmFsdWVDYWNoZSBcblxuICAgIC8vIGlmKCAhdC5pZ25vcmVDYWNoZSApIHtcbiAgICAvLyAgIC8vVE9ETzogdGhpcyBpcyBhIHRlbXBvcmFyeSBmaXggbmVlZHMgdG8gYmUgZmFzdGVyXG4gICAgLy8gICAvL21ha2UgdGhpcyBhIG1ldGhvZFxuICAgIC8vICAgZnVuY3Rpb24gY2xlYW51cCh0KSB7XG4gICAgLy8gICBcdHQuX2x2YWwgPSB2b2lkIDBcbiAgICAvLyAgIFx0dC5fX2x2YWwgPSB2b2lkIDAgXG4gICAgLy8gICBcdGlmKHQuX3ZhbCBpbnN0YW5jZW9mIG9iamVjdCApIHtcbiAgICAvLyAgIFx0XHQvL1RPRE86IGlmIHN0dWZmIGRvZXNudCB1cGRhdGUgdW5jb21tZW50IHRoaXMgbGluZVxuICAgIC8vICAgXHRcdC8vIGNsZWFudXAodC5fdmFsKVxuICAgIC8vICAgXHR9XG4gIFx0IC8vICAgIGZvcih2YXIgJGZpZWxkIGluIHQpIHtcbiAgXHQgLy8gICAgXHRpZihvcGVyYXRvcnNbJGZpZWxkXSkge1xuICBcdCAvLyAgICBcdFx0Y2xlYW51cCh0WyRmaWVsZF0pXG4gIFx0IC8vICAgIFx0fSBlbHNlIGlmKCRmaWVsZCA+IC0xKSB7XG4gIFx0IC8vICAgIFx0XHRjbGVhbnVwKHRbJGZpZWxkXSlcbiAgXHQgLy8gICAgXHR9XG4gIFx0IC8vICAgIH1cbiAgICAvLyBcdH1cbiAgICAvLyAgIGNsZWFudXAodClcblxuICAgIC8vICAgbHZhbCA9IHQuX19fbHZhbFxuICAgIC8vICAgY2FsY1ZhbCA9IHQudmFsXG4gICAgLy8gICBwYXNzVmFsdWVDYWNoZSA9IGx2YWwgPT09IHZvaWQgMCB8fCBsdmFsICE9PSBjYWxjVmFsXG4gICAgLy8gICB0Ll9fX2x2YWwgPSBjYWxjVmFsXG5cbiAgICAvLyB9IGVsc2Uge1xuXG4gICAgICAvLyB0LmNsZWFyQ2FjaGUoKVxuICAgICAgLy8gcGFzc1ZhbHVlQ2FjaGUgPSB0cnVlXG4gICAgLy8gfVxuXG4gICAgIC8vIGlmICggIHBhc3NWYWx1ZUNhY2hlIHx8ICggYmFzZSAmJiBiYXNlLmluc3RhbmNlcyApIHx8IHQuX3NraXAgKSB7IC8vcGFzcyB0aGlzIGNhbGN1bGF0aW9uIHRvIHZzZXQgZWxzZSBpdHMgdG9vIGhlYXZ5O1xuXG4gICAgdC5fbHZhbCA9IGZhbHNlICBcbiAgICAvLyB0Ll9za2lwID0gdHJ1ZVxuICAgIGlmKGJhc2UgJiYgYmFzZS5pbnN0YW5jZXMgfHwgdC5fc2tpcCB8fCB0Ll9fbHZhbCA9PT0gdm9pZCAwIHx8IHQuX19fbHZhbCAhPT0gdC52YWwgKSB7XG5cbiAgICAgIC8vIGlmKHdpbmRvdy5zbXV0KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd3dGYgaXMgaGFwcGVuaW5nISEhIScsIHQuX3BhdGgsIHQsIHQuX3VwZGF0ZU9yaWdpbiwgYXJndW1lbnRzKVxuICAgICAgLy8gfVxuXG4gICAgICAgIHZhciBwcm9wID0gdC5fcHJvcCxcbiAgICAgICAgICBwYXJlbnQgPSB0Ll9wYXJlbnQsXG4gICAgICAgICAgdnNldCA9IHByb3AgJiYgcHJvcC5fdnNldDtcblxuICAgICAgICB2YXIgb3BlcmF0b3JzID0gdC5vcGVyYXRvcnNcbiAgXG4gICAgICAgIC8vbWFrZSB0aGlzIGJldHRlclxuICAgICAgICBpZiAoIShmcm9tICYmIHJlbW92ZSkgJiYgb3BlcmF0b3JzICYmIChvcGVyYXRvcnNbdC5fbmFtZV0gfHwgKHBhcmVudCAmJiBwYXJlbnQuX190ID09PSAxICYmIG9wZXJhdG9yc1twYXJlbnQuX25hbWVdICYmICghZnJvbSB8fCB0Ll9uYW1lID09IHBhcmVudC5sZW5ndGggLSAxKSkpKSB7XG4gICAgICAgICAgLy93b3JrcyBmb3IgYXJyYXlzIHNpbmNlIGFycmF5cyBhcmUgYWx3YXlzIHJlcGxhY2VkIG9uIHVwZGF0ZSAsIHVwZGF0aW5nIGFuIGluZGl2aWR1YWwgaXRlbSB1c2luZyAuc2V0IHdpbGwgbm90IHJlc3VsdCBpbiBhbiB1cGRhdGUgYXQgdGhpcyBwb250IHdoaWNoIGhhcyB0byBiZSByZXNvbHZlZFxuICAgICAgICAgIHZhciBfb3AgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICAgICAgd2hpbGUgKG9wZXJhdG9yc1tfb3AuX25hbWVdKSB7XG4gICAgICAgICAgICBfb3AuX2x2YWwgPSBmYWxzZTsgLy9pZiBubyBjaGFuZ2UgdG8gbHZhbCBjYW4gZ28gd3JvbmcuLi5cbiAgICAgICAgICAgIF9vcCA9IF9vcC5fcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX29wKSB7XG4gICAgICAgICAgXHQvL3RoaXMgZ2VhdGx5IGluY3JlYXNlcyB1cGRhdGVzIG1heSBiZSBpbXBvcnRhbnQgZm9yIGFuaW1hdGlvbiBidXQgbm90IG5lc3NlY2FyeSBmb3IgYW55dGhpbmcgZWxzZSFcbiAgICAgICAgICAgIF9vcC5fdXBkYXRlKHZhbCwgc3RhbXAsIHRoaXMsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgbm9pbnN0YW5jZXMsIGluc3RhbmNlLCBpbnN0YW5jZXNVcGRhdGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2VzVXBkYXRlcykge1xuICAgICAgICAgIGluc3RhbmNlc1VwZGF0ZXMuY2FsbCh0LCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIG5vaW5zdGFuY2VzLCBpbnN0YW5jZSwgaW5zdGFuY2VzVXBkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICBiYXNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2c2V0KSB7XG4gICAgICAgICAgICB0Ll9jYWxsZXIgPSBiYXNlO1xuICAgICAgICAgICAgdnNldC5jYWxsKHQsIHN0YW1wLCBmcm9tLCByZW1vdmUsIHZhbCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChiYXNlICYmIHZzZXQgJiYgYmFzZS5pbnN0YW5jZXMgJiYgIW5vaW5zdGFuY2VzICYmIHByb3AudXBkYXRlaW5zdGFuY2VzICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgYmFzZS5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7IC8vbG9vayBmb3IgY3VycmVudCBjYWxsZXIgaW5zdGFuY2UgcGVyaGFwcz9cbiAgICAgICAgICAgICAgdC5fY2FsbGVyID0gdGhpcztcbiAgICAgICAgICAgICAgdnNldC5jYWxsKHQsIHN0YW1wLCBmcm9tLCByZW1vdmUsIHZhbCk7XG4gICAgICAgICAgICB9LCBwcm9wLm5hbWUsIHQpO1xuICAgICAgICAgICAgdC5fY2FsbGVyID0gYmFzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9mb3JtIGdvbmUgbGV0cyBzZWUhXG4gICAgICAgICAgLy9mcm9tIHNlbGYgZG9vcmdldmVuIGluIGNoYWluID09LS0gaWYgISBub3QgZnJvbSBmcm9tIC0tLT4gLCBleHRyYSBhcmdcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlLl91cGRhdGUuY2FsbCh0LCB2YWwsIHN0YW1wLCBmcm9tIHx8IHQsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbClcbiAgICAgICAgfVxuXG4gICAgICAgIC8vcGFzIG9wIG1ldCBkZXplIVxuICAgICAgICB0Ll9sc3RhbXAgPSBzdGFtcDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBpZih3aW5kb3cuc211dCkgY29uc29sZS5sb2coJ2NhdGNoIGl0IScsIGFyZ3VtZW50cylcbiAgICB9XG5cblxuICAgIH1cbiAgfSlcblxuLy9yZXF1aXJpbmcgb3BlcmF0b3JzIGRvZXMgbm90IGF1dG9tYXRpY2x5IHJlcXVpcmUgdmlnb3VyVmFsdWUsIG1heSBiZSBoYW5keT9cbnV0aWwuZGVmaW5lKGV4cG9ydHMsICdvcGVyYXRvcnMnLCB7XG4gIHZhbHVlOiBleHBvcnRzLm9wZXJhdG9ycyA9IHJlcXVpcmUoJy4vb3BlcmF0b3JzJylcbn0pXG5cblxuXG4iLCJ2YXIgVmFsdWUgPSByZXF1aXJlKCd2aWdvdXItanMvdmFsdWUnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsJyksXG4gIFZPYmplY3QgPSByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0JylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChcbiAgZnVuY3Rpb24oVGFyZ2V0KXtcbiAgICBpZiggVGFyZ2V0LnByb3RvdHlwZSBpbnN0YW5jZW9mIFZPYmplY3QgfHwgVGFyZ2V0ID09PSBWT2JqZWN0KSB7XG4gICAgICAvLyBUT0RPOiBmaXggdGhpcyB0byBhZmZlY3QgYWxsIFZPYmplY3QgYmxhY2tsaXN0cy4uLlxuICAgICAgVGFyZ2V0LnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ18kbGVuZ3RoJylcblxuICAgICAgdXRpbC5kZWZpbmUoIFRhcmdldCxcbiAgICAgICAgJyRsZW5ndGgnLCB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiAuLi5zbyB3ZSBkb250IGhhdmUgdG8gZG8gYmxhY2tsaXN0IGNoZWNrOlxuICAgICAgICAgICAgdXRpbC5pbmNsdWRlKHRoaXMuX2JsYWNrbGlzdCwgJ18kbGVuZ3RoJylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl8kbGVuZ3RoIHx8ICh0aGlzLl8kbGVuZ3RoID0gbWFrZUxlbmd0aCh0aGlzKSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZXh0ZW5kIFwiJGxlbmd0aFwiIG9uIG5vbiBWT2JqZWN0IENsYXNzJylcbiAgICB9XG4gIH1cbilcblxuZnVuY3Rpb24gbWFrZUxlbmd0aChpbnN0YW5jZSkge1xuICB2YXIgJGxlbmd0aCA9IG5ldyBWYWx1ZSh7XG4gICAgdmFsOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIGdldExlbmd0aChpbnN0YW5jZSlcbiAgICB9XG4gIH0pXG5cbiAgaW5zdGFuY2Uub24oZnVuY3Rpb24odmFsKXtcblxuICAgIC8vIHZhciBpZGVudGlmaWVyID0gaW5zdGFuY2UuX3BhdGgubGVuZ3RoIFxuICAgIC8vICAgPyBpbnN0YW5jZS5fcGF0aFxuICAgIC8vICAgOiBpbnN0YW5jZS5fcHJvcCAmJiBpbnN0YW5jZS5fcHJvcC5uYW1lXG4gICAgLy8gY29uc29sZS5sb2coJ1VQREFURSBPTicsIGlkZW50aWZpZXIsICdTSElORSBEQVQgTEVOR1RIPyEnLCAkbGVuZ3RoLnZhbFxuICAgIC8vIClcbiAgICAvLyBUT0RPOiBvbmx5IHVwZGF0ZSBpZiBhZGRlZCBvciByZW1vdmVkXG4gICAgJGxlbmd0aC5fdXBkYXRlLmFwcGx5KCRsZW5ndGgsIGFyZ3VtZW50cylcbiAgfSlcblxuICByZXR1cm4gJGxlbmd0aFxufVxuXG5mdW5jdGlvbiBnZXRMZW5ndGggKGN1cnJlbnQpIHtcbiAgaWYoIWN1cnJlbnQpe1xuICAgIHJldHVybiAwXG4gIH0gaWYgKGN1cnJlbnQuX2ZpbHRlcikge1xuICAgIHJldHVybiBjdXJyZW50Lmxlbmd0aFxuICB9IGVsc2UgaWYgKGN1cnJlbnQuX190ID09PSA0KSB7XG4gICAgcmV0dXJuIGdldExlbmd0aChjdXJyZW50Ll92YWwpXG4gIH0gZWxzZSBpZiAoY3VycmVudC5fX3QgPCAzKSB7XG4gICAgcmV0dXJuIGN1cnJlbnQua2V5cy5sZW5ndGhcbiAgfSBlbHNlIGlmICh0eXBlb2YgY3VycmVudC5fdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBjdXJyZW50Ll92YWwubGVuZ3RoXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIDBcbiAgfVxufVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG4gIC8qXG4gICAgRXh0ZW5zaW9uIGZvciBCYXNlIGNsYXNzZXMgdG8gY3JlYXRlIGFuIGluaGVyaXRhYmxlIG9uIC0gdmFsdWVcbiAgKi9cblxudmFyIFZhbHVlID0gcmVxdWlyZSgnLi8nKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCBCYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmRcbiggZnVuY3Rpb24oYmFzZSlcbiAge1xuICAgIGlmKCBiYXNlIGluc3RhbmNlb2YgQmFzZSApXG4gICAge1xuXG4gICAgICBiYXNlLmV4dGVuZFxuICAgICAgKFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTonb24nLFxuICAgICAgICAgIHNldDpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlOmZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgLy9yZW1vdmVcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbSBiZWluZyByZW1vdmVkIScpXG4gICAgICAgICAgICAgaWYodGhpcy5vbi4kcmVtb3ZlKSB7XG4gICAgICAgICAgICAgIHRoaXMub24uJHJlbW92ZS51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmV3OmZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgLy9pbml0XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSU5JVCEtLS0tJywgdGhpcywgdmFsLCBhcmd1bWVudHMpXG4gICAgICAgICAgICBpZih0aGlzLm9uLiRuZXcpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbi4kbmV3LnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6ZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAvL2luaXRcbiAgICAgICAgICAgIGlmKHRoaXMub24uJHBhcmVudCkge1xuICAgICAgICAgICAgICB0aGlzLm9uLiRwYXJlbnQudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbmRlcjpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIC8vaW5pdFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTkRFUiEtLS0tJywgdGhpcywgdmFsLCBhcmd1bWVudHMpXG4gICAgICAgICAgICBpZih0aGlzLm9uLiRyZW5kZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbi4kcmVuZGVyLnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG5cbiAgICB9XG4gICAgZWxzZVxuICAgIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGV4dGVuZCBcIm9uXCIgb24gbm9uIEJhc2UgQ2xhc3MnKVxuICAgIH1cbiAgfVxuKVxuIiwiLyoqXG4gKiBvcGVyYXRvcnNcbiAqIG9wZXJhdG9ycyBjYW4gYmUgc2V0IG9uIFYuVmFsdWUub3BlcmF0b3JzXG4gKiBkZWZpbmUgb3BlcmF0b3JzIG9uIHRoaXMgbW9kdWxlXG4gKiBAcHJvcGVydHlcbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCBWID0gcmVxdWlyZSgnLi4vJylcbiAgXG5leHBvcnRzLmFkZCA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsICsgb3BlcmF0b3Jcbn1cbmV4cG9ydHMuc3ViID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgLSBvcGVyYXRvclxufVxuZXhwb3J0cy5tdWx0aXBseSA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsICogb3BlcmF0b3Jcbn1cbmV4cG9ydHMuZGl2aWRlID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgLyBvcGVyYXRvclxufVxuZXhwb3J0cy5tYXggPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCA+IG9wZXJhdG9yID8gb3BlcmF0b3IgOiB2YWxcbn1cbmV4cG9ydHMubWluID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgPCBvcGVyYXRvciA/IG9wZXJhdG9yIDogdmFsXG59XG5leHBvcnRzLnRyYW5zZm9ybSA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gb3BlcmF0b3IgPT09IGZhbHNlID8gdmFsIDogb3BlcmF0b3Jcbn1cbmV4cG9ydHMuYWJzID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiBvcGVyYXRvciA/IE1hdGguYWJzKHZhbCkgOiB2YWxcbn1cbmV4cG9ydHMuZmxvb3IgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCB8IDBcbn1cbmV4cG9ydHMuY2VpbCA9IGZ1bmN0aW9uICggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIE1hdGguY2VpbCggdmFsIClcbn1cbmV4cG9ydHMucHJlcGVuZCA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gb3BlcmF0b3IgKyB2YWxcbn1cbmV4cG9ydHMub3IgPSBmdW5jdGlvbiAoIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgfHwgb3BlcmF0b3Jcbn1cbmV4cG9ydHMud2hlbiA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gb3BlcmF0b3IgJiYgdmFsXG59XG5leHBvcnRzLiRjb252ZXJ0VHlwZSA9IGZ1bmN0aW9uICggdmFsLCBvcGVyYXRvciApIHtcbiAgLy9jb252ZXJ0VHlwZVxuICBpZiggb3BlcmF0b3IgPT09ICdib29sZWFuJyApXG4gIHsgXG4gICAgcmV0dXJuIHZhbCA/IHRydWUgOiBmYWxzZVxuICB9IFxuICBlbHNlIGlmKCBvcGVyYXRvciA9PT0gJ251bWJlcicgKVxuICB7XG4gICAgLy9kbyBpc05hbiBzdGFydCB1c2luZyBsb0Rhc2ggZm9yIHRoaXMga2luZCBvZiBzdHVmZiAoIGFsbW9zdCBub3RoaW5nIClcbiAgICAvL2NvbnZlcnQgZmFsc3kgb3IgTmFOIHZhbHVlcyB0byAwXG4gICAgcmV0dXJuIE51bWJlciggdmFsIClcbiAgfVxufVxuXG5leHBvcnRzLiRjb252ZXJ0VGltZSA9IGZ1bmN0aW9uKCB0aW1lLCBkZWNpbWFscyApIHtcbiAgdmFyIGhycyA9IH5+ICh0aW1lIC8gMzYwMClcbiAgdmFyIG1pbnMgPSB+fiAoKHRpbWUgJSAzNjAwKSAvIDYwKVxuICB2YXIgc2VjcyA9ICFpc05hTihwYXJzZUZsb2F0KGRlY2ltYWxzKSkgJiYgaXNGaW5pdGUoZGVjaW1hbHMpXG4gICAgICA/ICh0aW1lICUgNjApLnRvRml4ZWQoZGVjaW1hbHMpIDogfn4odGltZSAlIDYwKVxuXG4gIHJldCA9IFwiXCI7XG4gIGlmIChocnMgPiAwKSByZXQgKz0gXCJcIiArIGhycyArIFwiOlwiICsgKG1pbnMgPCAxMCA/IFwiMFwiIDogXCJcIik7XG4gIHJldCArPSBcIlwiICsgbWlucyArIFwiOlwiICsgKHNlY3MgPCAxMCA/IFwiMFwiIDogXCJcIik7XG4gIHJldCArPSBcIlwiICsgc2VjcztcbiAgcmV0dXJuIHJldCB8fCAwO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG5cbi8vIGNvbnNvbGUubG9nKCAnPz8/PycsIHZhbCApXG4gIFxuICAvL3BhcyBvcCBtZXQgZGllIDBcbiAgaWYoICghdmFsICYmIHZhbCAhPT0gMCkgfHwgdmFsLl92YWwgPT09IGZhbHNlIHx8IHZhbCA9PT0gJ2Vycm9yJyB8fCB2YWwgPT09ICdzdWNjZXNzJyApXG4gIHtcbiAgICAvL1RPRE86IEFycmF5cyBmb3IgZGVmYXVsdCBvcGVyYXRvclxuICAgIHJldHVybiBvcGVyYXRvclxuICB9XG4gIHJldHVybiB2YWxcbn1cblxuZXhwb3J0cy5kZWZhdWx0Lm9yZGVyID0gMTAwMCIsIm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpIiwidmFyIHBrZyA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXG4gICwgcGx1Z2luSWQgPSBwa2cucGx1Z2luLmlkXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHt9XG5cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIGlmICghY2IpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuICB0cnkge1xuICAgIHdpbmRvdy52aWdvdXJOYXRpdmUuYnJpZGdlKHBsdWdpbklkLCAnZ2V0Jywgb3B0cywgY2IpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYihlKVxuICB9XG59XG5cbmV4cG9ydHMuc2V0ID0gZnVuY3Rpb24gKG9wdHMsIGNiKSB7XG4gIGlmICghY2IpIHtcbiAgICBjYiA9IG9wdHNcbiAgICBvcHRzID0ge31cbiAgfVxuICB0cnkge1xuICAgIHdpbmRvdy52aWdvdXJOYXRpdmUuYnJpZGdlKHBsdWdpbklkLCAnc2V0Jywgb3B0cywgY2IpXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYihlKVxuICB9XG59IiwibW9kdWxlLmV4cG9ydHM9e1wibmFtZVwiOlwidmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXJcIixcInZlcnNpb25cIjpcIjIwMTUvMDYvMDggMTc6MTk6MDIgVVRDICgwLjAuMSlcIixcImF1dGhvclwiOntcIm5hbWVcIjpcIlNoYXduIEluZGVyXCIsXCJlbWFpbFwiOlwic2hhd25Admlnb3VyLmlvXCJ9LFwicmVwb3NpdG9yeVwiOntcInR5cGVcIjpcImdpdFwiLFwidXJsXCI6XCJnaXQraHR0cHM6Ly9naXRodWIuY29tL3ZpZ291ci1pby92aWdvdXItbmF0aXZlLXN0YXR1c0Jhci5naXRcIixcImJyYW5jaFwiOlwibWFzdGVyXCJ9LFwiZW5naW5lc1wiOntcIm5vZGVcIjpcIj49MC4xMC4wXCJ9LFwibWFpblwiOlwiaW5kZXguanNcIixcInNjcmlwdHNcIjp7XCJzdGFydFwiOlwiZ2FzdG9uXCIsXCJ0ZXN0XCI6XCJ0ZXN0L3Rlc3QuanNcIn0sXCJkZXNjcmlwdGlvblwiOlwiQWxsb3dzIG9uZSB0byBjb250cm9sIHRoZSBuYXRpdmUgc3RhdHVzIGJhciBmcm9tIGEgd2ViIGFwcFwiLFwia2V5d29yZHNcIjpbXCJ2aWdvdXJcIixcIm5hdGl2ZVwiLFwicGx1Z2luXCIsXCJzdGF0dXNCYXJcIl0sXCJidWdzXCI6e1widXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vdmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyL2lzc3Vlc1wifSxcImhvbWVwYWdlXCI6XCJodHRwczovL2dpdGh1Yi5jb20vdmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyXCIsXCJkZXBlbmRlbmNpZXNcIjp7XCJnYXN0b25cIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS92aWdvdXItaW8vZ2FzdG9uLmdpdFwiLFwidmlnb3VyLW5hdGl2ZVwiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL3ZpZ291ci1pby92aWdvdXItbmF0aXZlLmdpdFwiLFwidmlnb3VyLWZzXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vdmlnb3VyLWlvL3ZpZ291ci1mcy5naXRcIixcInZpZ291ci1kZXYtdG9vbHNcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLWRldi10b29scy5naXRcIn0sXCJvcHRpb25hbERlcGVuZGVuY2llc1wiOnt9LFwiZGV2RGVwZW5kZW5jaWVzXCI6e1wibnBtXCI6XCJeMi43LjZcIixcIm5wbWxvZ1wiOlwiXjEuMi4wXCJ9LFwicGx1Z2luXCI6e1wiaWRcIjpcInN0YXR1c2JhclwiLFwiYW5kcm9pZFwiOntcImNsYXNzTmFtZVwiOlwiaW8udmlnb3VyLnBsdWdpbi5zdGF0dXNiYXIuU3RhdHVzQmFyUGx1Z2luXCIsXCJpbnN0YW50aWF0aW9uXCI6XCJuZXcgU3RhdHVzQmFyUGx1Z2luKHRoaXMsIHdlYlZpZXcpXCIsXCJsaWJOYW1lXCI6XCJzdGF0dXNiYXItZGVidWcuYWFyXCJ9fSxcImdpdEhlYWRcIjpcIjU4OGRlNDcyM2NiZGU2NzNmYjIyYjRhMjhiNzA0NzIwNDVkM2M4ZmZcIixcInJlYWRtZVwiOlwiIyB2aWdvdXItbmF0aXZlLXN0YXR1c0JhclxcbkFsbG93cyBvbmUgdG8gY29udHJvbCB0aGUgbmF0aXZlIHN0YXR1cyBiYXIgZnJvbSBhIHdlYiBhcHBcXG5cXG4jI0luc3RhbGxcXG5gbnBtIGkgdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXJgXFxuXFxuIyNVc2FnZVxcblNlZSBbdGVzdC9pbmRleC5qc10odGVzdC9pbmRleC5qcylcXG5cXG4jI0J1aWxkaW5nIGEgc2V0IG9mIG5hdGl2ZSBhcHBzIGZyb20geW91ciBjb2RlYmFzZVxcbi0gYG5wbSBydW4gYnVpbGRgXFxuLSBgbnBtIHJ1biBidWlsZCAtLSBpb3MgYW5kcm9pZGBcIixcInJlYWRtZUZpbGVuYW1lXCI6XCJSRUFETUUubWRcIixcIl9pZFwiOlwidmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXJAMC4wLjFcIixcIl9zaGFzdW1cIjpcIjgxY2MyNTkxMGJlN2YxNTk1NDE3YzNiOGZkZmI4MzgyYjEyNDdmNDdcIixcIl9mcm9tXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vdmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyLmdpdFwiLFwiX3Jlc29sdmVkXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vdmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyLmdpdCM1ODhkZTQ3MjNjYmRlNjczZmIyMmI0YTI4YjcwNDcyMDQ1ZDNjOGZmXCIsXCJzaGFcIjpcIjAuMC4xXCJ9IiwidmFyIGFwcCA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbiAgLmluamVjdChcbiAgICByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC9jb250ZW50JyApLFxuICAgIHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VzZXInIClcbiAgKVxuXG5yZXF1aXJlKCAnLi91c2VyJyApXG5yZXF1aXJlKCAnLi92YWx1ZXMnIClcbnJlcXVpcmUoICcuL3BsYXliYWNrJylcbnJlcXVpcmUoICcuL2luaXQnIClcblxud2luZG93LmEgPSBhcHBcbiIsInZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoICd2aWdvdXItanMvdXRpbC9jb25maWcnIClcbnZhciB1c2VyID0gYXBwLnVzZXJcblxuLy8gcHJlbG9hZGVyXG5hcHAuY3NzID0ge1xuICBhZGRDbGFzczogJ3ByZWxvYWQnXG59XG5cbnVzZXIuZGF0YS5pcyggJ2xvYWRlZCcgKVxuICAvL2RvIHRoaXMgbGF0ZXIgd2hlbiBjb250ZW50IGdldHMgYm91bmRcbiAgLnRoZW4oIGZ1bmN0aW9uKCkgeyBcbiAgICBhcHAucmVhZHkudmFsID0gdHJ1ZVxuICAgIC8vYWRkIHRoaXMgbGF0ZXJcbiAgICAvLyByZXR1cm4gYXBwLmNvbnRlbnQuaXMoICdsb2FkZWQnICkgXG4gIH0pXG4gIC5kb25lKCBmdW5jdGlvbigpIHtcbiAgICBhcHAuY3NzID0ge1xuICAgICAgcmVtb3ZlQ2xhc3M6ICdwcmVsb2FkJ1xuICAgIH1cbiAgfSlcblxuXG5cbmFwcC5pbml0aWFsaXNlZC5vbmNlKHRydWUsIGZ1bmN0aW9uKCkge1xuICAvLyBjb25zb2xlLmxvZyhkb2N1bWVudC5kb21haW4ucmVwbGFjZSgvXFw6XFxkXFxkXFxkXFxkLywgJzoxMDAwMScpKVxuXG4gIGFwcC5jbG91ZCA9IGNvbmZpZy5jbG91ZCA9PT0gJ2RvbWFpbicgPyBkb2N1bWVudC5kb21haW4rICc6MTAwMDEnICA6IGNvbmZpZy5jbG91ZFxuLy8gPT09PT09PVxuICAvLyBpZih3aW5kb3cuZ2FzdG9uICYmIHdpbmRvdy5nYXN0b24uc2VydmVyQWRkcmVzcy5pbmRleE9mKCd7JykgPT09IC0xKSB7XG4gIC8vICAgYXBwLmNsb3VkID0gJ3dzOi8vJyArXG4gIC8vICAgICB3aW5kb3cuZ2FzdG9uLnNlcnZlckFkZHJlc3Muc3BsaXQoJy8vJylbMV0uc3BsaXQoJzonKVswXSArIFxuICAvLyAgICAgJzoxMDAwMSdcbiAgLy8gfSBlbHNlIHtcbiAgLy8gICBhcHAuY2xvdWQgPSAnd3M6Ly8nICsgY29uZmlnLmNsb3VkXG4gIC8vIH1cbiAgXG4vLyA+Pj4+Pj4+IGRldlxuICB1c2VyLnRva2VuLnZhbCA9ICdmdXR1cmVsYW5kJ1xufSlcblxuLyogICBcbid3czovLycgXG4gICsgd2luZG93Lmdhc3Rvbi5zZXJ2ZXJBZGRyZXNzLnNwbGl0KCcvLycpWzFdLnNwbGl0KCc6JylbMF1cbiAgKyAnOjEwMDAxJy8vXG4qL1xuIiwidmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgVmFsdWUgPSByZXF1aXJlKCAndmlnb3VyLWpzL3ZhbHVlJyApXG52YXIgY2FzZXMgPSBhcHAuY2FzZXNcbnZhciB1c2VyID0gYXBwLnVzZXJcblxuYXBwLmlzUGxheWluZy52YWwgPSB7XG4gIHZhbDogZmFsc2UsXG4gICRpc1JlY2VpdmVyOnVzZXIucmVjZWl2ZXIucGxheWluZ1xufVxuXG5hcHAudm9sdW1lID0ge1xuICB2YWw6MSxcbiAgJGlzUmVjZWl2ZXI6IHVzZXIucmVjZWl2ZXIudm9sdW1lXG59XG5cbmNhc2VzLiRpc1BsYXlpbmcgPSBhcHAuaXNQbGF5aW5nXG5cbmlmKGNhc2VzLiRpc1Bob25lKSB7XG4gIGFwcC5wb3B1cC5vbihmdW5jdGlvbih2YWwpIHtcbiAgICBpZih2YWwpIHtcbiAgICAgIGlmKGFwcC5pc1BsYXlpbmcudmFsPT09dHJ1ZSkge1xuICAgICAgICBhcHAuaXNQbGF5aW5nLmZyb20udmFsID0gZmFsc2VcbiAgICAgICAgYXBwLnBvcHVwLmlzKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbCA9PT0gZmFsc2VcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYXBwLmlzUGxheWluZy5mcm9tLnZhbCA9IHRydWVcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmNhc2VzLiRpc0Z1bGxzY3JlZW4gPSBuZXcgVmFsdWUoIHtcbiAgdmFsOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gYXBwLnN0YXRlLnZhbCA9PT0gJ3BsYXllcidcbiAgfSxcbiAgbGlzdGVuOiBhcHAuc3RhdGVcbn0gKVxuXG4vLyBjYXNlcy4kaXNMb2FkaW5nVmlkZW8gPSBuZXcgVmFsdWUoIHtcbi8vICAgdmFsOiBmYWxzZSxcbi8vICAgZGVmZXI6IGZ1bmN0aW9uKCB1cGRhdGUgKSB7XG4vLyAgICAgdmFyIF90aGlzID0gdGhpc1xuLy8gICAgIGlmICggdGhpcy5fdGltZXIgKSB7XG4vLyAgICAgICBjbGVhclRpbWVvdXQoIHRoaXMuX3RpbWVyIClcbi8vICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbFxuLy8gICAgIH1cbi8vICAgICBpZiAoIHRoaXMuX3ZhbCApIHtcbi8vICAgICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgIF90aGlzLnZhbCA9IGZhbHNlXG4vLyAgICAgICAgIF90aGlzLl90aW1lciA9IG51bGxcbi8vICAgICAgIH0sIDIwMDAgKVxuLy8gICAgIH1cbi8vICAgICB1cGRhdGUoKVxuLy8gICB9XG4vLyB9IClcblxuLy8gYXBwLmlzUGxheWluZy5vbiggZnVuY3Rpb24oIHZhbCApIHtcbi8vICAgaWYgKCBjYXNlcy4kaXNMb2dnZWRJbi52YWwgKSB7XG4vLyAgICAgaWYgKCB2YWwgPT09IHRydWUgKSB7XG4vLyAgICAgICAvLyBUT0RPOiB0aGlzIGNyYXNoZXMgbm93LCBzbyBpIGNvbW1lbnRlZCBpdCBvdXRcbi8vICAgICAgIC8vIHZhciBtZWRpYSA9IGFwcC51c2VyLm5hdmlnYXRpb24ubWVkaWEuZnJvbVxuLy8gICAgICAgLy8gaWYgKCBtZWRpYS5fcGFyZW50Ll9uYW1lICE9PSAnY2hhbm5lbHMnICkge1xuLy8gICAgICAgLy8gICB2YXIgZXBpID0gYXBwLnVzZXIudXNhZ2UuZnJvbS5nZXQoIG1lZGlhLl9jb250ZW50UGF0aCApLFxuLy8gICAgICAgLy8gICAgIHNob3cgPSBlcGkuX3BhcmVudC5fcGFyZW50Ll9wYXJlbnQuX3BhcmVudFxuXG4vLyAgICAgICAvLyAgIGlmICggc2hvdyApIHtcbi8vICAgICAgIC8vICAgICBzaG93LnNldCggJ21lZGlhJywgbWVkaWEgKVxuLy8gICAgICAgLy8gICB9XG4vLyAgICAgICAvLyB9XG4vLyAgICAgfVxuLy8gICB9XG4vLyB9KVxuIiwidmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxudmFyIHVzZXIgPSBhcHAudXNlci5pbmplY3QoXG4gIHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdXNlci90b2tlbicpLFxuICByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VzZXIvdXNhZ2UnKSxcbiAgcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91c2VyL25hdmlnYXRpb24nKSxcbiAgcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91c2VyL211bHRpc2NyZWVuJylcbilcblxudXNlci5zZXQoe1xuICBzZWFyY2g6IGZhbHNlLFxuICBmb2N1c19yb3c6ICdzcG90bGlnaHQnLFxuICAvLyBmb2N1c19jaGFubmVsczowLFxuICBmb2N1c19hY3RvcjowLFxuICBmb2N1c19jaGFubmVsczowLFxuICBmb2N1c19zcG90bGlnaHQ6MCxcbiAgZm9jdXNfd2F0Y2hpbmc6MCxcbiAgZm9jdXNfcmVjb21tZW5kZWQ6MCxcbiAgZm9jdXNfcmVsZWFzZXM6MCxcbiAgcmVjZW50U2VhcmNoZXM6IHt9LFxuICBwb3B1cDowLFxuICB0cmFpbGVyTXV0ZWQ6dHJ1ZVxuICAvLyB1cmw6IHJlcXVpcmUoICd2aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL3VybCcgKVxufSlcblxuYXBwLnBvcHVwLnZhbCA9IHVzZXIucG9wdXBcblxudmFyIFZhbHVlID0gcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlJylcblxuYXBwLmRldmljZU1lc3NhZ2UgPSBuZXcgVmFsdWUoe1xuICB2YWw6IHVzZXIucmVjZWl2ZXJDbGllbnQsXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24oIGMsIGN2ICl7XG4gICAgdmFyIHRpdGxlID0gY3YgJiYgY3YuZnJvbSAmJiBjdi5mcm9tLnRpdGxlICYmIGN2LmZyb20udGl0bGUudmFsXG4gICAgLy8gY29uc29sZS5lcnJvcignZGV2aWNlTWVzc2FnZSEgJywgdGl0bGUpXG4gICAgcmV0dXJuIHRpdGxlID8gJ0Nvbm5lY3RlZCB0byAnICsgdGl0bGUgOiAnTm90IENvbm5lY3RlZCdcbiAgfVxufSlcbiIsInZhciBhcHAgPSByZXF1aXJlKCcuLycpXG52YXIgdXNlciA9IGFwcC51c2VyXG52YXIgY2FzZXMgPSBhcHAuY2FzZXNcbnZhciBWYWx1ZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZScpXG4gIC8vIFRPRE86IGJhc2UgdGhpcyBvbiBkZXZpY2Ugcm9sZVxuLy8gYXBwLnN0YXRlLnZhbCA9IHtcbi8vICAgZGVmYXVsdDogJ2ZpcnN0J1xuLy8gfVxuXG5hcHAuc3RhdGUudmFsID0gY2FzZXMuJGlzUGhvbmUgPyAnZmlyc3QnIDogJ3NlY29uZCdcblxuYXBwLmN1cnJlbnQgPSBuZXcgVmFsdWUoe1xuICB2YWw6IHVzZXIubmF2aWdhdGlvbi5sYXN0LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHYsIGxhc3QpIHtcbiAgICB2YXIga2V5ID0gbGFzdC5rZXkgJiYgbGFzdC5rZXkudmFsXG4gICAgcmV0dXJuIGtleSA9PT0gJ3BhZ2UnID8gdXNlci5uYXZpZ2F0aW9uLnBhZ2UudmFsIDoga2V5XG4gIH0sXG4gIGxpc3RlbjogW1xuICAgIHVzZXIubmF2aWdhdGlvbi5jb250ZW50LFxuICAgIHVzZXIubmF2aWdhdGlvbi5wYWdlXG4gIF1cbn0pXG5cbmFwcC5wcmV2aW91cyA9IG5ldyBWYWx1ZSh7XG4gIHZhbDphcHAuY3VycmVudCxcbiAgZGVmZXI6ZnVuY3Rpb24odXBkYXRlLGFyZ3Mpe1xuICAgIHZhciB2YWwgPSB0aGlzLl92YWwudmFsXG4gICAgaWYodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsICE9PSB0aGlzLmN1cnJlbnQpe1xuICAgICAgdGhpcy5wcmV2ID0gdGhpcy5jdXJyZW50XG4gICAgICB0aGlzLmN1cnJlbnQgPSB2YWxcbiAgICB9XG4gICAgdXBkYXRlKClcbiAgfSxcbiAgdHJhbnNmb3JtOmZ1bmN0aW9uKHZhbCl7XG4gICAgcmV0dXJuIHZhbC5fcGFyZW50LnByZXYgfHwgMFxuICB9XG59KVxuXG5hcHAuc2Vjb25kUG9wdXAgPSBuZXcgVmFsdWUoZmFsc2UpXG5cbmFwcC5oaWRlU3RhdHVzYmFyID0gbmV3IFZhbHVlKHtcbiAgdmFsOiBmYWxzZSxcbiAgdHJhbnNmb3JtOiBhcHAuaXNQbGF5aW5nXG59KVxuXG5jYXNlcy4kaGFzUmVjZWl2ZXIub24oZnVuY3Rpb24oKSB7XG4gIGFwcC5jc3MgPSB0aGlzLnZhbCA/IHtcbiAgICBhZGRDbGFzczogJ2hhc1JlY2VpdmVyJ1xuICB9IDoge1xuICAgIHJlbW92ZUNsYXNzOiAnaGFzUmVjZWl2ZXInXG4gIH1cbn0pXG5cbmlmKCFjYXNlcy4kaXNQaG9uZSl7XG4gIGNhc2VzLiRpc1JlY2VpdmVyLm9uKGZ1bmN0aW9uKCl7XG4gICAgYXBwLnN0YXRlLnZhbCA9IHRoaXMudmFsID8gJ3NlY29uZCcgOiAnaW5hY3RpdmUnXG4gIH0pXG59IiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEFjdG9ycyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2FjdG9ycycpXG52YXIgRGVzY3JpcHRpb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9kZXNjcmlwdGlvbicpXG52YXIgUHJvZ3Jlc3MgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zZWVrYmFyJykuQmFyXG52YXIgVGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC90aXRsZScpXG52YXIgUG9sbCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3BvbGwnKVxudmFyIFN0YXRpc3RpY3MgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdGF0aXN0aWNzJylcbnZhciBUcml2aWEgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC90cml2aWEnKVxudmFyIENvbnRlbnQgPSByZXF1aXJlKCcuLi9jb250ZW50JylcbnZhciBCYXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9iYXInKVxudmFyIFR3ZWV0cyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3R3ZWV0cycpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENvbnRlbnQoe1xuICAnaG9sZGVyLnBhZ2UnOiB7XG4gICAgY29udGFpbmVyOntcbiAgICAgICdtb2RlbC5maWVsZCc6J2d1aWRlLjAnLFxuICAgICAgdGl0bGViYXI6bmV3IEJhcih7XG4gICAgICAgIGNzczogJ3VpLWJhcicsXG4gICAgICAgIGFjY2VudDoge30sXG4gICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICB0aXRsZTpuZXcgVGl0bGUoKSxcbiAgICAgICAgICB0aW1lZmlsbGVyOiB7XG4gICAgICAgICAgICAnbGVmdC50ZXh0LmRhdGEnOidzdGFydC10aW1lJyxcbiAgICAgICAgICAgICdtaWRkbGUuZmlsbGVyJzogbmV3IFByb2dyZXNzKHtcbiAgICAgICAgICAgICAgJ3NlZWsudyc6ICc3NSUnXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICdyaWdodC50ZXh0LmRhdGEnOidlbmQtdGltZScgIFxuICAgICAgICAgIH0gIFxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGRlc2NyaXB0aW9uOm5ldyBEZXNjcmlwdGlvbih7XG4gICAgICAgIGRpc3BsYXk6e1xuICAgICAgICAgIGRhdGE6J2Rlc2NyaXB0aW9uJyxcbiAgICAgICAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICAgICAgICByZXR1cm4gY3YgPyAnYmxvY2snIDogJ25vbmUnXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGFjdG9yczpuZXcgQWN0b3JzKCksXG4gICAgICBwb2xsOm5ldyBQb2xsKCksXG4gICAgICBzdGF0aXN0aWNzOm5ldyBTdGF0aXN0aWNzKCksXG4gICAgICB0cml2aWE6bmV3IFRyaXZpYSgpLFxuICAgICAgdHdlZXRzOm5ldyBUd2VldHMoKSxcbiAgICB9LFxuICAgIGNvbGxlY3Rpb246e1xuICAgICAgZGF0YTonZ3VpZGUnLFxuICAgICAgZWxlbWVudDpuZXcgQmFyKHtcbiAgICAgICAgbGVmdDoge1xuICAgICAgICAgIHRpdGxlOm5ldyBUaXRsZSgpLFxuICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgICdsZWZ0LnRleHQnOntcbiAgICAgICAgICAgICAgZGF0YTonc3RhcnQtdGltZScsXG4gICAgICAgICAgICAgIGFkZDpbXG4gICAgICAgICAgICAgICAgJyAtICcsXG4gICAgICAgICAgICAgICAge2RhdGE6J2VuZC10aW1lJ31cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gIFxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG52YXIgUGxheWVyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9hY3RpdmUvcGxheWVyJylcbnZhciBUb3BiYXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL2FjdGl2ZS90b3BiYXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnY29udGVudC1pdGVtJyxcbiAgeDoge1xuICAgIHRyYW5zbGF0ZTogdHJ1ZVxuICB9LFxuICBzY3JvbGxiYXI6ICd5JyxcbiAgaG9sZGVyOiB7XG4gICAgeToge1xuICAgICAgdmFsOiAwLFxuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIHRpbWU6IDE4LFxuICAgICAgICBlYXNpbmc6ICdvdXRDdWJpYycsXG4gICAgICAgIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAgICAgaWYgKHRoaXMueS52YWwgPT09IC10aGlzLnBsYXllci5oLnZhbCAtIDEpIHtcbiAgICAgICAgICAgIGlmICghX3RoaXMuaXNTd2lwZWR1cC52YWwpIHtcbiAgICAgICAgICAgICAgX3RoaXMuc3dpcGV1cC5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIV90aGlzLnRpbWVvdXR5KSB7XG4gICAgICAgICAgICAgIF90aGlzLnRpbWVvdXR5ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNTd2lwZWR1cC52YWwpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzLnN3aXBldXAuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMudGltZW91dHkgPSBmYWxzZVxuICAgICAgICAgICAgICAgIF90aGlzLnkudmFsID0gX3RoaXMuaXNTd2lwZWR1cC52YWwgPyAtX3RoaXMucGxheWVyLmgudmFsICsgMzAgOiAwXG4gICAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBwbGF5ZXI6IG5ldyBQbGF5ZXIoKSxcbiAgICBzd2lwZXVwOiB7XG4gICAgICBkaXNwbGF5OiAnbm9uZScsXG4gICAgICBuZXN0ZWQ6IHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHc6IGFwcC53LFxuICAgICAgICBoOiBhcHAuaCxcbiAgICAgICAgbXNnOntcbiAgICAgICAgICBpY29uOm5ldyBJY29uKHtcbiAgICAgICAgICAgIGljb246J3B1bGxiYWNrJ1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRleHQ6ICdSZXN1bWUgSGVyZSdcbiAgICAgICAgfSxcbiAgICAgICAgJ2V2ZW50cy5jbGljayc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLiR1c2VyT3JpZ2luID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgdmFsOiBhcHAuaCxcbiAgICAgICAgbXVsdGlwbHk6IC0xXG4gICAgICB9LFxuICAgICAgaDogYXBwLmhcbiAgICB9LFxuICAgIGV4dGVuZDoge1xuICAgICAgaXNTd2lwZWR1cDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlZCAmJiB2YWwgJiYgdmFsLnZhbCkge1xuICAgICAgICAgIHRoaXMuc3dpcGV1cC5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgIHRoaXMueSA9IC10aGlzLnBsYXllci5oLnZhbCArIDMwXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5zd2lwZXVwLmRpc3BsYXkudmFsID09PSAnYmxvY2snKSB7XG4gICAgICAgICAgdGhpcy55ID0gLXRoaXMucGxheWVyLmgudmFsIC0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMueSA9IHZhbC52YWwgPT09IHRydWUgPyAtdGhpcy5wbGF5ZXIuaC52YWwgLSAxIDogMFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVjZWl2ZXJNZWRpYTogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5wYXJlbnQuZGF0YVxuICAgICAgICBpZihkYXRhKXtcbiAgICAgICAgICB2YXIgc3dpcGV1cCA9IHRoaXMuaXNTd2lwZWR1cCA9IHZhbC5mcm9tID09PSBkYXRhLmZyb21cbiAgICAgICAgICBpZiAoc3dpcGV1cCkge1xuICAgICAgICAgICAgdGhpcy5wbGF5ZXIucGxheWluZy5mcm9tID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBkYXRhLmZyb20uZ2V0KCd0aW1lJylcbiAgICAgICAgICAgIGlmICh0aW1lLnZhbCA8IDApIHtcbiAgICAgICAgICAgICAgZGF0YS5mcm9tLmdldCgndGltZScpLnZhbCA9IE1hdGguYWJzKHRpbWUudmFsKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCAnLi9zdHlsZS5sZXNzJyApXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgX2ZvY3VzZWQgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy91dGlsJykuZm9jdXNlZFxudmFyIExpc3QgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdCcpXG5cbnZhciBMaXN0SG9sZGVyID0gbmV3IEVsZW1lbnQoIHtcbiAgJ2hlYWRlci50ZXh0Jzp7ZGF0YTondGl0bGUnfSxcbiAgJ2V2ZW50cy5kb3duJzogZnVuY3Rpb24oIGUgKSB7XG4gICAgdmFyIF90aGlzID0gdGhpc1xuICAgIHZhciBob2xkZXIgPSB0aGlzLnBhcmVudFxuICAgIHZhciBlWSA9IGUueVxuICAgIHZhciBlWCA9IGUueFxuICAgIHZhciBpZCA9ICdwYXNzQ2hlY2snXG5cbiAgICB0aGlzLmFkZEV2ZW50KCAnbW92ZScsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgdmFyIGRZID0gZS55IC0gZVlcbiAgICAgIHZhciBkWCA9IGUueCAtIGVYXG4gICAgICBpZiAoIE1hdGguYWJzKCBkWCApID4gTWF0aC5hYnMoIGRZICkgKSB7XG4gICAgICAgIGhvbGRlci4kZm9jdXMuJHVzZXJPcmlnaW4gPSBfdGhpcy5uYW1lXG4gICAgICB9XG4gICAgICBfdGhpcy5yZW1vdmVFdmVudCggZmFsc2UsIGlkIClcbiAgICB9LCBpZCApXG5cbiAgICB0aGlzLmFkZEV2ZW50KCAndXAnLCBmdW5jdGlvbiggZSApIHtcbiAgICAgIF90aGlzLnJlbW92ZUV2ZW50KCBmYWxzZSwgaWQgKVxuICAgIH0sIGlkIClcbiAgfVxufSApLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoIHtcbiAgY3NzOiAnZmlyc3QtZGlzY292ZXInLFxuICBzcG90bGlnaHQ6IG5ldyBMaXN0SG9sZGVyKCB7XG4gICAgaGVhZGVyOmZhbHNlLFxuICAgIGxpc3Q6IG5ldyBMaXN0LlNwb3RsaWdodCh7J21vZGVsLmZpZWxkJzonc3BvdGxpZ2h0J30pLFxuICAgIGRvdHM6IG5ldyBMaXN0LkRvdHMoKVxuICB9ICksXG4gIGNoYW5uZWxzOiBuZXcgTGlzdEhvbGRlcih7XG4gICAgbW9kZWw6e2ZpZWxkOidjaGFubmVscyd9LFxuICAgIGxpc3Q6IG5ldyBMaXN0LkNoYW5uZWwoKVxuICB9ICksXG4gIHdhdGNoaW5nOiBuZXcgTGlzdEhvbGRlcigge1xuICAgIG1vZGVsOntmaWVsZDond2F0Y2hpbmcnfSxcbiAgICBsaXN0OiBuZXcgTGlzdC5XYXRjaGluZygpXG4gIH0gKSxcbiAgcmVsZWFzZXM6IG5ldyBMaXN0SG9sZGVyKCB7XG4gICAgbW9kZWw6e2ZpZWxkOidyZWxlYXNlcyd9LFxuICAgIGxpc3Q6IG5ldyBMaXN0LlBvc3RlcigpXG4gIH0gKSxcbiAgcmVjb21tZW5kZWQ6IG5ldyBMaXN0SG9sZGVyKCB7XG4gICAgbW9kZWw6e2ZpZWxkOidyZWNvbW1lbmRlZCd9LFxuICAgIGxpc3Q6IG5ldyBMaXN0LlBvc3RlcigpXG4gIH0gKSxcbiAgZXh0ZW5kOntcbiAgICAkZm9jdXM6IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0eXBlb2YgdmFsLnZhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB0aGlzW3ZhbC52YWxdXG4gICAgICAgIDogdGhpcy5jaGlsZHJlblsgdmFsLnZhbCB8fCAwIF1cbiAgICAgIF9mb2N1c2VkKCB0aGlzLCBjaGlsZCApXG4gICAgfVxuICB9LFxuICBzY3JvbGxiYXI6ICd5JyxcbiAgJ2V2ZW50cy5zY3JvbGwnOiBmdW5jdGlvbiggZSApIHtcbiAgICBpZihleHBvcnRzLmlnbm9yZVNjcm9sbCkgcmV0dXJuXG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVcbiAgICB2YXIgZnJhY3Rpb24gPSAoZXhwb3J0cy5zY3JvbGxUb3AgPSBub2RlLnNjcm9sbFRvcCkgLyAoIG5vZGUuc2Nyb2xsSGVpZ2h0IC0gbm9kZS5vZmZzZXRIZWlnaHQgKVxuICAgIHZhciBpbmRleCA9IE1hdGgucm91bmQoIGZyYWN0aW9uICogKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEgKSApXG4gICAgdmFyIG5hbWUgPSB0aGlzLmNoaWxkcmVuW2luZGV4XS5uYW1lXG4gICAgdGhpcy4kZm9jdXMuJHVzZXJPcmlnaW4gPSBuYW1lXG4gIH0sXG4gIHNldFNldHRpbmc6IHtcbiAgICBuYW1lOiAncHJlcFZhbHVlcycsXG4gICAgcGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5cbiAgICAgIHZhciBjaGlsZFxuICAgICAgdmFyIGZpZWxkXG4gICAgICB2YXIgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoXG4gICAgICB2YXIgaSA9IGxlbmd0aCAtIDFcbiAgICAgIHZhciBvYmpcblxuICAgICAgZm9yICggOyBpID49IDA7IGktLSApIHtcbiAgICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXVxuICAgICAgICBmaWVsZCA9ICdmb2N1c18nICsgY2hpbGRyZW5baV0ubmFtZVxuICAgICAgICBpZiAoICFhcHAudXNlclsgZmllbGQgXSApe1xuICAgICAgICAgIG9iaiA9IHt9XG4gICAgICAgICAgb2JqWyBmaWVsZCBdID0gMFxuICAgICAgICAgIGFwcC51c2VyLnNldCggb2JqIClcbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5saXN0LiRmb2N1cyA9IGFwcC51c2VyWyBmaWVsZCBdXG4gICAgICAgIGlmKGNoaWxkLmRvdHMpIGNoaWxkLmRvdHMuY29udGFpbmVyLiRmb2N1cyA9IGFwcC51c2VyWyBmaWVsZCBdXG4gICAgICB9XG5cbiAgICAgIGlmKGV4cG9ydHMuc2Nyb2xsVG9wKXtcbiAgICAgICAgZXhwb3J0cy5pZ25vcmVTY3JvbGwgPSB0cnVlXG4gICAgICAgIHRoaXMubm9kZS5zY3JvbGxUb3AgPSBleHBvcnRzLnNjcm9sbFRvcFxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgZXhwb3J0cy5pZ25vcmVTY3JvbGwgPSBmYWxzZVxuICAgICAgICB9KVxuICAgICAgfWVsc2V7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgZXhwb3J0cy5pZ25vcmVTY3JvbGwgPSB0cnVlXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICBleHBvcnRzLmlnbm9yZVNjcm9sbCA9IGZhbHNlXG4gICAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5ub2RlXG4gICAgICAgICAgaWYobm9kZSl7XG4gICAgICAgICAgICB2YXIgZm9jdXMgPSBfdGhpcy4kZm9jdXMudmFsXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBnZXRJbmRleChfdGhpc1tmb2N1c10pXG4gICAgICAgICAgICBub2RlLnNjcm9sbFRvcCA9IGluZGV4LyhsZW5ndGggLSAxKSAqICggbm9kZS5zY3JvbGxIZWlnaHQgLSBub2RlLm9mZnNldEhlaWdodCApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgfVxuICB9XG59ICkuQ2xhc3NcblxuZnVuY3Rpb24gZ2V0SW5kZXgoIF90aGlzICl7XG4gIGlmIChfdGhpcy5faW5kZXggPT09IHZvaWQgMCkge1xuICAgIHZhciBzaWJsaW5ncyA9IF90aGlzLnBhcmVudC5jaGlsZHJlblxuICAgIGZvciAodmFyIGkgPSBzaWJsaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgc2libGluZ3NbaV0uX2luZGV4ID0gaVxuICAgIH1cbiAgfVxuICByZXR1cm4gX3RoaXMuX2luZGV4XG59XG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgTW92aWUgPSByZXF1aXJlKCcuLi9tb3ZpZScpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IE1vdmllKHtcbiAgJ2hvbGRlci5wYWdlJzoge1xuICAgICdhY3RvcnMuYm9keS5jb2xsZWN0aW9uLmRhdGEnOidzaG93LmFjdG9ycycsXG4gICAgJ3JlY29tbWVuZGF0aW9ucy5ib2R5LmNvbGxlY3Rpb24uZGF0YSc6J3Nob3cucmVjb21tZW5kYXRpb25zJ1xuICB9XG59KS5DbGFzc1xuXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE1LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG5yZXF1aXJlKCAnLi9zdHlsZS5sZXNzJyApXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgY2FzZXMgPSBhcHAuY2FzZXNcbnZhciBUb3BiYXIgPSByZXF1aXJlKCcuL3RvcGJhcicpXG52YXIgTWVudSA9IHJlcXVpcmUoJy4vbWVudScpXG52YXIgUmVtb3RlID0gcmVxdWlyZSgnLi9yZW1vdGUnKVxudmFyIFBvcHVwXG52YXIgRmlyc3RcblxuLy9hcHAgYWxsZWVuIG1hYXIgem8gcmVxdWlyZW4gem9kYXQgamUgZXJiaWoga2FuIHZhcnMgbW9ldGVuIGFsdGlqZCBtZWdlZ2V2YiB3aXJkZW5cbi8vYXBwIGthbiBqZSB1c2VuIHZvb3IgZGluZ2VuIGFscyBhcHAudywgYXBwLmggb2YgZGVmYXVsdCBjYXNlc1xuXG5pZiAoIGNhc2VzLiRpc1Bob25lICkge1xuXG4gIHZhciBTd2l0Y2hlciA9IHJlcXVpcmUoICcuL3N3aXRjaGVyJyApXG5cbiAgRmlyc3QgPSBuZXcgRWxlbWVudCh7XG4gICAgLy8gdzphcHAudyxcbiAgICB5Ont2YWw6MCx0cmFuc2xhdGU6dHJ1ZX0sXG4gICAgLy8gaDphcHAuaCxcbiAgICBjc3M6ICdmaXJzdC1zdGF0ZScsXG4gICAgbWVudTogbmV3IE1lbnUoe1xuICAgICAgbWVudTogYXBwLm1lbnVcbiAgICB9KSxcbiAgICBvbjoge1xuICAgICAgLy9yZXBsYWNlIG9uIHdpdGggZXh0ZW5kZWQgdmFycyAobmljZXIpIG1heWJlIG1ha2UgYSB0eXBlIGZvciB0aGlzICh2YWx1ZSB0aGF0IGFsc28gdHJpZXMgdG8gZ2V0IHBhcmVudCBpZiBpdHMgbm8gZnVsbClcbiAgICAgIC8vdmFsdWUgdGhhdCBoYXMgYSBmdW5jdGlvbiBvbiBpdCB0aGF0cyBqdXN0IHRoZSBkZWZlcj9cbiAgICAgIHBvcHVwOntcbiAgICAgICAgZGVmZXI6ZnVuY3Rpb24odXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgICB2YXIgY2FsbGVyID0gdGhpcy5fcGFyZW50Ll9jYWxsZXJcbiAgICAgICAgICBpZih0eXBlb2YgdGhpcy52YWwgPT09ICdzdHJpbmcnIHx8IHRoaXMuZnJvbS5fY29udGVudFR5cGUgPT09ICdhY3RvcnMnKSB7XG4gICAgICAgICAgICBpZighY2FsbGVyLnBvcHVwKSB7XG4gICAgICAgICAgICAgIFBvcHVwID0gUG9wdXAgfHwgcmVxdWlyZSgnLi9wb3B1cCcpXG4gICAgICAgICAgICAgIGNhbGxlci5zZXQoe1xuICAgICAgICAgICAgICAgIHBvcHVwOiBuZXcgUG9wdXAoe1xuICAgICAgICAgICAgICAgICAgcG9wdXA6dGhpcy5fdmFsXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNlY29uZFBvcHVwOntcbiAgICAgICAgZGVmZXI6ZnVuY3Rpb24odXBkYXRlKSB7XG4gICAgICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgICB2YXIgY2FsbGVyID0gdGhpcy5fcGFyZW50Ll9jYWxsZXJcbiAgICAgICAgICBpZih0eXBlb2YgdGhpcy52YWwgPT09ICdzdHJpbmcnIHx8IHRoaXMuZnJvbS5fY29udGVudFR5cGUgPT09ICdhY3RvcnMnKSB7XG4gICAgICAgICAgICBpZighY2FsbGVyLnZvbHVtZSkge1xuICAgICAgICAgICAgICBQb3B1cCA9IFBvcHVwIHx8IHJlcXVpcmUoJy4vcG9wdXAnKVxuICAgICAgICAgICAgICBjYWxsZXIuc2V0KHtcbiAgICAgICAgICAgICAgICB2b2x1bWU6IG5ldyBQb3B1cCh7XG4gICAgICAgICAgICAgICAgICBwb3B1cDp0aGlzLl92YWxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBob2xkZXI6IHtcbiAgICAgIGNzczp7XG4gICAgICAgIHZhbDogYXBwLm1lbnUsIFxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHZhbCwgY3YpIHtcbiAgICAgICAgICByZXR1cm4gY3YgPyAnb3BlbicgOiAnJ1xuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB4OnsgXG4gICAgICAgIHZhbDogYXBwLm1lbnUsXG4gICAgICAgIG11bHRpcGx5OjMyNSxcbiAgICAgICAgYW5pbWF0aW9uOnsgdGltZTogMTIsIGVhc2luZzonb3V0Q3ViaWMnIH0gXG4gICAgICB9LFxuICAgICAgdG9wYmFyOiBuZXcgVG9wYmFyKCksXG4gICAgICAvLyB3OiB7XG4gICAgICAvLyAgIHBhcmVudDogJ3cnXG4gICAgICAvLyB9LFxuICAgICAgLy8gaDp7XG4gICAgICAvLyAgIHBhcmVudDogJ2gnXG4gICAgICAvLyB9LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGRvd246ZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmKGFwcC5tZW51LnZhbCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50ID0gdHJ1ZVxuICAgICAgICAgICAgYXBwLm1lbnUudmFsID0gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzd2l0Y2hlcjogbmV3IFN3aXRjaGVyKHtcbiAgICAgICAgLy8gdzphcHAudyxcbiAgICAgICAgLy8gaDp7IHZhbDphcHAuaCxzdWI6VG9wYmFyLmJhc2UuaCB9XG4gICAgICB9KSxcbiAgICAgIG1pbmlwbGF5ZXI6IG5ldyBSZW1vdGUoe1xuICAgICAgICBcbiAgICAgIH0pIFxuICAgIH1cbiAgfSkuQ2xhc3NcblxufSBlbHNlIHtcblxuICBGaXJzdCA9IG5ldyBFbGVtZW50KHtcbiAgICB0ZXh0OiAnb29wcyBub3QgcGhvbmUgaW4gZmlyc3RzY3JlZW4nXG4gIH0pLkNsYXNzXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGaXJzdCIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi9zaGFyZWQvaWNvbicpXG5cbnZhciBNZW51SXRlbSA9IG5ldyBFbGVtZW50KHtcblx0aWNvbjogbmV3IEljb24oe2ljb246J3NlYXJjaCd9KSxcblx0Y3NzOidtZW51LWl0ZW0nLFxuXHR0aXRsZTp7fVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuXHR3OmFwcC53LFxuXHRoOmFwcC5oLFxuXHRsb2dvOiB7fSxcblx0Y3NzOidtZW51Jyxcblx0ZXh0ZW5kOiB7XG5cdFx0bWVudTpmdW5jdGlvbigpe30sXG5cdFx0bmF2aWdhdGlvbjpmdW5jdGlvbigpe31cblx0fSxcblx0Ly8gc2Nyb2xsYmFyOid5Jyxcblx0YXBwZW5kOiBbXG5cdFx0TWVudUl0ZW0sXG5cdFx0eyAndGl0bGUudGV4dCc6J3NlYXJjaCcsXG5cdFx0XHQnaWNvbi5pY29uJzogJ3NlYXJjaE1lbnUnLFxuXHRcdFx0J2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Lm5hdmlnYXRpb24uZnJvbS5wYWdlLiR1c2VyT3JpZ2luID0gJ3NlYXJjaCdcblx0XHRcdFx0dGhpcy5wYXJlbnQubWVudS5mcm9tLnZhbCA9IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR7ICd0aXRsZS50ZXh0JzonZGlzY292ZXInLFxuXHRcdFx0J2ljb24uaWNvbic6ICdkaXNjb3ZlcicsXG5cdFx0ICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudC5uYXZpZ2F0aW9uLmZyb20ucGFnZS4kdXNlck9yaWdpbiA9ICdkaXNjb3Zlcidcblx0XHRcdFx0dGhpcy5wYXJlbnQubWVudS5mcm9tLnZhbCA9IGZhbHNlXG5cdFx0XHR9XG5cdFx0fSxcblx0XHR7XG5cdFx0XHQndGl0bGUudGV4dCc6J29uIGRlbWFuZCcsXG5cdFx0XHQnaWNvbi5pY29uJzogJ3Nob3dzJyxcblx0XHRcdGNzczonbWVudS1pdGVtIGluYWN0aXZlJ1xuXHRcdH0sXG5cdFx0e1xuXHRcdFx0J3RpdGxlLnRleHQnOidsaXZlIHR2Jyxcblx0XHRcdCdpY29uLmljb24nOiAndHYnLFxuXHRcdCAgY3NzOidtZW51LWl0ZW0gaW5hY3RpdmUnXG5cdFx0fSxcblx0XHR7XG5cdFx0XHQndGl0bGUudGV4dCc6J2d1aWRlJyxcblx0XHRcdCdpY29uLmljb24nOiAnZXBnJyxcblx0XHRcdGNzczonbWVudS1pdGVtIGluYWN0aXZlJ1xuXHRcdH1cblx0XSxcblx0Zm9vdGVyOiB7XG5cdFx0cHJvZmlsZTp7fSxcblx0XHR0aXRsZToge1xuXHRcdFx0dGV4dDonS2V2aW4gVGFndWUnXG5cdFx0fSxcblx0XHRzZXR0aW5nczogbmV3IEljb24oe1xuXHRcdFx0aWNvbjonc2V0dGluZ3MnXG5cdFx0fSlcblx0fVxufSkuc2V0KHtcblx0bmF2aWdhdGlvbjp7XG5cdFx0ZGVmZXI6ZnVuY3Rpb24odXBkYXRlKSB7XG5cdFx0XHRpZih0aGlzLmZyb20ucGFnZSkge1xuXHRcdFx0XHRmb3IodmFyIGkgaW4gdGhpcy5fY2FsbGVyLmNoaWxkcmVuKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5fY2FsbGVyLmNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0dmFyIHRpdGxlID0gY2hpbGQudGl0bGUgJiYgIGNoaWxkLnRpdGxlLnRleHQudmFsXG5cdFx0XHRcdFx0dmFyIHBhZ2UgPSB0aGlzLmZyb20ucGFnZS52YWxcblxuXHRcdFx0XHRcdGlmKCB0aXRsZSAmJiB0aXRsZT09PXBhZ2UgJiYgdGhpcy5fZm9jdXNlZCE9PWNoaWxkKSB7XG5cdFx0XHRcdFx0XHRpZih0aGlzLl9mb2N1c2VkKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2ZvY3VzZWQuY3NzID0nbWVudS1pdGVtJ1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHR0aGlzLl9mb2N1c2VkID0gdGhpcy5fY2FsbGVyLmNoaWxkcmVuW2ldXG5cdFx0XHRcdFx0XHR0aGlzLl9mb2N1c2VkLmNzcyA9ICdtZW51LWl0ZW0gZm9jdXNlZCcgXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHVwZGF0ZSgpXG5cdFx0fVxuXHR9XG59KS5DbGFzc1xuXG5cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBUaXRsZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3RpdGxlJylcbnZhciBTdWJ0aXRsZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3N1YnRpdGxlJylcbnZhciBEZXNjcmlwdGlvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2Rlc2NyaXB0aW9uJylcbnZhciBCYXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9iYXInKVxudmFyIEFjdG9ycyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2FjdG9ycycpXG52YXIgUmVjb21tZW5kYXRpb25zID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvcmVjb21tZW5kYXRpb25zJylcbnZhciBDb250ZW50ID0gcmVxdWlyZSgnLi4vY29udGVudCcpXG52YXIgTXBhYSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL21wYWEnKVxudmFyIFJhdGluZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3JhdGluZycpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IENvbnRlbnQoe1xuICAnaG9sZGVyLnBhZ2UnOiB7XG4gICAgdGl0bGViYXI6bmV3IEJhcih7XG4gICAgICBsZWZ0OntcbiAgICAgICAgdGl0bGU6bmV3IFRpdGxlKCksXG4gICAgICAgIHN1YnRpdGxlOm5ldyBTdWJ0aXRsZSgpXG4gICAgICB9LFxuICAgICAgcmlnaHQ6e1xuICAgICAgICBtcGFhOm5ldyBNcGFhKCksXG4gICAgICAgIHJhdGluZzpuZXcgUmF0aW5nKClcbiAgICAgIH1cbiAgICB9KSxcbiAgICBkZXNjcmlwdGlvbjogbmV3IERlc2NyaXB0aW9uKCksXG4gICAgYWN0b3JzOm5ldyBBY3RvcnMoKSxcbiAgICByZWNvbW1lbmRhdGlvbnM6bmV3IFJlY29tbWVuZGF0aW9ucygpXG4gIH1cbn0pLkNsYXNzIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxuXG52YXIgRnVsbHNjcmVlbiA9IG5ldyBFbGVtZW50KHtcbiAgaWNvbjogbmV3IEljb24oeyBpY29uOiAnZnVsbHNjcmVlbicgfSksXG4gIGV2ZW50czoge1xuICAgIGNsaWNrOiBmdW5jdGlvbigpe1xuICAgICAgY29uc29sZS5sb2coJ2dvIGZ1bGxzY3JlZW4hJylcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gRnVsbHNjcmVlblxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgVmlkZW8gPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvJylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRnVsbHNjcmVlbiA9IHJlcXVpcmUoJy4vZnVsbHNjcmVlbicpXG52YXIgU2Vla2JhciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3NlZWtiYXInKVxuXG52YXIgcG9zdHBvbmUgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG5cbnZhciBBU1NFVFMgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKS5wb2ludGVycy5hc3NldHNcblxudmFyIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKVxuXG52YXIgTG9hZGVyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvbG9hZGVyJylcblxudmFyIFBsYXllciA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOidmaXJzdC1wbGF5ZXInLFxuICB2aWRlbzogbmV3IFZpZGVvKHtcbiAgICBwbGF5ZXI6IHJlcXVpcmUoICd2aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvL2h0bWw1JyApLFxuICAgIHNyYzogeyBkYXRhOiAndmlkZW8nLCBwcmVwZW5kOiBBU1NFVFMgfSxcbiAgICBkdXJhdGlvbjogeyBkYXRhOiAnZHVyYXRpb24nIH0sXG4gICAgdm9sdW1lOiAxLFxuICAgIHRpbWU6IHsgZGF0YTogJ3RpbWUnIH0sXG4gICAgZXZlbnRzOntcbiAgICAgIHN0YWxsZWQ6ZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcmVsb2FkID0gdGhpcy5wYXJlbnQucHJlbG9hZFxuICAgICAgICBpZiggcHJlbG9hZCApIHByZWxvYWQodHJ1ZSlcbiAgICAgIH0sXG4gICAgICBwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5yZW5kZXJlZCAmJiB0aGlzLmdldEJ1ZmZlcigpPDAuMDAxKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQucHJlbG9hZCh0cnVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2FucGxheTpmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQucHJlbG9hZChmYWxzZSlcbiAgICAgIH0sXG4gICAgICBwcm9ncmVzczogZnVuY3Rpb24ocCwgYikge1xuICAgICAgICAvL2RpdCBnYWF0IGVydWl0XG5cbiAgICAgICAgaWYodGhpcy5wcmVsb2FkaW5nICYmIGItcCA+IDAuMSkge1xuICAgICAgICAgIHRoaXMucGFyZW50LnByZWxvYWQoZmFsc2UpXG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLmRhdGEuX2NvbnRlbnRUeXBlIT09J2NoYW5uZWxzJykge1xuICAgICAgICAgIHRoaXMuZGF0YS5mcm9tLnNldCgndGltZScsIC1NYXRoLmFicyhwKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSksXG4gIGg6MjEwLFxuICAvLyBsb2FkZXI6IHtcbiAgLy8gICAndyxoJzoyMDAsXG4gIC8vIH0sXG4gIG92ZXJsYXk6IHtcbiAgICBtaWRkbGU6IHtcbiAgICAgIGxlZnQ6IHsgcGxheToge1xuICAgICAgICAgIGljb246IG5ldyBJY29uKHsgXG4gICAgICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICAgIHZhbDogJ3BsYXknLFxuICAgICAgICAgICAgICAkaXNQbGF5aW5nOiAncGF1c2UnXG4gICAgICAgICAgICB9IFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN1YnRpdGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgIHZhbDogJ1BsYXknLFxuICAgICAgICAgICAgICAkaXNQbGF5aW5nOiAnUGF1c2UnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIGRvd246IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICBpZih0aGlzLmNoZWNrUGFyZW50KCdvdmVybGF5Jyx0cnVlKS5vcGFjaXR5LnZhbCA+IDAuNSkge1xuICAgICAgICAgICAgICAgIHZhciBwbGF5aW5nID0gdGhpcy5jaGVja1BhcmVudCgnb3ZlcmxheScpLnBsYXlpbmcuZnJvbVxuICAgICAgICAgICAgICAgIHBsYXlpbmcudmFsID0gIXBsYXlpbmcudmFsXG4gICAgICAgICAgICAgICAgLy8gZS50ZW1wUHJldmVudCA9IHRydWVcbiAgICAgICAgICAgICAgICBlLnByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtaWRkbGU6IHsgXG4gICAgICAgIGxpbmU6IHt9LFxuICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgdmFsOiAnbm9uZScsXG4gICAgICAgICAgJGhhc1JlY2VpdmVyOiAndGFibGUtY2VsbCcsXG4gICAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbigpe31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7IFxuICAgICAgICBzd2lwZXVwOiB7XG4gICAgICAgICAgaWNvbjogbmV3IEljb24oeyBpY29uOiAnc3dpcGV1cCcgfSksXG4gICAgICAgICAgc3VidGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6ICdQbGF5IG9uICdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgZG93bjogZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgIGlmKHRoaXMuY2hlY2tQYXJlbnQoJ292ZXJsYXknLHRydWUpLm9wYWNpdHkudmFsID4gMC41KSB7XG4gICAgICAgICAgICAgICAgYXBwLnVzZXIucmVjZWl2ZXIucGxheWluZy4kdXNlck9yaWdpbiA9IHRydWVcbiAgICAgICAgICAgICAgICBhcHAudXNlci5yZWNlaXZlci5tZWRpYS4kdXNlck9yaWdpbiA9IHRoaXMuY2hlY2tQYXJlbnQoJ2RhdGEnLHRydWUpLmZyb21cbiAgICAgICAgICAgICAgICBlLnByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICB2YWw6ICdub25lJyxcbiAgICAgICAgICAkaGFzUmVjZWl2ZXI6ICd0YWJsZS1jZWxsJyxcbiAgICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCl7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIGxlZnQ6IHsgXG4gICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgZGF0YTpmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLl9jb250ZW50VHlwZT09PSdjaGFubmVscycgPyAnbm9uZScgOiAndGFibGUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lOnsgaG9sZGVyOiB7IHRleHQ6e2RhdGE6J3RpbWUnLCBtdWx0aXBseTogeyBkYXRhOidkdXJhdGlvbid9LCBhYnM6dHJ1ZSwgJGNvbnZlcnRUaW1lOnRydWUgfSB9IH0sXG4gICAgICAgICAgaG9sZGVyIDp7XG4gICAgICAgICAgICBzZWVrYmFyOiBuZXcgU2Vla2Jhcih7XG4gICAgICAgICAgICAgYnV0dG9uOnt5Ont2YWw6LTgsdHJhbnNsYXRlOnRydWV9fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOnsgdGV4dDp7IGRhdGE6J2R1cmF0aW9uJywgJGNvbnZlcnRUaW1lOnRydWUgfSB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByaWdodDogeyBmdWxsc2NyZWVuOiBuZXcgRnVsbHNjcmVlbigpIH1cbiAgICB9LFxuICAgIG9wYWNpdHk6IHtcbiAgICAgIHZhbDoxLCBhbmltYXRpb246e1xuICAgICAgICB0aW1lOjE4LFxuICAgICAgICBlYXNpbmc6J291dEN1YmljJ1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVmaW5lOiB7XG4gICAgcHJlbG9hZDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAvLyBpZih2YWw9PT10cnVlICYmIHRoaXMucmVuZGVyZWQpIHtcbiAgICAgIC8vICB0aGlzLnByZWxvYWRpbmcgPSB0cnVlXG4gICAgICAvLyAgdGhpcy5vdmVybGF5LmJvdHRvbS5sZWZ0LnRhYmxlLmhvbGRlci5zZWVrYmFyLmNzcyA9ICd1aS1zZWVrYmFyIGxvYWRpbmcnXG4gICAgICAvLyAgdGhpcy5vdmVybGF5Lm9wYWNpdHkgPSAxXG4gICAgICAvLyB9IGVsc2Uge1xuICAgICAgLy8gICB0aGlzLnByZWxvYWRpbmcgPSBmYWxzZVxuICAgICAgLy8gICB0aGlzLm92ZXJsYXkuYm90dG9tLmxlZnQudGFibGUuaG9sZGVyLnNlZWtiYXIuY3NzID0gJ3VpLXNlZWtiYXInXG4gICAgICAvLyAgIGlmKHRoaXMudmlkZW8uJHBsYXlpbmcudmFsPT09dHJ1ZSkge1xuICAgICAgLy8gICAgIHRoaXMub3ZlcmxheS5vcGFjaXR5ID0gMFxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG4gICAgfSxcbiAgICBmYWRlT3V0OnBvc3Rwb25lKGZ1bmN0aW9uKCkge1xuICAgICAgaWYodGhpcy5wbGF5aW5nICYmIHRoaXMucGxheWluZy52YWw9PT10cnVlICYmICF0aGlzLnByZWxvYWRpbmcpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Lm9wYWNpdHkgPSAwXG4gICAgICB9XG4gICAgfSwzMDAwKVxuICB9LFxuICBldmVudHM6IHtcbiAgICBkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICBpZih0aGlzLm92ZXJsYXkub3BhY2l0eS52YWw9PT0wIHx8IGUudGVtcFByZXZlbnQpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5Lm9wYWNpdHkgPSAxIFxuICAgICAgICBpZih0aGlzLnBsYXlpbmcudmFsPT09dHJ1ZSkge1xuICAgICAgICAgIHRoaXMuZmFkZU91dCgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZih0aGlzLnBsYXlpbmcudmFsPT09dHJ1ZSAmJiAhZS50ZW1wUHJldmVudCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkub3BhY2l0eSA9IDBcbiAgICAgIH1cbiAgICB9LFxuICAgIG1vdmU6ZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLnBsYXlpbmcudmFsPT09dHJ1ZSkge1xuICAgICAgICB0aGlzLmZhZGVPdXQoKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZXh0ZW5kOntcbiAgICBwbGF5aW5nOiB7XG4gICAgICBzZXQ6ZnVuY3Rpb24odmFsKSB7XG4gICAgICAgIHRoaXMudmlkZW8uJHBsYXlpbmcgPSB2YWxcbiAgICAgICAgaWYodmFsLnZhbD09PXRydWUpIHtcbiAgICAgICAgICB0aGlzLm92ZXJsYXkub3BhY2l0eSA9IDBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm92ZXJsYXkub3BhY2l0eSA9IDFcbiAgICAgICAgfVxuICAgICAgLy8gaWYoKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgYXBwLmlzUGxheWluZy5mcm9tID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlY2VpdmVyOiBmdW5jdGlvbih2YWwsIHN0YW1wKSB7XG4gICAgICBpZihjYXNlcy4kaGFzUmVjZWl2ZXIudmFsKSB7XG4gICAgICAgIHZhciByZWNlaXZlckNsaWVudCA9IHZhbC5mcm9tXG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsYXllclxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFBhZ2UgPSByZXF1aXJlKCcuLi9wYWdlLmpzJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIExpc3QgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0JylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIFBvc3RlciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QvaXRlbScpLlBvc3RlclxudmFyIFRyaXZpYSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3RyaXZpYScpXG52YXIgRGVzY3JpcHRpb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9kZXNjcmlwdGlvbicpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBQYWdlKHtcbiAgdzogYXBwLncsXG4gIGg6IHtcbiAgICB2YWw6IGFwcC5oLFxuICAgIHN1YjogNjBcbiAgfSxcbiAgc2Nyb2xsYmFyOiAneScsXG4gIGNhcm91c2VsOiB7XG4gICAgY29udGFpbmVyOiBuZXcgTGlzdC5DYXJvdXNlbCh7XG4gICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgIGRhdGE6ICdpbWcuY292ZXInLFxuICAgICAgICBlbGVtZW50OiBuZXcgRWxlbWVudCh7XG4gICAgICAgICAgY3NzOiAnZm9jdXMtaXRlbScsXG4gICAgICAgICAgaW1nOiBuZXcgSW1nKHtcbiAgICAgICAgICAgIG92ZXJsYXk6IHt9LFxuICAgICAgICAgICAgJ2JhY2tncm91bmQuZGF0YSc6IHRydWVcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgICRmb2N1czoge1xuICAgICAgICBkYXRhOiAnZm9jdXMnXG4gICAgICB9XG4gICAgfSksXG4gICAgZG90czogbmV3IExpc3QuRG90cyh7XG4gICAgICBjb250YWluZXI6IHtcbiAgICAgICAgY29sbGVjdGlvbjoge1xuICAgICAgICAgIGRhdGE6ICdpbWcuY292ZXInLFxuICAgICAgICAgIGVsZW1lbnQ6IG5ldyBFbGVtZW50KClcbiAgICAgICAgfSxcbiAgICAgICAgJGZvY3VzOiB7XG4gICAgICAgICAgZGF0YTogJ2ZvY3VzJyxcbiAgICAgICAgICBkZWZhdWx0OjBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLFxuICAgICdtb2RlbC5zdWJzY3JpcHRpb24nOiB7XG4gICAgICBpbWc6IHtcbiAgICAgICAgY292ZXI6IHtcbiAgICAgICAgICAkOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJpbzogbmV3IERlc2NyaXB0aW9uKHtcbiAgICAnaGVhZGVyLnRleHQnOiAnYmlvJyxcbiAgICAnYm9keS50ZXh0LmRhdGEnOiAnYmlvJ1xuICB9KSxcbiAgZmFtb3VzOiB7XG4gICAgJ2hlYWRlci50ZXh0JzogJ0ZhbW91cyBGb3InLFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGRhdGE6ICdjYXRhbG9nJyxcbiAgICAgIGVsZW1lbnQ6IG5ldyBQb3N0ZXIoe1xuICAgICAgICAnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gZmFsc2VcbiAgICAgICAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEuZnJvbVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSxcbiAgdHJpdmlhOiBuZXcgVHJpdmlhKHtcbiAgICBtb2RlbDoge1xuICAgICAgZmllbGQ6ICd0cml2aWEnXG4gICAgfVxuICB9KSxcbiAgb246IHtcbiAgICAkcGFyZW50OiB7XG4gICAgICBkZWZlcjogZnVuY3Rpb24odXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudC5fY2FsbGVyLnBhcmVudC5wYXJlbnQudG9wYmFyLm1pZGRsZS50ZXh0ID0gdGhpcy5fcGFyZW50Ll9jYWxsZXIuZGF0YS5nZXQoJ3RpdGxlJylcbiAgICAgICAgdXBkYXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBjYXNlcyA9IHJlcXVpcmUoICd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycgKVxudmFyIHVhID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL3VhJyApXG5cbnZhciByYWYgPSByZXF1aXJlKCAndmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgSWNvbiA9IHJlcXVpcmUoICcuLi8uLi8uLi9zaGFyZWQvaWNvbicgKVxuXG52YXIgRGV2aWNlID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICdkZXZpY2UnLFxuICBpY29uOiBuZXcgSWNvbih7IGljb246IHsgXG4gICAgZGF0YTogJ2RldmljZSdcbiAgfSB9KSxcbiAgaW5mbzoge1xuICAgIHRpdGxlOiB7IHRleHQ6IHsgZGF0YTogJ3RpdGxlJ30gfSxcbiAgICBzdWJ0aXRsZTogeyB0ZXh0OiB7IGRhdGE6ICdpbmZvJyB9IH1cbiAgfVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoIHtcbiAgY3NzOiAnYWN0aXZlIGRldmljZXMnLFxuICBteURldmljZTogbmV3IERldmljZSh7XG4gICAgbW9kZWw6IHsgaW5oZXJpdDogZmFsc2UgfSxcbiAgICBvbjoge1xuICAgICAgJG5ldzoge2RlZmVyOiBmdW5jdGlvbih1cGRhdGUpe1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2NhbGxlci5kYXRhID0gYXBwLmNsb3VkLmNsaWVudFxuICAgICAgICB1cGRhdGUoKVxuICAgICAgfX1cbiAgICB9LFxuICAgIGluZm86IHtcbiAgICAgIHRpdGxlOiB7IHRleHQ6ICdUaGlzIERldmljZScgfSxcbiAgICAgIHN1YnRpdGxlOiB7IHRleHQ6IHsgZGF0YTogJ3RpdGxlJyB9IH1cbiAgICB9XG4gIH0pLFxuICBsaXN0VGl0bGU6IHsgdGV4dDogJ0F2YWlsYWJsZSBEZXZpY2VzJyB9LFxuICBtaWRkbGU6IHtcbiAgICBkaXNwbGF5OiB7XG4gICAgICB2YWw6ICdibG9jaycsXG4gICAgICAkaGFzRGV2aWNlczogJ25vbmUnXG4gICAgfSxcbiAgICB0ZXh0OiAnTm8gRGV2aWNlcyBBdmFpbGFibGUnXG4gIH0sXG4gIGxpc3Q6IHtcbiAgICBkaXNwbGF5OiB7XG4gICAgICB2YWw6ICdub25lJyxcbiAgICAgICRoYXNEZXZpY2VzOiAnYmxvY2snXG4gICAgfSxcbiAgICBjb2xsZWN0aW9uOiB7XG4gICAgICBlbGVtZW50OiBuZXcgRGV2aWNlKCB7XG4gICAgICAgIGNzczogJ2RldmljZScsXG4gICAgICAgIG1vZGVsOiBmdW5jdGlvbiggZGF0YSApIHtcbiAgICAgICAgICBpZiggZGF0YSAmJiBkYXRhLmZyb20gJiYgZGF0YS5mcm9tLmRldmljZSAmJiBcbiAgICAgICAgICAgICAgLyhwaG9uZSkvLnRlc3QoXG4gICAgICAgICAgICAgICAgZGF0YS5mcm9tLmRldmljZS52YWwgXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gMC41XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICBjbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdXNlciA9IGFwcC51c2VyLy90aGlzLmNoZWNrUGFyZW50KCAnb24udXNlcicsIHRydWUgKS5fdmFsXG4gICAgICAgICAgICB2YXIgY2xpZW50ID0gdGhpcy5kYXRhLmZyb21cbiAgICAgICAgICAgIGlmKCAvKHR2KXwodGFibGV0KXwoSUZFKS8udGVzdCggXG4gICAgICAgICAgICAgICAgICBjbGllbnQuZGV2aWNlLnZhbCBcbiAgICAgICAgICAgICAgICApIFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdXNlci5zZXRSZWNlaXZlciggY2xpZW50IClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gKSxcbiAgICAgIGRhdGE6IHRydWVcbiAgICB9XG4gIH0sXG4gIG9uOiB7XG4gICAgJHJlbmRlcjoge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKHVwZGF0ZSkge1xuICAgICAgICAvLyBmZiBiaW5kZW4gbm9nXG4gICAgICAgIHZhciBjYWxsZXIgPSB0aGlzLl9wYXJlbnQuX2NhbGxlclxuICAgICAgICBjYWxsZXIub24uZGV2aWNlcy5fdmFsLl91cGRhdGUoKVxuICAgICAgICB1cGRhdGUoKVxuICAgICAgfVxuICAgIH0sXG4gICAgJHBhcmVudDp7XG4gICAgICBkZWZlcjpmdW5jdGlvbih1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9jYWxsZXIucGFyZW50LnBhcmVudC50b3BiYXIubWlkZGxlLnRleHQgPSAnZGV2aWNlcydcbiAgICAgICAgdXBkYXRlKClcbiAgICAgIH1cbiAgICB9LFxuICAgIGRldmljZXM6IHtcbiAgICAgIGRlZmVyOiBmdW5jdGlvbiggdXBkYXRlICkge1xuICAgICAgICB2YXIgY2FsbGVyID0gdGhpcy5fcGFyZW50Ll9jYWxsZXJcbiAgICAgICAgY2FsbGVyLm9uLnJlY2VpdmVyLl91cGRhdGUoKVxuICAgICAgICBjYWxsZXIuZGF0YSA9IHRoaXMuZnJvbVxuICAgICAgICB1cGRhdGUoKVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVjZWl2ZXI6IHtcbiAgICAgIGRlZmVyOiBmdW5jdGlvbiggdXBkYXRlICkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAgIC8vIFRPRE86IGdldCByaWQgb2YgdGhpcyByYWZcbiAgICAgICAgcmFmKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoIF90aGlzLl9wYXJlbnQgKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGVyID0gX3RoaXMuX3BhcmVudC5fY2FsbGVyXG4gICAgICAgICAgICB2YXIgcmVjZWl2ZXIgPSAgX3RoaXMuZnJvbVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBlbGVtID0gY2FsbGVyLmxpc3QuZmluZCggJ19kLmZyb20nLCByZWNlaXZlci5mcm9tIClcbiAgICAgICAgICAgIGlmICggZWxlbSApIHtcbiAgICAgICAgICAgICAgaWYgKCBfdGhpcy5mb2N1cyAmJiBfdGhpcy5mb2N1cy5fbm9kZSApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5mb2N1cy5jc3MgPSB7XG4gICAgICAgICAgICAgICAgICByZW1vdmVDbGFzczogJ2ZvY3VzZWQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF90aGlzLmZvY3VzID0gZWxlbVxuICAgICAgICAgICAgICBlbGVtLmNzcyA9IHtcbiAgICAgICAgICAgICAgICBhZGRDbGFzczogJ2ZvY3VzZWQnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIF90aGlzLmZvY3VzICkge1xuICAgICAgICAgICAgICBpZiAoIF90aGlzLmZvY3VzICYmIF90aGlzLmZvY3VzLl9ub2RlICkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZvY3VzLmNzcyA9IHtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiAnZm9jdXNlZCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuZm9jdXMgPSBudWxsXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgfSApXG4gICAgICB9XG4gICAgfVxuICB9XG59ICkuQ2xhc3NcbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3NoYXJlZC9pY29uJylcblxudmFyIFBvcHVwID0gcmVxdWlyZSgnLi4vLi4vc2hhcmVkL3BvcHVwJylcblxudmFyIEFjdG9yXG52YXIgVm9sdW1lXG52YXIgRGV2aWNlc1xudmFyIFJlbW90ZVxuXG4vL2Jhc2lzIG9mIHBvcHVwIGlzIHNoYXJlZCAoYWxzbyB1c2VkIGZvciByZW1vdGU/IG9yIGlzIHJlbW90ZSBhIHBvcHVwIHRoaW5nPylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IFBvcHVwKHtcbiAgcG9wdXA6e1xuICAgIC8vIG1pc2M6ZnVuY3Rpb24odXBkYXRlKSB7XG4gICAgLy8gIHZhciB2YWwgPSB0aGlzLnZhbFxuICAgIC8vICAvL2RpdCBpcyBnZWRlZWxkIC0tIHpvdSBvb2sgdmFudWl0IGFwcCBrdW5uZW4gZXZlbnR1ZWVsXG4gICAgLy8gfSxcbiAgICBkZWZlcjpmdW5jdGlvbih1cGRhdGUsYXJncykge1xuXG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgXG4gICAgICB2YXIgdmFsID0gdGhpcy52YWxcbiAgICAgIHZhciBlbGVtZW50XG4gICAgICB2YXIgc3dpdGNoZXIgPSB0aGlzLl9jYWxsZXIgJiYgdGhpcy5fY2FsbGVyLnN3aXRjaGVyXG4gICAgICB2YXIgcGFyYW1zID0ge31cbiAgICAgIHZhciB0b3BiYXJQYXJhbXNcblxuICAgICAgaWYoIXN3aXRjaGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIGlmKHZhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignd3RmIGlzIGhhcHBlbmluPz8/PycpXG4gICAgICAgIHRoaXMuX2NhbGxlci55ID0gYXBwLmgudmFsXG4gICAgICB9IGVsc2UgaWYodGhpcy5mcm9tLl9jb250ZW50VHlwZSA9PT0gJ2FjdG9ycycpIHsgLy9saXN0ZW4gdG8gbWlzYyBkaWZmZXJlbnQhXG4gICAgICAgIC8vd29yZCBpZiB0aGlzLl9jb250ZW50VHlwZSA9PT0gJ2FjdG9yJyAvLyBkb2UgZGl0IC0tIHBvcHVwLnZhbCB3b3JkIG9wIGdlbGlzdGVuZCBpbiBhcHBcbiAgICAgICAgZWxlbWVudCA9IEFjdG9yID0gQWN0b3IgfHwgcmVxdWlyZSgnLi9hY3RvcicpXG4gICAgICAgIHBhcmFtcyA9IHsgXG4gICAgICAgICAgLy8gY2Fyb3VzZWw6e1xuICAgICAgICAgIC8vICAgY29udGFpbmVyOntcbiAgICAgICAgICAvLyAgICAgJGZvY3VzOiB0aGlzLmZyb20uZ2V0KCdmb2N1cycsMilcbiAgICAgICAgICAvLyAgIH0sXG4gICAgICAgICAgLy8gICBkb3RzOntcbiAgICAgICAgICAvLyAgICAgY29udGFpbmVyOntcbiAgICAgICAgICAvLyAgICAgICAkZm9jdXM6IHRoaXMuZnJvbS5nZXQoJ2ZvY3VzJywyKVxuICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgLy8gICB9XG4gICAgICAgICAgLy8gfSxcbiAgICAgICAgICBkYXRhOiB0aGlzLmZyb21cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKHZhbCA9PT0gJ3ZvbHVtZScpIHsgLy9saXN0ZW4gdG8gbWlzYyBkaWZmZXJlbnQhXG4gICAgICAgIGVsZW1lbnQgPSBWb2x1bWUgPSBWb2x1bWUgfHwgcmVxdWlyZSgnLi92b2x1bWUnKVxuICAgICAgfSBlbHNlIGlmKHZhbCA9PT0gJ2RldmljZXMnKSB7IC8vbGlzdGVuIHRvIG1pc2MgZGlmZmVyZW50IVxuICAgICAgICAvLyB0b3BiYXIubWlkZGxlLnRleHQudmFsID0gYXBwLmRldmljZU1lc3NhZ2VcbiAgICAgICAgZWxlbWVudCA9IERldmljZXMgPSBEZXZpY2VzIHx8IHJlcXVpcmUoJy4vZGV2aWNlcycpXG5cbiAgICAgICAgdmFyIHVzZXIgPSBhcHAudXNlclxuXG4gICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgZGV2aWNlczogdXNlci5kZXZpY2VzLFxuICAgICAgICAgICAgcmVjZWl2ZXI6IHVzZXIucmVjZWl2ZXJDbGllbnRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZih2YWwgPT09ICdyZW1vdGUnKSB7IC8vbGlzdGVuIHRvIG1pc2MgZGlmZmVyZW50IVxuICAgICAgICBlbGVtZW50ID0gUmVtb3RlID0gUmVtb3RlIHx8IHJlcXVpcmUoJy4vcmVtb3RlJylcbiAgICAgICAgdG9wYmFyUGFyYW1zID0ge1xuICAgICAgICAgIC8vIGxlZnQ6e1xuICAgICAgICAgIC8vICAgaWNvbjonbmF2RG93bidcbiAgICAgICAgICAvLyB9LFxuICAgICAgICAgIG1pZGRsZTp7XG4gICAgICAgICAgICB0ZXh0OntkYXRhOid0aXRsZSd9LFxuICAgICAgICAgICAgZGF0YTphcHAudXNlci5yZWNlaXZlci5tZWRpYVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyByaWdodDp7XG4gICAgICAgICAgLy8gICBkaXNwbGF5Oidub25lJ1xuICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgfSBcblxuICAgICAgaWYoZWxlbWVudCkge1xuICAgICAgICBzd2l0Y2hlci50cmFuc2l0aW9uID0ge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgJHBhcmFtczogcGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYodG9wYmFyUGFyYW1zKXtcbiAgICAgICAgc3dpdGNoZXIucGFyZW50LnRvcGJhci5zZXQodG9wYmFyUGFyYW1zKVxuICAgICAgfVxuXG4gICAgICB1cGRhdGUoKVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxuXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG5cbi8vbWF5YmUgYWRkIHNjcm9sbCwgb25seSB3aGVuIGxpc3QgaXMgdG9vIGxhcmdlXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbi8vIHg6e3RyYW5zbGF0ZTp0cnVlfVxuLy8gLCBzY3JvbGxiYXI6J3knXG59KS5DbGFzcyIsInZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uLy4uL3NoYXJlZC9pY29uJylcbnZhciBMaXN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vc2hhcmVkL2xpc3QnKVxudmFyIG9mZnNldCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy9vZmZzZXQnKVxuXG52YXIgdGh1bWIgPSBuZXcgTGlzdC5JdGVtLkluZm8oe1xuXHRjc3M6J2Nhcm91c2VsLWl0ZW0nLFxuXHRzY2FsZTp7XG5cdFx0cGFyZW50Oid4Jyxcblx0XHR0cmFuc2Zvcm06ZnVuY3Rpb24oKXtcblx0XHRcdHZhciByZWN0ID0gdGhpcy5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cdFx0XHR2YXIgbGVmdCA9IHJlY3QubGVmdFxuXHRcdFx0dmFyIHJpZ2h0ID0gcmVjdC5yaWdodFxuXHRcdFx0dmFyIG1pZGRsZSA9IGFwcC53LnZhbC8yXG5cdFx0XHR2YXIgd2lkdGggPSByZWN0LndpZHRoXG5cdFx0XHR2YXIgdmFsID0gTWF0aC5tYXgoMSAtIE1hdGguYWJzKChsZWZ0ICsgd2lkdGgvMikgLSBtaWRkbGUpLzEwMDAsMC44KVxuXHRcdFx0dGhpcy5jc3MgPSBsZWZ0IDw9IG1pZGRsZSAmJiByaWdodCA+PSBtaWRkbGVcblx0XHRcdFx0P1x0J2Nhcm91c2VsLWl0ZW0gZnJvbnQnXG5cdFx0XHRcdDogJ2Nhcm91c2VsLWl0ZW0nXG5cdFx0XHRyZXR1cm4gdmFsXG5cdFx0fVxuXHR9LFxuICAnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpIHtcbiAgXHRhcHAucG9wdXAuJHVzZXJPcmlnaW4gPSBmYWxzZVxuICAgIGFwcC51c2VyLm5hdmlnYXRpb24uY29udGVudC4kdXNlck9yaWdpbiA9IHRoaXMuZGF0YS5mcm9tXG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcblx0dzphcHAudyxcblx0aDoyNDAsXG5cdGV4dGVuZDoge1xuXHRcdG1lZGlhOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdC8vbG9vayBmb3IgZm9jdXNcblx0XHRcdC8vZG9lIGRhdCBwYXMgb24gaXMgbG9hZGVkXG5cdFx0XHQvLyBpZih2YWwuZnJvbS5fY29udGVudFR5cGU9PT0nY2hhbm5lbHMnKSB7XG5cblx0XHRcdHZhciBfdGhpcyA9IHRoaXNcblx0XHRcdHZhciBzbGlkZXIgPSB0aGlzLnNsaWRlclxuXHRcdFx0dmFyIGNoaWxkcmVuID0gc2xpZGVyLmNoaWxkcmVuXG5cblx0XHRcdGZvcih2YXIgaSBpbiBjaGlsZHJlbikge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXVxuXHRcdFx0XHRpZihjaGlsZC5kYXRhID09PSB2YWwuZnJvbSAmJiB0aGlzLmZvY3VzZWQgIT09IGNoaWxkKSB7XG5cdFx0XHRcdFx0aWYoIXNsaWRlci5fY2hlY2sgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSl7XG5cdFx0XHRcdFx0XHRzbGlkZXIueC5fcCA9IHRydWVcblx0XHRcdFx0XHRcdHNsaWRlci4kZm9jdXMgPSBpXG5cdFx0XHRcdFx0XHRzbGlkZXIueC5fcCA9IG51bGxcblx0XHRcdFx0XHRcdHNsaWRlci5fY2hlY2sgPSB0cnVlXG5cdFx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0XHRzbGlkZXIuJGZvY3VzID0gaVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZighdGhpcy5saXN0ZW5Gb2N1cykge1xuXHRcdFx0XHRcdFx0dGhpcy5saXN0ZW5Gb2N1cyA9IHRydWVcblx0XHRcdFx0XHRcdHNsaWRlci4kZm9jdXMub24oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBmb2N1cyA9IHNsaWRlci5jaGlsZHJlblt0aGlzLnZhbF0uZGF0YVxuXHRcdFx0XHRcdFx0XHRpZih2YWwuZnJvbSE9PWZvY3VzICYmIGZvY3VzKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly9udSBtb2V0IGVyIGVlbiBvbmNlIGxpc3RlbmVyIG9wIHRpbWVcblx0XHRcdFx0XHRcdFx0XHRhcHAudXNlci5yZWNlaXZlci5tZWRpYS4kdXNlck9yaWdpbiA9IGZvY3VzXG5cdFx0XHRcdFx0XHRcdFx0YXBwLnVzZXIubmF2aWdhdGlvbi5jb250ZW50LiR1c2VyT3JpZ2luID0gZm9jdXNcblx0XHRcdFx0XHRcdFx0XHRmb2N1cy5nZXQoJ3RpbWUnKS5pcygnbG9hZGVkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihhcHAudXNlci5yZWNlaXZlci5tZWRpYS5mcm9tPT09Zm9jdXMpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcy52YWwgPSBNYXRoLmFicyh0aGlzLnZhbClcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gfVxuXHRcdH1cblx0fSxcblx0c2xpZGVyOiBuZXcgTGlzdC5DYXJvdXNlbCh7XG5cdFx0eDp7dmFsOjI4MC0zMCsyfSxcblx0XHRjb2xsZWN0aW9uOiB7XG5cdFx0XHRkYXRhOnRydWUsXG5cdFx0XHRmaWx0ZXI6dHJ1ZSxcblx0XHRcdGVsZW1lbnQ6dGh1bWJcblx0XHR9LFxuXHRcdG1vZGVsOntcblx0XHRcdGNvbXBsZXRlOmZ1bmN0aW9uKCl7XG5cdFx0XHRcdGlmKHRoaXMuY2hpbGRyZW5bMV0gJiYgdGhpcy5wYXJlbnQubWVkaWEpeyAvLyBmb3JjZSBhbiB1cGRhdGUgd2hlbiBjaGlsZHJlbiBhcmUgcmVhZHlcblx0XHRcdFx0XHR0aGlzLnguX3AgPSB0cnVlXG5cdFx0XHRcdFx0dGhpcy5wYXJlbnQubWVkaWEudXBkYXRlKClcblx0XHRcdFx0XHR0aGlzLm1vZGVsID0gZmFsc2Vcblx0XHRcdFx0XHR0aGlzLnguX3AgPSBudWxsXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pXG59KS5DbGFzc1xuXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgUGFnZSA9IHJlcXVpcmUoICcuLi9wYWdlLmpzJyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBTZWVrYmFyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2JhcicpXG5cbnZhciBDYXJvdXNlbCA9IHJlcXVpcmUoJy4vY2Fyb3VzZWwnKVxuXG52YXIgRGVzY3JpcHRpb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9kZXNjcmlwdGlvbicpXG5cbnZhciBHdWlkZSA9IG5ldyBFbGVtZW50KHtcblx0J2hlYWRlci50ZXh0JzogJ1VwIE5leHQnLFxuXHRpdGVtczoge1xuXHRcdGNvbGxlY3Rpb246IHtcblx0XHRcdGRhdGE6J2d1aWRlJyxcblx0XHRcdGVsZW1lbnQ6IG5ldyBFbGVtZW50KHtcblx0XHRcdFx0Y3NzOidib2R5Jyxcblx0XHRcdFx0dGl0bGU6IHsgdGV4dDogeyBkYXRhOid0aXRsZScgfSB9LFxuXHRcdFx0XHRzdWJ0aXRsZToge1xuXHRcdFx0XHRcdHRleHQ6IHtcblx0XHRcdFx0XHRcdGRhdGE6J3N0YXJ0LXRpbWUnLFxuXHRcdFx0XHRcdFx0YWRkOltcblx0XHRcdFx0XHRcdFx0JyAtICcsXG5cdFx0XHRcdFx0XHRcdHsgZGF0YTonZW5kLXRpbWUnIH1cblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXHR9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgUGFnZSh7XG5cdGNzczoncmVtb3RlJyxcblx0Ly8gdGV4dDp7dmFsOidyZW1vdGVpdCEnfSxcblx0Y2Fyb3VzZWw6IG5ldyBDYXJvdXNlbCgpLFxuXHRpbmZvOiB7XG5cblx0fSxcblx0Y29udHJvbHM6IHtcblx0XHR0aXRsZTogeyB0ZXh0OnsgZGF0YTonZ3VpZGUuMC50aXRsZScsIGRlZmF1bHQ6e2RhdGE6J3RpdGxlJ30gfX0sXG5cdFx0c2Vla2JhcjogbmV3IFNlZWtiYXIoKSxcblx0XHRidXR0b25zOiB7XG5cdFx0XHRsZWZ0OiBuZXcgSWNvbih7XG5cdFx0XHRcdGljb246J3Jld2luZCdcblx0XHRcdH0pLFxuXHRcdFx0cGxheTogbmV3IEljb24oe1xuXHRcdFx0XHRleHRlbmQ6IHtcblx0XHRcdFx0XHRwbGF5aW5nOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdFx0XHRcdHRoaXMuaWNvbiA9IHZhbC52YWwgPT09IHRydWUgPyAncGF1c2UnIDogJ3BsYXknXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRpY29uOidwbGF5Jyxcblx0XHRcdFx0J2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5aW5nLiR1c2VyT3JpZ2luID0gIXRoaXMucGxheWluZy52YWxcblx0XHRcdFx0fVxuXHRcdFx0fSksXG5cdFx0XHRyaWdodDogbmV3IEljb24oe1xuXHRcdFx0XHRpY29uOidmYXN0Zm9yd2FyZCdcblx0XHRcdH0pLFxuXHRcdFx0dm9sdW1lOiBuZXcgSWNvbih7XG5cdFx0XHRcdGljb246J3ZvbHVtZScsXG5cdFx0XHRcdCdldmVudHMuY2xpY2snOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRhcHAuc2Vjb25kUG9wdXAudmFsID0gJ3ZvbHVtZSdcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdH0sXG5cdGV4dGVuZDoge1xuXHRcdHJlY2VpdmVyTWVkaWE6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0dmFyIGluZm8gPSB0aGlzLmluZm9cblx0XHRcdHZhciBmcm9tID0gdmFsLmZyb21cblx0XHRcdHRoaXMuY29udHJvbHMuZGF0YSA9IHZhbC5mcm9tXG5cdFx0XHRcblx0XHRcdC8vYnVnIGZpeFxuXHRcdFx0dmFyIHNlZWsgPSB0aGlzLmNvbnRyb2xzLnNlZWtiYXIuc2Vla1xuXHRcdFx0c2Vlay53LnVwZGF0ZShzZWVrKVxuXG5cdFx0XHRpZihmcm9tLl9jb250ZW50VHlwZT09PSdjaGFubmVscycpIHtcblx0XHRcdFx0aWYoaW5mby5ndWlkZSYmaW5mby5ndWlkZS5kYXRhICE9PSBmcm9tKSB7XG5cdFx0XHRcdFx0aW5mby5lbXB0eSgpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWluZm8uZ3VpZGUpIHtcblx0XHRcdFx0XHRpbmZvLmVtcHR5KClcblx0XHRcdFx0XHRpbmZvLnNldCh7XG5cdFx0XHRcdFx0XHRndWlkZTogbmV3IEd1aWRlKHtkYXRhOmZyb219KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0dGhpcy5jYXJvdXNlbC5kYXRhID0gYXBwLmNvbnRlbnQuZ2V0KCdjaGFubmVscycpXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jYXJvdXNlbC5tZWRpYSA9IGZyb21cblxuXHRcdFx0fSBlbHNlIGlmKCBmcm9tLl9jb250ZW50VHlwZSAhPT0gJ3JlY2VpdmVyJykge1xuXHRcdFx0XHRpZihpbmZvLmRlc2NyaXB0aW9uICYmIGluZm8uZGVzY3JpcHRpb24uZGF0YSAhPT0gZnJvbSkge1xuXHRcdFx0XHRcdGluZm8uZW1wdHkoKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFpbmZvLmRlc2NyaXB0aW9uKSB7XG5cdFx0XHRcdFx0aW5mby5lbXB0eSgpXG5cdFx0XHRcdFx0aW5mby5zZXQoe1xuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb246IG5ldyBEZXNjcmlwdGlvbih7ZGF0YTpmcm9tfSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGlmKGZyb20uX2NvbnRlbnRUeXBlPT09J21vdmllcycpIHtcblx0XHRcdFx0XHRcdHRoaXMuY2Fyb3VzZWwuZGF0YSA9IGFwcC5jb250ZW50LmdldCgnbW92aWVzJylcblx0XHRcdFx0XHRcdC8vZm9jdXMgZ2FhdCB3ZWlyZCFcblx0XHRcdFx0XHR9IGVsc2UgaWYoZnJvbS5fY29udGVudFR5cGUgPT09ICdzZXJpZXMnKSB7XG5cdFx0XHRcdFx0XHQvL2NvbnRlbnQgdHlwZSB3b3JkIGVwaXNvZGUgLS0tXG5cdFx0XHRcdFx0XHQvL2hhcmRlciB0byBkb1xuXHRcdFx0XHRcdFx0dGhpcy5jYXJvdXNlbC5kYXRhID0gYXBwLmNvbnRlbnQuZ2V0KCdzZXJpZXMnKVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY2Fyb3VzZWwubWVkaWEgPSBmcm9tXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRvbjoge1xuXHRcdCRwYXJlbnQ6e2RlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuXHRcdFx0dGhpcy5fcGFyZW50Ll9jYWxsZXIucGFyZW50LnBhcmVudC50b3BiYXIubWlkZGxlLnRleHQgPSAncmVtb3RlJ1xuXHRcdFx0dXBkYXRlKClcblx0XHR9fSxcblx0XHQkbmV3OntkZWZlcjpmdW5jdGlvbih1cGRhdGUpIHtcblx0XHRcdHRoaXMuX3BhcmVudC5fY2FsbGVyLnJlY2VpdmVyTWVkaWEgPSBhcHAudXNlci5yZWNlaXZlci5tZWRpYVxuXHRcdFx0dGhpcy5fcGFyZW50Ll9jYWxsZXIuY29udHJvbHMuYnV0dG9ucy5wbGF5LnBsYXlpbmcgPSBhcHAudXNlci5yZWNlaXZlci5wbGF5aW5nXG5cdFx0XHR1cGRhdGUoKVxuXHRcdH19XG5cdH1cbn0pLkNsYXNzXG5cblxuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBQYWdlID0gcmVxdWlyZSggJy4uL3BhZ2UuanMnIClcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vLi4vc2hhcmVkL2ljb24nKVxudmFyIG9mZnNldCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy9vZmZzZXQnKVxuXG5yZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgUGFnZSh7XG5cdHc6YXBwLncsXG5cdGNzczondm9sdW1lJyxcblx0dG9wOiB7XG5cdFx0dGl0bGU6IHsgdGV4dDogJzEwMCUnIH0sXG5cdFx0dm9sdW1lOiBuZXcgSWNvbih7XG5cdFx0XHRpY29uOid2b2x1bWUnLCBcblx0XHRcdCdldmVudHMuY2xpY2snOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQucGFyZW50LnZvbHVtZS4kdXNlck9yaWdpbiA9IDFcblx0XHRcdH1cblx0XHR9KVxuXHR9LFxuXHRleHRlbmQ6IHtcblx0XHR2b2x1bWU6ZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRpZighdGhpcy5fdm9sc2V0ICYmIHZhbC5mcm9tIT09dmFsKSB7XG5cdFx0XHRcdHRoaXMuX3ZvbHNldCA9IHRydWVcblx0XHRcdFx0dGhpcy5zbGlkZXIuYmxvY2sueSA9IHZhbFxuXHRcdFx0XHR0aGlzLnNsaWRlci5ibG9jay5taWRkbGUudGV4dCA9IHZhbFxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0b246IHtcblx0XHQkbmV3OnsgXG5cdFx0XHRkZWZlcjpmdW5jdGlvbih1cGRhdGUpIHtcblx0XHRcdFx0dmFyIGNhbGxlciA9IHRoaXMuX3BhcmVudC5fY2FsbGVyXG5cdFx0XHRcdGlmKCFjYWxsZXIudm9sdW1lKSB7XG5cdFx0XHRcdFx0Y2FsbGVyLnZvbHVtZSA9IGFwcC51c2VyLnJlY2VpdmVyLnZvbHVtZVxuXHRcdFx0XHR9XG5cdFx0XHRcdHVwZGF0ZSgpXG5cdFx0XHR9IFxuXHRcdH0sXG5cdFx0JHBhcmVudDp7XG5cdFx0XHRkZWZlcjpmdW5jdGlvbih1cGRhdGUpIHtcblx0XHRcdFx0dGhpcy5fcGFyZW50Ll9jYWxsZXIucGFyZW50LnBhcmVudC50b3BiYXIubWlkZGxlLnRleHQudmFsID0gJ3ZvbHVtZSdcblx0XHRcdFx0dXBkYXRlKClcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHNsaWRlcjoge1xuXHRcdHc6IGFwcC53LFxuXHRcdGg6e3ZhbDphcHAuaCxzdWI6MzUwfSxcblx0XHR4OnttYXg6MCxtaW46MH0sXG5cdFx0YmxvY2s6IHtcblx0XHRcdHk6eyBcblx0XHRcdFx0dHJhbnNmb3JtOiBmdW5jdGlvbih2LGN2KSB7XG5cdFx0XHRcdFx0Y3YgPSBjdj4tMSA/IGN2IDogMVxuXHRcdFx0XHRcdHJldHVybiAodGhpcy5wYXJlbnQgJiYgKHRoaXMucGFyZW50LmgudmFsLTMwKS02MCkqKCAxLWN2ICkrMzBcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGV2ZW50czoge1xuXHRcdFx0XHRkcmFnOmZ1bmN0aW9uKGUpIHtcblxuXHRcdFx0XHRcdGlmKCAhdGhpcy5fb2Zmc2V0ICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fb2Zmc2V0ID0gb2Zmc2V0LnkodGhpcy5wYXJlbnQpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vZHJhZ3N0YXJ0XG5cdFx0XHRcdFx0aWYoIXRoaXMuX2RyYWdpbmZvcykge1xuXHRcdFx0XHRcdFx0dGhpcy5fZHJhZ2luZm9zID0gZS55LW9mZnNldC55KHRoaXMpK3RoaXMuX29mZnNldFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdFx0dmFyIGNhbGMgPSAxIC0gKCBlLnkgLSB0aGlzLl9kcmFnaW5mb3MgKSAvICh0aGlzLnBhcmVudC5oLnZhbC0zMClcblx0XHRcdFx0XHRpZihjYWxjPjEpIGNhbGMgPSAxXG5cdFx0XHRcdFx0aWYoY2FsYzwwKSBjYWxjID0gMFxuXHRcdFx0XHRcdHRoaXMucGFyZW50LnBhcmVudC52b2x1bWUuJHVzZXJPcmlnaW4gPSBjYWxjXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHVwOmZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuX2RyYWdpbmZvcyA9IGZhbHNlXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRsZWZ0OiBuZXcgSWNvbih7XG5cdFx0XHRcdGljb246ICdtZW51J1xuXHRcdFx0fSksXG5cdFx0XHRtaWRkbGU6IHtcblx0XHRcdFx0dGV4dDogeyBcblx0XHRcdFx0XHR0cmFuc2Zvcm06IGZ1bmN0aW9uKGMsIGN2KSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZChjdioxMDApKyclJ1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJpZ2h0OiBuZXcgSWNvbih7XG5cdFx0XHRcdGljb246ICdtZW51UmlnaHQnXG5cdFx0XHR9KSxcblx0XHRcdC8vIHc6e3ZhbDphcHAudyxzdWI6MzB9LFxuXHRcdFx0aDo2MFxuXHRcdH1cblx0fSxcblx0bXV0ZToge1xuXHRcdG11dGVkOiBuZXcgSWNvbih7aWNvbjonbXV0ZWQnfSksXG5cdFx0J2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLnBhcmVudC52b2x1bWUuJHVzZXJPcmlnaW4gPSAwXG5cdFx0fVxuXHR9XG59KS5DbGFzc1xuXG5cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3NoYXJlZC9pY29uJylcbnZhciBTdWJ0aXRsZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3N1YnRpdGxlJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuXHRjc3M6J21pbmktcmVtb3RlJyxcblx0eTp7dmFsOjAsYW5pbWF0aW9uOnsgdGltZToxMCwgZWFzaW5nOidvdXRDdWJpYyd9fSxcblx0ZXh0ZW5kOiB7XG5cdFx0cGxheWluZzogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR0aGlzLnJpZ2h0Lmljb24gPSB2YWwudmFsID09PSB0cnVlID8gJ3BhdXNlJyA6ICdwbGF5J1xuXHRcdH0sXG5cdFx0bWVkaWE6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0dmFyIHR5cGUgPSB2YWwuZnJvbS5fY29udGVudFR5cGVcblx0XHRcdGlmKCB0eXBlID09PSAnbW92aWVzJyB8fCB0eXBlID09PSAnY2hhbm5lbHMnIHx8IHR5cGUgPT09ICdzZXJpZXMnIHx8IHR5cGUgPT09ICdlcGlzb2RlcycgKSB7XG5cdFx0XHRcdHZhciBfdGhpcyA9IHRoaXNcblx0XHRcdFx0Ly8gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gXHRfdGhpcy5wYXJlbnQuc3dpdGNoZXIuaCA9IHsgYWRkOi01MCB9XG5cdFx0XHRcdC8vIH0sNTAwKVxuXG5cdFx0XHRcdHRoaXMueSA9IDBcblx0XHRcdFx0aWYodGhpcy5kYXRhIT09dmFsLmZyb20pIHtcblx0XHRcdFx0XHR0aGlzLmRhdGEgPSB2YWwuZnJvbVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB0aGlzLnBhcmVudC5zd2l0Y2hlci5oID0geyBhZGQ6MCB9XG5cdFx0XHRcdHRoaXMueSA9IDUwXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRsZWZ0OiB7XG5cdFx0YmFja2dyb3VuZDoge1xuXHRcdFx0dmFsOmNvbmZpZy5wb2ludGVycy5pbWcsXG5cdFx0XHRhZGQ6IHsgZGF0YTogJ2ltZy50aHVtYicgfVxuXHRcdH1cblx0fSxcblx0bWlkZGxlOiB7XG5cdFx0dGl0bGU6IHtcblx0XHRcdHRleHQ6e2RhdGE6J3RpdGxlJ31cblx0XHR9LFxuXHRcdGluZm86bmV3IFN1YnRpdGxlKClcblx0fSxcblx0cmlnaHQ6IG5ldyBJY29uKHtcblx0XHRpY29uOidwbGF5Jyxcblx0XHQnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbihlKSB7XG5cdFx0XHRlLnByZXZlbnQgPSB0cnVlXG5cdFx0XHR0aGlzLnBhcmVudC5wbGF5aW5nLiR1c2VyT3JpZ2luID0gIXRoaXMucGFyZW50LnBsYXlpbmcudmFsXG5cdFx0fVxuXHRcdC8vaGllciBmZiBkaWUgbGlzdGVuaW5nXG5cdH0pLFxuXHQnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oZSkge1xuXHRcdGFwcC5wb3B1cC4kdXNlck9yaWdpbiA9ICdyZW1vdGUnXG5cdH1cbn0pLkNsYXNzXG5cblxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG4vLyB2YXIgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0JylcbnZhciBwb3N0cG9uZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy91dGlsJykucG9zdHBvbmVcbnZhciB0aW1lc3RhbXAgPSByZXF1aXJlKCdtb25vdG9uaWMtdGltZXN0YW1wJylcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxudmFyIFRvcGJhciA9IHJlcXVpcmUoJy4uL3RvcGJhcicpXG52YXIgc2VhcmNoID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2VhcmNoJylcblxuLy9UT0RPOiB1c2UgZGF0YSBib3VuZCB0byBkaXNwbGF5IGluc3RlYWQgb2YgdGhlIGJpZyBpZiBzdGF0ZW1lbnRcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J2ZpcnN0LXNlYXJjaCcsXG4gIGV4dGVuZDoge1xuICAgIHNlYXJjaDogZnVuY3Rpb24oKXt9XG4gIH0sXG4gIGRlZmluZToge1xuICAgIGFkZFJlY2VudFNlYXJjaDogcG9zdHBvbmUoZnVuY3Rpb24oc3JjaCkge1xuICAgICAgaWYoIXRoaXMubm9kZSkgcmV0dXJuXG4gICAgICBpZighdGhpcy5wYWdlIHx8ICF0aGlzLnBhZ2UucmVjZW50LmRhdGEpIHJldHVyblxuICAgICAgdmFyIGtleXMgPSB0aGlzLnBhZ2UucmVjZW50LmhvbGRlci5kYXRhLmtleXNcbiAgICAgIHZhciByZWNlbnRzID0gdGhpcy5wYWdlLnJlY2VudC5ob2xkZXIuZGF0YS4kdXNlck9yaWdpblxuICAgICAgaWYoa2V5cy5sZW5ndGg+NSkge1xuICAgICAgICByZWNlbnRzW2tleXNbMF1dLnJlbW92ZSgpXG4gICAgICB9XG4gICAgICB2YXIgZm91bmRcbiAgICAgIGlmKHJlY2VudHMpIHtcbiAgICAgICAgcmVjZW50cy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKHRoaXMudGl0bGUudmFsID09PSBzcmNoKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWVcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgaWYoIWZvdW5kKSB7XG4gICAgICAgIHJlY2VudHMuc2V0KHRpbWVzdGFtcCgpLHt0aXRsZTpzcmNofSlcbiAgICAgIH1cbiAgICB9LDEwMDApXG4gIH0sXG4gIC8vIHRvcGJhcjoge1xuICAvLyAgIGxlZnQ6IG5ldyBJY29uKHtcbiAgLy8gICAgIGljb246J21lbnUnLFxuICAvLyAgICAgZXZlbnRzOiB7XG4gIC8vICAgICAgIGRvd246ZnVuY3Rpb24oZSkge1xuICAvLyAgICAgICAgIGUucHJldmVudCA9IHRydWVcbiAgLy8gICAgICAgICBhcHAubWVudS52YWwgPSAhYXBwLm1lbnUudmFsXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9KSxcbiAgLy8gICBmaWVsZDogbmV3IElucHV0KHtcbiAgLy8gICAgIGV2ZW50czoge1xuICAvLyAgICAgICBmb2N1c291dDogZnVuY3Rpb24oZSkge1xuICAvLyAgICAgICAgIHZhciBvdmVybGF5ID0gdGhpcy5wYXJlbnQucGFyZW50Lm92ZXJsYXlcbiAgLy8gICAgICAgICBvdmVybGF5LmRpc3BsYXkgPSAnbm9uZSdcbiAgLy8gICAgICAgfSxcbiAgLy8gICAgICAgZm9jdXM6ZnVuY3Rpb24oZSkge1xuICAvLyAgICAgICAgIHRoaXMucGFyZW50LnBhcmVudC5vdmVybGF5LnNldCh7XG4gIC8vICAgICAgICAgICBkaXNwbGF5OidibG9jaydcbiAgLy8gICAgICAgICB9KVxuICAvLyAgICAgICB9XG4gIC8vICAgICB9XG4gIC8vICAgfSlcbiAgLy8gfSxcbiAgcGFnZTpuZXcgc2VhcmNoLlJlc3VsdExpc3Qoe1xuICAgIHNjcm9sbGJhcjoneScsXG4gICAgYXBwZW5kOntcbiAgICAgIHZhbDpbXG4gICAgICAgIG5ldyBFbGVtZW50KHtcbiAgICAgICAgICBuYW1lOidub1Jlc3VsdHMnLFxuICAgICAgICAgIGRpc3BsYXk6J25vbmUnLFxuICAgICAgICAgIGljb246IG5ldyBJY29uKHtpY29uOid3cm9uZyd9KSxcbiAgICAgICAgICAndGl0bGUudGV4dCc6J05vIHJlc3VsdHMhJyxcbiAgICAgICAgICAnYm9keS50ZXh0JzonUGxlYXNlIHRyeSB0byByZWZpbmUgeW91ciBxdWVyeSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBzZWFyY2guVG9wUmVzdWx0KHtcbiAgICAgICAgICBuYW1lOid0b3ByZXN1bHQnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgRWxlbWVudCh7XG4gICAgICAgICAgbmFtZToncmVjZW50JyxcbiAgICAgICAgICBtb2RlbDoge1xuICAgICAgICAgICAgaW5oZXJpdDpmYWxzZSxcbiAgICAgICAgICAgIGNvbXBsZXRlOmZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZih0aGlzLmRhdGEua2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vUmVjZW50LmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgICB0aGlzLmhvbGRlci5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubm9SZWNlbnQuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgICAgICAgICB0aGlzLmhvbGRlci5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vUmVjZW50OntcbiAgICAgICAgICAgIGljb246IG5ldyBJY29uKHtpY29uOidzZWFyY2hNZW51J30pLFxuICAgICAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICAgICAgdGV4dDonU3RhcnQgU2VhcmNoaW5nISdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiB7XG4gICAgICAgICAgICAgIHRleHQ6J0ZpbmQgeW91ciBmYXZvcml0ZSBtb3ZpZXMsIHNob3dzIGFuZCBjaGFubmVscy4nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBob2xkZXI6IG5ldyBzZWFyY2guUmVzdWx0cyh7XG4gICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICB0ZXh0OidyZWNlbnQgc2VhcmNoZXMnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sbGVjdGlvbjoge1xuICAgICAgICAgICAgICBkYXRhOnRydWUsXG4gICAgICAgICAgICAgIGVsZW1lbnQ6IG5ldyBzZWFyY2guUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGFyZW50KCdzZWFyY2gnLHRydWUpLiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhLnRpdGxlLnZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGZpbHRlcjoge1xuICAgICAgICAgICAgICAgIHNvcnQ6eyBmaWVsZDonX25hbWUnLCBvcmRlcjonei1hJ31cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICBdLFxuICAgICAgYmVmb3JlOidtb3ZpZXMnXG4gICAgfVxuICB9KSxcbiAgb3ZlcmxheToge1xuICAgIGRpc3BsYXk6J25vbmUnXG4gIH0sXG4gIHNlYXJjaDp7XG4gICAgZGVmZXI6ZnVuY3Rpb24odXBkYXRlLCBhcmdzKSB7XG5cbiAgICAgIGlmKCF0aGlzLmZyb20uY2xvdWQpIHJldHVybiB0cnVlXG5cbiAgICAgIHZhciBjYWxsZXIgPSB0aGlzLl9jYWxsZXJcbiAgICAgIHZhciBlbGVtJFxuXG4gICAgICB2YXIgbGlzdCA9IFtcbiAgICAgICAgICBjYWxsZXIucGFnZS5tb3ZpZXMsXG4gICAgICAgICAgY2FsbGVyLnBhZ2Uuc2VyaWVzLFxuICAgICAgICAgIGNhbGxlci5wYWdlLmNoYW5uZWxzLFxuICAgICAgICAgIGNhbGxlci5wYWdlLmFjdG9yc1xuICAgICAgICBdXG5cbiAgICAgIC8vIGlmKCFjYWxsZXIudG9wYmFyLmZpZWxkLmRhdGEpIHtcbiAgICAgIC8vICAgY2FsbGVyLnRvcGJhci5maWVsZC5kYXRhID0gdGhpcy5fdmFsXG4gICAgICAvLyB9XG4gICAgICBcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG5cbiAgICAgIGlmKHRoaXMudmFsKSB7XG4gICAgICAgIHZhciBzcmNoID0gc2VhcmNoLnBhcnNlU2VhcmNoKCB0aGlzLnZhbCApXG4gICAgICAgIGlmKCBzcmNoIT09ZmFsc2UgKSB7XG4gICAgICAgICAgY2FsbGVyLmFkZFJlY2VudFNlYXJjaChzcmNoKVxuICAgICAgICAgIGZvcih2YXIgaSBpbiBsaXN0KSB7XG4gICAgICAgICAgICBzZWFyY2guZmlsdGVyQ29sbGVjdGlvbiggbGlzdFtpXSwgc3JjaCApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FsbGVyLnBhZ2UucmVjZW50LmRpc3BsYXkgPSAnbm9uZSdcblxuICAgICAgICAgIGNhbGxlci5kYXRhLmdldCgnbW92aWVzJykuaXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzICYmIHRoaXMua2V5cy5sZW5ndGg+MiBcbiAgICAgICAgICAgICAgICAmJiB0aGlzLmZyb21bMF0gJiYgdGhpcy5mcm9tWzBdLmFjdG9yc1xuICAgICAgICAgIH0sIHRydWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZihjYWxsZXIuX25vZGUpIHtcbiAgICAgICAgICAgICAgZm9yKGVsZW0kIGluIGxpc3QpIHtcbiAgICAgICAgICAgICAgICBsaXN0W2VsZW0kXS5kaXNwbGF5ID0gbGlzdFtlbGVtJF0uZmlsdGVyLmxlbmd0aCA+IDAgXG4gICAgICAgICAgICAgICAgICA/ICdibG9jaycgXG4gICAgICAgICAgICAgICAgICA6ICdub25lJyAgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIHZhciByZXN1bHQgPSBzZWFyY2gudG9wUmVzdWx0KCBsaXN0ICkgXG4gICAgICAgICAgICAgIGNhbGxlci5wYWdlLnRvcHJlc3VsdC5kYXRhID0gcmVzdWx0IHx8IGZhbHNlXG4gICAgICAgICAgICAgIGNhbGxlci5wYWdlLnRvcHJlc3VsdC5kaXNwbGF5ID0gcmVzdWx0ID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgICAgICAgICAgICBjYWxsZXIucGFnZS5ub1Jlc3VsdHMuZGlzcGxheSA9IHJlc3VsdCA/ICdub25lJyA6ICdibG9jaydcbiAgICAgICAgICAgICAgLy9pZiBubyByZXN1bHQgdGhlbiAtLS0tXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IoZWxlbSQgaW4gbGlzdCkge1xuICAgICAgICAgICAgbGlzdFtlbGVtJF0uZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYWxsZXIucGFnZS50b3ByZXN1bHQuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgIGNhbGxlci5wYWdlLm5vUmVzdWx0cy5kaXNwbGF5ID0gJ25vbmUnIFxuICAgICAgICAgIGNhbGxlci5wYWdlLnJlY2VudC5kaXNwbGF5ID0gJ2Jsb2NrJyAgXG4gICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvcihlbGVtJCBpbiBsaXN0KSB7XG4gICAgICAgICAgbGlzdFtlbGVtJF0uZGlzcGxheSA9ICdub25lJ1xuICAgICAgICB9XG4gICAgICAgIGNhbGxlci5wYWdlLnRvcHJlc3VsdC5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgIGNhbGxlci5wYWdlLm5vUmVzdWx0cy5kaXNwbGF5ID0gJ25vbmUnIFxuICAgICAgICBjYWxsZXIucGFnZS5yZWNlbnQuZGlzcGxheSA9ICdibG9jaydcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpXG4gICAgfVxuICB9XG59KS5DbGFzc1xuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNSwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xuXG5yZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vc2hhcmVkL2ljb24nKVxudmFyIE1lbnUgPSByZXF1aXJlKCcuLi9tZW51JylcbnZhciBEaXNjb3ZlclxudmFyIFNlYXJjaFxudmFyIENoYW5uZWxcbnZhciBFcGlzb2RlXG52YXIgTW92aWVcbnZhciBjYXNlcyA9IGFwcC5jYXNlc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgU3dpdGNoZXIoe1xuICBjc3M6ICdmaXJzdC1zd2l0Y2hlcicsXG4gICdleHRlbmQubmF2aWdhdGlvbic6IGZ1bmN0aW9uKCkge30sXG4gIG9uVHJhbnNpdGlvbjogJ3NsaWRlJyxcbiAgbG9hZGVyOiBuZXcgRWxlbWVudCh7XG4gICAgY3NzOiAnZmlyc3QtbG9hZGVyJyxcbiAgICB4OiB7XG4gICAgICB0cmFuc2xhdGU6IHRydWVcbiAgICB9LFxuICAgIGxvYWRpY29uOiBuZXcgSWNvbih7XG4gICAgICBpY29uOiAnZXJyb3InXG4gICAgfSlcbiAgfSksXG4gIG5hdmlnYXRpb246IHtcbiAgICBkZWZlcjogZnVuY3Rpb24odXBkYXRlLCBhcmdzKSB7XG4gICAgICB2YXIgbmF2ID0gdGhpcy5mcm9tXG5cbiAgICAgIGlmICghbmF2IHx8ICFuYXYubGFzdCB8fCAhbmF2Lmxhc3QuZnJvbS5rZXkpIHJldHVybiB0cnVlXG5cbiAgICAgIHZhciBmaWVsZCA9IG5hdi5sYXN0LmZyb20ua2V5LnZhbFxuICAgICAgdmFyIHBhZ2VcbiAgICAgIHZhciBlbGVtZW50XG4gICAgICB2YXIgc3dpdGNoZXIgPSB0aGlzLl9jYWxsZXJcbiAgICAgIHZhciBwYXJhbXNcbiAgICAgIHZhciBvcHRpb25zXG4gICAgICBuYXYgPSBuYXZbZmllbGRdXG5cbiAgICAgIGlmIChmaWVsZCA9PT0gJ3BhZ2UnKSB7XG5cbiAgICAgICAgdmFyIHBhZ2UgPSBuYXYudmFsXG5cbiAgICAgICAgaWYgKHBhZ2UgPT09ICdkaXNjb3ZlcicpIHtcbiAgICAgICAgICBlbGVtZW50ID0gRGlzY292ZXIgPSBEaXNjb3ZlciB8fCByZXF1aXJlKCcuLi9kaXNjb3ZlcicpXG4gICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgJGZvY3VzOiBhcHAudXNlci5mb2N1c19yb3csXG4gICAgICAgICAgICBkYXRhOiBhcHAuY29udGVudC5nZXQoJ2Rpc2NvdmVyJylcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocGFnZSA9PT0gJ3NlYXJjaCcpIHtcbiAgICAgICAgICBlbGVtZW50ID0gU2VhcmNoID0gU2VhcmNoIHx8IHJlcXVpcmUoJy4uL3NlYXJjaCcpXG4gICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgZGF0YTogYXBwLmNsb3VkLmRhdGEsXG4gICAgICAgICAgICBzZWFyY2g6IGFwcC51c2VyLnNlYXJjaCxcbiAgICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgICAgcmVjZW50OiB7XG4gICAgICAgICAgICAgICAgZGF0YTogYXBwLnVzZXIucmVjZW50U2VhcmNoZXMuZnJvbVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoZmllbGQgPT09ICdjb250ZW50Jykge1xuICAgICAgICBpZiAoIXN3aXRjaGVyLl9zd0VsZW0gfHwgc3dpdGNoZXIuX3N3RWxlbS5kYXRhICE9PSBuYXYuZnJvbSkge1xuXG4gICAgICAgICAgdmFyIHR5cGUgPSBuYXYuX2NvbnRlbnRUeXBlXG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ21vdmllcycpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBNb3ZpZSA9IE1vdmllIHx8IHJlcXVpcmUoJy4uL21vdmllJylcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcGlzb2RlcycpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBFcGlzb2RlID0gRXBpc29kZSB8fCByZXF1aXJlKCcuLi9lcGlzb2RlJylcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjaGFubmVscycpIHtcbiAgICAgICAgICAgIGVsZW1lbnQgPSBDaGFubmVsID0gQ2hhbm5lbCB8fCByZXF1aXJlKCcuLi9jaGFubmVsJylcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgZGF0YTogbmF2LmZyb20sXG4gICAgICAgICAgICBob2xkZXI6IHtcbiAgICAgICAgICAgICAgcGxheWVyOiB7XG4gICAgICAgICAgICAgICAgcGxheWluZzogYXBwLmlzUGxheWluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlcjogYXBwLnVzZXIucmVjZWl2ZXJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVjZWl2ZXJNZWRpYTogYXBwLnVzZXIucmVjZWl2ZXIubWVkaWFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBzd2l0Y2hlci50cmFuc2l0aW9uID0ge1xuICAgICAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgJHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgIGRpcmVjdGlvbjogYXBwLm1lbnUudmFsID8gMCA6IGZpZWxkID09PSAnY29udGVudCcgPyAxIDogLTEsXG4gICAgICAgICAgJG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSgpXG4gICAgfVxuICB9XG59KS5DbGFzc1xuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgdXNlciA9IGFwcC51c2VyXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3NoYXJlZC9pY29uJylcbnZhciBUaXRsZSA9IHJlcXVpcmUoJy4uLy4uL3NoYXJlZC90aXRsZScpXG52YXIgSW5wdXQgPSByZXF1aXJlKCcuL2lucHV0JylcblxudmFyIHNlYXJjaEZpZWxkID0gbmV3IElucHV0KHtcbiAgZXZlbnRzOiB7XG4gICAgZm9jdXNvdXQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgIC8vIHZhciBvdmVybGF5ID0gdGhpcy5wYXJlbnQucGFyZW50Lm92ZXJsYXlcbiAgICAgIC8vIG92ZXJsYXkuZGlzcGxheSA9ICdub25lJ1xuICAgIH0sXG4gICAgZm9jdXM6ZnVuY3Rpb24oZSkge1xuICAgICAgLy8gdGhpcy5wYXJlbnQucGFyZW50Lm92ZXJsYXkuc2V0KHtcbiAgICAgIC8vICAgZGlzcGxheTonYmxvY2snXG4gICAgICAvLyB9KVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuXHRjc3M6J3RvcGJhcicsXG5cdGV4dGVuZDp7XG5cdFx0JGN1cnJlbnQ6ZnVuY3Rpb24odmFsKXtcblx0XHRcdHZhciBjdXJyZW50ID0gdmFsLnZhbFxuXHRcdFx0aWYoY3VycmVudCA9PT0gJ3NlYXJjaCcpe1xuXHRcdFx0XHRpZighdGhpcy5zZWFyY2gpe1xuXHRcdFx0XHRcdHRoaXMuc2V0KHtcblx0XHRcdFx0XHRcdGNzczondG9wYmFyIHNlYXJjaGluZycsXG5cdFx0XHRcdFx0XHRhZGQ6W1xuXHRcdFx0XHRcdFx0XHRuZXcgc2VhcmNoRmllbGQoe1xuXHRcdFx0XHRcdFx0XHRcdG5hbWU6ICdzZWFyY2gnLFxuXHRcdFx0XHRcdFx0XHRcdGRhdGE6YXBwLnVzZXIuc2VhcmNoXG5cdFx0XHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdFx0XHQnbWlkZGxlJ1xuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH1lbHNlIGlmKHRoaXMuc2VhcmNoKXtcblx0XHRcdFx0dGhpcy5zZWFyY2gucmVtb3ZlKClcblx0XHRcdFx0dGhpcy5jc3MgPSAndG9wYmFyJ1xuXHRcdFx0fVxuXG5cdFx0XHRpZiggY3VycmVudCA9PT0gJ2NvbnRlbnQnICl7XG5cdFx0XHRcdHRoaXMubWlkZGxlLmRhdGEgPSB1c2VyLm5hdmlnYXRpb24uY29udGVudC5mcm9tXG5cdFx0XHR9ZWxzZSBpZiggY3VycmVudCA9PT0gJ2Rpc2NvdmVyJyApe1xuXHRcdFx0XHR0aGlzLm1pZGRsZS5kYXRhID0geyB0aXRsZTpjdXJyZW50IH1cblx0XHRcdH1cblxuXHRcdH1cblx0fSxcblx0bGVmdDogbmV3IEljb24oeyBcblx0XHRpY29uOntcblx0XHRcdHZhbDphcHAuY3VycmVudCxcblx0XHRcdHRyYW5zZm9ybTpmdW5jdGlvbih2LGN1cnJlbnQpe1xuXHRcdFx0XHRyZXR1cm4gY3VycmVudCA9PT0gJ2NvbnRlbnQnID8gJ2JhY2snIDogJ21lbnUnXG5cdFx0XHR9XG5cdFx0fSxcblx0XHRldmVudHM6IHtcblx0XHRcdGRvd246ZnVuY3Rpb24oZSkge1xuXHRcdFx0XHRlLnByZXZlbnQgPSB0cnVlXG5cdFx0XHRcdGlmKCB0aGlzLmljb24udmFsID09PSAnbWVudScgKXtcblx0XHRcdFx0XHRhcHAubWVudS52YWwgPSAhYXBwLm1lbnUudmFsXG5cdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdHVzZXIubmF2aWdhdGlvbi5wYWdlLiR1c2VyT3JpZ2luID0gYXBwLnByZXZpb3VzLnZhbCB8fCAnZGlzY292ZXInXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IFxuXHR9KSxcblx0bWlkZGxlOm5ldyBUaXRsZS5TaG93KCksXG5cdHJpZ2h0OiBuZXcgSWNvbih7XG5cdFx0aWNvbjonY2FzdCcsXG5cdFx0J2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKSB7XG5cdFx0XHRhcHAucG9wdXAuJHVzZXJPcmlnaW4gPSAnZGV2aWNlcydcblx0XHR9XG5cdH0pXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuQ2xhc3NcblxuIiwicmVxdWlyZSgnLi9yZXNldC5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBldmVudHMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMnKVxudmFyIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKVxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIG5vZGU6ICdmb3JtJyxcbiAgbmFtZTogJ3NlYXJjaCcsXG4gIGNzczogJ3NlYXJjaC1maWVsZCcsXG4gIG1vZGVsOiB7XG4gICAgaW5oZXJpdDogZmFsc2UsXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy50YWJsZS5jbGVhci5kaXNwbGF5ID0gdGhpcy5kYXRhLnZhbCA/ICd0YWJsZS1jZWxsJyA6ICdub25lJ1xuICAgIH1cbiAgfSxcbiAgdGFibGU6IHtcbiAgICBsZWZ0aWNvbjogbmV3IEljb24oe1xuICAgICAgaWNvbjogJ3NlYXJjaCdcbiAgICB9KSxcbiAgICBpbnB1dEZpZWxkOiB7XG4gICAgICBub2RlOiAnaW5wdXQnLFxuICAgICAgYXR0cjoge1xuICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgIG5hbWU6ICdzZWFyY2gnLFxuICAgICAgICBwbGFjZWhvbGRlcjogJ1NlYXJjaCdcbiAgICAgIH0sXG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGRhdGE6IHRydWVcbiAgICAgIH0sXG4gICAgICBldmVudHM6IHtcbiAgICAgICAga2V5ZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMTMpIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICB9LFxuICAgICAgICBrZXl1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICAgIGlmIChlLmtleUNvZGUgIT09IDkpIHtcbiAgICAgICAgICAgIHZhciBzcmNoID0gdGhpcy5ub2RlLnZhbHVlLmxlbmd0aCA/IHRoaXMubm9kZS52YWx1ZS50cmltKCkgOiAnJ1xuICAgICAgICAgICAgdGhpcy5kYXRhLiR1c2VyT3JpZ2luID0gc3JjaFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgY2xlYXI6IG5ldyBJY29uKHtcbiAgICAgIGljb246ICdjbG9zZVNtYWxsJyxcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgZS5wcmV2ZW50ID0gdHJ1ZVxuICAgICAgICAgIHRoaXMucGFyZW50LmZyb21Eb3duID0gdHJ1ZVxuICAgICAgICAgICAgLy9UT0RPOiBmaWd1cmUgb3V0IHdoeSB0aGlzLnBhcmVudCBkb2VzIG5vdCBoYXZlIGRhdGEgYm91bmQgdG8gaXQhXG4gICAgICAgICAgdGhpcy5wYXJlbnQuaW5wdXRGaWVsZC5kYXRhLiR1c2VyT3JpZ2luID0gJydcbiAgICAgICAgICAgIC8vIGZvY3Vzb3V0LmNhbGwodGhpcy5wYXJlbnQucGFyZW50LGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICBldmVudHM6IHtcbiAgICBmb2N1c2luOiBmb2N1c1xuICB9XG59KS5DbGFzc1xuXG5mdW5jdGlvbiBmb2N1cyhlKSB7XG4gIGNvbnNvbGUubG9nKCd3dGYgd3RmIHd0ZicsIHRoaXMucGFyZW50KVxuICBpZiAodGhpcy5ldmVudHMuZm9jdXMpIHtcbiAgICB0aGlzLmV2ZW50cy5mb2N1cy5fdmFsLmNhbGwodGhpcywgZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmb2N1c291dChlKSB7XG4gIGlmICh0aGlzLmV2ZW50cy5mb2N1c291dCkge1xuICAgIHRoaXMuZXZlbnRzLmZvY3Vzb3V0Ll92YWwuY2FsbCh0aGlzLCBlKVxuICB9XG59XG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOidzZWNvbmQtYmlvJyxcbiAgJ2V4dGVuZC4kZm9jdXMnOmZ1bmN0aW9uKHZhbCl7XG4gICAgdmFyIGluZGV4ID0gdmFsLnZhbFxuICAgIGlmKGluZGV4ICE9PSB0aGlzLl9pbmRleCl7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YVxuICAgICAgaWYoZGF0YSl7XG4gICAgICAgIHRoaXMuc3dpdGNoZXIudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OkltZyxcbiAgICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICAgIG9wYWNpdHk6MCxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ZGF0YS5mcm9tLmdldChbJ2ltZycsJ2NvdmVyJyxpbmRleCB8fCAwXSwnJylcbiAgICAgICAgICB9LFxuICAgICAgICAgICRvcHRpb25zOntcbiAgICAgICAgICAgIGZvcmNlOnRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faW5kZXggPSBpbmRleFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJGZvY3VzOntcbiAgICBkYXRhOidmb2N1cydcbiAgfSxcbiAgc3dpdGNoZXI6bmV3IFN3aXRjaGVyKHtcbiAgICBvblRyYW5zaXRpb246J2ZhZGUnLFxuICAgIC8vIGFkZDpuZXcgSW1nKHtcbiAgICAvLyAgICdiYWNrZ3JvdW5kLmRhdGEnOidpbWcuY292ZXIuMCdcbiAgICAvLyB9KSxcbiAgfSksLy93aWxsIHN3aXRjaCBiZXR3ZWVuIGltYWdlc1xuICBvdmVybGF5OntcbiAgICAnaGVhZGVyLnRleHQuZGF0YSc6J3RpdGxlJyxcbiAgICBiaW86e1xuICAgICAgJ2hlYWRlci50ZXh0JzonQmlvJyxcbiAgICAgICdib2R5LnRleHQuZGF0YSc6J2JpbydcbiAgICB9XG4gIH0sXG4gIG1vZGVsOntcbiAgICBzdWJzY3JpcHRpb246e1xuICAgICAgaW1nOntcbiAgICAgICAgY292ZXI6e1xuICAgICAgICAgICQ6dHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxudmFyIFdpZGdldCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL2luYWN0aXZlL3dpZGdldCcpXG52YXIgQ29udGVudCA9IHJlcXVpcmUoJy4uL2NvbnRlbnQnKVxudmFyIFRyYWlsZXIgPSByZXF1aXJlKCcuLi90cmFpbGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IENvbnRlbnQoe1xuICBjc3M6ICdzZWNvbmQtY2hhbm5lbCcsXG4gIGNvbnRhaW5lcjoge1xuICAgIGxlZnQ6IHtcbiAgICAgIHRyYWlsZXI6IG5ldyBUcmFpbGVyKHtcbiAgICAgICAgJ3ZpZGVvLnNyYy5kYXRhJzondmlkZW8nXG4gICAgICB9KVxuICAgIH0sXG4gICAgbWlkZGxlOntcbiAgICAgIGd1aWRlOiBuZXcgV2lkZ2V0Lkd1aWRlKClcbiAgICB9LFxuICAgIHJpZ2h0OiBuZXcgU3dpdGNoZXIoe1xuICAgICAgb25UcmFuc2l0aW9uOiBmdW5jdGlvbihjdXJyZW50LCBsYXN0KSB7XG4gICAgICAgIGlmKGxhc3QpIGxhc3QucmVtb3ZlKClcbiAgICAgICAgdGhpcy5hZGQoY3VycmVudClcbiAgICAgIH0sXG4gICAgICBtb2RlbDp7XG4gICAgICAgIHN1YnNjcmlwdGlvbjp7XG4gICAgICAgICAgZ3VpZGU6e1xuICAgICAgICAgICAgMDp7XG4gICAgICAgICAgICAgIHN0YXRpc3RpY3M6e1xuICAgICAgICAgICAgICAgIHRpdGxlOnRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsOmZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgIHZhciB3aWRnZXREYXRhID0gZGF0YS5ndWlkZSAmJiBkYXRhLmd1aWRlWzBdXG4gICAgICAgICAgaWYod2lkZ2V0RGF0YSl7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6IHdpZGdldERhdGEuc3RhdGlzdGljcyA/IFdpZGdldC5TdGF0cyA6IFdpZGdldC5BYm91dCxcbiAgICAgICAgICAgICAgJHBhcmFtczp7IGRhdGE6ZGF0YSB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbiAgfSxcbiAgJ2V4dGVuZC4kY29tcGxldGUnOmZ1bmN0aW9uKHZhbCl7XG4gICAgdmFyIGNvbXBsZXRlID0gdmFsLnZhbFxuICAgIGlmKGNvbXBsZXRlID09PSB0cnVlKXtcbiAgICAgIHRoaXMuY29udGFpbmVyLnNldCh7XG4gICAgICAgIGxlZnQ6e1xuICAgICAgICAgIHR3aXR0ZXI6IG5ldyBXaWRnZXQuVHdpdHRlcih7XG4gICAgICAgICAgICBkYXRhOnRoaXMuZGF0YVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfWVsc2UgaWYoY29tcGxldGUgPT09IGZhbHNlKXtcbiAgICAgIC8vIHRoaXMuY29udGFpbmVyLnNldCh7XG4gICAgICAvLyAgIGxlZnQ6e1xuICAgICAgLy8gICAgIHR3aXR0ZXI6IGZhbHNlXG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH0pXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBDb3ZlciA9IHJlcXVpcmUoJy4uL2NvdmVyJylcbnZhciBDaGFubmVsXG52YXIgVm9kXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY292ZXI6IG5ldyBDb3ZlcigpLFxuICAnZXh0ZW5kLiRhY3RpdmUnOiBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgYWN0aXZlID0gdmFsLnZhbFxuICAgIGlmIChhY3RpdmUgIT09IHZvaWQgMCkge1xuICAgICAgdmFyIGJnID0gdGhpcy5jb3Zlci5iZ1xuICAgICAgdmFyIGluZm8gPSB0aGlzLmluZm9cbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgaWYgKGJnLl9sb2FkZWQpIGJnLm9wYWNpdHkgPSBmYWxzZVxuICAgICAgICBiZy4kd2FpdCA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiZy4kd2FpdCA9IHRydWVcbiAgICAgICAgYmcub3BhY2l0eSA9IDBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICRhY3RpdmU6IHRydWVcbn0pLkNsYXNzXG5cbmV4cG9ydHMuc2VsZWN0ID0gZnVuY3Rpb24oZGF0YSwgdHlwZSkge1xuICBpZiAoIXR5cGUpIHR5cGUgPSBkYXRhLl9jb250ZW50VHlwZVxuXG4gIHJldHVybiB0eXBlID09PSAnY2hhbm5lbHMnID8ge1xuICAgIGVsZW1lbnQ6IENoYW5uZWwgPSBDaGFubmVsIHx8IHJlcXVpcmUoJy4uL2NoYW5uZWwnKSxcbiAgICAkcGFyYW1zOiB7fVxuICB9IDoge1xuICAgIGVsZW1lbnQ6IFZvZCA9IFZvZCB8fCByZXF1aXJlKCcuLi92b2QnKSxcbiAgICAkcGFyYW1zOiB7XG4gICAgICAkcG9wdXA6IGFwcC5wb3B1cFxuICAgIH1cbiAgfVxufVxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3NlY29uZC1jb3ZlcicsXG4gIGJnOm5ldyBJbWcoe1xuICAgIG9wYWNpdHk6MCxcbiAgICAkd2FpdDp0cnVlLFxuICAgIGJhY2tncm91bmQ6e1xuICAgICAgZGF0YTonaW1nLmNvdmVyLjAnLFxuICAgICAgYWRkOntcbiAgICAgICAgZGF0YTonc2hvdy5pbWcuY292ZXIuMCdcbiAgICAgIH1cbiAgICB9XG4gIH0pLFxuICBvdmVybGF5Ont9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxudmFyIHBvc3Rwb25lID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxudmFyIENvbnRlbnQgPSByZXF1aXJlKCcuLi9jb250ZW50JylcblxudmFyIF9wcmV2aWV3ID0gcG9zdHBvbmUoZnVuY3Rpb24oc3dpdGNoZXIsZm9jdXNJbmRleCkgeyAvL21vdmUgdGhpcyB0byBhcHAgY29udHJvbCBzdHVmZlxuICBpZihmb2N1c0luZGV4ICE9PSB2b2lkIDApe1xuICAgIHZhciBjbG91ZGRhdGEgPSBhcHAuY2xvdWQuZGF0YVxuICAgIHZhciBmb2N1c3JvdyA9IGFwcC51c2VyLmZvY3VzX3Jvdy52YWxcbiAgICB2YXIgZGF0YSA9IGNsb3VkZGF0YS5nZXQoWydkaXNjb3ZlcicsZm9jdXNyb3csJ2l0ZW1zJyxmb2N1c0luZGV4XSlcbiAgICBhcHAucHJldmlldy52YWwgPSBkYXRhXG4gICAgaWYoc3dpdGNoZXIuX3N3RWxlbSkgc3dpdGNoZXIuX3N3RWxlbS4kYWN0aXZlLnZhbCA9IHRydWVcbiAgfVxufSw0MDApXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFN3aXRjaGVyKHtcbiAgY3NzOiAnc2Vjb25kLWRpc2NvdmVyJyxcbiAgZXh0ZW5kOntcbiAgICAkaGlnaGxpZ2h0OmZ1bmN0aW9uKHZhbCl7XG4gICAgICB2YXIgaW5kZXggPSB2YWwudmFsXG4gICAgICB2YXIgbGFzdCA9IHRoaXMubGFzdFxuICAgICAgaWYoaW5kZXggIT09IGZhbHNlKXtcbiAgICAgICAgaWYoIXRoaXMuZnJvbUNvbnRlbnQpe1xuICAgICAgICAgIGlmKHRoaXMuX3N3RWxlbSkgdGhpcy5fc3dFbGVtLiRhY3RpdmUgPSBmYWxzZVxuICAgICAgICAgIF9wcmV2aWV3KHRoaXMsaW5kZXgpXG4gICAgICAgICAgdGhpcy5sYXN0ID0gdm9pZCAwXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHRoaXMuZnJvbUNvbnRlbnQgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICAkcHJldmlldzpmdW5jdGlvbih2YWwpe1xuICAgICAgdmFsID0gdmFsLnZhbFxuICAgICAgaWYodmFsKXtcbiAgICAgICAgdmFyIGRhdGEgPSB2YWwuZnJvbVxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IENvbnRlbnQuc2VsZWN0KGRhdGEpXG4gICAgICAgIHRyYW5zaXRpb24uJHBhcmFtcy5kYXRhID0gZGF0YVxuICAgICAgICB0cmFuc2l0aW9uLiRwYXJhbXMuJGNvbXBsZXRlID0gZmFsc2VcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvblxuICAgICAgfVxuICAgIH0sXG4gICAgJGNvbnRlbnQ6ZnVuY3Rpb24odmFsKXtcbiAgICAgIHZhbCA9IHZhbC52YWxcbiAgICAgIGlmKHZhbCl7XG4gICAgICAgIHZhciBkYXRhID0gdmFsLmZyb21cbiAgICAgICAgdmFyIHRyYW5zaXRpb24gPSBDb250ZW50LnNlbGVjdChkYXRhKVxuICAgICAgICB0cmFuc2l0aW9uLiRwYXJhbXMuZGF0YSA9IGRhdGFcbiAgICAgICAgdHJhbnNpdGlvbi4kcGFyYW1zLiRjb21wbGV0ZSA9IHRydWVcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gdHJhbnNpdGlvblxuICAgICAgICB0aGlzLmZyb21Db250ZW50ID0gdHJ1ZVxuICAgICAgICBhcHAucHJldmlldy52YWwgPSBkYXRhXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvblRyYW5zaXRpb246J2ZhZGUnXG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxuICAsIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxuICAsIERpc2NvdmVyID0gcmVxdWlyZSgnLi9kaXNjb3ZlcicpXG4gICwgU2VhcmNoID0gcmVxdWlyZSgnLi9zZWFyY2gnKVxuICAsIFN0YXR1c2JhciA9IHJlcXVpcmUoJy4vc3RhdHVzYmFyJylcbiAgLCBhcHAgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvYXBwJylcbiAgLCBOYXZpZ2F0aW9uID0gcmVxdWlyZSgnLi9uYXZpZ2F0aW9uJylcbiAgLCBQbGF5ZXIgPSByZXF1aXJlKCcuL3BsYXllcicpXG4gICwgQ29udGVudCA9IHJlcXVpcmUoJy4vY29udGVudCcpXG5cbi8vc2Vjb25kc2NyZWVuIHRvcGxldmVsXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczonc2Vjb25kLXN0YXRlJyxcbiAgeTp7dHJhbnNsYXRlOnRydWUsdmFsOjB9LFxuICBzd2l0Y2hlcjpuZXcgU3dpdGNoZXIoeyAvLyBzd2l0Y2hlcyBiZXR3ZWVuIG1haW4gYW5kIHNlYXJjaFxuICAgIG9uVHJhbnNpdGlvbjonZmFkZSdcbiAgfSksXG4gIG5hdmlnYXRpb246bmV3IE5hdmlnYXRpb24oKSxcbiAgc3RhdHVzYmFyOm5ldyBTdGF0dXNiYXIoKSxcbiAgc2VhcmNoOm5ldyBTZWFyY2goKSxcbiAgZXh0ZW5kOntcbiAgICAkaGlnaGxpZ2h0OmZ1bmN0aW9uKCB2YWwgKXt9LFxuICAgICRwcmV2aWV3OmZ1bmN0aW9uKCB2YWwgKXt9LFxuICAgICRwYWdlOmZ1bmN0aW9uKCB2YWwsIHN0YW1wICl7XG5cblxuICAgICAgaWYodGhpcy4kbWVkaWEudmFsIHx8ICFzdGFtcCkgcmV0dXJuXG4gICAgICB2YXIgcGFnZSA9IHZhbC52YWxcblxuICAgICAgYXBwLnVzZXIudHJhaWxlck11dGVkLiR1c2VyT3JpZ2luID0gdHJ1ZVxuICAgICAgYXBwLmhpZGVTdGF0dXNiYXIudmFsID0gZmFsc2VcbiAgICAgIFxuICAgICAgaWYoIHBhZ2UgPT09ICdkaXNjb3ZlcicgKXtcbiAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgIHk6MCxcbiAgICAgICAgICBzd2l0Y2hlcjp7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOntcbiAgICAgICAgICAgICAgZWxlbWVudDpEaXNjb3ZlcixcbiAgICAgICAgICAgICAgJHBhcmFtczp7XG4gICAgICAgICAgICAgICAgJHByZXZpZXc6dGhpcy4kcHJldmlldy5fdmFsLFxuICAgICAgICAgICAgICAgICRoaWdobGlnaHQ6dGhpcy4kaGlnaGxpZ2h0Ll92YWwsXG4gICAgICAgICAgICAgICAgJGNvbnRlbnQ6ZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbmF2aWdhdGlvbjp7XG4gICAgICAgICAgICBjb250YWluZXI6e1xuICAgICAgICAgICAgICB5OjBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9ZWxzZSBpZihwYWdlID09PSAnc2VhcmNoJyl7XG4gICAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgICB5OiAtYXBwLmgudmFsICsgODAsXG4gICAgICAgICAgc2VhcmNoOntcbiAgICAgICAgICAgICRzZWFyY2g6YXBwLnVzZXIuc2VhcmNoLFxuICAgICAgICAgICAgJG11dGVkOmFwcC51c2VyLnRyYWlsZXJNdXRlZCxcbiAgICAgICAgICAgIGRhdGE6YXBwLmNsb3VkLmRhdGFcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICB9LFxuICAgICRjb250ZW50OmZ1bmN0aW9uKCB2YWwsc3RhbXAgKXtcblxuICAgICAgLy8gaWYodGhpcy4kbWVkaWEudmFsIHx8ICFzdGFtcCkgcmV0dXJuXG4gICAgICAvLyB2YXIgZGF0YSA9IHZhbC5mcm9tXG4gICAgICBpZih0aGlzLiRtZWRpYS52YWwgfHwgIXN0YW1wKSByZXR1cm5cblxuICAgICAgYXBwLmhpZGVTdGF0dXNiYXIudmFsID0gZmFsc2VcblxuICAgICAgdGhpcy5zZXQoe1xuICAgICAgICB5OjAsXG4gICAgICAgIHN3aXRjaGVyOntcbiAgICAgICAgICB0cmFuc2l0aW9uOiB7XG4gICAgICAgICAgICBlbGVtZW50OkRpc2NvdmVyLFxuICAgICAgICAgICAgJHBhcmFtczp7XG4gICAgICAgICAgICAgICRwcmV2aWV3OmZhbHNlLFxuICAgICAgICAgICAgICAkaGlnaGxpZ2h0OmZhbHNlLFxuICAgICAgICAgICAgICAkY29udGVudDp2YWxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5hdmlnYXRpb246e1xuICAgICAgICAgIGNvbnRhaW5lcjp7XG4gICAgICAgICAgICB5OjQyMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgICRtZWRpYTpmdW5jdGlvbiggdmFsLCBzdGFtcCApe1xuICAgICAgaWYodmFsLnZhbCl7XG4gICAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgICB5OjAsXG4gICAgICAgICAgc3dpdGNoZXI6e1xuICAgICAgICAgICAgdHJhbnNpdGlvbjp7XG4gICAgICAgICAgICAgIGVsZW1lbnQ6UGxheWVyLFxuICAgICAgICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICAgICAgICBvdmVybGF5OntcbiAgICAgICAgICAgICAgICAgICR2b2x1bWU6YXBwLnZvbHVtZSxcbiAgICAgICAgICAgICAgICAgICR0aW1lOnZhbC52YWwuZ2V0KCd0aW1lJylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBsYXlpbmc6YXBwLmlzUGxheWluZyxcbiAgICAgICAgICAgICAgICBkYXRhOnZhbC4kdXNlck9yaWdpbixcbiAgICAgICAgICAgICAgICB2aWRlbzoge1xuICAgICAgICAgICAgICAgICAgdm9sdW1lOiBhcHAudm9sdW1lXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXZpZ2F0aW9uOntcbiAgICAgICAgICAgIGNvbnRhaW5lcjp7XG4gICAgICAgICAgICAgIHk6NDYwICsgODBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9ZWxzZXtcbiAgICAgICAgYXBwLnVzZXIudXBkYXRlTmF2aWdhdGlvbigpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzZXRTZXR0aW5nOntcbiAgICBuYW1lOid1cGRhdGVOYXYnLFxuICAgIHBhcmVudDpmdW5jdGlvbigpe1xuICAgICAgYXBwLnVzZXIudXBkYXRlTmF2aWdhdGlvbigpXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBMaXN0ID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QnKVxudmFyIHBvc3Rwb25lID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBQcm9ncmVzcyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL2luYWN0aXZlL3Byb2dyZXNzJylcblxudmFyIHlFbGVtZW50ID0gbmV3IEVsZW1lbnQoe1xuICB5OiB7XG4gICAgdHJhbnNsYXRlOiB0cnVlLFxuICAgIHZhbDo0MjBcbiAgfVxufSkuQ2xhc3NcblxudmFyIHRpdGxlRWxlbWVudCA9IG5ldyB5RWxlbWVudCh7XG4gICd0ZXh0LmRhdGEnOiAndGl0bGUnXG59KS5DbGFzc1xuXG52YXIgbWFwID0ge1xuICBzcG90bGlnaHQ6IHtcbiAgICBpbmRleDogMCxcbiAgICBsaXN0OiBMaXN0LldhdGNoaW5nXG4gIH0sXG4gIGNoYW5uZWxzOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGlzdDogTGlzdC5DaGFubmVsXG4gIH0sXG4gIHdhdGNoaW5nOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGlzdDogTGlzdC5XYXRjaGluZ1xuICB9LFxuICByZWxlYXNlczoge1xuICAgIGluZGV4OiAzLFxuICAgIGxpc3Q6IExpc3QuUG9zdGVyXG4gIH0sXG4gIHJlY29tbWVuZGVkOiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGlzdDogTGlzdC5Qb3N0ZXJcbiAgfVxufVxuXG52YXIgc3dpdGNoRm9jdXMgPSBmdW5jdGlvbihfdGhpcywgaW5kZXgsIGZvY3VzZWQsIHR5cGUpIHtcbiAgdmFyIGRpcmVjdGlvbiA9IGluZGV4ID4gX3RoaXMuaW5kZXggPyAtMSA6IDFcbiAgICAvL3N3aXRjaCB0aGUgdGl0bGVcblxuICBfdGhpcy5jb250YWluZXIuc2V0KHtcbiAgICBiYXI6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgICBlbGVtZW50OiB0aXRsZUVsZW1lbnQsXG4gICAgICAgICAgZGlyZWN0aW9uOiBkaXJlY3Rpb24sXG4gICAgICAgICAgJHBhcmFtczoge1xuICAgICAgICAgICAgZGF0YTogZm9jdXNlZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIHVwOiB7XG4gICAgICAgICAgb3BhY2l0eTppbmRleCA9PT0gMCA/IDAuNSA6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZG93bjoge1xuICAgICAgICAgIG9wYWNpdHk6aW5kZXggPT09IDQgPyAwLjUgOiAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgX3RoaXMuaW5kZXggPSBpbmRleFxuXG4gIGxpc3RGb2N1cyhfdGhpcywgaW5kZXgsIGZvY3VzZWQsIHR5cGUsIGRpcmVjdGlvbilcbn1cblxudmFyIGxpc3RGb2N1cyA9IHBvc3Rwb25lKGZ1bmN0aW9uKF90aGlzLCBpbmRleCwgZm9jdXNlZCwgdHlwZSwgZGlyZWN0aW9uKSB7XG4gIHZhciBsaXN0cyA9IF90aGlzLmNvbnRhaW5lci5saXN0c1xuICB2YXIgZm9jdXNJdGVtID0gYXBwLnVzZXJbJ2ZvY3VzXycgKyB0eXBlXVxuXG4gIGlmKGxpc3RzKXtcbiAgICBsaXN0cy50cmFuc2l0aW9uID0ge1xuICAgICAgZWxlbWVudDogbWFwW3R5cGVdLmxpc3QsXG4gICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICRwYXJhbXM6IHtcbiAgICAgICAgZGF0YTogZm9jdXNlZCxcbiAgICAgICAgJGZvY3VzOiBhcHAuaGlnaGxpZ2h0LnZhbCA9IGZvY3VzSXRlbVxuICAgICAgfSxcbiAgICAgICRvcHRpb25zOiB7XG4gICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59LCAyMDApXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICdzZWNvbmQtbmF2aWdhdGlvbicsXG4gIGNvbnRhaW5lcjogbmV3IHlFbGVtZW50KHtcbiAgICBwcm9ncmVzczogbmV3IFByb2dyZXNzKHtcbiAgICAgIHBlcmNlbnRhZ2U6e1xuICAgICAgICB0ZXh0OntcbiAgICAgICAgICB2YWw6e1xuICAgICAgICAgICAgcGFyZW50OidvbicsXG4gICAgICAgICAgICBhbmltYXRpb246e1xuICAgICAgICAgICAgICBlYXNpbmc6J291dEN1YmljJyxcbiAgICAgICAgICAgICAgdGltZToxOFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgICAgICAgcmV0dXJuIH5+Y3YgKyAnJSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtb2RlbDp7XG4gICAgICAgIGNvbXBsZXRlOmZ1bmN0aW9uKGRhdGEpe1xuICAgICAgICAgIHRoaXMub24udXBkYXRlKHRoaXMpXG4gICAgICAgIH0sXG4gICAgICAgIGluaGVyaXQ6ZmFsc2VcbiAgICAgIH0sXG4gICAgICBvbjp7XG4gICAgICAgIGRhdGE6J3RpbWUnLFxuICAgICAgICBkZWZlcjpmdW5jdGlvbih1cGRhdGUpe1xuICAgICAgICAgIGlmKH5+dGhpcy5mcm9tLnZhbCl7XG4gICAgICAgICAgICB0aGlzLl9jYWxsZXIub3BhY2l0eSA9IDFcbiAgICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0aGlzLl9jYWxsZXIub3BhY2l0eSA9IDBcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtdWx0aXBseToxMDBcbiAgICAgIH1cbiAgICB9KSxcbiAgICBiYXI6IHtcbiAgICAgIHRpdGxlOiBuZXcgU3dpdGNoZXIoe1xuICAgICAgICBvblRyYW5zaXRpb246IGZ1bmN0aW9uKGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbikge1xuICAgICAgICAgIF90cmFuc2l0aW9uKHRoaXMsIDQwLCBjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24pXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgYXJyb3dzOiB7XG4gICAgICAgIHVwOm5ldyBJY29uKHtcbiAgICAgICAgICBpY29uOid1cE5hdicsXG4gICAgICAgICAgb3BhY2l0eTowLjFcbiAgICAgICAgfSksXG4gICAgICAgIGRvd246IG5ldyBJY29uKHtcbiAgICAgICAgICBpY29uOidkb3duTmF2J1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgbGlzdHM6IG5ldyBTd2l0Y2hlcih7XG4gICAgICBvblRyYW5zaXRpb246IGZ1bmN0aW9uKGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbikge1xuICAgICAgICBfdHJhbnNpdGlvbih0aGlzLCA0MDAsIGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbilcbiAgICAgIH1cbiAgICB9KVxuICB9KSxcbiAgJ21vZGVsLnN1YnNjcmlwdGlvbi4kLiQnOiB0cnVlLFxuICBleHRlbmQ6e1xuICAgICRmb2N1czogZnVuY3Rpb24odmFsKSB7IC8vdmFsID09PSAnc3BvdGxpZ2h0Jy8ncmVjb21tZW5kZWQnIGV0Y1xuICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFcbiAgICAgIGlmKCFkYXRhKSByZXR1cm5cbiAgICAgIFxuICAgICAgaWYoIWRhdGEuJGxlbmd0aC52YWwpIHtcbiAgICAgICAgZGF0YS4kbGVuZ3RoLm9uY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgX3RoaXMuJGZvY3VzLnVwZGF0ZSgpXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB2YXIgZm9jdXNlZCA9IGRhdGFbdmFsLnZhbF1cbiAgICAgIGlmKGZvY3VzZWQpIHtcbiAgICAgICAgc3dpdGNoRm9jdXMoX3RoaXMsIG1hcFt2YWwudmFsXS5pbmRleCwgZm9jdXNlZCwgdmFsLnZhbClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNldFNldHRpbmc6IHtcbiAgICBuYW1lOiAncHJlcFZhbHVlcycsXG4gICAgcGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIGZvcih2YXIgdHlwZSBpbiBtYXApIHtcbiAgICAgICAgdmFyIGZpZWxkID0gJ2ZvY3VzXycgKyB0eXBlXG4gICAgICAgIGlmKCFhcHAudXNlcltmaWVsZF0pIHtcbiAgICAgICAgICB2YXIgb2JqID0ge31cbiAgICAgICAgICBvYmpbZmllbGRdID0gMFxuICAgICAgICAgIGFwcC51c2VyLnNldChvYmopXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbmZ1bmN0aW9uIF90cmFuc2l0aW9uKF90aGlzLCBkZWx0YSwgY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uKSB7XG4gIGlmKGxhc3QpIHtcbiAgICBsYXN0LnkgPSBkZWx0YSAqIGRpcmVjdGlvbiAvLyBzaG91bGQgc3RpbGwgcmVtb3ZlXG4gICAgY3VycmVudC55ID0gZGVsdGEgKiAtZGlyZWN0aW9uXG4gIH1cbiAgX3RoaXMuYWRkKGN1cnJlbnQpXG4gIGlmKF90aGlzLl90aW1lcikge1xuICAgIGNsZWFyVGltZW91dChfdGhpcy5fdGltZXIpXG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbFxuICB9XG4gIF90aGlzLl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgX3RoaXMuX3RpbWVyID0gbnVsbFxuICAgIGRvaXQoKVxuICB9LCA1MClcblxuICBmdW5jdGlvbiBkb2l0KCl7XG4gICAgaWYoIWN1cnJlbnQuX2Jsb2NrZWQpIGN1cnJlbnQueSA9IDBcbiAgICBlbHNlIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9pdClcbiAgfVxufVxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicpXG52YXIgVmlkZW8gPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvJylcbnZhciBQcm9ncmVzcyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL2luYWN0aXZlL3Byb2dyZXNzJylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nJylcbnZhciBwb3N0cG9uZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy91dGlsJykucG9zdHBvbmVcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxuXG52YXIgZmFkZUljb24gPSBwb3N0cG9uZShmdW5jdGlvbihfdGhpcywgZm9yY2Upe1xuICB2YXIgaWNvbiA9IF90aGlzLl9zd0VsZW0gJiYgX3RoaXMuX3N3RWxlbS5pY29uXG4gIGlmKGljb24pe1xuICAgIGljb24uY3NzID0gJ3VpLWljb24gZmFkZS1vdXQnXG4gICAgaWNvbi5vcGFjaXR5ID0gMFxuICB9XG59LDEwMDApXG5cbnZhciBmYWRlT3ZlcmxheSA9IHBvc3Rwb25lKGZ1bmN0aW9uKF90aGlzLCBmb3JjZSl7XG4gIGlmKGFwcC5pc1BsYXlpbmcudmFsKSBfdGhpcy5vcGFjaXR5ID0gMFxuICBlbHNlIHVwZGF0ZVBsYXkoX3RoaXMpXG59LDEwMDApXG5cbnZhciB1cGRhdGVQbGF5ID0gcG9zdHBvbmUoZnVuY3Rpb24oX3RoaXMpe1xuICBhcHAuaGlkZVN0YXR1c2Jhci52YWwgPSBmYWxzZVxuICBpZihfdGhpcy4kcGxheWluZykgX3RoaXMuJHBsYXlpbmcudXBkYXRlKClcbn0sMTAwMClcblxudmFyIE92ZXJsYXkgPSBuZXcgRWxlbWVudCh7XG4gIGNzczoncGxheWVyLW92ZXJsYXknLFxuICBvcGFjaXR5OjAsXG4gIGluZm86e1xuICAgIHBvc3RlcjpuZXcgSW1nKHsnYmFja2dyb3VuZC5kYXRhJzonaW1nLnBvc3Rlcid9KSxcbiAgICB0aXRsZXM6e1xuICAgICAgJ25vd3BsYXlpbmcudGV4dCc6J05vdyBQbGF5aW5nJyxcbiAgICAgICd0aXRsZS50ZXh0LmRhdGEnOid0aXRsZScsXG4gICAgICAnc3VidGl0bGUudGV4dC5kYXRhJzonc3VidGl0bGUnXG4gICAgfVxuICB9LFxuICBpY29uOm5ldyBJY29uKHtcbiAgICBvcGFjaXR5OjAsXG4gICAgaWNvbjp7XG4gICAgICB2YWw6J3BsYXknLFxuICAgICAgJGlzUGxheWluZzoncGF1c2UnXG4gICAgfVxuICB9KSxcbiAgbmV4dDp7fVxufSkuQ2xhc3NcblxudmFyIEJhck92ZXJsYXkgPSBuZXcgRWxlbWVudCh7XG4gIG9wYWNpdHk6MCxcbiAgY29udGFpbmVyOntcbiAgICB0eHQ6e30sXG4gICAgcHJvZ3Jlc3M6bmV3IFByb2dyZXNzKClcbiAgfSxcbiAgJ2V4dGVuZC4kdmFsdWUnOmZ1bmN0aW9uKHZhbCl7XG4gICAgdGhpcy5jb250YWluZXIuc2V0KHsgLy9jaGFuZ2UgdGhpcyBmb3IgZGF0YVxuICAgICAgdHh0OntcbiAgICAgICAgdmFsdWU6e1xuICAgICAgICAgIHRleHQ6dmFsLnZhbFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcHJvZ3Jlc3M6e1xuICAgICAgICBvbjp2YWwudmFsICAgIFxuICAgICAgfVxuICAgIH0pXG4gIH1cbn0pLkNsYXNzXG5cbnZhciBTZWVrT3ZlcmxheSA9IG5ldyBCYXJPdmVybGF5KHtcbiAgY3NzOidzZWVrLW92ZXJsYXknLFxuICAnY29udGFpbmVyLnR4dCc6e1xuICAgIHRleHQ6J1NFRUtJTkcgJyxcbiAgICAndmFsdWUudGV4dCc6e1xuICAgICAgZGF0YTondGltZScsXG4gICAgICBtdWx0aXBseTo0NTAwLC8ve2RhdGE6J2R1cmF0aW9uJ30sXG4gICAgICAkY29udmVydFRpbWU6dHJ1ZSwvL3tkYXRhOidkdXJhdGlvbid9LFxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxudmFyIFZvbHVtZU92ZXJsYXkgPSBuZXcgQmFyT3ZlcmxheSh7XG4gIGNzczondm9sdW1lLW92ZXJsYXknLFxuICAnY29udGFpbmVyLnR4dCc6e1xuICAgIHRleHQ6J1ZPTFVNRSAnLFxuICAgICd2YWx1ZS50ZXh0Jzp7XG4gICAgICB2YWw6MCxcbiAgICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoIGN2ICogMTAwIHx8IDAgKSArICclJ1xuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxudmFyIE92ZXJsYXlTd2l0Y2hlciA9IG5ldyBTd2l0Y2hlcih7XG4gIGV4dGVuZDp7XG4gICAgJHBsYXlpbmc6ZnVuY3Rpb24odmFsKXtcbiAgICAgIHRoaXMub3BhY2l0eSA9IDFcbiAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgZWxlbWVudDpPdmVybGF5LFxuICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICBkYXRhOnRoaXMucGFyZW50LmRhdGEsXG4gICAgICAgICAgaWNvbjp7XG4gICAgICAgICAgICBjc3M6J3VpLWljb24gZmFkZS1pbicsXG4gICAgICAgICAgICBvcGFjaXR5OjEsXG4gICAgICAgICAgICBjbGVhcjp0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiggYXBwLmlzUGxheWluZy52YWwgKSBmYWRlT3ZlcmxheSggdGhpcyApXG4gICAgICBmYWRlSWNvbiggdGhpcyApXG4gICAgfSxcbiAgICAkdGltZTpmdW5jdGlvbih2YWwpe1xuICAgICAgaWYoYXJndW1lbnRzWzJdPT09dm9pZCAwIHx8IHZhbC52YWwgPCAwIHx8IGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLl9jb250ZW50VHlwZSA9PT0gJ2NoYW5uZWxzJykgcmV0dXJuXG4gICAgICB0aGlzLm9wYWNpdHkgPSAxXG4gICAgICB0aGlzLnRyYW5zaXRpb24gPSB7XG4gICAgICAgIGVsZW1lbnQ6U2Vla092ZXJsYXksXG4gICAgICAgICRwYXJhbXM6e1xuICAgICAgICAgICR2YWx1ZTp2YWwudmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcC5oaWRlU3RhdHVzYmFyLnZhbCA9IHRydWVcblxuICAgICAgaWYoIGFwcC5pc1BsYXlpbmcudmFsICkge1xuICAgICAgICBmYWRlT3ZlcmxheSggdGhpcyApXG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHVwZGF0ZVBsYXkodGhpcylcbiAgICAgIH1cblxuICAgIH0sXG4gICAgJHZvbHVtZTpmdW5jdGlvbih2YWwpe1xuICAgICAgaWYoYXJndW1lbnRzWzJdPT09dm9pZCAwKSByZXR1cm5cbiAgICAgIHRoaXMub3BhY2l0eSA9IDFcbiAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgZWxlbWVudDpWb2x1bWVPdmVybGF5LFxuICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICAkdmFsdWU6dmFsLnZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHAuaGlkZVN0YXR1c2Jhci52YWwgPSB0cnVlXG4gICAgICBpZiggYXBwLmlzUGxheWluZy52YWwgKSBmYWRlT3ZlcmxheSggdGhpcyApXG4gICAgICBlbHNlIHVwZGF0ZVBsYXkodGhpcylcbiAgICB9XG4gIH0sXG4gIG9uVHJhbnNpdGlvbjpmdW5jdGlvbihjdXJyZW50LGxhc3Qpe1xuICAgIGlmKGxhc3Qpe1xuICAgICAgbGFzdC5zZXQoe1xuICAgICAgICBvcGFjaXR5OjAsXG4gICAgICAgICR0aW1lb3V0OntcbiAgICAgICAgICAyMDA6ZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxhc3QucmVtb3ZlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGN1cnJlbnQuJHRpbWVvdXQgPSB7XG4gICAgICA1MDpmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRkKGN1cnJlbnQpXG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3NlY29uZC1wbGF5ZXInLFxuICB2aWRlbzpuZXcgVmlkZW8oe1xuICAgIHBsYXllcjogcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlby9odG1sNScpLFxuICAgIGR1cmF0aW9uOntkYXRhOidkdXJhdGlvbid9LFxuICAgIHRpbWU6IHtkYXRhOid0aW1lJ30sXG4gICAgc3JjOiB7IHByZXBlbmQ6Y29uZmlnLnBvaW50ZXJzLmFzc2V0cywgZGF0YTondmlkZW8nfSxcbiAgICBldmVudHM6e1xuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy5kYXRhLmZyb20uc2V0KCd0aW1lJywgLU1hdGguYWJzKHApKVxuICAgICAgfVxuICAgIH1cbiAgfSksXG4gIG92ZXJsYXk6bmV3IE92ZXJsYXlTd2l0Y2hlcigpLFxuICBleHRlbmQ6e1xuICAgIHBsYXlpbmc6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy5vdmVybGF5LiRwbGF5aW5nID0gdmFsXG4gICAgICB0aGlzLnZpZGVvLiRwbGF5aW5nID0gdmFsXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG5cdGNzczonc2Vjb25kLXByb2dyZXNzJyxcbiAgb246e1xuICAgIGRhdGE6J3RpbWUnLFxuICBcdGFiczp0cnVlLFxuICAgIG11bHRpcGx5OjEwMFxuICB9LFxuICBkaXNwbGF5OntcbiAgICB2YWw6YXBwLnByZXZpZXcsXG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgdmFyIHBvcHVwID0gYXBwLnBvcHVwLnZhbFxuICAgICAgcmV0dXJuIChjdiAmJiBjdi5fY29udGVudFR5cGUgPT09ICdjaGFubmVscycpIHx8IChwb3B1cCAmJiB0eXBlb2YgcG9wdXAgIT09ICdzdHJpbmcnKSA/ICdub25lJyA6ICdibG9jaydcbiAgICB9LFxuICAgIGxpc3RlbjphcHAucG9wdXBcbiAgfSxcbiAgdzp7XG4gICAgc2VsZjonb24nLFxuICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIHJldHVybiBNYXRoLm1heCh+fmN2LDMpICsgJyUnXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIFRyYWlsZXIgPSByZXF1aXJlKCcuLi90cmFpbGVyJylcbnZhciBzZWFyY2ggPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2VhcmNoJylcbnZhciB3aGVuID0gcmVxdWlyZSgncHJvbWlzZScpLmFsbFxudmFyIFN1YnRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3VidGl0bGUnKVxuXG52YXIgTm9SZXN1bHRzID0gbmV3IEVsZW1lbnQoe1xuICBjb250YWluZXI6e1xuICAgICd0aXRsZS50ZXh0JzonTm8gUmVzdWx0cyEnLFxuICAgICdzdWJ0aXRsZS50ZXh0JzonUGxlYXNlIHRyeSB0byByZWZpbmUgeW91ciBxdWVyeSdcbiAgfVxufSkuQ2xhc3NcblxudmFyIFN0YXJ0U2VhcmNoaW5nID0gbmV3IEVsZW1lbnQoe1xuICBjb250YWluZXI6e1xuICAgICd0aXRsZS50ZXh0JzonU3RhcnQgU2VhcmNoaW5nIScsXG4gICAgJ3N1YnRpdGxlLnRleHQnOidGaW5kIHlvdXIgZmF2b3JpdGUgbW92aWVzLCBzaG93cyBhbmQgY2hhbm5lbHMnXG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICdzZWNvbmQtc2VhcmNoJyxcbiAgZXh0ZW5kOntcbiAgICAkc2VhcmNoOmZ1bmN0aW9uKCB2YWwgKXtcbiAgXHQgIHZhciBfdGhpcyA9IHRoaXNcbiAgICBcdHZhciByZXN1bHRzID0gdGhpcy5yZXN1bHRzXG4gICAgXHR2YXIgY2hpbGRyZW4gPSByZXN1bHRzLmxpc3QuY2hpbGRyZW5cbiAgICBcdHZhciBxdWVyeSA9IHNlYXJjaC5wYXJzZVNlYXJjaCggdmFsLnZhbCApXG4gICAgXHR2YXIgY29udGVudCA9IGFwcC5jb250ZW50XG5cbiAgICBcdHRoaXMuc2VhcmNoYm94LnF1ZXJ5LnRleHQgPSBxdWVyeVxuXG4gICAgXHRpZihxdWVyeSAhPT0gZmFsc2Upe1xuICAgIFx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBcdFx0XHRzZWFyY2guZmlsdGVyQ29sbGVjdGlvbiggY2hpbGRyZW5baV0sIHF1ZXJ5IClcbiAgICBcdFx0fVxuICAgIFx0fVxuXG4gICAgICBpZihxdWVyeSl7XG4gICAgICAgIGZ1bmN0aW9uIGxvYWRlZCgpe1xuICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5rZXlzXG4gICAgICAgICAgdmFyIGZyb20gPSB0aGlzLmZyb21cbiAgICAgICAgICByZXR1cm4ga2V5cyAmJiBrZXlzLmxlbmd0aCA+IDJcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGRvbmUoKXtcbiAgICAgICAgICBmb3IgKHZhciBqID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2pdXG4gICAgICAgICAgICBjaGlsZC5kaXNwbGF5ID0gY2hpbGQuZmlsdGVyLmxlbmd0aCA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHRvcFJlc3VsdCA9IHNlYXJjaC50b3BSZXN1bHQoIGNoaWxkcmVuIClcbiAgICAgICAgICBpZiggdG9wUmVzdWx0ICl7XG4gICAgICAgICAgICByZXN1bHRzLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICByZXN1bHRzLnRvcHJlc3VsdC5kYXRhID0gdG9wUmVzdWx0XG4gICAgICAgICAgICBpZihfdGhpcy5tZXNzYWdlKXtcbiAgICAgICAgICAgICAgX3RoaXMubWVzc2FnZS5yZW1vdmUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgcmVzdWx0cy5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICBfdGhpcy5zZXQoe1xuICAgICAgICAgICAgICBtZXNzYWdlOm5ldyBOb1Jlc3VsdHMoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB3aGVuKFtcbiAgICAgICAgICBjb250ZW50LmdldCgnbW92aWVzJykuaXMobG9hZGVkKSxcbiAgICAgICAgICBjb250ZW50LmdldCgnYWN0b3JzJykuaXMobG9hZGVkKSxcbiAgICAgICAgICBjb250ZW50LmdldCgnc2VyaWVzJykuaXMobG9hZGVkKSxcbiAgICAgICAgICBjb250ZW50LmdldCgnY2hhbm5lbHMnKS5pcyhsb2FkZWQpXG4gICAgICAgIF0pLmRvbmUoZG9uZSlcbiAgICAgIH1lbHNle1xuICAgICAgICByZXN1bHRzLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgIG1lc3NhZ2U6bmV3IFN0YXJ0U2VhcmNoaW5nKClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgIH0sXG4gICAgJG11dGVkOmZ1bmN0aW9uKHZhbCl7XG4gICAgICB0aGlzLnJlc3VsdHMudG9wcmVzdWx0LmJvZHkuY29udGFpbmVyLnRyYWlsZXIuJG11dGVkID0gdmFsLnZhbFxuICAgIH1cbiAgfSxcbiAgc2VhcmNoYm94OntcbiAgXHRzZWFyY2hpY29uOm5ldyBJY29uKHtcbiAgXHRcdGljb246J3NlYXJjaCdcbiAgXHR9KSxcbiAgXHQncXVlcnkudGV4dCc6JydcbiAgfSxcbiAgcmVzdWx0czp7XG4gIFx0bGlzdDpuZXcgc2VhcmNoLlJlc3VsdExpc3QoKSxcbiAgXHR0b3ByZXN1bHQ6e1xuICBcdFx0bW9kZWw6e2luaGVyaXQ6ZmFsc2V9LFxuICBcdFx0aGVhZGVyOntcbiAgXHRcdFx0dGV4dDp7XG4gIFx0XHRcdFx0Ly8gZGF0YTondGl0bGUnLFxuICBcdFx0XHRcdHByZXBlbmQ6J1RvcCBSZXN1bHQnLy8gLSAnXG4gIFx0XHRcdH1cbiAgXHRcdH0sXG4gIFx0XHRib2R5OntcbiAgXHRcdFx0Y29udGFpbmVyOntcbiAgXHRcdFx0XHR0cmFpbGVyOm5ldyBUcmFpbGVyKCksXG4gIFx0XHRcdFx0aW5mbzp7XG4gIFx0XHRcdFx0XHQndGl0bGUudGV4dC5kYXRhJzondGl0bGUnLFxuICAgICAgICAgICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKClcbiAgXHRcdFx0XHR9XG4gIFx0XHRcdH0sXG4gIFx0XHRcdCdkZXNjcmlwdGlvbi50ZXh0LmRhdGEnOidkZXNjcmlwdGlvbidcbiAgXHRcdH1cbiAgXHR9XG4gIH1cbn0pLkNsYXNzXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFwcC5jYXNlcy4kaXNUYWJsZXQgXG4/IG5ldyBFbGVtZW50KHtcbiAgICBjc3M6J3NlY29uZC1zdGF0dXNiYXIgYnJhbmRlZCcsXG4gICAgeTp7XG4gICAgICB0cmFuc2xhdGU6dHJ1ZSxcbiAgICAgIHZhbDo4MCxcbiAgICAgIG11bHRpcGx5OmFwcC5oaWRlU3RhdHVzYmFyXG4gICAgfSxcbiAgICBwYXJ0bmVyOntcbiAgICAgIGxvZ286e31cbiAgICB9LFxuICAgIHdlYXRoZXI6e1xuICAgICAgYWRkOm5ldyBJY29uKHtpY29uOid3ZWF0aGVyJ30pLFxuICAgICAgdGV4dDonUGFydGlhbGx5IENsb3VkZWQnXG4gICAgfSxcbiAgICBldGE6e1xuICAgICAgYWRkOm5ldyBJY29uKHtpY29uOidhaXJwbGFuZSd9KSxcbiAgICAgIHRleHQ6J1RpbWUgdG8gTG9zIEFuZ2VsZXM6IDZocidcbiAgICB9LFxuICAgIGJldHdlZW46e30sXG4gICAgZGlyZWN0djp7XG4gICAgICBsb2dvOnt9XG4gICAgfVxuICB9KS5DbGFzc1xuOiBuZXcgRWxlbWVudCh7XG4gICAgY3NzOidzZWNvbmQtc3RhdHVzYmFyJyxcbiAgICB5OntcbiAgICBcdHRyYW5zbGF0ZTp0cnVlLFxuICAgICAgdmFsOjgwLFxuICAgICAgbXVsdGlwbHk6YXBwLmhpZGVTdGF0dXNiYXJcbiAgICB9LFxuICAgIGRpcmVjdHY6e1xuICAgICAgbG9nbzp7fVxuICAgIH0sXG4gICAgc2VuZGVyOntcbiAgICAgIGljb246bmV3IEljb24oe2ljb246J3Bob25lJ30pLFxuICAgICAgdGl0bGU6e3RleHQ6J2NvbnRyb2xsZWQgYnkgaVBob25lJ31cbiAgICB9XG4gIH0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIFZpZGVvID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlbycpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIEFTU0VUUyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpLnBvaW50ZXJzLmFzc2V0c1xudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgTXV0ZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL211dGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnc2Vjb25kLXRyYWlsZXInLFxuICAnZXh0ZW5kLiRtdXRlZCc6ZnVuY3Rpb24oKXt9LFxuICAkbXV0ZWQ6dHJ1ZSxcbiAgdmlkZW86bmV3IFZpZGVvKHtcbiAgICBwbGF5ZXI6IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8vaHRtbDUnKSxcbiAgICBzcmM6e1xuICAgICAgZGF0YTogJ3RyYWlsZXInLFxuICAgICAgcHJlcGVuZDogQVNTRVRTXG4gICAgfSxcbiAgICBkdXJhdGlvbjogdHJ1ZSxcbiAgICB2b2x1bWU6e1xuICAgICAgcGFyZW50OickbXV0ZWQnLFxuICAgICAgbXVsdGlwbHk6LTEsXG4gICAgICBhZGQ6MVxuICAgIH0sXG4gICAgbG9vcDogdHJ1ZSxcbiAgICBhdXRvcGxheTogdHJ1ZVxuICB9KSxcbiAgbG9nbzpuZXcgSW1nKHtcbiAgICAnYmFja2dyb3VuZC5kYXRhJzonaW1nLmxvZ28nXG4gIH0pLFxuICBtdXRlZDpuZXcgTXV0ZSh7XG4gICAgaWNvbjp7XG4gICAgICBwYXJlbnQ6JyRtdXRlZCdcbiAgICB9XG4gIH0pXG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxudmFyIEl0ZW0gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2l0ZW0nKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgQ29udGVudCA9IHJlcXVpcmUoJy4uL2NvbnRlbnQnKVxudmFyIFN1YnRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3VidGl0bGUnKVxudmFyIFRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvdGl0bGUnKVxudmFyIEJpbyA9IHJlcXVpcmUoJy4uL2JpbycpXG5cbnZhciBPdmVydmlldyA9IG5ldyBDb250ZW50KHtcbiAgY3NzOidvdmVydmlldycsXG4gIGNvbnRhaW5lcjp7XG4gICAgdG9wOiB7XG4gICAgICAnbGVmdC5wb3N0ZXInOm5ldyBJdGVtLlBvc3Rlcih7XG4gICAgICAgICdpbWcuYmFja2dyb3VuZCc6e1xuICAgICAgICAgIGFkZDp7XG4gICAgICAgICAgICBkYXRhOidzaG93LmltZy5wb3N0ZXInXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSksXG4gICAgICByaWdodDoge1xuICAgICAgICB0aXRsZTpuZXcgVGl0bGUoKSxcbiAgICAgICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKClcbiAgICAgIH1cbiAgICB9LFxuICAgICdkZXNjcmlwdGlvbi50ZXh0LmRhdGEnOiAnZGVzY3JpcHRpb24nLFxuICAgIHN0YXJyaW5nOiB7XG4gICAgICBkaXNwbGF5OntcbiAgICAgICAgdmFsOidibG9jaycsXG4gICAgICAgIHdoZW46e2RhdGE6J2FjdG9ycyd9LFxuICAgICAgICBvcjonbm9uZSdcbiAgICAgIH0sXG4gICAgICAnaGVhZGVyLnRleHQnOiAnU3RhcnJpbmcnLFxuICAgICAgJ2FjdG9ycy5jb2xsZWN0aW9uJzoge1xuICAgICAgICBkYXRhOiAnYWN0b3JzJyxcbiAgICAgICAgZWxlbWVudDogSXRlbS5Qb3N0ZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbnZhciBQcmV2aWV3ID0gbmV3IENvbnRlbnQoe1xuICBjc3M6J3ByZXZpZXcnLFxuICAnY292ZXIuYmcuYmFja2dyb3VuZCc6e1xuICAgIGRhdGE6ICdpbWcuY292ZXIuMScsXG4gICAgYWRkOntcbiAgICAgIGRhdGE6J3Nob3cuaW1nLmNvdmVyLjInXG4gICAgfVxuICB9LFxuICAnY29udGFpbmVyLmluZm8nOiB7XG4gICAgdGl0bGU6bmV3IFRpdGxlLlNob3coKSxcbiAgICBzdWJ0aXRsZTpuZXcgU3VidGl0bGUoKSxcbiAgICAnZGVzY3JpcHRpb24udGV4dC5kYXRhJzogJ2Rlc2NyaXB0aW9uJ1xuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTd2l0Y2hlcih7XG4gIGNzczogJ3NlY29uZC12b2QnLFxuICBvblRyYW5zaXRpb246J2ZhZGUnLFxuICBleHRlbmQ6e1xuICAgICRhY3RpdmU6ZnVuY3Rpb24odmFsKXtcbiAgICAgIGlmKHRoaXMuX3N3RWxlbSkgdGhpcy5fc3dFbGVtLiRhY3RpdmUgPSB2YWwudmFsXG4gICAgfSxcbiAgICAkY29tcGxldGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIGNvbXBsZXRlID0gdmFsLnZhbFxuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGFcbiAgICAgIHZhciBpc0VwaXNvZGUgPSBkYXRhLl9jb250ZW50VHlwZSA9PT0gJ2VwaXNvZGVzJ1xuXG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBkYXRhOiBkYXRhLmZyb20sXG4gICAgICAgICRhY3RpdmU6dGhpcy4kYWN0aXZlXG4gICAgICB9XG5cbiAgICAgIGlmIChjb21wbGV0ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgLy8gZWxlbWVudDogaXNFcGlzb2RlID8gRXBpc29kZU92ZXJ2aWV3IDogT3ZlcnZpZXcsXG4gICAgICAgICAgZWxlbWVudDogT3ZlcnZpZXcsXG4gICAgICAgICAgJHBhcmFtczogcGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29tcGxldGUgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICAvLyBlbGVtZW50OiBpc0VwaXNvZGUgPyBFcGlzb2RlUHJldmlldyA6IFByZXZpZXcsXG4gICAgICAgICAgZWxlbWVudDogUHJldmlldyxcbiAgICAgICAgICAkcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJHBvcHVwOmZ1bmN0aW9uKHZhbCl7XG4gICAgICB2YXIgZGF0YSA9IHZhbC52YWxcbiAgICAgIGlmKGRhdGEgJiYgdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKXtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0ge1xuICAgICAgICAgIGVsZW1lbnQ6QmlvLFxuICAgICAgICAgICRwYXJhbXM6e1xuICAgICAgICAgICAgZGF0YTpkYXRhLmZyb21cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBpZih0aGlzLiRjb21wbGV0ZSkgdGhpcy4kY29tcGxldGUudXBkYXRlKClcbiAgICAgIH1cbiAgICB9LFxuICAgIGRhdGE6ZnVuY3Rpb24odmFsKXtcbiAgICAgIGlmKHRoaXMuX3N3RWxlbSAmJiAhdGhpcy5fc3dFbGVtLnN3aXRjaGVyKXtcbiAgICAgICAgdGhpcy5fc3dFbGVtLmRhdGEgPSB2YWwudmFsXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAkYWN0aXZlOnRydWVcbn0pLkNsYXNzXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgVmlkZW8gPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBNcGFhID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvbXBhYScpXG52YXIgUmF0aW5nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvcmF0aW5nJylcbnZhciBTY29yZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3N0YXRpc3RpY3MnKS5TY29yZVxuXG5leHBvcnRzLlR3aXR0ZXIgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3R3aXR0ZXItd2lkZ2V0JyxcbiAgJ2hlYWRlci50ZXh0JzogJ1R3ZWV0cycsXG4gICd0d2VldHMuY29sbGVjdGlvbic6IHtcbiAgICBkYXRhOiAnZ3VpZGUuMC50d2VldHMnLFxuICAgIGVsZW1lbnQ6IG5ldyBFbGVtZW50KHtcbiAgICAgIGNzczogJ3R3ZWV0JyxcbiAgICAgIGJpcmQ6IG5ldyBJY29uKHtpY29uOid0d2l0dGVyJ30pLFxuICAgICAgJ2F1dGhvci50ZXh0LmRhdGEnOiAnYXV0aG9yJyxcbiAgICAgICdib2R5LnRleHQuZGF0YSc6ICdib2R5J1xuICAgIH0pXG4gIH1cbn0pLkNsYXNzXG5cbmV4cG9ydHMuR3VpZGUgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ2d1aWRlLXdpZGdldCcsXG4gICdoZWFkZXIudGV4dCc6ICdHdWlkZScsXG4gICdwcm9ncmFtcy5jb2xsZWN0aW9uJzoge1xuICAgIGRhdGE6ICdndWlkZScsXG4gICAgZWxlbWVudDogbmV3IEVsZW1lbnQoe1xuICAgICAgY3NzOiAncHJvZ3JhbScsXG4gICAgICAndGl0bGUudGV4dC5kYXRhJzogJ3RpdGxlJyxcbiAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgICdzdGFydC50ZXh0LmRhdGEnOiAnc3RhcnQtdGltZScsXG4gICAgICAgICdkYXNoLnRleHQnOiAnIC0gJyxcbiAgICAgICAgJ2Jhci5zZWVrJzoge30sXG4gICAgICAgICdlbmQudGV4dC5kYXRhJzogJ2VuZC10aW1lJ1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn0pLkNsYXNzXG5cbnZhciBQb2xsZXIgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3BvbGxlcicsXG4gICdsZWZ0LmxvZ28nOiBuZXcgSW1nKCksXG4gIHJpZ2h0OiB7XG4gICAgJ3RpdGxlLnRleHQuZGF0YSc6ICd0aXRsZScsXG4gICAgYmFyOiB7XG4gICAgICAnZXh0ZW5kLiRib3JkZXJUb3BDb2xvcic6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZih2YWwudmFsKSB0aGlzLm5vZGUuc3R5bGUuYm9yZGVyVG9wQ29sb3IgPSB2YWwudmFsXG4gICAgICB9LFxuICAgICAgJyRib3JkZXJUb3BDb2xvci5kYXRhJzogJ2NvbG9yJyxcbiAgICAgIHc6IHtcbiAgICAgICAgZGF0YTogJ3ZvdGVzJyxcbiAgICAgICAgZGl2aWRlOiAxMDAwMCxcbiAgICAgICAgbXVsdGlwbHk6IDEwMCxcbiAgICAgICAgYWRkOiAnJSdcbiAgICAgIH1cbiAgICB9LFxuICAgICdzdWJ0aXRsZS50ZXh0Jzoge1xuICAgICAgZGF0YTogJ3ZvdGVzJyxcbiAgICAgIGFkZDogJyBWT1RFUydcbiAgICB9XG4gIH0sXG4gIHNldFNldHRpbmc6IHtcbiAgICBuYW1lOiAnYmluZHZvdGVzJyxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgICAgdGhpcy5yaWdodC5iYXIudyA9IHtcbiAgICAgICAgZGl2aWRlOiBwYXJlbnQub25cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbnZhciBQb2xsID0gbmV3IEVsZW1lbnQoe1xuICBvbjogeyAvLyBzdG9yZSB0aGUgdG90YWx2b3Rlc1xuICAgIGRhdGE6ICdwb2xsLjAudm90ZXMnLFxuICAgICdhZGQuZGF0YSc6ICdwb2xsLjEudm90ZXMnXG4gIH0sXG4gIGFwcGVuZDogW1xuICAgIFBvbGxlciwge1xuICAgICAgJ21vZGVsLmZpZWxkJzogJ3BvbGwuMCdcbiAgICB9LCB7XG4gICAgICAnbW9kZWwuZmllbGQnOiAncG9sbC4xJ1xuICAgIH1cbiAgXVxufSkuQ2xhc3NcblxuZXhwb3J0cy5TdGF0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnc3RhdHMtd2lkZ2V0JyxcbiAgJ2hlYWRlci50ZXh0JzogJ1N0YXRpc3RpY3MnLFxuICBjb250YWluZXI6IHtcbiAgICBtb2RlbDp7ZmllbGQ6J2d1aWRlLjAnfSxcbiAgICBzY29yZTogbmV3IFNjb3JlKCksXG4gICAgaW5mbzoge1xuICAgICAgJ3RpdGxlLnRleHQnOiAnV2hvIHdpbGwgd2luPycsXG4gICAgICAnc3VidGl0bGUudGV4dCc6ICdVc2UgcGhvbmUgdG8gdm90ZSdcbiAgICB9LFxuICAgIHBvbGw6IG5ldyBQb2xsKClcbiAgfVxufSkuQ2xhc3NcblxuZXhwb3J0cy5BYm91dCA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnYWJvdXQtd2lkZ2V0JyxcbiAgJ2hlYWRlci50ZXh0JzogJ0Fib3V0IHRoZSBTaG93JyxcbiAgY29udGFpbmVyOiB7XG4gICAgaW1nOm5ldyBJbWcoe1xuICAgICAgJ2JhY2tncm91bmQuZGF0YSc6J2ltZy50aHVtYidcbiAgICB9KSxcbiAgICBpbmZvOntcbiAgICAgICdtb2RlbC5maWVsZCc6J2d1aWRlLjAnLFxuICAgICAgdGl0bGVzOntcbiAgICAgICAgJ3RpdGxlLnRleHQuZGF0YSc6ICd0aXRsZScsXG4gICAgICAgICdzdWJ0aXRsZS50ZXh0LmRhdGEnOiAnc3VidGl0bGUnXG4gICAgICB9LFxuICAgICAgc3RpY2tlcnM6e1xuICAgICAgICBtcGFhOm5ldyBNcGFhKCksXG4gICAgICAgIHJhdGluZzogbmV3IFJhdGluZygpXG4gICAgICB9XG4gICAgfSxcbiAgICAnZGVzY3JpcHRpb24udGV4dC5kYXRhJzonZ3VpZGUuMC5kZXNjcmlwdGlvbidcbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBQb3N0ZXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2l0ZW0nKS5Qb3N0ZXJcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczondWktYWN0b3JzJyxcbiAgZGlzcGxheTp7XG4gICAgZGF0YTonYWN0b3JzJyxcbiAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICByZXR1cm4gY3YgPyAnYmxvY2snIDogJ25vbmUnXG4gICAgfVxuICB9LFxuICBoZWFkZXI6IHsgdGV4dDogJ1N0YXJyaW5nJyB9LFxuICBib2R5OiB7XG4gICAgc2Nyb2xsYmFyOiAneCcsXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgZGF0YTogJ2FjdG9ycycsXG4gICAgICBlbGVtZW50OiBuZXcgUG9zdGVyKHtcbiAgICAgICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhLmZyb21cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczondWktYmFyJ1xufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcblxudmFyIERlc2NyaXB0aW9uID0gbmV3IEVsZW1lbnQoe1xuXHRjc3M6J3VpLWRlc2NyaXB0aW9uJyxcbiAgaGVhZGVyOiB7IHRleHQ6ICdEZXNjcmlwdGlvbicgfSxcbiAgYm9keToge1xuICAgIHRleHQ6IHsgZGF0YTogJ2Rlc2NyaXB0aW9uJyB9XG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gRGVzY3JpcHRpb25cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcbiAgLCBpY29uID0gbmV3IEVsZW1lbnQoeyBjc3M6J3VpLWljb24nIH0pXG4gICwgbWFwID1cbiAgICB7IGRpc2NvdmVyOidcXHVlNjAwJ1xuICAgICwgc2hvd3M6J1xcdWU2MDEnXG4gICAgLCB0djonXFx1ZTYwMidcbiAgICAsIHNldHRpbmdzOidcXHVlNjAzJ1xuICAgICwgY2FzdDonXFx1ZTYwNCdcbiAgICAsIGRlc2t0b3A6J1xcdWU2MDInXG4gICAgLCBwbGF5OidcXHVlNjA1J1xuICAgICwgcGF1c2U6J1xcdWU2MDYnXG4gICAgLCBmdWxsc2NyZWVuOidcXHVlNjA3J1xuICAgICwgZXhpdGZ1bGxzY3JlZW5BbHQ6J1xcdWU2MDgnXG4gICAgLCBwdWxsYmFjazonXFx1ZTYwOSdcbiAgICAsIHN3aXBldXA6J1xcdWU2MGEnXG4gICAgLCBhbGxDaGFubmVsczonXFx1ZTYwYidcbiAgICAsIGRpc2Nvbm5lY3RlZDonXFx1ZTYwYydcbiAgICAsIG1lbnU6J1xcdWU2MGQnXG4gICAgLCBJRkU6J1xcdWU2MGUnXG4gICAgLCBiYWNrOidcXHVlNjBmJ1xuICAgICwgY2xvc2VTbWFsbDonXFx1ZTYxMCdcbiAgICAsIGNsb3NlOidcXHVlNjExJ1xuICAgICwgd3Jvbmc6J1xcdWU2MTInXG4gICAgLCBjb3JyZWN0OidcXHVlNjEzJ1xuICAgICwgZmFjZWJvb2s6J1xcdWU2MTQnXG4gICAgLCB0d2l0dGVyOidcXHVlNjE1J1xuICAgICwgcGhvbmU6J1xcdWU2MTYnXG4gICAgLCB0YWJsZXQ6J1xcdWU2MTcnXG4gICAgLCB2b2x1bWU6J1xcdWU2MTgnXG4gICAgLCBtdXRlZDonXFx1ZTYxOSdcbiAgICAsIHBhdXNlQWx0OidcXHVlNjFhJ1xuICAgICwgcGxheUFsdDonXFx1ZTYxYidcbiAgICAsIHJld2luZDonXFx1ZTYxYydcbiAgICAsIGZhc3Rmb3J3YXJkOidcXHVlNjFkJ1xuICAgICwgcHJvZmlsZTonXFx1ZTYxZSdcbiAgICAsIGRyb3Bkb3duOidcXHVlNjFmJ1xuICAgICwgcmlnaHROYXY6J1xcdWU2MjAnXG4gICAgLCBsZWZ0TmF2OidcXHVlNjIxJ1xuICAgICwgcmlnaHQ6J1xcdWU2MjInXG4gICAgLCBzZWFyY2g6J1xcdWU2MjMnXG4gICAgLCBub1Jlc3VsdDonXFx1ZTYyNCdcbiAgICAsIHNlYXJjaE1lbnU6J1xcdWU2MjUnXG4gICAgLCBlcGc6J1xcdWU2MjYnXG4gICAgLCB1cE5hdjonXFx1ZTYyNydcbiAgICAsIGRvd25OYXY6J1xcdWU2MjgnXG4gICAgLCBtZW51UmlnaHQ6J1xcdWU2MjknXG4gICAgLCBhaXJwbGFuZTonXFx1ZTYyYSdcbiAgICAsIG11dGVkQWx0OidcXHVlNjJiJ1xuICAgICwgbG9ja2VkOidcXHVlNjJjJ1xuICAgICwgd2VhdGhlcjonXFx1ZTYyZCdcbiAgICAsIGVtcHR5OicgJ1xuICAgIH1cblxuaWNvbi5leHRlbmQoe1xuICBpY29uOiBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgbmFtZSA9IG1hcFt2YWwudmFsXVxuICAgIGlmKG5hbWUpIHtcbiAgICAgIHZhciB2ID0gJzxzcGFuPicgKyBuYW1lICsgJzwvc3Bhbj4nLFxuICAgICAgICB2YWx1ZSA9IHRoaXMubm9kZS5pbm5lckhUTUwsXG4gICAgICAgIGRpdmluZGV4ID0gdmFsdWUuaW5kZXhPZignPGRpdicpXG4gICAgICBpZih+ZGl2aW5kZXgpIHYgKz0gdmFsdWUuc2xpY2UoZGl2aW5kZXgpXG4gICAgICB0aGlzLmh0bWwgPSB2O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdpY29uIGVycm9yOiAnLCB2YWwudmFsLCAnIGlzIG5vdCBkZWZpbmVkJylcbiAgICB9XG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGljb24uQ2xhc3NcbmV4cG9ydHMubWFwID0gbWFwXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgQVNTRVRTID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvY29uZmlnJykucG9pbnRlcnMuYXNzZXRzXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBvcGFjaXR5OiAwLFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgZGF0YTonaW1nJyxcbiAgICBwcmVwZW5kOkFTU0VUUyxcbiAgICBsb2FkOiBmdW5jdGlvbih0KSB7XG4gICAgICBpZih0aGlzLiR3YWl0ICYmIHRoaXMuJHdhaXQudmFsKXtcbiAgICAgICAgdGhpcy4kd2FpdC5vbmNlKGZhbHNlLGZ1bmN0aW9uKCl7XG4gICAgICAgICAgdGhpcy5vcGFjaXR5ID0gZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH1lbHNle1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBmYWxzZVxuICAgICAgfVxuICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZVxuICAgICAgdC5fbG9hZGVkID0gdHJ1ZVxuICAgIH1cbiAgfSxcbiAgJ2V4dGVuZC4kd2FpdCc6ZnVuY3Rpb24oKXt9XG59KS5DbGFzcyIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIExpc3QgPSByZXF1aXJlKCcuLycpXG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IExpc3Qoe1xuICBjb2xsZWN0aW9uOiB7XG4gICAgZGF0YTogJ2l0ZW1zJyxcbiAgICBlbGVtZW50Okl0ZW0uQ2hhbm5lbFxuICB9XG59KS5DbGFzcyIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIF9mb2N1c2VkID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvdXRpbCcpLmZvY3VzZWRcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczonbGlzdC1kb3RzJyxcbiAgY29udGFpbmVyOntcbiAgICBjb2xsZWN0aW9uOntcbiAgICAgIGRhdGE6J3Nwb3RsaWdodC5pdGVtcycsXG4gICAgICBlbGVtZW50Om5ldyBFbGVtZW50KClcbiAgICB9LFxuICAgICdleHRlbmQuJGZvY3VzJzogZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgIC8vIGFsZXJ0KHR5cGVvZiB2YWwudmFsID09PSAnc3RyaW5nJylcbiAgICAgIHZhciBjaGlsZCA9IHR5cGVvZiB2YWwudmFsID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHRoaXNbdmFsLnZhbF1cbiAgICAgICAgOiB0aGlzLmNoaWxkcmVuWyB2YWwudmFsIHx8IDAgXVxuICAgICAgX2ZvY3VzZWQoIHRoaXMsIGNoaWxkIClcbiAgICB9LFxuICAgIG1vZGVsOnsgY29tcGxldGU6ZnVuY3Rpb24oKXtcbiAgICAgIGlmKCB0aGlzLmNoaWxkcmVuWzBdICl7XG4gICAgICAgIGlmKHRoaXMuJGZvY3VzKSB0aGlzLiRmb2N1cy51cGRhdGUoKVxuICAgICAgICB0aGlzLm1vZGVsID0geyBjb21wbGV0ZTpudWxsIH1cbiAgICAgIH1cbiAgICB9fVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoICcuL3N0eWxlLmxlc3MnIClcblxudmFyIGNhc2VzID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJyApXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciB1dGlsID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvdXRpbCcpXG52YXIgX2ZvY3VzZWQgPSB1dGlsLmZvY3VzZWRcbnZhciBfcHJldmVudEFuaW1hdGlvbiA9IHV0aWwucHJldmVudEFuaW1hdGlvblxuXG52YXIgQmFzZSA9IG5ldyBFbGVtZW50KCB7XG4gIGNzczogJ2Jhc2UtbGlzdCcsXG4gIG1vZGVsOiBmdW5jdGlvbigpIHtcblxuICAgIGlmICggdGhpcy5jaGlsZHJlblsgMCBdICkge1xuICAgICAgaWYoICF0aGlzLiRmb2N1cyApIHtcbiAgICAgICAgY29uc29sZS5lcnJvcigndGhpcyBsaXN0IG5lZWRzIGEgJGZvY3VzIHZhbHVlIScpXG4gICAgICAgIC8vIHRoaXMuJGZvY3VzID0gMFxuICAgICAgfVxuICAgICAgX3VwZGF0ZVgodGhpcylcbiAgICAgIHRoaXMuJGZvY3VzLnVwZGF0ZSgpXG4gICAgICB0aGlzLm1vZGVsID0gZmFsc2VcbiAgICB9XG4gIH0sXG4gIHNldFNldHRpbmc6IHtcbiAgICBuYW1lOiAndXBkYXRlWCcsXG4gICAgcGFyZW50OiBmdW5jdGlvbigpIHtcbiAgICAgIF91cGRhdGVYKHRoaXMpXG4gICAgfVxuICB9LFxuICAnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpe1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudFxuICAgIGlmKHBhcmVudC5wYXJlbnQuJGZvY3VzKSBwYXJlbnQucGFyZW50LiRmb2N1cy5mcm9tID0gcGFyZW50Ll9uYW1lXG4gICAgLy8gY29uc29sZS5lcnJvcigndGhpcyEnLHRoaXMucGFyZW50LnBhcmVudClcbiAgfVxufSApLkNsYXNzXG5cbnZhciBMaXN0ID0gbmV3IEJhc2UoIHtcbiAgJ2V4dGVuZC4kZm9jdXMnOiBmdW5jdGlvbiggdmFsICkge1xuICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICB2YXIgbiA9IHZhbC52YWwgfHwgMFxuICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudFxuICAgIFxuICAgIF9mb2N1c2VkKCB0aGlzLCB0aGlzLmNoaWxkcmVuWyBuIF0gKVxuICAgIF9ib3VuY2UoIHRoaXMgKVxuXG4gICAgaWYoICFjYXNlcy4kaXNQaG9uZSAmJiBwYXJlbnQgKXtcbiAgICAgIFxuICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVcbiAgICAgIHZhciBwYXJlbnRUb3AgPSBwYXJlbnQubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgIGlmKF90aGlzLnJhZklkKSB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoX3RoaXMucmFmSWQpXG4gICAgICBmdW5jdGlvbiBjaGVjaygpe1xuICAgICAgICB2YXIgdG9wID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgaWYoIXRvcCB8fCB0b3AgPT09IHBhcmVudFRvcCkge1xuICAgICAgICAgIF90aGlzLnggPSB7XG4gICAgICAgICAgICBtdWx0aXBseTogLW5cbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMucmFmSWQgPSBudWxsXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIF90aGlzLnJhZklkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjaGVjaylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2soKVxuXG4gICAgfWVsc2V7XG4gICAgICB0aGlzLnggPSB7XG4gICAgICAgIG11bHRpcGx5OiAtblxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgeDoge1xuICAgIHRyYW5zbGF0ZTogdHJ1ZSxcbiAgICB2YWw6MCxcbiAgICBtdWx0aXBseTogMCxcbiAgICBkZWZlcjogX2RlZmVyXG4gIH0sXG4gIHk6e1xuICAgIHRyYW5zbGF0ZTp0cnVlLFxuICAgIHZhbDowXG4gIH0sXG4gICRpc1Bob25lOiB7XG4gICAgeDoge1xuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIHRpbWU6IDI0LFxuICAgICAgICBlYXNpbmc6ICdvdXRDdWJpYydcbiAgICAgIH1cbiAgICB9LFxuICAgICdldmVudHMuZ3JhYic6IHtcbiAgICAgIHg6IHRydWUsXG4gICAgICBwYXNzOiBfcGFzcyxcbiAgICAgIG1vdmU6IF9oaWdobGlnaHQsXG4gICAgICB1cDogX3Bvc2l0aW9uXG4gICAgfVxuICB9XG59ICkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gY2FzZXMuJGlzUGhvbmUgPyBuZXcgQmFzZSgge1xuICAvLyBtb2RlbDpmdW5jdGlvbigpe1xuICAvLyAgIGlmICggdGhpcy5jaGlsZHJlblsgMCBdICkge1xuICAvLyAgICAgdmFyIG5hbWUgPSB0aGlzLnBhcmVudC5fbmFtZVxuICAvLyAgICAgdmFyIHNjcm9sbExlZnQgPSBleHBvcnRzW25hbWVdICYmIGV4cG9ydHNbbmFtZV0uc2Nyb2xsTGVmdFxuICAvLyAgICAgaWYoc2Nyb2xsTGVmdCl7XG4gIC8vICAgICAgIGV4cG9ydHNbbmFtZV0uaWdub3JlU2Nyb2xsID0gdHJ1ZVxuICAvLyAgICAgICB0aGlzLm5vZGUuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnRcbiAgLy8gICAgICAgZXhwb3J0c1tuYW1lXS5pZ25vcmVTY3JvbGwgPSBmYWxzZVxuICAvLyAgICAgfWVsc2V7XG4gIC8vICAgICAgIGlmKCAhdGhpcy4kZm9jdXMgKSB7XG4gIC8vICAgICAgICAgY29uc29sZS5lcnJvcigndGhpcyBsaXN0IG5lZWRzIGEgJGZvY3VzIHZhbHVlIScpXG4gIC8vICAgICAgICAgLy8gdGhpcy4kZm9jdXMgPSAwXG5cbiAgLy8gICAgICAgfVxuICAvLyAgICAgICBfdXBkYXRlWCh0aGlzKVxuICAvLyAgICAgICB0aGlzLiRmb2N1cy51cGRhdGUoKVxuICAvLyAgICAgfVxuICAvLyAgICAgdGhpcy5tb2RlbCA9IGZhbHNlXG4gIC8vICAgfVxuICAvLyB9LFxuICAnZXh0ZW5kLiRmb2N1cyc6IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuICAgIF9mb2N1c2VkKCB0aGlzLCBjaGlsZHJlblsgdmFsLnZhbCB8fCAwIF0gKVxuICAgIGlmICggIXRoaXMubm9kZS5zY3JvbGxMZWZ0ICYmIHZhbC52YWwgKSB7XG4gICAgICB0aGlzLm5vZGUuc2Nyb2xsTGVmdCA9IHZhbC52YWwgKiBfc3RlcCggdGhpcywgY2hpbGRyZW4gKVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsYmFyOiAneCcsXG4gICdldmVudHMuc2Nyb2xsJzogZnVuY3Rpb24oIGUgKSB7XG4gICAgLy8gdmFyIG5hbWUgPSB0aGlzLnBhcmVudC5fbmFtZVxuICAgIC8vIGlmKCFleHBvcnRzW25hbWVdKSBleHBvcnRzW25hbWVdID0ge31cbiAgICAvLyBlbHNlIGlmKGV4cG9ydHNbbmFtZV0uaWdub3JlU2Nyb2xsKSByZXR1cm5cblxuICAgIGlmKCF0aGlzLl9jaGVja2VkKXsgLy9ibG9jayB0aGUgZmlyc3RcbiAgICAgIHRoaXMuX2NoZWNrZWQgPSB0cnVlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IG5vZGUuc2Nyb2xsTGVmdFxuICAgIHZhciBmcmFjdGlvbiA9IHNjcm9sbExlZnQgLyAoIG5vZGUuc2Nyb2xsV2lkdGggLSBub2RlLm9mZnNldFdpZHRoIClcbiAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKCBmcmFjdGlvbiAqICggX2xlbmd0aCggdGhpcyApIC0gMSApIClcbiAgICAvLyBleHBvcnRzW25hbWVdLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0XG4gICAgX3RoaXMuJGZvY3VzLmZyb20gPSBpbmRleFxuICB9XG59ICkuQ2xhc3MgOiBMaXN0XG5cbmV4cG9ydHMuQ2Fyb3VzZWwgPSBMaXN0XG5leHBvcnRzLlNwb3RsaWdodCA9IHJlcXVpcmUoICcuL3Nwb3RsaWdodCcgKVxuZXhwb3J0cy5DaGFubmVsID0gcmVxdWlyZSggJy4vY2hhbm5lbCcgKVxuZXhwb3J0cy5Qb3N0ZXIgPSByZXF1aXJlKCAnLi9wb3N0ZXInIClcbmV4cG9ydHMuV2F0Y2hpbmcgPSByZXF1aXJlKCAnLi93YXRjaGluZycgKVxuZXhwb3J0cy5Eb3RzID0gcmVxdWlyZSggJy4vZG90cycgKVxuZXhwb3J0cy5JdGVtID0gcmVxdWlyZSggJy4vaXRlbScgKVxuXG52YXIgdHJlc2hvbGQgPSA2MFxudmFyIGZsaWNrID0gMTBcblxuZnVuY3Rpb24gX2JvdW5jZSggbGlzdCApIHtcbiAgaWYgKCBsaXN0LnguX2UgKXtcbiAgICBsaXN0LnggPSB7XG4gICAgICBfZXN1YjogbGlzdC54Ll9lLl92YWxcbiAgICB9XG4gICAgbGlzdC54LnVwZGF0ZSgpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2hpZ2hsaWdodCggZSwgZCl7XG4gIHZhciBsZW5ndGggPSBfbGVuZ3RoKCB0aGlzIClcbiAgdmFyIHN0ZXAgPSBfc3RlcCggdGhpcyApXG4gIHZhciBvbGRwb3MgPSB0aGlzLl9zdGFydFxuICB2YXIgbmV3cG9zID0gb2xkcG9zXG4gIGlmICggZC54IDwgLXRyZXNob2xkICkge1xuICAgIG5ld3BvcyA9IE1hdGgubWF4KCBvbGRwb3MgLSBNYXRoLmNlaWwoICggLWQueCApIC8gc3RlcCApLCAtbGVuZ3RoICsgMSApXG4gIH0gZWxzZSBpZiAoIGQueCA+IHRyZXNob2xkICkge1xuICAgIG5ld3BvcyA9IE1hdGgubWluKCBvbGRwb3MgKyBNYXRoLmNlaWwoIGQueCAvIHN0ZXAgKSwgMCApXG4gIH1cbiAgaWYoLW5ld3BvcyAhPT0gdGhpcy4kZm9jdXMudmFsKSBfc2V0KCB0aGlzLCBuZXdwb3MgKVxufVxuXG5mdW5jdGlvbiBfcGFzcyggZSwgZCApIHtcbiAgaWYoTWF0aC5hYnMoIGQueCApID4gTWF0aC5hYnMoIGQueSApKXtcbiAgICB0aGlzLl9zdGFydCA9IC10aGlzLiRmb2N1cy52YWwgfHwgMFxuICAgIHJldHVybiB0cnVlXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Bvc2l0aW9uKCBlLCBkLCBsZCApIHsgLy8gdW5pZnkgd2l0aCBzd2l0Y2hlclxuICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuXG4gIHZhciBsZW5ndGggPSBfbGVuZ3RoKCB0aGlzIClcbiAgdmFyIG9sZHBvcyA9IHRoaXMuX3N0YXJ0IHx8IDBcbiAgdmFyIG5ld3Bvc1xuICB2YXIgc3RlcCA9IF9zdGVwKCB0aGlzLCBjaGlsZHJlbiApXG5cbiAgaWYgKCBNYXRoLmFicyggbGQueCApID4gZmxpY2sgKSB7XG4gICAgaWYgKCBsZC54IDwgMCAmJiBkLnggPCB0cmVzaG9sZCApIHtcbiAgICAgIG5ld3BvcyA9IE1hdGgubWF4KCBvbGRwb3MgLSBNYXRoLmNlaWwoICggLWQueCApIC8gc3RlcCApLCAtbGVuZ3RoICsgMSApXG4gICAgfSBlbHNlIGlmICggbGQueCA+IDAgJiYgZC54ID4gLXRyZXNob2xkICkge1xuICAgICAgbmV3cG9zID0gTWF0aC5taW4oIG9sZHBvcyArIE1hdGguY2VpbCggZC54IC8gc3RlcCApLCAwIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKCBkLnggPCAtdHJlc2hvbGQgKSB7XG4gICAgICBuZXdwb3MgPSBNYXRoLm1heCggb2xkcG9zIC0gTWF0aC5jZWlsKCAoIC1kLnggKSAvIHN0ZXAgKSwgLWxlbmd0aCArIDEgKVxuICAgIH0gZWxzZSBpZiAoIGQueCA+IHRyZXNob2xkICkge1xuICAgICAgbmV3cG9zID0gTWF0aC5taW4oIG9sZHBvcyArIE1hdGguY2VpbCggZC54IC8gc3RlcCApLCAwIClcbiAgICB9XG4gIH1cblxuICBpZiAoIG5ld3BvcyAhPT0gdm9pZCAwICYmIC1uZXdwb3MgIT09IHRoaXMuJGZvY3VzLnZhbCApIF9zZXQoIHRoaXMsIG5ld3BvcyApXG4gIFxuICBfYm91bmNlKCB0aGlzIClcbn1cblxuZnVuY3Rpb24gX3N0ZXAoIGxpc3QsIGNoaWxkcmVuLCBjb3JyZWN0ZWQgKSB7IC8vIHRoaXMgY2FuIGJlIGNsZWFuZXJcbiAgdmFyIG5vZGVcblxuICBpZiAoICFjaGlsZHJlbiApIGNoaWxkcmVuID0gbGlzdC5jaGlsZHJlblxuICBpZiAoIGNoaWxkcmVuWyAwIF0gKSB7XG4gICAgaWYgKCAhbGlzdC5fc3RlcCApIHtcbiAgICAgIG5vZGUgPSBsaXN0Lm5vZGVcbiAgICAgIGxpc3QuX3N0ZXAgPSBub2RlLnNjcm9sbFdpZHRoIC8gX2xlbmd0aCggbGlzdCApIC8vIFxuICAgIH1cbiAgICBpZiAoIGNvcnJlY3RlZCApIHtcbiAgICAgIG5vZGUgPSBsaXN0Lm5vZGVcbiAgICAgIHJldHVybiAoIG5vZGUuc2Nyb2xsV2lkdGggLSBub2RlLm9mZnNldFdpZHRoICkgLyAoIF9sZW5ndGgoIGxpc3QgKSAtIDEgKVxuICAgIH1cbiAgICByZXR1cm4gbGlzdC5fc3RlcFxuICB9XG59XG5cbmZ1bmN0aW9uIF9sZW5ndGgoIF90aGlzICl7XG4gIHJldHVybiBfdGhpcy5jaGlsZHJlbi5sZW5ndGggLy9fdGhpcy5fbGVuZ3RoIHx8ICggX3RoaXMuX2xlbmd0aCA9IF90aGlzLmNoaWxkcmVuLmxlbmd0aCApXG59XG5cbmZ1bmN0aW9uIF9kZWZlciggdXBkYXRlLCBhcmdzICkge1xuICB2YXIgbGlzdCA9IHRoaXMuX2NhbGxlclxuICB2YXIgc3RlcCA9IF9zdGVwKCBsaXN0LCBudWxsLCB0cnVlIClcbiAgaWYgKCBzdGVwICkge1xuICAgIGlmKCF0aGlzLl92YWwpIHRoaXMudmFsID0gc3RlcFxuICAgIHRoaXMuX2ZsYWcgPSBudWxsXG4gIH1cbiAgdXBkYXRlKClcbn1cblxuZnVuY3Rpb24gX3VwZGF0ZVgoIF90aGlzICl7XG4gIGlmKCBfdGhpcy54ICl7XG4gICAgX3ByZXZlbnRBbmltYXRpb24oX3RoaXMsZnVuY3Rpb24oKXtcbiAgICAgIF90aGlzLnguX3AgPSB0cnVlXG4gICAgICBfdGhpcy54LnVwZGF0ZSgpXG4gICAgICBfdGhpcy54Ll9wID0gbnVsbFxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gX3NldCggX3RoaXMsIG5ld3BvcyApe1xuICB2YXIgZmllbGQgPSBfdGhpcy4kZm9jdXMuX2ZsYWcgJiYgX3RoaXMuJGZvY3VzLl9mbGFnLmRhdGFbMl1cbiAgdmFyIGRhdGEgPSBfdGhpcy5kYXRhXG4gIGlmKCBmaWVsZCAmJiBkYXRhICl7XG4gICAgZGF0YS5mcm9tLnNldChmaWVsZCwtbmV3cG9zKVxuICB9ZWxzZSBfdGhpcy4kZm9jdXMuZnJvbSA9IC1uZXdwb3Ncbn0iLCJ2YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgVGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC90aXRsZScpXG52YXIgU3VidGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdWJ0aXRsZScpXG52YXIgYmxvY2tlZCA9ICdibG9ja2VkJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGltZzogbmV3IEltZygpLFxuICAnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZvY3VzID0gdGhpcy5wYXJlbnQuJGZvY3VzXG4gICAgaWYgKGZvY3VzKSBmb2N1cy5mcm9tID0gdGhpcy4kaW5kZXhcbiAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEuZnJvbVxuICB9LFxuICBleHRlbmQ6IFt7XG4gICAgICBuYW1lOiAnJGluZGV4JyxcbiAgICAgIHR5cGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luZGV4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICB2YXIgc2libGluZ3MgPSB0aGlzLnBhcmVudC5jaGlsZHJlblxuICAgICAgICAgIGZvciAodmFyIGkgPSBzaWJsaW5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgc2libGluZ3NbaV0uX2luZGV4ID0gaVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5faW5kZXhcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAkYmxvY2tlZDogX2Jsb2NrZWRcbiAgICB9XSxcbiAgJyRibG9ja2VkLmRhdGEnOmJsb2NrZWRcbn0pLkNsYXNzXG5cbmV4cG9ydHMuSW5mbyA9IG5ldyBleHBvcnRzKHtcbiAgY3NzOiAnaW5mby1pdGVtJyxcbiAgJ2ltZy5iYWNrZ3JvdW5kLmRhdGEnOiAnaW1nLnRodW1iJyxcbiAgaW5mbzoge1xuICAgIHRpdGxlOiBuZXcgVGl0bGUuU2hvdygpLFxuICAgIHN1YnRpdGxlOiBuZXcgU3VidGl0bGUoKVxuICB9XG59KS5DbGFzc1xuXG5leHBvcnRzLlBvc3RlciA9IG5ldyBleHBvcnRzKHtcbiAgY3NzOiAncG9zdGVyLWl0ZW0nLFxuICAnaW1nLmJhY2tncm91bmQuZGF0YSc6ICdpbWcucG9zdGVyJyxcbn0pLkNsYXNzXG5cbmV4cG9ydHMuQ2hhbm5lbCA9IG5ldyBleHBvcnRzLkluZm8oe1xuICAnbG9nbyc6IG5ldyBJbWcoe1xuICAgICdiYWNrZ3JvdW5kLmRhdGEnOiAnaW1nLmxvZ28nXG4gIH0pLFxuICAnaW5mby50aXRsZS50ZXh0LmRhdGEnOiAnZ3VpZGUuMC50aXRsZSdcbn0pLkNsYXNzXG5cbmV4cG9ydHMuQ2Fyb3VzZWwgPSBuZXcgSW1nKHtcbiAgY3NzOiAnc3BvdGxpZ2h0LWl0ZW0nLFxuICAnZXh0ZW5kLiRibG9ja2VkJzogX2Jsb2NrZWQsXG4gICdldmVudHMuY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEuZnJvbVxuICB9LFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgZGF0YTogJ2ltZy5zcG90bGlnaHQnXG4gIH0sXG4gICckYmxvY2tlZC5kYXRhJzpibG9ja2VkXG59KS5DbGFzc1xuXG5mdW5jdGlvbiBfYmxvY2tlZCh2YWwpe1xuICBpZih2YWwudmFsKXtcbiAgICB0aGlzLmFkZEV2ZW50KCdjbGljaycsZnVuY3Rpb24oKXtcbiAgICAgIC8vIG5ldyBBdWRpbygnaHR0cDovL3d3dy5ub2lzZWFkZGljdHMuY29tL3NhbXBsZXNfMXc3MmI4MjAvMzczOS5tcDMnKS5wbGF5KClcbiAgICAgIGFsZXJ0KCdUaGlzIGl0ZW0gaXMgbm90IGF2YWlsYWJsZScpXG4gICAgfSxibG9ja2VkKVxuICAgIHRoaXMuY3NzID0geyBhZGRDbGFzczpibG9ja2VkIH1cbiAgICB0aGlzLnNldCh7XG4gICAgICBsb2NrOm5ldyBJY29uKHtpY29uOidsb2NrZWQnfSlcbiAgICB9KVxuICB9ZWxzZXtcbiAgICBpZih0aGlzLmxvY2spe1xuICAgICAgdGhpcy5yZW1vdmVFdmVudChmYWxzZSwgYmxvY2tlZClcbiAgICAgIHRoaXMuY3NzID0geyByZW1vdmVDbGFzczpibG9ja2VkIH1cbiAgICAgIHRoaXMubG9jay5yZW1vdmUoKVxuICAgIH1cbiAgfVxufVxuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgTGlzdCA9IHJlcXVpcmUoJy4vJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBJdGVtID0gcmVxdWlyZSgnLi9pdGVtJylcblxuTGlzdC5Qb3N0ZXIgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgTGlzdCh7XG4gIGNvbGxlY3Rpb246IHtcbiAgICBkYXRhOiAnaXRlbXMnLFxuICAgIGVsZW1lbnQ6bmV3IEl0ZW0uUG9zdGVyKClcbiAgfVxufSkuQ2xhc3NcblxuLy8gZXhwb3J0cy5lbGVtZW50ID0gZWxlbWVudCIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIExpc3QgPSByZXF1aXJlKCcuLycpXG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IExpc3QuQ2Fyb3VzZWwoIHtcbiAgY29sbGVjdGlvbjoge1xuICAgIGRhdGE6ICdpdGVtcycsXG4gICAgZWxlbWVudDpJdGVtLkNhcm91c2VsXG4gIH1cbn0gKS5DbGFzcyIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIExpc3QgPSByZXF1aXJlKCcuLycpXG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IExpc3Qoe1xuICBjb2xsZWN0aW9uOiB7XG4gICAgZGF0YTogJ2l0ZW1zJyxcbiAgICBlbGVtZW50Om5ldyBJdGVtLkluZm8oe1xuICAgICAgYmFyOntcbiAgICAgICAgdzp7XG4gICAgICAgICAgZGF0YTondGltZScsXG4gICAgICAgICAgbXVsdGlwbHk6MTAwLFxuICAgICAgICAgIGFiczp0cnVlLFxuICAgICAgICAgIGFkZDonJSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFNwcml0ZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3ByaXRlJylcbiAgLCBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU3ByaXRlKFxueyBjc3M6J3VpLWxvYWRlcidcbiwgdzozMFxuLCBoOjMwXG4sIHBhcmFtczp7IGNvbHM6MSwgcm93czoyNiB9IC8vIG9uY2U6dHJ1ZSB9XG59KS5DbGFzc1xuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgYmFja2dyb3VuZDp7XG4gICAgZGF0YTonbXBhYScsXG4gICAgYWRkOntkYXRhOidzaG93Lm1wYWEnfSxcbiAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odiwgbXBhYSl7XG4gICAgICBpZiggbXBhYSApIHJldHVybiAnYXNzZXRzL2ltZy9hcHAvbXBhYV8nICsgbXBhYS50b0xvd2VyQ2FzZSgpICsgJy5wbmcnXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBJY29uKHtcbiAgY3NzOid1aS1pY29uIHNoYXJlZC1tdXRlJyxcbiAgaWNvbjp7XG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgcmV0dXJuIGN2ID8gJ211dGVkQWx0JyA6ICd2b2x1bWUnXG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgQmFyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2JhcicpLkJhclxuXG52YXIgVm90ZVJvdyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAndWktdm90ZXJvdycsXG4gIGxlZnQ6IHtcbiAgICBsb2dvOiB7IFxuICAgICAgYmFja2dyb3VuZDogeyBcbiAgICAgICAgZGF0YTogJ2ltZycsXG4gICAgICAgIHByZXBlbmQ6IGNvbmZpZy5wb2ludGVycy5hc3NldHNcbiAgICAgIH0sXG4gICAgICAnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5kYXRhLnZvdGVzLnZhbCArPSAxXG4gICAgICB9XG4gICAgfVxuICB9LFxuICByaWdodDoge1xuICAgIGNvdW50OiB7XG4gICAgICBtb2RlbDpmdW5jdGlvbihkYXRhKXtcbiAgICAgICAgaWYoZGF0YS5fcGFyZW50KXtcbiAgICAgICAgICB0aGlzLm1vZGVsID0gZmFsc2VcbiAgICAgICAgICB0aGlzLnZvdGVmaWxsZXIuZGF0YSA9IGRhdGEuX3BhcmVudFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGVhbTogeyB0ZXh0OiB7IGRhdGE6ICd0aXRsZScgfSB9LFxuICAgICAgdm90ZXM6IHsgdGV4dDogeyBkYXRhOiAndm90ZXMnICxhZGQ6ICcgVk9URVMnIH0gfSxcbiAgICAgIHZvdGVmaWxsZXI6IG5ldyBCYXIoe1xuICAgICAgICBzZWVrOiB7XG4gICAgICAgICAgdzp7XG4gICAgICAgICAgICBkYXRhOnRydWUsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCBjLCBjdiApe1xuICAgICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnBhcmVudC5wYXJlbnRcbiAgICAgICAgICAgICAgdmFyIG15dm90ZXMgPSBjb3VudC5kYXRhICYmIGNvdW50LmRhdGEudm90ZXMgJiYgY291bnQuZGF0YS52b3Rlcy52YWxcbiAgICAgICAgICAgICAgaWYobXl2b3Rlcykge1xuICAgICAgICAgICAgICAgIHZhciB2MSA9IGN2WzBdLnZvdGVzLnZhbFxuICAgICAgICAgICAgICAgIHZhciB2MiA9IGN2WzFdLnZvdGVzLnZhbFxuICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IHYxICsgdjJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCBteXZvdGVzIC8gdG90YWwgKSAqIDEwMCArICclJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICAnZXh0ZW5kLiRiYWNrZ3JvdW5kQ29sb3InOiBmdW5jdGlvbiggdmFsICl7XG4gICAgICAgICAgICB2YXIgY291bnQgPSB0aGlzLnBhcmVudC5wYXJlbnRcbiAgICAgICAgICAgIHZhciBteWNvbG9yID0gY291bnQuZGF0YSAmJiBjb3VudC5kYXRhLmNvbG9yICYmIGNvdW50LmRhdGEuY29sb3IudmFsXG4gICAgICAgICAgICBpZihteWNvbG9yKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gbXljb2xvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJyRiYWNrZ3JvdW5kQ29sb3IuZGF0YSc6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbnZhciBQb2xsID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICd1aS1wb2xsJyxcbiAgZGlzcGxheTp7XG4gICAgdmFsOidibG9jaycsXG4gICAgd2hlbjp7ZGF0YToncG9sbC4wLnRpdGxlJ30sXG4gICAgb3I6J25vbmUnXG4gIH0sXG4gIGhlYWRlcjogeyB0ZXh0OiB7IGRhdGE6ICdwb2xsLnRpdGxlJyB9IH0sXG4gIGZpcnN0OiBuZXcgVm90ZVJvdyh7XG4gICAgbW9kZWw6IHsgZmllbGQ6ICdwb2xsLjAnIH1cbiAgfSksXG4gIHNlY29uZDogbmV3IFZvdGVSb3coe1xuICAgIG1vZGVsOiB7IGZpZWxkOiAncG9sbC4xJyB9XG4gIH0pXG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxcbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3NoYXJlZC9pY29uJylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJyApXG4gICAgLmluamVjdCggcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXIvdHJhbnNpdGlvbnMnICkgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczoncG9wdXAnLFxuICB0b3BiYXI6e1xuICAgIGxlZnQ6bmV3IEljb24oe2ljb246J2xlZnQnfSksXG4gICAgbWlkZGxlOiB7IHRleHQ6J3BvcHVwJyB9LFxuICAgIHJpZ2h0Om5ldyBJY29uKHtcbiAgICAgIGljb246J2Nsb3NlJyxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBjbGljazpmdW5jdGlvbigpIHtcbiAgICAgICAgICAvL2hvdyB0byBzeW5jIGl0IHdpdGggbWlzYz8/P1xuICAgICAgICAgIHRoaXMucGFyZW50LnBhcmVudC5wb3B1cC4kdXNlck9yaWdpbiA9IGZhbHNlXG4gICAgICAgICAgLy8gYXBwLnVzZXIubmF2aWdhdGlvbi5taXNjLiR1c2VyT3JpZ2luXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICB3OmFwcC53LFxuICBoOmFwcC5oLFxuICB5OlxuICB7IHZhbDowLCBcbiAgICBhbmltYXRpb246XG4gICAgeyB0aW1lOmFwcC5oLnZhbCAvIDMwXG4gICAgLCBzdGFydDphcHAuaFxuICAgICwgZWFzaW5nOidvdXRDdWJpYydcbiAgICAsIGRvbmU6ZnVuY3Rpb24oY3YpIHtcbiAgICAgICAgdmFyIHQgPSB0aGlzXG4gICAgICAgIGlmKGN2Pj0xMDApIHQucmVtb3ZlKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHN3aXRjaGVyOm5ldyBTd2l0Y2hlcih7XG4gICAgb25UcmFuc2l0aW9uOiB7XG4gICAgICB2YWw6J2ZhZGUnLFxuICAgICAgJGhhc1RvdWNoOiAnc2xpZGUnXG4gICAgfSxcbiAgICBiYWNrRmFsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc29sZS5lcnJvcignd3RmIG1vZXQgaGllci4uLmJhY2tmYWxsYmFjaycpXG4gICAgfVxuICB9KSxcbiAgZXh0ZW5kOntcbiAgICBwb3B1cDpmdW5jdGlvbigpe31cbiAgfVxufSkuQ2xhc3NcblxuXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICB0ZXh0OntkYXRhOidyYXRpbmcnLGFkZDp7ZGF0YTonc2hvdy5yYXRpbmcnfX1cbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgUG9zdGVyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9pdGVtJykuUG9zdGVyXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG5cbnZhciBSZWNvbW1lbmRhdGlvbnMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3VpLXJlY29tbWVuZGF0aW9ucycsXG4gIGRpc3BsYXk6e1xuICAgIHZhbDonYmxvY2snLFxuICAgIHdoZW46e2RhdGE6J3JlY29tbWVuZGF0aW9ucyd9LFxuICAgIG9yOidub25lJ1xuICB9LFxuICBoZWFkZXI6IHsgdGV4dDogJ1lvdVxcJ2xsIGxvdmUgdGhlc2UnIH0sXG4gIGJvZHk6IHtcbiAgICBzY3JvbGxiYXI6ICd4JyxcbiAgICBjb2xsZWN0aW9uOiB7XG4gICAgICBkYXRhOiAncmVjb21tZW5kYXRpb25zJyxcbiAgICAgIGVsZW1lbnQ6IFBvc3RlclxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBSZWNvbW1lbmRhdGlvbnNcbiIsInZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwLycpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgZGlzcGxheSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9jb2xsZWN0aW9uL2Rpc3BsYXknKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIFN1YnRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3VidGl0bGUnKVxudmFyIE11dGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9tdXRlJylcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxuXG52YXIgUmVzdWx0ID0gZXhwb3J0cy5SZXN1bHQgPSBhcHAuY2FzZXMuJGlzUGhvbmUgXG4/IG5ldyBFbGVtZW50KHtcbiAgICBjc3M6J3NlYXJjaC1yZXN1bHQnLFxuICAgIGJvZHk6IHtcbiAgICAgIHRpdGxlOiB7XG4gICAgICAgIHRleHQ6e2RhdGE6J3RpdGxlJ30sXG4gICAgICB9LFxuICAgICAgYXJyb3dSaWdodDogbmV3IEljb24oeyBpY29uOidyaWdodCcgfSlcbiAgICB9LFxuICAgICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKGUpIHtcbiAgICAgIGFwcC51c2VyLm5hdmlnYXRpb24uY29udGVudC4kdXNlck9yaWdpbiA9IHRoaXMuZGF0YVxuICAgICB9XG4gIH0pLkNsYXNzXG46IG5ldyBFbGVtZW50KHtcbiAgICBjc3M6J3NlYXJjaC1yZXN1bHQnLFxuICAgICdwb3N0ZXIuY29udGFpbmVyJzpuZXcgSW1nKHtcbiAgICAgICdiYWNrZ3JvdW5kLmRhdGEnOidpbWcucG9zdGVyJ1xuICAgIH0pLFxuICAgIGJvZHk6e1xuICAgICAgJ3RpdGxlLnRleHQuZGF0YSc6J3RpdGxlJyxcbiAgICAgIHN1YnRpdGxlOm5ldyBTdWJ0aXRsZSgpXG4gICAgfVxuICB9KS5DbGFzc1xuXG52YXIgUmVzdWx0cyA9IGV4cG9ydHMuUmVzdWx0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOidzZWFyY2gtcmVzdWx0cycsXG4gIHRpdGxlOiB7XG4gICAgdGV4dDoncmVjZW50IHNlYXJjaGVzJ1xuICB9LFxuICBjb2xsZWN0aW9uOiB7XG4gICAgb3B0aW9uOmRpc3BsYXksXG4gICAgZWxlbWVudDpSZXN1bHRcbiAgfVxufSkuQ2xhc3NcblxudmFyIFRvcFJlc3VsdCA9IGV4cG9ydHMuVG9wUmVzdWx0ID0gbmV3IEVsZW1lbnQoe1xuICB0aXRsZToge3RleHQ6J3RvcCByZXN1bHQnfSxcbiAgY3NzOidzZWFyY2gtdG9wLXJlc3VsdCcsXG4gIGJvZHk6IHtcbiAgICBwb3N0ZXI6e1xuICAgICAgaW1nOiB7XG4gICAgICAgIGJhY2tncm91bmQ6IHtcbiAgICAgICAgICB2YWw6IGNvbmZpZy5wb2ludGVycy5pbWcsXG4gICAgICAgICAgYWRkOiB7IGRhdGE6J2ltZy5wb3N0ZXInIH1cbiAgICAgICAgfSxcbiAgICAgICAgYmFja2Ryb3A6e30sXG4gICAgICAgIG11dGU6bmV3IE11dGUoe1xuICAgICAgICAgIGRpc3BsYXk6e1xuICAgICAgICAgICAgdmFsOidub25lJyxcbiAgICAgICAgICAgICRoYXNSZWNlaXZlcjonYmxvY2snXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpY29uOntcbiAgICAgICAgICAgIHZhbDphcHAudXNlci50cmFpbGVyTXV0ZWRcbiAgICAgICAgICB9LFxuICAgICAgICAgICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGFwcC51c2VyLnRyYWlsZXJNdXRlZC4kdXNlck9yaWdpbiA9ICFhcHAudXNlci50cmFpbGVyTXV0ZWQudmFsXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0sXG4gICAgdGV4dEhvbGRlcjp7XG4gICAgICB0aXRsZTogeyB0ZXh0OnsgZGF0YTondGl0bGUnIH0gfSxcbiAgICAgIGluZm86IHsgdGV4dDonMTEyIG1pbnV0ZXMnIH0sXG4gICAgICByYXRpbmc6IHtcbiAgICAgICAgdGV4dDogeyBkYXRhOidyYXRpbmcnfVxuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0aW9uOiB7IHRleHQ6IHsgZGF0YTogJ2Rlc2NyaXB0aW9uJ30gfSxcbiAgICAgICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgYXBwLnVzZXIubmF2aWdhdGlvbi5jb250ZW50LiR1c2VyT3JpZ2luID0gdGhpcy50aXRsZS5kYXRhXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb2RlbDogeyBpbmhlcml0OiBmYWxzZSB9XG4gIC8vICdtb2RlbC5maWVsZCc6J21vdmllcy4wJyAvL2RlemUgbW9ldCBkeW5hbWljbHkgY2hhbmdlbiA6KFxufSkuQ2xhc3NcblxuZXhwb3J0cy5SZXN1bHRMaXN0ID0gbmV3IEVsZW1lbnQoe1xuICBtb3ZpZXM6IG5ldyBSZXN1bHRzKHtcbiAgICB0aXRsZToge1xuICAgICAgdGV4dDonbW92aWVzJ1xuICAgIH0sXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgZWxlbWVudDogbmV3IFJlc3VsdCh7XG4gICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgICAgICB0aXRsZTp0cnVlLFxuICAgICAgICAgICAgYWN0b3JzOntcbiAgICAgICAgICAgICAgJDp7XG4gICAgICAgICAgICAgICAgdGl0bGU6dHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIGRhdGE6J21vdmllcydcbiAgICB9XG4gIH0pLFxuICBzZXJpZXM6IG5ldyBSZXN1bHRzKHtcbiAgICB0aXRsZToge1xuICAgICAgdGV4dDonc2VyaWVzJ1xuICAgIH0sXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgZGF0YTonc2VyaWVzJ1xuICAgIH1cbiAgfSksXG4gIGNoYW5uZWxzOiBuZXcgUmVzdWx0cyh7XG4gICAgdGl0bGU6IHtcbiAgICAgIHRleHQ6J2NoYW5uZWxzJ1xuICAgIH0sXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgZGF0YTonY2hhbm5lbHMnXG4gICAgfVxuICB9KSxcbiAgYWN0b3JzOiBuZXcgUmVzdWx0cyh7XG4gICAgdGl0bGU6IHtcbiAgICAgIHRleHQ6J2FjdG9ycydcbiAgICB9LFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGRhdGE6J2FjdG9ycycsXG4gICAgICBlbGVtZW50OiBuZXcgUmVzdWx0KHtcbiAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgICAgIHRpdGxlOnRydWUsXG4gICAgICAgICAgICBjYXRhbG9nOntcbiAgICAgICAgICAgICAgJDp7XG4gICAgICAgICAgICAgICAgdGl0bGU6dHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgLy9taXNjXG4gICAgICAgICAgLy8gYWxlcnQoJz8nKVxuICAgICAgICAgIGFwcC5wb3B1cC4kdXNlck9yaWdpbiA9IHRoaXMuZGF0YS5mcm9tXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9KVxufSkuQ2xhc3NcblxuZXhwb3J0cy5maWx0ZXJDb2xsZWN0aW9uID0gZnVuY3Rpb24oIGVsZW1lbnQsIHNyY2gsIGZpbHRlcikge1xuICBmaWx0ZXIgPSBmaWx0ZXIgfHwge1xuICAgIGNvbmRpdGlvbjoge1xuICAgICAgJG9yOiBbXG4gICAgICB7IHRpdGxlOnsgJGNvbnRhaW5zOnNyY2ggfSB9LFxuICAgICAgeyBjYXRhbG9nOnsgJDogeyB0aXRsZTogeyAkY29udGFpbnM6c3JjaCB9IH0gfSB9LFxuICAgICAgeyBhY3RvcnM6eyAkOiB7IHRpdGxlOiB7ICRjb250YWluczpzcmNoIH0gfSB9IH1cbiAgICAgIF1cbiAgICB9XG4gIH1cbiAgaWYoIGVsZW1lbnQuZmlsdGVyICkge1xuICAgIGVsZW1lbnQuZmlsdGVyLmZpbHRlciA9IGZpbHRlclxuICB9IGVsc2Uge1xuICAgIGVsZW1lbnQuY29sbGVjdGlvbiA9IHsgZmlsdGVyOiBmaWx0ZXIgfVxuICB9ICAgIFxufVxuXG5leHBvcnRzLnRvcFJlc3VsdCA9IGZ1bmN0aW9uKCBsaXN0ICkge1xuICBmb3IodmFyIGkgaW4gbGlzdCkge1xuICAgIGlmKCBsaXN0W2ldLmZpbHRlciAmJiBsaXN0W2ldLmZpbHRlclswXSApIHtcbiAgICAgIHJldHVybiBsaXN0W2ldLmZpbHRlclswXVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnBhcnNlU2VhcmNoID0gZnVuY3Rpb24odmFsKSB7XG4gIGlmKHZhbCAmJiB2YWwuX190ID09PSAyKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cbiAgdmFsID0gdmFsICYmIHZhbC50cmltKCkgfHwgJydcbiAgdmFyIHN0ciA9ICcnO1xuICByZXR1cm4gdmFsXG59IiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvJykgLy8gIHJlcGxhY2UgYXBwIHN0dWZmIHdpdGggcGFyZW50XG52YXIgdWEgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci91YScpXG52YXIgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG52YXIgdmlkZW9VdGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlby91dGlsJylcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vaWNvbicpXG52YXIgX2xpbWl0VXBkYXRlcyA9IHVhLnBsYXRmb3JtID09PSAnaW9zJyB8fCB1YS5wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnXG5cbnZhciBCYXIgPSBuZXcgRWxlbWVudCh7XG4gIGNzczondWktc2Vla2JhcicsXG4gIGJnOnt9LFxuICBzZWVrOnt9XG59KS5DbGFzc1xuXG52YXIgc2Vla2JhciA9IG5ldyBCYXIoeyBcbiAgJ3NlZWsudyc6eyBcbiAgICBkYXRhOid0aW1lJyxcbiAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoY3YpICogMTAwICsgJyUnXG4gICAgfVxuICB9LFxuICBiZzoge1xuICAgIGxvYWRlcmJhcjoge1xuICAgICAgLy8gYXBwZW5kOltFbGVtZW50LHt9LHt9LHt9LHt9LHt9LHt9LHt9LHt9XVxuICAgIH1cbiAgfSxcbiAgZXZlbnRzOlxuICB7IGRvd246IGZ1bmN0aW9uKGUpIHsgXG4gICAgICBlLnRlbXBQcmV2ZW50ID0gdHJ1ZVxuICAgICAgc2V0VGltZS5jYWxsKHRoaXMsIGUpXG4gICAgfSxcbiAgICBkcmFnOiBzZXRUaW1lLFxuICAgIHVwOmNhc2VzLnRvdWNoXG4gICAgPyBmdW5jdGlvbihlKXtcbiAgICAgICAgdmFyIG92ZXJsYXlPcGFjaXR5ID0gdGhpcy5wYXJlbnQucGFyZW50LnBhcmVudC5vcGFjaXR5XG4gICAgICAgIGlmKCF0aGlzLl9za2lwVXApIHNldFRpbWUuY2FsbCh0aGlzLCBlKVxuICAgICAgICBlbHNlIHRoaXMuX3NraXBVcCA9IG51bGxcbiAgICAgIH1cbiAgICA6IHNldFRpbWVcbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gc2Vla2Jhci5DbGFzc1xuXG5leHBvcnRzLkJhciA9IEJhclxuXG5mdW5jdGlvbiBzZXRUaW1lKGUpIHtcblxuICAvLyBjb25zb2xlLmVycm9yKCd4eHh4JylcblxuICB2YXIgcmVjdCA9IHRoaXMubm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICwgeFxuICAgICwgbnJcblxuICBpZih0aGlzLl9sZWZ0KXtcbiAgICB4ID0gcmVjdC50b3BcbiAgICBuciA9IChlLnkteCkvcmVjdC5oZWlnaHRcbiAgfWVsc2UgaWYodGhpcy5fcmlnaHQpe1xuICAgIHggPSByZWN0LnRvcFxuICAgIG5yID0gKHJlY3QuaGVpZ2h0LShlLnkteCkpL3JlY3QuaGVpZ2h0XG4gIH1lbHNle1xuICAgIHggPSByZWN0LmxlZnRcbiAgICBuciA9IChlLngteCkvKHJlY3QucmlnaHQteClcbiAgfVxuXG4gIHZhciB2YWwgPSBuciA+IDEgPyAxIDogbnIgPCAwID8gMCA6IG5yXG4gIGlmKCB2YWwgIT09IHRoaXMuX3ByZXZWYWwgKVxuICB7XG4gICAgdGhpcy5zZWVrLmRhdGEuZnJvbS5zZXQoJ3RpbWUnLHZhbClcbiAgICB0aGlzLl9wcmV2VmFsID0gdmFsXG4gIH1cbn0iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG5cbnZhciBTY29yZSA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOid1aS1zY29yZScsXG4gIHRvcDoge1xuICAgIGluZm86IHtcbiAgICAgICd0aXRsZS50ZXh0LmRhdGEnOiAnc3RhdGlzdGljcy50aXRsZScsXG4gICAgICAnc3VidGl0bGUudGV4dC5kYXRhJzogJ3N0YXRpc3RpY3MuZGF0ZSdcbiAgICB9LFxuICAgIHRlYW1zOiB7XG4gICAgICBsZWZ0OiBuZXcgSW1nKHtcbiAgICAgICAgJ2JhY2tncm91bmQuZGF0YSc6ICdzdGF0aXN0aWNzLmxlZnQuaW1nJ1xuICAgICAgfSksXG4gICAgICByaWdodDpuZXcgSW1nKHtcbiAgICAgICAgJ2JhY2tncm91bmQuZGF0YSc6ICdzdGF0aXN0aWNzLnJpZ2h0LmltZydcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICBib2R5OiB7XG4gICAgJ2xlZnQudGV4dC5kYXRhJzogJ3N0YXRpc3RpY3MubGVmdC5wb2ludHMnLFxuICAgIG1pZGRsZWxlZnQ6IHtcbiAgICAgICd0aXRsZS50ZXh0LmRhdGEnOiAnc3RhdGlzdGljcy5sZWZ0LmFjcm9ueW0nLFxuICAgICAgJ3N1YnRpdGxlLnRleHQuZGF0YSc6ICdzdGF0aXN0aWNzLmxlZnQuaW5uaW5ncydcbiAgICB9LFxuICAgIG1pZGRsZXJpZ2h0OiB7XG4gICAgICAndGl0bGUudGV4dC5kYXRhJzogJ3N0YXRpc3RpY3MucmlnaHQuYWNyb255bScsXG4gICAgICAnc3VidGl0bGUudGV4dC5kYXRhJzogJ3N0YXRpc3RpY3MucmlnaHQuaW5uaW5ncydcbiAgICB9LFxuICAgICdyaWdodC50ZXh0LmRhdGEnOiAnc3RhdGlzdGljcy5yaWdodC5wb2ludHMnLFxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3VpLXN0YXRpc3RpY3MnLFxuICBkaXNwbGF5OntcbiAgICBkYXRhOidzdGF0aXN0aWNzLnRpdGxlJyxcbiAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICByZXR1cm4gY3YgPyAnYmxvY2snIDogJ25vbmUnXG4gICAgfVxuICB9LFxuICAnaGVhZGVyLnRleHQnOiAnU3RhdGlzdGljcycsXG4gIGJvZHk6bmV3IFNjb3JlKClcbn0pLkNsYXNzXG5cbmV4cG9ydHMuU2NvcmUgPSBTY29yZSIsInZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIHRleHQ6IHtcbiAgICBkYXRhOiAnc3VidGl0bGUnLFxuICAgIGFkZDogW1xuICAgICAgJy4nLCB7XG4gICAgICAgIGRhdGE6ICd5ZWFyJyxcbiAgICAgICAgYWRkOiBbJyAtICcsIHtcbiAgICAgICAgICBkYXRhOiAnZHVyYXRpb24nLFxuICAgICAgICAgIGRpdmlkZTogNjAsXG4gICAgICAgICAgZmxvb3I6IHRydWUsXG4gICAgICAgICAgYWRkOiAnIE1pbnV0ZXMnXG4gICAgICAgIH1dXG4gICAgICB9LFxuICAgICAgJy4nLCB7XG4gICAgICAgIGRhdGE6ICdndWlkZS4wLnN0YXJ0LXRpbWUnLFxuICAgICAgICBhZGQ6IFsnIC0gJywge1xuICAgICAgICAgIGRhdGE6ICdndWlkZS4wLmVuZC10aW1lJ1xuICAgICAgICB9XVxuICAgICAgfVxuICAgIF0sXG4gICAgdHJhbnNmb3JtOiBmdW5jdGlvbih2LCBjdikge1xuICAgICAgdmFyIGFyciA9IGN2LnNwbGl0KCcuJylcbiAgICAgIHZhciBsID0gYXJyLmxlbmd0aCAtIDFcbiAgICAgIHZhciBzdHIgPSBhcnJbbF1cbiAgICAgIHdoaWxlIChzdHJbMV0gPT09ICctJyB8fCAoc3RyWzVdID09PSAnLScgJiYgc3RyWzddID09PSAnICcpKSB7IC8vZGlydHkhXG4gICAgICAgIHN0ciA9IGFyclstLWxdXG4gICAgICB9XG4gICAgICBpZiAoc3RyKSByZXR1cm4gc3RyXG5cbiAgICAgIHZhciBmcm9tID0gdGhpcy5kYXRhICYmIHRoaXMuZGF0YS5mcm9tXG4gICAgICBpZiAoZnJvbSkge1xuICAgICAgICB2YXIgZXBpc29kZSA9IChmcm9tLl9uYW1lIHwgMCkgKyAxXG4gICAgICAgIHZhciBzZWFzb24gPSAoZnJvbS5fcGFyZW50Ll9wYXJlbnQuX25hbWUgfCAwKSArIDFcbiAgICAgICAgcmV0dXJuICdTZWFzb24gJyArIHNlYXNvbiArICcgLSAnICsgJ0VwaXNvZGUgJyArIGVwaXNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICAndGV4dC5kZWZhdWx0LmRhdGEnOid0aXRsZSdcbn0pLkNsYXNzXG5cbmV4cG9ydHMuU2hvdyA9IG5ldyBleHBvcnRzKHtcbiAgJ3RleHQuZGF0YSc6J3Nob3cudGl0bGUnXG59KS5DbGFzc1xuXG4vLyBleHBvcnRzLlByb2dyYW0gPSBuZXcgZXhwb3J0cyh7XG4vLyAgICd0ZXh0LmRhdGEnOidndWlkZS4wLnRpdGxlJ1xuLy8gfSkuQ2xhc3Ncbi8vIGV4cG9ydHMuVG9wYmFyID0gbmV3IGV4cG9ydHMuU2hvdyh7XG5cbi8vIH0pIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgQVNTRVRTID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvY29uZmlnJykucG9pbnRlcnMuYXNzZXRzXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICd1aS10cml2aWEnLFxuICAnaGVhZGVyLnRleHQnOiAnVHJpdmlhJyxcbiAgZGlzcGxheTp7XG4gICAgZGF0YTondHJpdmlhLnRpdGxlJyxcbiAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICByZXR1cm4gY3YgPyAnYmxvY2snIDogJ25vbmUnXG4gICAgfVxuICB9LFxuICBib2R5OiB7XG4gICAgYmFja2dyb3VuZDogeyBcbiAgICAgIGRhdGE6ICdpbWcnLFxuICAgICAgcHJlcGVuZDogQVNTRVRTXG4gICAgfSxcbiAgICAndGl0bGUudGV4dC5kYXRhJzogJ3RyaXZpYS50aXRsZScsXG4gICAgJ3N1YnRpdGxlLnRleHQuZGF0YSc6ICd0cml2aWEuc3VidGl0bGUnLFxuICAgICdkZXNjcmlwdGlvbi50ZXh0LmRhdGEnOiAndHJpdmlhLmRlc2NyaXB0aW9uJ1xuICB9XG59KS5DbGFzc1xuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG5cbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxuXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG5cbnZhciB0d2VldCA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAndHdlZXQnLFxuICBpY29uOiBuZXcgSWNvbih7aWNvbjondHdpdHRlcid9KSxcbiAgZnJvbTogeyB0ZXh0OiB7IHZhbDogJ0AnLCBhZGQ6IHsgZGF0YTogJ2F1dGhvcicgfSB9IH0sXG4gIG1zZzogeyB0ZXh0OiB7IGRhdGE6ICdib2R5JyB9IH0sXG4gIHJldHdlZXQ6IHsgdGV4dDogJ1JFVFdFRVQnIH1cbn0pXG5cbnZhciBUd2VldHMgPSBuZXcgRWxlbWVudCh7XG4gICAgY3NzOiAndWktdHdlZXRzJyxcbiAgICBkaXNwbGF5OntcbiAgICAgIGRhdGE6J3R3ZWV0cycsXG4gICAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICAgIHJldHVybiBjdiA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgIH1cbiAgICB9LFxuICAgIGhlYWRlcjogeyB0ZXh0OiAnVHdlZXRzJyB9LFxuICAgIGhvbGRlcnQ6IHsgLy93ZWlyZCBuYW1lLi4uLiBob2xkZXIgaXMgYSBjbGFzc1xuICAgICAgc2Nyb2xsYmFyOiAneCcsXG4gICAgICBib2R5OiB7XG4gICAgICAgIGNvbGxlY3Rpb246IHtcbiAgICAgICAgICBkYXRhOiAndHdlZXRzJyxcbiAgICAgICAgICBlbGVtZW50OiB0d2VldFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBUd2VldHNcbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOid1aS13YWxscGFwZXInXG59KS5DbGFzc1xuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNSwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xuXG5yZXF1aXJlKCAnLi9zdHlsZS5sZXNzJyApXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInIClcbiAgICAuaW5qZWN0KCByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlci90cmFuc2l0aW9ucycgKSApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBjYXNlcyA9IGFwcC5jYXNlc1xudmFyIFdhbGxwYXBlciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3dhbGxwYXBlcicpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBTd2l0Y2hlcigge1xuICBjc3M6J2FwcC1zd2l0Y2hlcicsXG4gIG9uOiB7XG4gICAgc3RhdGU6IHsgLy9zdGF0ZSBsZWtrZXIgZXh0ZW5kZWRcbiAgICAgIGRlZmVyOiBmdW5jdGlvbiggdXBkYXRlICkge1xuICAgICAgICB2YXIgb24gPSB0aGlzLl9wYXJlbnRcbiAgICAgICAgdmFyIHN3aXRjaGVyID0gb24uX2NhbGxlclxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmZyb20udmFsXG4gICAgICAgIFxuICAgICAgICBpZiggc3RhdGU9PT0nc2Vjb25kJyApIHtcblxuICAgICAgICAgIHN3aXRjaGVyLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgICBlbGVtZW50OnJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL2luYWN0aXZlJyksXG4gICAgICAgICAgICAkcGFyYW1zOnsgXG4gICAgICAgICAgICAgICRoaWdobGlnaHQ6b24uaGlnaGxpZ2h0Ll92YWwsXG4gICAgICAgICAgICAgICRwcmV2aWV3Om9uLnByZXZpZXcuX3ZhbCxcbiAgICAgICAgICAgICAgJG1lZGlhOmFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLFxuICAgICAgICAgICAgICAkcGFnZTpvbi5uYXZpZ2F0aW9uLl92YWwucGFnZSxcbiAgICAgICAgICAgICAgJGNvbnRlbnQ6b24ubmF2aWdhdGlvbi5fdmFsLmNvbnRlbnQsXG4gICAgICAgICAgICAgIG5hdmlnYXRpb246e1xuICAgICAgICAgICAgICAgIGRhdGE6YXBwLmNvbnRlbnQuZ2V0KCdkaXNjb3ZlcicpLFxuICAgICAgICAgICAgICAgICRmb2N1czpvbi5mb2N1cy5fdmFsLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjp7XG4gICAgICAgICAgICAgICAgICBwcm9ncmVzczp7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6b24ucHJldmlldy5fdmFsXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICRwcm9ncmVzczphcHAucHJvZ3Jlc3NcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9IGVsc2UgaWYoIHN0YXRlPT09J2ZpcnN0JyApIHtcblxuICAgICAgICAgIHN3aXRjaGVyLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgICBlbGVtZW50OnJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL2FjdGl2ZScpLFxuICAgICAgICAgICAgJHBhcmFtczp7XG4gICAgICAgICAgICAgIG1lbnU6IHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uOiBhcHAudXNlci5uYXZpZ2F0aW9uXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uOntcbiAgICAgICAgICAgICAgICBmb2N1czpvbi5mb2N1cy5fdmFsLFxuICAgICAgICAgICAgICAgIHBvcHVwOm9uLnBvcHVwLl92YWwsXG4gICAgICAgICAgICAgICAgc2Vjb25kUG9wdXA6b24uc2Vjb25kUG9wdXAuX3ZhbFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBob2xkZXI6e1xuICAgICAgICAgICAgICAgIHRvcGJhcjp7XG4gICAgICAgICAgICAgICAgICAkY3VycmVudDogYXBwLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzd2l0Y2hlcjp7XG4gICAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uOiBhcHAudXNlci5uYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtaW5pcGxheWVyOntcbiAgICAgICAgICAgICAgICAgIG1lZGlhOmFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLFxuICAgICAgICAgICAgICAgICAgcGxheWluZzphcHAudXNlci5yZWNlaXZlci5wbGF5aW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiggc3RhdGUgPT09ICdpbmFjdGl2ZScpe1xuICAgICAgICBcbiAgICAgICAgICBzd2l0Y2hlci50cmFuc2l0aW9uID0ge1xuICAgICAgICAgICAgZWxlbWVudDpXYWxscGFwZXIsXG4gICAgICAgICAgICAkcGFyYW1zOnt9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICB1cGRhdGUoKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgb25UcmFuc2l0aW9uOidmYWRlJ1xufSApLkNsYXNzXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE1LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG5leHBvcnRzLmZvY3VzZWQgPSBmdW5jdGlvbiggaG9sZGVyLCBmb2N1c2VkLCBtZXRob2QgKSB7XG4gIGlmICggZm9jdXNlZCApIHtcbiAgICBcbiAgICB2YXIgcHJldmlvdXMgPSBob2xkZXIuX2ZvY3VzZWRcblxuICAgIGlmICggcHJldmlvdXMgIT09IGZvY3VzZWQgKSB7XG5cbiAgICAgIGlmICggcHJldmlvdXMgKSB7XG4gICAgICAgIHByZXZpb3VzLmNzcyA9IHtcbiAgICAgICAgICByZW1vdmVDbGFzczogJ2ZvY3VzZWQnXG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXMuJGZvY3VzZWQgPSBmYWxzZVxuICAgICAgfVxuXG4gICAgICBmb2N1c2VkLmNzcyA9IHtcbiAgICAgICAgYWRkQ2xhc3M6ICdmb2N1c2VkJ1xuICAgICAgfVxuXG4gICAgICBmb2N1c2VkLiRmb2N1c2VkID0gdHJ1ZVxuXG4gICAgICBpZiAoIG1ldGhvZCApIG1ldGhvZCggZm9jdXNlZCwgcHJldmlvdXMgKVxuXG4gICAgICBob2xkZXIuX2ZvY3VzZWQgPSBmb2N1c2VkXG4gICAgfVxuXG4gIH1cbn1cblxuZXhwb3J0cy5wcmV2ZW50QW5pbWF0aW9uID0gZnVuY3Rpb24oIF90aGlzLCBtZXRob2QsIGRvbmUgKXtcbiAgX3RoaXMuX2Jsb2NrZWQgPSB0cnVlXG4gIF90aGlzLmNzcyA9IHthZGRDbGFzczonZG9udEFuaW1hdGUnfVxuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgbWV0aG9kKClcbiAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICBfdGhpcy5jc3MgPSB7cmVtb3ZlQ2xhc3M6J2RvbnRBbmltYXRlJ31cbiAgICAgIF90aGlzLl9ibG9ja2VkID0gbnVsbFxuICAgICAgaWYoIGRvbmUgKSBkb25lKClcbiAgICB9KVxuICB9KVxufSIsInZhciBhcHAgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9hcHAnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvdXJsJylcbnZhciB1YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL3VhJylcbnZhciBkZXZpY2UgPSB1cmwucGFyYW1zLmRldmljZSAmJiB1cmwucGFyYW1zLmRldmljZS52YWwgfHwgdWEuZGV2aWNlXG5cbnZhciBjbGllbnRpbmZvID0ge1xuICBwaG9uZToge1xuICAgIHRpdGxlOiAnS2V2aW5cXCdzIGlQaG9uZScsXG4gICAgaW5mbzogJ2lQaG9uZSA2J1xuICB9LFxuICBpcGFkOiB7XG4gICAgdGl0bGU6ICdLZXZpblxcJ3MgaVBhZCcsXG4gICAgaW5mbzogJ2lQYWQgMicsXG4gICAgZGV2aWNlOiAndGFibGV0J1xuICB9LFxuICB0djoge1xuICAgIHRpdGxlOiAnU2hhcnAnLFxuICAgIGluZm86ICc1MlwiIExFRCBUVicsXG4gICAgZGV2aWNlOiAndHYnXG4gIH0sXG4gIHRhYmxldDoge1xuICAgIHRpdGxlOiAnVW5pdGVkIEFpcmxpbmVzJyxcbiAgICBpbmZvOiAnSW4gRmxpZ2h0IEVudGVydGFpbm1lbnQnLFxuICAgIGRldmljZTogJ0lGRSdcbiAgfSxcbiAgZGVmOiB7XG4gICAgdGl0bGU6IHVhLnBsYXRmb3JtKycgJytkZXZpY2UsXG4gICAgaW5mbzogdWEucGxhdGZvcm0rJyAnK2RldmljZSxcbiAgICBkZXZpY2U6ZGV2aWNlXG4gIH1cbn1cblxuYXBwLmNsb3VkLmNsaWVudC52YWwgPSBjbGllbnRpbmZvW2RldmljZV0gfHwgY2xpZW50aW5mby5kZWYiLCJyZXF1aXJlKCcuL3VhaGFjaycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvYXBwJylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3N3aXRjaGVyJylcbnZhciB1c2VyID0gYXBwLnVzZXJcblxuaWYoYXBwLmNhc2VzLiRpc05hdGl2ZSl7XG4gIHZhciBzdGF0dXNCYXIgPSByZXF1aXJlKCd2aWdvdXItbmF0aXZlLXN0YXR1c0JhcicpXG4gIHN0YXR1c0Jhci5zZXQoe1xuICAgIHN0eWxlOidsaWdodCcsXG4gICAgdmlzaWJpbGl0eTonb3ZlcmxheSdcbiAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIpIGFsZXJ0KFwiZXJyb3Igc2V0dGluZyBzdGF0dXNCYXI6IFwiICtlcnIpXG4gIH0pXG59XG5cbi8vIHN3aXRjaGVyIGJldHdlZW4gZmlyc3Qvc2Vjb25kL3BsYXllclxuXG4vLyBhcHAucmVhZHkub25jZSh0cnVlLGZ1bmN0aW9uKCl7XG5cbnJlcXVpcmUoJy4vY2xpZW50aGFjaycpXG5cbi8vIGFwcC5yZWFkeS5vbmNlKHRydWUsZnVuY3Rpb24oKXtcblxuYXBwLnNldCh7XG4gIHN3aXRjaGVyOiBuZXcgU3dpdGNoZXIoIHtcbiAgICBvbjoge1xuICAgICAgbmF2aWdhdGlvbjogdXNlci5uYXZpZ2F0aW9uLFxuICAgICAgcGxheTogYXBwLnBsYXlpbmcsXG4gICAgICByZWNlaXZlcjogdXNlci5yZWNlaXZlcixcbiAgICAgIHVzYWdlOiB1c2VyLnVzYWdlLFxuICAgICAgY29udGVudDogYXBwLmNvbnRlbnQsXG4gICAgICBzZWFyY2g6IHVzZXIuc2VhcmNoLFxuICAgICAgZm9jdXM6IHVzZXIuZm9jdXNfcm93LFxuICAgICAgcHJldmlldzogYXBwLnByZXZpZXcsXG4gICAgICBoaWdobGlnaHQ6IGFwcC5oaWdobGlnaHQsXG4gICAgICBwb3B1cDphcHAucG9wdXAsXG4gICAgICBzZWNvbmRQb3B1cDphcHAuc2Vjb25kUG9wdXAsXG4gICAgICAvL25hdiB3b3JkIGRpZmZlcmVudFxuICAgICAgLy8gd2F0Y2hlZDogdXNlci53YXRjaGVkLmZyb20sXG4gICAgICBzdGF0ZTogYXBwLnN0YXRlLFxuICAgICAgb3ZlcmxheTogYXBwLm92ZXJsYXksXG4gICAgICBsb2FkaW5nOiBhcHAubG9hZGluZyxcbiAgICAgIGFjdGl2ZUNsaWVudDogdXNlci5hY3RpdmVDbGllbnQsXG4gICAgICB2b2x1bWU6IGFwcC52b2x1bWVcbiAgICB9XG4gIH0pXG59KVxuXG5cbi8vIFRPRE86IHJlbmFtZSBhcHAuaW5pdGlhbGl6ZWQ/XG5cbi8vIGFwcC5wb3B1cC52YWwgPSAnYWN0b3InXG4vLyBhcHAubWVudS52YWwgPSB0cnVlXG4vLyB9KVxuXG5hcHAuaW5pdGlhbGlzZWQudmFsID0gdHJ1ZVxuXG5cbi8vIGFwcC5yZWFkeS5pcyh0cnVlLGZ1bmN0aW9uKCl7XG4vLyAgIGFwcC5zZWNvbmRQb3B1cC52YWwgPSAndm9sdW1lJ1xuLy8gfSx0cnVlKSIsInZhciB1YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL3VhJylcbnZhciBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcblxuY29uc29sZS5sb2coJy0tLS0tLS0tLS0tLS0tLS0gdWEgaGFja2luZyB0aGF0IScsIHVhKVxuXG5cbmlmKHVhLmRldmljZSA9PT0gJ2Rlc2t0b3AnKSB7XG4gIGNvbnNvbGUubG9nKCdoYWNrIGRhdCBkZXNrdG9wJylcbiAgdWEuZGV2aWNlID0gJ3R2J1xuICB1YS5wbGF0Zm9ybSA9ICdmYW5jeSdcbiAgY2FzZXMuJGlzRGVza3RvcCA9IGZhbHNlXG4gIGNvbnNvbGUubG9nKCdsb2wgc2V0IGRhdCB0diB0cmV1cycpXG4gIGNhc2VzLiRpc1R2ID0gdHJ1ZVxuXG4gIHdpbmRvdy5JTkFDVElWRSA9IHRydWVcbn0gZWxzZSBpZih1YS5kZXZpY2UgPT09ICdpcGFkJykge1xuICB3aW5kb3cuSU5BQ1RJVkUgPSB0cnVlXG5cbn1cbiIsIm1vZHVsZS5leHBvcnRzPXtcIm5hbWVcIjpcImRpcmVjdHYtZmxcIixcInZlcnNpb25cIjpcIjIwMTUvMDYvMDggMTc6MTk6MDEgVVRDICgxLjAuMylcIixcImRlc2NyaXB0aW9uXCI6XCJcIixcIm1haW5cIjpcImluZGV4LmpzXCIsXCJzY3JpcHRzXCI6e1wic3RhcnRHYXN0b25cIjpcIi4vbm9kZV9tb2R1bGVzLy5iaW4vZ2FzdG9uIGRldlwiLFwic3RhcnRcIjpcIm5wbSBydW4gc3RhcnRHYXN0b25cIixcInRlc3RcIjpcImVjaG8gXFxcIkVycm9yOiBubyB0ZXN0IHNwZWNpZmllZFxcXCIgJiYgZXhpdCAxXCIsXCJzeW1saW5rXCI6XCJta2RpciAtcCBub2RlX21vZHVsZXM7IGxuIC1zZiAkKHB3ZCkgJChwd2QpL25vZGVfbW9kdWxlc1wiLFwic3RhcnRIdWJcIjpcIi4vbm9kZV9tb2R1bGVzL3ZpZ291ci1odWIvYmluL2h1YiAtZCAtYyBkaXJlY3R2XCIsXCJwcmVzdGFydFwiOlwibnBtIHJ1biBzdGFydEh1YiAmXCIsXCJidWlsZFwiOlwidk5hdGl2ZSBidWlsZFwiLFwicmVsZWFzZVwiOlwicGFja2VyIC1yIC1jIHBhY2thZ2UuanNvbiwucGFja2FnZS5qc29uXCJ9LFwicmVwb3NpdG9yeVwiOntcInR5cGVcIjpcImdpdFwiLFwidXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vdmlnb3VyLWlvL2RpcmVjdHYtZmwuZ2l0XCIsXCJicmFuY2hcIjpcIm1hc3RlclwifSxcImF1dGhvclwiOlwiVmlnb3VyXCIsXCJidWdzXCI6e1widXJsXCI6XCJodHRwczovL2dpdGh1Yi5jb20vdmlnb3VyLWlvL2RpcmVjdHYtZmwvaXNzdWVzXCJ9LFwiaG9tZXBhZ2VcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vZGlyZWN0di1mbFwiLFwiZGVwZW5kZW5jaWVzXCI6e1widGhyb3VnaDJcIjpcIipcIixcImxvZGFzaFwiOlwiMy4yLjBcIixcIm1vbm90b25pYy10aW1lc3RhbXBcIjpcIjAuMC45XCIsXCJwcm9taXNlXCI6XCJeNy4wLjFcIixcInZpZ291ci1qc1wiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tOnZpZ291ci1pby92aWdvdXItanMuZ2l0I2RpcmVjdHZcIn0sXCJkZXZEZXBlbmRlbmNpZXNcIjp7XCJ2aWdvdXItbmF0aXZlXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb206dmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUuZ2l0XCIsXCJ2aWdvdXItbmF0aXZlLXN0YXR1c0JhclwiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tOnZpZ291ci1pby92aWdvdXItbmF0aXZlLXN0YXR1c0Jhci5naXRcIixcInZpZ291ci1wYWNrZXItc2VydmVyXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb206dmlnb3VyLWlvL3ZpZ291ci1wYWNrZXItc2VydmVyLmdpdFwiLFwidmlnb3VyLWh1YlwiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tOnZpZ291ci1pby92aWdvdXItaHViLmdpdCNkaXJlY3R2XCIsXCJnYXN0b25cIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbTp2aWdvdXItaW8vZ2FzdG9uLmdpdFwifSxcInZpZ291clwiOntcImNsb3VkXCI6XCJodHRwOi8vZGlyZWN0di5kZXYudmlnb3VyLmlvOjgwXCIsXCJicmFuY2hlc1wiOntcInlvdXppLWRldlwiOntcImNsb3VkXCI6XCJodHRwOi8vMTAuMC4xLjI6MTAwMDFcIn0sXCJtYXJjdXMtZGV2XCI6e1wiY2xvdWRcIjpcImh0dHA6Ly8xMC4wLjEuMTk5OjEwMDAxXCJ9LFwic2hhd24tZGV2XCI6e1wiY2xvdWRcIjpcImh0dHA6Ly8xOTIuMTY4LjIuMTg6MTAwMDFcIn19LFwiZGV2ZWxvcG1lbnRcIjp7XCJidXR0b25cIjpmYWxzZX0sXCJwb2ludGVyc1wiOntcImltZ1wiOlwiaHR0cDovL2RldmFzc2V0cy52aWdvdXIuaW8vXCIsXCJhc3NldHNcIjpcImh0dHA6Ly9kZXZhc3NldHMudmlnb3VyLmlvL1wifSxcInBhY2tlclwiOntcIndlYlwiOlwiaW5kZXguaHRtbFwiLFwiYXNzZXRzXCI6e1wiYnVuZGxlLmpzXCI6dHJ1ZSxcImJ1bmRsZS5jc3NcIjp0cnVlLFwiaW5kZXguaHRtbFwiOnRydWUsXCJhc3NldHNcIjpcIipcIixcImZvbnRzLmNzc1wiOnRydWV9LFwiZ2l0XCI6e1wib3duZXJcIjpcInZpZ291ci1pb1wiLFwicmVwb1wiOlwiZGlyZWN0di1mbFwifSxcIm1haWxcIjp7XCJmcm9tQWRkcmVzc1wiOlwic2hhd25Admlnb3VyLmlvXCIsXCJ0b1wiOlwic2hhd25Admlnb3VyLmlvXCJ9LFwic2xhY2tcIjp7fSxcInNlcnZlclwiOnt9fSxcIm5hdGl2ZVwiOntcInBsYXRmb3Jtc1wiOntcImlvc1wiOntcInByb2R1Y3ROYW1lXCI6XCJEaXJlY3QgVFYgLSBGdXR1cmUgTGFuZFwiLFwib3JnYW5pemF0aW9uTmFtZVwiOlwiVmlnb3VyXCIsXCJvcmdhbml6YXRpb25JZGVudGlmaWVyXCI6XCJpby52aWdvdXIuZGlyZWN0di1mbFwiLFwiYnVpbGROdW1iZXJcIjpcIjFcIixcImFwcEluZGV4UGF0aFwiOlwiaW5kZXguaHRtbFwiLFwiYXBwVXJsSWRlbnRpZmllclwiOlwiY29tLmRpcmVjdHYtZmwub3JnXCIsXCJhcHBVcmxTY2hlbWVcIjpcImRpcmVjdHYtZmxcIn19fX0sXCJnYXN0b25cIjp7XCJicm93c2VyaWZ5LXRyYW5zZm9ybXNcIjpbe1wicGF0aFwiOlwidmlnb3VyLWpzL3V0aWwvaW5mb3JtLXRyYW5zZm9ybVwiLFwib3B0aW9uc1wiOntcImdsb2JhbFwiOlwiZmFsc2VcIn19XSxcInJlcXVpcmUtcGF0aHNcIjp7XCJkdHZcIjpcInNyY1wiLFwic2hhcmVkXCI6XCJzcmMvY29tcG9uZW50cy9zaGFyZWRcIixcImR0di1jb21wb25lbnRzXCI6XCJzcmMvY29tcG9uZW50c1wiLFwiZHR2LWFjdGl2ZVwiOlwic3JjL2NvbXBvbmVudHMvYWN0aXZlXCIsXCJkdHYtaXRlbVwiOlwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2NvbnRlbnQtaXRlbVwiLFwiZHR2LWNoYW5uZWxcIjpcInNyYy9jb21wb25lbnRzL2FjdGl2ZS9jb250ZW50LWl0ZW0vY2hhbm5lbFwiLFwiZHR2LWVwaXNvZGVcIjpcInNyYy9jb21wb25lbnRzL2FjdGl2ZS9jb250ZW50LWl0ZW0vZXBpc29kZVwiLFwiZHR2LW1vdmllXCI6XCJzcmMvY29tcG9uZW50cy9hY3RpdmUvY29udGVudC1pdGVtL21vdmllXCJ9fSxcInNoYVwiOlwiMS4wLjNcIn0iXX0=
