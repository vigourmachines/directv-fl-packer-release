require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/Users/shawn/Work/directv-fl/config.js":[function(require,module,exports){
window.name = 'directv-fl'

// window.package = require('package.json')
// console.log('wtf...', window.package)

module.exports = exports = require( 'vigour-js/util/config' )
              .inject
              ( { 'repository.branch': 'branches' }
              , require( 'vigour-js/util/config/ua' )
              )

exports( function( result ) {
  for(var key in result) {
    // console.log('\n', i, result[i])
    exports[key] = result[key] 
  }
  exports.parsed = true

}, false, window.package, true )
},{"vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js","vigour-js/util/config/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/ua.js"}],"/Users/shawn/Work/directv-fl/index.js":[function(require,module,exports){


// window.__ua__ = {
//   device:'tablet'
// }

window.package = require('package.json');
var config = require('/Users/shawn/Work/directv-fl//config')
  , remote


if( config.development && config.development.button )
{
  remote = require( 'vigour-js/util/debug' )
            .native( false, false, function(url) {} , 'bundle' )
}

if( !remote ) 
{
  var cases = require( 'vigour-js/browser/cases' )
    , ua = require( 'vigour-js/browser/ua' )

  // if(ua.device === 'tablet'){
  //   var viewport = document.querySelector("meta[name=viewport]")
  //   viewport.setAttribute('content', 'width=device-width, initial-scale=0.6, maximum-scale=1.0, user-scalable=0');
  // }

  require( './src/main' )
  
}
},{"./src/main":"/Users/shawn/Work/directv-fl/src/main/index.js","/Users/shawn/Work/directv-fl//config":"/Users/shawn/Work/directv-fl/config.js","package.json":"package.json","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/util/debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js":[function(require,module,exports){

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/domain-browser/index.js":[function(require,module,exports){
/*global define:false require:false */
module.exports = (function(){
	// Import Events
	var events = require('events')

	// Export Domain
	var domain = {}
	domain.createDomain = domain.create = function(){
		var d = new events.EventEmitter()

		function emitError(e) {
			d.emit('error', e)
		}

		d.add = function(emitter){
			emitter.on('error', emitError)
		}
		d.remove = function(emitter){
			emitter.removeListener('error', emitError)
		}
		d.bind = function(fn){
			return function(){
				var args = Array.prototype.slice.call(arguments)
				try {
					fn.apply(null, args)
				}
				catch (err){
					emitError(err)
				}
			}
		}
		d.intercept = function(fn){
			return function(err){
				if ( err ) {
					emitError(err)
				}
				else {
					var args = Array.prototype.slice.call(arguments, 1)
					try {
						fn.apply(null, args)
					}
					catch (err){
						emitError(err)
					}
				}
			}
		}
		d.run = function(fn){
			try {
				fn()
			}
			catch (err) {
				emitError(err)
			}
			return this
		};
		d.dispose = function(){
			this.removeAllListeners()
			return this
		};
		d.enter = d.exit = function(){
			return this
		}
		return d
	};
	return domain
}).call(this)
},{"events":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/events/events.js"}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/inherits/inherits_browser.js":[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/os-browserify/browser.js":[function(require,module,exports){
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/support/isBufferBrowser.js":[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/util.js":[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/support/isBufferBrowser.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","inherits":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/inherits/inherits_browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js":[function(require,module,exports){
// If `Date.now()` is invoked twice quickly, it's possible to get two
// identical time stamps. To avoid generation duplications, subsequent
// calls are manually ordered to force uniqueness.

var _last = 0
var _count = 1
var adjusted = 0
var _adjusted = 0

module.exports =
function timestamp() {
  /**
  Returns NOT an accurate representation of the current time.
  Since js only measures time as ms, if you call `Date.now()`
  twice quickly, it's possible to get two identical time stamps.
  This function guarantees unique but maybe inaccurate results
  on each call.
  **/
  //uncomment this wen
  var time = Date.now()
  //time = ~~ (time / 1000) 
  //^^^uncomment when testing...

  /**
  If time returned is same as in last call, adjust it by
  adding a number based on the counter. 
  Counter is incremented so that next call get's adjusted properly.
  Because floats have restricted precision, 
  may need to step past some values...
  **/
  if (_last === time)  {
    do {
      adjusted = time + ((_count++) / (_count + 999))
    } while (adjusted === _adjusted)
    _adjusted = adjusted
  }
  // If last time was different reset timer back to `1`.
  else {
    _count = 1
    adjusted = time
  }
  _adjusted = adjusted
  _last = time
  return adjusted
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/promise/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./lib')

},{"./lib":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js":[function(require,module,exports){
'use strict';

var asap = require('asap/raw');

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// All `_` prefixed properties will be reduced to `_{random number}`
// at build time to obfuscate them and discourage their use.
// We don't use symbols or Object.defineProperty to fully hide them
// because the performance isn't good enough.


// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};
function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}
function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

module.exports = Promise;

function Promise(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('not a function');
  }
  this._32 = 0;
  this._8 = null;
  this._89 = [];
  if (fn === noop) return;
  doResolve(fn, this);
}
Promise._83 = noop;

Promise.prototype.then = function(onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
};
function handle(self, deferred) {
  while (self._32 === 3) {
    self = self._8;
  }
  if (self._32 === 0) {
    self._89.push(deferred);
    return;
  }
  asap(function() {
    var cb = self._32 === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._32 === 1) {
        resolve(deferred.promise, self._8);
      } else {
        reject(deferred.promise, self._8);
      }
      return;
    }
    var ret = tryCallOne(cb, self._8);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}
function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(
      self,
      new TypeError('A promise cannot be resolved with itself.')
    );
  }
  if (
    newValue &&
    (typeof newValue === 'object' || typeof newValue === 'function')
  ) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (
      then === self.then &&
      newValue instanceof Promise
    ) {
      self._32 = 3;
      self._8 = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._32 = 1;
  self._8 = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._32 = 2;
  self._8 = newValue;
  finale(self);
}
function finale(self) {
  for (var i = 0; i < self._89.length; i++) {
    handle(self, self._89[i]);
  }
  self._89 = null;
}

function Handler(onFulfilled, onRejected, promise){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) return;
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) return;
    done = true;
    reject(promise, reason);
  })
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

},{"asap/raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/done.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this;
  self.then(null, function (err) {
    setTimeout(function () {
      throw err;
    }, 0);
  });
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/es6-extensions.js":[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js');
var asap = require('asap/raw');

module.exports = Promise;

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new Promise(Promise._83);
  p._32 = 1;
  p._8 = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) return value;

  if (value === null) return NULL;
  if (value === undefined) return UNDEFINED;
  if (value === true) return TRUE;
  if (value === false) return FALSE;
  if (value === 0) return ZERO;
  if (value === '') return EMPTYSTRING;

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([]);
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._32 === 3) {
            val = val._8;
          }
          if (val._32 === 1) return res(i, val._8);
          if (val._32 === 2) reject(val._8);
          val.then(function (val) {
            res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","asap/raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/finally.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js');

module.exports = Promise;
Promise.prototype['finally'] = function (f) {
  return this.then(function (value) {
    return Promise.resolve(f()).then(function () {
      return value;
    });
  }, function (err) {
    return Promise.resolve(f()).then(function () {
      throw err;
    });
  });
};

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./core.js');
require('./done.js');
require('./finally.js');
require('./es6-extensions.js');
require('./node-extensions.js');

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","./done.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/done.js","./es6-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/es6-extensions.js","./finally.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/finally.js","./node-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/node-extensions.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/lib/node-extensions.js":[function(require,module,exports){
'use strict';

// This file contains then/promise specific extensions that are only useful
// for node.js interop

var Promise = require('./core.js');
var asap = require('asap');

module.exports = Promise;

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity;
  return function () {
    var self = this;
    var args = Array.prototype.slice.call(arguments);
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop();
      }
      args.push(function (err, res) {
        if (err) reject(err);
        else resolve(res);
      })
      var res = fn.apply(self, args);
      if (res &&
        (
          typeof res === 'object' ||
          typeof res === 'function'
        ) &&
        typeof res.then === 'function'
      ) {
        resolve(res);
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments);
    var callback =
      typeof args[args.length - 1] === 'function' ? args.pop() : null;
    var ctx = this;
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx);
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) {
          reject(ex);
        });
      } else {
        asap(function () {
          callback.call(ctx, ex);
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this;

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value);
    });
  }, function (err) {
    asap(function () {
      callback.call(ctx, err);
    });
  });
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-asap.js":[function(require,module,exports){
"use strict";

// rawAsap provides everything we need except exception management.
var rawAsap = require("./raw");
// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
module.exports = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    rawAsap(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

},{"./raw":"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-raw.js"}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/browser-raw.js":[function(require,module,exports){
(function (global){
"use strict";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.jss
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// ASAP was originally a nextTick shim included in Q. This was factored out
// into this ASAP package. It was later adapted to RSVP which made further
// amendments. These decisions, particularly to marginalize MessageChannel and
// to capture the MutationObserver implementation in a closure, were integrated
// back into ASAP proper.
// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/promise/node_modules/asap/raw.js":[function(require,module,exports){
(function (process){
"use strict";

var domain; // The domain module is executed on demand
var hasSetImmediate = typeof setImmediate === "function";

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including network IO events in Node.js.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
module.exports = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
        flushing = true;
    }
    // Avoids a function call
    queue[queue.length] = task;
}

var queue = [];
// Once a flush has been requested, no further calls to `requestFlush` are
// necessary until the next `flush` completes.
var flushing = false;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory excaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
    flushing = false;
}

rawAsap.requestFlush = requestFlush;
function requestFlush() {
    // Ensure flushing is not bound to any domain.
    // It is not sufficient to exit the domain, because domains exist on a stack.
    // To execute code outside of any domain, the following dance is necessary.
    var parentDomain = process.domain;
    if (parentDomain) {
        if (!domain) {
            // Lazy execute the domain module.
            // Only employed if the user elects to use domains.
            domain = require("domain");
        }
        domain.active = process.domain = null;
    }

    // `setImmediate` is slower that `process.nextTick`, but `process.nextTick`
    // cannot handle recursion.
    // `requestFlush` will only be called recursively from `asap.js`, to resume
    // flushing after an error is thrown into a domain.
    // Conveniently, `setImmediate` was introduced in the same version
    // `process.nextTick` started throwing recursion errors.
    if (flushing && hasSetImmediate) {
        setImmediate(flush);
    } else {
        process.nextTick(flush);
    }

    if (parentDomain) {
        domain.active = process.domain = parentDomain;
    }
}

}).call(this,require('_process'))

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","domain":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/domain-browser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js":[function(require,module,exports){
var Cloud = require('vigour-js/browser/network/cloud')
    .inject(
      require('vigour-js/browser/network/cloud/datacloud'),
      require('vigour-js/browser/network/cloud/authenticate')
    ),
  Value = require('vigour-js/value'),
  Data = require('vigour-js/data'),
  util = require('vigour-js/util'),
  cases = require('vigour-js/browser/cases'),
  ua = require('vigour-js/browser/ua'),
  raf = require('vigour-js/browser/animation/raf')

// var semver = require('vigour-js/util/semver')

require('vigour-js/value/flags/process') // mustbecome injectable on object ( all these extension should be located seperately )

function setClientInfo (cloud, base) {
  // todo: move client to cloud
  
  var oldclient = cloud.client.from.raw
  var obj = oldclient 
    ? { 
        title: oldclient.title,
        device: oldclient.device,
        info: oldclient.info
      }
    : {}
  filterEmpty(obj)

  var client = cloud.data.get(['clients', cloud.clientid]),
    title, device, castId

  var info = cases.touch 
    ? ua.device + ' ' + 
      ( ua.platform === 'ios' ? 'iOS' : ua.platform ) +
      ( ua.version ? ' ' + ua.version : '' )
    : ua.platform + ' ' + ua.browser + ' ' + ua.version

  if (cases.$isIos) {
    title = ua.device === 'phone' ? 'iphone' : 'ipad'
    device = ua.device
  } else {
    if (ua.platform === 'appletv') {
      title = 'Apple TV'
      device = 'cast'
    } else if (cases.$isChromecast) {
      title = 'Chromecast'
      device = 'cast'
      castId = window.sessionId
    } else {
      device = ua.device
      title = cases.$isDesktop ? ua.platform : ua.platform + ' ' + device
    }
  }

  util.merge( obj, {
    title: title,
    device: device,
    info: info
  }, false, false )

  if (castId) {
    obj.castId = castId || false
  }

  // client.merge(obj, false, false)
  client.val = obj
  cloud.client.val = client

  // DEBUG LOGS: 
  // cloud.client.on(function(val, stamp, from){
  //   // console.log('\n\n\n\nupdate kenker', val, from)
  //   var origin = from || this._updateOrigin
  //   if(val && val.token || (origin && origin._name === 'token')) {
  //     console.error('TOKENSETTOKENSETTOKENSET', val && (val.token || val) )
  //   }
  // })

  // user.clientUserToken = user.client.from.get('userToken') deze is duidelijk fucked up and has to be fixed
}

exports.extend = util.extend( require('./values'), function (base) {
  var _cloud = new Cloud(new Value())
    , _first //= true
  
  cases.$isConnected = new Value( _cloud.connected )

  // todo: move to cloud
  _cloud.client = new Value()

  _cloud.once('welcome', function (id) {
    setClientInfo(_cloud, base)
  })

  // _cloud.on('reconnect',)
  // console.error('>>> adding reconnect listener')
  _cloud.on('reconnect', function() {
    // console.log('>>>> reconnect set up reset client info!', _cloud.client.from.raw)
    var setObj = {}
    _cloud.client.from.each(function(i) {
      if(i !== 'key' && i !== 'type' && i !== 'ip'){
        setObj[i] = this._val
      }
    })
    _cloud.client.from.on('remove', function() {
      if(Object.keys(setObj).length) {
        // console.log('reset dat client info', setObj)
        _cloud.data.clients.set(_cloud.clientid, setObj)
      }
    })
  })

  base.define({
    cloud: {
      get: function () {
        return _cloud
      },
      set: function (val) {
        if (util.isObj(val)) {
          if (val.fastLogin) {
            _cloud.fastLogin.val = true
          }

          if (val.api) {
            _cloud.api.val = val.api
          }

          if (val.url) {
            _cloud.url.val = val.url
          }
        } else {
          _cloud.url.val = val
        }
      }
    }
  })

  var _version = new Data( _cloud.data.get('app'), { subscription: { $:true } } )

  //semvar -- APP VERSION DOES NOT WORK!
  base.versionData = new Value({
    val: _version,
    defer: function(update, args) {
      var doUpdate
      var t
      if(this.from.version) {
        console.log('hey hey hey')
        if( !window.package ) 
        {
          console.error( 'no window package', window.package )
        }
        else 
        {
          var newversion = this.from.version.val
            , oldversion = window.package.version

          if(newversion && oldversion) {
            newversion = newversion.split('.')
            oldversion = oldversion.split('.')
            newversion = Number(newversion[1])
            oldversion = Number((oldversion[1]||0))
            if( newversion > oldversion ) {
              doUpdate = true
              this.clearCache()
              window.package.version = this.from.version.val
            }
          }
        }
      } 
      update( doUpdate ? void 0 : true )
    }
  })

})


function filterEmpty(obj) {
  for(var f in obj) {
    if(obj[f] === void 0) {
      delete obj[f]
    }
  }
}

},{"./values":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/network/cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/index.js","vigour-js/browser/network/cloud/authenticate":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/authenticate.js","vigour-js/browser/network/cloud/datacloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/datacloud.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js":[function(require,module,exports){
var Value = require('../value')
  , CloudData = require( '../browser/network/cloud/data' )
  , util = require('../util')
  , vObj = require('../object')


util.define
( CloudData
, '_contentPath'
, { get: function() {
      var p = this._path
      for(var i in p ) {
        if( p[i] === 'shows' || p[i] === 'channels' ) {
          return p.slice( i )
        }
      }

      console.error('_contentPath used on non-content data', this, p)
      // throw new Error('_contentPath used on non-content data')
      // return this._path.slice( base.instances[0].data.from._path.length )
    }
  }
)

util.define(
  vObj
, '_contentType'
, { get:function() {
      var from = this.from
      if( from.cloud && from._parent ) return from._parent._name
    }
  }
)

exports.extend = util.extend( 
  require('./values')
, require('./cloud')
, function( app ) {
    var content = app.content = new Value({})
    // var get = Value.prototype.get
    util.define(content, 'get', function(){
        if( this._val && this._val.cloud ) { 
          return this._val.get.apply(this._val, arguments) 
        } else { 
          throw new Error( 'app.content , dont have cloud data!') 
        }
      })

    app.region.on(onChange)
    app.language.on(onChange)

    onChange()

    function onChange(){
      var region = app.region.val
        , language = app.language.val

      //TODO:make this configurable in the app
      if(language==='it') {
        language = 'en'
      }

      if(region && language){
        //TODO: make mtvData configurable
        // content.val = app.cloud.data.get(['mtvData', region, language])

        // content.val = app.cloud.data

      }
      content.val = app.cloud.data
    }
    
  }
)

},{"../browser/network/cloud/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","./cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js","./values":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * 
 * could think of something so style requires are parsed optionaly
 * maybe in vigour-js use dynamic script tags and parse those /w gaston if you are using gaston
 * this will make it more usable for others in the future and makes it compatible with pure browserify
 */

require('./style.less')
require('vigour-js/browser/animation/easing')

var Element = require('./ui/element')
  , cases = require('vigour-js/browser/cases')
  , animation = require('vigour-js/browser/animation')
  , events = require('vigour-js/browser/events/advanced')
  , ua = require('vigour-js/browser/ua')
  , raf = require('vigour-js/browser/animation/raf')
  , eventUtils = require('vigour-js/browser/events/util')
  , app
  , _ios = ua.platform==='ios'
  , _windows = ua.platform === 'windows'
  , arr = ['phone','tablet','tv','desktop','ios','android','windows','mac','$hasTouch','slow','chromecast'] //maybe make this configrable
  //ui/cases --
  , i = arr.length - 1

//hier process in requiren en added 'appStart' ofzoiets dergelijks
//add ook process aan base dingen dan word iets pas geadd na een bepaalde process update
//ultra mofo powerfull

cases.$isIosBrowser = _ios && ( 'standalone' in navigator && !navigator.standalone )
cases.$isIosFull = (!cases.$isIosBrowser&&_ios) || ((_ios || _windows) && !!window.cordova) || false
cases.$isRetina = window.devicePixelRatio > 1
cases.$isSlow = (_windows && ua.device === 'phone') || (ua.noRaf&&ua.hasTransition) || _ios && (window.screen.height === (960 / 2)) || ua.device === 'tv'
cases.$isNative = window.cordova ? true : false
cases.$isWindowsMobile = ua.platform === 'windows' && ua.device === 'phone' && !!window.cordova
cases.$isPhoneBrowser = ua.device === 'phone' && !( cases.$isNative || cases.$isIosFull )
//packer case voor web // native

app = module.exports = new Element({
  'x,y':{val:0,clean:true,translate:true}
, node: document.body
, w: window.innerWidth
, h: window.innerHeight
, css: 'app'
})

//if(cases.$isiosFull) {
  // app.y = {add:20}
  // app.h = {sub:20}
//}

var listener = function() {
//   console.log('resize!!','w:',window.innerWidth,'h:',window.innerHeight,'block?:',app.blockResize)
  if(!app.blockResize) {
    // animation.prevent = true
    app.w.val = window.innerWidth
    app.h.val = window.innerHeight
    // animation.prevent = false
  } else {
    app.blockResize = false
  }
}

function defaultCase(str) {
  if(str !== '$hasTouch'){
    var cssStr =  's' + str.charAt(0).toUpperCase() + str.slice(1);
    var caseStr = '$i' + cssStr
    if(cases[caseStr]===void 0) {
      cases[caseStr] = (ua.device === str || ua.platform === str) ? true : false
    }
    app.css = {addClass:cases[caseStr] ? 'i' + cssStr : 'notI'+ cssStr}
  }else{
    app.css = {addClass:cases.$hasTouch ? 'hasTouch' : 'notHasTouch'}
  }
}

// listener = eventUtils.throttle(listener,60)
// listener =
// cases.$isnoCalc = !util.hasCalc()
//case too see if app is running in a browser on ios (limits video capabilities)

if(cases.$istouch) events.document.addEvent('move',function(e) {
  if(!events._maybescroll && !events._setscroll) e.preventDefault()
},'app')

if('orientation' in window) window.addEventListener('orientationchange',listener)
if(!_ios) window.addEventListener('resize',listener)

//adding #<case> in url forces case, multiple hashes ==> multiple cases
//this is for testing purposes , add development indentifier for compiler

//this has to go
if(window.location.hash) {
  var hashCases = window.location.hash.split('#')[1]
    , x = hashCases.split(',')

  for(var j in x) {
    var y = x[j].split('=')
    ua[y[0]] = y[1]
  }
  
}

if(ua.device === 'tv') {
  cases.$isSlow = true
}

for(;i >= 0;) defaultCase(arr[i--])




},{"./style.less":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/style.less","./ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/animation":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js","vigour-js/browser/animation/easing":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/easing.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events/advanced":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/advanced.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Element = require('../../../browser/element')

require('../../../value/flags/parent')
require('../../../value/flags/self')
require('../../../value/flags/process')
require('../../../value/flags/util')
require('../../../browser/events')

module.exports =
  Element
  .inject
  ( require('../../../browser/element/properties/collection')
  , require('../../../browser/element/properties')
  , require('../../../browser/element/properties/scrollbar')
  , require('../../../browser/element/properties/process')
  , require('../../../value/on')
  )


},{"../../../browser/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../browser/element/properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","../../../browser/element/properties/collection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/index.js","../../../browser/element/properties/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/process.js","../../../browser/element/properties/scrollbar":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/scrollbar.js","../../../browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../../value/flags/parent":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/parent.js","../../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","../../../value/flags/self":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js","../../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../../../value/on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/on.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/sprite/index.js":[function(require,module,exports){
var Element = require('../element')
  , util = require('../../../browser/events/util') 
  , sprite = new Element({ 
    'w,h':50,
    x:{translate:true,val:0}
  })

sprite.extend({ name: 'params' //this has to come from ui (element)
  , type: false
  , set: function(val) {
    this._params = val
    this.Class.prototype._params = val //temp?
  }
})

sprite.setSetting({
  name:'spinner',
  render:function() {
    var t = this
      , params = this._params || {}
      , start = params.start || 0
      , speed = params.frames || 3
      , rows = params.rows || 1
      , cols = params.cols || 0 //ignore
      , once = params.once
      , cnt = start
      , steps = (params.steps || (rows*cols-start) || 19)
      , curRow = 0
      , curCol = 0

    if(!t.display || !t.display._base===t) {
      t.display = t.display && t.display.val || 'block'
    }
    t.display.addListener([displayListener,t],true)

    t.node.style.backgroundSize = this.w.val*cols+'px auto'
    //remeber where it was perhaps if re-rendered
    if(t.display.val==='none') return

    t._spinner = util.interval(function() { //test interval for leaks
      t.node.style.backgroundPosition = 
        (-t.w.val*curCol)+'px '+(rows ? (-t.h.val*curRow) : 0)+'px'
      cnt++
      if(cnt === steps) {
        cnt = start
        if(once) {
          // console.error('XXXXX')
          removeRaf.call(t)
          return
        }
      }
      curRow = rows ? ~~(cnt/cols) : 0
      curCol = cnt-(curRow)*cols
    },speed)
  },
  remove:removeRaf
})

function removeRaf() {
     // alert('lets remove this badboy')

  if(this._spinner) {
    this._spinner()
    this._spinner = null
  }
}

function displayListener (val) {
  if(val.val==='none') {
    removeRaf.call(this)
  } else {
    if(!this._spinner) this.setting('render')
  }
}

module.exports = sprite.Class



},{"../../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var Base = require('vigour-js/base')
  , Element = require('vigour-js/browser/element')
  , Value = require('vigour-js/value')
  , VObject = require('vigour-js/object')
  , switcher = new Element()
  , cases = require('vigour-js/browser/cases')

function extendFactory( field ){
  return { name:field
  , type:false
  , set:function( fn ){
      if(fn instanceof Function)
      {
        var set = {}
        set['_'+field] = fn
        this.define(set)
      }
      else
      {
        console.error('property ' + field + ' needs to be a function')
      }
    }
  }
}

Value.flags.$params = {
  set:function( val ) {
    this.params = val
  }
}

Value.flags.$options = {
  set:function( val ) {
    this.options = val
  }
}

switcher.extend
( { loader:{}
  , animation:{}
  , delay:{}
  , done:{}
  , force:{}
  , backFallback:
    { cache:false
    // , set:function(){}
    }
  , onTransition:
    { cache:false
    // , set:function(){}
    }
  , transition:
    { cache:false
    , set:function( val ){
        var element = val.element && val.element._val
          , params = val.params
          , options = val.options || {}
          , force = options && options.force
          , children = this.children
          , last = this._swElem || children[0]
          , base = element && element.base
          , childrenLength = children.length
          , current
          , child
          , direction
          , _this = this

        //if there are old loading listeners remove these
        if( this._loading )
        {
          this._loading[1].removeListener( this._loading[0] )
          this._loading = void 0
        }

        // if( _this._timer ){
        //   clearTimeout( _this._timer )
        //   _this._timer = null
        // }

        // console.log('options?!'.green.inverse,options)
        //is it the same , is it not the same whatup!
        if( base && base instanceof Element || element === Element )
        { 
          if( !force && this._swElem && this._swElem instanceof element )
          {
            this._swElem.set( params )
          }
          else
          {

            // if there are still old pages, remove these
            if( childrenLength > 1 )
            {
              for ( i = childrenLength - 1; i >= 0; i-- ) 
              {
                child = children[i]
                if( child !== last ) child.remove()
              }
            }

            direction = this._direction = val.direction && val.direction._val
            if( options && options.loader && !options.loader.$loaded )
            {
              if( !this.loader )
              {
                console.error( 'no loader defined!' )
                return
              }

              var loader = new this.loader._val.Class()

              if( options.loader instanceof VObject ) //TODO: this has gotten VERY dirty > clean this up!
              {
                options.done = function(){
                  if( !current ) current = new element( params )
                  if( loader._remove )
                  {
                    options.done = void 0
                    options.delay = cases.tablet ? 400 : 200 //dit is natuurlijk absurd
                    
                    if( _this._swElem instanceof element )
                    {
                      _this._swElem.set( params )
                    }
                    else
                    {
                      _this.onTransition._val.call( _this, current, _this._swElem , 0, options )
                    }
                    options.delay = void 0
                  }
                }

                var path = options.loader._path
                this._loading = [ function() {
                  // if( _this._timer ){
                  //   clearTimeout( _this._timer )
                  //   _this._timer = null
                  // }
                  loader._remove = true
                  if( current && options.done ) options.done()

                }, options.loader ]

                // console.log('add the listener for',path)
                this._loading[1].is('loaded', this._loading[0] )
                // _this._timer = setTimeout( this._loading[0], 5000 )
              }
              else
              {
                options.done = function(){
                  if( !current ) current = new element( params )

                  options.done = void 0
                  options.delay = 200

                  if( _this._swElem instanceof element )
                  {
                    _this._swElem.set( params )
                  }
                  else
                  {
                    _this.onTransition._val.call( _this, current, _this._swElem , 0, options )
                  }

                  options.delay = void 0
                }
              }

              options.loader = void 0

              this.onTransition._val.call( this, loader, last, direction, options)
            }
            else
            {
              current = new element(params)
              options.done = void 0
              options.delay = void 0
              options.loader = void 0
              
              this.onTransition._val.call( this, current, last , direction, options )
            }

            if( options.animation !== void 0 ) options.animation = void 0
            if( options.delay ) options.delay = void 0

          }
        }
        else if(params)
        {
          console.error('only params defined!', params)
        }
        else if(params)
        {
          console.error('no params and no element defined!')
        }
      }
    }
  }
)

switcher.define
({ back:function(){ //remove back logic from switcher (you can't isolate it! ie when you land on page, what is back?)
      this.backFallback._val.call( this )
		}
  , add:function( element, previous ){
      console.log('add--->',element)
      this._swElem = element

      // try
      // {
        Element.prototype.add.apply( this, arguments )
      // }
      // catch(err)
      // {
      //   console.error('error adding the new element',err,arguments)
      // }
    }
	}
)

switcher.extend
( { name:'on'
  , set:function( val ) {
      // set history variable for all
      // val.each(function(){
      //   var from = this.$userOrigin.val
      //   if(!from) return
      //   if(!from._history) from.set('history',true)
      //   if(!this.__checked)
      //   {
      //     this.on(function(){
      //       var caller = this._parent._caller
            
      //       if(!caller._backStore)
      //       { 
      //         caller._backStore = [ this ]
      //       }
      //       else if(caller._direction === -1)
      //       {
      //         if(caller._backStore[1] !== void 0) caller._backStore.shift()
      //         else caller._backStore = [ this ]
      //       }
      //       else if(caller._direction === 1)
      //       {
      //         caller._backStore.unshift( this )
      //       }
            
      //     })
      //     this.__checked = true
      //   }
      // })
    }
  , remove:function(){ // create refs to original
      if( this._loading )
      {
        this._loading[1].removeListener(this._loading[0])
        this._loading = null
      }
      
      if( this._swTimer ) clearTimeout( this._swTimer )
      if( this._timer ) clearTimeout( this._timer )

      if( this.on.$remove ) this.on.$remove.update()
    }
  , new:function(){
      if( this.on.$new ) this.on.$new.update()
    }
  }
)

module.exports = new switcher.Class().Class
},{"vigour-js/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var app = require('vigour-js/app'),
  cases = require('vigour-js/browser/cases'),
  util = require('vigour-js/util')

exports.extend = util.extend(function(base) {
  base.set({
    onTransition: {
      defer: function(update) { //obscure transform
        if (exports[this._val]) this._val = exports[this._val]
        update()
      }
    }
  })
})

//slide transition
exports.slide = function(current, last, direction, options) {
  if (direction && last) animate(this, current, last, direction, options)
  else basic(this, current, last, direction, options)
}

//fade transition
exports.fade = function(current, last, direction, options) {
  basic(this, current, last, direction, options)
}

//basic transition
function basic(_this, current, last, direction, options) {
  var done = options.done,
    noAnimation = options.animation === false,
    delay = options.delay

  if (last) {
    add(_this, current, last)

    if (noAnimation) {
      remove(_this, last)
      add(_this, current)

      if (done) {
        if (delay) {
          timer(_this, function() {
            if (options.done) options.done()
          }, delay)
        } else done()
      }
    } else if (delay) {
      timer(_this, function() {
        fade(_this, last, options)
      }, delay)
    } else fade(_this, last, options)
  } else add(_this, current, false, done)
}

//animated transition
function animate(_this, current, last, direction, options) {
  var animationTime = 20 // make this configurable
    ,
    appWidth = app.w.val,
    currentStart, forward = direction === 1,
    lastEnd

  if (forward) {
    currentStart = appWidth
    lastEnd = appWidth / -3
  } else {
    currentStart = appWidth / -3
    lastEnd = appWidth
  }

  if (cases.$isWindows) {
    current.x = {
      translate: true,
      val: currentStart
    }

    last.x = {
      translate: true,
      val: 0
    }

    window.requestAnimationFrame(function() {
      current.x = 0
      last.x = lastEnd

      timer(_this, function() {
        remove(_this, last, options.done)
      }, 210)
    })
  } else {
    current.x = {
      animation: {
        start: currentStart,
        time: animationTime,
        delay: 1,
        easing: 'outCubic',
        done: function() {
          remove(_this, last, options.done)
        }
      },
      val: 0
    }

    last.x = {
      animation: {
        time: animationTime,
        delay: 2,
        easing: 'outCubic'
      },
      val: lastEnd
    }
  }

  if (!forward) add(_this, current, last)
  else add(_this, current)

}

function add(_this, toAdd, before, done) {
  if (toAdd) _this.add(toAdd, before)
  if (done) done()
}

function fade(_this, last, options) {
  last.opacity = 0
  last.node.pointerEvents = 'none'
  timer(_this, function() {
    remove(_this, last, options.done)
  }, 200)
}

function remove(_this, toRemove, done) {
  if (toRemove) toRemove.remove()
  if (done) done()
}

function timer(_this, fn, time) {
  if (_this._swTimer) {
    clearTimeout(_this._swTimer)
    _this._swTimer = null
  }
  _this._swTimer = setTimeout(function() {
    fn.call(_this)
    _this._swTimer = null
  }, time)
}

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/id.js":[function(require,module,exports){
var util = require('../../util')

require('../../value/flags/process')

exports.extend = util.extend
( function( base ) {
    // base
    base.extend
    ( 
      { id: function(val) {
          var id = val.val

          if( id && this.cloud ) 
          {
            this.data = this.cloud.data.get([ 'users', id ])
          } 
          else if( !id ) 
          {
            // this.data = void 0
            //TODO: this works buggy in values --- void 0 does not update data, maybe just use false for now
            console.log('base.mockdata')
            this.data = base.mockdata
          }
        }
      , data: {
          //mockdata on start can break everything down
          val: base.mockdata ,
          set:function( val ) {
            var user = this

            // if(!this.first) {
              // this.first = true
            // } else {

            if(user.instances && user.instances.length) {
              // console.error ('-- tmp fix data on base switch to instance[0]' )
              //TODO: this is a hacky solution! fix later
              user = user.instances[0]
            }

            if( val.from.cloud  ) 
            {
              if( user.___c !== val.from ) 
              {
                user.initialised = null
                user.___c = val.from
                for(var key in user.on.user) {
                  user.on.user[key].call( user, key )
                }
                user.initialised = true
              }
            }
            else 
            {
              if( user.___c === false ) return
              user.___c = false
              for(var key in user.on.user) {
                user.on.mock[key].call( user, key )
              }
              user.initialised = null
            }
          }
          // }
        }
      }
    )

})

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js":[function(require,module,exports){
require('../../value/flags/self')
require('../../value/flags/process')
require('../../value/flags/util')
  //TODO: clean these to work /w inject

var util = require('../../util'),
  Value = require('../../value'),
  Base = require('../../base'),
  Data = require('../../data'),
  vObject = require('../../object').inject(
    require('./origin')
  ),
  timestamp = require('monotonic-timestamp'),
  _subscriptions = {},
  MockData = require('./mockdata'),
  mockdata = new MockData({})
  // make mockdata vailable

var _extend = Base.prototype.extend

var user = new Base({
  defaultType: require('./type')
})

user.define({
  subscriptions: {
    get: function () {
      return _subscriptions
    },
    set: function (val) {
      if (val) util.merge(_subscriptions, val)
    }
  },
  mockdata: {
    get: function () {
      return mockdata
    },
    set: function (val) {
      if (val) mockdata.merge(val)
    }
  },
  on: {
    value: {
      mock: {},
      user: {}
    }
  }
, extend: function( settings ) {

    if(settings.mock) {
      this.mockdata = settings.mock
    }

    var ret = _extend.apply(this, arguments)

    if(settings.val !== void 0) {
      this[settings.name] = settings.val
    }

    if( settings.on ) {

      if( typeof settings.on === 'function' ) {
        settings.on.call( this, settings.name ) 
      } else {
        if( this.data && this.data.cloud ) {
          settings.on.user && settings.on.user.call( this, settings.name ) 
        } else {
          settings.on.mock && settings.on.mock.call( this, settings.name ) 
        }
      }    
    }

    return ret
  }
})

// user

exports.extend = util.extend(
  require('../cloud'),
  function (base) {
    var appuser = base.user = new user.Class().inject(
      require('./set'),
      require('./id')
      //inject pas op extend???
    )
    appuser.parent = base
    appuser.cases = base.cases
    appuser.cloud = base.cloud
  }
)
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","../../value/flags/self":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js","../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../cloud":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/cloud.js","./id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/id.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","./origin":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/origin.js","./set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/set.js","./type":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/type.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js":[function(require,module,exports){
var util = require('../../util')
  , Data = require('../../data')

module.exports = exports = Data.new()  

util.define( exports,
'get', function( val, set, notself ) {
  return this.path
  ( (val instanceof Array) ? val : String(val).split('.')
  , set !== void 0 ? set : {}
  , false
  , false
  , false
  , false
  , true
  , !notself
  )
})


},{"../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/multiscreen/index.js":[function(require,module,exports){
var util = require('vigour-js/util'),
  Value = require('vigour-js/value'),
  cases = require('vigour-js/browser/cases'),
  Data = require('vigour-js/data').inject(
    require('vigour-js/data/selection')    
  ),
  Compound = require('vigour-js/object/compound'),
  events = require('vigour-js/browser/events'),
  ua = require('vigour-js/browser/ua'),
  raf = require('vigour-js/browser/animation/raf')

var VObject = require('vigour-js/object')
VObject.inject(
  require('vigour-js/value/length')
)

var INACTIVE = typeof window !== void 0 && window.INACTIVE

var deviceIsCandidate = /(desktop)|(tv)|(cast)|(tablet)|(airplay)/i
cases.$isCandidate = deviceIsCandidate.test(ua.device)

var deviceIsTvLike = /(tv)|(cast)|(airplay)/i

require('vigour-js/value/flags/process')

exports.extend = util.extend(function (user) {

  var content = user.parent.inject(require('../../content')).content

  content.on('self', function() {
    if( user.token.val ) {
      if(user.receiver.media.val && user.receiver.media.from !== user.receiver.media ) {
        if(user.receiver.media.from!== content.get( user.receiver.media.from._contentPath )) {
          // console.error('lets go change it!', user.receiver.media)
          user.receiver.media.$userOrigin = content.get( user.receiver.media.from._contentPath )
        }
      }
    } 
  })

  // extend basic properties
  user.extend({
    receiver: {
      mock: {
        receiver: {
          volume: 1,
          media: false,
          playing: false
        }
      },
      val: {
        media: {
          $bubble: {
            references:{
              $lte:1
            }
          },
          defer:function(update){
            var playing = this._parent.playing
            if(playing && !this.from.val) playing.from.val = false
            update()
          }
        }
      },
      subscription: {
        receiver: {
          volume: true,
          playing:true,
          media: {
            $: true
          }
        }
      },
      on: {
        mock: setMock_receiver,
        user: setUser_receiver
      }
    },
    clients: {
      subscription: {
        clients: {
          $: {
            $: true
          }
        }
      },
      on: {
        mock: setClients,
        user: setClients
      }
    },
    candidates: { val: {} },
    siblings: { val: {} },
    receiverClient: {
      val: {},
      on: {
        mock: setMock_receiverClient,
        user: setUser_receiverClient
      },
      subscription: {
        receiverClient:{
          $: true  
        }
      }
    },
    activeClient: {
      val: {},
      mock: {
        activeClient: true
      },
      subscription: {
        activeClient:{
          $: true  
        }
      },
      on: {
        mock: setMock_activeClient,
        user: setUser_activeClient
      }
    }
  })
  
  // extend devices (needs siblings)
  user.extend({
    devices: {
      val: new Compound(user.siblings)
    }
  })
  
  // extend case values
  user.extend({
    hasReceiver: {
      val: {
        val: user.receiverClient,
        transform: function(val, cv) {
          var endpoint = user.receiverClient.from
          return (
            endpoint && !endpoint._removed &&
            endpoint.cloud && endpoint._path[0] === 'clients'
          ) || 0
        }
      }
    },
    isReceiver: {      
      val: {
        defer: function(update, args){
          var origin = args[2] || this._updateOrigin
          if(!origin || 
             !(origin._prop || origin._name === 'receiverClient')
            ) {
            // console.log('block update', origin)
            return true
          }
          // console.log('no block')
          var stamp = args[1]
          if(stamp !== 'cleanup') {
            if(user._handleOldIsReceiver) {
              if( user._wasReceiver && 
                  !user.hasReceiver.val &&
                  !user.isActive.val
                ) {
                // console.error('i was receiver for this guy', user.data._val.raw)
                user.setReceiver(user.cloud.client.from)
              }
              user._handleOldIsReceiver = null
            }
            this.clearCache()
            user._wasReceiver = this.val
          }
          update()
        },
        val: user.receiverClient,
        transform: function(val, cv) {
          var endpoint = user.receiverClient.from
          return (
            endpoint && !endpoint._removed &&
            endpoint.cloud && endpoint === user.cloud.client.from
          ) || 0
        }
      }
    },
    hasCandidates: { 
      val: { 
        val: user.candidates.$length,
        $convertType: 'boolean'
      }
    },
    hasDevices: {
      val: { 
        val: user.devices.$length,
        $convertType: 'boolean'
      }
    },
    isActive: {
      val: {
        defer: function(update, args){
          // console.log('----- isActive check dat!')
          var origin = args[2] || this._updateOrigin
          if(!origin || 
             !(origin._prop || origin._name === 'activeClient')
            ) {
            // console.log('no blockit', 
            //   origin._path,
            //   origin,
            //   '\nval:', args[0]
            // )
            update(true)
            // return true
          }
          var stamp = args[1]

          if(stamp) {
            if(stamp !== 'cleanup') {
              if(user._handleOldIsActive) {
                if( user._wasActive && 
                    !( user.activeClient.$userOrigin && 
                       user.activeClient.$userOrigin._val
                     )
                  ) {
                  // console.error('i was activeClient for this guy RESET')
                  user.activeClient.$userOrigin = user.cloud.client._val
                }
                user._handleOldIsActive = null
              }
              this.clearCache()
              user._wasActive = this.val
            }
            
          }
          // console.log('go update!')
          update()
        },
        val: user.activeClient,
        // $bubble: {
        //   references: 2
        // },
        transform: function (c, cv) {
          var endpoint = user.activeClient.from
          return (
            (endpoint && endpoint.val === true) ||
            endpoint === user.cloud.client.from
          ) || 0
        }
      }
    },
    setReceiver: {
      type: false,
      val: function(client) {
        var user = this
        // console.error('setReceiver called lol')
        client = client.from
        if(!client) return

        var casttype = client.cast && client.cast.val

        if(casttype) {
          // console.log('setReceiver! user.cast[casttype]', user.cast[casttype])
          // console.log('setReceiver! user.cast[casttype].setReceiver', user.cast[casttype].setReceiver)
          user.cast[casttype].setReceiver(client)
        } else {
          client.set('token', user.token.val)
          user.receiverClient.$userOrigin = client
        }
      }
    }
  })
  
  // DEBUG:
  // user.activeClient.on(function(){
  //   console.error('activeClient happenin!', this.from && this.from.toString())
  // })
  
  // user.hasReceiver.on(function(){
  //   console.error('lol hasReceiver listener fires! val:', this.val)
  // })
  // user.isReceiver.on(function(){
  //   console.error('lol isReceiver listener fires! val:', this.val)
  // })
  // user.activeClient.on(function(){
  //   console.error('lol activeClient listener fires! val:\n', this.from.toString())
  // })

  // listeners:

  // on activity: make me activeClient
  if(!cases.$isChromecast && !INACTIVE) {
    var activeEvent = cases.$isTv ? 'keydown' : 'down'
    events.document.addEvent(activeEvent, function () {
      if( user.cloud.client._val &&
          !(cases.$isFullscreen && cases.$isFullscreen.val)
        ) {
        user.activeClient.$userOrigin = user.cloud.client.from
      }
    })  
  }
  

  // re-establish old setup after reconnect
  user.cloud.on('welcome', function(){
    if(user.cloud._status > 2){
      user._handleOldIsActive = true
      user._handleOldIsReceiver = true
      user.cloud.data.once(function(){
        // console.log('ok go reset dat old situation')
        user.isActive.update()
        user.isReceiver.update()
      })
    }
  })

  /*
  * when I become active, unset myself as receiver
  * and if not iplogin > select new receiver
  */
  user.isActive.on(true, function() {
    var isReceiver = user.isReceiver.val
    // console.log('isReceiver?!', isReceiver)

    if(user.hasCandidates.val) { //  && !user.iplogin.val
      // console.log('user.hasCandidates.val', user.hasCandidates.val)
      // console.log('isReceiver', 
      //   isReceiver, 
      //   '\nuser.hasReceiver.val', user.hasReceiver.val
      //   )
      if(isReceiver || !user.hasReceiver.val) {
        // console.log('ok select receiver because i became active!')
        var newreceiver = selectReceiver(user, user.candidates)
        if(newreceiver) {
          // wait for my own isactive set
          raf(function(){
            user.setReceiver(newreceiver)
          })
        } else if(isReceiver) {
          user.receiverClient.$userOrigin = null
        }
      }
    } else if(isReceiver){
      user.receiverClient.$userOrigin = null
    }
  })  
  

  // when receiver leaves, I might have to become the new receiver
  if(cases.$isCandidate) {
    user.hasReceiver.on(0, function(val, stamp, from){
      if(stamp === user.cloud.stamp) {
        // console.log('yes update is ok')
        if(!user.isActive.val){
          // wait for all removes to finish
          raf(function(){
            // select receiver
            // console.log('ok select receiver because receiver left!')
            var newreceiver = selectReceiver(user, user.clients)
            // if its me > update user
            if(newreceiver === user.cloud.client.from) {
              user.setReceiver(newreceiver)
            } else {
              // console.log('i am not new receiver! newreceiver is', newreceiver && newreceiver.raw)
            }
          })
        }
      } else {
        // console.log('update not from the cloud')
      }
    })
  }

  // when a tv joins, I might want to grab it
  if(!user.iplogin.val){
    user.candidates.on(function(val, stamp, from, remove, added){
      // console.error('-------- check for tv joiner\n',
      //   'user.hasCandidates.val', user.hasCandidates.val, '\n',
      //   'user.isActive.val', user.isActive.val, '\n',
      //   'user.initialised', user.initialised
      // )
      // console.log(user.candidates.toString())
      if(user.hasCandidates.val && user.isActive.val &&
          user.initialised
        ) {
        grabTV(user)
      } else {
        // console.error('no candidates')
      }
    })
  }

  
  // make cases
  cases.$isActive = user.isActive
  // cases.$hasCandidates = user.hasCandidates
  cases.$hasDevices = user.hasDevices
  cases.$hasReceiver = user.hasReceiver
  cases.$isReceiver = user.isReceiver


})

// clients
function updateClients() {
  this.clients.update()
}

function setClients () {
  var user = this
  var linked = user.data._val

  // clients
  var linkedclients = linked.get('clients')
  // cache old, set new, and remove listener if cached old
  var oldclients = user.clients._val
  user.clients = linkedclients
  linkedclients.addListener([updateClients, user], true)
  if( oldclients ) {
    oldclients.removeListener(updateClients, user)
  }

  // candidates
  // cache previouse value
  var oldcandidates = user.candidates && user.candidates._val
  // make candidates
  var candidates = user.candidates = new Data( linkedclients, {
    condition: { 
      device: {
        $contains: '(desktop)|(tv)|(cast)|(tablet)|(airplay)'
      },
      key: {
        $exists: true,
        $ne: this.cloud.clientid
      }
    }
  })
  // add listener because of reasons
  candidates.on(function(){
    user.candidates.update()
  })
  // clean up dat old selection
  if(oldcandidates) {
    oldcandidates.remove()
  }
  
  // siblings
  // cache previouse value
  var oldsiblings = user.siblings && user.siblings._val
  // make siblings
  var siblings = user.siblings = new Data( linkedclients, {
    condition: {
      key: {
        $exists: true,
        $ne: this.cloud.clientid
      }
    }
  })
  // add listener because of reasons
  siblings.on(function(){
    // console.log('update on candidates > update user.candidates')
    user.siblings.update()
  })
  // clean up dat old selection
  if(oldsiblings) {
    oldsiblings.remove()
  }
}

// activeClient

var acRemoveTarget
var acAddedTarget

function setMock_activeClient () {
  // console.log('---------- setMock_activeClient!')

  var user = this

  if(acRemoveTarget) {
    acRemoveTarget.removeListener(acRemoveCheck, user)
    acRemoveTarget = null
  }
  if(acAddedTarget) {
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
  }

  var linked = user.data._val

  user.activeClient = linked.get('activeClient', {})
  user.activeClient.$userOrigin = user.cloud.client.from

}



function setUser_activeClient () {
  // console.log('---------- setUser_activeClient!')

  var user = this

  // console.log('dat activeClient:', 
  //   user.data._val.activeClient
  //   ? 'yes activeclient\n' + user.data._val.activeClient.toString()
  //   : 'no activeClient in ma new user!!\n' + user.data._val.toString()
  // )

  if(acAddedTarget) {
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
  }
  
  var linked = user.data._val
  var linkedRef = linked.get('activeClient', {})

  if(acRemoveTarget) {
    acRemoveTarget.removeListener(acRemoveCheck, user)
  }
  acRemoveTarget = linkedRef
  acRemoveTarget.addListener([acRemoveCheck, user], true)

  user.activeClient = linkedRef
  
  // console.error('USERSWITCH ACTIVECLIENT')
  if(!INACTIVE){
    if(cases.$isTv) {
      // console.error('IM TV USERSWITCH WAT TO DO')
      // user.activeClient.$userOrigin = user.cloud.client.from
      // TODO: fix this:
      var activeClient = linkedRef.from
      // console.error('activeClient is', activeClient)
      // console.log('i am', user.cloud.client.from.raw)
      if(!(activeClient && activeClient._name !== 'activeClient')) {
        // console.error('set maself active')
        // console.error('SET ME TO DAT activeClient (TV)')
        user.activeClient.$userOrigin = user.cloud.client.from
      }else {
        // console.log('udpate activeClient because do it')
        user.activeClient.update()
      }
    } else if(!cases.$isChromecast) {
      // console.error('SET ME TO DAT activeClient')
      user.activeClient.$userOrigin = user.cloud.client.from
    }
  }
  

  if(user.hasCandidates.val) {
    // console.log('check for tv to grab on setUser_activeClient')
    grabTV(user)
  }

  user.activeClient.update()

}
function acRemoveCheck (firer, val, stamp, from, remove) {
  var user = this
  if(firer._removed) {
    if(acAddedTarget) {
      acAddedTarget.removeListener(acAddedCheck, user)
    }
    acAddedTarget = firer._parent
    acAddedTarget.addListener([acAddedCheck, user], true)
  }
}
function acAddedCheck (firer, val, stamp, from, remove, added) {
  var user = this,
    linkeduser = firer

  if(linkeduser.activeClient){
    acAddedTarget.removeListener(acAddedCheck, user)
    acAddedTarget = null
    
    acRemoveTarget = linkeduser.activeClient
    acRemoveTarget.addListener([acRemoveCheck, user], true)

    user.activeClient = linkeduser.activeClient
  }
}

// receiverClient
var rcAddedTarget
var rcRemoveTarget

function setMock_receiverClient () {
  var user = this

  if(rcAddedTarget) {
    rcAddedTarget.removeListener(rcAddedCheck, user)
  }
  if(rcRemoveTarget) {
   rcRemoveTarget.removeListener(rcRemoveCheck, user) 
  }

  var linked = user.data._val
  user.receiverClient = linked.get('receiverClient', false)
}
function setUser_receiverClient () {
  var user = this

  if(rcAddedTarget) {
    rcAddedTarget.removeListener(rcAddedCheck, user)
    rcAddedTarget = null
  }

  var linked = user.data._val
  var linkedRef = linked.get('receiverClient', {})

  if(rcRemoveTarget) {
    rcRemoveTarget.removeListener(rcRemoveCheck, user)
  }
  rcRemoveTarget = linkedRef
  rcRemoveTarget.addListener([rcRemoveCheck, user], true)

  user.receiverClient = linkedRef

  if(cases.$isTv) {
    // set tv to receiver if activeclient and no receiver
    var activeClient = user.activeClient.from
    if( activeClient && activeClient.__t === 2 &&
        activeClient !== user.cloud.client.from &&
        !user.hasReceiver.val
      ) {
      user.setReceiver(user.cloud.client.from)
    }
  } else if (cases.$isChromecast) {
    // always set chromecast to receiver
    user.setReceiver(user.cloud.client.from)
  }

}
function rcRemoveCheck (firer, val, stamp, from, remove) {
  var user = this
  if(firer._removed) {
    if(rcAddedTarget) {
      rcAddedTarget.removeListener(rcAddedCheck, user)
    }
    rcAddedTarget = firer._parent
    rcAddedTarget.addListener([rcAddedCheck, user], true)
  }
}
function rcAddedCheck (firer, val, stamp, from, remove, added) {
  var user = this,
    linkeduser = firer

  if(linkeduser.receiverClient){
    rcAddedTarget.removeListener(rcAddedCheck, user)
    rcAddedTarget = null

    rcRemoveTarget = linkeduser.receiverClient
    rcRemoveTarget.addListener([rcRemoveCheck, user], true)

    user.receiverClient = linkeduser.receiverClient
  }
}
// receiver
function setMock_receiver () {
  var user = this
  linkReceiver(user)
}
function setUser_receiver () {
  var user = this
  linkReceiver(user)
}
function linkReceiver (user) {
  var linked = user.data._val
    , linkedreceiver = linked.get('receiver', {})

  user.receiver = {
    volume: linkedreceiver.get('volume', 1),
    media: linkedreceiver.get('media', false),
    playing: linkedreceiver.get('playing', false)
  }
}

function selectReceiver(user, list) {
  // console.error('\n\n=========================selectReceiver!!!\n\n')
  while(list && list.__t === 4 && !list._filter){
    list = list._val
  }
  if(!list) {
    return console.error('could not determine list to select from')
  }
  var winner
  list.each(function(){
    var client = this._val
    // sanity check
    if(!client || client._removed || !client.device) {
      return console.error('bad client', 
        'path:', client && client._path,
        'client:', client && client.raw || client
      )
    }
    // skip if client is the activeClient
    if(client === user.activeClient.from) {
      return
    }
    var device = client.device.val
    // skip if client is not a candidate
    if(!deviceIsCandidate.test(device)) {
      return
    }

    // skip if client is in use by other user
    if(client.token && client.token.val !== user.token.val) {
      return
    }
    // client is a possible winner
    winner = client
    // stick if client is tv-like
    if(deviceIsTvLike.test(device)) {
      return true
    }
  })
  // console.error('\n\n========================= winner:',winner,user.cloud.clientid,'\n\n')

  return winner
}

function grabTV(user){
  // console.error('============= grabTV!')
  user.candidates._val.each(function(){
    var candidate = this.from
    // console.error('candidate', 
    //   'deviceIsTvLike', deviceIsTvLike.test(candidate.device.val),
    //   '!candidate.token', !(candidate.token && candidate.token.val),
    //   'candidate.token', (candidate.token && candidate.token.val)
    // )
    if(candidate.device.val === 'tv' &&
        !(candidate.token && candidate.token.val)
      ) {
      // console.error('grab dat!')
      candidate.set('token', user.token.val)
      if(!user.hasReceiver.val) {
        user.setReceiver(candidate)
      }
    }
  })
}

// function log(){
//   console.log('--------------------\n\n\n\n')
//   console.log(window.FLAG,':')
//   console.log.apply(console, arguments)
//   console.log('\n\n\n\n--------------------')
// }
// log.start = function(flag){
//   console.log('\n\n\n====================== START',
//     window.FLAG ? window.FLAG : '', flag, '\n\n'
//   )
// }
// log.end = function(flag){
//   console.log('\n\n====================== END',
//     window.FLAG ? window.FLAG : '', flag, '\n\n'
//   )
// }

},{"../../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/object/compound":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/compound.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js","vigour-js/value/length":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/navigation.js":[function(require,module,exports){
var util = require('vigour-js/util')
var vObject = require('vigour-js/object')
var MockData = require('./mockdata')

require('vigour-js/value/flags/process')

//nav is taking care of: 
// double updates on the same thing with the same value (syncing in it trough the cloud)
// updating navigation
// mock and user data, subscriptions

//TODO: add view

// content en switch op content pakken
//   page
//   content
// ook bubble: 1 op alle dingen
// function updateNavigation

exports.extend = util.extend
( function( user ) {

  var content = user.parent.inject(require('../content')).content

  content.on('self', function() {
    var nav = user.navigation
    var content = this
    var contentNav = nav.content.from
    var misc = nav.misc.from

    if(contentNav._contentPath) {
      nav.content.$userOrigin.val = content.from.get(contentNav._contentPath) //DIT IN NAVIGATION
    }

    if(misc._contentPath) {
      nav.content.$userOrigin.val = content.from.get(misc._contentPath) //DIT IN NAVIGATION
    }
  })

  user.define({
    updateNavigation: function( key ) {
      if(this.navigation.last && this.navigation.last.$userOrigin) {
        key = key || this.navigation.last.$userOrigin.get('key').val
        if( typeof key === 'string' ) {
          this.navigation[key]._update( this.navigation[key]._val._val , 'l'+Math.floor(Math.random()*9999) )
          return
        }
      }
      this.navigation.page.$userOrigin = 'discover'
    }
  })

  user.extend({
    navigation: {
      mock: {
        navigation: 
        { content: false
        , page: false 
        , misc: false
        , last: { key: 'page', time: 0 }
        }
      },
      subscription: {
        navigation: 
        { content:true
        , page:true
        , misc: true
        , last: 
          { key:true
          , time:true
          }
       }
      },
      val: 
      { page: { defer: deferNavigation }
      , content: { defer: deferNavigation }
      , misc: { defer: deferNavigation }
      },
      on: {
        user: function navigationToUserData( key ) {

          resolveLastListener(this)
          
          this.navigation = {
            last: this.data._val.get( [ key, 'last' ] )
          }
          this.__first = true

          var nav = this.navigation
            , userData = this.data.$userOrigin

          this._lastupdate = function lastUpdateUser( val, stamp, from ) {
                          // console.log('hey this should do the update')

            if( this.key && nav[this.key.val] )  
            {

              // console.log('hey this should do the update!1')

              nav[this.key.val].$userOrigin._update( void 0, 'l'+stamp  )
              nav.update()
            }
          }

          nav.last.from.on(this._lastupdate)

          // console.error('KEY',key)
          // debugger

          this.navigation = 
          { page: userData.get( [ key, 'page' ], 'discover' ) 
          , content: userData.get( [ key, 'content' ] )
          , misc: userData.get( [ key, 'misc' ] )
          }

          if(nav.last.from.key) {
            // debugger
            nav.last.from._update( void 0, vObject.stamp() )
          } else if(!nav.last.from.key) {
            //no page switch to default ( make a default possilbe )
            nav.page.$userOrigin = 'discover'
          }

        },
        mock: function navigationToMockData() {

          resolveLastListener(this)
    
          var nav = this.navigation

           var mock = this.mockdata.navigation
            , set = 
              { page: mock.page
              , content: mock.content
              , misc: mock.misc
              // , last: mock.last 
              }

          this.navigation = { last: mock.last }

          //TODO: this is a temp fix should go back to page you logout from!
          if(this.__first) {
            mock.page.val = 'discover'
          } 
    
          this._lastupdate = function lastUpdateMock( val, stamp, from ) {
            if( nav[this.key.val] ) 
            {
              nav[this.key.val].$userOrigin._update( void 0, 'l'+stamp  )
            }
          }

          nav.last.from.on( this._lastupdate )
          // var nav = hoe kom ik hier aan mn user???
          // console.error('?????',this.token._lval, this.token.val)
          // need to use setter (not nav ref)
          this.navigation = set
        }
      }
    }
  })

  function resolveLastListener( user ) {
    if( user._lastupdate 
        && user.navigation.last 
        && user.navigation.last.from !== user.navigation.last
     ){
      user.navigation.last.from.removeListener(user._lastupdate)
      user._lastupdate = null
     }
  }      

  function deferNavigation( update, args ) {
    if( args[1] && args[1][0] === 'l' && 
      this._name === this._parent.last.from.key.val
    ) {

      this.clearCache()
      //TODO: more specific may be too many updates???
      // console.log('lezz update it', this._parent._path, this._path)

      update()

      // this._parent._update.apply( this._parent, args )


    } 
    else 
    {
      update( true )
    }
  } 

})

},{"../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/origin.js":[function(require,module,exports){
//userOrigin
var util = require('../../util')
  , MockData = require('./mockdata')
  , timestamp = require('monotonic-timestamp')

exports.extend = util.extend( function( vObject ) {

  var _coreSet = vObject.set
    , _fromUser = function( obj ) {
        var val = obj
          , nav
          , last

        while (val && !val._removed && val instanceof vObject) {

          if( val._parent && val._parent._prop && val._parent._prop.name === 'navigation' ) {
            nav = val
          } 

          if( ( val.cloud && val._path[0] === 'users' ) 
              || val instanceof MockData 
            ) {
            return [ val, nav ]
          }
          last = val;
          val = val._val;
        }

        var result = last && !last._removed && last !== obj
          ? last 
          : false

        return [ result, nav ]

      }

  util.define( vObject, 
    '$userOrigin', {
    set: function( val ) {

      var search = _fromUser(this)
        , found = search[0] //|| this
        , nav = search[1]
        , same

      if(!found) {
        var propname = this._prop && this._prop.name

        if(propname) {
          // console.error('>>>>>>>> making and linking', propname)

          var user = this._caller,
            linkeduser = user.data._val

          if(!linkeduser) {
            console.error('????', val)
            debugger
          }

          found = linkeduser.get(propname, {})
          this.val = found
        }
      } else {
        // console.error('FOUND', this._prop && this._prop.name, found._path, found.raw, found)
      }

      if(!found) {

        // console.error('no user but do from')
        // return _coreSet( this.from, val )

        throw new Error('cannot find correct $userOrigin for '+ ( this._name || this._prop && 'propety '+this._prop.name ) )
      }

      _coreSet.call( found , val)

      if(nav && nav._name ) {
        nav._parent.last.from.val = 
        { time: timestamp()
        , key: nav._name
        }
      } 

    },
    get: function() {
      return _fromUser( this )[0] //|| this
    }
  })
})
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , user = require('./')
  , vObj = require('../../object')

exports.extend = util.extend( 
function( base ) {

  function setUser(i) {
    //make these 2 more defualt
    // console.log(i)
    // console.log( 'swtich to user', i, this.data._val )
    this[i] = this.data.$userOrigin.get( i, this[i]._prop.$default )
  }

  function setMock(i) {
    // console.log( 'swtich to mock', i, this.mockdata[i] )
    this[i] = this.mockdata[i]
  }

  base.define({
    _set: function(val, i ) 
    {
      if ( this[i] instanceof vObj ) 
      {
        //TODO: torough testing
        this[i].val = val[i]
      } 
      if (typeof this[i] === 'function') 
      {
        if (val[i] instanceof Array) 
        {
          this[i].apply(this,val[i])
        } else 
        {
          this[i](val[i])
        }
      } 
      else 
      {
        if ( this.isProperty( i, val ) ) {
          // console.warn('this is a property!', i , val )
          this[i] = val[i]
        } else {
          if( this[i] ) 
          {
            // merge? check ook voor cloud bijvoorbeeld
            this[i] = val[i]
          }
          else 
          {
            // console.error('NOW LETS MAKE A BASIC TYPE', i, this)

            var mock = {}

            mock[i] = val[i]

            var subscription = {}
            subscription[i] = true

            // this.mockdata = mock

            this.extend({
              name:i
            , mock: mock
            , $default: val[i]
            , subscription: subscription //maybe do this if not specified
            , on: {
                mock: setMock
              , user: setUser
              }
            })

            //dit beter---- moet namelijk niet val[i] worden maar mockdata (of meteen switchen naar userData)
            
           

          }
        }

        // console.log('hey', i, this[i] )
        
      }
    }
  })

})
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/token.js":[function(require,module,exports){
var util = require('../../util')
  , Value = require('../../value')
  , cases = require('../../browser/cases')

require('../../value/flags/process')

//TODO: url error on start up (set from cloud)
exports.extend = util.extend
( function( base ) {

  base.define({
    updateId: function( res ) {
      this.id = res instanceof Array ? res[ res.length -1 ] : res
      
      //hier ff voor navigation
      //get last?
    }
  , authenticate: function authenticate( _this, request, val, update ) {
      var user = this
        , cloud = user.cloud

      if(cloud.params.fastLogin && typeof localStorage !== "undefined"){
        var userId = localStorage.getItem('userId')
        if(userId){
          request.id = userId
        }
      }
      // console.log('go cloud.authenticate!!')
      cloud.authenticate( request, function( res ) {
        
        if(res.error && typeof localStorage !== "undefined"){
          localStorage.removeItem('userId')
        }
        _this.clearCache()

        if(val !== _this.val){
          // console.error('\n\n\ndid a fast re-login! -- double check')
        }

        if( res.error || !_this.val ){
          _this.val = false
          user.id = false
          update()
          if( res.error ){
            console.error('authenticate error:', res.error)
          }else{
            if(! (user.iplogin && user.iplogin.val) ){
              user.cloud.emit('logout', res )

              if(typeof localStorage !== "undefined" ){
                localStorage.removeItem('userId')
              }
            } 
            // console.error('token is set to false while authenticating (logout! -- need to get a method to break it while in progress)')
          }
        }else{
          // console.log('AUTH SUC6', user, res )
          //dit is ook wrong completely! -- dit alleen doen met een usertoken!!!!
          // anders wachten tot een overtake actie
          if( _this.val !== true ) {
            user.updateId( res )
          }

          if(cloud.params.fastLogin && typeof localStorage !== "undefined"){
            var userId
            if(res instanceof Array)
              userId = res[res.length-1]
            else
              userId = res
            localStorage.setItem('userId', userId)  
          }

          if(user.iplogin && user.iplogin.val) {
            // console.log('TV LOGIN SUCCESS! maybe go make maself dat user')
            // console.log('>>> token', user.token.val)
            
          }
          
          update()
        }
      })
    }
  })
  
  // console.log('????????????? set iplogin', cases.$isTv || cases.$isChromecast)
  // base.iplogin = cases.$isTv || cases.$isChromecast
  
  base.extend(
  { //primary
    iplogin: { val: cases.$isTv || cases.$isChromecast },
    token:{
      // TODO: when IP based connectivity is fixed this is not needed
      subscription: {
        token: true
      },
      val:{
        transform: function( val, cv ) {
          return ( cv instanceof Object ) ? false : cv
        },
        defer:function( update, args, tempdefer ) {

          if(args[0] && args[0].defer) return true

          var token = this
          var user = token._caller

          // console.error('TOKEN SET!xxx', token)

          user.cloud.connected.is(true, function() {
            var oldval = args
              , val = token.val
              , userId = user.id && user.id.val
              , iplogin = user.iplogin && user.iplogin.val

            // if( user.iplogin && user.iplogin.val ){
            //   iplogin = true
            // }
            //DOUBLE CHECK --- this was in there to allways make sure this stuff did not happen...
            // if( user.activeClient && user.activeClient.$userOrigin && user.activeClient.from === user.client.from  ) {
              // console.log('mc dirty lets fix this here! on logout set false to be certain', user.activeClient.$userOrigin )
              // user.activeClient.$userOrigin = false
            // }

            token.clearCache()

            // console.error('token is set!', val)
            // console.log('token is set!', iplogin)

            if( userId && !iplogin ){
              // console.log('LOGOUT ---> EMIT'.red.inverse, userId )
              var _last = user.cloud.logout( userId )
              if(typeof localStorage !== "undefined"){
                localStorage.removeItem('userId')
              }
            }

            if( val ){

              var url = user.cloud.api.get('auth')

              var request = 
              { url: url
              , subs: user.subscriptions
              , token: val
              //TODO: also add tv
              }
              , auth = user.__authenticated__

              if( iplogin ){
                // this is all tv vibes
                if( val === true ) {
                  delete request.token
                }
                request.tv = true

                if( !auth ){
                  // console.log('IPLOGIN FIRST TIME POP DAT AUTHENTICATE')
                  user._authrequest = request
                  user.authenticate( token, request, val, update )
                  user.__authenticated__ = true
                }else{
                  var users = user.cloud.data.get('users')
                    , set

                  // console.error('IPLOGIN USERSWITCH')
                  // find the user I should switch to
                  users.each(function( key ) {

                    // console.log('>> HAVE USER', this)
                    var clouduser = this

                    if(clouduser.token && clouduser.token.val === token.val) {
                      // im switching to this user
                      set = clouduser._name
                      // console.log('switch to this usert!')
                    } else {
                      if(
                        clouduser.receiverClient && 
                        clouduser.receiverClient.from === user.cloud.client.from
                        ){
                        // console.error('this other user has me as receiverClient, better remove')
                        clouduser.receiverClient.$userOrigin = null
                      }
                      if(clouduser.activeClient && 
                        clouduser.activeClient.from === user.cloud.client.from
                        ){
                        // console.error('this other user has me as receiverClient, better remove')
                        clouduser.activeClient.$userOrigin = null
                      }
                    }
                  })
                  if(!set) {
                    user.id = false
                  }else{
                    user.id = set

                  }
                  update() 
                }

              }else{
                user._authrequest = request
                user.authenticate( token, request, val, update )
              }
            }else{
              user.id = false
              update() 
            }
          })
        }
      }
    },
    localStorageToken: {
      val: {
        defer:function(update, args) {
          var user = this._caller
          if(!user._readLocalStorage && typeof this.val === 'string') {
            user._readLocalStorage = this.val
            var token = localStorage.getItem(user._readLocalStorage)
            if(token && token !== 'true') {
              user.token = token
            }
            user.token.on(function() {
              var tokenval = this.val
              if(typeof tokenval === 'string') {
                localStorage.setItem(user._readLocalStorage, tokenval)
              } else {
                localStorage.removeItem(user._readLocalStorage)
              }
            })
            update()
          } else {
            update(true)
          }
        }
      }
    }
  })

  // base.token = false

  base.cases.$isLoggedIn = new Value(
  { val: base.token
  , transform:function(val, cv) {
      if(cv === true) return 0
    }
  })

  var myclient = base.cloud.client

  myclient.on(function(val, stamp, from){
    // console.log('something happened on my cloud client!')
    origin = from || this._updateOrigin
    if(stamp === base.cloud.stamp) {
      var cloudclient = myclient.from
      if(cloudclient.token){
        // console.log('-------- token on user is now', base.token.val, 'set with', cloudclient.token.val)
        base.token.val = base._authrequest.token = cloudclient.token.val

        // console.log('-------- did set token on user')
      }
    }
  })

  base.token._name = 'token'

})




},{"../../browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/type.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , Value = require('../../value')//.new()
  , objectSet = require('../../object').set
  , util = require('../../util')

// Value.inject(require('./listen_fix'))

module.exports = {
  type: Value,
  create: function(val, prop, settings, noupdate) {

    // console.log('create it', val, settings )
    var v = new Value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings) {

      if (!settings._vset) {

        //can also add a thing to set on get by default?

        if(settings.mock) {
          //if not set add some efficiency plz
          this.mockdata = settings.mock
        }

        if(settings.subscription) {
          this.subscriptions = settings.subscription
        }

        if(settings.on) {
          if( typeof settings.on === 'function' ) {
            this.on.mock[settings.name] = settings.on
            this.on.user[settings.name] = settings.on
          } else {
            if(settings.on.mock && !this.on.mock[settings.name]) {
              // console.log(base, base.on)
              this.on.mock[settings.name] = settings.on.mock
            }
            if(settings.on.user && !this.on.user[settings.name]) {
              this.on.user[settings.name] = settings.on.user
            }
          }
        }

        settings._vset = function(stamp, from, remove, cval) {
          
          var base = this._caller
                || this._base
                || this


          //if !base --
          // if(!base.)

          if(settings.set) {
            settings.set.call(
              base, this, stamp, from, remove, cval
            )
          }
        }
      }

      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  set: function(val, prop, settings) {
    // console.error('set it', val )
    this._caller = this
    return val
  },
  get: function(prop, settings) {
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/usage.js":[function(require,module,exports){
var util = require('vigour-js/util')

var vObject = require('vigour-js/object')

var MockData = require('./mockdata')

var cases = require('vigour-js/browser/cases')

var Data = require('vigour-js/data')
      .inject( require('vigour-js/data/selection') )


require('vigour-js/value/flags/process')

exports.extend = util.extend
( function( user ) {

  var content = user.parent.inject(require('../content')).content

  user.extend({
    usage: {
      mock: {
        usage:{}
      },
      subscription: {
        usage: {
          shows: {
            $: {
              media:{
                //dit moet sowieso niet title worden! liever gewoon true of id ofzo
                $:true
              },
              favourite:true,
              timestamp:true
            }
          }
        }
      },
      on: {
        mock:function() {
          this.usage = this.mockdata.usage
        },
        user:function() {
          this.usage = this.data.from.get('usage',{})
        }
      }
    },

    watched:{
      on: {
        //mischien eigen , nieuwe selection maken alvast
        mock: function() {
          if(this.__watched) {
            this.__watched.remove()
            this.__watched = null
          }
          if(this.watched) this.watched.$empty()
          this.watched = {}
        },
        user:function() {
          var user = this
          if(this.__watched) {
            this.__watched.remove()
            this.__watched = null
          }

          var selection = this.__watched = new Data( user.usage.from.get('shows') , {
            condition: { 
              media: {
                title: {
                  $exists: true
                }
              }
            }
          })

          user.watched = {}

          selection.on(function() {
            var sets = {}

            selection.each(function(i) {
              var bla =  content.get(this._path.slice(-2))
              var obj = {}
              
              util.path(obj, bla._path, {
                img:true,
                title:true
              })

             var _cloud =  user.parent.cloud
             _cloud.subscribe(obj)

              user.watched.set(this._name, 
              { show: bla
              , media: this.media.from
              })

              user.watched[this._name].once('remove', function() {
                _cloud.unsubscribe(obj)
              })

              sets[this._name] = true
            })

            user.watched.each(function(name) {
              if(!sets[name]) {
                if(user.watched)
                this.remove()
              }
            })

            sets = false

            user.watched.update()
          })
          selection._update()

        }
      } 
    },

    favourites:{
      on: {
        //mischien eigen , nieuwe selection maken alvast
        mock: function() {
          if(this.__favourites) {
            this.__favourites.remove()
            this.__favourites = null
          }
          if(this.favourites) this.favourites.$empty()
          this.favourites = {}
        },
        user:function() {
          var user = this
          if(user.__favourites) {
            user.__favourites.remove()
            user.__favourites = null
          }
          this.favourites.$empty()
          var selection = user.__favourites = new Data( user.usage.from.get('shows') , {
            condition: { 
              favourite: true
            }
          })

          user.favourites = {}

          selection.on(function() {
            var sets = {}

            selection.each(function(i) {
              var bla =  content.get(this._path.slice(-2))

              user.favourites.set(this._name,bla)
              sets[this._name] = true
            })

            user.favourites.each(function(name) {
              if(!sets[name]  ) {
                this.remove()
              }
            })

            sets = false

            user.favourites.update()
          })
          selection._update()

        }
      } 
    }
  })

  user.extend({
    hasWatched: {
      val: {
        val: user.watched,
        transform: hasTransform
      }
    },
    hasFavourites: {
      val: {
        val: user.favourites,
        transform: hasTransform
      }
    }
  })

  var oldContent = content._val

  content.on('self', function() {
    // console.log('content is changing from', oldContent && oldContent._path, 'to', this._val._path)
    if( user.token.val ) {
      resolveWatchedMedia( user )
      user.favourites._prop.on.user.call(user)
      user.watched._prop.on.user.call(user)
    } else {
      resolveWatchedMedia( user )
      user.favourites._prop.on.mock.call(user)
      user.watched._prop.on.user.call(user)
    }
  })

  cases.$hasFavourites = user.hasFavourites
  cases.$hasWatched = user.hasWatched

})

function resolveWatchedMedia( user ) {
  user.watched.from.each(function() {
    var media = this.media && this.media.from
    if(media) {

      var newPath = user.parent.content.from._path.concat( media._contentPath )       
      var oldPath = media._path

      if( !util.compareArrays( oldPath, newPath ) ) {
        console.log('resolve', oldPath, newPath)
        this.media.val = user.parent.content.get( newPath )
      }
    }
  })
}

function hasTransform( c, cv) {
  var selection = c._parent._val
  if(selection) {
    if(selection.$length.val>0) {
      return true
    }
  }
  return 0
}
  
},{"../content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","./mockdata":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/mockdata.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","vigour-js/data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/values.js":[function(require,module,exports){
var util = require('../util')
  , Value = require('../value')
  , url = require('../browser/network/url')
  , ua = require('../browser/ua')

require('../value/flags/process')

//---------------------------------------


//---------------------------------------

exports.extend = util.extend( function( app ) {

  //use cases reference on app
  var cases = app.cases || ( app.cases = require('../browser/cases') )

  app.initialised = new Value( false )

  app.overlay = new Value( false )

  app.focusState = new Value('menu')

  app.region = new Value({ init: app.initialised })
  //browser
  //ua.browser

  app.url = ua.device === 'tv' && ua.platform === 'lg' 
        ?  new Value({defer:function(){}, params:{}, string:''}) 
        :  url 
  //ook pas op app initilised!

  app.ready = new Value()

  app.menu = new Value({ init: app.ready })

  //TODO:network
  //move network api file to here perhaps
  app.network = new Value()

  //TODO: double check this is efficient
  app.loading = new Value({ 
    init: app.ready
  , defer: function( update, args ) {
      //TODO: cached updatePath ?
      var id = this.updatePath.join('.')
      if( args[0]===false && ( (id && id === this.id) || !this.id ) ) {
        this.val = args[0]
        this.id = false
      } else if( args[0] === true ) {
        this.id = id
        this.val = true
      }
      update()
    }
    //add defered later (maybe dont show a loader for less then xxx sec) 
  })

  // '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //add localstorage

  var guessLanguage = app.guessLanguage = function guessLanguage(){
    //TODO: cordova language
    var guess = window.navigator.userLanguage
             || window.navigator.language
             || app.region.val 
    if(guess)
      return guess.slice(0,2).toLowerCase()
  }

 app.language = new Value(  
  { transform: function( val, cv ) {
      if(!cv || typeof cv !== 'string') {
        cv = guessLanguage()
      } 
      return cv ? cv.slice(0,2).toLowerCase() : false
    }
  , init: app.initialised 
  })

  app.fullscreen = new Value({ force: true })

  app.loader = new Value()

  app.volume = new Value(
  { val:1
  , transform:function(v,cv){
      // console.log('volume?',cv,isNaN(cv) ? 1 : cv)
      //TODO: use loDash for isNan
      return isNaN(cv) ? 1 : cv
    }
  })

  app.popup = new Value({ init: app.ready })

  app.preview = new Value({ init: app.ready })

  app.highlight = new Value({ init: app.ready })

  app.state = new Value({ init: app.ready })
  
  app.notification = new Value( 
  { init: app.ready  
  , force: true //TODO: make this better
  })

  app.isPlaying = new Value(
  { init: app.ready
  , val:false
  })

  app.restrictPlayback = new Value()

  //make injectable
  app.wifiOnly = new Value(
    localStorage 
    ? { val: localStorage.getItem('wifiOnly') || false
      , defer:function( update ){
          if(this._val) localStorage.setItem('wifiOnly',true)
          else localStorage.removeItem('wifiOnly')
          update()
        }
      }
    : false
  )

  app.restrictPlayback.val = 
  { val: app.wifiOnly
  , transform:function(v,cv){
      return ( cv && cases.$isNative && api.network.val !== 'wifi' )
        ? true
        : false
    }
  }

  // TODO: move this (setting case value) out of app values
  cases.$storeAvailable = new Value( 
    cases.$isNative && ( cases.$isIos || cases.$isAndroid || cases.$isWindowsMobile ) //&& window.Store
  )

})
},{"../browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../browser/network/url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js","../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('../')
  , util = require('../util')
  , inject = require('../util/inject')
// , raf = require('../browser/animation/raf')


/*
  util.define( extend, 'extensions',{val:[], setClass:true} )
*/

/**
 * Base is used as a class constructor.
 * @constructor V.Base
 * @param  {*} [val] Startvalue for new V.Base
 */
var base = V.Base = module.exports = exports = function(val) {
  this._from = this.constructor
  if (val) this.set(val)
}

exports.settings = require('./settings')

/**
 * Sets properties defined in an object.
 * Define a _set method on a base instance to get custom method per set.
 * @function _set
 * @param  {*} val         Any value
 * @param  {*} [params]    Added parameters
 * @param {Boolean} noset  When true returns a parsed val object but set nothing
 * @return {Object}        return self for chaining
 */
var _set = exports.set = function(val, params, noset) {
  for (var i in val) {
    if (~i.indexOf(',')) {
      for (var arr = i.split(','), multiobj = {}, m = 0, ml = arr.length; m < ml; m++) {
        multiobj[arr[m]] = util.clone(val[i])
      }
      if (!noset) {
        _set.call(this, multiobj, params, noset)
      } else {
        delete val[i]
        for (var n in multiobj) {
          val[n] = multiobj[n]
        }
      }
    } else {
      i = util.dotField(val, i)

      // console.error( 'SET', this, this._set)

      if (this._set && !noset) {
        this._set.call(this, val, i, params)
      } else {
        //TODO: check for property move from element set to here
        // if( V.Object && this.isProperty( i, val ) && this[i] instanceof V.Object )
        // {
        //   console.log('??', i, val, this.isProperty( i, val ) )
        //   this[i].val = val[i]
        // }
        // else
        // {
          this[i] = val[i]
        // }
      }
    }
  }
  return noset ? val : this
};

util.define(base,
  /**
   * When a Base is extended without defining the type this is the default type.
   * @property defaultType
   */
  'isProperty', function( i, val) {
    var t = this
      , result = 

      
    // val[i] instanceof Object  //THIS MAY GO AWAY LATER
           //TODO: check if this is really nesseracy ( void 0 )
           // && 

      //SUPER DANGERGOUS THING

          !( t._[i] === void 0 //--- danger resolve when define _ is fixed
           && !util.lookup.call(t, i) 
           && typeof t[i]!=='function' 
          )

    // console.log( val[i] instanceof Object, t._[i] === void 0, 'val:',t._[i], !util.lookup.call(t, i), typeof t[i]!=='function'  )

    // console.log( 'IS PROPERTY', i, result )

    return result
  },
  'defaultType', false,
  'extensions', false,
  'define', function(val) {
    for(var i in val) {
      util.define( this, i, val[i] )
      util.define( this.Class, i, val[i] )
    }
  },
  /**
   * Extend is used to add properties to base.
   * Settings are similar to standard defineProperty.
   * @method extend
   * @param   {Object}   settings        Define the following fields: name, type, set, new, remove.
   * @param   {String}   settings.name   Define the name of the property
   * @param   {Object}   [settings.type] Define the type of object e.g. V.Value, set type to false if you want to use standard defineProperty
   * @param   {Function} settings.set    Define a function on set
   * @param   {Function} settings.new    Define a function on construct
   * @param   {Function} settings.remove Define a function on remove
   * @return  {[type]}                   [description]
   */
  'extend', function(settings) {

    //TODO: add to instance as well , have a dictionary of extenstions -- get to orginal easyly
    var args = util.arg(arguments)
      , l = args.length
      , i

    if (l > 1) {
      for (i = 0; i < l; this.extend( args[i++] ));
    } else if (!settings.name) {
      for (i in settings) {

        if( typeof settings[i] === 'function' ) 
        {
          this.extend( { name: i, set: settings[i] } )
        }
        else
        {
          settings[i].name = i
          this.extend( settings[i] )
        }

      }
    } else {

      if( settings === true ){
        alert()
      }


      if (!settings.def && settings.def !== 0) settings.def = false;
  
      if (this.Class.prototype._settings) {
        exports.settings.parse.call(this, settings)
        if (settings._settings) exports.settings.create.call(this, settings)
      }
      //1. normal extensions
      if (settings.type === false || ( !settings.type && !this.defaultType ) ) {

        //TODO: test if double define is actually ok!
        // util.define(this, settings.name, settings)

        util.define(this.Class, settings.name, settings)

      } else {
        //2. V.Values
        if (!settings.type) settings.type = this.defaultType
          //a type has fields type, set ,get, create
        var get =  function(prop) {
            //custom get
            return settings.type.get 
              ? settings.type.get.call(this, prop, settings)
              : prop
          }
          , set =  function(val) {

            var prop = this[settings.name]
            if(prop===null) return
            if (prop===settings.def) { //(prop instanceof V.Object)
              //return is hier mischien niet nodig;
              return settings.type.create.call(this, val, prop, settings)
            } else {
              val = settings.type.set.call(this, val, prop, settings)
              if (val!== null) prop.val = val
            }
          }

        //TODO: test if double define is actually ok!
        util.define(
          this,
          settings.name,
          settings.def,
          set,
          get,
          true
        )
        //dit breaked wat shit

        //or on value ? value.prop

        //make extended prototype object perhaps
        // this.Class.prototype['__'+settings.name+'__'] = settings

        util.define(
          this.Class,
          settings.name,
          settings.def,
          set,
          get
        )
      }
    }
  },
  /**
   * Removes this Base. Also removes all listeners added to extensions.
   * Instances true will remove all instances as well.
   * @method remove
   * @param  {[type]} instances  [description]
   * @param  {[type]} fromremove [description]
   * @param  {[type]} params     [description]
   */
  'remove', function(instances, fromremove, params) {

    // this._removing = true

    if(!this._from) return

    this.setting('remove', [params]);

    if (!fromremove) {
      var ins = this._from.base.instances
      if(ins) {
        for (var n = 0, l = ins.length; ins[n] !== this || !ins.splice(n, 1); n++);
      }
    }

    for (var i in this.__) {
      if (this.__[i] instanceof V.Object) {
        //nested, blacklist, not (fields in object), from, stamp, noupdate
//         console.log('---------', i, this.__[i], this.__[i]._path )
        this.__[i].remove(false, false, false, false, false, true);
        this.__[i] = null
      } else {
        this.__[i] = null
      }
    }
    this.__ = null

    if (instances && this.instances) {
      for (j = this.instances.length - 1; j >= 0; this.instances[j--].remove(true, true));
    }

    for (var j in this) {
      // if(this[j] instanceof V.Base) {
      //   this[j].remove()
      // } 
      this[j] = null;
    }

    this._settings = null
    this._ = null
    delete this._settings
    delete this._
    delete this.__
    // delete this._class; may not be nessecary
  },
  /*set on prototype*/
  'set', _set,
  'get', function( path, self ) {
    return util.get( this, path, self )
  },

  'inject', inject,
  /**
   * Passes field parameter only for instances matching a field
   * @method
   * @param  {Function} fn    [description]
   * @param  {String}   field [description]
   * @param  {*}        val   [description]
   * @param  {*}        p     [description]
   * @return {Boolean}        [description]
   */
  'eachInstance', function(fn, field, val, p) {
    var instances = this.instances;
    if (instances) {
      for (var i = 0, l = instances.length, instance; i < l; i++) {
        instance = instances[i];


//problem! has to correct for missing instances!!!
//   console.log(instance, instances)

          

        if (instance && (!field || !instance.__ || !instance.__[field])) {
          if (fn.call(instance, val, p)) {
            return true;
          }
          if (instance.eachInstance(fn, field, val)) {
            return true;
          }
        } else if(!instance) {
          console.error('\n\n\n\ninstance in base gone?', i , instances)
          // debugger
        }
      }
    }
  },
  /**
   * Creates a class from the current Base instance
   * @constructor Class
   * @return {Object}
   */
  'Class', {
    get: function() {
      if (!this._class) {
        this.instances = [];
        this._class = function(val, proto, setting) {
          if (!proto) {
            var from = this._from.base;
            from.instances.push(this);
            if (this.setting) {
              this.setting('new', [from, setting]);
            }
            if (val) {
              this.set(val);
            }
          }
        };
        this._class.base = this;
        this._class.prototype = new this._from(false, true);
        this._class.prototype.__ = null;
        util.setstore.call(this);
        var i, _proto = this._class.prototype._ = {};
        for (i in this.__) {
          _proto[i] = this.__[i];
        }
        for (i in this._) {
          if (_proto[i] === void 0) {
            _proto[i] = this._[i];
          }
        }
        this._class.prototype._from = this._class;
        this._class.inject = inject
      }
      return this._class;
    }
  });
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./settings":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/settings.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/settings.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('./'),
  util = require('../util');

/**
 * Settings are used for special cases e.g. onRemove or onNew instance
 * @property
 */
util.define(base, '_settings');

base.prototype._._settings = {};

/**
 * Set settings on Base
 * @function _set
 * @param  {Object}  set      Object to set
 * @param  {Boolean} [remove]
 * @param  {Boolean} [force]  True/false
 */
var _set = function(set, remove, force) {
  var _s = set._settings //e.g. node , remove and parent
    , t = this
    , __t = t._._settings
    , setting
    , i
    , _t

  util.setstore.call(t)

  if (!t.__._settings) {
    // console.log('create my own settings')
    t.__._settings = {}
    for (var j in __t) {
      t._settings[j] = __t[j]
    }
  }

  _t = t.__._settings

  // console.log('SETTINGS?'.inverse, set, __t)

  for (i in _s) {
    setting = _s[i]
    //efficient memory management only make own if absolutely nessecary
    if ((remove && _t[setting][set.name]) || (!remove && !_t[setting][set.name]) || force) {
      
      if (_t[setting] === __t[setting]) {
        _t[setting] = {}
        for (var n in __t[setting]) {
          _t[setting][n] = __t[setting][n]
        }
      }

      if (remove) {
        this.eachInstance(function() {
          if (this[set.name] !== t[set.name]) {
            if (this._setting !== _t && this._settings[setting] === _t[setting]) {
              // console.log('found that the settings are the same and not the same property make my own');
              // console.log('------ SETTING')
              _set.call(this, _t[setting][set.name], false, true);
            }
          } else {
            if (this._setting !== _t && this._settings[setting] !== _t[setting]) {
              // console.log('------ REMOVE SETTING')

              // console.log(this.name,set.name,'found that the property is the same but settings are not!');
              this.removeSetting(set.name, setting);
            }
          }
        });
        _t[setting][set.name] = null;
        delete _t[setting][set.name]; //delete is kut!;
        if (util.empty(_t[setting])) {
          // console.log('lets put this to true!')
          _t[setting] = true;
        }
      } else {
        // console.log('------ DO SETTING', set, _t, setting, set.name)
        if(_t[setting]===true) {
          _t[setting]={}
        }
        _t[setting][set.name] = set;
        // console.log('RESULT?', setting, _t[setting])
      }
    }
  }

  // console.log('SETTINGS? -- result'.inverse, _t, this._settings===_t, this.BLUXEN)

};

/**
 * Creates a setting
 * @method create
 * @param  {[type]} set [description]
 * @return {[type]}     [description]
 */
exports.create = function(set) {
  set._set = set.set;
  set.set = function(val, prop) {
    _set.call(this, set)
    set._set.apply(this, arguments)
  }
}

/**
 * Extracts settings from settingsobject and stores them in an array.
 * @method parse
 * @param  {Object} settings Settingobject
 * @param  {Object} object   Settingsobject
 */
exports.parse = function(settings, object) {
  if (!object) {
    object = this._settings
  }
  for (var i in object) {
    if (settings[i]) {
      if (!settings._settings) {
        settings._settings = [];
      }
      settings._settings.push(i);
    }
  }
};

/**
 * Adds setting(s) to Base prototype
 * @method add
 * @param  {String[]}    name  Array of settingnames
 * @param  {Prototype}   proto Prototype eg. myBase class
 */
exports.add = function(name, proto) { //start using this sometimes!;
  if (name instanceof Array) {
    for (var i in name) {
      if (proto) {
        this.add(name[i], proto);
      } else {
        this.addSetting(name[i], false);
      }
    }
  } else {
    if (!proto) {
      util.setstore.call(this);
      if (!this.__._settings) {
        this.__._settings = {};
      }
      for (var j in this._._settings) {
        this._settings[j] = this._._settings[j];
      }
      this._settings[name] = true;
    } else {
      proto.prototype._settings[name] = true;
    }
  }
};

/**
 * Add settings to instances of Base
 * settings only work for instances of the added Basesettings
 * @method
 */
util.define(base,
  'addSetting', function(name) {
    exports.add.call(this, name);
    if (this._class) {
      this._class.prototype._._settings = this._settings;
    }
  },
  /**
   * Simple implementation of setting.create
   * @method setSetting
   * @param  {Object} set Settingobject
   */
  'setSetting', function(set) {
    //eerst checken of ie al bestaat anders kan het voorkomen dat het teveel is
    exports.parse.call(this, set);

    // console.log('SET SETTING'.yellow.inverse, set, this._settings )

    //get gebruiken --- object is een check op meerdere fields returns true of false // bij get ook mogelijk om field mee te geven
    _set.call(this, set);

    // console.log('SET SETTING -- result'.yellow.inverse, this._settings )

  },
  /**
   * [description]
   * @method removeSetting
   * @param  {String}       name     Name of the setting to remove
   * @param  {Array|Object} settings Settingobject
   */
  'removeSetting', function(name, settings) {

    // if(!settings) {
    //   //this may all be not nessecary!
    //   for(var i in this._settings) {
    //     for(var j in this._settings[i]) {
    //       if(this._settings[i][j].name===name) {
    //         settings=this._settings[i][j]
    //         break;
    //       }
    //     }
    //   }
    // }

    if (!(settings instanceof Array)) {
      //this may all be not nessecary!
      // if(settings instanceof Object) {
      //   settings = settings._settings
      // } else {
        settings = [settings];
      // }
    }

    for (var i = settings.length - 1, found, _settings = this._settings; i >= 0; i--) {
      if (_settings && _settings[settings[i]] && _settings[settings[i]][name]) {
        found = true;
        break;
      }
    }
    if (found) {
      _set.call(this, {
        name: name,
        _settings: settings
      }, true);
    }
  },

  /**
   * Checks if object has settings and executes them. Arguments are passed to settings.
   * @method setting
   * @param  {String}    name Name of the setting
   * @param  {Arguments} arg  Arguments to pass to settings
   */
  'setting', function(name, arg) { //misschien arg
    var _s = this._settings;
    if (_s && _s[name] && _s[name] !== true) {
      for (var i in _s[name]) {
        _s[name][i][name].apply(this, arg);
      }
    }
  });

/**
 * Base has two default settings
 * new is invoked on construction , remove on removal;
 * @settings
 */
exports.add(['new', 'remove'], base)

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/easing.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var animation = require('./');
animation.easing = exports;
// t: current time, b: beginning value, c: change In value, d: duration
// courtesy of Robert Penner
exports.inCubic = function(t, b, c, d) {
  return c * (t /= d) * t * t + b;
};

exports.outCubic = function(t, b, c, d) {
  return c * ((t = t / d - 1) * t * t + 1) + b;
};

exports.outBack = function(t, b, c, d, s) {
  var s = 1.70158;
  return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
};
},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/frame.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var Value = require('../../value')
  , frame = new Value(1)
  , util = require('../../util')
  , _on = function() {
    // console.group()
    // console.log('\n\n----RAF----'.magenta.bold)
    exports.rafId = window.requestAnimationFrame(_on)
    frame.val++
    // console.groupEnd()
  }

frame.done = new Value(true)

util.define(frame,
  'addListener', function(val, mark, remove) {
    if (!this._listeners){
      this.done.val = false
      _on()
    }
    Value.prototype.addListener.call(this, val, mark, remove)
  }
, 'removeListener', function(val, mark, remove) {
    var t = this
    Value.prototype.removeListener.call(t, val, mark, remove)
    if (!this._listeners) {
      window.cancelAnimationFrame(exports.rafId)
      this.val = 1
      this.done.val = true
    }
  }
)

module.exports = frame
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

var element = require('../element').inject(require('../element/properties')) //element added (extend) //call extend on flags (make buffer if already extended)
  , object = require('../../object')
  , util = require('../../util')
  , flags = require('../../value/flags/util')
  , operators = require('../../value/operators')
  , frame = require('./frame')
  , _linear = function(t, b, c, d) {
    return c * t / d + b
  }
//-------------------------------------------------------------------
operators._a = function (val, operator) {
  return operator
}

function preventSet(val) {
  this._p = true
  this.val = val
  this._p = false
}

operators._a.order = 2

flags.animation = {
  set: function (val) {
    
    var thisObject = this
      , _p = thisObject.checkParent('_prop')

    if (val) {

      if (!thisObject._val) thisObject.val = 0

      var name = _p._prop.name
        , element = _p._caller
        , noListener = val.noListener
        , path = thisObject._path
        , id = name.concat(path.join(''))
        , skip = val.skip
        , easing = val.easing 
          && exports.easing[val.easing] 
          || val.easing 
          || _linear
        , time, start, ready

      if(!_p._animListen) _p._animListen = function (val) {
        var tn = this[name]
        if(tn) tn.update(this, true)
        else {
          var FORTESTING = frame._listeners && frame._listeners.length
          console.log('_animListen setting',frame._listeners && frame._listeners.length)
          frame.removeListener(void 0, this)
          console.log('>> _animListen setting',frame._listeners && frame._listeners.length)
          if(FORTESTING && FORTESTING === (frame._listeners && frame._listeners.length))
          {
            console.error('this >>',this)
            // debugger
          }
        }
      }

      element.setSetting({
        name:'animation',
        remove:function() {
          var FORTESTING = frame._listeners && frame._listeners.length
          // console.log('remove setting',frame._listeners && frame._listeners.length)
          

          frame.removeListener( void 0, this)


          if(frame._listeners && FORTESTING && FORTESTING === (frame._listeners && frame._listeners.length))
          {
            for(var i in frame._listeners ) {
              if( frame._listeners[i] instanceof Array ) {
//                 console.log('COMPARE',frame._listeners[i][1]===this, frame._listeners[i][1], 'vs', this )
                if( frame._listeners[i][1]===this, frame._listeners[i][1] ) {
                    // frame._listeners.splice(i,1)
//                     console.error('this >>',this.node)
                    // debugger
                }
              }
            }
          }


        }
      })

      _p.preventSet = preventSet

      _p.set('translate', true)

      thisObject.set('_a', {
        time: val.time || 60,
        val: function(v, cv, b) {
          
          var t = this
            , a
            , prop = _p //t[name] ||
            , pr = t[name]

          if (!t._a) t._a = {}
        
          if (!t._a[id]) {

            start = val.start === void 0 
              ? t.rendered && (thisObject.__lval !== void 0)
                ? thisObject.__lval
                : cv
              : val.start instanceof object 
                ? val.start.val
                : val.start

            t._a[id] = {
              _start: start,
              _end: start,
              _current: start,
              _count: 0
            }

            if (!t.rendered) return start
          }

          if (t.rendered) {
            if(skip) {
              t._a[id]._current = cv
              skip = false
              return cv
            }

            a = t._a[id]
            if (pr._p || exports.prevent) {
              a._frame = 0
//               console.log('remove prevent',frame._listeners && frame._listeners.length)
              frame.removeListener(prop._animListen, this, true)
//               console.log('>> remove prevent',frame._listeners && frame._listeners.length)
              if (pr._p !== 1) {
                a._current = a._end = cv
                if (val.complete) noListener = val.complete.call(t, cv)
                if (val.done) setTimeout( function() { val.done.call(t,cv) }, 0)
                if (val.once) {
                  setTimeout( function() { 
                    if(val.once) val.once.call(t,cv) 
                    val.once = null
                  }, 0)
                }
              }
            } else if (a._frame !== frame.val) {
              if (a._frame || (cv !== void 0 && a._current !== cv)) { //checking a.frame faster than comparing a.current to cv
                if (a._end !== cv) {

                  if (val.init) val.init.call(t, a._current)
                  if(!noListener) {
                    frame.addListener([prop._animListen, this, name]
                      , function (listenArray, listeners) {
                        for(var i in listeners) {
                          if(listeners[i].pop) {
                            if(listeners[i].pop && listeners[i][1]===t && listeners[i][2]===name) {
                              return false
                            }
                          }
                        }
                       return true 
                      }
                    )
                  }
                  a._start = a._current
                  a._end = cv
                  a._count = 0
                  time = ~~v.time.val
                }
                a._frame = frame.val

                if(val.delay){
                  val.delay--
                  return a._start
                }

                var cnt = ++a._count
                a._current = easing.call(t, cnt, a._start, a._end - a._start, time || (time = ~~v.time.val))
                if(val[cnt]) val[cnt].call(this,a._current,cv)
              }
              if (a._count === time) {              
                a._current = cv
                a._frame = 0
                a._count = 0

                if (val.complete) noListener = val.complete.call(t, cv)
                if (val.done) setTimeout( function() { val.done.call(t,cv) }, 0)
                if (val.once) {
                  setTimeout( function() { 
                    if(val.once) val.once.call(t,cv) 
                    val.once = null
                  }, 0)
                }

                if(!noListener)
                {
//                   console.log('remove nolistener',frame._listeners && frame._listeners.length)
                  frame.removeListener(prop._animListen, this, true)
//                   console.log('>> remove nolistener',frame._listeners && frame._listeners.length)
                }
              }
            }
            return a._current
          } 
        }
      })
            
      _p._skip = true
      thisObject._skip = true
      
      if (val.start !== void 0) {
        var caller = this._caller
        if(!caller) caller = this.checkParent('_prop')._caller
        caller.setRender(name, function(parent) {
          this.update(name)
        })
      }
    } 
    else {
      thisObject.remove('_a')
      thisObject._skip = void 0
      _p._skip = void 0
      _remove(_p)
    }

  }
}
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js","../../value/operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../element/properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","./frame":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/frame.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var ua = require('../ua'),
  RAF = 'equestAnimationFrame',
  CAP = 'R' + RAF,
  util = require('../../util')
  lastFrame = 0;

util.define(ua, 'hasTransition', {
  get:function() {
    if(!ua._hasTransition) {
       var b = document.body || document.documentElement
        , s = b.style
        , p = 'ransition';
      ua._hasTransition = typeof s['t'+p] === 'string' 
        || typeof s[ua.prefix + 'T'+p] === 'string'
    }
    return ua._hasTransition
  }
})
  
RAF = 'r' + RAF;
if (!window[RAF]) { 

  ua.noRaf = true

  //window[ua.prefix + CAP] || 

  window[RAF] = function(callback) {
    return setTimeout(callback, 20);
  };
  window.cancelAnimationFrame = function(id) {
    clearTimeout(id);
  };
}



module.exports = exports = window[RAF]

exports.timer = function( fn, frames, repeat ){
  if( --frames ){
    exports(function(){
      if( repeat ) fn()
      exports.timer( fn, frames, repeat )
    })
  } else {
    exports( fn )
  }
}

exports.repeat = function( fn, frames ){
  exports.timer( fn, frames, true )
}

//check ios 6 paul irish says stuff goes wrong there...
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var cases = require('./'),
  element = require('../element'),
  setFlags = require('../element/set'),
  base = require('../../base'),
  util = require('../../util');

//------------------CASES FOR SET-------------------------------
var _css = function(t, name, invert, remove) {
    if (!invert) {
      if(!t.css) { t.css = '' }
      t.css.set( remove ? 'removeClass' : 'addClass', name ) 
      t.css.update(t)
                  // console.error('\n\n\nset css!!!!!xxx', name, t.node)

      t.eachInstance(function() {
            console.error('\n\n\ninstance! set css!!!!!', name, t.node)

        // if(this.css !== t.css) {
          this.css.set( remove ? 'removeClass' : 'addClass', name ) 
          this.css.update(this)
        // }
      })
    }
  },
  methods = cases.methods;

setFlags.remove = function(i, val, copy, top) {
  //this could become a seperate module since remove may be usefull for different purposes
  if (val && val.__remove__) {
    if (this[i] instanceof base) {
      top[i] = false;
    } else if (util.lookup.call(this, i)) {
      delete val.__remove__;
    } else {
      delete val[i];
      return true;
    }
  }
};

setFlags.cases = methods.reader(function caseReaderBase(name, val, dynamic, invert) {
  var t = this,
    f = function(obj) {
      obj = base.set(obj, false, true);
      for (var i in obj) {
        if (util.isObj(obj[i])) {
          obj[i] = f(obj[i]);
        }
      }
      return obj;
    },
    method,
    parsed,
    set,
    sVal,
    original;
  val = f(val);

  if (dynamic) {
    if (!t._cases) {
      t._cases = {};
    }
    if (val === null) {
      if (t._cases[name].method) {
        // console.error(name, 'case === null , remove it');
        cases[name].removeListener(t._cases[name].method);
      }
      if (cases[name].val) {
        t.css = {
          removeClass: name
        };
         t.eachInstance(function() {
            this.css = {
              removeClass: name
            };
         })
      }
      delete t._cases[name]; //removes case orginal
    } else {
      // console.error('SET CASE',name,t._cases[name]&&t._cases[name].method);
      parsed = methods.original(t, true, val, t._cases, true, name);
      t._cases[name] = {
        val: val,
        orig: parsed[0],
        nested: parsed[1]
      };

      if (!t._cases[name].method) {
        // console.error('this is what i have set for original', t._cases);
        method = t._cases[name].method = function() {

          // console.log('LETS TRY TO RUN METHOD',name,val);

          if (val) {
            set = methods.merge(true, name, val, t._cases); //arg no val;
            sVal = set [0];
            original = set[1];
            delete sVal.val;
            delete original.val;
            if (cases[name].val) {
              _css(t, name, invert);
              t.set(sVal, true);
            } else {
              _css(t, name, invert, true);
              t.set(original, true);
            }
          }
        };
        // console.error('ADD LISTENER TO',name,  t._cases[name]);
        cases[name].addListener(method);
        //remove setting on remove (saves memory)
        t.setSetting({
          name: '_c' + name,
          remove: function() {
            if(this === t ) {
              cases[name].removeListener(method); //if(!this.css === this._from.base.css) 
              this._cases[name].method = null
            }
          }
        });
        // } else {
        // console.log(name, 'already got listeners for case',name);
      }
      if (cases[name].val) {
        _css(t, name, invert);
        t.set(val, true);
      }
    }
  } else {
    _css(t, name, invert);
    t.set(val); //maybe copy args?
  }
  return true;
});
},{"../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../element/set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var object = require('../../object'),
  util = require('../../util'),
  element = require('../element'), //element /w extend
  value = require('../../value'),
  flags = require('../../value/flags');

/**
 * cases
 * cases are used to set one or more values when a specific case is true
 * there are 2 types of cases , static and dynamic ,
 * static cases are set at initialization of the application , usefull for things such as device type (phone, desktop, tv)
 * dynamic cases can be changed dynamicly and Objects or Bases that use the case will be changed dynamicly as well
 */

util.define(exports, 'methods', {});
//multiple, recursive and original have to become extensions on V.Object.convert so it's possible to use the same for data and events

var _isObj = util.isObj,
  /*
    _recur
    special merge that adds __remove__ if a field has to be removed
  */
  _recur = function(original, merge, fieldExists) {

    // console.log(original, merge, fieldExists)

    var keys, i, key, originalChild, mergeChild;
    if (fieldExists) {
      keys = {};
      for (key in original) {
        keys[key] = true; //keys can be undefined -- code can become shorter
      }
    }
    for (i in merge) {
      if (!fieldExists || keys[i]) {
        originalChild = original[i];
        mergeChild = merge[i];
        if (originalChild instanceof Object) {
          if (originalChild.__remove__ && (mergeChild && !mergeChild.__remove__)) {
            delete originalChild.__remove__;
          }
          if (!(mergeChild instanceof Object)) {
            merge[i] = {
              val: mergeChild
            };
          }
          _recur(originalChild, mergeChild, fieldExists);
        } else {
          original[i] = mergeChild;
          originalChild = 'burn';
        }
      }
    }
  },
  /*
          _multiple
          merge multiple orginals into a new orginal object also resolve nested cases
      */
  _multiple = function(t, nested, cases, currentObj, currentVal, base, name, path, orig) {

    if (!path) {
      orig = t;
      path = [];
    }
    var j, _case, cvChild;

    if((currentVal instanceof object) && !base) {

      // currentObj.val = t._val
      // console.error('VOBJ', currentObj)


    } else if (currentVal instanceof Object) {
      for (j in currentVal) {
        cvChild = currentVal[j];
        if (exports[j]) {
          _case = exports[j];
          if (_case instanceof object) {
            if (!base || !element.set.lookup.call(orig, path[path.length - 1])) { //element is required in cases.base, make this part extendable
              nested[j] = true;
            }
          }
          if (!_isObj(cvChild)) {
            currentObj.val = t && (t._val !== void 0 ? t._val : void 0);
          } else {
            path.push(j);
            //should be possible to use nested for current nested case;
            _multiple(t, nested, cases, currentObj, cvChild, base, name, path, orig);
          }
          currentObj[j] = null;
        } else {
          if (_isObj(cvChild)) {
            if (!currentObj[j]) {
              currentObj[j] = (t && t[j] && t[j].convert && t[j].convert(cvChild)) || (cvChild instanceof Array ? [] : {});
            }
            path.push(j);
            _multiple(t && t[j], nested, cases, currentObj[j], cvChild, base, name, path, orig);
            if (base && (!t || !t[j])) {
              currentObj[j].__remove__ = true;
            }
          } else {
            if (t && currentObj && !currentObj[j]) {
              if (flags[j]) {
                delete currentObj[j];
                currentObj.val = t._val !== void 0 ? t._val : void 0;
              } else {
                currentObj[j] = j === 'val' 
                  ? (t._val !== void 0 ? t._val : void 0) 
                  : (t[j]!==void 0 && t[j].convert && t[j].convert())
              }
            }
          }
        }
      }
    }
  };

/*
      original
      create a orginal store for a new case
    */
exports.methods.original = function(t, isObj, val, cases, base, name) {



  var obj = isObj ? t.convert(val) : t._val,
    i, cflag, nested = {};

  _multiple(t, nested, cases, obj, val, base, name);

  // for(var i in nested) {
  //   console.error('NESTED:::',i);
  // }
  // console.log(base ? 'BASE:': 'PROPERTY:' , name,'ORIGINAL GENERATION','\nval:',val,'\nobj:',obj,'\nnested:',nested,'\ncases:',cases);

  for (i in cases) {
    if (!nested[i]) {
      cflag = cases[i].orig;
      if (!isObj) {
        if (_isObj(cflag)) {
          if (cflag.val) {
            obj = cflag.val;
          }
        } else {
          obj = cflag;
        }
      } else {
        if (_isObj(cflag)) {
          if (!cases[i].nested[name]) {
            _recur(obj, cflag, name);
          }
        } else if (obj.val) {
          obj.val = cflag;
        }
      }
    }
  }



  return [obj, nested];
};
/*
  merge
  merge dynamic cases (overwrite /w cases that are true and further in the order of cases)
*/
exports.methods.merge = function(isObj, name, val, cases) {
  var original = util.clone(cases[name].orig),
    sVal = val,
    overwrite,
    i,
    merge,
    originalChild;
  for (i in cases) {
    if (i !== name && !cases[name].nested[i]) {
      if (exports[i].val) {
        merge = cases[i].val;
        if (_isObj(original) || _isObj(merge)) {
          if (!_isObj(original)) {
            original = {
              val: original
            };
          }
          if (!_isObj(merge)) {
            merge = {
              val: merge
            };
          }
          _recur(original, merge, true);
          for (i in exports) {
            originalChild = original[i];
            if (originalChild !== null && originalChild !== void 0) {
              delete original[i]; //delete is pretty slow
            }
          }
          if (overwrite) {
            if (isObj) {
              if (sVal === val) {
                sVal = util.clone(sVal);
              }
              merge = util.clone(merge);
              for (i in exports) {
                if (merge[i] !== null && merge[i] !== void 0) {
                  // console.error('REMOVE FIX', i);
                  delete merge[i]; //delete is pretty slow
                }
              }
              _recur(sVal, merge, true);
            } else {
              if (merge.val) {
                sVal = merge.val;
              }
            }
          }
        } else {
          original = merge;
        }
      }
    } else {
      overwrite = true;
    }
  }
  return [sVal, original];
};
/*
  reader
  abstraction for use in cases.object and cases.base
*/
exports.methods.reader = function(fn, dynamic, _static) {
  return function reader(name, val) {
    var invert = (name[0] === '!'),
      vCase = invert ? exports[(name.slice(1))] : exports[name],
      ret;
    if (vCase) {
      if (vCase instanceof object) {
        if (invert && !exports[name]) {
          exports[name] = new value({
            val: function() {
              return !vCase.val;
            },
            listen: vCase
          });
        }
        ret = fn ? fn.call(this, name, val, true, invert) : dynamic;
      } else {
        ret = invert ? !!fn : fn ? fn.call(this, name, val) : _static
      }
    } else if (invert) {
      ret = fn ? fn.call(this, name, val, false, invert) : _static;
    }
    if (vCase === false && fn) {
      ret = true;
    }
    return ret;
  };
};

require('./object');
require('./base');
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","./base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/base.js","./object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/object.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = require('../../value/flags'),
  Cases = require('./'),
  object = require('../../object'),
  util = require('../../util'),
  methods = Cases.methods,
  dynamic = {
    set: function(val, stamp, reset, name) {

      if(!this._flag) this._flag = {}

      var t = this,
          //selection for t._flag easy maken
          
          
        flags = t._flag.case || (t._flag.case = [
          'case',
          t._val,
          false, {},
          dynamic
        ]),
        cases = flags[3],
        isObj = util.isObj(val),
        setVal = (isObj && !val.val) ? false : true;
      if (val === null) {
        if (cases[name]) {
          Cases[name].removeListener(cases[name].method);
        }
        delete cases[name];
      } else {
        flags[5] = true;
        if (!cases[name]) {
          var x = methods.original(t, isObj, val, cases, false, name);
          cases[name] = {
            val: val,
            orig: x[0],
            nested: x[1],
            method: function() {
              var set = methods.merge(isObj, name, val, cases),
              sVal = set[0],
              original = set[1];
              // console.log(name)
              // if(name === '$isActive' )console.error('boeloe boeloe boeloe!!!',sVal,original)

              flags[5] = true; //the closures here are not really nessecary better to avoid
              if (Cases[name].val) {

                if(!sVal) console.warn(name,'wrong in cases!', sVal, Cases, flags)
                if (setVal && sVal) {
                  // if(name === '$isActive' )console.log('yee its true')
                  flags[1] = sVal.val || sVal;
                }
                t.val = sVal;
              } else {
                                  // if(name === '$isActive' )console.log('no way gozee')

                if (setVal) flags[1] = original && original.val || original

                if(name === '$isActive' )console.log('no way gozee 2',original, t)

                t.val = original;
              }
              flags[5] = null;
            }
          };
          Cases[name].addListener(flags[3][name].method);
        }
        if (Cases[name].val) {
          if (setVal) {
            flags[1] = val.val || val;
          }
          object.set.call(t, val, stamp, false, true);
          //not always
          t._ignorefornow = true

        }
        flags[5] = null;
      }
    },
    // reset:function() {
      // console.error('reset')
    // },
    //add reset later
    remove: function(flags, name) {
      // console.log(flags, name)
      var cnt = 0
      for (var i in flags[3]) {
        // if(flags[3])
        cnt++
        if(!this._ignorefornow && !name || i===name) {
          cnt --
          Cases[i].removeListener(flags[3][i].method);
        } else {
          delete this._ignorefornow
        }
      }
      if(cnt) {
        // console.log('CASE OBJECT REMOVAL --- IT IS NOT EMPY')
        return true
      }
    },
    stack: 'case'
  },
  _static = {
    set: function(val, stamp, reset, name) {
      if (val !== null) {
        object.set.call(this, val, stamp, false, true);
      }
    }
  };

flags.dynamic.cases = methods.reader(false, dynamic, _static);
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

/*
  gets and caches values for css classes, also possible to change styles of classes
  return an array of multiple css objects corresponding to the class name
  when you pass field it searches the field trough all the classes selected, always takes first argument
  maybe have to make this for things such as div selectors / nested stuff --- will be cpu intensive!;
*/
var selector = 'cssRules',
  parseclass = function(slctr) {
    slctr = '.' + slctr.replace(/\./g, ' .').toLowerCase();
    for (var robj, select = document.styleSheets, length = select.length, i = 0, selectItem; i < length; i++) {
      selectItem = select[i][selector] || select[i][(selector = 'rules')]; //location of this polyfill can be improved
      if(selectItem) {
        for (var j = 0, l = selectItem.length, item; selectItem, j < l; item = selectItem[j++], item.selectorText === slctr && (robj = item.style));
      }
    }
    return robj;
  },
  c = function(cssClass, cache) {
    var t = exports;
    cache.push(t[cssClass] || (t[cssClass] = parseclass(cssClass)) || {});
    return cssClass;
  };

module.exports = function(slctr, field) {
  if (slctr) {
    var cache = this[slctr];
    if (!cache) {
      cache = [];
      for (var selectarray = slctr.split(' '), i = 0, l = selectarray.length, cssClass; i < l; i++) {
        if ((cssClass = c(selectarray[i], cache).split('.')) instanceof Array) {
          c(cssClass[cssClass.length - 1], cache);
        }
      }
      this[slctr] = cache;
    }
    if (field) {
      if(!(cache instanceof Array))
        return
      for (var ret, i = cache.length - 1; !ret && i >= 0; ret = cache[i--][field]);
      cache = ret;  
    }
    return cache;
  }
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../../base')
  , valueBase = require('../../value/base')
  , vigour = require('../../')
  , util = require('../../util')
  , elementBase = new base()

elementBase.defaultType = valueBase.type

module.exports = exports = vigour.Element = elementBase.Class
exports.base = elementBase

var _doc = typeof document !== 'undefined' ? document : 'no document', //reference to document is faster than using window.document;
  /**
   * Removes children from parent node
   * @method _removeChildren
   */
  _removeChildren = function() {
    for (var c = this._node.childNodes, i = 0, l = c.length; i < l; i++) {
      if (c[i].base) {
        // console.log
        c[i].base.remove(false, false, true);
      }
    }
  };

/**
 * node
 * adds and clones html nodes;
 * @attribute
 */
exports.base.extend({
    name: 'node',
    type: false ,
    /**
     * Defines what happens when node is set
     * @method set
     * @param  {*} val Defines the value of this._node
     */
    set: function(val) {
      //changing node bugs /w conversions
      //iframe selectors dont evaluate to a string
      if (val instanceof Object || !val.length) {
        this._node = val;
      } else {
        this._node = _doc.createElement(val);
      }
      this._node.base = this;
    },
    /**
     * Defines what happens when you get node
     * @method get
     */
    get: function() {
      if (!this._node) {
        this.node = _doc.createElement('div');
      }
      return this._node;
    },
    /**
     * Defines what happens when you create a new node
     * @method new
     * @param  {Object} from    Target
     * @param  {[type]} newnode [description]
     */
    "new": function(from, newnode) {
      if (!newnode) {
        var node = from._node;
        if (node) {
          this._node = node.cloneNode(true); //especialy good to do for memory (also saves 20% on cpu)
          this._node.base = this;
        }
      } else {
        this._node = newnode;
      }
      if (from._node && from._node.hasChildNodes()) {
        var i, c = this._node.childNodes,
          cf = from._node.childNodes,
          l = c.length,
          ci, cfb;
        for (i = 0; i < l; i++) {
          cfb = cf[i].base;
          if (cfb) {
            c[i].base = new cfb.Class(false, false, c[i]);
            //maybe call children new stuff with a custom setting as well?
            if (cfb._name) {
              c[i].base._name = cfb._name;
              this[cfb._name] = c[i].base;
            }
            c[i].base.setting('parent', [this]);
          }
        }
      }
    },
    /**
     * Defines what happens when you remove a node
     * @method remove
     * @param  {*}  [param] If param doesn't remove node from parent
     */
    remove: function(param) {
      _removeChildren.call(this);
      if(this._node) this._node.base = null //little slow optimize later
      if (!param) {
        var _p = this._node.parentNode;
        if (_p) {
          _p.removeChild(this._node);
          if (this._name && _p.base) {
            _p.base[this._name] = null;
          }
        }
      }
    }
  },
  /**
   * Set css class of a div
   * Use addClass or removeClass to add/remove a class
   * @attribute css
   * @param  {Object} val [description]
   * warning: the add operator in css is currently used by .name,
   * and will be replaced when you try to build a string
   * using {val: .... add: ....}
   */
  {
    // __$css: function(val) {
      // this.css
    // }
    css: function(val) {
      var _val = val.val || '';
      val._skip = true; //_skip is an ugly name
      if(val.addClass){
        if (!~_val.indexOf(val.addClass.val)) {
          val._val = ((_val.length > 0 ? _val + ' ' : '') + val.addClass.val);
          if(val.add) val._val = val._val.replace(val.add.val,'')
          val._lval = false;
          val.__lval = false;
          val.___lval = false;
          _val = val.val;
        }
        val.addClass.remove();
      }

      if(val.removeClass){
        if (_val && val._val) {
          val._val = val._val.replace(new RegExp(' ?' + val.removeClass.val), '');
          val._lval = false;
          val.__lval = false;
          val.___lval = false;
          _val = val.val;
        }
        val.removeClass.remove();
      }

      if( _val ) {
        this.node.className = _val.replace('$','')
      } else {
        this.node.className = ''
      }
    }
  },
  /**
   * Makes it possible to reference a child by name
   * Setting on a class does not update names of instances
   * Element[NAME]
   * @attribute name
   */
  {
    name: 'name',
    type: false,
    set: function(val) {
      var _p = this.parent;
      if (this._name) {
        if (_p) {
          _p[this._name] = null;
        }
      }
      this._name = val;
      if (!this._node || val !== this.node.nodeName.toLowerCase()) {
        //name does not inherit, beware!
        // console.log('WHATS THIS?',val);
        // this.css = {addClass:val};
        // this.className = this._name;
        if(!this.css || this.css._val!==val)this.css = { add: ' ' + val }
        //special name field?
      }
      if (_p) {
        _p[val] = this;
      }
    },
    get: function() {
      return this._name;
    }
  },
  /**
   * Returns parent base element
   * @attribute parent
   */
  {
    name: 'parent',
    type: false,
    get: function() {
      if (this._node) {
        var _p = this._node.parentNode || this._p;
        return _p ? _p.base || _p._p : false;
      }
    }
  },
  /**
   * Returns childNodes /w base classes array slow, cache if possible
   * @attribute children
   */
  {
    name: 'children',
    type: false,
    get: function() {
      if(!this._node) return []
      var c = this._node.childNodes,
        l = c.length,
        _c = new Array(l),
        i;
      for (i = 0; i < l; i++) {
        _c[i] = c[i].base || c[i];
      }
      return _c;
    }
  });

var recurRender = function(parent) {

  if (!this.lastindex) this.setting('render', [parent]) //execute render settings

  if (this.renders) {

    // console.error('RENDER ---', this.name, this.renders)

    for (var p
      , c = this.node.childNodes
      , cl
      , arr = this.renders
      , obj
      , i = this.lastindex || 0, l = arr.length; i < l; i++) {
      obj = arr[i]

     if(obj) {
        p = util.checkArray(c, obj, 'base')
        if (p !== false) {
          recurRender.call(obj, this)
        } else if(obj._from) {

          // console.log('CLASS!',obj, obj.name && this[obj.name] && this[obj.name] === cl)

          cl = obj.Class

          if(obj.name && this[obj.name] && this[obj.name] === cl) {
            recurRender.call(this[obj.name], this)
          } else {
           for (var j in c) {
             if (c[j].base && c[j].base instanceof cl) {
               recurRender.call(c[j].base, this)
               break;
             }
            }
          }
        }
      }
      // arr.splice(i,1)
    }
  }

  this.lastindex = l
},

setRender = function() {
  var p, pp;
  if (this.parent) {
    p = this.parent;
    if (p.renders) {
      p.renders.push(this);
    } else {
      p.renders = [this];
      pp = p.parent;
      if (pp && !(pp._settings && pp._settings.render !== true)) {
        setRender.call(p);
      }
    }
  }
},

valRender = function(val) {
  var _settings = (val.__ && val.__._settings || val._._settings)
  if (val._.renders || val.__ && val.__.renders || _settings.render !== true) {
    if (!this.renders) this.renders = []
    if (!(this.__ && this.__.renders)) this.renders = util.clone(this.renders)
    // console.log(this.renders===this.__.renders, this.__.renders, this._.renders)

    // console.log(util.checkArray(this.renders,val._from))
    // console.log('XXXXXX',val)
    // if(util.checkArray(this.renders,val._from._from,'_from._from')===false&&util.checkArray(this.renders,val._from,'_from')===false) {
      this.renders.push(val)
    // }
    // console.log('renders push --- creates leaks!')
  }
}

//define vanuit base (korter!)
util.define(exports,
   'append', function(arr) {

    // alert('APPEND')
    // console.log('APPEND'.inverse,arr)

      var args = arguments

      if(arguments.length>1) {
        arr = util.arg(arguments)
      } //else if(arr )

      var insertbefore
      if(!arr.length && !(arr instanceof exports) && arr.val) {
        insertbefore = arr.before
        arr = arr.val
      }
      var Class = arr[0]
      , i = 0
      , l = arr.length
      if(!arr.length) {
        this.add(arr, insertbefore)
      } else if(typeof Class === 'function') {
        for(var i=1, l = arr.length;i<l;i++) {
          this.add(new Class(arr[i]), insertbefore)
        }
      } else {
        for(;i<l;i++) {
          this.add(arr[i], insertbefore)
        }
      }
  },
  'checkRender', function(val, notRendered) {
    if (val) valRender.call(this, val)
    if (!notRendered) {
      var _renders = (this.__ && this.__.renders || this._.renders)
      if ( ( (_renders  || ((this.__ && this.__._settings)  || this._._settings).render !== true)
          && (!this.lastindex || (_renders && this.lastindex < _renders.length))
        ) && this.rendered) {
        recurRender.call(this, this)
      } else {
        if(this.parent) valRender.call(this.parent, this)
      }
    }
  },
  'checkParent', util.checkParentFactory('parent'),
  'get',function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },
  'find', function(get, match, level) {
    if(level === void 0) level = true
    var children = this.node.childNodes
      , i = 0
      , found
      , child
      , len = children.length
      , passOn = level===true ? true : level-1
    for(;i<len;i++) {
      child = children[i].base
      if(child) {
        if(child.get(get, true)==match) {
          return child
        } else if(level) {
          found = child.find(get, match, passOn)
          if(found) return found
        }
      }
    }
  },
  'setRender', function(name, val) {
    this.setSetting({
      name: name,
      render: val
    });
    setRender.call(this);
    this.eachInstance(function() { //look for current caller instance perhaps?
      setRender.call(this)
    }, name);
  },
  'renders', false,
  /**
   * Add element as child
   * @method
   * @param  {Object}  val  Object to be added
   * @return {Object}       Returns the V.element
   */
  'add', function(val, insertbefore) {
    
    if(insertbefore) {
      if(typeof insertbefore === 'string') insertbefore = this[insertbefore]
      if(insertbefore) {
        this.node.insertBefore(val.node, insertbefore.node || insertbefore)
      } else {
        console.error('cannot find insertbefore')
      }
    } else {
              // console.error(val)

      this.node.appendChild(val.node)
    }

    val.setting('parent', [this]) //execute parent settings
    if (val.name) this[val.name] = val
    //--------------------
    //needs cleaning costs 3% now...
    this.checkRender(val)
    //--------------------
    return this
  },
  /**
   * Removes all children
   * @method empty
   * @param  {Boolean} instances True will remove all instances of children removed
   */
  'empty',
  function(instances) {
    var c = this.node.childNodes
      , i
    this.node.innerHtml = ''
    for (i = c.length - 1; i >= 0; i--) {
      if (c[i].base) c[i].base.remove(instances)
    }
  });

exports.base.addSetting('parent')
exports.base.addSetting('render')
require('./set')
},{"../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../value/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js","./set":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/display.js":[function(require,module,exports){
var collection = require('./util')

exports.prepare = function(el) {
  if(!el.display) el.display = 'block'
}

exports.newElement = function(data, element, t) {
  var c = collection.children(t)
  for(var i in c) {
    if(c[i]._d && c[i]._d===data) {
      c[i].display = element.display.val
      return true
    }
  }
}
 
exports.rem = function (el, t, hasFilter, noResolve) {
 el.display = 'none'
 return true
}

exports.fragment = function(a,b,exclude,i) {
  //since it never removes excludes should never be applied
  //exclude is normally used to not add things again if they already exist
  if(exclude) exclude[i]=null
}

},{"./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/index.js":[function(require,module,exports){

var collection = require('./util')
  , util = require('../../../../util')

/**
 * collection
 * links arrays or object to elements
 * use filter if you want to convert
 * @attribute
 */

exports.extend = util.extend(
  require('../data'),
  function(base){

    base.extend({
      name:'collection',
      // render:function() {
      //   this.update('collection') 
      // },
      remove:function() {
        if(this._colElem) this._colElem.remove()
      },
      set: function(val, stamp, from, remove, change, added) {

        // console.error('xxxx!@#!!@#!#', this.data && this.data.toString())

        val._skip = true

        var hasFilter = collection.filter(val, this)
          , data = this.filter || val.val
          , options = this._colOptions || val.options 
              && (this._colOptions = val.options.convert())
          , orig =  val.element
          , el = this._colElem 
              || (orig && orig._val) && (this._colElem = new (orig._val.Class || orig._val)())
          , firstRun = !this._colInit
          , slStamp
          , elVal
          , colElem = this._colElem

          // console.log('!!!OPTIONS!', options)

        //dirty block! clean it FAST

        // || !this.rendered 

        if(!(data && el)) return //||!this.rendered
        
        slStamp = orig._slStamp
        elVal = orig._val

        if(slStamp) {
          orig._slStamp = stamp
        } else if(colElem && orig._slStamp !== stamp) {
          if(!(elVal.Class && (colElem instanceof elVal.Class)) 
            && !(!elVal.Class && (colElem instanceof elVal))) {
            el = this._colElem = new (elVal.Class || elVal)()
            orig._slStamp = stamp
          }
        }



        // console.log('ook leuk ff update', val, stamp, from, remove, change, added)
          // console.log('pass!')
          
        if(firstRun) {

          options && options.prepare && options.prepare(el)

          this._colInit = true
          this.node.appendChild(collection.fragment( data, el, this, false, options
            , hasFilter ))

        } else {

          if(from && from._parent === data.from) {
            if(remove) {
              var r = util.checkArray(collection.children(this),from,'_d',true)
              if(r) {
                if(!(options && options.rem && options.rem(r, this, hasFilter))) {
                  r.remove()
                }
              }
            } else if(util.checkArray(collection.children(this),from,'_d')===false) {

              collection.element( from, el, this, true, this.node, options, hasFilter, true )
            } else if(hasFilter && options && options.indexChange) {

                options.indexChange(
                  util.checkArray(collection.children(this),from,'_d',true)
                  , this, hasFilter )
            }
            
          } else {
            
            // console.log('122XXXXX', from, hasFilter, collection.filter(val, this)) //try to fix order by name better

            if(!from) {

              if(remove) {
                collection.clear(this, options)
              } else {

                var c = collection.children(this)
                  , exclude = {}
                  , name
                  , fField
                  , keys
                  , child

                // console.log('XXXXX',hasFilter) //try to fix order by name better
                if(hasFilter===true) {
                  keys = data.keys
                }

                for(var j in c) {
                  child = c[j]
                  name = c[j]._d._name

                  // console.log(c[j], hasFilter, keys, util.checkArray(data,child._d) === false)

                  if(hasFilter && !keys ? util.checkArray(data,child._d) === false : !data[name] || data[name]!==child._d ) {

                    // console.log('CHECK!---',j)

                    if(!(options && options.rem && options.rem(child, this, hasFilter, hasFilter))) {
                      child.remove()
                    }
                  } else {
                    //this is more efficient
                    // if(data[name]!==c[j]._d) c[j].data = data[name] 
                    exclude[name]=true
                    if(hasFilter) {
                      if(options && options.indexChange) {
                        if(child._d._indexCache[hasFilter][0]!==child.i) {
                          options.indexChange(child, this, hasFilter, true)
                        }
                      } else if(hasFilter===true) {
                        if(j!=util.checkArray(keys,name,true)) {
                          delete exclude[name]
                          if(!(options && options.rem && options.rem(c[j], this, hasFilter, hasFilter))) {
                            child.remove()
                          }
                        } 
                      }
                    }
                  }
                }

                this.node.appendChild(
                  collection.fragment(data, el, this, exclude, options, hasFilter)
                )
              }

            }
          }
        }
      }
    })
})
},{"../../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/data.js","./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/util.js":[function(require,module,exports){
var element = require('../')
  , Data = require('../../../../data').inject(require('../../../../data/selection'))
  , util = require('../../../../util')

var r = function() {
  return String(~~(Math.random()*9))+''
}

exports.element = function (data, element, t, update, node, options, hasFilter, resolve) {
  var elem
  if(options && options.newElement) {
    elem = options.newElement.apply(this,arguments)
    if(elem===true) return
  }
  elem = elem || new element.Class()
  
  elem._col = true

//   console.log( '---->', data )

  if (data !== void 0) elem._dSet(data)
  if (node) node.appendChild(elem.node)
  elem.setting('parent', [t])
  ;options&&options.element&&options.element(elem, t, hasFilter, resolve)
  if (update && data !== void 0) elem.updateData()
  t.checkRender(elem, true)
  return elem
}

exports.fragment = function (data, element, t, exclude, options, hasFilter) {
  var frag = document.createDocumentFragment()
    , item = function(i) {
        //if you use the passed i it is a different value for selections
        if(this._name) i = this._name
        if(!(options&&options.fragment&&options.fragment(t,this,exclude,i))
          && (!exclude || !exclude[i]) ) {
          var elem = exports.element( this || null, element, t, false, frag, options
              , hasFilter)
          if(elem) frag.appendChild( elem.node )
          elem.updateData()
        }
      }
  frag._p = t

  if(data.each) {
    data.each(item)
  } else {
    //normal data
    for(var i in data) {
      item.call( data[i] ,i )
    }
  }

  // element.updateData(true)
  return frag
}

exports.children = function (t, options) {
  if(!t) return
  var ch = []
  for(var i in t.node.childNodes) {
    var child = t.node.childNodes[i].base
    if(child && child._col) {
      ch.push(child)
    }
  }
  ;options&&options.children&&options.children(ch)
  return ch
}

exports.clear = function (t, options) {
  t.colInit = null
  var c = exports.children(t)
  for(var i in c) { c[i].remove() }
  ;options&&options.clear&&options.clear(t)
}

exports.filter = function (val,t) {


  var data = val.val


  // console.log('DO I HAVE FULTER!>?',data,  val, t)


  if(val.filter && val.filter.val===true) {
    // console.log('sort by name') moet beter
        // console.log('got it!DATAx!')

    return true
    //different vibes
  }

  if (data && val.filter && !t.filter) {

    // console.log('MAKE NEW STYUFFF')

    var a = val.filter.raw
    //dit is kapot
    data = t.filter = new Data(data, a)

    // console.log('FILTERSSSS!', a, t)
    // debugger

    a._col = true
    
    data.addListener(function (val, stamp, from, remove) {
      t.collection._update(val, stamp, from, remove)
    })
    
    t.setSetting({
      // name: 'collecitonfilter',
      remove: function () {
        t.filter.remove()
        t.filter = null
      }
    })

    // console.log('DATAx!')
    return data._uid
    // return t.filter._uid//data is filter
  } else if(data && data._filter) {
        // console.log('DxxxATAx!')

    return data._uid
  } 
  else if(t.filter) {

    return t.filter._uid
  }

    // console.log('NO DATAX! FILTER', t)

}

// exports.indexChange = function(el, t, hasFilter, noResolve) {
// var oldIndex = el._d._indexCache[hasFilter][1]
//     , newIndex = el._d._indexCache[hasFilter][0]
//     , ch = !noResolve && collection.children(t,exports)
//     , l


//   exports.xy(el)

//   if(noResolve) return

//   l = ch.length
  
  
//   var clone = el.node.cloneNode(true)
//   t.node.removeChild(el)
//   el._node = clone


   
//   // t.h = t.node.scrollHeight
// }
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js","../../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../../data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js","../../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var data = require('../../../data/base')
  , util = require('../../../util')
  , flags = require('../../../value/flags')

/**
  * extends updateData to take childNodes into account
  * may need to add extra argument for go deep
  * @method
*/
exports.extend = util.extend([ data, {
  updateData: function ( instances, data, fmodel ) {

    // if( instances ) console.error('????----------->>>>>')

    if (this._d) {
      this._subscribed = false
      data = this._d
    }

    var ffmodel = false
    var parsed = false
    if (!fmodel && !this.model && !this._fmodel) ffmodel = true
    //fmodel is first model
    for (var children = this.node.childNodes
      , i = children.length - 1
      , base; i >= 0; i--) {

      base = children[i].base
      
      // if(base && base.model && base.model.field && base.modelParsed !== base.model.field.val && base.instances && instances) {
      //   // console.error('1', base && base.name, base.instances)
      //       if(!data && instances) {
      //         if(!data) {
      //           data = base.checkParent('_d',true) || this.checkParent('_d',true)
      //           // console.log('hey hey hey', data, this._d, base._d, base)
      //         }
      //         console.error('lezzgo instances', data)
      //         // base._d = data = data.get(this.model.field.val) //util.path(data,this.model.field.val.split('.'))
      //         for(var i in base.instances) {
      //           if(!base.instances[i].model.parsed) {
      //             // console.error('?',base.instances[i].model.parsed)
      //             base.instances[i].updateData(false, data)
      //           }
      //         }
      //         // base.modelParsed = 
      //         // base.model = {}
      //         // base.model.parsed = base.model.field.val 
      //         // return
      //       }
      // }

      // if(base && base.model && base.model.field && !base._d) {
        // base._dSet(data, true)
      // }

      if (base
      && (!(base.model && base.model.inherit && base.model.inherit.val===false))
      && (base._d === void 0 || base._dfrom || (base.model && base.model.field) )) {
        var tdata = data

        if (base.model && (data || base.model && base.model.field)) {
          if (ffmodel) base._fmodel = true

          //hier ook ff model parsen!
          if(base.model && base.model.field) {
            tdata = data.get(base.model.field.val)
            base.modelParsed = base.model.field.val
            // console.error(tdata)
          }
            // console.error(tdata._cachedPath)

          base._dSet(tdata, true)
        }

        base.updateData(false, tdata, base._fmodel || fmodel)
      }
    }
  }
}])
},{"../../../data/base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/base.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../value/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    here some basic html properties are added to V.Element.Nessecary
    for values that you want to be able to bind to V.Objects
    Uses base.extend -- see core.base for more information
  */

var ua = require('../../ua')
var css = require('../../css')
var Value = require('../../../value')
var util = require('../../../util')
var hash = require('../../../util/hash')
var raf = require('../../animation/raf')
var _load = require('../').images = {}
var _transform = ua.prefix + 'Transform'
var _cssTransform = ua.prefix + '-transform'
var postpone = require('vigour-js/browser/events/util').postpone
var body = document.body.style
    //think about doc ready event or fallback if no body
var _translate = body.perspectiveProperty != void 0
                 || body.WebkitPerspective != void 0
                    ? ['translate3d(', ',0px)']
                    : ['translate(', ')']
var _coordinate = function(style) {
      var margin = 'margin' + (style[0].toUpperCase() + style.slice(1));
      return function(val) {
        if(val.clean) {
          _cleanCoordinate.call(this,style,margin)
          val.clean = null
        }
        if (val.translate) {
          this.translate(val)
        } else {
          this.node.style[this.relative ? margin : style] = val.val + 'px'
        }
      }
    }
var _clearTransform = new RegExp(_cssTransform+'(.*?);')
var _clear =
    { x: /(margin-left(.*?);)|(left(.*?);)/g
    , y: /(margin-top(.*?);)|(top(.*?);)/g
    }
var _cleanCoordinate = function( check ) {
      var t = this._t
      , keep = false
      , val = this[check]
      , cssText = this.node.style.cssText.replace( _clear[check], '' )

    if( val && val.translate && val.translate.val===false) val.translate = null

    if(this.node.style[_transform] && !val.translate) {
      if(t) {
        if(!this[check].translate) {
          for(var i = 2 ; i < 6 ; i++) {
            if(t[i])keep=true
          }
        } else {
          keep=true
        }
      }
      if(!keep) cssText = cssText.replace(_clearTransform,'')
    }
    this.node.style.cssText = cssText
  }

var setTimers, removeTimers, _setTimeout

exports.extend = util.extend(function(base) {
  util.define(base.Class,
    'cleanCoordinates', function(coord) {
       if(this._node) {
        if(!coord) {
          _cleanCoordinate.call(this,'x')
          _cleanCoordinate.call(this,'y')
        } else {
          _cleanCoordinate.call(this,coord)
        }
      }
    },
    'translate', function(val) {
    var _x
      , _y
      , _val =  val.val
      , _scale
      , _rotate
      , _rotateY
      , _rotateX
      , _str = ''
      , _name = val && val._prop.name
      , _t = this._t = this._t || []
      , nope = false

    //cirtical performance point hence use of | 0
    if (_name === 'x') {
      _x = _val | 0
      if (_x === _t[0]) nope = true
    } else if (_name === 'y') {
      _y = _val | 0
      if (_y === _t[1]) nope = true
    } else if (_name === 'rotate') {
      _rotate = _val
      if (_rotate === _t[2]) nope = true
    } else if (_name === 'scale') {
      _scale = _val
      if (_scale === _t[3]) nope = true
    } else if (_name === 'rotateY') {
      _rotateY = _val
      if (_rotateY === _t[4]) nope = true
    } else if (_name === 'rotateX') {
      _rotateX = _val
      if (_rotateX === _t[4]) nope = true
    }

    if (!nope) {
      _t[0] =  _x || (this.x.translate && this.x.val | 0) || 0
      _t[1] =  _y || (this.y.translate && this.y.val | 0) || 0
      _t[2] = _rotate || this.rotate.val
      _t[3] = _scale || this.scale.val
      _t[4] = _rotateY || this.rotateY.val
      _t[5] = _rotateX || this.rotateX.val
      if (_t[0] || _t[1]) {
        _str = _str
          .concat(
            _translate[0]
          + _t[0] + 'px,'
          + _t[1] + 'px'
          + _translate[1]
          )
      }
      if (_t[2]) { _str = _str.concat(' rotate(' + _t[2] + 'deg)') }
      if (_t[3]) { _str = _str.concat(' scale(' + _t[3] + ')') }
      if (_t[4]) { _str = _str.concat(' rotateY(' + _t[4] + 'deg)') }
      if (_t[5]) { _str = _str.concat(' rotateX(' + _t[5] + 'deg)') }
      this.node.style[_transform] = _str
    }
    return this
  }, 'update', function() {
    for (var i = 0, _args = util.arg(arguments), l = _args.length, p; i < l; i++ ) {
      if (_args[i] instanceof Array) {
        this.update.apply(this, _args[i]);
      } else {
        p = util.get(this, _args[i]);
        if (p) {
          p.update(this);
        }
      }
    }
    return this;
  });

  var done = postpone(function(val,self,sdir){
    if(self){
      if(val._listeners !== void 0) val.val = self.node[sdir]
      else self[sdir].__lval = void 0
    }
  },20)

  function createScroll(dir){
    var s = 'scroll'
      , sdir = s + dir //scrollLeft or scrollTop

    return {
      name:sdir,
      set:function(val) {
        var v = val.val
          , self = this
        if(v !== void 0) self.node[sdir] = v
        if(!self.__sT){
          self.__sT = true
          self.addEvent(s,function(){
            done(val,self,sdir)
          })
        }

      },
      get:function(val){
        if(val.__lval === void 0) val.val = this.node[sdir]
        return val
      },
      render:function() {
        var self = this
          , val = self[sdir].__lval
        if(val){
          raf(function(){
            self.node[sdir] = val
          })
        }
      }
    }

  }

  base.extend({
    name: 'relative',
    type: false,
    get: function() {
      var s = this.position !== false ? this.position.val : (this.position = {
        css: true,
        val: css(this.css.val, 'position')
      })
      return s !== 'absolute'
    }
  },
  {
    type: false,
    name: 'rendered',
    get: function() {
      var ret = this._rendered || (this.node === document.body),
        parent;
      if (!ret) {
        parent = this.node.parentNode;
        while (!ret && parent) {
          if (parent.base && parent._rendered) {
            ret = true;
          }
          if (parent == document.body) {
            ret = true;
          }
          parent = parent.parentNode;
        }
        if (ret) {
          this._rendered = true;
        }
      }
      return ret;
    }
  },
  createScroll('Left'),
  createScroll('Top'),
  {
    position: function(val) {
      // console.log('?????',val.css.val)
      // if (!val.css) { //check when ignoring this becomes a problem
        this.node.style.position = val.val;
      // }
    },
    // scrollTop:function(val) {
    //   console.error(val.val)
    //   this.node.scrollTop = val.val
    // },
    rotate: function(val) {
      this.translate(val);
    },
    rotateY: function(val) {
      this.translate(val);
    },
    rotateX: function(val) {
      this.translate(val);
    },
    scale: function(val) {
      this.translate(val);
    },
    src: function(val) {
      var v = val.val;
      if (v && v[v.length - 1] !== '/') {
        this.node.src = v;
      }
    },
    attr:function(val) {
      var t = this
      val.each(function(i) {
        t.node.setAttribute(i,this.val)
      })
    },
    backgroundPos: function(val) {
      this.node.style.backgroundPosition = val.val
    },
    backgroundBatch: function(val) {


    },
    background: function(val) { //optional maybe in a seperate module
      var v = val.val
        , t = this
        , style = this.node.style
        , url
        , hashed
        , parentBatch
        , batch

      if(val.gone && val.gone.val) {
        val._skip = true
        style.backgroundImage = ''
      } else if (v && v[v.length - 1] !== '/') {
        url = 'url(' + v + ')'
        if(style.backgroundImage===url) return

        //Value
        if (val.size) style.backgroundSize = val.size.val

        if (val.load) {

          hashed = hash(v)
          parentBatch = this.checkParent('backgroundBatch')
          if(parentBatch) batch = parentBatch.backgroundBatch

          if(!_load[hashed]) {
            this._loaded = null
            //also remove setting

            if(batch) {
              window.cancelAnimationFrame(batch._raf)
              if(!batch.batch) batch.batch = []
              batch.batch.push(hash)
            }

            _load[hashed]=new Value(false)
            var img = document.createElement('img')
            img.onload = function() {

             if(batch) {
               batch.batch.splice(util.checkArray(batch.batch,hashed),1)
               if(batch.batch.length===0) {
                batch.batch = null
                batch._raf = raf(function() {
                  if(parentBatch._node) batch._val.call(parentBatch)
                })
               }
             }

              _load[hashed].val = true
              img.onload = null
              img = null
              _load[hashed].remove(false,false,false,false,false,true)
              _load[hashed] = true
            }
            img.src = v
          }

          if(_load[hashed]!==true) {
             this._loaded = null

            _load[hashed].addListener([function() {
              if(val.load && val.load.val!==true) val.load._val.call(this, t);
            },val._base], true)
          } else {

            this._loaded = true

            if(batch) {
              if((!batch.batch) || batch.batch.length===0) {
                batch.batch = null
                window.cancelAnimationFrame(batch._raf)
                batch._raf = raf(function() {
                   if(parentBatch._node) batch._val.call(parentBatch)
                })
              }
            }

            if(val.load.val!==true) val.load._val.call(this, t);

          }
        }

        style.backgroundImage = url

      }
    },
    padding: function(val) {
      this.node.style.padding = val.val + 'px';
    },
    y: _coordinate('top'),
    x: _coordinate('left'),
    display: function(val) {
      this.node.style.display = val.val;
    },
    w: function(val) {
      // console.log('w');
      var v = val.val
      this.node.style.width = (v > -1 ? (v | 0)  + 'px' : v ) || '100%' 
    },
    h: function(val) {
      // var v = val.val | 0 typo or bug?
      var v = val.val
      this.node.style.height = (v > -1 ? (v | 0)  + 'px' : v ) || '100%'
    },
    opacity: function(val) {
      var v = val.val;
      if(v===false) this.node.style.opacity = null
      else this.node.style.opacity = v > -1 ? v : 1;
    },
    html: function(val) {
      var v = val.val || ''
      if( v.replace )
      {
        //add some injection prevention as option? (no script etc)
        v = v.replace(/\t/g, '    ')
             .replace(/\r\n|\n|\r/g, '<br/>')
             .replace(/  /g, '&nbsp; ')
             .replace(/  /g, ' &nbsp;') // second pass
                                        // handles odd number of spaces, where we
                                        // end up with "&nbsp;" + " " + " "
        this.node.innerHTML = v
      }

    },
    href: function(val) {
      this.node.href = val.val;
    },
    text: function(val) {

      // console.log('SETTING TEXT'.green.inverse. val.val, val)

      var node = this.node
        , nodes = node.childNodes
        , v = val.val || val.val === 0 ? val.val : ''

      if(v instanceof Object) v = ''

      if (/text/.test(node.type)) {
        node.value = v;
        return;
      }

      if (nodes) {
        for (var i = 0, l = nodes.length; i < l; i++) {
          if (nodes[i].nodeType === 3) {
            // console.log('BLABLA'.inverse,v)
            nodes[i].nodeValue = v;
            return;
          }
        }
      }
      node.appendChild(document.createTextNode(v));
    },
    $timeout: function( val ) {
      if(setTimers === void 0){
        setTimers = function() {
          var _this = this
          var timeout = this.$timeout
          if( timeout ) {
            if(_setTimeout === void 0){
              _setTimeout = function( _this, timeout, keys, i ) {
                var time = keys[ i ] - ( keys[ i - 1 ] || 0 )
                var fn = timeout[ keys[ i ] ]._val
                fn.id = setTimeout( function() {
                  fn.id = null
                  if( !fn.done || !_this.done ) {
                    fn.call( _this )
                    fn.done = true
                    _this.done = null
                  }
                  if( keys[ ++i ] ) _setTimeout( _this, timeout, keys, i )
                }, time )
              }

            }

            _setTimeout( _this, timeout, timeout.keys, 0 )
          }
        }
      }
      if( this.rendered ) {
        setTimers.call( this )
      } else {
        this.setSetting( {
          name: 'setTimers',
          render: setTimers
        } )
      }

      this.setSetting( {
        name: 'removeTimers',
        remove: removeTimers || (removeTimers = function() {
          console.error('--------REMOVE',this._node)
          var timers = this.$timeout
          if( timers ) {
            timers.each( function() {
              var fn = this._val
              console.error('---------removing',fn,fn.done)
              if( this.done ) this.done = null
              if( fn.id ) clearTimeout( fn.id )
              if( fn.done ) fn.done = null
            } )
          }
        })
      } )
    }
  });
});
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","../../css":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(function(base) {
  var proto = base.Class.prototype
    , add = proto.add

  util.define
  ( proto
  , 'add'
  ,  function(val) {
       if( !val.process )
       {
          add.apply( this, arguments )
       } else
       {
          val.__tempAdd = util.arg( arguments )
          val.__tempAdd.unshift(this)
       }
     }
  )

  base.extend({
    process: function(val) {
      console.log('xxxx___xxxx')
      if(this.__tempAdd && !this.parent) {
        add.apply(this.__tempAdd[0], this.__tempAdd.slice(1))
        this.__tempAdd = null
      }
    }
  })

})

//process wordt mischien meer een operator?
//soort field eigenlijk
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/scrollbar.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = require('../../events')
  , cases = require('../../cases')
  , ua = require('../../ua')
  , global = false
  , NONE = 'none'
  , _ios = ua.platform==='ios'
  , _android = ua.platform==='android'
  , VISIBLE = 'visible'
  , extend = require('../../../util').extend
  , doc = events.document
  , timer
  , fn

if(cases.$hasTouch){

  function blur (e){
    if(!document.activeElement){
      doc.removeEvent(false,'blur')
    }else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM'){
      document.activeElement.blur()
      doc.removeEvent(false,'blur')
    }
  }

  events.preventDown = 
  { val:
    { down:function(e,method) {
        if(document.activeElement) doc.addEvent('up',blur,'blur')
        else if(e.target.tagName!=='INPUT' && e.target.tagName!=='FORM' && !events._maybescroll) e.preventDefault()
      }
    }
  }

  events.scrollbar = 
  { val: 
    { down:function(e,method,val) {

        var scrollStart
          , t = this
          , scrollStr
          , xAxis = (val._val === 'x')
          , axis
          , otheraxis
          , move
          , d
          , bottomPrevent
          
        if(xAxis) {
          axis = 'x'
          otheraxis = 'y'
          scrollStr = 'scrollLeft'
          d = t.node.scrollWidth - t.node.offsetWidth
        }else{
          axis = 'y'
          otheraxis = 'x'
          scrollStr = 'scrollTop'
          d = t.node.scrollHeight - t.node.offsetHeight
        }

        scrollStart = t.node[scrollStr] //<======== less efficient but more predictable for compensation

        if(d > 0){
          events[axis] = true
          events._maybescroll = true
          if(!xAxis){
            if (!scrollStart){
              scrollStart = t.node[scrollStr] =  1
            }else if(scrollStart===d) {
              scrollStart = t.node[scrollStr] = d - 1
            }else if(scrollStart > d){
              bottomPrevent = true
            }
          }

          var y = e.y
            , x = e.x
            , moveid = scrollStr + axis
          
          doc.addEvent('move',function(e){
            var dx = Math.abs(x-e.x)
              , dY = y-e.y
              , dy = Math.abs(dY)

            if(xAxis){
              if(dy > dx){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
            }else{
              if(dx > dy){
                events[axis] = false
                if(!events[otheraxis]) e.preventDefault()
              }
              if(bottomPrevent && dY > 0){
                e.preventDefault()
              }
            }

            move = true
            blur(e)
            doc.removeEvent(false,moveid)
          },moveid)

          doc.addEvent('up',function(e) {
            var ms = events._maybescroll, msl, arr

            if(!move){
              var scrll = t.node[scrollStr]
              move = !(scrll === scrollStart) || scrll < 0 || ( scrll > d && !bottomPrevent )
            }

            if(!move && !events[otheraxis] && !events.click.block && ms && ms.length){
              msl = ms.length
              while(msl--) if(!e.prevent){
                arr = ms[msl]
                arr[0].call(arr[1],e)
              }
            }

            if(!events[otheraxis] || move) events._maybescroll = false

            events[axis] = false
            doc.removeEvent(false,scrollStr)

            window.requestAnimationFrame(function(){
              document.body.scrollTop = 0
            })
          },scrollStr)
        }
      }
    }
  }

  fn = function (val) {
      
    var style = this.node.style

    style.overflow = 'scroll'
    style.webkitOverflowScrolling = 'touch'
    style.msTouchAction = 'auto'
    style.touchAction = 'auto'

    if (val.val === 'x') {
      style.msTouchAction = 'pan-x'
      style.touchAction = 'pan-x'
      style.overflowY = 'hidden'
      style.overflowX = 'scroll'
    }else if (val.val === 'y') {
      style.msTouchAction = 'pan-y'
      style.touchAction = 'pan-y'
      style.overflowX = 'hidden'
      style.overflowY = 'scroll'
    }

    this.events = { scrollbar:val.val }
    if(!global) {
      global = true
      doc.events = { preventDown:true }
    }
  }

}else{

  fn = function (val) {
    console.error('nunu hey!')

    var style = this.node.style;
    style.overflow = 'auto';
    style.overflowY = val.val !== 'x' ? 'scroll' : 'hidden';
    style.overflowX = val.val !== 'y' ? 'scroll' : 'hidden';
  }

}

exports.extend = extend(function(base) {
  base.extend({ scrollbar:fn })
})  
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../../events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/util.js":[function(require,module,exports){
var ua = require('../../ua')
  , _prefix = '-'+ua.prefix.toLowerCase()
  , _transform = _prefix + '-transform'

exports.getMatrix = function(node) {
  if(node.style[_transform]) {
    var arr = window.getComputedStyle(node, null)
      .getPropertyValue(_transform).replace('matrix(', '').split(',')
    return arr
  }
}

// exports.hasCalc = function() {
//   var dummy = document.createElement('div')
//     , props = [ _prefix+'-calc', 'calc' ]
//     , i = props.length
//   while(i-1) {
//     dummy.style.cssText = 'width:' + props[i-1] + '(1px);'
//     if (dummy.style.length) return props[i-1]
//     i--
//   }
// }
},{"../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/set.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var util = require('../../util')
  , element = require('./')
  , object = require('../../object')

/**
 * flags
 * add keywords to set objects which are checked using a function in flags
 * simply add fields to the set module
 */
var flags = exports
  /**
   * _flag
   * function that calls flag functions on element.set.flags
   */
  , _flag = function(name, val, copy, top) {
      var f;
      for (var i in flags) {
        f = flags[i].call(this, name, val, copy, top);
        if (f) {
          return f;
        }
      }
    }

util.define(element,
  /**
   * set
   * adds children for non existing attributes
   * _original are original values changed by cases and events
   * instances - add or remove children from instances;
   */
  '_set', function(val, i, instances) {
    //this
    if (!_flag.call(this, i, val[i], instances, val)) {

      if ( !this.isProperty( i, val ) ) {

        if (val[i] instanceof element) {
          var before
          if (this[i]) {
            for(var c=this.node.childNodes,node$=0,len=c.length;node$<len;node$++) {
              if(c[node$]===this[i].node) {
                before = c[(node$+1)]
                break;
              }
            }
            this[i].remove && this[i].remove();
          }
          //replace element if its already there
          // console.error(add, instances, val[i])
          var add = instances ? new val[i].Class : val[i];
          add.name = i;
          this.add(add, before);
          if (instances) {
            this.eachInstance(function() {
              var a = new add.Class();
              a._name = i;
              this.add(a);
            });
          }
        } else {
          
          if( this[i] instanceof object ) 
          {
            //TODO: torough testing
            this[i].val = val[i]
          } 
          else if( val[i] instanceof object ) 
          {
            console.warn('are you sure you want to set using a vObject? maybe require some stuff (e.g. data)')
            this[i] = val[i]
          } 
          else if( this[i] instanceof element ) 
          {
            if( val[i] ) {
              this[i].set(val[i], instances)
            } else if( val[i] === false ){
              if ( instances ) {
                this.eachInstance(function() {
                  if (this[i]) this[i].remove()
                })
              }
              this[i].remove()
              this[i] = null
            }
          } 
          else 
          {
            if(val[i] instanceof Object ) {
              var add = new element().set(val[i], instances)
              add.name = i;
              this.add(add)
              if (instances)
              {
                this.eachInstance( function() {
                  var a = new add.Class()
                  a._name = i
                  this.add(a)
                })
              }
            } else {
              console.warn('"' + i + '" is not an existing property. "' + val[i] + '" is a primitive. Adding as primitive.' )
              this[i] = val[i]
            }

          }
        }
      } else {
        if(typeof this[i] === 'function') {
          if(val[i] instanceof Array) {
            this[i].apply(this,val[i])
          } else {
            this[i](val[i])
          }
        } else {
          this[i] = val[i]
        }
      }
      //dynamic changes to the _original set object pool
      //if (!copy && this._original) {
      //this._original[i] = val[i]; //check if stuff /w classes is nessecary;
      //}
    }
  },
  /**
   * convert
   * for each fields in val convert back to a setObject;
   */
  'convert', function(val) {
    var setObj = {},
      isObj;
    for (var i in val) {
      isObj = util.isObj(val[i])
      if (this[i] instanceof element) {
        setObj[i] = isObj ? this[i].convert(val[i]) : this[i]
      } else if (this[i] instanceof object) {
        setObj[i] = this[i].convert(isObj && val[i])
      } else if (this[i] === void 0 || (util.lookup.call(this, i) && this[i] === false)) {
        setObj[i] = false
      } else {
        setObj[i] = this[i]
      }
    }
    return setObj
  })
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
//duration in a V.Value --> update if nessecary?
var ua = require('../../ua')
  , video = require('./')
  , postpone = require('../../../browser/events/util').postpone
  , _winPhone = ua.platform === 'windows' && ua.device === 'phone'
  , _ios = ua.platform === 'ios'
  , _android = ua.platform === 'android'
  , _ios7 = _ios && navigator.userAgent.split('OS')[1][1] === '7' // TEMP FIX UNTIL WE DO UA
  , _canplay = 'canplay'//_ios7 ? 'canplaythrough' : 'canplay' 

function createListener () {
  var args = arguments
    , l = args.length

  return function(type) {
    for (var i = 0, _this = this; i < l; this.node.addEventListener(args[i++]
      , function(e) { type._val.call(_this,e) }));
  }

}

function _canplayListener () {
  if ( !this._canplay && !_winPhone ) { //later versions (if fixedin 9)
    
    var _this = this
      , node = this.node
    
    this._canplay = true
    
    // if(_ios) node.style.visibility = 'hidden'

    function canPlay() {
      if ( _this.time ) {
        
        if (!_this.time.val) this._firstT = true
          //fixes for phonegap! windowsmobile
        if (_android && ua.browser !== 'chrome') { 
          //and special browser!; check firefox; //identify more browsers that do not need this crap
          var tries = 0
          clearInterval( _this._timeFixInterval )
          _this._timeFixInterval = setInterval(function() {
            _this.updateTime()
            if (tries === 3) {
              _this._canplay = null
              clearInterval(_this._timeFixInterval)
            }
            if (_this.node.duration !== 1) { //android sets duration to 1 as default instead of 0
              tries++
              if (_this.playing) _this.node.play()
            }
          }, 200)
        } else {

          if (_this.time.val) {
            if (_ios7) {
              setTimeout(function() { _this.updateTime() }, 0)
            } else {
              _this.updateTime()
            }
          } else {
            _this._forceTime = true 
          }

          if( _ios && this.playing ){
            var time = _this.time.val * _this.duration.val
            function timeupdate(){
              if(~~node.currentTime >= ~~time){
                node.removeEventListener('timeupdate', timeupdate)
                if(_ios7){
                  function canplaythrough(){
                    node.play()
                    node.style.visibility = 'visible'
                    node.removeEventListener('canplaythrough',canplaythrough)
                  }
                  node.addEventListener('canplaythrough',canplaythrough)
                }else{
                  node.play()
                }
              }
            }

            node.addEventListener('timeupdate', timeupdate)
            node.pause()
          }

          _this._canplay = null

        }
      }

      node.removeEventListener(_canplay, canPlay)
    }

    this._canPlay = canPlay
    node.addEventListener(_canplay, canPlay)
  }
}

function setTime (val) {
  if (this.node.readyState) {
    this.node.currentTime = val
    if (_ios) this._correctTime = val
  } else {
    _canplayListener.call(this)
  }
}


module.exports =  
{ progress: {
    set: function() {
      var _this = this
      this.node.addEventListener('end', (_this._prEnd = function() {
        _this.clearProgress()
      }))
    },
    remove: function() {
      this.node.removeEventListener('canplay',this._canPlay)
      this.node.removeEventListener('end', this._prEnd) //maybe no play and pause!;
    }
  }
, buffer: function(val) {
    var buffered = this.node && this.node.buffered
    if (buffered) {
      var l = buffered.length
        , piv = -1
        , t = this.node.currentTime || 0
        , ls
        , tt
        , i = 0
      
      for (; i < l; i++) {
        ls = buffered.start(i)
        if (ls > piv && ls < t) {
          piv = i
          tt = ls
        } else {
          break
        }
      }
      if (piv > -1) {
        piv = buffered.end(piv)
        return piv < t ? 0 : piv / this.duration.val
      } else {
        return 0
      }
    }
    return 0
  }
, play: function(val) {
    if(this.node && this.node.pause) {
      if (val) {
        this.node.play()
      }
      else {
        this.node.pause()
      }
    }
  }
, time: 
  //tests for android , winphone, firefoxphone (seeking on winphone is not possible anyways)
  { set   //_ios  || _android //ua.device === 'phone' || ua.device === 'tablet'
      // postpone(setTime)
    : setTime
  , get: function(val) {
      var time = this.node && this.node.currentTime
      if (this._correctTime) {
        if (this._correctTime > time - 2 && this._correctTime < time + 2) { //|| this.cnt
          time = this._correctTime
          if (!this.cnt) {
            this.cnt = 3
          } else if (this._cnt < 2) {
            this._correctTime = false
            this._cnt = false
          } else {
            this._correctTime+=0.5 //should be interval of progress updates
            this._cnt--
          }
        } else {
          time = this._correctTime
        }
      }
      return time / this.duration.val || val.val
    }
  }
, duration: function(val) {
    var node = this.node
    return node && node.readyState ? node.duration : val && val.val
  }
, autoplay: function(val) {
    if(this.node) this.node.autoplay = val.val
  }
, loop: function(val) {
    if(this.node) this.node.loop = val.val
  }
, volume: function(val) {
    var volume = val.val
    if(this.node && !isNaN(volume)) this.node.volume = volume
  }

, "new": function() {
    this.addEvent('down',function(e){ e.preventDefault() })
    _canplayListener.call(this)
    if (this.volume) this.volume.update(this)
  }
, events: {
    pause:function(val) {
      var _this = this
      if(_ios && _this.node) { 
       _this.node.addEventListener('pause', function(e) {
         if(!_this.ignoreevents) _this.pause()     
       })
      }
    }
  , progress: video.progress
  , ready: createListener('loadedmetadata')
  , canplay: function(val) {
      var _this = this
      if(_this.node) _this.node.addEventListener(_canplay, function(e) {
        if(_this.node && _this.node.readyState===4) {
          _this._stalled = false
          val._val.call(_this,e)
        }
      })
    }
  , stalled: function(val) {
      var _this = this
        , node = this.node
        , listen = function(e) {
          var time = _this.getTime()
          if(!(_this.getBuffer(time)-time > 0.05)) {
            _this._stalled = true
            val._val.call(_this,e)
          }
        }
      if(node){
        node.addEventListener('stalled', listen )
        node.addEventListener('waiting', listen )
      }
    }
  , play: 
    { play: function() {
        if (this.events.play) this.events.play._val.call(this)
      }
    , set: false
    }
  , end: createListener('ended')
  }
, src: function(val) {
    var src = this.node.src
    if (src !== val || val || !val && src) this.node.src = val.val
  }
}

if (!video.player) video.player = module.exports
},{"../../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var element = require('../')
  .inject
  ( require('../properties')
  )

  , events = require('../../events')
  , util = require('../../../util')
  , postpone = require('../../events/util').postpone
  , base = new element({
      node: 'video'
  })
  
module.exports = exports = base.Class
var video = exports
exports.base = base

base.setSetting(
{ name: '_videoSettings'
, new: function() {
    if (this.player.new) this.player.new.call(this)
  }
, remove:function() {
    if (this.player.remove) this.player.remove.call(this)
  }
, render:function() {
     if (this.player.render) this.player.render.call(this)
  }
})
//proxy adden --> should be an extension on src
base.node.setAttribute('webkit-playsinline', '')

//cloud shorten these 3 functions
function _vidEvents (val) {

  this._readyForEvents = true

//   console.log('\n\n\n\n\nn\n\n\nSET VIDEVENTS')

  var t = this
    , e = (this.player || video.player).events
  val.each(function(i) {
    if (e[i] && e[i].set !== false) (e[i].set || e[i]).call(t, this, i)
  })
  return e
}

function _removeVidEvents (val) {
  var t = this
    , e = (this.player || video.player).events

  val.each(function(i) {
    if (e[i] && e[i].remove) e[i].remove.call(t, this, i)
  })
}

function _playHook (param) {
  var val = this.events
  if (val) {
    var t = this
      , e = (this.player || video.player).events
    val.each(function(i) {
      if (e[i] && e[i].play) e[i].play.call(t, this, i, param)
    })
  }
}

function _progress(val) {

  // console.error('SET progress',this._progress)

  if (!this._progress) {

      // console.error('SET progress for REAL',this._progress)

    //maybe do this with requestAnimationFrame -- danger lies in incosistency with timing
    var params = val
      , interval = params.interval && params.interval.val || 500 
      , fn = params._val
      , t = this
      , pr = (this.player || video.player).progress

    if (pr && pr.set) pr.set.call(t)

    t._progress = setInterval(function() {

      // console.log('before progress call!',t.src.val)
      // if(t.playing&&!t.__paused) {
      //   // t.play()
      //   // no src!
      // }

      var p = Number(t.getTime())
        , b = t.getBuffer(p)
        , d = Number(t.duration.val)

      if(d===1) d=0 //android fix -- maybe remove

      if (p >= 1 && d) {
        t.pause()
        t.playing = false //should this be removed an go to end? 
        //call pause and set time in here?
        t.clearProgress()
      } else {

        if(t._stalled && d) { //just to make sure buffering always dissapaers    
          if(b>0.85 || (t.__lp && t.events.canplay && (p > t.__lp+(1/d)))) { //in seconds
            t._stalled = false
            t.events.canplay._val.call(t)
            t.__lp = null
          } else if( (!t.__lp) && p>-1) {
            t.__lp = p
          } 
        }

        if(!t.ignoreevents) fn.call(t, p, b)
      }
    }, interval)
  }
}

this._progress = _progress

exports.progress = 
{ play: function(i, p, pa) {
    if (pa) {
      _progress.call(this, this.events.progress)
    } else {
      this.clearProgress()
    }
  }
, set: function(val) {
    if (this.playing) _progress.call(this, val)
  }
, remove: function() {
    this.clearProgress()
  }
}

util.define(exports
, 'resumePlay', postpone(function() {
    if(this.node) {
      if(this.$playing.val===true) {
        this.play()
      }
      this.isSeeking = null
      // console.error('RESUME!')
    }
  },1001)
, 'setEvents', function() {
    _vidEvents.call(this, this.events)
  }
, 'play', function(clear, ignore) {

    if (clear) delete this.ignoreevents
    if (!ignore && !this.ignoreevents && this.playing !== true) {
        this.playing = true
        _playHook.call(this, true)
    } else if(this.__paused && this.events.progress) {
      this.playing = true
      _progress.call(this,this.events.progress)
    }
    this.__paused = null
    ;(this.player || video.player).play.call(this, true)
  }
, 'pause', function(ignore) {

    if(ignore) this.ignoreevents = true

    if (!this.ignoreevents && this.playing !== false) {
      this.playing = false
      _playHook.call(this, false)
      if(this.events.pause) {
        this.events.pause._val.call(this)
      }
    } else {
      this.clearProgress()
    }

    this.__paused = true
    ;(this.player || video.player).play.call(this, false)
  }
, 'toggle', function(val) {
    if (this.playing) {
      this.pause()
    } else {
      this.play()
    }
  }
, 'updateTime', function() {
    this._firstT = false
    exports.setTime.call(this, this.time)
  }
, 'getTime', function() {

    // console.error(this.isSeeking)

    return this.isSeeking 
      || (this.rendered && this.player 
      || video.player).time.get.call(this, this.time) 
      || 0
  }
, 'getBuffer', function(val) {
    return (this.rendered && this.player || video.player).buffer.call(this, val || 0)
  }
, 'clearProgress', function() {
    if (this._progress) {
      // console.log('remove that progress')
      clearInterval(this._progress)
      this._progress = null
      var pr = (this.player || video.player).progress
      if (pr && pr.remove) pr.remove.call(this)
    }
  }
)

base.extend(
{ name: 'player'
, type: false
, set: function(val) {
    util.setstore.call(this)
    this.__.player = val
    if (val.element) this.node = val.element
    if (this._class) this._class.prototype._.player = val
  }
, get: function(val) {
    return util.getStore.call(this, 'player') || video.player || {}
  }
}
, 
{ name: 'duration'
, set: function(val) {}
, get: function(val) {
    val._overwrite = (this.player || video.player).duration.call(this, val)
    return val
  }
}
,
{
  name:'$playing'
, set:function( val ) {
    //stamp info
    // if( this.rendered ) //TODO avoid heavy check
    // {
      // console.error('!!!!!!!!!!!set $playing', val.val)
      if( val.val )
      {
        this.play()
      }
      else
      {
        this.pause()
      }
    // }
  }
}
, 
{ name: 'time'
, set: 
  (exports.setTime = function(val) {
    if (!this._ignore) {


      val._overwrite = null
    
      var v = val.val
        , i = false

      if (v !== void 0) {
        if (!this._firstT || this._forceTime === true) { 
          v = Math.abs(v)
          i = true;
          this._firstT = true
          this._forceTime = null
        }

        if (v >= 0) {



          if(this.duration){
            this.isSeeking = v

            // if(playing) this.pause()

            if(this.__lp) this.__lp = null
            ;(this.player || video.player).time.set.call(this, v * this.duration.val)
            if(this.events.seeking && !i)  this.events.seeking._val.call(this,v)

            this.resumePlay()

          }else{
            console.error('can\'t set time, no duration defined!')
          }

          

        }
      }

    }
  })
}
, 
{ autoplay: function(val) {
    (this.player || video.player).autoplay.call(this, val)
  }
, loop: function(val) {
    (this.player || video.player).loop.call(this, val)
  }
, volume: function(val) {
    (this.player || video.player).volume.call(this, val)
  }
, src: function(val) {
    if(val.val!==this.___Src) {
      this.___Src = val.val
      if(this.events.src)  this.events.src._val.call(this,val)
      ;(this.player || video.player).src.call(this, val)
      // console.error('!!!!!!!!!!!set src')

      if(this.$playing.val === true) {
        this.play()
      }

    }
  }
}
, 
{ name: 'events'
, "new": function() {
    //deze functie kunnen instellen
    if(  (this.player && this.player.setEvents !== false)) {
      _vidEvents.call(this, this.events)
    }
  }
, remove: function() {
    if(this.rafId)
    { 
      window.cancelAnimationFrame(this.rafId)
      this.rafId = null
    }
    _removeVidEvents.call(this, this.events)
  }
, set: function(val) {
//   console.log('EVENTS!')
    
    var a = util.arg(arguments)
    
      a[5] = this._readyForEvents 
           ? _vidEvents.call(this, val) 
           : (this.player || video.player).events 

      if(!a[5].seeking) a[5].seeking = {set:false}
      if(!a[5].src) a[5].src = {set:false}
    
    events._set.apply(this, a)
  }
})

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js","../../events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../properties":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
exports.time = function(time, decimals) {
  var hrs = ~~ (time / 3600),
    mins = ~~ ((time % 3600) / 60),
    secs = decimals ? (time % 60).toFixed(decimals) : ~~(time % 60);
  ret = "";
  if (hrs > 0) ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
  ret += "" + mins + ":" + (secs < 10 ? "0" : "");
  ret += "" + secs;
  return ret || 0;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/advanced.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
var events = require('./')
  , operators = require('../../value/operators')
  , doc = events.document

module.exports = events

operators._e = function(val, operator) {
  return val + operator
}

operators._esub = function(val, operator) {
  return val - operator
}

operators._e.order = 3
  
function chooseMove (val, method) {
  return val.move && val.move._val 
    || !method.__t && method !== true && method 
    || method._val;
}

function drag (e, method, val) {
  var t = val.bind ? val.bind._val : this
    , move = chooseMove(val, method)
    , id = 'drag'
  e.preventDefault()
  if (move) doc.addEvent('move', function(e) {
    move.call(t, e, val)
  }, id)

  if (val.down) val.down._val.call(t, e, val)
  
  doc.addEvent('up', function(e) {
    if (val.up) val.up._val.call(t, e, val)
    doc.removeEvent(false, id)
  }, id)
}

function active (e, method, val) {
  var self = this
    , id = 'active'
    , timer = setTimeout(function(){
        self.css = {addClass:val._val}
        timer = null
      },50)

  if(exports._deactivate) exports._deactivate()

  exports._deactivate = function(){
    if(timer) clearTimeout(timer)
    doc.removeEvent(false,id)
    exports._deactivate = null
    window.requestAnimationFrame(function(){
      if(!self) return
      if(!self._stayActive) self.css = {removeClass:val._val}
      else self.css = {addClass:val._val}
    })
  }

  doc.addEvent('move',exports._deactivate,id)
  doc.addEvent('up',exports._deactivate,id)
}

function shallowRaw (vobj) {
  var obj = {}
    , keys = vobj.keys
    , key
    , i = keys.length - 1
  for (; i >= 0; i--) {
    key = keys[i]
    obj[key] = vobj[key]
  }
  return obj
}

function initGrab (t, e, val, name) {
  if (!t[name] || !t[name]._e) t[name] = { _e: 0 }
  if (val[name]._val !== true) t[name].set('_e', shallowRaw(val[name]))
  return e[name] - (t[name]._e.val)
}

function grab (e, method, val, nested) {
  var t = val.bind && !nested ? val.bind.val : this
    , id = ( val.y 
      ? 'y' 
      : val.x 
        ? 'x' 
        : 'xy') 
        + 'Grab' 
        + (nested || '')
  if (t) {
    if (t._node) {
      var move = chooseMove(val, method)
        , startX = e.x
        , startY = e.y
        , ready
        , cX
        , cY
        , oldX
        , oldY
        , newX = startX
        , newY = startY
        , pass
        , upFn = function(e) {
            t.x._p = false
            t.y._p = false
            if (val.up && pass) {
              val.up._val.call(t, e, {
                x: newX - startX,
                y: newY - startY
              },
              { x: newX - oldX
              , y: newY - oldY
              })
            }
            events.click.block = false
            doc.removeEvent(false, id)
          }
      if (!val.x && !val.y){ //this needs revision
        val.x = {_val: true}
        val.y = {_val: true}
      }
      if (val.down) val.down._val.call(t, e, val);
      doc.addEvent('move', function(e) {
        oldX = newX
        oldY = newY
        newX = e.x
        newY = e.y

        events.click.block = true

        if (!ready) {
          pass = val.pass ? val.pass._val.call(t, e, {
            x: newX - startX,
            y: newY - startY
          }) : true
          if(!pass) {
            upFn(e)
            move = false
            doc.removeEvent(false, id)
          } else {
            e.preventDefault()
            if (val.x) {
              cX = initGrab(t, e, val, 'x')
              t.x._p = 1
            }
            if (val.y) {
              cY = initGrab(t, e, val, 'y')
              t.y._p = 1
            }
            if (val.start) val.start._val.call(t, e, val)
            ready = true
          }
        }else{
          e.preventDefault() //for android
          if (cX) t.x = { _e: newX - cX }
          if (cY) t.y = { _e: newY - cY }
          if (move) move.call(t, e, {
              x: newX - startX,
              y: newY - startY
            },val) //check for speed
        }
      }, id)
      doc.addEvent('up', upFn, id)
    } else {
      for (var i = t.length - 1; i >= 0; i--) {
        grab.call(t[i], e, method, val, i + 1)
      }
    }
  }
}
//add the events
events.drag = { val: { down: drag } }
events.grab = { val: { down: grab } }
events.active = { val: { down: active } }
},{"../../value/operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/basic.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var events = module.exports = require('./')
  , cases = require('../cases')
  , util = require('../../util')
  , ua = require('../ua')

cases.$hasTouch =
( ( 'ontouchstart' in window )
  || window.DocumentTouch
  && document instanceof DocumentTouch
)
|| navigator.msMaxTouchPoints
|| false

function _basic(e, method, val) {
  e.x = e.pageX
  e.y = e.pageY
  method.call(this, e, val)
}

util.define
( events
, '_out'
, { value: [] }
)
//clickout cannot be used to create complex events! it's too custom 
//tried to fix

function keyBoardEvent( name, domEvent, wrapper ) {

  var _name = '_'+name

  util.define( events, _name, { value:[] } )

  var event = 
  {
    create: function( field, from ) {
      var exec = function( e ) {

        //dit gaat heel snel fout hiero
        // console.log('nu ff ook de wrapper callen!', field, from, events[from])
         if( this.rendered ) {

          if( wrapper ) {
            wrapper.call(this, e, this.events[from]._val )
            //this.events[from]._val.call(this, e)
          }
          else if( events[from] && events[from].val) {
            var method = events[from].val
            for(var i in events[from]) {
              if( cases[i]) {
                method = events[from][i]
              }
            }
            method = method[field]
            if( method ) {
              method.call(this, e, this.events[from]._val )
            } 
          } else if( this.events[from] ) {
            this.events[from]._val.call(this, e)
          }

        }
      }
      events.document.addEvent( domEvent, function(e) {

        for ( var arr = events[ _name ], i = arr.length - 1; i >= 0; i-- ) {
          exec.call( arr[i], e )
          
          if( arr[i] ) {
            // console.log( 'do it now!', _name, arr, arr[i], e)
            arr[i].eachInstance( exec, 'events', e )
          }

        }
      }, name )
    },
    add: function( id, field ) {

      field = _name

      this.setSetting(
      { name: field
      , remove: events[ name ].remove
      })

      if ( !util.checkArray( events[ _name ], this ) ) 
      {
        events[ _name ].push(this)
      }

    },
    remove: function() {
      // console.log('WRONGWRONGWRONG!!!!!', _name, events[_name], events)
      //selected moet mischein alleen vanuit Value $focused -- niet op elk item op key up....
      //doe dit smart -- for now zou auto remove kunnen doen als iets er niet meer is?
      var index = util.checkArray( events[ _name ], this, true ) 
      if( ~index ) {

        var noRemove

        // console.log('this:', this )
        // console.log('from base:', this._from.base)
        // console.log('event name:', name)
        // console.log('events:', this.events )
        if(this.events && this._from.base.events) { 
          noRemove = this.events[name] === this._from.base.events[name]
          // console.log('events equals class:', noRemove )
        } else {
          // console.error('no nice events')
        }
        
        if(!noRemove) {
          events[ _name ].splice( index, 1 )
        }
        else {
          console.log(noRemove, 'noRemove evnt, are we sure - fix this asap')
        }
        // debugger
        // this.removeSetting( name ) --- redo this later
      }
    }
  }

  events[ name ] = event

}

events.$makeKeyBoardEvent = keyBoardEvent

keyBoardEvent( 'keyboard', 'keyup' )
keyBoardEvent( 'keyboardDown', 'keydown' )
keyBoardEvent( 'keyboardDown$down', 'keydown' )
keyBoardEvent( 'keyboardDown$click', 'keydown' )

//-----dit ff echt goed fixen!

function basicDown(e, method, val) {
  if( e.which!==1 || events.down.block ) return
   _basic.call(this,e, method, val)
}

events.down =
{ $hasTouch:
  { touchstart: function(e, method, val) {
      if(events.down.block) return
      var targetTouches = e.targetTouches[0] || {}
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
    }
  }
, val: { mousedown: basicDown }
// , tv: 
//   {  // mousedown: basicDown //combineren binnen kort moet voor LG
//      keyboardDown$down: function( e, method, val ) {
//       //this._$focused && 
//       if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) 
//       {
//         method.call(this, e, val)
//       }

//     }
//   }
}

//right-down
events.rdown =
{ $hasTouch:
  { touchstart: function () {
      //2 fingers?
    }
  }
, val:
  { mousedown: function (e, method, val) {
      if(e.which===3) {
        document.oncontextmenu = function() { return false }
        e.preventDefault()
        // e.rdown = true
        _basic.call(this,e,method,val)
        setTimeout(function() { document.oncontextmenu = false }, 0)
      }
    }
  }
}

//move
events.move = {
  $hasTouch:
  { touchmove: function (e, method, val) {
      var targetTouches = e.targetTouches[0]
      e.x = targetTouches.pageX
      e.y = targetTouches.pageY
      method.call(this, e, val)
      // document.write(e.targetTouches[0].pageX);
    }
  }
  , val: {
    mousemove: _basic
  }
}

//up
events.up = {
  //keyUp
  $hasTouch: {
    touchend: function(e, method, val) {
      var ct = e.changedTouches
      e.x = ct[0].pageX
      e.y = ct[0].pageY
      method.call(this, e, val)
    }
  }
, val: {
    mouseup: _basic
  }
}

//click
events.click = {
  // tv: {
  //   keyboardDown$click: function(e, method, val ) {

  //     if( this._$focused && util.checkArray( [ 13, 29443 ] , e.keyCode ) !== false ) {
  //       method.call(this, e, val)
  //     }

  //   }
  // },
  val: {
    down: function(e, method, val) {

      // console.log('CLICK IT!')

      var t = this
        , name = 'click'
      if(!events.click.block){
        t.addEvent('up', function(e) {
          t.removeEvent('up', name)
          var ms = events._maybescroll
          if(ms){
            if(ms.length) events._maybescroll.unshift([method,t])
            else events._maybescroll = [[method,t]]
          }else if(!events.click.block) method.call(t, e, val)
        }, name);
        setTimeout(function() {
          t.removeEvent('up', name)
        }, 300)
      }
    }
  }
}

events.rclick = {
  val: {
    rdown:events.click.val.down
  }
}

var _outRemove = function() {
    var index = util.checkArray(events._out, this, true)
    if (~index) {
      events._out.splice(index, 1)
      this.removeSetting('_out', _outSetting)

      // debugger

    }
  }
, _outSetting = {
  name: '_out',
  render: function() {
    if (!util.checkArray(events._out, this)) {
      events._out.push(this)
    }
  },
  remove: _outRemove
}

events.out = {
  create: function() {
    this.m = true;
    events.document.addEvent('up', function(e) {

      var base = e.target,
        exec = function() {
          var p = base
            , t
          while (p && !t) {
            if (p.base && this === p.base) {
              t = true;
            } else {
              p = p.parentNode;
            }
          }
          if (!t && this.rendered) this.events.out._val.call(this, e)
        }
      for (var arr = events._out, i = arr.length - 1; i >= 0; i--) {
        exec.call(arr[i])
        if (arr[i]) arr[i].eachInstance(exec, 'events')
      }
    },'out')
  },
  add: function() {
    var t = this
     // events._out.push(this)
    this.setSetting(_outSetting)
  },
  remove:_outRemove
};
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var element = require('../element')
  , cases = require('../cases')
  , util = require('../../util')
  , FieldStore = function () {}

util.define(FieldStore, '_uid', { value: 0 })

exports._r = {} //list of basic (raw) events e.g. 'mousedown'

//remove events if there are no children that use them anymore

exports.document = new element({ node: document })

exports.document.exec = function( event ) {
  if( this.__e[event] )
  {
    var args = util.arg( arguments, 1 )
    for( var i in this.__e[event] )
    {
      this.__e[event][i].apply( this, args )
    }
  }
}

function _create( i, from ) {
  if( exports[i] )
  {
    // console.log('complex', i, from)
    _createComplex( i, from )
  }
  else
  {
    // console.log('_basic', i)

    exports[i] = { _basic: true }
    _createBasic( i )
  }
}

function _createWhile (i, m) {
  return function(e) {
    var parent = e.target
      , base, events
    while (parent) {
      base = parent.base
      if (base) {
        events = base.events
        if (events[i]) {
          if (m) {
            exports[i]._m.call(base, e, events[i])
          } else if (events[i]._val) {
            events[i]._val.call(base, e)
          }
          if (e.prevent) return
        }
        events = base.__e
        if (events && events[i]) {

          for (var j in events[i]) {
            if(j!=='_uid') {
              if (m) {
                exports[i]._m.call(base, e, events[i][j])
              } else {
                // console.log('?what', i, j, base, base._node)
                events[i][j].call(base, e)
              }
              if (e.prevent) return
            }
          }
        }
      }
      parent = parent.parentNode
    }
  }
}

function _createBasic (i, r) {
  var type = i || r

  // console.log('createBasic', type,i)

  exports._r[i] = true
  if(type === 'scroll') {
    document.addEventListener(type, function(e){
      var base = e.target.base
        , events

      if(base) {
        events = base.events
        if(events && events[i]) events[i]._val.call(base, e)
        events = base.__e
        if (events && events[i]) {
          for (var j in events[i]) {
            if(j!=='_uid') events[i][j].call(base, e)
          }
        }
      }
    },true)
  }else document.addEventListener(type, (exports[i].m = _createWhile(i)))
}

function _setComplex ( i, m, r, from ) {
  var met = exports[i]._m = function (e, val) {
    if (e.prevent) return
    m.call(this, e, (val._val || val.val || val), val)
  }
  exports[i].m = _createWhile(i, true)
  exports._r[i] = true
  if (exports[r]) {
    if (!exports[r].m) {
      _create(r, from )
    }
    if (!exports[r]._basic) {
      exports[i].__e = exports[r].__e
      exports[i]._m = function (e, m) {
        exports[r]._m.call(this, e, function(e) {
          met.call(this, e, m)
        })
      }
    } else {
      exports[i].__e = r
    }
  }
  document.addEventListener((exports[r] && exports[r].__e) || r, exports[i].m)
}

var addWrapper = function( add, field, orig ) {
  return function() {
    // console.log( 'ADD WRAP!', field, orig , arguments )
    return add.apply(this, arguments)
  }
}

function _createComplex( field, from ) {

  // console.log('_createComplex' ,field, from )

  if( exports[field].create ) exports[field].create( field, from)
  var m
    , i
    , j
  for ( i in exports[field] ) {
    if (cases[i] === true) m = exports[field][i]
  }
  if ( m || ( m = exports[field].val ) ) {
    for (j in m) //only one
    ;exports[field].__e = j

    if (m[j] === true) 
    {
      exports[field]._basic = true
      _createBasic(field, j)
    } 
    else 
    {
      //basic en non basic ijn niet te combineren -- combineren nog kapot
      // console.log('set complex field', field, m, j,  exports[j]) 
      //!!!tripple check dit!!!
       for( j in m ) 
       { 
        if( exports[j] && exports[j].add 
         && exports[field] && !exports[field].add
        ) 
        {
          exports[field].add = addWrapper( exports[j].add, field, j )
        }
        _setComplex(field, m[j], j, from )
      }
      //!!!danger loop!!!
    }

  }
}

exports._set = function (val, stamp, from, remove, cval, blacklist) {
  var t = this
  val.each(function (i) {
    if (!blacklist || !blacklist[i]) {
      if (this._val === false) {
        if (exports[i]) {
          if (exports[i].remove) exports[i].remove.call(t)
          t.eachInstance(exports[i].remove, val._prop.name)
          this.remove()
        }
      } else {
        
        // console.log('_cre', i, exports[i])

        if (!(exports[i] && exports[i].m)) {
          // console.log('---pass', i)
          _create(i, i)
        }
        //add wrapper?


        // console.log('_set',i, exports[i].add, exports[i])

        if (exports[i].add) exports[i].add.call( t, false, i )
      }
    }
  })
}

element.base.extend(
{ name: 'events'
, set: exports._set
})

util.define(element
, 'addEvent', function(field, fn, id) {
          // console.log('XXXX',field)

    if (!(exports[field] && exports[field].m)) _create(field)
    var events = this.__e || (this.__e = {})
      , f = events[field] || (events[field] = new FieldStore())

    if (!id) {
      f._uid++
      id = f._uid
    }
    f[id] = fn

    // console.log('addEvent!!!', field)

    if (exports[field].add) exports[field].add.call(this, id, field)
    return this
  }
, 'removeEvent', function (field, id, fn) {
    var events = this.__e
      , remove
    if (events) {
      if (field && events[field]) {
        remove = (exports[field] && exports[field].remove)
        if (id) {
          if (events[field][id] && (!fn || events[field][id] === fn)) {
            if (remove) exports[field].remove.call(this, id)
            delete events[field][id]
          }
        } 
        else {
          for (id in events[field]) {
            if (!fn || events[field][id] === fn) {
              if (remove) exports[field].remove.call(this, id)
              delete events[field][id]
            }
          }
        }
        if (util.empty(events[field])) delete events[field]
      } 
      else if (!field) {
        for (field in events) {
          this.removeEvent(field, id, fn)
        }
      }
    }
    if (util.empty(events)) delete this.__e
    return this
  })

require('./basic')

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js","./basic":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/basic.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js":[function(require,module,exports){
var matrix = require('../element/properties/util').getMatrix
  , vigour = require('../../')
  , css = require('../css')

exports.left = exports.x = function ( object, arr ) {
  return offset(object,arr,'left','offsetLeft', 4)
}

exports.top = exports.y = function ( object, arr ) {
  return offset(object,arr,'top','offsetTop', 5)
} 

function offset ( object, arr, prop, propL, matrixIndex ) {
  if(!object) return 0
  var start = false
  if(!arr) {
    arr = []
    start = true
  }
  
  if(vigour.Element && object instanceof vigour.Element) object = object.node

  var amount = object[propL]
    , temp = 0
  if(typeof(amount) !== 'number') amount = 0
  if(object.parentNode) exports[prop](object.parentNode, arr)
    if( ( (object.style && object.style.position)
      ||object.__preCss
      ||object.className 
        && (object.__preCss = css(object.className, 'position')||true)) 
      !== 'absolute' ) {
        arr.push(['rel', amount])
    } else {
      var matrixArray = matrix(object)
      arr.push(['abs', matrixArray 
        ? parseInt(matrixArray[matrixIndex],10)+amount //normal amount as well
        : amount ])
    }
  
  if(start) {
    var lastrel
      , abs = 0
      , i
    for(i in arr) {
      if(arr[i][0] == 'abs') {
        abs += arr[i][1]
      } else {
        lastrel = arr[i][1]
      }
    }
    amount = arr[arr.length - 1][0] === 'rel' ? abs+lastrel : abs
  }
  return amount || 0
}

  



},{"../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../css":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/css.js","../element/properties/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js":[function(require,module,exports){
var raf = require('../animation/raf')
  , util = require('../../util')

exports.throttle = function(fn, frames, bind) {
  frames || (frames = 20) //~0.4sec
  var timer
    , arg
    , nobind = !bind
  return function() {
    arg = arguments
    if(nobind) bind = this
    if(!timer) {
      timer = frames
      raf(function repeat() {
        timer--
        if(!timer) {
          fn.apply(bind,arg) 
        } else {
          raf(repeat)
        }
      })
    }
  }
}

//TODO: postpone based on frames
exports.postpone = function(fn, time, bind) {
  time || (time = 200) //no raf!
  var timer
    , arg
    , nobind = !bind
  return function() {
    arg = arguments
    if(nobind) bind = this
    if(timer) clearTimeout(timer)
    timer = setTimeout(function() {
      fn.apply(bind,arg)
    },time)
    return timer
  }
}

//TODO: test for leaks...
exports.interval = function(fn, frames, bind) {
  frames || (frames = 30) //~0.5sec
  var timer
    , clear
    , arg = util.arg(arguments,3)
  if(!timer) {
    timer = frames
    raf(function repeat() {
      timer--
      if(!timer) {
        timer = frames
        fn.apply(bind,arg)
      } 
      if(!clear) raf(repeat)
    })
  }
  return function() {
    clear=true
  }
}

},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var _a = 'addEventListener'
  , util = require('../../util')
  , ua = require('../ua')
  , cnt = 0

/**
 * xhr wrapper, adds some nice extras such as multiple requests to a single api call
 * xhr wrapper will include jsonp in a later stage
 * @method extend
 * @param   {String|Array} params.url         Specifiy the url, array fetches multiple url's
 * @param   {String}   [params.api]           Repeat this string for the url that needs to be called
 * @param   {Function} [params.complete]      Specify a callback when an array is passed to url complete is called when all items are complete
 * @param   {Function} [params.error]         On error callback
 * @param   {Function} [params.change]        Function called on xhr.onreadystatechange
 * @param   {Boolean}  [params.async]         If set to false will call an syncronous request (not recommended!)
 * @param   {String}   [params.user]          User parameter
 * @param   {String}   [params.pass]          Password parameter
 * @param   {Boolean}  [params.parse]         If set to false will not try to parse response to JSON
 * @param   {String}   [params.type|.method]  POST or GET, default is get;
 * @param   {String}   [params.contentType]   request content type default id "application/x-www-form-urlencoded"
 * @param   {String}   [params.mime]          defines mime type
 * @param   {Function} [params.progress]      Progress callback
 * @param   {Boolean|String} [params.jsonp]   Use jsonp , if passed as a string determines script+?callback=
 * @param   {Object}   [params.header]        Sets request headers
 * @param   {*}        [params.data]          Pass data to the request, defaults to ? on get;
 */

var iframes
  , ajax = module.exports = function(params, urlset) {
    var _url = params.url;
    if (!urlset && _url instanceof Array) {
      params.m = function() {
        if ((++params.r) === params.n) {
          for (var i = 0, arr = [], l = _url.length; i < l; arr.push(params.d[_url[i++]]));
          params.complete(arr);
        }
      };
      params.r = 0;
      params.d = {};
      for (var i = 0, l = params.n = _url.length; i < l; module.exports(params, _url[i++]));
    } else {
      var data = params.data
        , encode = params.encode
        , url = (params.api || '') + (urlset || _url)
        , headers = params.headers
        , success = params.complete
        , progress = params.progress
        , error = params.error
        , change = params.change
        , mime = params.mime
        , user = params.user
        , pass = params.pass
        , jsonp = params.jsonp
        , parse = params.parse
        , iframe = params.iframe
        , reqdata = null
        , fallback = params.fallback
        , fallbackIndex = params._fallbackIndex
        , method = params.type || params.method || 'GET'
        , contentType = params.contentType || encode === 'json'
          ? 'application/json'
          : 'application/x-www-form-urlencoded'
        , async = (params.async === false) ? false : true
        
      if( jsonp ) 
      {
        ajax.jsonp( url, success, error )  
        //function( url, success, error, context, cbName ) {
      } 
      else 
      {
        // ------------------------------------------------------------ DATA
        var xhr = new XMLHttpRequest()
        if(iframe) {
          cnt++
          var elem
            , msg = {}
            , reqid = cnt

          for(var field in params) {
            if(field!=='error'&&field!=='iframe'&&field!=='complete') {

              msg[field]=params[field]
            }
          }
          var setmsg = function() {
            var elem
            iframes[iframe].onload = null
            var msgcomplete = function(e) {
              // console.error('IFRAME REQ MSG COMPLETE',e.data)
              if(e.data) {
                var d
                try {
                  d = JSON.parse(e.data)
                } catch(e) {
                  if(error) error(e)
                  return
                }
                if(d.id!==reqid) return
                if(d.err) {
                  if(error) {
                    error(d.err)
                  }
                  return
                }
                var resp = d.msg
                if(success) {
                  if (parse !== false) {
                    try {
                      resp = JSON.parse(resp)
                    } catch (e) {}
                  }
                  success(resp,e)
                }
                removeEventListener('message', msgcomplete)
              }
            }
            if(window.addEventListener) {
              addEventListener("message", msgcomplete, false)
              elem = iframes[iframe].contentWindow
              msg = JSON.stringify({
                msg:msg,
                id:reqid
              })
              elem.postMessage(msg, '*')
            }
          }

          if(!iframes) iframes = {}
          if(!iframes[iframe]) {
            elem = iframes[iframe] = document.createElement('iframe')
            elem.src = iframe
            elem.cListeners = [
              setmsg
            ]
            elem.onload = function() {
              for(var h in elem.cListeners) {
                elem.cListeners[h]()
              }
              elem.cListeners = null
            }
            elem.style.visibility='hidden'
            elem.style.width = '0px'
            elem.style.height = '0px'
            elem.style.position = 'absolute'
            document.body.appendChild(elem)
          } else if(iframes[iframe].cListeners) {
            iframes[iframe].cListeners.push(setmsg)
            //elem.cListeners[i]
          } else {
            setmsg()
          }
          return;
        }

        if (data) {

          if (method === 'GET') {
            url += '?' + enCode(data, 'GET', encode)
          } else {
            reqdata = enCode(data, 'POST', encode)
  //           console.log( reqdata )
          }
        }

        // ------------------------------------------------------------ METHOD, URL, ASYNC, USER & PASS
        xhr.open(method, url, async, user, pass)
        // ------------------------------------------------------------ HEADERS
        xhr.setRequestHeader('Content-Type', contentType)
        if (headers) {
          for (var f in headers) {
            xhr.setRequestHeader(f, headers[f]);
          }
        }

        // ------------------------------------------------------------ EVENTS
        if (success) {
          xhr[_a]("load", function(e) {
            var resp = (e.target || e.srcElement).response;
            if (parse !== false) {
              try {
                resp = JSON.parse(resp)
              } catch (e) {}
            }
            if (params.m) {
              params.d[urlset] = resp
              params.m()
            } else {
              success(resp, e)
            }
          }, false)
        }
        if (error) {
          if(!fallbackIndex) params._fallbackIndex = 0
          if(fallback && fallbackIndex!==fallback.length) {
            params._fallbackIndex++
            params = util.merge(params,fallbackIndex)
            ajax(params, urlset)
          } else {
            xhr[_a]("error", error, false)
          }
        }
        if (progress) {
          xhr[_a]("progress", progress, false)
        }
        if (change) {
          xhr.onreadystatechange = change
        }
        // ------------------------------------------------------------ MIME
        if (mime) {
          xhr.overrideMimeType(mime)
        }
        // ------------------------------------------------------------ SEND

        xhr.send(reqdata)
      }
    }
  }

var jsonpStamp = 0

ajax.jsonp = function( url, success, error, context, cbName ) {

  if( !cbName || cbName === true ) cbName = 'callback'

  var name = '_jsonp_' + jsonpStamp++
    , script = document.createElement('script')
  
  if (url.match(/\?/)) 
  { 
    url += '&'+cbName+'='+name
  }
  else 
  {
    url += '?'+cbName+'='+name
  }
  
  script.type = 'text/javascript'
  script.src = url
  
  if(error) {
    script.onerror = function( e ) {
      error( e )
    }
  }

  window[name] = function(data){
    success.call(( context || window ), data)
    document.getElementsByTagName('head')[0].removeChild(script)
    script = null
    delete window[name]
  }
  
  document.getElementsByTagName('head')[0].appendChild(script)

}

var enCode = ajax.encode = function(data, method, encode) {
  var result = ''

  if(encode === 'json'){
    result = JSON.stringify(data)
  } else if(data instanceof Object) {
    if (!util.isNode && (window.FormData && data instanceof FormData) && method !== 'GET') {
      result = data
    } else if (data instanceof Array) {
      result = JSON.stringify(data[f])
      if(encode === 'uri') result = encodeURIComponent(result)
    } else {
      for (var f in data) {
        var val = data[f]
        if(val instanceof Object) val = JSON.stringify(val)
        if(encode === 'uri'){
          f = encodeURIComponent(f)
          val = encodeURIComponent(val)
        }
        result += f + '=' + val + '&'
      }
      result = result.slice(0, -1)

    }
  } else {
    result = (encode === 'uri') ? encodeURIComponent(data) : data
  }
  // console.log('encoded:', result)
  return result
}
},{"../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/authenticate.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var util = require('../../../util')

exports.extend = util.extend(extend)

function extend(Cloud) {
  util.define( Cloud
  , 'authenticate', function authenticate(req, cb, re){
      window.authrequest = req
      var cloud = this

      if(typeof req === 'function')
        req = req()

      if(!req)
        return cloud.socket.removeListener('connect', reAuth)

      cloud.emit('authenticate', req, function(res){
        if(res.hop)
          cloud.hop(res.hop)
        else if(cb)
          cb(res)
      })
     
      if(!re){
        cloud.on('connect', reAuth)
      }

      function reAuth(){
        console.error('connect ->>> reAuth?')
        if(cloud._status > 2){
          console.error('reconnect ->>> reAuth!', req)
          cloud.authenticate(req, cb, true)
        }
      }
      cloud._reAuth = reAuth
    }
  , 'logout', function logout(userid){
      var cloud = this

      cloud.emit('logout', userid)

      if(
        cloud.data.users[userid] && 
         cloud.data.users[userid].activeClient 
         && cloud.data.users[userid].activeClient.from._name === cloud.clientid
       ) 
       {
         cloud.data.users[userid].activeClient.remove()
       }

      
      var stamp = cloud.stamp

      if(userid){
        if(cloud.data.users[userid])

        if( 
          cloud.data.users[userid].activeClient 
          && cloud.data.users[userid].activeClient.from._name === cloud.clientid) 
        {
          cloud.data.users[userid].activeClient.from = cloud.data.users[userid].activeClient
        }

        cloud.data.users[userid].remove(void 0, void 0, void 0, void 0, stamp)
        // else
        //   console.error('that user does not exist')
      } else{
        cloud.data.users.each(function(userid){
          this.remove(void 0, void 0, void 0, void 0, stamp)
        })
      }

      cloud.socket.removeListener('connect', cloud._reAuth)
      cloud._reAuth = null

    }
  )
}
},{"../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var util = require( '../../../util' )
  , NetworkData = require( '../data' )
    .inject( require( '../../../object/hashpath' ) )
    //TODO: add localstorage --> , !util.isNode && require('../../../object/localstorage')
  , networkDataElement = require( '../data/element' )
  , Data = require( '../../../data' )
  , preventUpdate
  , vObject = require( '../../../object' )
  , monoStamp = require( 'monotonic-timestamp' )
  , CloudData = NetworkData.new
    ( false //put some settings!
    , function CloudData( val, hook, parent, cloud ) {
        var _this = this

        if( cloud )
        {
          _this.cloud = cloud
          _this.addListener(cdListener)

          if(!util.isNode && !!window.cordova) 
          {

            document.addEventListener('pause', function() {
              //TODO: this does not work yet -- make prevent update a usable thing in app logic ( e.g. in device lists or clients )
              _this.preventUpdate = true
            }, false)

            document.addEventListener('resume', function() {
              
              cloud.kickPing()

              if( _this.timeout )
              {
                clearTimeout( _this.timeout )
              }

              _this.timeout = setTimeout( function() {
                if( _this.defered ) 
                {
                  _this.merge( _this.defered.data, false, _this.defered.stamp )
                }
                _this.preventUpdate = null
                _this.defered = null
                _this.timeout = null
              }, 100 )
              // _this.preventUpdate = true //wait for another update and timeout
            }, false)
          }

          cloud.on
          ( 'set'
          , function( data ) {
 
            // console.clear()
            
            // console.group()
            // console.log('\n-----------INCOMING CLOUD-------\n', data )

            // if()

            // console.log(JSON.stringify(data, false, 2).slice(0,200))
            // console.groupCollapsed()
            // console.log(JSON.stringify(data, false, 2))
            // console.groupEnd()
              // console.log('INCOMING!\n', JSON.stringify(data))
              var set = data.s
                , vclock = data.v
                // , stamps = vclock[1]
                , subs = cloud.state.subs.map
                , substamp = vclock[1]

              if( vclock[0] instanceof Array )
              {

                //vclock where is it??????

                for( var i = vclock[0].length; hash = vclock[0][--i]; )
                {
                  updateSub( subs[hash], substamp )
                }

              }
              else
              {
                updateSub( subs[data.v[0]], substamp )
              }

              // substamp = 0

              // for( var s in stamps )
              // {
              //   console.log('burrr', stamps[s])
              //   if( stamps[s] > stamp ) stamp = stamps[s]
              // }

              var stamp = monoStamp()
              cloud.stamp = stamp

              // _this._time

              if( !_this.preventUpdate ) 
              {
                _this.merge( data.s, false, stamp )
              } 
              else
              {
                if(!_this.defered)
                {
                  //pause geen timeout alleen maar uitstellen
                  _this.defered = 
                  { data: data.s
                  , stamp: stamp
                  }
                }
                else 
                {
                  _this.defered.stamp = stamp
                  _this.defered.data = util.merge( _this.defered.data, data.s)
                  // _this.defered.data._update( data.s )

                }
              }

            }
          )

        }
        else if( parent )
        {
          _this.cloud = parent.cloud
        }

      }
    )
  , __update

module.exports = CloudData

function updateSub( cached, vclock ) {
  if( !cached ) return

  return // not implemented

  // var sub = cached.subsobj
  // if( !sub._v ) sub.set( '_v', {} )

  // for( var f in vclock )
  // {
  //   sub._v.set( f, vclock[f] )
  // }

}

function createSub( path, sub, partialSub ) {

  if( path.length )
  {
    util.path( sub, path, partialSub, true )
    return sub
  }
  else
  {
    return partialSub
  }

}

function t4walker( val ) {
//TODO: remove $t:4
  for( var i in val )
  {

    if(val[i] instanceof Object)
    {

      if(val[i] instanceof vObject)
      {
        val[i] = { $path: val[i]._path } // $t: 4 
      }
      else
      {
        t4walker( val[i] )
      }

    }

  }

}

function cdListener( val, stamp, from, remove, added, old ){
  var cloud = this.cloud
  // console.log('OOOO cloudata listenerbur', this._path, val)
  if( stamp === 'localStorage' || stamp===false  )
  {
    // console.log('I WILL NOT UPDATE'.red.inverse)
    // console.log('Cloud from localstorage'.inverse.red)
    return
  }


  if( stamp !== cloud.stamp && val !== void 0 )
  {

    // console.log('>>>>>> shiner')

    // console.log('\n\n\n\n\nupdate cloud', val)



    if( remove && from )
    {
      if( from._removed )
      {
          // console.log('!!!!!!UPDATE CLOUD!!!', from && from._path, val, stamp)

        cloud.set(from._hashpath, [from._path, null, cloud.timeStamp()])
      }

    }
    else if ( from && !this._cloudignore )
    {


      // if( stamp === void 0 ) {
      //   alert('X')
      // }

      // console.log( 'cccccccccccc update!', this._path , from._updateOrigin, from._cachedPath)

      // console.error('_update Origin call from cloud.data') 
      if( from._updateOrigin === from ) //hier gaat iets mis
      {
        if( from.__t === 2 && val instanceof Object ) {
//           console.log(from, val)
          t4walker(val)
        }


        //["users", "U_fe7cc800136b7608", "clients", "V_kuco2zs2qf"]
        var p = from&&from._path
        if(p && p[0] === 'users' && p[p.length-2] && p[p.length-2] === 'clients' ) {
          //TODO: very dirty fix!
          // console.error('break it down!', p, p, val )
          return
        }

        if(p && p[0] === 'users' && p[1] === 'media') {
          throw(new Error('THIS IS WRONG ABORT!---> setting users.media '+p.join('.')))
          // console.error('THIS IS WRONG ABORT!---> setting users.media', p)
          return
        }


        cloud.set
        ( from._hashpath
        , [ from._path
          , from.__t === 4 ? {  $path: val._path } : val //$t: 4,
          , cloud.timeStamp()
          ]
        )

      }

    }

  }

}

CloudData.prototype._blacklist.push('cloud', 'datacloud', '_batchUnsub','_cloudignore', '_lstamp', '$t', '$loaded', '_fromlfrom')

__update = CloudData.prototype.__update

CloudData.inject( require('vigour-js/object/flags') )

CloudData.flags.$path = {
  reset:true,
  set: function(val, stamp, reset) {
    
    if( reset ) {
      throw new Error('cloud data $path flag reset???')
    }
  
    var t = this
    if(stamp !== this.cloud.stamp) {
      throw new Error('set with $path only allowed from the hub')
    }

    var path = util.changeType( val )
    if(path.length){
      // console.log('___________ $path set')
       // val, set, notself, stamp 
       // noupdate
      this._$setVal( this.cloud.data.get( path, {}, void 0, stamp ) ,stamp,false,true)
    }

    if(this.__t!==4) {
      throw new Error('cloud data $path flag __t !== 4')
    }

  }
}


var _set = CloudData.prototype.set

var _$setVal = CloudData.prototype._$setVal

//CloudData add flags

//( name, val, vobj, stamp, noupdate, from )
util.define
( CloudData
, '_$setVal', function( val, stamp ) {
   //setVal

   // console.log('.............', this._path, stamp, stamp && this.cloud.stamp === stamp)
   if(this.cloud.stamp === stamp && !this.$loaded) {
    //TODO: faster to do ! loaded
    var parent = this
    while(parent && !parent.$loaded) {
      parent.$loaded = true
      parent = parent._parent
    }
   }

   _$setVal.apply( this, arguments )
  }
, 'set', function(name, val, vobj, stamp){
  if (stamp !== this.cloud.stamp &&
      this._name === 'clients' &&
      !this[name] && 
      name !== this.cloud.clientid
     ) {
    console.error('\n\nI WANT TO BLOCK THIS YA DURK',
      '\nstamp !== this.cloud.stamp', stamp !== this.cloud.stamp,
      "\nthis._name === 'clients'", this._name === 'clients',
      "\n!this[name]", !this[name],
      "\nname !== this.cloud.clientid", name !== this.cloud.clientid
    )
    debugger
    // return false
  }
  return _set.apply(this, arguments)
}
, 'updateQueue'
, function() {
    // why this???
  }
, 'stamp'
, function(){
    if( !this.cloud ) {
      console.error( 'WAT NO CLOUD?! in this:\n', this )
      return
    }
    return this.cloud.timeStamp()
  }
, '__update'
, function( val, stamp, from, remove, added, oldval ) {

    // if(stamp && this._lstamp === stamp) return


    // console.log(from, '\n', this._lfrom, from, from&&from._lfrom._cachedPath, this._cachedPath, this._lfrom)
    if(from && from._lfrom) {

      this._fromlfrom = from._lfrom
      // console.error(this._fromlfrom)
      // return
    }

    if(this._fromlfrom && this._fromlfrom === (from && from._lfrom) && this._lstamp===stamp) {
      //TODO: this is a memory leak get rid of it circ refs should be resolved from vobj itself
      delete this._fromlfrom
      return
    }

    this._lstamp = stamp

    // if(this._path[0]==='clients') {
    //   console.log('2', this._path, stamp===this.cloud.stamp)
    // }
    // console.log('1 lets __update', this._path, arguments)
    // if( this._ignore  ) {
      // console.log('21 lets __update', this._path, arguments)
      // delete this._ignore
      // return false
    // }
    //most nested update hier addition maken voor process
    // console.log(val, stamp, from)
    //is dit maybe weird???
    return __update.call( this, val, stamp, from, remove, added, oldval )
  }
, '_set'
, function (val, stamp) {
    if( !stamp ) return
    if( this._lstamp > stamp )
    {
      return
    }
    // console.log('lets set it!!!', this._path, arguments)

    return NetworkData.prototype._set.apply( this,arguments )
  }
, 'subscribe'
, function( val, from, parentFixer ) {
              // console.log('start')

    if( from && from.cloud  && from._val === this ) {

        //BUG: dit kan heel veel broken maken!!!!!!!
//         console.log('\n\nHURK!!!!!! DIT IS TEMP MOET NIET EEN EXTRA SUB GEMAAKT WORDEN!' )

        // from = void 0

        //TODO: dit is helemaal wrong GET RID OF IT!!!!
        // return
    }

    // console.log( 'lets do it sub sub'.cyan.inverse, this, val, from, parentFixer )
    // if(from) {
      // console.log('GOT FROM', from , 'SUBSCRIBE')
    // }
     if (!val || typeof val === 'function') { return; }
     // if(val instanceof vObject) {
     //    val = val.from
     // }


     var path = this._path
       , elem = val[1]
       , sub
       , partialSub
       , stringified
       , subsArray
       , exists
       , listeners
       , fromName

      var found = path && util.checkArray( path , 'usage' )
    


    // if( found || found===0) {
            // console.log('lets try to sub', val && val._path, ':', this._path )
      // }
   

    // if(elem) {
    //   console.error(elem, elem._col, elem._dfrom, elem._fmodel)
    // }

    // console.log('SUBSCRIBE', elem._dfrom, elem._fmodel, 'DFROM, FMODEL!')

    // if (elem && !elem._col && (!elem._dfrom || elem._fmodel)) {
    var isElem = (elem && !elem._col && (!elem._dfrom || elem._fmodel))

    if( isElem && !elem.getModel) {
      // console.error('be carefull! cloud data elem does not have getModel')
    } else if( isElem ) {

      // console.error('XXX!')
      //hier dingen vinden voor
      // console.log('!DFROM!')

    //isElem

    //val, from, parentFixer

    // if(val[3] && val[3] instanceof Array) {
    //       console.log( 'YES!!!' )

    // }

          // console.log( '!!!!!!111111', arguments, val[3], from, parentFixer, this, path )

    var fieldignore
    if( val[1]._ignoreFieldInSubscription ) {
      // alert('!'+val[3])
      if(!val[3]) {
        // console.log('FIELDIGNORE'.blue.inverse, val, this, path )
        // debugger

        // if(fi)

        fieldignore = true
      }
    }

    //TODO: has to become val[2]!!!
    //typeof from === 'string' ? from :
      //dit is niet goed!!!!
      fromName = val[3]

    // console.log( '--------22!!!!!!111111', partialSub, val[3], '\n\n?', val[3]._name  )

      //val[3] instanceof Data
      partialSub = elem.getModel( this,  val[3] , fieldignore )
      // console.clear()
    // console.log( '----!!!!!!111111', partialSub )
      // if(partialSub && partialSub.specialFix) {
      //   console.log('LETS DO IT ITI IT', partialSub, partialSub.specialFix, path)
        
      //   // if(partialSub.specialFix instanceof Array ) {

      //   //   console.log( path, partialSub.specialFix, partialSub )
      //   //   if(path[path.length-1] === partialSub.specialFix[0]) {

      //   //     if(partialSub.$ && partialSub.$[partialSub.specialFix[1]]) {
      //   //         console.log('do it!')
      //   //         partialSub = partialSub.$[partialSub.specialFix[1]]
      //   //     }

      //   //   }

      //   // } else 

      //   if(path[path.length-1]===partialSub.specialFix) {
      //     path.pop()
      //   }
        
      //   delete partialSub.specialFix
      // }

      // console.log('LETS DO IT ITI IT'.green.inverse, partialSub)

      // partialSub.DEBUG$log('partial')

    } else if (val instanceof Data && val.__sub) {
    //isData+Subscription
      //dit moet ook gefixed!!!!!!!!!
      partialSub = networkDataElement.parseData(val)

    } else if (val instanceof vObject ) {
    //vObject
      listeners = val._listeners

      // console.log(this._path, 'LISTENER', from )

      if(listeners) {
        for( var listener$=0, len$=listeners.length; listener$<len$; listener$++ ) {
                // console.log('!!!!!!!!!!! listner$333333'.red.inverse, listeners[listener$])
                  // console.log('--------->',this._path, 'LISTENER, ' , listeners[listener$]._path, val)
          this.subscribe( listeners[listener$], val )
        }
      }

      // if(val._parent && !val._parent.cloud) {
        // console.log('parent',val._parent, val._parent._listeners)
      //   listeners = val._parent._listeners

      //   // val._pa
      //   if(listeners) {
      //     for (var listener$=0, len$=listeners.length; listener$<len$; listener$++) {
      //       this.subscribe(listeners[listener$], false, true)
      //     }
      //   }
      // }

      return;
    } else if (val && util.isObj(val) && !(val instanceof Array)) {
      //isNormalSubscription
      // console.log('IS OBJ'.cyan)
      partialSub = val
      val = JSON.stringify(val)
    }

    if (partialSub) {

     //if! empty
     // console.log('2 LETS DO IT ITI IT 2',this , path, 'from:', from, 'sub:', networkDataElement.parseData(from, partialSub, this._subs ) )

     var fromCheck
     if(from) partialSub = networkDataElement.parseData(from, partialSub, this._subs)
      //de check moet nu in from gebeuren
      // console.log('.subscribe cloud.data partialSub are we sure this is from a ref in the cloud'.blue.inverse, partialSub, path) //replace /w from

      if(from && from.cloud && from._val === this) {
        path = from._path //if from is cloud
        // alert('!')
        fromCheck = true
        // console.warn('do nothing prop from cloud', from)
      }

     sub = createSub(path, {}, partialSub)
     stringified = JSON.stringify(sub)

     var substarget =  fromCheck ? from : this

     if(!substarget._subs) substarget._subs = []
     if(elem) elem._subscribed = true
     // console.log('3LETS DO IT ITI IT 3'.red.inverse, networkDataElement.parseData(from, partialSub) )

      subsArray = [ partialSub, elem || val , stringified ]

      if(fromName) {
        subsArray.push(fromName)
      }

      exists = util.checkArray( substarget._subs, stringified, 2)
      //maybe check if val already exists
      // console.log(' TEST TRUE ----- SUBSCRIBE', from, exists, this._subs, stringified, partialSub, sub )
      //TODO: check if not exists subsArray each field
      // console.log('PUSH! SUBS'.green.inverse, subsArray ,stringified, exists )
      var same
      for(var i in substarget._subs ) {

        // console.log(substarget._subs[i], i, substarget._path)
        //compare objects

        if( substarget._subs[i][1] === (elem || val) && substarget._subs[i][2] === stringified ) {
          //distincation!!!!
          // console.log('THE SAME'.cyan.inverse)
          same = true
        }

      }

      if(!same) {
      substarget._subs.push( subsArray )
        //just dont subscribe ---
        if ( exists===false ) {

          // console.log(' TRUE ----- SUBSCRIBE', JSON.stringify(sub,false,2) )
          this.cloud.subscribe(sub, stringified)
        }
        else {
          // console.warn('ALLREADY EXISTS!', sub, stringified)
        }
      }
    }

  }
, 'unsubscribe'
, function( val, from ) {

    //todo: double check if this goes well
    // console.error('1unsubscribe!')

    //doundle remove

    if 
    ( !val
      || val._col
      || (val._filter && val._filter._col)
      || !(!val._dfrom || val._fmodel)
    ) 
    { 
      return 
    }

     var path = this._path
       , stringified
       , subsArray
       , sub
       , exists
       , partialSub
       , index
       , field
       , listeners = val._listeners

    // console.log('unsubscriblex','path:'.blue, path, 'stringified:'.blue,  sub, 'this:'.blue,this, 'val:'.blue, val, 'from:',from )

    if ( util.isObj( val ) && !( val instanceof Array ) ) val = JSON.stringify( val )

    index = this._subs && util.checkArray( this._subs, val, 1 )
    //niet alle 1's weghalen

        // console.log('unsubs??????'.red.inverse, util.clone(this._subs), val, index, this )
        //missing index!


    if ( index!==false && index !== void 0 ) {




      if(val.model && val.model.parsing) {

        // console.log('MODEL unsubs??????'.red.inverse)
        // var removeI

        //block unsubs on model parsing
        if(val.model && val.model.field ) {
          // console.clear()
          // console.log('WARN! unsubs field WARN!'.red.inverse, from, this._subs[index] )

          //reapply if field
          field = this.get(val.model.field.val)
          if(!field._subs) field._subs = []

          // console.log('WARN! unsubs field WARN!'.red.inverse,field===this, field, from, this._subs[index] )


          var __subs = util
            .get( this._subs[index][0], val.model.field.val )

            // console.log( 'subs[0]'.blue,  this._subs[index][0] )

          if( __subs ) {
          this._subs[index][0] = __subs
          // field._subs.push(this._subs[index])
          // console.log('REMOVE SUBS and push'.red.inverse, index,field._subs, __subs, this._subs[index], this._path)
          // debugger
          // this._subs.splice(index, 1)
        } else {
          // console.log('warn'.red)

        }
          // console.log( __subs )


         
          //dit ff beter doen (meerdere _subs)
          //tel counts
          
          //voor deze splice check op index en stringified!

         
        }

        return
      }

      subsArray = this._subs[index]
      stringified = subsArray[2]
      partialSub = subsArray[0]
      // if(from) partialSub = networkDataElement.parseData(from, partialSub)

      // console.log( 'partialSub'.inverse, partialSub )

      sub = createSub(path, {}, partialSub)

      //voor deze splice check op index en stringified!
      //kan dus ook efficienter
      // if( removeI !== void 0 ) {
        // console.log('REMOVE', index)
         // console.log('REMOVE SUBS'.red.inverse, index, this._subs, this._path )
          // debugger
        this._subs.splice(index, 1)

      // }



      exists = util.checkArray(this._subs, stringified, 2)

      if(exists!==false) {
        // console.log('EXISTS????'.cyan.inverse, exists, stringified, this._subs, this._path, this)
      } else {
        // console.log('!EXISTS' , exists, stringified)
      }

      if ( exists === false ) this.cloud.unsubscribe(sub, stringified)
        // this._subsRAF.push([sub, stringified])
        // this._subsRAF = [] search & remove use different identifiers e.g. subs array

    } else if( val._removed ) {

            // console.log('unsubs??22222???? 2222222'.red.inverse)

      // console.error('is this really nessecary? _removed , froce all listeners remove tagets etc')
    } else if(listeners) {

                  // console.log('unsubs??333333333???? 2222222'.red.inverse)

      // console.log('----> this is also pretty different! _listeners')
      for (var listener$=0, len$=listeners.length; listener$<len$; listener$++) {
        if (listeners[listener$] instanceof Array) {
          this.unsubscribe(listeners[listener$][1], val)
        } else if (listeners[listener$].__t) {
          this.unsubscribe(listeners[listener$], val)
        }
      }
      return
    }

  }
)

},{"../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../object/hashpath":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/hashpath.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/index.js","../data/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/element.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js","vigour-js/object/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/datacloud.js":[function(require,module,exports){
module.exports = DataCloud

var timestamp = require('monotonic-timestamp'),
  util = require('../../../util/object'),
  CloudData = require('./data'),
  VObject = require('../../../object'),
  Batch = VObject.new({
    merge: true
  }),
  CloudState = VObject.new({
    merge: true
  }),
  makeHash = require('../../../util/hash'),
  batchtime = 20,
  SUBS = 'subs',
  SETS = 'sets',
  UNSUBS = 'unsubs'

function DataCloud () {
  // window.datacloud = this
  var cloud = this
  cloud._joins = {}
  cloud._status = 1

  cloud.on('connect', function () {
    // console.error('---- cloud connect >> cloud._status++ call _reconnect')
    cloud._status++
    cloud._reconnect()
  })

  // console.log('start making state')
  cloud.state = new CloudState({
        subs: {
          map: {},
          tree: {}
        },
        sets: {
          map: {} /*, list:[]*/
        }
      }
      // , { localstorage: 'VC$' }
    )
    // console.log('done making state', JSON.stringify(cloud.state.raw,false,2))

  if (!cloud.state.sets.list) cloud.state.sets.set('list', [])
    // ^^ set met lege array merged niet

  cloud.batch = {
    maps: {
      sets: {},
      subs: {},
      unsubs: {}
    }
  }

  // console.log('------SET C DATA')

  cloud.data = new CloudData({}, false //{localstorage:'cloudData'}
    , false, this)

  // console.log('------LOG')


  // console.log(JSON.stringify( cloud.data.raw,false,2))
  // ^^ dit kan door weirde shit in localStorage de constructor laten kappen!

  // cloud.on('incoming::pong', this._clearCache)
  // cloud.on('data', this._clearCache)

  cloud._qTimer = setInterval(function _qTimer () {
    cloud._doBatch()
  }, batchtime)


  // cloud.on('welcome', function onWelcome(){

  // })

  cloud.on('subscribed', function (msg) {
    // console.error('>>> Hey Cloud says im subscribed to', msg)
  })

}

DataCloud.prototype.timeSync = function timeSync () {
  // console.log('timeSync!')
  var cloud = this,
    outstamp = Date.now()
  cloud.emit('time', function (cloudstamp) {

    var traveltime = Date.now() - outstamp,
      arrival = outstamp + traveltime / 2,
      offset = cloudstamp - arrival
      // console.log('timestamp in', traveltime, 'offset', offset)
    if (traveltime < cloud._timeTravel) {
      cloud._timeTravel = traveltime
      cloud._timeOffset = offset
    }
    var tries = cloud._timeTries++
      if (traveltime > 75 && tries < 10 || traveltime > 50 && tries < 5 || traveltime > 20 && tries < 2) {
        cloud.timeSync()
      }
  })
}

DataCloud.prototype.outList = function (label) {
  var batch = this.batch
  if (!batch.lists) {
    batch.lists = {}
    return batch.lists[label] = []
  } else if (!batch.lists[label]) {
    return batch.lists[label] = []
  } else {
    return batch.lists[label]
  }
}

DataCloud.prototype._doBatch = function _doBatch () {
  var cloud = this,
    out = cloud.batch.lists

  if (out) {
    // console.log('emit dat batch out!')
    // console.log('EMITTING!',out)
    // if(typeof window !== 'undefined'){
    //   console.log('writing out', JSON.stringify(out).slice(0,50))
    //   console.groupCollapsed()
    //   console.log(JSON.stringify(out,false,2))
    //   console.groupEnd()
    // }
    cloud.emit('batch', out)
      // cloud.write(out)
      // cache sets untill next heartbeat
      // var setslist = out.sets
      // if(setslist) {
      //   var cache = cloud.state.sets
      //     , setsmap = cloud.batch.maps.sets

    //   for(var hash in setsmap) {
    //     var update = setsmap[hash].update
    //     if(update[1] === null)
    //       update[1] = '$$null'
    //     storeSet(hash, update, cache.list, cache.map)
    //   }
    // }
    cloud.batch.lists = null
    cloud.batch.maps = {
      subs: {},
      sets: {},
      unsubs: {}
    }
  }
}

DataCloud.prototype._clearCache = function _clearCache () {
  // if(this.state.sets.list.length){
  //   this.state.sets.remove()
  //   this.state.set('sets', {map:{},list:[]})
  // }
  // could be nicer if we have a good way of clearing arrays
}

DataCloud.prototype.subscribe = function subscribe (subsobj, str) {
  // console.log('subscribe!', str)
  var cloud = this,
    state = cloud.state,
    hash, cached

  if (subsobj.hash && subsobj.subsobj) {
    // console.log('das cached!')
    hash = subsobj.hash
    cached = subsobj
  } else {
    if (!str)
      str = JSON.stringify(subsobj)
    hash = makeHash(str)
    cached = state.subs.map[hash]
  }
  // console.log('hash', hash)


  if (!cached) { // place in tree

    // console.log('set active!')

    state.subs.map.set(hash, {
      hash: hash,
      subsobj: subsobj,
      active: cloud._status,
      cleared: false
    })
    cached = state.subs.map[hash]
    var tree = state.subs.tree
    insertLeaf(tree, cached.subsobj, cached)
  } else if (!cached.active || cached.active._val) {
    // console.warn('subscription already active!', cached, cached.active)
    return
  } else {
    cached.active.val = cloud._status
  }

  var unsubsmap = cloud.batch.maps.unsubs,
    unsubindex = unsubsmap[hash]

  if (unsubindex !== void 0) {
    cloud.cancel(hash, unsubindex, UNSUBS)
    return
  }

  var subslist = cloud.outList(SUBS),
    subsmap = cloud.batch.maps.subs,
    out

  if (!cached.cleared._val) {
    cached.cleared.val = cloud._status
    var depends = cloud.getDeps(state.subs.tree, cached.subsobj, cached, {})
    if (!util.empty(depends)) {
      out = {
        $subsobj: cached.subsobj.raw,
        $depends: depends
      }
    } else {
      out = cached.subsobj.raw
    }
  } else {
    out = cached.subsobj.raw
    cached.cleared.val = cloud._status
  }

  subsmap[hash] = subslist.length
  subslist.push(out)
}

DataCloud.prototype.getDeps = function getDeps (tree, walker, cached, list) {
  walker.each(function (f) {
    var branch = tree[f]
    if (branch) {
      if (branch._subs) {
        branch._subs.each(function (i) {
          var found = this._val
          if (found.subsobj._v && found.hash._val !== cached.hash._val && !found.cleared._val && !list[found.hash._val]) {
            found.cleared.val = cached.cleared._val
            list[found.hash._val] = found.subsobj.raw
          }
        })
      }
      getDeps(branch, walker[f], cached, list)
    }
  })
  return list
}

DataCloud.prototype.unsubscribe = function unsubscribe (subsobj, str) {
  // still do
  var cloud = this
  // console.error('unsubscribe!', subsobj)
  if (subsobj instanceof Array) {
    // console.log('unsub with array', subsobj)
    var tree = cloud.state.subs.tree,
      spot = tree.get(subsobj)

    if (spot) {
      // console.log('OK UNSUBSCRIBE TO THIS CRAP', spot)
      recurUnsub(cloud, spot, str)
    }
  } else {

    var batchmap = cloud.batch.maps.subs,
      hash,
      cached

    if (subsobj.hash) {
      hash = subsobj.hash.val
      cached = subsobj
    } else {
      if (!str) {
        str = JSON.stringify(subsobj)
      }
      hash = makeHash(str)

      var statemap = cloud.state.subs.map

      cached = statemap[hash]
    }

    var index = batchmap[hash]

    if (index !== void 0) {
      cloud.cancel(hash, index, SUBS)

    } else {
      var list = cloud.outList('unsubs')
      cloud.batch.maps.unsubs[hash] = list.length
      list.push(hash)
    }

    cached.active.val = false
  }

}

function recurUnsub (cloud, spot, clear) {
  // console.log('recurUnsub!', spot._path)
  spot.each(function (f) {
    if (this._subs) {
      this._subs.each(function () {
        // console.log('unsub on this!', this.raw, 'clear?', clear)
        if (clear && this.from.subsobj._v) {
          this.from.subsobj._v.remove()
        }
        cloud.unsubscribe(this.from)
      })
    }
    if (f !== '_subs') {
      recurUnsub(cloud, this, clear)
    }
  })
}

DataCloud.prototype.cancel = function cancel (hash, index, label) {
  var batch = this.batch,
    list = batch.lists[label]
  removeIndex(list, index)
  if (!list.length) {
    delete batch.lists[label]
    if (util.empty(batch.lists)) {
      delete batch.lists
    }
  }
  var map = batch.maps[label]
  delete map[hash]
  for (hash in map)
    if (map[hash] > index) {
      map[hash] --
    }
}

DataCloud.prototype.set = function set (hash, update) {

  // console.log('SET CLOUD!')

  if (!update[0].length) {
    // console.error('EMPTY PATH', update)
  }

  var cloud = this,
    list = cloud.outList(SETS),
    map = cloud.batch.maps.sets

  storeSet(hash, update, list, map)
}

function storeSet (hash, update, list, map) {
  // console.log('storeset?!')
  var V = list.__t,
    stored = map[hash]

  if (stored) {
    var val = update[1],
      ts = update[2],
      oldval = stored.update[1]

    if (V) oldval = oldval.raw

    if (val instanceof Object && oldval instanceof Object && !(val.$path) && !(oldval.$path)) {
      if (!V) oldval = util.clone(oldval)
      val = util.merge(oldval, val)
    }

    if (V) {
      stored.update.set(1, val)
      stored.update.set(2, ts)
    } else {
      stored.update[1] = val
      stored.update[2] = ts
    }

    if (!V) {
      var i = stored.i,
        end = list.length - 1
      if (i !== end) {
        moveToEnd(list, i)
        for (var maphash in map) {
          if (map[maphash].i >= i) map[maphash].i--
        }
        stored.i = end
      }
    }
  } else {
    var setobj = {
      update: update,
      i: list.length
    }
    if (V) {
      map.set(hash, setobj)
    } else {
      map[hash] = setobj
    }

    stored = map[hash]
    list.push(stored.update)
  }
}

DataCloud.prototype._reconnect = function _reconnect () {

  // alert('(RE)CONNECT!')
  // console.error('------------- (RE)CONNECT!')

  var cloud = this,
    state = cloud.state,
    subs = state.subs.map

  cloud._timeTries = 0
  cloud._timeTravel = Infinity
  cloud.timeSync()

  // clean data
  cloud.stamp = 'cleanup'
  if (cloud.data.clients) {
    var myclient = cloud.data.clients[cloud.clientid]

    if(myclient) {
      myclient = myclient.raw
      delete myclient.key
      delete myclient.type
      delete myclient.ip
      delete myclient.token
    }

    cloud.data.set('clients', {
      clear: true
    }, void 0, cloud.stamp)

    // TODO: put all cloud.client logic in one place
    if(cloud.clientid && cloud.client) {
      cloud.client.val = cloud.data.clients.get(cloud.clientid, {})
      if(myclient) {
        cloud.client.from.val = myclient
      }
    }
  }

  if (cloud.data.users) {
    cloud.data.users.each(function () {
      // console.log('CLEAN CLOUD: clean usrt!!', this._name)

      this.set('clients', {
        clear: true
      }, void 0, cloud.stamp)

      // CLEAN MAINSCREEN AND ACTIVE CLIENT?!

      // this.mainscreen.set('clientRef', false, void 0, cloud.stamp)
      // this.mainscreen.clientRef.remove(void 0, void 0, void 0, void 0, cloud.stamp)

      // this.activeClient.remove(void 0, void 0, void 0, void 0, cloud.stamp)

    })
  }

  // if(sets.length){
  //   sets.sort(byTs)
  //   for(var i = 0, set ; set = sets[i++];){
  //     if(set[1] === '$$null')
  //       set[1] = null
  //   }
  //   cloud.write({sets:sets})
  //   // would be nicer to insert them into current batch
  // }

  var resubs = []
  subs.each(function (f) {
    // console.log('resub?', f)
    var cached = this,
      active = cached.active,
      cleared = cached.cleared

    if (active._val === 1) {
      active.val = true
      cleared.val = true
    } else if (active._val) {
      // active._val = false

      active.val = false
      // dit wordt niet in ls opgelsagen

      if (cleared._val === 1) {
        cleared.val = true
      } else if (cleared._val) {
        cleared.val = false
      }
      resubs.push(cached)
    } else if (cleared._val) {
      if (cleared._val === 1) {
        cleared.val = true
      } else {
        cleared.val = false
      }
    }

  })
  for (var i = 0, resub; resub = resubs[i]; i++) {
    // console.error('resubscribe!!', resub.subsobj.raw)
    cloud.subscribe(resub)
  }
  // console.error('done resubscribin')

  for (var j in cloud._joins) {
    cloud.join(cloud._joins[j], true)
  }

}

DataCloud.prototype.timeStamp = function () {
  var ts = timestamp()
  if (this._timeOffset) {
    ts += this._timeOffset
  }
  return ts
}

function insertLeaf (tree, subsobj, cached) {
  subsobj.each(function (f) {
    if (f === '*') {
      if (!tree.$) {
        tree.set('$', {})
      }
      subsobj['*'].each(function (s) {
        subsobj['*'][s][1].each(function (ss) {
          insertLeaf(tree.$, subsobj['*'][s][1][ss], cached)
        })
      })
      return
    }
    if (!tree[f]) {
      tree.set(f, {})
    }
    if (subsobj[f].val === true) {
      if (!tree[f]._subs) {
        tree[f].set('_subs', [cached])
      } else {
        tree[f]._subs.push(cached)
      }
    } else {
      insertLeaf(tree[f], subsobj[f], cached)
    }
  })
}

function moveToEnd (arr, i) {
  var tmp = arr[i]
  while (arr[i + 1]) {
    arr[i] = arr[++i]
  }
  arr[i] = tmp
}

function removeIndex (arr, i) {
  while (arr[i + 1]) {
    arr[i] = arr[++i]
  }
  arr.pop()
}

// function byTs (a, b) {
//   return a[2] - b[2]
// }

},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../../util/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js","./data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/data.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js":[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var util = require('../../../util'),
  io = util.isNode 
    ? require('socket.io-client') 
    : require('./socket.io.min.js'),
  G = require('../../../util/global'),
  id = require('../../../util/id'),
  urlEncode = require('../ajax').encode,
  VObject = require('../../../object'),
  Value = require('../../../value'),
  Emitter = require('./emitter')

var Cloud = module.exports = function Cloud (url, params) {
  
  if (!params) {
    params = {}
  }

  var cloud = this
  cloud.params = params
  cloud.url = url
  cloud.VID = params.VID = fixVID(params.VID)
    // var HID = params.HID || G.env('HID')
    // if(HID)
    //   cloud.HID = params.HID = HID
  cloud.connected = new Value(false)

  // cloud.connected.addListener(function(){
  //   console.log('connected: state change >', this.val)
  // })

  cloud.api = new Value({
    defer: function (update, args) {
      var type = this.from.__t
      if (type !== 2) {
        throw new Error('cloud.api needs to be an Object')
      }
      update()
    }
  })

  // cloud.api.on(function(){
  //  console.error('lolk cloud.api is set!! on', this.val)
  // })

  if (params.api) {
    cloud.api.val = params.api
  }

  cloud.addDocumentListeners()

  if (url instanceof VObject) {
    var current = url.val
      // console.log('current', current)

    if (current) {
      cloud.init(url, params)
    } else {
      var placeholder = new Emitter()
      placeholder.emit = function () {
        var buffer = cloud.emitbuffer || (cloud.emitbuffer = [])
        buffer.push(arguments)
      }
      placeholder.placeholder = true
      cloud.socket = placeholder
      url.addListener(function (val, p1, p2, p3) {
        // console.log('URL VAL CHANGE', this.val)
        if (this.val) {
          cloud.init(url, params)
        }
      })
    }
  } else {
    // console.log('normal burk just init', url)
    cloud.init(url, params)
  }

}

Cloud.inject = require('../../../util/inject')

Cloud.prototype.addDocumentListeners = function () {
  var cloud = this
  if (!util.isNode && window.cordova) {
    document.addEventListener('resume', function () {
      // console.log('connected: RESUME')
      cloud.connected.val = false
    }, false)
    document.addEventListener('pause', function () {
      // console.log('connected: PAUSE')
      cloud.connected.val = false
    }, false)
  }
}

Cloud.prototype.init = function (url, params) {
  // console.log('CLOUD INIT!')
  var cloud = this,
    socket = cloud.connect(url, params,
      { disconnect: function () {
          log('disconnect')
          cloud.connected.val = false
        },
        connect: function () {
          log('connect')
          cloud.connected.val = true
          socket.io.engine.on('heartbeat', function () {
            cloud.connected.val = true
          })          
        },
        welcome: function (address) {
          log('welcome')
          address = address.split('@')

          var clientid = cloud.clientid = address[0],
            hubid = address[1],
            state = cloud.state

          cloud.hub = params.h = hubid

          cloud.socket.io.uri = fixUrl(cloud.socket.io.uri, params)
        },
        hop: function (newhub) {
          log('hop')
          cloud.hop(newhub)
        },
        err: function (err) {
          log.error(err)
          if (err.type === 'tokenCheck') {
            if (typeof localStorage !== 'undefined') {
              localStorage.removeItem('productionuserToken')
              localStorage.removeItem('userId')
            }
          }
        },
        reconnecting: logger('reconnecting'),
        reconnect_attempt: logger('reconnect_attempt'),
        reconnect: logger('reconnect'),
        reconnect_failed: logger('reconnect_failed')
      }
    )

  var emitbuffer = cloud.emitbuffer
  if (emitbuffer) {
    for (var e in emitbuffer) {
      socket.emit.apply(socket, emitbuffer[e])
    }
    cloud.emitbuffer = null
  }

}

Cloud.prototype.connect = function (url, params, listeners) {

  var cloud = this

  if (!url)
    url = cloud.url
  if (!params)
    params = cloud.params

  if (url instanceof VObject) {
    url = url.val
  }

  url = fixUrl(url, params)

  var oldsocket = cloud.socket

  if (oldsocket && !oldsocket.placeholder) {
    oldsocket.disconnect()
    oldsocket.io.disconnect()
  }

  // console.log('---------- cloud.connect!', url, params)

  var socket = cloud.socket = new io(url, {
    forceNew: true,
    timeout: 5e3
  })

  if (listeners) {
    for (var l in listeners) {
      socket.on(l, listeners[l])
    }
  }

  if (oldsocket) {
    // console.error('------------- transferring old listeners', socket._callbacks)
    passOn(oldsocket, socket)
  }

  // ------- these extentions are only for logging
  // window.cloudmessages = []
  // var _onevent = cloud.socket.onevent
  // cloud.socket.onevent = function (packet) {
  //   window.cloudmessages.push(JSON.stringify(packet.data, false, 2))
  //   console.log('incoming cloud message!', JSON.stringify(packet.data, false, 2))
  //   _onevent.apply(this, arguments)
  // }
  // var _emit = cloud.socket.emit
  // cloud.socket.emit = function (event, data) {
  //   if (typeof data !== 'function') {
  //     console.log('\ncloud.socket.emit:', event, data)
  //     if (event === 'batch') {
  //       if (data.subs) {
  //         for (var s in data.subs) {
  //           if (data.subs[s].mtvData) {
  //             // console.log('\nsubscribin to mtvData!', data.subs[s].mtvData)
  //           }
  //         }
  //       }
  //       if (data.sets) {
  //         for (var s in data.sets) {
  //           // console.error('set:', JSON.stringify(data.sets[s]))
  //         }
  //       }
  //     }
  //   }
  //   _emit.apply(this, arguments)
  // }
  // ------- these extentions are only for logging
  
  return socket

}

Cloud.prototype.hop = function hop (newhub) {

  // console.log('GOT ORDER TO HOP TO', newhub)

  var cloud = this,
    params = cloud.params
    // --------------- dev
  if (newhub.indexOf('@') !== -1)
    cloud.url = 'ws://' + newhub.split('@')[1]
    // --------------- /dev
  cloud.hub = params.h = newhub
  cloud.connect()
}

Cloud.prototype.whenReady = function whenReady (fn) {
  if (this.clientid)
    fn()
  else
    this.once('welcome', fn)
}

Cloud.prototype.kickPing = function kickPing (time) {
  var e = this.socket.io.engine
  e.ping()
  e.onHeartbeat(time || e.pingTimeout)
  e.setPing()
}

Cloud.prototype.disconnect = function disconnect () {
  var socket = this.socket
  if (socket) {
    socket.disconnect()
    socket.io.disconnect()
  }
}

delegateList(Cloud.prototype, 'socket', ['on', 'once', 'emit'])

function delegateList (obj, target, list) {
  for (var i = list.length - 1; i >= 0; i--) {
    delegate(obj, target, list[i])
  }
}

function delegate (obj, target, field) {
  obj[field] = function delegated () {
    var thing = this[target]
    thing[field].apply(thing, arguments)
  }
}

function logit (flag) {
  return function logger () {
    if(window.gaston){
      console.log(':: vigour-cloud ::', flag, arguments)
    }
  }
}

var vflag = ':: vigour-cloud ::'
function log () {
  if(window.gaston){
    var args = util.arg(arguments)
    args.unshift(vflag)
    console.log.apply(console, args)
  }
}
log.error = function (flag, err){
  console.error(vflag, flag, '\n', err)
}
function logger (flag){
  return function logger () {
    var args = util.arg(arguments)
    args.unshift(vflag, flag)
    console.log.apply(console, args)
  }
}

function fixVID (VID) {
  VID = VID || G.session('VID') || id('V_')
  return G.session('VID', VID)
}

function passOn (from, to) {
  for (var e in from._callbacks) {
    var fromlist = from._callbacks[e]
    for (var i = 0, fn; fn = fromlist[i]; i++) {
      // console.log('hand over dat listner', fn.name === 'on' && fn.fn ? 'once' : 'on',e, fn.fn || fn)
      if (fn.name === 'on' && fn.fn) {
        to.once(e, fn.fn)
      } else {
        to.on(e, fn)
      }
    }
  }
  from.off()
}

function fixUrl (url, params) {
  var cutoff = url.indexOf('?')
  if (cutoff > -1) {
    url = url.slice(0, cutoff)
  }
  return url + '?' + urlEncode(params, 'GET', 'uri')
}
},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/global":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/global.js","../../../util/id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js","../../../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js","./emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js","./socket.io.min.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/socket.io.min.js","socket.io-client":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/socket.io.min.js":[function(require,module,exports){
(function (global){
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.io=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){module.exports=_dereq_("./lib/")},{"./lib/":2}],2:[function(_dereq_,module,exports){var url=_dereq_("./url");var parser=_dereq_("socket.io-parser");var Manager=_dereq_("./manager");var debug=_dereq_("debug")("socket.io-client");module.exports=exports=lookup;var cache=exports.managers={};function lookup(uri,opts){if(typeof uri=="object"){opts=uri;uri=undefined}opts=opts||{};var parsed=url(uri);var source=parsed.source;var id=parsed.id;var io;if(opts.forceNew||opts["force new connection"]||false===opts.multiplex){debug("ignoring socket cache for %s",source);io=Manager(source,opts)}else{if(!cache[id]){debug("new io instance for %s",source);cache[id]=Manager(source,opts)}io=cache[id]}return io.socket(parsed.path)}exports.protocol=parser.protocol;exports.connect=lookup;exports.Manager=_dereq_("./manager");exports.Socket=_dereq_("./socket")},{"./manager":3,"./socket":5,"./url":6,debug:10,"socket.io-parser":46}],3:[function(_dereq_,module,exports){var url=_dereq_("./url");var eio=_dereq_("engine.io-client");var Socket=_dereq_("./socket");var Emitter=_dereq_("component-emitter");var parser=_dereq_("socket.io-parser");var on=_dereq_("./on");var bind=_dereq_("component-bind");var object=_dereq_("object-component");var debug=_dereq_("debug")("socket.io-client:manager");var indexOf=_dereq_("indexof");var Backoff=_dereq_("backo2");module.exports=Manager;function Manager(uri,opts){if(!(this instanceof Manager))return new Manager(uri,opts);if(uri&&"object"==typeof uri){opts=uri;uri=undefined}opts=opts||{};opts.path=opts.path||"/socket.io";this.nsps={};this.subs=[];this.opts=opts;this.reconnection(opts.reconnection!==false);this.reconnectionAttempts(opts.reconnectionAttempts||Infinity);this.reconnectionDelay(opts.reconnectionDelay||1e3);this.reconnectionDelayMax(opts.reconnectionDelayMax||5e3);this.randomizationFactor(opts.randomizationFactor||.5);this.backoff=new Backoff({min:this.reconnectionDelay(),max:this.reconnectionDelayMax(),jitter:this.randomizationFactor()});this.timeout(null==opts.timeout?2e4:opts.timeout);this.readyState="closed";this.uri=uri;this.connected=[];this.encoding=false;this.packetBuffer=[];this.encoder=new parser.Encoder;this.decoder=new parser.Decoder;this.autoConnect=opts.autoConnect!==false;if(this.autoConnect)this.open()}Manager.prototype.emitAll=function(){this.emit.apply(this,arguments);for(var nsp in this.nsps){this.nsps[nsp].emit.apply(this.nsps[nsp],arguments)}};Manager.prototype.updateSocketIds=function(){for(var nsp in this.nsps){this.nsps[nsp].id=this.engine.id}};Emitter(Manager.prototype);Manager.prototype.reconnection=function(v){if(!arguments.length)return this._reconnection;this._reconnection=!!v;return this};Manager.prototype.reconnectionAttempts=function(v){if(!arguments.length)return this._reconnectionAttempts;this._reconnectionAttempts=v;return this};Manager.prototype.reconnectionDelay=function(v){if(!arguments.length)return this._reconnectionDelay;this._reconnectionDelay=v;this.backoff&&this.backoff.setMin(v);return this};Manager.prototype.randomizationFactor=function(v){if(!arguments.length)return this._randomizationFactor;this._randomizationFactor=v;this.backoff&&this.backoff.setJitter(v);return this};Manager.prototype.reconnectionDelayMax=function(v){if(!arguments.length)return this._reconnectionDelayMax;this._reconnectionDelayMax=v;this.backoff&&this.backoff.setMax(v);return this};Manager.prototype.timeout=function(v){if(!arguments.length)return this._timeout;this._timeout=v;return this};Manager.prototype.maybeReconnectOnOpen=function(){if(!this.reconnecting&&this._reconnection&&this.backoff.attempts===0){this.reconnect()}};Manager.prototype.open=Manager.prototype.connect=function(fn){debug("readyState %s",this.readyState);if(~this.readyState.indexOf("open"))return this;debug("opening %s",this.uri);this.engine=eio(this.uri,this.opts);var socket=this.engine;var self=this;this.readyState="opening";this.skipReconnect=false;var openSub=on(socket,"open",function(){self.onopen();fn&&fn()});var errorSub=on(socket,"error",function(data){debug("connect_error");self.cleanup();self.readyState="closed";self.emitAll("connect_error",data);if(fn){var err=new Error("Connection error");err.data=data;fn(err)}else{self.maybeReconnectOnOpen()}});if(false!==this._timeout){var timeout=this._timeout;debug("connect attempt will timeout after %d",timeout);var timer=setTimeout(function(){debug("connect attempt timed out after %d",timeout);openSub.destroy();socket.close();socket.emit("error","timeout");self.emitAll("connect_timeout",timeout)},timeout);this.subs.push({destroy:function(){clearTimeout(timer)}})}this.subs.push(openSub);this.subs.push(errorSub);return this};Manager.prototype.onopen=function(){debug("open");this.cleanup();this.readyState="open";this.emit("open");var socket=this.engine;this.subs.push(on(socket,"data",bind(this,"ondata")));this.subs.push(on(this.decoder,"decoded",bind(this,"ondecoded")));this.subs.push(on(socket,"error",bind(this,"onerror")));this.subs.push(on(socket,"close",bind(this,"onclose")))};Manager.prototype.ondata=function(data){this.decoder.add(data)};Manager.prototype.ondecoded=function(packet){this.emit("packet",packet)};Manager.prototype.onerror=function(err){debug("error",err);this.emitAll("error",err)};Manager.prototype.socket=function(nsp){var socket=this.nsps[nsp];if(!socket){socket=new Socket(this,nsp);this.nsps[nsp]=socket;var self=this;socket.on("connect",function(){socket.id=self.engine.id;if(!~indexOf(self.connected,socket)){self.connected.push(socket)}})}return socket};Manager.prototype.destroy=function(socket){var index=indexOf(this.connected,socket);if(~index)this.connected.splice(index,1);if(this.connected.length)return;this.close()};Manager.prototype.packet=function(packet){debug("writing packet %j",packet);var self=this;if(!self.encoding){self.encoding=true;this.encoder.encode(packet,function(encodedPackets){for(var i=0;i<encodedPackets.length;i++){self.engine.write(encodedPackets[i])}self.encoding=false;self.processPacketQueue()})}else{self.packetBuffer.push(packet)}};Manager.prototype.processPacketQueue=function(){if(this.packetBuffer.length>0&&!this.encoding){var pack=this.packetBuffer.shift();this.packet(pack)}};Manager.prototype.cleanup=function(){var sub;while(sub=this.subs.shift())sub.destroy();this.packetBuffer=[];this.encoding=false;this.decoder.destroy()};Manager.prototype.close=Manager.prototype.disconnect=function(){this.skipReconnect=true;this.backoff.reset();this.readyState="closed";this.engine&&this.engine.close()};Manager.prototype.onclose=function(reason){debug("close");this.cleanup();this.backoff.reset();this.readyState="closed";this.emit("close",reason);if(this._reconnection&&!this.skipReconnect){this.reconnect()}};Manager.prototype.reconnect=function(){if(this.reconnecting||this.skipReconnect)return this;var self=this;if(this.backoff.attempts>=this._reconnectionAttempts){debug("reconnect failed");this.backoff.reset();this.emitAll("reconnect_failed");this.reconnecting=false}else{var delay=this.backoff.duration();debug("will wait %dms before reconnect attempt",delay);this.reconnecting=true;var timer=setTimeout(function(){if(self.skipReconnect)return;debug("attempting reconnect");self.emitAll("reconnect_attempt",self.backoff.attempts);self.emitAll("reconnecting",self.backoff.attempts);if(self.skipReconnect)return;self.open(function(err){if(err){debug("reconnect attempt error");self.reconnecting=false;self.reconnect();self.emitAll("reconnect_error",err.data)}else{debug("reconnect success");self.onreconnect()}})},delay);this.subs.push({destroy:function(){clearTimeout(timer)}})}};Manager.prototype.onreconnect=function(){var attempt=this.backoff.attempts;this.reconnecting=false;this.backoff.reset();this.updateSocketIds();this.emitAll("reconnect",attempt)}},{"./on":4,"./socket":5,"./url":6,backo2:7,"component-bind":8,"component-emitter":9,debug:10,"engine.io-client":11,indexof:42,"object-component":43,"socket.io-parser":46}],4:[function(_dereq_,module,exports){module.exports=on;function on(obj,ev,fn){obj.on(ev,fn);return{destroy:function(){obj.removeListener(ev,fn)}}}},{}],5:[function(_dereq_,module,exports){var parser=_dereq_("socket.io-parser");var Emitter=_dereq_("component-emitter");var toArray=_dereq_("to-array");var on=_dereq_("./on");var bind=_dereq_("component-bind");var debug=_dereq_("debug")("socket.io-client:socket");var hasBin=_dereq_("has-binary");module.exports=exports=Socket;var events={connect:1,connect_error:1,connect_timeout:1,disconnect:1,error:1,reconnect:1,reconnect_attempt:1,reconnect_failed:1,reconnect_error:1,reconnecting:1};var emit=Emitter.prototype.emit;function Socket(io,nsp){this.io=io;this.nsp=nsp;this.json=this;this.ids=0;this.acks={};if(this.io.autoConnect)this.open();this.receiveBuffer=[];this.sendBuffer=[];this.connected=false;this.disconnected=true}Emitter(Socket.prototype);Socket.prototype.subEvents=function(){if(this.subs)return;var io=this.io;this.subs=[on(io,"open",bind(this,"onopen")),on(io,"packet",bind(this,"onpacket")),on(io,"close",bind(this,"onclose"))]};Socket.prototype.open=Socket.prototype.connect=function(){if(this.connected)return this;this.subEvents();this.io.open();if("open"==this.io.readyState)this.onopen();return this};Socket.prototype.send=function(){var args=toArray(arguments);args.unshift("message");this.emit.apply(this,args);return this};Socket.prototype.emit=function(ev){if(events.hasOwnProperty(ev)){emit.apply(this,arguments);return this}var args=toArray(arguments);var parserType=parser.EVENT;if(hasBin(args)){parserType=parser.BINARY_EVENT}var packet={type:parserType,data:args};if("function"==typeof args[args.length-1]){debug("emitting packet with ack id %d",this.ids);this.acks[this.ids]=args.pop();packet.id=this.ids++}if(this.connected){this.packet(packet)}else{this.sendBuffer.push(packet)}return this};Socket.prototype.packet=function(packet){packet.nsp=this.nsp;this.io.packet(packet)};Socket.prototype.onopen=function(){debug("transport is open - connecting");if("/"!=this.nsp){this.packet({type:parser.CONNECT})}};Socket.prototype.onclose=function(reason){debug("close (%s)",reason);this.connected=false;this.disconnected=true;delete this.id;this.emit("disconnect",reason)};Socket.prototype.onpacket=function(packet){if(packet.nsp!=this.nsp)return;switch(packet.type){case parser.CONNECT:this.onconnect();break;case parser.EVENT:this.onevent(packet);break;case parser.BINARY_EVENT:this.onevent(packet);break;case parser.ACK:this.onack(packet);break;case parser.BINARY_ACK:this.onack(packet);break;case parser.DISCONNECT:this.ondisconnect();break;case parser.ERROR:this.emit("error",packet.data);break}};Socket.prototype.onevent=function(packet){var args=packet.data||[];debug("emitting event %j",args);if(null!=packet.id){debug("attaching ack callback to event");args.push(this.ack(packet.id))}if(this.connected){emit.apply(this,args)}else{this.receiveBuffer.push(args)}};Socket.prototype.ack=function(id){var self=this;var sent=false;return function(){if(sent)return;sent=true;var args=toArray(arguments);debug("sending ack %j",args);var type=hasBin(args)?parser.BINARY_ACK:parser.ACK;self.packet({type:type,id:id,data:args})}};Socket.prototype.onack=function(packet){debug("calling ack %s with %j",packet.id,packet.data);var fn=this.acks[packet.id];fn.apply(this,packet.data);delete this.acks[packet.id]};Socket.prototype.onconnect=function(){this.connected=true;this.disconnected=false;this.emit("connect");this.emitBuffered()};Socket.prototype.emitBuffered=function(){var i;for(i=0;i<this.receiveBuffer.length;i++){emit.apply(this,this.receiveBuffer[i])}this.receiveBuffer=[];for(i=0;i<this.sendBuffer.length;i++){this.packet(this.sendBuffer[i])}this.sendBuffer=[]};Socket.prototype.ondisconnect=function(){debug("server disconnect (%s)",this.nsp);this.destroy();this.onclose("io server disconnect")};Socket.prototype.destroy=function(){if(this.subs){for(var i=0;i<this.subs.length;i++){this.subs[i].destroy()}this.subs=null}this.io.destroy(this)};Socket.prototype.close=Socket.prototype.disconnect=function(){if(this.connected){debug("performing disconnect (%s)",this.nsp);this.packet({type:parser.DISCONNECT})}this.destroy();if(this.connected){this.onclose("io client disconnect")}return this}},{"./on":4,"component-bind":8,"component-emitter":9,debug:10,"has-binary":38,"socket.io-parser":46,"to-array":50}],6:[function(_dereq_,module,exports){(function(global){var parseuri=_dereq_("parseuri");var debug=_dereq_("debug")("socket.io-client:url");module.exports=url;function url(uri,loc){var obj=uri;var loc=loc||global.location;if(null==uri)uri=loc.protocol+"//"+loc.host;if("string"==typeof uri){if("/"==uri.charAt(0)){if("/"==uri.charAt(1)){uri=loc.protocol+uri}else{uri=loc.hostname+uri}}if(!/^(https?|wss?):\/\//.test(uri)){debug("protocol-less url %s",uri);if("undefined"!=typeof loc){uri=loc.protocol+"//"+uri}else{uri="https://"+uri}}debug("parse %s",uri);obj=parseuri(uri)}if(!obj.port){if(/^(http|ws)$/.test(obj.protocol)){obj.port="80"}else if(/^(http|ws)s$/.test(obj.protocol)){obj.port="443"}}obj.path=obj.path||"/";obj.id=obj.protocol+"://"+obj.host+":"+obj.port;obj.href=obj.protocol+"://"+obj.host+(loc&&loc.port==obj.port?"":":"+obj.port);return obj}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{debug:10,parseuri:44}],7:[function(_dereq_,module,exports){module.exports=Backoff;function Backoff(opts){opts=opts||{};this.ms=opts.min||100;this.max=opts.max||1e4;this.factor=opts.factor||2;this.jitter=opts.jitter>0&&opts.jitter<=1?opts.jitter:0;this.attempts=0}Backoff.prototype.duration=function(){var ms=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var rand=Math.random();var deviation=Math.floor(rand*this.jitter*ms);ms=(Math.floor(rand*10)&1)==0?ms-deviation:ms+deviation}return Math.min(ms,this.max)|0};Backoff.prototype.reset=function(){this.attempts=0};Backoff.prototype.setMin=function(min){this.ms=min};Backoff.prototype.setMax=function(max){this.max=max};Backoff.prototype.setJitter=function(jitter){this.jitter=jitter}},{}],8:[function(_dereq_,module,exports){var slice=[].slice;module.exports=function(obj,fn){if("string"==typeof fn)fn=obj[fn];if("function"!=typeof fn)throw new Error("bind() requires a function");var args=slice.call(arguments,2);return function(){return fn.apply(obj,args.concat(slice.call(arguments)))}}},{}],9:[function(_dereq_,module,exports){module.exports=Emitter;function Emitter(obj){if(obj)return mixin(obj)}function mixin(obj){for(var key in Emitter.prototype){obj[key]=Emitter.prototype[key]}return obj}Emitter.prototype.on=Emitter.prototype.addEventListener=function(event,fn){this._callbacks=this._callbacks||{};(this._callbacks[event]=this._callbacks[event]||[]).push(fn);return this};Emitter.prototype.once=function(event,fn){var self=this;this._callbacks=this._callbacks||{};function on(){self.off(event,on);fn.apply(this,arguments)}on.fn=fn;this.on(event,on);return this};Emitter.prototype.off=Emitter.prototype.removeListener=Emitter.prototype.removeAllListeners=Emitter.prototype.removeEventListener=function(event,fn){this._callbacks=this._callbacks||{};if(0==arguments.length){this._callbacks={};return this}var callbacks=this._callbacks[event];if(!callbacks)return this;if(1==arguments.length){delete this._callbacks[event];return this}var cb;for(var i=0;i<callbacks.length;i++){cb=callbacks[i];if(cb===fn||cb.fn===fn){callbacks.splice(i,1);break}}return this};Emitter.prototype.emit=function(event){this._callbacks=this._callbacks||{};var args=[].slice.call(arguments,1),callbacks=this._callbacks[event];if(callbacks){callbacks=callbacks.slice(0);for(var i=0,len=callbacks.length;i<len;++i){callbacks[i].apply(this,args)}}return this};Emitter.prototype.listeners=function(event){this._callbacks=this._callbacks||{};return this._callbacks[event]||[]};Emitter.prototype.hasListeners=function(event){return!!this.listeners(event).length}},{}],10:[function(_dereq_,module,exports){module.exports=debug;function debug(name){if(!debug.enabled(name))return function(){};return function(fmt){fmt=coerce(fmt);var curr=new Date;var ms=curr-(debug[name]||curr);debug[name]=curr;fmt=name+" "+fmt+" +"+debug.humanize(ms);window.console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)}}debug.names=[];debug.skips=[];debug.enable=function(name){try{localStorage.debug=name}catch(e){}var split=(name||"").split(/[\s,]+/),len=split.length;for(var i=0;i<len;i++){name=split[i].replace("*",".*?");if(name[0]==="-"){debug.skips.push(new RegExp("^"+name.substr(1)+"$"))}else{debug.names.push(new RegExp("^"+name+"$"))}}};debug.disable=function(){debug.enable("")};debug.humanize=function(ms){var sec=1e3,min=60*1e3,hour=60*min;if(ms>=hour)return(ms/hour).toFixed(1)+"h";if(ms>=min)return(ms/min).toFixed(1)+"m";if(ms>=sec)return(ms/sec|0)+"s";return ms+"ms"};debug.enabled=function(name){for(var i=0,len=debug.skips.length;i<len;i++){if(debug.skips[i].test(name)){return false}}for(var i=0,len=debug.names.length;i<len;i++){if(debug.names[i].test(name)){return true}}return false};function coerce(val){if(val instanceof Error)return val.stack||val.message;return val}try{if(window.localStorage)debug.enable(localStorage.debug)}catch(e){}},{}],11:[function(_dereq_,module,exports){module.exports=_dereq_("./lib/")},{"./lib/":12}],12:[function(_dereq_,module,exports){module.exports=_dereq_("./socket");module.exports.parser=_dereq_("engine.io-parser")},{"./socket":13,"engine.io-parser":25}],13:[function(_dereq_,module,exports){(function(global){var transports=_dereq_("./transports");var Emitter=_dereq_("component-emitter");var debug=_dereq_("debug")("engine.io-client:socket");var index=_dereq_("indexof");var parser=_dereq_("engine.io-parser");var parseuri=_dereq_("parseuri");var parsejson=_dereq_("parsejson");var parseqs=_dereq_("parseqs");module.exports=Socket;function noop(){}function Socket(uri,opts){if(!(this instanceof Socket))return new Socket(uri,opts);opts=opts||{};if(uri&&"object"==typeof uri){opts=uri;uri=null}if(uri){uri=parseuri(uri);opts.host=uri.host;opts.secure=uri.protocol=="https"||uri.protocol=="wss";opts.port=uri.port;if(uri.query)opts.query=uri.query}this.secure=null!=opts.secure?opts.secure:global.location&&"https:"==location.protocol;if(opts.host){var pieces=opts.host.split(":");opts.hostname=pieces.shift();if(pieces.length){opts.port=pieces.pop()}else if(!opts.port){opts.port=this.secure?"443":"80"}}this.agent=opts.agent||false;this.hostname=opts.hostname||(global.location?location.hostname:"localhost");this.port=opts.port||(global.location&&location.port?location.port:this.secure?443:80);this.query=opts.query||{};if("string"==typeof this.query)this.query=parseqs.decode(this.query);this.upgrade=false!==opts.upgrade;this.path=(opts.path||"/engine.io").replace(/\/$/,"")+"/";this.forceJSONP=!!opts.forceJSONP;this.jsonp=false!==opts.jsonp;this.forceBase64=!!opts.forceBase64;this.enablesXDR=!!opts.enablesXDR;this.timestampParam=opts.timestampParam||"t";this.timestampRequests=opts.timestampRequests;this.transports=opts.transports||["polling","websocket"];this.readyState="";this.writeBuffer=[];this.callbackBuffer=[];this.policyPort=opts.policyPort||843;this.rememberUpgrade=opts.rememberUpgrade||false;this.binaryType=null;this.onlyBinaryUpgrades=opts.onlyBinaryUpgrades;this.pfx=opts.pfx||null;this.key=opts.key||null;this.passphrase=opts.passphrase||null;this.cert=opts.cert||null;this.ca=opts.ca||null;this.ciphers=opts.ciphers||null;this.rejectUnauthorized=opts.rejectUnauthorized||null;this.open()}Socket.priorWebsocketSuccess=false;Emitter(Socket.prototype);Socket.protocol=parser.protocol;Socket.Socket=Socket;Socket.Transport=_dereq_("./transport");Socket.transports=_dereq_("./transports");Socket.parser=_dereq_("engine.io-parser");Socket.prototype.createTransport=function(name){debug('creating transport "%s"',name);var query=clone(this.query);query.EIO=parser.protocol;query.transport=name;if(this.id)query.sid=this.id;var transport=new transports[name]({agent:this.agent,hostname:this.hostname,port:this.port,secure:this.secure,path:this.path,query:query,forceJSONP:this.forceJSONP,jsonp:this.jsonp,forceBase64:this.forceBase64,enablesXDR:this.enablesXDR,timestampRequests:this.timestampRequests,timestampParam:this.timestampParam,policyPort:this.policyPort,socket:this,pfx:this.pfx,key:this.key,passphrase:this.passphrase,cert:this.cert,ca:this.ca,ciphers:this.ciphers,rejectUnauthorized:this.rejectUnauthorized});return transport};function clone(obj){var o={};for(var i in obj){if(obj.hasOwnProperty(i)){o[i]=obj[i]}}return o}Socket.prototype.open=function(){var transport;if(this.rememberUpgrade&&Socket.priorWebsocketSuccess&&this.transports.indexOf("websocket")!=-1){transport="websocket"}else if(0==this.transports.length){var self=this;setTimeout(function(){self.emit("error","No transports available")},0);return}else{transport=this.transports[0]}this.readyState="opening";var transport;try{transport=this.createTransport(transport)}catch(e){this.transports.shift();this.open();return}transport.open();this.setTransport(transport)};Socket.prototype.setTransport=function(transport){debug("setting transport %s",transport.name);var self=this;if(this.transport){debug("clearing existing transport %s",this.transport.name);this.transport.removeAllListeners()}this.transport=transport;transport.on("drain",function(){self.onDrain()}).on("packet",function(packet){self.onPacket(packet)}).on("error",function(e){self.onError(e)}).on("close",function(){self.onClose("transport close")})};Socket.prototype.probe=function(name){debug('probing transport "%s"',name);var transport=this.createTransport(name,{probe:1}),failed=false,self=this;Socket.priorWebsocketSuccess=false;function onTransportOpen(){if(self.onlyBinaryUpgrades){var upgradeLosesBinary=!this.supportsBinary&&self.transport.supportsBinary;failed=failed||upgradeLosesBinary}if(failed)return;debug('probe transport "%s" opened',name);transport.send([{type:"ping",data:"probe"}]);transport.once("packet",function(msg){if(failed)return;if("pong"==msg.type&&"probe"==msg.data){debug('probe transport "%s" pong',name);self.upgrading=true;self.emit("upgrading",transport);if(!transport)return;Socket.priorWebsocketSuccess="websocket"==transport.name;debug('pausing current transport "%s"',self.transport.name);self.transport.pause(function(){if(failed)return;if("closed"==self.readyState)return;debug("changing transport and sending upgrade packet");cleanup();self.setTransport(transport);transport.send([{type:"upgrade"}]);self.emit("upgrade",transport);transport=null;self.upgrading=false;self.flush()})}else{debug('probe transport "%s" failed',name);var err=new Error("probe error");err.transport=transport.name;self.emit("upgradeError",err)}})}function freezeTransport(){if(failed)return;failed=true;cleanup();transport.close();transport=null}function onerror(err){var error=new Error("probe error: "+err);error.transport=transport.name;freezeTransport();debug('probe transport "%s" failed because of error: %s',name,err);self.emit("upgradeError",error)}function onTransportClose(){onerror("transport closed")}function onclose(){onerror("socket closed")}function onupgrade(to){if(transport&&to.name!=transport.name){debug('"%s" works - aborting "%s"',to.name,transport.name);freezeTransport()}}function cleanup(){transport.removeListener("open",onTransportOpen);transport.removeListener("error",onerror);transport.removeListener("close",onTransportClose);self.removeListener("close",onclose);self.removeListener("upgrading",onupgrade)}transport.once("open",onTransportOpen);transport.once("error",onerror);transport.once("close",onTransportClose);this.once("close",onclose);this.once("upgrading",onupgrade);transport.open()};Socket.prototype.onOpen=function(){debug("socket open");this.readyState="open";Socket.priorWebsocketSuccess="websocket"==this.transport.name;this.emit("open");this.flush();if("open"==this.readyState&&this.upgrade&&this.transport.pause){debug("starting upgrade probes");for(var i=0,l=this.upgrades.length;i<l;i++){this.probe(this.upgrades[i])}}};Socket.prototype.onPacket=function(packet){if("opening"==this.readyState||"open"==this.readyState){debug('socket receive: type "%s", data "%s"',packet.type,packet.data);this.emit("packet",packet);this.emit("heartbeat");switch(packet.type){case"open":this.onHandshake(parsejson(packet.data));break;case"pong":this.setPing();break;case"error":var err=new Error("server error");err.code=packet.data;this.emit("error",err);break;case"message":this.emit("data",packet.data);this.emit("message",packet.data);break}}else{debug('packet received with socket readyState "%s"',this.readyState)}};Socket.prototype.onHandshake=function(data){this.emit("handshake",data);this.id=data.sid;this.transport.query.sid=data.sid;this.upgrades=this.filterUpgrades(data.upgrades);this.pingInterval=data.pingInterval;this.pingTimeout=data.pingTimeout;this.onOpen();if("closed"==this.readyState)return;this.setPing();this.removeListener("heartbeat",this.onHeartbeat);this.on("heartbeat",this.onHeartbeat)};Socket.prototype.onHeartbeat=function(timeout){clearTimeout(this.pingTimeoutTimer);var self=this;self.pingTimeoutTimer=setTimeout(function(){if("closed"==self.readyState)return;self.onClose("ping timeout")},timeout||self.pingInterval+self.pingTimeout)};Socket.prototype.setPing=function(){var self=this;clearTimeout(self.pingIntervalTimer);self.pingIntervalTimer=setTimeout(function(){debug("writing ping packet - expecting pong within %sms",self.pingTimeout);self.ping();self.onHeartbeat(self.pingTimeout)},self.pingInterval)};Socket.prototype.ping=function(){this.sendPacket("ping")};Socket.prototype.onDrain=function(){for(var i=0;i<this.prevBufferLen;i++){if(this.callbackBuffer[i]){this.callbackBuffer[i]()}}this.writeBuffer.splice(0,this.prevBufferLen);this.callbackBuffer.splice(0,this.prevBufferLen);this.prevBufferLen=0;if(this.writeBuffer.length==0){this.emit("drain")}else{this.flush()}};Socket.prototype.flush=function(){if("closed"!=this.readyState&&this.transport.writable&&!this.upgrading&&this.writeBuffer.length){debug("flushing %d packets in socket",this.writeBuffer.length);this.transport.send(this.writeBuffer);this.prevBufferLen=this.writeBuffer.length;this.emit("flush")}};Socket.prototype.write=Socket.prototype.send=function(msg,fn){this.sendPacket("message",msg,fn);return this};Socket.prototype.sendPacket=function(type,data,fn){if("closing"==this.readyState||"closed"==this.readyState){return}var packet={type:type,data:data};this.emit("packetCreate",packet);this.writeBuffer.push(packet);this.callbackBuffer.push(fn);this.flush()};Socket.prototype.close=function(){if("opening"==this.readyState||"open"==this.readyState){this.readyState="closing";var self=this;function close(){self.onClose("forced close");debug("socket closing - telling transport to close");self.transport.close()}function cleanupAndClose(){self.removeListener("upgrade",cleanupAndClose);self.removeListener("upgradeError",cleanupAndClose);close()}function waitForUpgrade(){self.once("upgrade",cleanupAndClose);self.once("upgradeError",cleanupAndClose)}if(this.writeBuffer.length){this.once("drain",function(){if(this.upgrading){waitForUpgrade()}else{close()}})}else if(this.upgrading){waitForUpgrade()}else{close()}}return this};Socket.prototype.onError=function(err){debug("socket error %j",err);Socket.priorWebsocketSuccess=false;this.emit("error",err);this.onClose("transport error",err)};Socket.prototype.onClose=function(reason,desc){if("opening"==this.readyState||"open"==this.readyState||"closing"==this.readyState){debug('socket close with reason: "%s"',reason);var self=this;clearTimeout(this.pingIntervalTimer);clearTimeout(this.pingTimeoutTimer);setTimeout(function(){self.writeBuffer=[];self.callbackBuffer=[];self.prevBufferLen=0},0);this.transport.removeAllListeners("close");this.transport.close();this.transport.removeAllListeners();this.readyState="closed";this.id=null;this.emit("close",reason,desc)}};Socket.prototype.filterUpgrades=function(upgrades){var filteredUpgrades=[];for(var i=0,j=upgrades.length;i<j;i++){if(~index(this.transports,upgrades[i]))filteredUpgrades.push(upgrades[i])}return filteredUpgrades}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./transport":14,"./transports":15,"component-emitter":9,debug:22,"engine.io-parser":25,indexof:42,parsejson:34,parseqs:35,parseuri:36}],14:[function(_dereq_,module,exports){var parser=_dereq_("engine.io-parser");var Emitter=_dereq_("component-emitter");module.exports=Transport;function Transport(opts){this.path=opts.path;this.hostname=opts.hostname;this.port=opts.port;this.secure=opts.secure;this.query=opts.query;this.timestampParam=opts.timestampParam;this.timestampRequests=opts.timestampRequests;this.readyState="";this.agent=opts.agent||false;this.socket=opts.socket;this.enablesXDR=opts.enablesXDR;this.pfx=opts.pfx;this.key=opts.key;this.passphrase=opts.passphrase;this.cert=opts.cert;this.ca=opts.ca;this.ciphers=opts.ciphers;this.rejectUnauthorized=opts.rejectUnauthorized}Emitter(Transport.prototype);Transport.timestamps=0;Transport.prototype.onError=function(msg,desc){var err=new Error(msg);err.type="TransportError";err.description=desc;this.emit("error",err);return this};Transport.prototype.open=function(){if("closed"==this.readyState||""==this.readyState){this.readyState="opening";this.doOpen()}return this};Transport.prototype.close=function(){if("opening"==this.readyState||"open"==this.readyState){this.doClose();this.onClose()}return this};Transport.prototype.send=function(packets){if("open"==this.readyState){this.write(packets)}else{throw new Error("Transport not open")}};Transport.prototype.onOpen=function(){this.readyState="open";this.writable=true;this.emit("open")};Transport.prototype.onData=function(data){var packet=parser.decodePacket(data,this.socket.binaryType);this.onPacket(packet)};Transport.prototype.onPacket=function(packet){this.emit("packet",packet)};Transport.prototype.onClose=function(){this.readyState="closed";this.emit("close")}},{"component-emitter":9,"engine.io-parser":25}],15:[function(_dereq_,module,exports){(function(global){var XMLHttpRequest=_dereq_("xmlhttprequest");var XHR=_dereq_("./polling-xhr");var JSONP=_dereq_("./polling-jsonp");var websocket=_dereq_("./websocket");exports.polling=polling;exports.websocket=websocket;function polling(opts){var xhr;var xd=false;var xs=false;var jsonp=false!==opts.jsonp;if(global.location){var isSSL="https:"==location.protocol;var port=location.port;if(!port){port=isSSL?443:80}xd=opts.hostname!=location.hostname||port!=opts.port;xs=opts.secure!=isSSL}opts.xdomain=xd;opts.xscheme=xs;xhr=new XMLHttpRequest(opts);if("open"in xhr&&!opts.forceJSONP){return new XHR(opts)}else{if(!jsonp)throw new Error("JSONP disabled");return new JSONP(opts)}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling-jsonp":16,"./polling-xhr":17,"./websocket":19,xmlhttprequest:20}],16:[function(_dereq_,module,exports){(function(global){var Polling=_dereq_("./polling");var inherit=_dereq_("component-inherit");module.exports=JSONPPolling;var rNewline=/\n/g;var rEscapedNewline=/\\n/g;var callbacks;var index=0;function empty(){}function JSONPPolling(opts){Polling.call(this,opts);
this.query=this.query||{};if(!callbacks){if(!global.___eio)global.___eio=[];callbacks=global.___eio}this.index=callbacks.length;var self=this;callbacks.push(function(msg){self.onData(msg)});this.query.j=this.index;if(global.document&&global.addEventListener){global.addEventListener("beforeunload",function(){if(self.script)self.script.onerror=empty},false)}}inherit(JSONPPolling,Polling);JSONPPolling.prototype.supportsBinary=false;JSONPPolling.prototype.doClose=function(){if(this.script){this.script.parentNode.removeChild(this.script);this.script=null}if(this.form){this.form.parentNode.removeChild(this.form);this.form=null;this.iframe=null}Polling.prototype.doClose.call(this)};JSONPPolling.prototype.doPoll=function(){var self=this;var script=document.createElement("script");if(this.script){this.script.parentNode.removeChild(this.script);this.script=null}script.async=true;script.src=this.uri();script.onerror=function(e){self.onError("jsonp poll error",e)};var insertAt=document.getElementsByTagName("script")[0];insertAt.parentNode.insertBefore(script,insertAt);this.script=script;var isUAgecko="undefined"!=typeof navigator&&/gecko/i.test(navigator.userAgent);if(isUAgecko){setTimeout(function(){var iframe=document.createElement("iframe");document.body.appendChild(iframe);document.body.removeChild(iframe)},100)}};JSONPPolling.prototype.doWrite=function(data,fn){var self=this;if(!this.form){var form=document.createElement("form");var area=document.createElement("textarea");var id=this.iframeId="eio_iframe_"+this.index;var iframe;form.className="socketio";form.style.position="absolute";form.style.top="-1000px";form.style.left="-1000px";form.target=id;form.method="POST";form.setAttribute("accept-charset","utf-8");area.name="d";form.appendChild(area);document.body.appendChild(form);this.form=form;this.area=area}this.form.action=this.uri();function complete(){initIframe();fn()}function initIframe(){if(self.iframe){try{self.form.removeChild(self.iframe)}catch(e){self.onError("jsonp polling iframe removal error",e)}}try{var html='<iframe src="javascript:0" name="'+self.iframeId+'">';iframe=document.createElement(html)}catch(e){iframe=document.createElement("iframe");iframe.name=self.iframeId;iframe.src="javascript:0"}iframe.id=self.iframeId;self.form.appendChild(iframe);self.iframe=iframe}initIframe();data=data.replace(rEscapedNewline,"\\\n");this.area.value=data.replace(rNewline,"\\n");try{this.form.submit()}catch(e){}if(this.iframe.attachEvent){this.iframe.onreadystatechange=function(){if(self.iframe.readyState=="complete"){complete()}}}else{this.iframe.onload=complete}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling":18,"component-inherit":21}],17:[function(_dereq_,module,exports){(function(global){var XMLHttpRequest=_dereq_("xmlhttprequest");var Polling=_dereq_("./polling");var Emitter=_dereq_("component-emitter");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:polling-xhr");module.exports=XHR;module.exports.Request=Request;function empty(){}function XHR(opts){Polling.call(this,opts);if(global.location){var isSSL="https:"==location.protocol;var port=location.port;if(!port){port=isSSL?443:80}this.xd=opts.hostname!=global.location.hostname||port!=opts.port;this.xs=opts.secure!=isSSL}}inherit(XHR,Polling);XHR.prototype.supportsBinary=true;XHR.prototype.request=function(opts){opts=opts||{};opts.uri=this.uri();opts.xd=this.xd;opts.xs=this.xs;opts.agent=this.agent||false;opts.supportsBinary=this.supportsBinary;opts.enablesXDR=this.enablesXDR;opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;return new Request(opts)};XHR.prototype.doWrite=function(data,fn){var isBinary=typeof data!=="string"&&data!==undefined;var req=this.request({method:"POST",data:data,isBinary:isBinary});var self=this;req.on("success",fn);req.on("error",function(err){self.onError("xhr post error",err)});this.sendXhr=req};XHR.prototype.doPoll=function(){debug("xhr poll");var req=this.request();var self=this;req.on("data",function(data){self.onData(data)});req.on("error",function(err){self.onError("xhr poll error",err)});this.pollXhr=req};function Request(opts){this.method=opts.method||"GET";this.uri=opts.uri;this.xd=!!opts.xd;this.xs=!!opts.xs;this.async=false!==opts.async;this.data=undefined!=opts.data?opts.data:null;this.agent=opts.agent;this.isBinary=opts.isBinary;this.supportsBinary=opts.supportsBinary;this.enablesXDR=opts.enablesXDR;this.pfx=opts.pfx;this.key=opts.key;this.passphrase=opts.passphrase;this.cert=opts.cert;this.ca=opts.ca;this.ciphers=opts.ciphers;this.rejectUnauthorized=opts.rejectUnauthorized;this.create()}Emitter(Request.prototype);Request.prototype.create=function(){var opts={agent:this.agent,xdomain:this.xd,xscheme:this.xs,enablesXDR:this.enablesXDR};opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;var xhr=this.xhr=new XMLHttpRequest(opts);var self=this;try{debug("xhr open %s: %s",this.method,this.uri);xhr.open(this.method,this.uri,this.async);if(this.supportsBinary){xhr.responseType="arraybuffer"}if("POST"==this.method){try{if(this.isBinary){xhr.setRequestHeader("Content-type","application/octet-stream")}else{xhr.setRequestHeader("Content-type","text/plain;charset=UTF-8")}}catch(e){}}if("withCredentials"in xhr){xhr.withCredentials=true}if(this.hasXDR()){xhr.onload=function(){self.onLoad()};xhr.onerror=function(){self.onError(xhr.responseText)}}else{xhr.onreadystatechange=function(){if(4!=xhr.readyState)return;if(200==xhr.status||1223==xhr.status){self.onLoad()}else{setTimeout(function(){self.onError(xhr.status)},0)}}}debug("xhr data %s",this.data);xhr.send(this.data)}catch(e){setTimeout(function(){self.onError(e)},0);return}if(global.document){this.index=Request.requestsCount++;Request.requests[this.index]=this}};Request.prototype.onSuccess=function(){this.emit("success");this.cleanup()};Request.prototype.onData=function(data){this.emit("data",data);this.onSuccess()};Request.prototype.onError=function(err){this.emit("error",err);this.cleanup(true)};Request.prototype.cleanup=function(fromError){if("undefined"==typeof this.xhr||null===this.xhr){return}if(this.hasXDR()){this.xhr.onload=this.xhr.onerror=empty}else{this.xhr.onreadystatechange=empty}if(fromError){try{this.xhr.abort()}catch(e){}}if(global.document){delete Request.requests[this.index]}this.xhr=null};Request.prototype.onLoad=function(){var data;try{var contentType;try{contentType=this.xhr.getResponseHeader("Content-Type").split(";")[0]}catch(e){}if(contentType==="application/octet-stream"){data=this.xhr.response}else{if(!this.supportsBinary){data=this.xhr.responseText}else{data="ok"}}}catch(e){this.onError(e)}if(null!=data){this.onData(data)}};Request.prototype.hasXDR=function(){return"undefined"!==typeof global.XDomainRequest&&!this.xs&&this.enablesXDR};Request.prototype.abort=function(){this.cleanup()};if(global.document){Request.requestsCount=0;Request.requests={};if(global.attachEvent){global.attachEvent("onunload",unloadHandler)}else if(global.addEventListener){global.addEventListener("beforeunload",unloadHandler,false)}}function unloadHandler(){for(var i in Request.requests){if(Request.requests.hasOwnProperty(i)){Request.requests[i].abort()}}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./polling":18,"component-emitter":9,"component-inherit":21,debug:22,xmlhttprequest:20}],18:[function(_dereq_,module,exports){var Transport=_dereq_("../transport");var parseqs=_dereq_("parseqs");var parser=_dereq_("engine.io-parser");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:polling");module.exports=Polling;var hasXHR2=function(){var XMLHttpRequest=_dereq_("xmlhttprequest");var xhr=new XMLHttpRequest({xdomain:false});return null!=xhr.responseType}();function Polling(opts){var forceBase64=opts&&opts.forceBase64;if(!hasXHR2||forceBase64){this.supportsBinary=false}Transport.call(this,opts)}inherit(Polling,Transport);Polling.prototype.name="polling";Polling.prototype.doOpen=function(){this.poll()};Polling.prototype.pause=function(onPause){var pending=0;var self=this;this.readyState="pausing";function pause(){debug("paused");self.readyState="paused";onPause()}if(this.polling||!this.writable){var total=0;if(this.polling){debug("we are currently polling - waiting to pause");total++;this.once("pollComplete",function(){debug("pre-pause polling complete");--total||pause()})}if(!this.writable){debug("we are currently writing - waiting to pause");total++;this.once("drain",function(){debug("pre-pause writing complete");--total||pause()})}}else{pause()}};Polling.prototype.poll=function(){debug("polling");this.polling=true;this.doPoll();this.emit("poll")};Polling.prototype.onData=function(data){var self=this;debug("polling got data %s",data);var callback=function(packet,index,total){if("opening"==self.readyState){self.onOpen()}if("close"==packet.type){self.onClose();return false}self.onPacket(packet)};parser.decodePayload(data,this.socket.binaryType,callback);if("closed"!=this.readyState){this.polling=false;this.emit("pollComplete");if("open"==this.readyState){this.poll()}else{debug('ignoring poll - transport state "%s"',this.readyState)}}};Polling.prototype.doClose=function(){var self=this;function close(){debug("writing close packet");self.write([{type:"close"}])}if("open"==this.readyState){debug("transport open - closing");close()}else{debug("transport not open - deferring close");this.once("open",close)}};Polling.prototype.write=function(packets){var self=this;this.writable=false;var callbackfn=function(){self.writable=true;self.emit("drain")};var self=this;parser.encodePayload(packets,this.supportsBinary,function(data){self.doWrite(data,callbackfn)})};Polling.prototype.uri=function(){var query=this.query||{};var schema=this.secure?"https":"http";var port="";if(false!==this.timestampRequests){query[this.timestampParam]=+new Date+"-"+Transport.timestamps++}if(!this.supportsBinary&&!query.sid){query.b64=1}query=parseqs.encode(query);if(this.port&&("https"==schema&&this.port!=443||"http"==schema&&this.port!=80)){port=":"+this.port}if(query.length){query="?"+query}return schema+"://"+this.hostname+port+this.path+query}},{"../transport":14,"component-inherit":21,debug:22,"engine.io-parser":25,parseqs:35,xmlhttprequest:20}],19:[function(_dereq_,module,exports){var Transport=_dereq_("../transport");var parser=_dereq_("engine.io-parser");var parseqs=_dereq_("parseqs");var inherit=_dereq_("component-inherit");var debug=_dereq_("debug")("engine.io-client:websocket");var WebSocket=_dereq_("ws");module.exports=WS;function WS(opts){var forceBase64=opts&&opts.forceBase64;if(forceBase64){this.supportsBinary=false}Transport.call(this,opts)}inherit(WS,Transport);WS.prototype.name="websocket";WS.prototype.supportsBinary=true;WS.prototype.doOpen=function(){if(!this.check()){return}var self=this;var uri=this.uri();var protocols=void 0;var opts={agent:this.agent};opts.pfx=this.pfx;opts.key=this.key;opts.passphrase=this.passphrase;opts.cert=this.cert;opts.ca=this.ca;opts.ciphers=this.ciphers;opts.rejectUnauthorized=this.rejectUnauthorized;this.ws=new WebSocket(uri,protocols,opts);if(this.ws.binaryType===undefined){this.supportsBinary=false}this.ws.binaryType="arraybuffer";this.addEventListeners()};WS.prototype.addEventListeners=function(){var self=this;this.ws.onopen=function(){self.onOpen()};this.ws.onclose=function(){self.onClose()};this.ws.onmessage=function(ev){self.onData(ev.data)};this.ws.onerror=function(e){self.onError("websocket error",e)}};if("undefined"!=typeof navigator&&/iPad|iPhone|iPod/i.test(navigator.userAgent)){WS.prototype.onData=function(data){var self=this;setTimeout(function(){Transport.prototype.onData.call(self,data)},0)}}WS.prototype.write=function(packets){var self=this;this.writable=false;for(var i=0,l=packets.length;i<l;i++){parser.encodePacket(packets[i],this.supportsBinary,function(data){try{self.ws.send(data)}catch(e){debug("websocket closed before onclose event")}})}function ondrain(){self.writable=true;self.emit("drain")}setTimeout(ondrain,0)};WS.prototype.onClose=function(){Transport.prototype.onClose.call(this)};WS.prototype.doClose=function(){if(typeof this.ws!=="undefined"){this.ws.close()}};WS.prototype.uri=function(){var query=this.query||{};var schema=this.secure?"wss":"ws";var port="";if(this.port&&("wss"==schema&&this.port!=443||"ws"==schema&&this.port!=80)){port=":"+this.port}if(this.timestampRequests){query[this.timestampParam]=+new Date}if(!this.supportsBinary){query.b64=1}query=parseqs.encode(query);if(query.length){query="?"+query}return schema+"://"+this.hostname+port+this.path+query};WS.prototype.check=function(){return!!WebSocket&&!("__initialize"in WebSocket&&this.name===WS.prototype.name)}},{"../transport":14,"component-inherit":21,debug:22,"engine.io-parser":25,parseqs:35,ws:37}],20:[function(_dereq_,module,exports){var hasCORS=_dereq_("has-cors");module.exports=function(opts){var xdomain=opts.xdomain;var xscheme=opts.xscheme;var enablesXDR=opts.enablesXDR;try{if("undefined"!=typeof XMLHttpRequest&&(!xdomain||hasCORS)){return new XMLHttpRequest}}catch(e){}try{if("undefined"!=typeof XDomainRequest&&!xscheme&&enablesXDR){return new XDomainRequest}}catch(e){}if(!xdomain){try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}}}},{"has-cors":40}],21:[function(_dereq_,module,exports){module.exports=function(a,b){var fn=function(){};fn.prototype=b.prototype;a.prototype=new fn;a.prototype.constructor=a}},{}],22:[function(_dereq_,module,exports){exports=module.exports=_dereq_("./debug");exports.log=log;exports.formatArgs=formatArgs;exports.save=save;exports.load=load;exports.useColors=useColors;exports.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"];function useColors(){return"WebkitAppearance"in document.documentElement.style||window.console&&(console.firebug||console.exception&&console.table)||navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31}exports.formatters.j=function(v){return JSON.stringify(v)};function formatArgs(){var args=arguments;var useColors=this.useColors;args[0]=(useColors?"%c":"")+this.namespace+(useColors?" %c":" ")+args[0]+(useColors?"%c ":" ")+"+"+exports.humanize(this.diff);if(!useColors)return args;var c="color: "+this.color;args=[args[0],c,"color: inherit"].concat(Array.prototype.slice.call(args,1));var index=0;var lastC=0;args[0].replace(/%[a-z%]/g,function(match){if("%"===match)return;index++;if("%c"===match){lastC=index}});args.splice(lastC,0,c);return args}function log(){return"object"==typeof console&&"function"==typeof console.log&&Function.prototype.apply.call(console.log,console,arguments)}function save(namespaces){try{if(null==namespaces){localStorage.removeItem("debug")}else{localStorage.debug=namespaces}}catch(e){}}function load(){var r;try{r=localStorage.debug}catch(e){}return r}exports.enable(load())},{"./debug":23}],23:[function(_dereq_,module,exports){exports=module.exports=debug;exports.coerce=coerce;exports.disable=disable;exports.enable=enable;exports.enabled=enabled;exports.humanize=_dereq_("ms");exports.names=[];exports.skips=[];exports.formatters={};var prevColor=0;var prevTime;function selectColor(){return exports.colors[prevColor++%exports.colors.length]}function debug(namespace){function disabled(){}disabled.enabled=false;function enabled(){var self=enabled;var curr=+new Date;var ms=curr-(prevTime||curr);self.diff=ms;self.prev=prevTime;self.curr=curr;prevTime=curr;if(null==self.useColors)self.useColors=exports.useColors();if(null==self.color&&self.useColors)self.color=selectColor();var args=Array.prototype.slice.call(arguments);args[0]=exports.coerce(args[0]);if("string"!==typeof args[0]){args=["%o"].concat(args)}var index=0;args[0]=args[0].replace(/%([a-z%])/g,function(match,format){if(match==="%")return match;index++;var formatter=exports.formatters[format];if("function"===typeof formatter){var val=args[index];match=formatter.call(self,val);args.splice(index,1);index--}return match});if("function"===typeof exports.formatArgs){args=exports.formatArgs.apply(self,args)}var logFn=enabled.log||exports.log||console.log.bind(console);logFn.apply(self,args)}enabled.enabled=true;var fn=exports.enabled(namespace)?enabled:disabled;fn.namespace=namespace;return fn}function enable(namespaces){exports.save(namespaces);var split=(namespaces||"").split(/[\s,]+/);var len=split.length;for(var i=0;i<len;i++){if(!split[i])continue;namespaces=split[i].replace(/\*/g,".*?");if(namespaces[0]==="-"){exports.skips.push(new RegExp("^"+namespaces.substr(1)+"$"))}else{exports.names.push(new RegExp("^"+namespaces+"$"))}}}function disable(){exports.enable("")}function enabled(name){var i,len;for(i=0,len=exports.skips.length;i<len;i++){if(exports.skips[i].test(name)){return false}}for(i=0,len=exports.names.length;i<len;i++){if(exports.names[i].test(name)){return true}}return false}function coerce(val){if(val instanceof Error)return val.stack||val.message;return val}},{ms:24}],24:[function(_dereq_,module,exports){var s=1e3;var m=s*60;var h=m*60;var d=h*24;var y=d*365.25;module.exports=function(val,options){options=options||{};if("string"==typeof val)return parse(val);return options.long?long(val):short(val)};function parse(str){var match=/^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);if(!match)return;var n=parseFloat(match[1]);var type=(match[2]||"ms").toLowerCase();switch(type){case"years":case"year":case"y":return n*y;case"days":case"day":case"d":return n*d;case"hours":case"hour":case"h":return n*h;case"minutes":case"minute":case"m":return n*m;case"seconds":case"second":case"s":return n*s;case"ms":return n}}function short(ms){if(ms>=d)return Math.round(ms/d)+"d";if(ms>=h)return Math.round(ms/h)+"h";if(ms>=m)return Math.round(ms/m)+"m";if(ms>=s)return Math.round(ms/s)+"s";return ms+"ms"}function long(ms){return plural(ms,d,"day")||plural(ms,h,"hour")||plural(ms,m,"minute")||plural(ms,s,"second")||ms+" ms"}function plural(ms,n,name){if(ms<n)return;if(ms<n*1.5)return Math.floor(ms/n)+" "+name;return Math.ceil(ms/n)+" "+name+"s"}},{}],25:[function(_dereq_,module,exports){(function(global){var keys=_dereq_("./keys");var hasBinary=_dereq_("has-binary");var sliceBuffer=_dereq_("arraybuffer.slice");var base64encoder=_dereq_("base64-arraybuffer");var after=_dereq_("after");var utf8=_dereq_("utf8");var isAndroid=navigator.userAgent.match(/Android/i);var isPhantomJS=/PhantomJS/i.test(navigator.userAgent);var dontSendBlobs=isAndroid||isPhantomJS;exports.protocol=3;var packets=exports.packets={open:0,close:1,ping:2,pong:3,message:4,upgrade:5,noop:6};var packetslist=keys(packets);var err={type:"error",data:"parser error"};var Blob=_dereq_("blob");exports.encodePacket=function(packet,supportsBinary,utf8encode,callback){if("function"==typeof supportsBinary){callback=supportsBinary;supportsBinary=false}if("function"==typeof utf8encode){callback=utf8encode;utf8encode=null}var data=packet.data===undefined?undefined:packet.data.buffer||packet.data;if(global.ArrayBuffer&&data instanceof ArrayBuffer){return encodeArrayBuffer(packet,supportsBinary,callback)}else if(Blob&&data instanceof global.Blob){return encodeBlob(packet,supportsBinary,callback)}if(data&&data.base64){return encodeBase64Object(packet,callback)}var encoded=packets[packet.type];if(undefined!==packet.data){encoded+=utf8encode?utf8.encode(String(packet.data)):String(packet.data)}return callback(""+encoded)};function encodeBase64Object(packet,callback){var message="b"+exports.packets[packet.type]+packet.data.data;return callback(message)}function encodeArrayBuffer(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}var data=packet.data;var contentArray=new Uint8Array(data);var resultBuffer=new Uint8Array(1+data.byteLength);resultBuffer[0]=packets[packet.type];for(var i=0;i<contentArray.length;i++){resultBuffer[i+1]=contentArray[i]}return callback(resultBuffer.buffer)}function encodeBlobAsArrayBuffer(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}var fr=new FileReader;fr.onload=function(){packet.data=fr.result;exports.encodePacket(packet,supportsBinary,true,callback)};return fr.readAsArrayBuffer(packet.data)}function encodeBlob(packet,supportsBinary,callback){if(!supportsBinary){return exports.encodeBase64Packet(packet,callback)}if(dontSendBlobs){return encodeBlobAsArrayBuffer(packet,supportsBinary,callback)}var length=new Uint8Array(1);length[0]=packets[packet.type];var blob=new Blob([length.buffer,packet.data]);return callback(blob)}exports.encodeBase64Packet=function(packet,callback){var message="b"+exports.packets[packet.type];if(Blob&&packet.data instanceof Blob){var fr=new FileReader;fr.onload=function(){var b64=fr.result.split(",")[1];callback(message+b64)};return fr.readAsDataURL(packet.data)}var b64data;try{b64data=String.fromCharCode.apply(null,new Uint8Array(packet.data))}catch(e){var typed=new Uint8Array(packet.data);var basic=new Array(typed.length);for(var i=0;i<typed.length;i++){basic[i]=typed[i]}b64data=String.fromCharCode.apply(null,basic)}message+=global.btoa(b64data);return callback(message)};exports.decodePacket=function(data,binaryType,utf8decode){if(typeof data=="string"||data===undefined){if(data.charAt(0)=="b"){return exports.decodeBase64Packet(data.substr(1),binaryType)}if(utf8decode){try{data=utf8.decode(data)}catch(e){return err}}var type=data.charAt(0);if(Number(type)!=type||!packetslist[type]){return err}if(data.length>1){return{type:packetslist[type],data:data.substring(1)}}else{return{type:packetslist[type]}}}var asArray=new Uint8Array(data);var type=asArray[0];var rest=sliceBuffer(data,1);if(Blob&&binaryType==="blob"){rest=new Blob([rest])}return{type:packetslist[type],data:rest}};exports.decodeBase64Packet=function(msg,binaryType){var type=packetslist[msg.charAt(0)];if(!global.ArrayBuffer){return{type:type,data:{base64:true,data:msg.substr(1)}}}var data=base64encoder.decode(msg.substr(1));if(binaryType==="blob"&&Blob){data=new Blob([data])}return{type:type,data:data}};exports.encodePayload=function(packets,supportsBinary,callback){if(typeof supportsBinary=="function"){callback=supportsBinary;supportsBinary=null}var isBinary=hasBinary(packets);if(supportsBinary&&isBinary){if(Blob&&!dontSendBlobs){return exports.encodePayloadAsBlob(packets,callback)}return exports.encodePayloadAsArrayBuffer(packets,callback)}if(!packets.length){return callback("0:")}function setLengthHeader(message){return message.length+":"+message}function encodeOne(packet,doneCallback){exports.encodePacket(packet,!isBinary?false:supportsBinary,true,function(message){doneCallback(null,setLengthHeader(message))})}map(packets,encodeOne,function(err,results){return callback(results.join(""))})};function map(ary,each,done){var result=new Array(ary.length);var next=after(ary.length,done);var eachWithIndex=function(i,el,cb){each(el,function(error,msg){result[i]=msg;cb(error,result)})};for(var i=0;i<ary.length;i++){eachWithIndex(i,ary[i],next)}}exports.decodePayload=function(data,binaryType,callback){if(typeof data!="string"){return exports.decodePayloadAsBinary(data,binaryType,callback)}if(typeof binaryType==="function"){callback=binaryType;binaryType=null}var packet;if(data==""){return callback(err,0,1)}var length="",n,msg;for(var i=0,l=data.length;i<l;i++){var chr=data.charAt(i);if(":"!=chr){length+=chr}else{if(""==length||length!=(n=Number(length))){return callback(err,0,1)}msg=data.substr(i+1,n);if(length!=msg.length){return callback(err,0,1)}if(msg.length){packet=exports.decodePacket(msg,binaryType,true);if(err.type==packet.type&&err.data==packet.data){return callback(err,0,1)}var ret=callback(packet,i+n,l);if(false===ret)return}i+=n;length=""}}if(length!=""){return callback(err,0,1)}};exports.encodePayloadAsArrayBuffer=function(packets,callback){if(!packets.length){return callback(new ArrayBuffer(0))}function encodeOne(packet,doneCallback){exports.encodePacket(packet,true,true,function(data){return doneCallback(null,data)})}map(packets,encodeOne,function(err,encodedPackets){var totalLength=encodedPackets.reduce(function(acc,p){var len;if(typeof p==="string"){len=p.length}else{len=p.byteLength}return acc+len.toString().length+len+2},0);var resultArray=new Uint8Array(totalLength);var bufferIndex=0;encodedPackets.forEach(function(p){var isString=typeof p==="string";var ab=p;if(isString){var view=new Uint8Array(p.length);for(var i=0;i<p.length;i++){view[i]=p.charCodeAt(i)}ab=view.buffer}if(isString){resultArray[bufferIndex++]=0}else{resultArray[bufferIndex++]=1}var lenStr=ab.byteLength.toString();for(var i=0;i<lenStr.length;i++){resultArray[bufferIndex++]=parseInt(lenStr[i])}resultArray[bufferIndex++]=255;var view=new Uint8Array(ab);for(var i=0;i<view.length;i++){resultArray[bufferIndex++]=view[i]}});return callback(resultArray.buffer)})};exports.encodePayloadAsBlob=function(packets,callback){function encodeOne(packet,doneCallback){exports.encodePacket(packet,true,true,function(encoded){var binaryIdentifier=new Uint8Array(1);binaryIdentifier[0]=1;if(typeof encoded==="string"){var view=new Uint8Array(encoded.length);for(var i=0;i<encoded.length;i++){view[i]=encoded.charCodeAt(i)}encoded=view.buffer;binaryIdentifier[0]=0}var len=encoded instanceof ArrayBuffer?encoded.byteLength:encoded.size;var lenStr=len.toString();var lengthAry=new Uint8Array(lenStr.length+1);for(var i=0;i<lenStr.length;i++){lengthAry[i]=parseInt(lenStr[i])}lengthAry[lenStr.length]=255;if(Blob){var blob=new Blob([binaryIdentifier.buffer,lengthAry.buffer,encoded]);doneCallback(null,blob)}})}map(packets,encodeOne,function(err,results){return callback(new Blob(results))})};exports.decodePayloadAsBinary=function(data,binaryType,callback){if(typeof binaryType==="function"){callback=binaryType;binaryType=null}var bufferTail=data;var buffers=[];var numberTooLong=false;while(bufferTail.byteLength>0){var tailArray=new Uint8Array(bufferTail);var isString=tailArray[0]===0;var msgLength="";for(var i=1;;i++){if(tailArray[i]==255)break;if(msgLength.length>310){numberTooLong=true;break}msgLength+=tailArray[i]}if(numberTooLong)return callback(err,0,1);bufferTail=sliceBuffer(bufferTail,2+msgLength.length);msgLength=parseInt(msgLength);var msg=sliceBuffer(bufferTail,0,msgLength);if(isString){try{msg=String.fromCharCode.apply(null,new Uint8Array(msg))}catch(e){var typed=new Uint8Array(msg);msg="";for(var i=0;i<typed.length;i++){msg+=String.fromCharCode(typed[i])}}}buffers.push(msg);bufferTail=sliceBuffer(bufferTail,msgLength)}var total=buffers.length;buffers.forEach(function(buffer,i){callback(exports.decodePacket(buffer,binaryType,true),i,total)})}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./keys":26,after:27,"arraybuffer.slice":28,"base64-arraybuffer":29,blob:30,"has-binary":31,utf8:33}],26:[function(_dereq_,module,exports){module.exports=Object.keys||function keys(obj){var arr=[];var has=Object.prototype.hasOwnProperty;for(var i in obj){if(has.call(obj,i)){arr.push(i)}}return arr}},{}],27:[function(_dereq_,module,exports){module.exports=after;function after(count,callback,err_cb){var bail=false;err_cb=err_cb||noop;proxy.count=count;return count===0?callback():proxy;function proxy(err,result){if(proxy.count<=0){throw new Error("after called too many times")}--proxy.count;if(err){bail=true;callback(err);callback=err_cb}else if(proxy.count===0&&!bail){callback(null,result)}}}function noop(){}},{}],28:[function(_dereq_,module,exports){module.exports=function(arraybuffer,start,end){var bytes=arraybuffer.byteLength;start=start||0;end=end||bytes;if(arraybuffer.slice){return arraybuffer.slice(start,end)}if(start<0){start+=bytes}if(end<0){end+=bytes}if(end>bytes){end=bytes}if(start>=bytes||start>=end||bytes===0){return new ArrayBuffer(0)}var abv=new Uint8Array(arraybuffer);var result=new Uint8Array(end-start);for(var i=start,ii=0;i<end;i++,ii++){result[ii]=abv[i]}return result.buffer}},{}],29:[function(_dereq_,module,exports){(function(chars){"use strict";exports.encode=function(arraybuffer){var bytes=new Uint8Array(arraybuffer),i,len=bytes.length,base64="";for(i=0;i<len;i+=3){base64+=chars[bytes[i]>>2];base64+=chars[(bytes[i]&3)<<4|bytes[i+1]>>4];base64+=chars[(bytes[i+1]&15)<<2|bytes[i+2]>>6];base64+=chars[bytes[i+2]&63]}if(len%3===2){base64=base64.substring(0,base64.length-1)+"="}else if(len%3===1){base64=base64.substring(0,base64.length-2)+"=="}return base64};exports.decode=function(base64){var bufferLength=base64.length*.75,len=base64.length,i,p=0,encoded1,encoded2,encoded3,encoded4;if(base64[base64.length-1]==="="){bufferLength--;if(base64[base64.length-2]==="="){bufferLength--}}var arraybuffer=new ArrayBuffer(bufferLength),bytes=new Uint8Array(arraybuffer);for(i=0;i<len;i+=4){encoded1=chars.indexOf(base64[i]);encoded2=chars.indexOf(base64[i+1]);encoded3=chars.indexOf(base64[i+2]);encoded4=chars.indexOf(base64[i+3]);bytes[p++]=encoded1<<2|encoded2>>4;bytes[p++]=(encoded2&15)<<4|encoded3>>2;bytes[p++]=(encoded3&3)<<6|encoded4&63}return arraybuffer}})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/")},{}],30:[function(_dereq_,module,exports){(function(global){var BlobBuilder=global.BlobBuilder||global.WebKitBlobBuilder||global.MSBlobBuilder||global.MozBlobBuilder;var blobSupported=function(){try{var b=new Blob(["hi"]);return b.size==2}catch(e){return false}}();var blobBuilderSupported=BlobBuilder&&BlobBuilder.prototype.append&&BlobBuilder.prototype.getBlob;function BlobBuilderConstructor(ary,options){options=options||{};var bb=new BlobBuilder;for(var i=0;i<ary.length;i++){bb.append(ary[i])}return options.type?bb.getBlob(options.type):bb.getBlob()}module.exports=function(){if(blobSupported){return global.Blob}else if(blobBuilderSupported){return BlobBuilderConstructor}else{return undefined}}()}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],31:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");module.exports=hasBinary;function hasBinary(data){function _hasBinary(obj){if(!obj)return false;if(global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer||global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){return true}if(isArray(obj)){for(var i=0;i<obj.length;i++){if(_hasBinary(obj[i])){return true}}}else if(obj&&"object"==typeof obj){if(obj.toJSON){obj=obj.toJSON()}for(var key in obj){if(obj.hasOwnProperty(key)&&_hasBinary(obj[key])){return true}}}return false}return _hasBinary(data)}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{isarray:32}],32:[function(_dereq_,module,exports){module.exports=Array.isArray||function(arr){return Object.prototype.toString.call(arr)=="[object Array]"}},{}],33:[function(_dereq_,module,exports){(function(global){(function(root){var freeExports=typeof exports=="object"&&exports;var freeModule=typeof module=="object"&&module&&module.exports==freeExports&&module;var freeGlobal=typeof global=="object"&&global;if(freeGlobal.global===freeGlobal||freeGlobal.window===freeGlobal){root=freeGlobal}var stringFromCharCode=String.fromCharCode;function ucs2decode(string){var output=[];var counter=0;var length=string.length;var value;var extra;while(counter<length){value=string.charCodeAt(counter++);if(value>=55296&&value<=56319&&counter<length){extra=string.charCodeAt(counter++);if((extra&64512)==56320){output.push(((value&1023)<<10)+(extra&1023)+65536)}else{output.push(value);counter--}}else{output.push(value)}}return output}function ucs2encode(array){var length=array.length;var index=-1;var value;var output="";while(++index<length){value=array[index];if(value>65535){value-=65536;
output+=stringFromCharCode(value>>>10&1023|55296);value=56320|value&1023}output+=stringFromCharCode(value)}return output}function createByte(codePoint,shift){return stringFromCharCode(codePoint>>shift&63|128)}function encodeCodePoint(codePoint){if((codePoint&4294967168)==0){return stringFromCharCode(codePoint)}var symbol="";if((codePoint&4294965248)==0){symbol=stringFromCharCode(codePoint>>6&31|192)}else if((codePoint&4294901760)==0){symbol=stringFromCharCode(codePoint>>12&15|224);symbol+=createByte(codePoint,6)}else if((codePoint&4292870144)==0){symbol=stringFromCharCode(codePoint>>18&7|240);symbol+=createByte(codePoint,12);symbol+=createByte(codePoint,6)}symbol+=stringFromCharCode(codePoint&63|128);return symbol}function utf8encode(string){var codePoints=ucs2decode(string);var length=codePoints.length;var index=-1;var codePoint;var byteString="";while(++index<length){codePoint=codePoints[index];byteString+=encodeCodePoint(codePoint)}return byteString}function readContinuationByte(){if(byteIndex>=byteCount){throw Error("Invalid byte index")}var continuationByte=byteArray[byteIndex]&255;byteIndex++;if((continuationByte&192)==128){return continuationByte&63}throw Error("Invalid continuation byte")}function decodeSymbol(){var byte1;var byte2;var byte3;var byte4;var codePoint;if(byteIndex>byteCount){throw Error("Invalid byte index")}if(byteIndex==byteCount){return false}byte1=byteArray[byteIndex]&255;byteIndex++;if((byte1&128)==0){return byte1}if((byte1&224)==192){var byte2=readContinuationByte();codePoint=(byte1&31)<<6|byte2;if(codePoint>=128){return codePoint}else{throw Error("Invalid continuation byte")}}if((byte1&240)==224){byte2=readContinuationByte();byte3=readContinuationByte();codePoint=(byte1&15)<<12|byte2<<6|byte3;if(codePoint>=2048){return codePoint}else{throw Error("Invalid continuation byte")}}if((byte1&248)==240){byte2=readContinuationByte();byte3=readContinuationByte();byte4=readContinuationByte();codePoint=(byte1&15)<<18|byte2<<12|byte3<<6|byte4;if(codePoint>=65536&&codePoint<=1114111){return codePoint}}throw Error("Invalid UTF-8 detected")}var byteArray;var byteCount;var byteIndex;function utf8decode(byteString){byteArray=ucs2decode(byteString);byteCount=byteArray.length;byteIndex=0;var codePoints=[];var tmp;while((tmp=decodeSymbol())!==false){codePoints.push(tmp)}return ucs2encode(codePoints)}var utf8={version:"2.0.0",encode:utf8encode,decode:utf8decode};if(typeof define=="function"&&typeof define.amd=="object"&&define.amd){define(function(){return utf8})}else if(freeExports&&!freeExports.nodeType){if(freeModule){freeModule.exports=utf8}else{var object={};var hasOwnProperty=object.hasOwnProperty;for(var key in utf8){hasOwnProperty.call(utf8,key)&&(freeExports[key]=utf8[key])}}}else{root.utf8=utf8}})(this)}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],34:[function(_dereq_,module,exports){(function(global){var rvalidchars=/^[\],:{}\s]*$/;var rvalidescape=/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;var rvalidtokens=/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;var rvalidbraces=/(?:^|:|,)(?:\s*\[)+/g;var rtrimLeft=/^\s+/;var rtrimRight=/\s+$/;module.exports=function parsejson(data){if("string"!=typeof data||!data){return null}data=data.replace(rtrimLeft,"").replace(rtrimRight,"");if(global.JSON&&JSON.parse){return JSON.parse(data)}if(rvalidchars.test(data.replace(rvalidescape,"@").replace(rvalidtokens,"]").replace(rvalidbraces,""))){return new Function("return "+data)()}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],35:[function(_dereq_,module,exports){exports.encode=function(obj){var str="";for(var i in obj){if(obj.hasOwnProperty(i)){if(str.length)str+="&";str+=encodeURIComponent(i)+"="+encodeURIComponent(obj[i])}}return str};exports.decode=function(qs){var qry={};var pairs=qs.split("&");for(var i=0,l=pairs.length;i<l;i++){var pair=pairs[i].split("=");qry[decodeURIComponent(pair[0])]=decodeURIComponent(pair[1])}return qry}},{}],36:[function(_dereq_,module,exports){var re=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;var parts=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];module.exports=function parseuri(str){var src=str,b=str.indexOf("["),e=str.indexOf("]");if(b!=-1&&e!=-1){str=str.substring(0,b)+str.substring(b,e).replace(/:/g,";")+str.substring(e,str.length)}var m=re.exec(str||""),uri={},i=14;while(i--){uri[parts[i]]=m[i]||""}if(b!=-1&&e!=-1){uri.source=src;uri.host=uri.host.substring(1,uri.host.length-1).replace(/;/g,":");uri.authority=uri.authority.replace("[","").replace("]","").replace(/;/g,":");uri.ipv6uri=true}return uri}},{}],37:[function(_dereq_,module,exports){var global=function(){return this}();var WebSocket=global.WebSocket||global.MozWebSocket;module.exports=WebSocket?ws:null;function ws(uri,protocols,opts){var instance;if(protocols){instance=new WebSocket(uri,protocols)}else{instance=new WebSocket(uri)}return instance}if(WebSocket)ws.prototype=WebSocket.prototype},{}],38:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");module.exports=hasBinary;function hasBinary(data){function _hasBinary(obj){if(!obj)return false;if(global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer||global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){return true}if(isArray(obj)){for(var i=0;i<obj.length;i++){if(_hasBinary(obj[i])){return true}}}else if(obj&&"object"==typeof obj){if(obj.toJSON){obj=obj.toJSON()}for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)&&_hasBinary(obj[key])){return true}}}return false}return _hasBinary(data)}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{isarray:39}],39:[function(_dereq_,module,exports){module.exports=_dereq_(32)},{}],40:[function(_dereq_,module,exports){var global=_dereq_("global");try{module.exports="XMLHttpRequest"in global&&"withCredentials"in new global.XMLHttpRequest}catch(err){module.exports=false}},{global:41}],41:[function(_dereq_,module,exports){module.exports=function(){return this}()},{}],42:[function(_dereq_,module,exports){var indexOf=[].indexOf;module.exports=function(arr,obj){if(indexOf)return arr.indexOf(obj);for(var i=0;i<arr.length;++i){if(arr[i]===obj)return i}return-1}},{}],43:[function(_dereq_,module,exports){var has=Object.prototype.hasOwnProperty;exports.keys=Object.keys||function(obj){var keys=[];for(var key in obj){if(has.call(obj,key)){keys.push(key)}}return keys};exports.values=function(obj){var vals=[];for(var key in obj){if(has.call(obj,key)){vals.push(obj[key])}}return vals};exports.merge=function(a,b){for(var key in b){if(has.call(b,key)){a[key]=b[key]}}return a};exports.length=function(obj){return exports.keys(obj).length};exports.isEmpty=function(obj){return 0==exports.length(obj)}},{}],44:[function(_dereq_,module,exports){var re=/^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;var parts=["source","protocol","authority","userInfo","user","password","host","port","relative","path","directory","file","query","anchor"];module.exports=function parseuri(str){var m=re.exec(str||""),uri={},i=14;while(i--){uri[parts[i]]=m[i]||""}return uri}},{}],45:[function(_dereq_,module,exports){(function(global){var isArray=_dereq_("isarray");var isBuf=_dereq_("./is-buffer");exports.deconstructPacket=function(packet){var buffers=[];var packetData=packet.data;function _deconstructPacket(data){if(!data)return data;if(isBuf(data)){var placeholder={_placeholder:true,num:buffers.length};buffers.push(data);return placeholder}else if(isArray(data)){var newData=new Array(data.length);for(var i=0;i<data.length;i++){newData[i]=_deconstructPacket(data[i])}return newData}else if("object"==typeof data&&!(data instanceof Date)){var newData={};for(var key in data){newData[key]=_deconstructPacket(data[key])}return newData}return data}var pack=packet;pack.data=_deconstructPacket(packetData);pack.attachments=buffers.length;return{packet:pack,buffers:buffers}};exports.reconstructPacket=function(packet,buffers){var curPlaceHolder=0;function _reconstructPacket(data){if(data&&data._placeholder){var buf=buffers[data.num];return buf}else if(isArray(data)){for(var i=0;i<data.length;i++){data[i]=_reconstructPacket(data[i])}return data}else if(data&&"object"==typeof data){for(var key in data){data[key]=_reconstructPacket(data[key])}return data}return data}packet.data=_reconstructPacket(packet.data);packet.attachments=undefined;return packet};exports.removeBlobs=function(data,callback){function _removeBlobs(obj,curKey,containingObject){if(!obj)return obj;if(global.Blob&&obj instanceof Blob||global.File&&obj instanceof File){pendingBlobs++;var fileReader=new FileReader;fileReader.onload=function(){if(containingObject){containingObject[curKey]=this.result}else{bloblessData=this.result}if(!--pendingBlobs){callback(bloblessData)}};fileReader.readAsArrayBuffer(obj)}else if(isArray(obj)){for(var i=0;i<obj.length;i++){_removeBlobs(obj[i],i,obj)}}else if(obj&&"object"==typeof obj&&!isBuf(obj)){for(var key in obj){_removeBlobs(obj[key],key,obj)}}}var pendingBlobs=0;var bloblessData=data;_removeBlobs(bloblessData);if(!pendingBlobs){callback(bloblessData)}}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"./is-buffer":47,isarray:48}],46:[function(_dereq_,module,exports){var debug=_dereq_("debug")("socket.io-parser");var json=_dereq_("json3");var isArray=_dereq_("isarray");var Emitter=_dereq_("component-emitter");var binary=_dereq_("./binary");var isBuf=_dereq_("./is-buffer");exports.protocol=4;exports.types=["CONNECT","DISCONNECT","EVENT","BINARY_EVENT","ACK","BINARY_ACK","ERROR"];exports.CONNECT=0;exports.DISCONNECT=1;exports.EVENT=2;exports.ACK=3;exports.ERROR=4;exports.BINARY_EVENT=5;exports.BINARY_ACK=6;exports.Encoder=Encoder;exports.Decoder=Decoder;function Encoder(){}Encoder.prototype.encode=function(obj,callback){debug("encoding packet %j",obj);if(exports.BINARY_EVENT==obj.type||exports.BINARY_ACK==obj.type){encodeAsBinary(obj,callback)}else{var encoding=encodeAsString(obj);callback([encoding])}};function encodeAsString(obj){var str="";var nsp=false;str+=obj.type;if(exports.BINARY_EVENT==obj.type||exports.BINARY_ACK==obj.type){str+=obj.attachments;str+="-"}if(obj.nsp&&"/"!=obj.nsp){nsp=true;str+=obj.nsp}if(null!=obj.id){if(nsp){str+=",";nsp=false}str+=obj.id}if(null!=obj.data){if(nsp)str+=",";str+=json.stringify(obj.data)}debug("encoded %j as %s",obj,str);return str}function encodeAsBinary(obj,callback){function writeEncoding(bloblessData){var deconstruction=binary.deconstructPacket(bloblessData);var pack=encodeAsString(deconstruction.packet);var buffers=deconstruction.buffers;buffers.unshift(pack);callback(buffers)}binary.removeBlobs(obj,writeEncoding)}function Decoder(){this.reconstructor=null}Emitter(Decoder.prototype);Decoder.prototype.add=function(obj){var packet;if("string"==typeof obj){packet=decodeString(obj);if(exports.BINARY_EVENT==packet.type||exports.BINARY_ACK==packet.type){this.reconstructor=new BinaryReconstructor(packet);if(this.reconstructor.reconPack.attachments===0){this.emit("decoded",packet)}}else{this.emit("decoded",packet)}}else if(isBuf(obj)||obj.base64){if(!this.reconstructor){throw new Error("got binary data when not reconstructing a packet")}else{packet=this.reconstructor.takeBinaryData(obj);if(packet){this.reconstructor=null;this.emit("decoded",packet)}}}else{throw new Error("Unknown type: "+obj)}};function decodeString(str){var p={};var i=0;p.type=Number(str.charAt(0));if(null==exports.types[p.type])return error();if(exports.BINARY_EVENT==p.type||exports.BINARY_ACK==p.type){var buf="";while(str.charAt(++i)!="-"){buf+=str.charAt(i);if(i+1==str.length)break}if(buf!=Number(buf)||str.charAt(i)!="-"){throw new Error("Illegal attachments")}p.attachments=Number(buf)}if("/"==str.charAt(i+1)){p.nsp="";while(++i){var c=str.charAt(i);if(","==c)break;p.nsp+=c;if(i+1==str.length)break}}else{p.nsp="/"}var next=str.charAt(i+1);if(""!==next&&Number(next)==next){p.id="";while(++i){var c=str.charAt(i);if(null==c||Number(c)!=c){--i;break}p.id+=str.charAt(i);if(i+1==str.length)break}p.id=Number(p.id)}if(str.charAt(++i)){try{p.data=json.parse(str.substr(i))}catch(e){return error()}}debug("decoded %s as %j",str,p);return p}Decoder.prototype.destroy=function(){if(this.reconstructor){this.reconstructor.finishedReconstruction()}};function BinaryReconstructor(packet){this.reconPack=packet;this.buffers=[]}BinaryReconstructor.prototype.takeBinaryData=function(binData){this.buffers.push(binData);if(this.buffers.length==this.reconPack.attachments){var packet=binary.reconstructPacket(this.reconPack,this.buffers);this.finishedReconstruction();return packet}return null};BinaryReconstructor.prototype.finishedReconstruction=function(){this.reconPack=null;this.buffers=[]};function error(data){return{type:exports.ERROR,data:"parser error"}}},{"./binary":45,"./is-buffer":47,"component-emitter":9,debug:10,isarray:48,json3:49}],47:[function(_dereq_,module,exports){(function(global){module.exports=isBuf;function isBuf(obj){return global.Buffer&&global.Buffer.isBuffer(obj)||global.ArrayBuffer&&obj instanceof ArrayBuffer}}).call(this,typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{}],48:[function(_dereq_,module,exports){module.exports=_dereq_(32)},{}],49:[function(_dereq_,module,exports){(function(window){var getClass={}.toString,isProperty,forEach,undef;var isLoader=typeof define==="function"&&define.amd;var nativeJSON=typeof JSON=="object"&&JSON;var JSON3=typeof exports=="object"&&exports&&!exports.nodeType&&exports;if(JSON3&&nativeJSON){JSON3.stringify=nativeJSON.stringify;JSON3.parse=nativeJSON.parse}else{JSON3=window.JSON=nativeJSON||{}}var isExtended=new Date(-0xc782b5b800cec);try{isExtended=isExtended.getUTCFullYear()==-109252&&isExtended.getUTCMonth()===0&&isExtended.getUTCDate()===1&&isExtended.getUTCHours()==10&&isExtended.getUTCMinutes()==37&&isExtended.getUTCSeconds()==6&&isExtended.getUTCMilliseconds()==708}catch(exception){}function has(name){if(has[name]!==undef){return has[name]}var isSupported;if(name=="bug-string-char-index"){isSupported="a"[0]!="a"}else if(name=="json"){isSupported=has("json-stringify")&&has("json-parse")}else{var value,serialized='{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';if(name=="json-stringify"){var stringify=JSON3.stringify,stringifySupported=typeof stringify=="function"&&isExtended;if(stringifySupported){(value=function(){return 1}).toJSON=value;try{stringifySupported=stringify(0)==="0"&&stringify(new Number)==="0"&&stringify(new String)=='""'&&stringify(getClass)===undef&&stringify(undef)===undef&&stringify()===undef&&stringify(value)==="1"&&stringify([value])=="[1]"&&stringify([undef])=="[null]"&&stringify(null)=="null"&&stringify([undef,getClass,null])=="[null,null,null]"&&stringify({a:[value,true,false,null,"\x00\b\n\f\r "]})==serialized&&stringify(null,value)==="1"&&stringify([1,2],null,1)=="[\n 1,\n 2\n]"&&stringify(new Date(-864e13))=='"-271821-04-20T00:00:00.000Z"'&&stringify(new Date(864e13))=='"+275760-09-13T00:00:00.000Z"'&&stringify(new Date(-621987552e5))=='"-000001-01-01T00:00:00.000Z"'&&stringify(new Date(-1))=='"1969-12-31T23:59:59.999Z"'}catch(exception){stringifySupported=false}}isSupported=stringifySupported}if(name=="json-parse"){var parse=JSON3.parse;if(typeof parse=="function"){try{if(parse("0")===0&&!parse(false)){value=parse(serialized);var parseSupported=value["a"].length==5&&value["a"][0]===1;if(parseSupported){try{parseSupported=!parse('"  "')}catch(exception){}if(parseSupported){try{parseSupported=parse("01")!==1}catch(exception){}}if(parseSupported){try{parseSupported=parse("1.")!==1}catch(exception){}}}}}catch(exception){parseSupported=false}}isSupported=parseSupported}}return has[name]=!!isSupported}if(!has("json")){var functionClass="[object Function]";var dateClass="[object Date]";var numberClass="[object Number]";var stringClass="[object String]";var arrayClass="[object Array]";var booleanClass="[object Boolean]";var charIndexBuggy=has("bug-string-char-index");if(!isExtended){var floor=Math.floor;var Months=[0,31,59,90,120,151,181,212,243,273,304,334];var getDay=function(year,month){return Months[month]+365*(year-1970)+floor((year-1969+(month=+(month>1)))/4)-floor((year-1901+month)/100)+floor((year-1601+month)/400)}}if(!(isProperty={}.hasOwnProperty)){isProperty=function(property){var members={},constructor;if((members.__proto__=null,members.__proto__={toString:1},members).toString!=getClass){isProperty=function(property){var original=this.__proto__,result=property in(this.__proto__=null,this);this.__proto__=original;return result}}else{constructor=members.constructor;isProperty=function(property){var parent=(this.constructor||constructor).prototype;return property in this&&!(property in parent&&this[property]===parent[property])}}members=null;return isProperty.call(this,property)}}var PrimitiveTypes={"boolean":1,number:1,string:1,undefined:1};var isHostType=function(object,property){var type=typeof object[property];return type=="object"?!!object[property]:!PrimitiveTypes[type]};forEach=function(object,callback){var size=0,Properties,members,property;(Properties=function(){this.valueOf=0}).prototype.valueOf=0;members=new Properties;for(property in members){if(isProperty.call(members,property)){size++}}Properties=members=null;if(!size){members=["valueOf","toString","toLocaleString","propertyIsEnumerable","isPrototypeOf","hasOwnProperty","constructor"];forEach=function(object,callback){var isFunction=getClass.call(object)==functionClass,property,length;var hasProperty=!isFunction&&typeof object.constructor!="function"&&isHostType(object,"hasOwnProperty")?object.hasOwnProperty:isProperty;for(property in object){if(!(isFunction&&property=="prototype")&&hasProperty.call(object,property)){callback(property)}}for(length=members.length;property=members[--length];hasProperty.call(object,property)&&callback(property));}}else if(size==2){forEach=function(object,callback){var members={},isFunction=getClass.call(object)==functionClass,property;for(property in object){if(!(isFunction&&property=="prototype")&&!isProperty.call(members,property)&&(members[property]=1)&&isProperty.call(object,property)){callback(property)}}}}else{forEach=function(object,callback){var isFunction=getClass.call(object)==functionClass,property,isConstructor;for(property in object){if(!(isFunction&&property=="prototype")&&isProperty.call(object,property)&&!(isConstructor=property==="constructor")){callback(property)}}if(isConstructor||isProperty.call(object,property="constructor")){callback(property)}}}return forEach(object,callback)};if(!has("json-stringify")){var Escapes={92:"\\\\",34:'\\"',8:"\\b",12:"\\f",10:"\\n",13:"\\r",9:"\\t"};var leadingZeroes="000000";var toPaddedString=function(width,value){return(leadingZeroes+(value||0)).slice(-width)};var unicodePrefix="\\u00";var quote=function(value){var result='"',index=0,length=value.length,isLarge=length>10&&charIndexBuggy,symbols;if(isLarge){symbols=value.split("")}for(;index<length;index++){var charCode=value.charCodeAt(index);switch(charCode){case 8:case 9:case 10:case 12:case 13:case 34:case 92:result+=Escapes[charCode];break;default:if(charCode<32){result+=unicodePrefix+toPaddedString(2,charCode.toString(16));break}result+=isLarge?symbols[index]:charIndexBuggy?value.charAt(index):value[index]}}return result+'"'};var serialize=function(property,object,callback,properties,whitespace,indentation,stack){var value,className,year,month,date,time,hours,minutes,seconds,milliseconds,results,element,index,length,prefix,result;try{value=object[property]}catch(exception){}if(typeof value=="object"&&value){className=getClass.call(value);if(className==dateClass&&!isProperty.call(value,"toJSON")){if(value>-1/0&&value<1/0){if(getDay){date=floor(value/864e5);for(year=floor(date/365.2425)+1970-1;getDay(year+1,0)<=date;year++);for(month=floor((date-getDay(year,0))/30.42);getDay(year,month+1)<=date;month++);date=1+date-getDay(year,month);time=(value%864e5+864e5)%864e5;hours=floor(time/36e5)%24;minutes=floor(time/6e4)%60;seconds=floor(time/1e3)%60;milliseconds=time%1e3}else{year=value.getUTCFullYear();month=value.getUTCMonth();date=value.getUTCDate();hours=value.getUTCHours();minutes=value.getUTCMinutes();seconds=value.getUTCSeconds();milliseconds=value.getUTCMilliseconds()}value=(year<=0||year>=1e4?(year<0?"-":"+")+toPaddedString(6,year<0?-year:year):toPaddedString(4,year))+"-"+toPaddedString(2,month+1)+"-"+toPaddedString(2,date)+"T"+toPaddedString(2,hours)+":"+toPaddedString(2,minutes)+":"+toPaddedString(2,seconds)+"."+toPaddedString(3,milliseconds)+"Z"}else{value=null}}else if(typeof value.toJSON=="function"&&(className!=numberClass&&className!=stringClass&&className!=arrayClass||isProperty.call(value,"toJSON"))){value=value.toJSON(property)}}if(callback){value=callback.call(object,property,value)}if(value===null){return"null"}className=getClass.call(value);if(className==booleanClass){return""+value}else if(className==numberClass){return value>-1/0&&value<1/0?""+value:"null"}else if(className==stringClass){return quote(""+value)}if(typeof value=="object"){for(length=stack.length;length--;){if(stack[length]===value){throw TypeError()}}stack.push(value);results=[];prefix=indentation;indentation+=whitespace;if(className==arrayClass){for(index=0,length=value.length;index<length;index++){element=serialize(index,value,callback,properties,whitespace,indentation,stack);results.push(element===undef?"null":element)}result=results.length?whitespace?"[\n"+indentation+results.join(",\n"+indentation)+"\n"+prefix+"]":"["+results.join(",")+"]":"[]"}else{forEach(properties||value,function(property){var element=serialize(property,value,callback,properties,whitespace,indentation,stack);if(element!==undef){results.push(quote(property)+":"+(whitespace?" ":"")+element)}});result=results.length?whitespace?"{\n"+indentation+results.join(",\n"+indentation)+"\n"+prefix+"}":"{"+results.join(",")+"}":"{}"}stack.pop();return result}};JSON3.stringify=function(source,filter,width){var whitespace,callback,properties,className;if(typeof filter=="function"||typeof filter=="object"&&filter){if((className=getClass.call(filter))==functionClass){callback=filter}else if(className==arrayClass){properties={};for(var index=0,length=filter.length,value;index<length;value=filter[index++],(className=getClass.call(value),className==stringClass||className==numberClass)&&(properties[value]=1));}}if(width){if((className=getClass.call(width))==numberClass){if((width-=width%1)>0){for(whitespace="",width>10&&(width=10);whitespace.length<width;whitespace+=" ");}}else if(className==stringClass){whitespace=width.length<=10?width:width.slice(0,10)}}return serialize("",(value={},value[""]=source,value),callback,properties,whitespace,"",[])}}if(!has("json-parse")){var fromCharCode=String.fromCharCode;var Unescapes={92:"\\",34:'"',47:"/",98:"\b",116:"  ",110:"\n",102:"\f",114:"\r"};var Index,Source;var abort=function(){Index=Source=null;throw SyntaxError()};var lex=function(){var source=Source,length=source.length,value,begin,position,isSigned,charCode;while(Index<length){charCode=source.charCodeAt(Index);switch(charCode){case 9:case 10:case 13:case 32:Index++;break;case 123:case 125:case 91:case 93:case 58:case 44:value=charIndexBuggy?source.charAt(Index):source[Index];Index++;return value;case 34:for(value="@",Index++;Index<length;){charCode=source.charCodeAt(Index);if(charCode<32){abort()}else if(charCode==92){charCode=source.charCodeAt(++Index);switch(charCode){case 92:case 34:case 47:case 98:case 116:case 110:case 102:case 114:value+=Unescapes[charCode];Index++;break;case 117:begin=++Index;for(position=Index+4;Index<position;Index++){charCode=source.charCodeAt(Index);if(!(charCode>=48&&charCode<=57||charCode>=97&&charCode<=102||charCode>=65&&charCode<=70)){abort()}}value+=fromCharCode("0x"+source.slice(begin,Index));break;default:abort()}}else{if(charCode==34){break}charCode=source.charCodeAt(Index);begin=Index;while(charCode>=32&&charCode!=92&&charCode!=34){charCode=source.charCodeAt(++Index)}value+=source.slice(begin,Index)}}if(source.charCodeAt(Index)==34){Index++;return value}abort();default:begin=Index;if(charCode==45){isSigned=true;charCode=source.charCodeAt(++Index)}if(charCode>=48&&charCode<=57){if(charCode==48&&(charCode=source.charCodeAt(Index+1),charCode>=48&&charCode<=57)){abort()}isSigned=false;for(;Index<length&&(charCode=source.charCodeAt(Index),charCode>=48&&charCode<=57);Index++);if(source.charCodeAt(Index)==46){position=++Index;for(;position<length&&(charCode=source.charCodeAt(position),charCode>=48&&charCode<=57);position++);if(position==Index){abort()}Index=position}charCode=source.charCodeAt(Index);if(charCode==101||charCode==69){charCode=source.charCodeAt(++Index);if(charCode==43||charCode==45){Index++}for(position=Index;position<length&&(charCode=source.charCodeAt(position),charCode>=48&&charCode<=57);position++);if(position==Index){abort()}Index=position}return+source.slice(begin,Index)}if(isSigned){abort()}if(source.slice(Index,Index+4)=="true"){Index+=4;return true}else if(source.slice(Index,Index+5)=="false"){Index+=5;return false}else if(source.slice(Index,Index+4)=="null"){Index+=4;return null}abort()}}return"$"};var get=function(value){var results,hasMembers;if(value=="$"){abort()}if(typeof value=="string"){if((charIndexBuggy?value.charAt(0):value[0])=="@"){return value.slice(1)}if(value=="["){results=[];for(;;hasMembers||(hasMembers=true)){value=lex();if(value=="]"){break}if(hasMembers){if(value==","){value=lex();if(value=="]"){abort()}}else{abort()}}if(value==","){abort()}results.push(get(value))}return results}else if(value=="{"){results={};for(;;hasMembers||(hasMembers=true)){value=lex();if(value=="}"){break}if(hasMembers){if(value==","){value=lex();if(value=="}"){abort()}}else{abort()}}if(value==","||typeof value!="string"||(charIndexBuggy?value.charAt(0):value[0])!="@"||lex()!=":"){abort()}results[value.slice(1)]=get(lex())}return results}abort()}return value};var update=function(source,property,callback){var element=walk(source,property,callback);if(element===undef){delete source[property]}else{source[property]=element}};var walk=function(source,property,callback){var value=source[property],length;if(typeof value=="object"&&value){if(getClass.call(value)==arrayClass){for(length=value.length;length--;){update(value,length,callback)}}else{forEach(value,function(property){update(value,property,callback)})}}return callback.call(source,property,value)};JSON3.parse=function(source,callback){var result,value;Index=0;Source=""+source;result=get(lex());if(lex()!="$"){abort()}Index=Source=null;return callback&&getClass.call(callback)==functionClass?walk((value={},value[""]=result,value),"",callback):result}}}if(isLoader){define(function(){return JSON3})}})(this)},{}],50:[function(_dereq_,module,exports){module.exports=toArray;function toArray(list,index){var array=[];index=index||0;for(var i=index||0;i<list.length;i++){array[i-index]=list[i]}return array}},{}]},{},[1])(1)});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/element.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../../../util')
  , element = require('../../element')
  , utilHash = require('../../../util/hash')
  , vObject = require('../../../object')

/*this file has nothing to do with the networkdata Class
  it only reads out models for elements so you can make a subscription
*/

function sortField( filter, obj ) {
  if( filter.sort && filter.sort.field ) 
  {
    var sort = { $:{} }
    sort.$[filter.sort.field] = true
    util.merge( obj, sort )
  }

  return obj
}

//TODO: has to work in the hub
var disableSelections = true

exports.parseData = function( val, fromtargets, logger ) {


  //important for unSubscribe ???
    // console.log('LETS PARSE DATA!'.cyan.inverse , val, JSON.stringify(fromtargets))
  

  // console.log('LETS PARSE DATA!'.cyan.inverse , val, JSON.stringify(fromtargets))

  if(!val) return
    // console.log('LETS PARSE DATA!2'.cyan.inverse , val, JSON.stringify(fromtargets))

  var subsobj = {}
    , f = val._filter
    , targets = fromtargets || val.__sub

  if (targets) {
    // console.log('targets', targets)
    if (f && !disableSelections) {
      if(!subsobj['*']) subsobj['*']=[]
      subsobj['*'].push([
        util.clone(f, {subsObj:true, fn:true, type:true})
        , sortField(f, fromtargets || { $: targets })
      ])

    // console.log( 'IM DOING SELECTS parseDatelex', subsobj )
    //TEMPFIX!!!!
    for(var i in subsobj['*'][1] ) {
      //wel ff de fields ook doen prob

      subsobj[i] = subsobj['*'][1][i]
    }
    delete subsobj['*']

    } else {
          // console.log( 'targets IM DOING SELECTS parseDatelex', targets )

      subsobj = targets
    }
  } else {
        // console.log('LETS PARSE DATA!4'.cyan.inverse , val, JSON.stringify(fromtargets))

    // console.warn( 'cant\'t find target -- lets do stuff!', val  )
    //TODO:guard voor als het het niet wil -- mischiend door _subs zoeken

    // if(val._path) {
    //   console.log(val._path)
    // }

    //no tragets dont do anything?
  }

  // console.log('RESULT!', JSON.stringify(subsobj))

  return subsobj
}

function setFlag( obj, string, flag, field, val, from, elem ) {



  var nonCloudDataBindings
    , fromKey

    , beTripppin


  if( from ) {
    fromKey = from._name !== void 0 ? from._name : from

    if( from instanceof vObject) {

      //tegenover gestelde bij
      // if(from.__t === 4) {
        // if(from._val && from._val.cloud) {
          //haal juist field weg
        // }
      // } 
      // console.log('FROM!', from._name, from._path )
      fromKey = from._name
    }

    if(from instanceof Array && from[1]) {
      // console.log('be tripping!', from)
      //   fromKey = from[1] && from[1]._name

      // beTripppin = from[0]._name

    }

  }

  var dd = elem && from && ( elem._d || elem.checkParent('data', true) )

  // if(beTripppin) {
  //   console.log(dd, fromKey, beTripppin)
  // }


  if (field === 'collection') {
    var obj2

    if (flag.filter && flag.filter.val!==true && !disableSelections) 
    {
      //dit nog handelen op refs
      obj2 = {}


      //ENABLE FOR SELECTION
      // if (string === true) {

      //   string = '*'
      // } else {

      //   string = string + '.*'
      // }
      var f = flag.filter.raw

        // console.log( 'SET FLAG', arguments )


  // console.log( 'FIELD!:', field , 'FROM:', from,  string.split('.'), string )

      var arr = util.path(obj, string.split('.'), [])

      arr.push( 
        [f, {
          $: sortField(f,obj2)
        }]
      )

      //obj, path, val, overwrite

      //TEMPFIX!!!!
      var temp = util.path( obj, string.split('.'), {}, true )
      for(var i in arr[arr.length-1][1] ) {
        //wel ff de fields ook doen prob

        temp[i] = arr[arr.length-1][1][i]
      }
      arr = temp

          // console.log( 'IM DOING SELECPS COL COL!', arr )


    } else {

      var f = string === true ? '$' : string + '.$'
        , p =  f.split('.')

        , specialFix

      if( dd && dd[ fromKey ] ) 
      {
        nonCloudDataBindings = true
        if( p[0] === fromKey ) 
        {
          p.shift()
          nonCloudDataBindings = false
        }
      }

      if( nonCloudDataBindings ) 
      {
        if(specialFix) {
          obj.specialFix = fromKey
          if(beTripppin) {
            obj.specialFix = [ fromKey, beTripppin ]
          }
          obj2 = util.path(obj, p , {})
          readModel(flag.element._val instanceof element ? flag.element._val : flag.element._val.base, obj2 )
        }
      } 
      else 
      {
        obj2 = util.path(obj, p , {})
        readModel(flag.element._val instanceof element ? flag.element._val : flag.element._val.base, obj2 )
      }

    }

                  // console.log(  'xxxXX1112222XXxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )


  } else {

    if( dd && dd[ fromKey ] ) 
    {
      nonCloudDataBindings = true
    }

    if ( string instanceof Array ) 
    {
      for (var i in string) 
      {
        if( nonCloudDataBindings )
        {
          //TODO: this is a tempfix
          // console.log('NON cloud bindings', string, string[i])
          if( string[i] instanceof Array ) {
            // console.log('!@!@!@')
            string[i] = string[i][0]
          }
          string[i] = string[i].split('.')
          if( string[i][0] === fromKey ) 
          {
            string[i].shift()
            util.path( obj, string[i], true )
          }
        }
        else
        {
          //TODO: this is a tempfix
          // console.log('OBJ:' , obj, 'STRING[i]:', string[i], 'STRING:', string, fromKey)
           if( string[i] instanceof Array ) {
            // console.log('2!@!@!@')
            string[i] = string[i][0]
          }
          util.path(obj, string[i].split('.'), true)
        }
      }
    } 
    else if ( string !== true && typeof string === 'string' ) 
    {
              // console.log(  'xxxXXXXxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )

      if( nonCloudDataBindings )
      {
        // console.log( nonCloudDataBindings , 'NONCLOUD')
          string = string.split('.')
          if( string[0] === fromKey ) 
          {
            string.shift()
              // console.log( 'FIELD!:222222', string )

            if(string.length > 0) util.path( obj, string, true )
          }
          // console.log( nonCloudDataBindings , 'NONCLOUD', string, obj )
      }
      else
      {
        // console.log(  'xxxxx', string, obj ) //, fromKey, elem._d, elem.data, elem.checkParent('data', true) )
        util.path( obj, string.split('.'), true )
      }
    } 
    else 
    {
      // console.log('----> 2'.inverse, string, obj, flag, field)
      // console.error('xxxxxx')
      // obj['__#__'] = true
      // obj = true;
      // console.log('!!!',obj, parent);
      // obj['#'] = true;
    }
    

  }
}

function store( obj, flag, field, val, from, elem ) {

  // console.log('STORE', arguments )

  if (flag instanceof Array) {
    for (var i = 0, l = flag.length; i < l; i++) {
      setFlag(obj, flag[i]._flag.data[2], flag, field, val, from, elem )

    }
  } else {
        // console.log('------>'.red,flag)

    setFlag(obj, flag._flag.data[2], flag, field, val, from, elem )
  }
}

function readModel( elem, obj, val, from , ignorefield) {

  // console.log( 'lets read model'.yellow.inverse, val && val._path || 'no valPath', from && from._path || 'no fromPath' , val, elem, obj, val, from )
    //hier moet het gecombineerd worden met een value waar het aan gebind is!

  if (elem.model && (elem.model.flags||elem.model.subscription||elem.model.field)) {
    
    // if(obj) console.log('XXX121212XXX COLLECTION',  elem.model.field && elem.model.field.val )
    // console.log('SET SORTFIELD! 2.12', JSON.stringify(obj,false,2), elem.model.field && elem.model.field.val)

    var a = obj
      , field
      , doItIgnoreFlags

      //["users", "U_ba3215a1b1038a70", "navigation", "episode"] 
    // console.log( '\n\n\n\n\n-------->', elem.model.field && elem.model.field.val, elem.model.parsing && !elem.model.parsed  )

    if(ignorefield) {
      // console.log('STOP! ignorefield', obj, elem.model.field && elem.model.field.val, from, from && from._path)
      // debugger
    }
    //TODO: compare arrays 
    else if(elem.model.field && elem.model.field.val && !elem.model.parsing && !elem.modelParsed && ( typeof from !== 'string' || elem.model.field.val === from  )  ) {
      field = elem.model.field.val.split('.')
      
      if( elem.model.field.val === from ) {

        // console.log('HERE ITS INTERESTING DO', elem.model.field.val , from )

      } else {
        a = util.path(obj,field,{},true)
        doItIgnoreFlags = true
      }

    } else {
      if(from && elem.model.field && elem.model.field.val !== from) {
        return void 0
      }
    }

    if(elem.model && elem.model.subscription ) {

      var subs = elem.model.subscription.raw
      if(subs === true) {
        if(field) {
          if(field.length>1) {
          a = util.path(obj,field,true,true)
          } else {
            obj[field[0]] = true
            a = true
          }
        }
      } else {
        var sub = elem.model.subscription.raw
        if( typeof sub === 'string' ) {
          var old = sub
          sub = {}
          sub[old] = true
        }
        util.merge(a,sub)
      }
    }

    for (var i in elem.model.flags) {
      store(a, elem.model.flags[i], i, val, from, elem )
    }
    
  }

  if( !elem.model || !elem.model.block || !elem.model.block.val ) {

    for (
      var children = elem.children
      , child
      , child$ = 0
      , children$len = children && children.length
      ; child$ < children$len
      ; child = child$++
    ) {
      child = children[child$]
      if ((!child.model || (!child.model.inherit || child.model.inherit.val!==false))
        && !child._col && !child.data || child._dfrom) { //dit kan beter!
        readModel(child, a || obj, val, from )
      //elem, obj, val, from , ignorefield, field
      }
    }
  }

  if(obj['__#__']) {
    // obj.$ = true
    // util.merge(obj, obj['__#__'])
    delete obj['__#__']
  }

  return elem.model && elem.model.block && elem.model.block.val==='all' ? void 0 : obj
}

util.define(element, 'getModel', function( val, from, ignorefield ) {

  var subscription = readModel( this, {}, val, from, ignorefield )

  // console.error('parsed subscription!', JSON.stringify(subscription, false, 2) )
  //waarom komt ie 3x extra?

  return !util.empty( subscription ) ? subscription : null
})
},{"../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","../../element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require('../../../object')
  , data = require('../../../data')
  , Value = require('../../../value')
  , util = require('../../../util')
  , vigour = require('../../../')
  , _networkdata = module.exports = exports = vigour.Networkdata = data.new({
      mixed: 4, //mischien niet mixed
      merge: true
    })
  , _sub = 'subscribe'
  , _unsub = 'un' + _sub
  , _listener = 'Listener'
  , _al = 'add' + _listener
  , _rl = 'remove' + _listener
  , _proto = object.prototype
  , _protoAddListener = _proto[_al]
  , _protoRemoveListener = _proto[_rl]
  , _checkSubscription = function( field, val ) {
      var a = this
      while (a && a.__t === 4) {
        if(a.__block) return
        a = a._val
      }
      // console.log(field, a)
      if((a instanceof _networkdata) && a[field]) a[field](val, this)
    }
  , V = require('../../../')

_networkdata.prototype._blacklist.push('_subs','_complete')
//'_' + _sub, '_' + _unsub, we dont use there now
// _subscribe(_sub);
// _subscribe(_unsub);


//TODO: fix mark!!!!!!!!!!! mark:true
util.define(_networkdata,
  'get', function( val, set, notself, stamp ) {
    
    // IM GETTING! ["users", "u_ba3215a1b1038a70", "mtvData", "NL", "nl", "shows"] undefined
    //obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i
    // var bla = (val instanceof Array) ? val : String(val).split('.')
    // console.log('IM GETTING!', bla, val, set, this, this.path)

    //TODO: Always give me the non-from is possible
    // console.warn('Get -- self is now on on defualt should become something different!')
    //obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self,
    //conditional self

    return this.path
      ( (val instanceof Array) ? val : String(val).split('.')
      , set !== void 0 ? set : {}
      , false
      , false
      , false
      , stamp || false //stampy
      , true
      , !notself
      )

  },
  // '_changevobj', function(val,stamp) {
  //   console.error(val,stamp)
  //   return _changevobj.apply(this,arguments)
  // },
  // '_hook', function(val, param) {
  //   for (var i in param) {
  //     this['_' + i] = param[i];
  //   }
  // }, //dont use this now so lets add when used
  _al, function( val ) {
    // console.log('LETS GO!', _sub, val, !!this[_sub])
    if(this[_sub]) this[_sub](val)
    _protoAddListener.apply( this, arguments )
  },
  _rl, function( val, mark ) {
    if (this._listeners && this[_unsub]) {
      // console.log('REMOVE _L'.red.inverse, mark)
      this[_unsub]( mark )
    }
    _protoRemoveListener.apply( this, arguments )
  }
);

//-------DATA---------
util.define(data, 
  _al, function(val) {
    // console.log('0--------->',val)
    if(!this.__block) _checkSubscription.call(this, _sub, val);
    _protoAddListener.apply(this, arguments);
  },
  _rl, function(val, mark) {
     // console.error('2.1 REMOVE _L', mark, val, _unsub)
    if(!this.__block) _checkSubscription.call(this, _unsub, mark);
    _protoRemoveListener.apply(this, arguments);
  }
);

//-------Value---------

// util.define(Value, //test is this impacts performance to much
//   _al, function(val) {
//     // console.log('0--------->',val)
//     if(!this.__block) _checkSubscription.call(this, _sub, val);
//     _protoAddListener.apply(this, arguments);
//   },
//   _rl, function(val, mark) {
//      // console.error('2.1 REMOVE _L', mark, val, _unsub)
//     if(!this.__block) _checkSubscription.call(this, _unsub, mark);
//     _protoRemoveListener.apply(this, arguments);
//   }
// );





},{"../../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js":[function(require,module,exports){
var util = require('../../util')
  , Value = require('../../value')
  , config = require('../../util/config')
  , process = require('../../value/flags/process')
  , raf = require('../../browser/animation/raf')
  , postpone = require('../../browser/events/util').postpone
  , ua = require('../../browser/ua')

Value.prototype._blacklist.push('_last')

module.exports = exports = new Value()
//TODO: .params /w listeners!

config.hashUrl = ua.device === 'tv' && ua.platform === 'lg' ? false :  config.hashUrl

// history.pushState({}, '','' )
// history.go(0)
// history.back()

var pstate = !config.hashUrl //= !window.DEBUG$ && window.history && window.history.pushState
  , cnt = 0
  , timedState
  , state = postpone ( pstate ? function(val) {
      //load current params as well
      //same goes for the other
      //we could add a delay here!
      href = window.location.href

      console.log(val,  val.replace(/ /g, '+').replace(/^#\//, '').toLowerCase())

      window.history.pushState( {}, val, val.replace(/ /g, '+').replace(/^#\//, '').toLowerCase() )
    } : function(val) {
      exports.block = true
      window.location.href = '#/' + val.replace(/ /g, '+').toLowerCase()
      exports.block = false
    } )
  , _set = Value.prototype._set
  , parse = function() {
      if (!pstate) 
      {
        var url = window.location.href.split('#')
        var params = ''
        if( url && url.length === 1 ) {
          params = query( url[0] )
          url[0] = url[0].replace(params, '')
          // window.location = '#/'+params
          // return = 'x'
        }
        // console.log( url, ( url.length > 1 ? url[1].replace(/\+/g, ' ') : ' ' ).slice(1), params )
        // +params
        return ( url.length > 1 ? url[1].replace(/\+/g, ' ') : ' ' ).slice(1)+params
      } else 
      {
        
        var url = window.location.href
        if( url ) {
          params = query( url )
          url = url.replace(params, '')
          // window.location = '#/'+params
          // return = 'x'
        }

        return String(window.location.href)
               .replace(String(window.location.origin) + '/', '')
               .replace(/^#\//, '')
               .replace(/\+/g, ' ')
               || ''
      }
    }
  , query = function( str ) {
      if(!str) str = parse() || ''
      var arr = str.split('?')
        , len = arr.length
      str = len > 1 && arr[ arr.length - 1 ] ? '?'+arr[ arr.length - 1 ] : ''
      return str
    }

exports.parse = parse

//TODO: back btn hijack (event hijack add random param)
//TODO: use raf for updates
exports.val = { 
  string: function() {
    var str = parse()
    return str.replace( query( str ), '' )
  },
  params: {
    val: function() { return query() },
    defer:function( update, args ) {

      this.clearCache() //maybe not?

      var val = this.val
        , params
        , nestedparams
        , c

      if( val && val!==this._last ) {
        this._last = val
        params = val.slice(1).split('&')
        nestedparams = {}
        for( var i in params ) {
          c = params[i].split('=')
          if( c.length>1 ) 
          {
            nestedparams[c[0]] = c[1]
          }
          else
          {
            console.error('url: no [key]=[value] format -- not implemented yet')
          }
        }
        this.val = nestedparams
      }
      raf(function() { update() })
    }
  },
  transform: function( v, cv ) {
    return cv
  },
  defer: function( update, args ) {
    if( args[1] && args[1][0] === 'u' ) 
    {
      this.clearCache()
      raf( function() {
        update()
      })
    } else 
    {
      this.clearCache()
      var a = ( typeof args[0] === 'string'  ? args[0] : args[0] && args[0].val || this.val )
      if(a) 
      {
        exports.blocks = cnt

        state( a + this.params.val )
      }
      return  true
      //TODO: update( true ) blocks all consecutive updates
    }
  }
}

function urlEvent(e) {
  var stamp

  if( !config.hashUrl || exports.blocks!==cnt ) 
  {
    cnt++
    stamp = 'u'+cnt
    exports.clearCache()
    exports.string.clearCache() //maybe not clear on string?
    // exports._update( parse(), 'url' )
    exports.string._update( exports.string.val , stamp )
    exports.params._update( exports.string.val, stamp )
    exports._update( exports.string.val, stamp )
    exports._lstamp = null

  } else {
    cnt++
  }
}

util.define( exports, 'update', function() {
  urlEvent()
})

util.define( exports.string, 'raw', {
  get:function() {
    return this.val.replace( / /g, '+' )
  }
})

if( config.hashUrl )
{
  window.onhashchange = urlEvent
}
else
{
  window.onpopstate = urlEvent
}
//TODO: add popstate


},{"../../browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","../../browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","../../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js","../../value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../value/flags/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js":[function(require,module,exports){
/*
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
/*
/*
  useragent sniffing is never used for feature detection, for a multi-screen app you do need information about the device also when running in the browser
  has fields V.ua.platform, device, browser and version. This implementation when compiled, is only 700 bytes
*/
var util = require('../util')
/**
 * test
 * search for regexps in the userAgent
 * fn is a on succes callback
 * check http://www.useragentstring.com/ to test for userAgents
 * @method
 */
, test = exports.test = function( _ua, fn ) {

  for
  ( var tests = util.arg( arguments, 1 )
      , i = tests.length - 1
      , query = tests[i][0]
    ; query !== true && !new RegExp( query ).test( _ua )
    ; query = tests[--i][0]
  )

  ;if( fn.slice || fn.call( this, query, tests[i] ) )
  {
    this[fn] = tests[i][1]
  }

}
, parse = exports.parse = function(_ua, obj) {

  if( !_ua )
  {
    obj = exports
    _ua = typeof navigator !== 'undefined'
        ? navigator.userAgent.toLowerCase()
        : 'no navigator'
  }

  _ua = _ua.toLowerCase()

  if( !obj ) obj = {}

  // _ua = 'webos; linux - large screen'

  var _ff = 'firefox'
    , _android = 'android'
    , _mobile = '.+mobile'
    , _webkit = 'webkit'
    , _ps = 'playstation'
    , _xbox = 'xbox'
    , _linux = 'linux'
    , _castDetect = 'crkey'
    , _chromecast = 'chromecast'
    , _tablet = 'tablet'
    , _windows = 'windows'
    , _phone = 'phone'
    , _iphoneVersion

  test.call
  ( obj
  , _ua
  , function( query, arr ) {

      obj.browser = arr[2] || query

      var _v = _ua.match
      ( new RegExp
        ( '((([\\/ ]version|'
        + arr[0]
        + '(?!.+version))[\/ ])| rv:)([0-9]{1,4}\\.[0-9]{0,2})'
        )
      )

      obj.version = _v ? Number( _v[4] ) : 0
      obj.prefix = arr[1]
      //TODO: add prefix for opera v>12.15;
      //TODO: windows check for ie 11 may be too general;
    }
  , [ true, _webkit ]
  , [ '\\(windows', 'ms', 'ie' ]
  , [ 'safari', _webkit ]
  , [ _ff, 'Moz' ]
  , [ 'opera', 'O' ]
  , [ 'msie', 'ms', 'ie' ]
  , [ 'chrome|crios\/', _webkit, 'chrome' ]
  )

  /**
  * platform detection
  */
  test.call
  ( obj
  , _ua
  , 'platform'
  , [ true, _windows ]
  , [ _linux, _linux ]
  , [ 'lg.{0,3}netcast', 'lg' ] //TODO:propably need to add more!
  , [ _ff + _mobile, _ff ]
  , [ 'mac os x', 'mac' ]
  , [ 'iphone|ipod|ipad', 'ios' ]
  , [ _xbox, _xbox ]
  , [ _ps, _ps ]
  , [ _android, _android ]
  , [ _windows, _windows ]
  , [ _castDetect, _chromecast ]
  , [ 'smart-tv;|;samsung;smarttv', 'samsung' ] //SmartTV2013
  )

  /**
  * device detection
  */
  test.call
  ( obj
  , _ua
  , 'device'
  , [ true, 'desktop' ]
  , [ _windows + '.+touch|ipad|' + _android,  _tablet ]
  , [ 'iphone|(' + _android + _mobile + ')|(' + _ff + _mobile + ')|' + _windows + ' phone|iemobile'
    , _phone
    ]
  , [ _xbox + '|' + _ps, 'console' ]
  , [ 'tv|smarttv|googletv|appletv|hbbtv|pov_tv|netcast.tv|webos.+large', 'tv' ]
  , [ _castDetect, _chromecast ]
  , [ 'amazon-fireos', _tablet ]
  )

  //TODO: amazon firetv and phone
    // alert(window.innerWidth*window.innerHeight +  '  '+ 414 * 736)
  
  //414  736
  var iphone6plus = 414 * 736
  if
  ( obj.platform === _android
    && !util.isNode
    && obj.device === _phone
    && window.innerWidth*window.innerHeight > iphone6plus
    // && ~_ua.indexOf('crosswalk')
  )
  {
    obj.device = 'tablet'
  }

  return obj
}

if( !util.isNode ) 
{ 
  parse()
  //TODO: this is very ugly, try to find a better solution
  if( window.__ua__ ) 
  {
    for( var field in window.__ua__ )
    {
      exports[field] = window.__ua__[field]
    }
  }
}

/**
 * prop
 * re-writes js properties to their css counterpart
 * e.g. webkitTransform --> -webkit-transform
 * now its commented since its not nessecary yet
 * @method
 */
// this.prop = function(str) {
//  return str.replace(this.prefix,'-'+this.prefix+'-').toLowerCase();
// }

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var  data = require('./')
  , base = require('../base')
  , util = require('../util')
  , flags = require('../value/flags/data')
  , vObject = require('../object')

exports.extend = util.extend( function(base, extensions, modelblacklist) {

  // var _blacklist = util.add(['flags', 'ref', 'parse', 'parsing'], modelblacklist),
    var _compare = util.compareArrays,
    methods = {
      _dUpdate: function(obj, val, stamp, from, remove, added, oldval, instances, argx1, argx2 ) {
        // if(window.here) console.log('X',stamp)
        if (this.model) {
          //$ndata
          //TODO: very dirty fix get rid of this!
          if( obj === '$ndata' ){
            val = from
            stamp = remove
            from = added
            remove = oldval
            added = instances
            oldval = argx1
            instances = argx2
            // console.log('!@#!@#!@#!@#@!#!@#!@#!@#'.red.inverse)
          }

          // var non = 0
          //   , cnt = 0
          // for( var i in arguments ) 
          // {
          //   cnt++
          //   if(!arguments[i]) {
          //     non++
          //   }
          //   console.log( arguments[i] )
          // }
          // if(non === cnt) {
          //   alert('no args')
          //   return true
          // }

          if (!this._d && this.parent) {
            var p = this.parent;
            while (!this._d && p) {
              if (p._d) {
                // console.error('SET DATA')
                this._dSet(p._d, true);
              } else {
                p = p.parent;
              }
            }
          }
          var t = this,
            model = t.model,
            f = model.flags,

            // f = model ? model.flags : false be carefull with updates in values that have data

            path = t._d && t._d._path || [],
            name = (from || (from = (t._d && t._d._updateOrigin)) && !(from === t._d && (from = false))) && from.updatePath,
            fromPath = from && from._path,
            method = function(i, field) {

              var select, pass, fr, lfield;
              // if( field._flag[2].__t) {
              //multiple flags!
                // console.log('FLAG'.inverse, name, field._flag)
              // }

              if(!field._flag.data) {
                console.error('NO DATA FLAG', name, field._flag, val, obj, remove, added, oldval)
                return
              }
              field = field._flag.data[2];

               // console.log('DATA UPDATE'.magenta.inverse,
               //      'obj:', obj
               //    , 'val:', val
               //    , 'stamp:', stamp
               //    , 'from:', from
               //    , 'remove:', remove
               //    , 'added:', added
               //    , 'field:', field
               //  )
              // var test = (i==='text' && field === 'real.duration')
              // if(test) console.log(field,i)
              // if(test) pass = true

              if (i === 'collection' && t._colFilter) return
              //if not own colfilter --> handle yourself!;
              // if data has changed change colfilter adn send update
              //be carefull /w changes!; too crude

              if (field === true) {
                // console.log('PASS'.inverse,name)
                pass = true;
              } else if (field.pop) {
                // console.log(name,'???')

                // console.log('--->',field, field.pop)

                field = field.concat();

                for (var j = field.length - 1; j >= 0; j--) {
                  if (!lfield !== void 0) {
                    select = util.get(t._d, field[j]);
                    if (select !== void 0) {
                      lfield = true;
                      // break;
                    }
                  }
                  field[j] = field[j].split('.');
                }
              } else {

                // console.log('DO DO!'.inverse,name, t._d && t._d._updateOrigin)

                // console.log(name, path, select, obj, val, stamp, from, remove, added, oldval, instances)

                field = field.split('.')

                select = util.get(t._d, field)

                if(!select && t._d && t._d.from && field ) {
                  // console.log('NO SELECT'.red.inverse, t._d )
                  select = util.get(t._d.from, field)
                  // if(select) {
                  //   // console.log('FOUND SELECT'.green.inverse, select)
                  // }
                } 

                if(select && from && from.__t === 4) lfield = true //test dit of het alles slow maakt

                // if(test&&select) console.log(select._val)
              }

              if (!pass && from) {

                // console.log('testing....?', name, from, select, lfield)
                // if(test) console.log(name, select, lfield, from);

                fr = true;
                var fromFrom

                if ( from === select || ( fromFrom = from.from ) === select ) {
                  pass = true;
                } else {
                  if (t._d._filter && select && select._ancestor(from)) {
                    pass = true;
                    //field ook voor arrays!;
                  } else if (lfield) {

                    // console.log('got lfield!!!!')

                    for (var n = 0; n < field.length; n++) {
                      if (name && _compare(name, field[n]) || field[n][0] === name[0] && util.get(val, field[n].concat().shift())) 
                      {
                        fr = false;
                        break;
                      } 
                      else if ((_compare(path.concat(field[n]), fromPath) || _compare(field[n], fromPath))) 
                      {
                        fr = false;
                        break;
                      } 
                      else {

                        // console.log('HERE?'.cyan.inverse, '\n\n\n', select.from.raw, 'val:'
                        //   , val, 'field:', field, 'fn', field[n], 'n:', n, 'check field:', val && val[field[n]], 'ref:', val.from)
                        // console.log('coming trugh', select && from._val !== null && val, field[n]
                        //   , select && from._val !== null && val && ( val[field[n]] || val.__t === 4 && val.from[field[n]] ) )
                        //TODO: need to add more gaurding for val.$path check if this is cloud and ref

                        if(select && from._val !== null && val && (val[field[n]] || val.$path || val.__t === 4) && (select._ancestor(from) || select.from._ancestor( fromFrom )  ))  //
                        {
                          // console.log(val, field);
                          pass = true;
                          break;
                        }
                      }
                    }
                  } else {

                    // console.log( '---', select, val, field, from, 'fromPath:' , fromPath )

                    if(val===null) {
                      // if(DEBUG$) t._d.DEBUG$log('data/base ---> ERROR val is null  --->'+t._d._removed )
                    } else if(val === void 0) {
                      // TODO: handle this
                      // console.log('\n\n\n undefined what to do now?', arguments,this)
                      // debugger
                      // pass = true
                      // pass = true
                    } else if (name && _compare(name, field) || field[0] === name && name[0] && util.get(val, field.concat().shift())) {
                      fr = false;
                    } else if (path && (_compare(path.concat(field), fromPath) || _compare(field, fromPath))) {
                      fr = false;
                    } else if (select && (val[field[0]]) && select._ancestor && select._ancestor(from)) {
                      // console.log(val, field);
                      pass = true
                    } else if( t.__checkKeys__ ) {
                      // console.log('lets checkj the keys!')
                      // console.log( field, name, val, path, select, val[field[0]], from, this )
                      for( var key$ in t.__checkKeys__ ) {
                        if( field === t.__checkKeys__[key$] || field[0] === t.__checkKeys__[key$] ) {
                          // console.log('maybe??!!@#!@', i, t.__checkKeys__[key$])
                          pass = true
                        }
                      }

                    }
                    // console.log(val, field[0], from);
                  }
                }
              }
              // pass = true;
              // console.log('PASS>>>>>>>>>?'.magenta.inverse, pass ? 'OK!'.green.inverse : 'NO!'.red.inverse  
              //   , 'val:'.blue, val
              //   , 'obj._path:'.blue, obj && obj._path
              //   , 'field:'.blue, field
              //   , 'fromPath:'.blue, fromPath
              //   , 'from:'.blue, from
              //   , 'select'.blue, select
              //   )

              // if(! pass && )

              // pass = true

              //|| remove 

              if (pass || remove || (instances || remove || select !== void 0) && ( !fr || remove === 1)) {

                // console.log('updating!'.cyan.inverse, i, val, instances, remove, select, fr, from)
                // debugger
                //stamp meegeven????
                // console.log( 'FROM!!!!!'.green.inverse, from )
                // console.l
                t[i]._update(val, false, from, remove, added, oldval, !instances, t);
                return true;
              }
            };
          //----------------------------------------------------
            //add advanced models (like on website)
            //not tested and still pretty broken
           var parser = function() {
            if (this._d) {
              var t = this, a
              //if added or first run
              t.model.val //set _caller
              // if (model.field) console.log('????', this.field, model.field)

              if (model.field) a = util.get(t._d, model.field.val)
              if (model._val) a = model._val.call(t, a || t._d) || a
              if (a && t._d !== a) {
                model.parsing = true
                if(model.field) this.modelParsed = model.field.val
                this._dSet(a)
                model.parsing = false
              }
            }
          }
          parser.call(t)
          if (instances) t.eachInstance(parser, 'model')
          //----------------------------------------------------

          //----------------------------------------------------
          if (f && (instances || t._d)) {
            for (var i in f) {
              if (!f[i].__t) {
                for (var j = 0, l = f[i].length; j < l; j++) {
                  if (method(i, f[i][j])) {
                    break;
                  }
                }
              } else {
                method(i, f[i]);
              }
            }
          }
          //----------------------------------------------------

         if(this.model.complete) this.model.complete._val.call(this,data)

        }
      },
      _dSet: function(val, dfrom) {


        // if(val) {
        //   console.log('_Dset'.cyan.inverse, val._path, dfrom)
        // }
        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        if(this.model._flag && this.model._flag.defer  && !this.__processing) {
          this.__pFlag = [ val, dfrom ]
          return
        }

        //dfrom moet niet nog een subscribe doen! -- als het goed is is zn parent al subscribed

        if (this._d && this._d.__t) this._d.removeListener(true, this)
        this._d = val
        if (dfrom) this._dfrom = true
        this._dListen()



        return val;
      },
      _dListen: function() {

          // console.log('HEEEEEE', this.model)

        // if(this.model._flag && this.model._flag.process && !this.__processing) {
        //   console.log('oo2')
        //   this.model._update()
        //   return
        // }

        //hier gaan we s fftjes werken met each

        // this._dfrom = true;
        var _this

        if (this.model && this._d && this._d instanceof vObject) 
        { //this model maybe not nessecary?

          // console.log('----->'.cyan.inverse, this._d )

          this._d.addListener([this._dUpdate, this])

          _this = this
          
          //hier filteren op cloudData --- ook werken vanuit remove!!!
            //never do for cloud data
         
          if( !this._d.cloud )
          {
            this._d.each(
              function() { 
                _this.__checkKeys__ = true

                if(this.__t === 4 ) this.addListener([ _this._dUpdate, _this, '$ndata', this ]) 
              }
            )
          }
          //eventueel .val gebruiken voor Values *awesjume!
          //eventueel hier dingen adden aan model

        } 
        else if( this.model && this._d ) 
        {
          for( var key in this._d ) 
          {
            if(!this.__checkKeys__ || this.__checkKeys__ === true) this.__checkKeys__ = []
            if( this._d[key] instanceof vObject )
            {
              if(!this.__checkKeys__.push) {
                console.error('xxxxxx', this, this.__checkKeys__, key, this._d)
                debugger
              }
              this.__checkKeys__.push( key )
              this._d[key].addListener([ this._dUpdate, this, '$ndata', key ])
            }
          }

        }
      },
      updateData: function(instances) {

        if(this.model._flag && this.model._flag.defer && !this.__processing) {
          // console.log('oo2')
          this.__pFlagU = [ instances ]
          this.model._update()
          return
        }
        // console.log('!DOIT updateData'.cyan.inverse)

        this._dUpdate(this._d, void 0, false, false, false, false, false, instances)
      }
    },
    extend = function(i) {
      base.extend({
        name: i,
        type: false,
        value: (extensions && extensions[i]) ? function() {
          methods[i].apply(this, arguments);
          extensions[i].apply(this, arguments);
        } : methods[i]
      });
    };
  for (var i in methods) {
    extend(i)
  }
  base.extend({
    name: 'model',
    cache: false,
    set: function(val) {

      if(this.__pFlag || this.__pFlagU) {
        /*
        TODO: test defer better!!!
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        */
        this.__processing = true
        this.model.parsing = false
        if(this.__pFlag) {
          this._dSet.apply(this,this.__pFlag)
        }
        //subscribe helemaal fucked met field erbij
        if(this.__pFlagU) {
          this.updateData.apply(this,this.__pFlagU)
        }
        this.__pFlagU = null
        this.__pFlag = null
        this.__processing = null
      }

      if(val.field && val.field.val !== this.modelParsed) {
        var a = this.modelParsed && this.modelParsed.split('.')
          , parent
        this.modelParsed = null
        if(this._d) {
          parent = this._d
          if(a) {
            for(var i = a.length-1; i >=0 ; i--) {
              parent = parent._parent
            }
            if(parent) {
              this._dSet(parent)
              this.updateData(true)
            }
          } else {
            this.updateData(true)
          }
        }
        this.modelParsed = null
      }
    },
    remove: function() {
      if( this._d )
      {
        if ( this._d.__t )  
        {
          this._d.removeListener( void 0, this )

          if( !this._d.cloud )
          {
            var _this = this
            this._d.each(
              function() { 
                // _this.__checkKeys__ = true
                if(this.__t === 4 ) this.removeListener( void 0, _this ) 
              }
            )
          }

        }
        else if( this.__checkKeys__) 
        {
          for( var key$ in this.__checkKeys__ ) 
          {
            if( this._d[this.__checkKeys__[key$]] instanceof vObject )
            {
              this._d[this.__checkKeys__[key$]].removeListener( void 0, this )
            }
          }
        }
      }
    }
    // parent: function(parent) {
    //   if( parent.data && (!parent.parent || parent.parent.data!==parent.data) ) {

    //     console.error('WTF?')

    //     this.data = parent.data
    //   }
    // }
  }, {
    name: 'data',
    type: false,
    set: function(val) {
        // console.log('?',val)
      if( this._d === val ) return

      // if(!this.model) this.model = {} //dit met het nooit setten van fmodel scheel op show al 3/9 subscriptions
      //nu nog shared subs maken -- 'shows' (ook meteen process) en dan word thet als het goed is nog een stuk minder
    
      // this.model = {} //pas op met deze
      // console.log('?2')

      if( this.model._flag && this.model._flag.defer ) {
        this.__pFlag = [ val ]
        this.__pFlagU = [ true ]
        // console.log('!@#!@#!@# OOOO'.red)
        return
      }

      // console.error('!!!!!MODEL -- dit moet zoveel mogelijk gereduced', this.model)

      this.model.parsing = false
      this._dSet(val)

      //subscribe helemaal fucked met field erbij
      this.updateData(true)

    },
    get: function() {
      return this._d
    }
  })
})
},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../value/flags/data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/data.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/conditions.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */
var data = require('./'),
  cnt = 0,
  handleTest = module.exports = function(test, subsObj) {
    // console.error('handleTest!', test)
    if (test instanceof Object) {
      var keys = Object.keys(test);
      if (keys.length === 1) {
        var key = keys[0]
          , valcheck = handleField(key, test[key], subsObj)
          
        return subsObj._check = function(doc){
          // console.log('TESTING', test, doc && doc.raw)
          // console.log('checking for key', key)
          var val = getValue(doc)
          return valcheck(val)
        }
      } else {
        var list = [],
          key;
        for (var k = 0, l = keys.length; k < l; k++) {
          key = keys[k];
          list.push(handleField(key, test[key], subsObj));
        }
        return subsObj._check = makeAND(list);
      }
    } else {
      return subsObj._check = function(doc) {
        return getValue(doc) === test;
      }
    }
  }

function handleField(key, value, subsObj) {
  // console.warn('handleField [', key, '] value', value)
  var check;
  switch (key) {
    case '$not':
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj);
        check = function(doc) {
          return follow(doc) === false;
        };
      } else {
        check = function(doc) {
          return doc !== value;
        };
      }
      break;
    case '$ne':
      check = function(doc) {
        return doc !== value;
      };
      break;
    case '$and':
      var list = makeList(value, subsObj);
      check = makeAND(list);
      break;
    case '$nand':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc) === false) return true;
        }
        return false;
      };
      break;
    case '$or':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return true;
        }
        return false;
      };
      break;
    case '$nor':
      var list = makeList(value, subsObj);
      check = function(doc) {
        for (var i = 0, l = list.length; i < l; i++) {
          if (list[i](doc)) return false;
        }
        return true;
      };
      break;
    case '$every':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (!follow(this)) return !(result = false);
          });
          return result;
        } else {
          return false;
        }
      };
      break;
    case '$nevery':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = false;
          doc.each(function() {
            if (!follow(this)) return result = true;
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$':
    case '$some':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      if (value instanceof Object) {
        var follow = handleTest(value, subsObj.$);
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (follow(this)) return found = true;
            });
            return found || false;
          }
          return false;
        };
      } else {
        check = function(doc) {
          if (doc && doc.__t < 3) {
            var found;
            doc.each(function() {
              if (this === value) return found = true;
            });
            return found || false;
          }
          return false;
        };
        subsObj.$._check = function(doc) {
          return doc === value;
        };
      }
      break;
    case '$nsome':
      subsObj.set('$', {});
      // subsObj.$ = {
      //   _up: subsObj
      // };
      var follow = handleTest(value, subsObj.$);
      check = function(doc) {
        if (doc && doc.__t < 3) {
          var result = true;
          doc.each(function() {
            if (follow(this)) return !(result = false);
          });
          return result;
        } else {
          return true;
        }
      };
      break;
    case '$lt':
      check = function(doc) {
        // console.log('burk lt', doc, value)
        return doc < value;
      };
      break;
    case '$lte':
      check = function(doc) {
        return doc <= value;
      };
      break;
    case '$gt':
      check = function(doc) {
        return doc > value;
      };
      break;
    case '$gte':
      check = function(doc) {
        return doc >= value;
      };
      break;
    case '$contains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return regex.test(doc);
      };
      break;
    case '$ncontains':
      var regex = new RegExp(value, 'i');
      check = function(doc) {
        return !regex.test(doc);
      };
      break;
    case '$containsall':
      break;
    case '$ncontainsall':
      break;
    case '$has':
      check = function(doc) {
        return doc && doc[value] !== void 0;
      };
      break;
    case '$nhas':
      check = function(doc) {
        return !doc || doc[value] === void 0;
      };
      break;
    case '$exists':
      check = function(doc) {
        return (doc !== void 0 && doc !== null) === value;
      };
      break;
    case '$in':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return true;
        }
        return false;
      };
      break;
    case '$nin':
      check = function(doc) {
        for (var i = 0, l = value.length; i < l; i++) {
          if (doc === value[i]) return false;
        }
        return true;
      };
      break;
    case '$regex':
      check = function(doc) {
        return value.test(doc);
      }
      break;
    default:
      if (value instanceof Object) {
        var dsubsObj = subsObj[key];

        if (dsubsObj) {
          // console.log('already made that dsubsObj with key', key);
          // dsubsObj._up = subsObj
        } else {
          subsObj.set(key, {});
          dsubsObj = subsObj[key];
        }
        var follow = handleTest(value, dsubsObj);

        check = function(doc) {
          // console.log('TESTING: check OBJECT', doc && doc.raw || doc, 'for field', key)
          doc = getField(doc, key)

          // console.log('wups', doc && doc.raw || doc)
          return follow(doc);
        };
      } else {
        check = function(doc) {
          doc = getField(doc, key)
          
          // doc = getValue(doc)
          // console.log('TESTING: check VALUE', doc && doc.raw || doc, value, doc === value)
          return doc === value;
        };
        subsObj.set(key, {});
        subsObj[key]._check = check
        // subsObj[key] = {
        //   _up: subsObj,
        //   _check: function(doc) {
        //     return doc === value;
        //   }
        // };
      }

  }
  return subsObj ? subsObj._check = check : check;
}

function makeList(arr, subsObj) {
  var list = [];
  for (var i = 0, l = arr.length; i < l; i++) {
    list.push(handleTest(arr[i], subsObj));
  }
  return list;
}

function makeAND(list, subsObj) {
  return function(doc) {
    var val = getValue(doc);
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i](val) === false) return false;
    }
    return true;
  };
}

function getValue(thing){
  var val = thing && thing.from && thing.from.val
  return val !== void 0 ? val : thing
  
}
function getField(thing, field){
  // console.error('getField field', field, 'from', thing && thing.raw || thing)
  thing = getValue(thing)
  return thing ? getValue(thing[field]) : void 0
}
},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var V = require('vigour-js'),
  object = require('vigour-js/object'),
  util = require('vigour-js/util');

module.exports = exports = V.Data = object.new();
exports.prototype._blacklist.push('__sub','__block');
util.define(exports, '_hook', function(val, obj) {
  if (obj.subscription) {
    this.__sub = obj.subscription;
    delete obj.subscription;
  }
  if(obj.block) {
    this.__block = true
    delete obj.block
  }
});


},{"vigour-js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Marcus Besjes, marcus@vigour.io
 */

var conditions = require('./conditions')
  , utilHash = require('../util/hash')
  , VObject = require('../object')
  , util = require('../util')

/**
 * Selection
 * Class extention for selection / filtering functionality
 * @Class
 */

exports.SubsObj = VObject.new()
exports.SubsObj.prototype._blacklist.push( '_root'
                                         , '_check'
                                         , '_sort'
                                         , '_uid'
                                         )

exports.extend = util.extend(function(base){

  base.prototype._blacklist.push( '_filter'
                                , '_uid'
                                , '_hash'
                                , '_indexCache'
                                , '_subscnt'
                                )

  var _update = base.prototype._update
    , _hook = base.prototype._hook
    , _remove = base.prototype.remove

  util.define( base
    , 'remove', function() {
        var l
        if(this._filter && (l = this.length)){
          for(var i = 0; i < l; i++)
            delete this[i]
        }
        return _remove.apply(this, arguments)
      }
    , 'filter', {
        get: function() {
          return this._filter
        },
        set: function(val) {
          // console.log('new filter \n from --->', this._filter, '\n to ---->'
          //            , val
          //            )
          this._filter = val //moet ook werken als data nog geen selection is
          this._build(undefined, true)
          _update.call( this, void 0, this.stamp(), void 0, false
                      , false, void 0
                      )
        }
      }
    , '_hook', function(val, filter) {
        if (_hook) {
          _hook.call(this, val, filter)
        }
        if (!util.empty(filter) && val) {
          var selection = this
          selection._subscnt = 0
          selection._filter = filter

          selection._hash = utilHash(val._path + JSON.stringify(
            [ filter.condition
            , filter.range
            , filter.sort
            ])
          )
          //!only nessecary serverside!
          if (!selection._uid) selection._uid = selection._hash
        };
      }
    , '_build', function(val, noupdate) {
        var selection = this
        
        if (!val) val = selection._val
        if(!val) return
        if (selection.length) selection._clear() 

        var list = []
          , itemsHandler = this._itemsHandler
          , filter = selection._filter
          , subsObj = filter.subsObj || new exports.SubsObj({}, selection)
          , stamp = this.stamp()
          , sort, item

        if (val.__t === 4 && !val._filter) {
          val = val.from;
        }

        if (filter.sort) {
          if (typeof filter.sort === 'string') {
            filter.sort = {
              field: filter.sort
            }
          }
          sort = filter.sort
          if (!sort.fn) {
            if (!sort.type) sort.type = 'string'
            sort.fn = sortMakers[sort.type](sort)
          }
          subsObj.path(sort.field.split('.'), {}).set('_sort', true)
        }
        // console.log('building?!')
        if (filter.condition) {
          // console.log('found condition', filter.condition)
          var pcnt = 0
            , rcnt = 0
          var check = filter.check 
                 || ( filter.check = conditions( filter.condition
                                               , subsObj
                                               )
                    )
          filter.subsObj = subsObj
          val.each(function(f) {
            item = this
            if (itemsHandler) itemsHandler(item, subsObj, selection)
            if (check(item)) {
              pcnt++
              list.push(item)
            } else if (selection._has(item) !== void 0) {
              // console.log('-------- > removed from selection by condition:'
              //             , item.raw
              //             )
              unstoreIndex(item, selection)
              if(!noupdate){
                _update.call(selection, item, stamp, selection, item, false, null)
              }
              rcnt++
            } else { 
              rcnt++
            }
          })
          // console.log('ran condition: passed:', pcnt, 'rejects:', rcnt)
        } else {
          val.each(function() {
            if (itemsHandler) itemsHandler(this, subsObj, selection)
            list.push(this)
          })
        }

        filter.subsObj = subsObj

        if (sort && list.length > 1) {
          list.sort(filter.sort.fn)
        }

        var i, item

        var range = filter.range
        if (range) {
          if (!(range instanceof Array)) {
            range = filter.range = [0, filter.range]
          }
          if (list.length) {
            var newlist = list.splice(range[0], range[1])
            for (i = list.length; item = list[--i];) {
              if(selection._has(item) !== void 0){
                unstoreIndex(item, selection)
                // if(!noupdate){
                //   _update.call(selection, item, stamp, selection, item, false
                //               , null
                //               )
                // }
                
              }
            }
            list = newlist
          }
        }

        for (var i = list.length, item; item = list[--i];) {
          selection[i] = item
          var isnew = selection._has(item) === void 0
          storeIndex(item, selection, i)
          // if (isnew) {
          //   if(!noupdate){
          //     console.log('doing update wickeds')
          //     _update.call(selection, item, stamp, selection, false, item, null)  
          //   }
          // }
        }
        selection.length = list.length
      }
    , '_update', function(val, stamp, from, remove, added, oldval) {

        if (this._filter) {
           // if(window.here) console.log('hups _update on selection!')

          var selection = this
            , upath = selection.updatePath

          if (upath[0] !== void 0) {
            var shortpath = upath.length === 1
              , itemremove = shortpath && remove
              , item = itemremove ? selection._lfrom : selection.val[upath[0]]
              , relevant

            if (selection._val._filter) {
              if (selection._val._has(item) === void 0) {
                if (selection._has(item) !== void 0) {
                  selection._checkItem(item, false, val, stamp)
                }
                return
              }
            }
            var hint = itemremove ? false : (shortpath && added) ? void 0 : upath

            if (selection._checkItem(item, hint, val, stamp) === true) {
              return _update.apply(selection, arguments) 
            }
          } else {
            // console.log('hit on selection itself?!')
            if (!from) {
              // console.log('\n>>>>>> hit on selection itself (V.Data)')
              if (remove) {
                if (selection.length) selection._clear()              
              }else{
                selection._build()
              }
            }
            return _update.apply(this, arguments)
          }
        } else {
           // if(window.here) console.log('hups _update on selection!',this)
           // console.log('SELECT', this, arguments, this._path)
          return _update.apply(this, arguments)
        }
      }
    , '_has', function(item) {
        var indexCache = item._indexCache
          , uid = this._uid
          , ic

        if (indexCache && uid && (ic = indexCache[uid])) {
          return ic[0]
        }
      }
    , '_clear', function() {
        var self = this
        self.each(function(f) {
          self[f] = void 0
          delete self[f]
        })
        self.length = 0
      }
    , '_checkItem', function(item, hint, val, stamp) {
        if(!item) { return }
        // console.log('_checkItem!', item.raw, hint)
        var selection = this
          , from = item
          , filter = selection._filter
          , sort = filter.sort
          , range = filter.range
          , ranged = range && !(  range[0] === 0 
                               && range[1] >= selection._val.length 
                               || selection.length < range[1] - range[0]
                               )
          , removed = hint === false || item._removed
          , added, index, isin
          , result = isin = (index = selection._has(item)) !== void 0

        var check = filter.check
          , pass = removed 
                   ? false 
                   : (!ranged && hint === 1) 
                     ? isin 
                     : !check || check(item)

        // console.log('================ checkitem in', selection._path)
        // console.log('itemwex', item._val && item._val.raw)
        // console.log('isin', isin, 'pass', pass, 'result', result)
        // console.log('---------- checked item', pass)
        // console.log('removed?', removed)
        // console.log('ranged? (pass == already in)', (!ranged && hint === 1), isin)
        // console.log('ok time for checking', check)
        // console.log('conditions', filter.condition)
        // console.log('check?', check && check(item))
        // console.log('----------')
        
        if (isin !== pass) {
          if (isin) {
            result = 1
            unstoreIndex(item, selection)
            removed = item
            var mark
            while (mark = selection[++index]) {
              selection[index - 1] = mark
              storeIndex(mark, selection, index - 1)
            }

            var end = index - 1
            selection[end] = null
            delete selection[end]

            var replacement
            if (ranged) {
              if (sort) {
                selection._val.each(function() {
                  if (  selection._has(this) === void 0 
                     && (!selection[end] || sort.fn(this, selection[end]) < 0) 
                     && (!check || check(this))
                     ) {
                    replacement = selection[end] = this
                  }
                })
              } else {
                selection._val.each(function() {
                  if ( selection._has(this) === void 0 
                     && (!check || check(this))
                     ) {
                    return replacement = selection[end] = this
                  }
                })
              }
            }
            if (!replacement) {
              selection.length--
            } else {
              storeIndex(replacement, selection, index - 1)
              added = replacement
            }
          } else {
            var newindex
            if (sort) {
              var sortfn = sort.fn
              if (selection.length) {
                selection.each(function(f) {
                  if (sortfn(item, this) < 0) {
                    return newindex = f
                  }
                })
              }
              if (newindex !== void 0) {
                result = 1
                newindex = Number(newindex)
                storeIndex(item, selection, newindex)
                added = item
                if (ranged) {
                  removed = selection[selection.length - 1]
                  unstoreIndex(removed, selection)
                } else {
                  this.length++
                }
                var index = selection.length - 2
                while (index >= newindex) {
                  storeIndex(selection[index], selection, index + 1)
                  selection[index + 1] = selection[index--]
                }
                selection[newindex] = item
              } else if (!ranged) {
                result = 1
                newindex = selection.length++
                selection[newindex] = item
                storeIndex(item, selection, newindex)
                added = item
              }
            } else if (!ranged) {
              result = 1
              newindex = selection.length++
              selection[newindex] = item
              storeIndex(item, selection, newindex)
              added = item
            }
          }
        } else if (isin && sort) {
                      console.log('???', sort, sort.field, hint)

          // console.log('isin + sort! resort?')
          if (hint && hint.length && sort.field) {
            if (~sort.field.indexOf('.')) {
              var sortpath = sort.field.split('.')
              if (!util.compareArrays(hint.slice(1), sortpath)) {
                return result
              }
            } else {
              if (hint[1] !== sort.field) return result
            }
          }

          console.log('?')

          var newindex
          selection.each(function(f) {
            if (f != index) {
              var s = sort.fn(item, this)
              if (s === -1) {
                if (f == index + 1) return true
                newindex = f < index ? f : f - 1
                return true
              } else if (f >= index + 1 && s === 0) {
                return true
              } else if (f > index) {
                newindex = f
              }
            }
          });
          // console.log('newindex', newindex)
          if (newindex !== void 0) {
            result = 1
            var tmp
            if (index > newindex) {
              while (index > newindex) {
                tmp = selection[index] = selection[--index]
                if (tmp) storeIndex(tmp, selection, index + 1)
              }
            } else {
              while (index < newindex) {
                tmp = selection[index] = selection[++index]
                if (tmp) storeIndex(tmp, selection, index - 1)
              }
            }
            selection[newindex] = item
          }

          var end = selection.length - 1

          if (  ranged 
             && (newindex == end || newindex === void 0 
             && index == end)
             ) {
            var replaced
            selection._val.each(function() {
              if (  selection._has(this) === void 0 
                 && sort.fn(this, item) === -1 
                 && (!check || check(this))
                 ) {
                if (!replaced) replaced = item
                selection[end] = item = this
              }
            })
            storeIndex(item, selection, end)
            if (replaced) {
              unstoreIndex(replaced, selection)
              removed = replaced
              added = item
              result = 1
            }
          } else if (newindex !== void 0) {
            storeIndex(item, selection, Number(newindex))
          }

        }
        if (result === 1) {
          // console.log('update from _checkItem!')
          selection.__update(val, stamp, from, removed, added)
        }
        return result
      }
    )

})

var storeIndex = exports.storeIndex = function(item, selection, index) {
  // console.log('storeIndex! item', item._name, '@', index)
  var indexCache = item._indexCache
    , ic
  if (indexCache) {
    ic = indexCache[selection._uid]
    if (ic) {
      ic[1] = ic[0]
      ic[0] = index
    } else {
      indexCache[selection._uid] = [index]
    }
  } else {
    item._indexCache = {}
    item._indexCache[selection._uid] = [index]
  }
}

var unstoreIndex = exports.unstoreIndex = function(item, selection) {
  var indexCache = item._indexCache
  if (indexCache) {
    var ic = indexCache[selection._uid]
    ic[1] = ic[0]
    ic[0] = void 0
  }
}

var sortMakers = {
  number: function(sort) {
    var field = sort.field
    return function(a, b) {
      var va = a[field] && a[field].val
        , vb = b[field] && b[field].val
      if (va === void 0 || vb === void 0) {
        return va === vb 
               ? 0 
               : va === void 0 
                 ? 1 
                 : -1
      }
      return sort.order 
             ? (va - vb) * -1 
             : va - vb
    }
  },
  string: function(sort) {
    var field = sort.field
    if (~field.indexOf('.')) {
      var path = field.split('.')
      return function(a, b) {
        a = getDotFieldVal(a, path)
        b = getDotFieldVal(b, path)
        if (a === void 0 || b === void 0) {
          return a === b 
                 ? 0 
                 : a === void 0 
                   ? 1 
                   : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    } else {
      return function(a, b) {
        a = getFieldVal(a, field)
        b = getFieldVal(b, field)
        var weakA = a === void 0 || a === null
          , weakB = b === void 0 || b === null
        if (weakA || weakB) {
          return a === b ? 0 : weakA ? 1 : -1
        }
        var re = a > b 
                 ? 1 
                 : a === b 
                   ? 0 
                   : -1
        return sort.order ? re * -1 : re
      }
    }
  }
}

function getFieldVal(obj, field) {
  var v = obj.val
  return v && v[field] && v[field].val
}

function getDotFieldVal(obj, field) {
  var v = obj.path(field)
  return v && v.val
}

function putSort(path) {
  var obj = part = {}
  for (var i = 0, l = path.length; i < l; i++) {
    part = part[path[i]] = {
      _up: part
    }
  }
  part._sort = true
  return obj
}

},{"../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js","./conditions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/conditions.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js":[function(require,module,exports){
//V only used as a reference now...

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/colors/colors.js":[function(require,module,exports){
/*
colors.js

Copyright (c) 2010

Marak Squires
Alexis Sellier (cloudhead)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

*/

var isHeadless = false;

if (typeof module !== 'undefined') {
  isHeadless = true;
}

if (!isHeadless) {
  var exports = {};
  var module = {};
  var colors = exports;
  exports.mode = "browser";
} else {
  exports.mode = "console";
}

//
// Prototypes the string object to have additional method calls that add terminal colors
//
var addProperty = function (color, func) {
  exports[color] = function (str) {
    return func.apply(str);
  };
  String.prototype.__defineGetter__(color, func);
};

function stylize(str, style) {

  var styles;

  if (exports.mode === 'console') {
    styles = {
      //styles
      'bold'      : ['\x1B[1m',  '\x1B[22m'],
      'italic'    : ['\x1B[3m',  '\x1B[23m'],
      'underline' : ['\x1B[4m',  '\x1B[24m'],
      'inverse'   : ['\x1B[7m',  '\x1B[27m'],
      'strikethrough' : ['\x1B[9m',  '\x1B[29m'],
      //text colors
      //grayscale
      'white'     : ['\x1B[37m', '\x1B[39m'],
      'grey'      : ['\x1B[90m', '\x1B[39m'],
      'black'     : ['\x1B[30m', '\x1B[39m'],
      //colors
      'blue'      : ['\x1B[34m', '\x1B[39m'],
      'cyan'      : ['\x1B[36m', '\x1B[39m'],
      'green'     : ['\x1B[32m', '\x1B[39m'],
      'magenta'   : ['\x1B[35m', '\x1B[39m'],
      'red'       : ['\x1B[31m', '\x1B[39m'],
      'yellow'    : ['\x1B[33m', '\x1B[39m'],
      //background colors
      //grayscale
      'whiteBG'     : ['\x1B[47m', '\x1B[49m'],
      'greyBG'      : ['\x1B[49;5;8m', '\x1B[49m'],
      'blackBG'     : ['\x1B[40m', '\x1B[49m'],
      //colors
      'blueBG'      : ['\x1B[44m', '\x1B[49m'],
      'cyanBG'      : ['\x1B[46m', '\x1B[49m'],
      'greenBG'     : ['\x1B[42m', '\x1B[49m'],
      'magentaBG'   : ['\x1B[45m', '\x1B[49m'],
      'redBG'       : ['\x1B[41m', '\x1B[49m'],
      'yellowBG'    : ['\x1B[43m', '\x1B[49m']
    };
  } else if (exports.mode === 'browser') {
    styles = {
      //styles
      'bold'      : ['<b>',  '</b>'],
      'italic'    : ['<i>',  '</i>'],
      'underline' : ['<u>',  '</u>'],
      'inverse'   : ['<span style="background-color:black;color:white;">',  '</span>'],
      'strikethrough' : ['<del>',  '</del>'],
      //text colors
      //grayscale
      'white'     : ['<span style="color:white;">',   '</span>'],
      'grey'      : ['<span style="color:gray;">',    '</span>'],
      'black'     : ['<span style="color:black;">',   '</span>'],
      //colors
      'blue'      : ['<span style="color:blue;">',    '</span>'],
      'cyan'      : ['<span style="color:cyan;">',    '</span>'],
      'green'     : ['<span style="color:green;">',   '</span>'],
      'magenta'   : ['<span style="color:magenta;">', '</span>'],
      'red'       : ['<span style="color:red;">',     '</span>'],
      'yellow'    : ['<span style="color:yellow;">',  '</span>'],
      //background colors
      //grayscale
      'whiteBG'     : ['<span style="background-color:white;">',   '</span>'],
      'greyBG'      : ['<span style="background-color:gray;">',    '</span>'],
      'blackBG'     : ['<span style="background-color:black;">',   '</span>'],
      //colors
      'blueBG'      : ['<span style="background-color:blue;">',    '</span>'],
      'cyanBG'      : ['<span style="background-color:cyan;">',    '</span>'],
      'greenBG'     : ['<span style="background-color:green;">',   '</span>'],
      'magentaBG'   : ['<span style="background-color:magenta;">', '</span>'],
      'redBG'       : ['<span style="background-color:red;">',     '</span>'],
      'yellowBG'    : ['<span style="background-color:yellow;">',  '</span>']
    };
  } else if (exports.mode === 'none') {
    return str + '';
  } else {
    console.log('unsupported mode, try "browser", "console" or "none"');
  }
  return styles[style][0] + str + styles[style][1];
}

function applyTheme(theme) {

  //
  // Remark: This is a list of methods that exist
  // on String that you should not overwrite.
  //
  var stringPrototypeBlacklist = [
    '__defineGetter__', '__defineSetter__', '__lookupGetter__', '__lookupSetter__', 'charAt', 'constructor',
    'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf', 'charCodeAt',
    'indexOf', 'lastIndexof', 'length', 'localeCompare', 'match', 'replace', 'search', 'slice', 'split', 'substring',
    'toLocaleLowerCase', 'toLocaleUpperCase', 'toLowerCase', 'toUpperCase', 'trim', 'trimLeft', 'trimRight'
  ];

  Object.keys(theme).forEach(function (prop) {
    if (stringPrototypeBlacklist.indexOf(prop) !== -1) {
      console.log('warn: '.red + ('String.prototype' + prop).magenta + ' is probably something you don\'t want to override. Ignoring style name');
    }
    else {
      if (typeof(theme[prop]) === 'string') {
        addProperty(prop, function () {
          return exports[theme[prop]](this);
        });
      }
      else {
        addProperty(prop, function () {
          var ret = this;
          for (var t = 0; t < theme[prop].length; t++) {
            ret = exports[theme[prop][t]](ret);
          }
          return ret;
        });
      }
    }
  });
}


//
// Iterate through all default styles and colors
//
var x = ['bold', 'underline', 'strikethrough', 'italic', 'inverse', 'grey', 'black', 'yellow', 'red', 'green', 'blue', 'white', 'cyan', 'magenta', 'greyBG', 'blackBG', 'yellowBG', 'redBG', 'greenBG', 'blueBG', 'whiteBG', 'cyanBG', 'magentaBG'];
x.forEach(function (style) {

  // __defineGetter__ at the least works in more browsers
  // http://robertnyman.com/javascript/javascript-getters-setters.html
  // Object.defineProperty only works in Chrome
  addProperty(style, function () {
    return stylize(this, style);
  });
});

function sequencer(map) {
  return function () {
    if (!isHeadless) {
      return this.replace(/( )/, '$1');
    }
    var exploded = this.split(""), i = 0;
    exploded = exploded.map(map);
    return exploded.join("");
  };
}

var rainbowMap = (function () {
  var rainbowColors = ['red', 'yellow', 'green', 'blue', 'magenta']; //RoY G BiV
  return function (letter, i, exploded) {
    if (letter === " ") {
      return letter;
    } else {
      return stylize(letter, rainbowColors[i++ % rainbowColors.length]);
    }
  };
})();

exports.themes = {};

exports.addSequencer = function (name, map) {
  addProperty(name, sequencer(map));
};

exports.addSequencer('rainbow', rainbowMap);
exports.addSequencer('zebra', function (letter, i, exploded) {
  return i % 2 === 0 ? letter : letter.inverse;
});

exports.setTheme = function (theme) {
  if (typeof theme === 'string') {
    try {
      exports.themes[theme] = require(theme);
      applyTheme(exports.themes[theme]);
      return exports.themes[theme];
    } catch (err) {
      console.log(err);
      return err;
    }
  } else {
    applyTheme(theme);
  }
};


addProperty('stripColors', function () {
  return ("" + this).replace(/\x1B\[\d+m/g, '');
});

// please no
function zalgo(text, options) {
  var soul = {
    "up" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', ''
    ],
    "down" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '', ''
    ],
    "mid" : [
      '', '', '', '',
      '', '', '', '',
      '', '', '', '',
      '', '', '',
      '', '', '', '',
      '', '', ' '
    ]
  },
  all = [].concat(soul.up, soul.down, soul.mid),
  zalgo = {};

  function randomNumber(range) {
    var r = Math.floor(Math.random() * range);
    return r;
  }

  function is_char(character) {
    var bool = false;
    all.filter(function (i) {
      bool = (i === character);
    });
    return bool;
  }

  function heComes(text, options) {
    var result = '', counts, l;
    options = options || {};
    options["up"] = options["up"] || true;
    options["mid"] = options["mid"] || true;
    options["down"] = options["down"] || true;
    options["size"] = options["size"] || "maxi";
    text = text.split('');
    for (l in text) {
      if (is_char(l)) {
        continue;
      }
      result = result + text[l];
      counts = {"up" : 0, "down" : 0, "mid" : 0};
      switch (options.size) {
      case 'mini':
        counts.up = randomNumber(8);
        counts.min = randomNumber(2);
        counts.down = randomNumber(8);
        break;
      case 'maxi':
        counts.up = randomNumber(16) + 3;
        counts.min = randomNumber(4) + 1;
        counts.down = randomNumber(64) + 3;
        break;
      default:
        counts.up = randomNumber(8) + 1;
        counts.mid = randomNumber(6) / 2;
        counts.down = randomNumber(8) + 1;
        break;
      }

      var arr = ["up", "mid", "down"];
      for (var d in arr) {
        var index = arr[d];
        for (var i = 0 ; i <= counts[index]; i++) {
          if (options[index]) {
            result = result + soul[index][randomNumber(soul[index].length)];
          }
        }
      }
    }
    return result;
  }
  return heComes(text);
}


// don't summon zalgo
addProperty('zalgo', function () {
  return zalgo(this);
});

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/index.js":[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/index.js":[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/socket.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/socket.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) {
      opts.port = pieces.pop();
    } else if (!opts.port) {
      // if no port is specified manually, use the protocol default
      opts.port = this.secure ? '443' : '80';
    }
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized || null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else if (0 == this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function() {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  var transport;
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  if ('closing' == this.readyState || 'closed' == this.readyState) {
    return;
  }

  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.readyState = 'closing';

    var self = this;

    function close() {
      self.onClose('forced close');
      debug('socket closing - telling transport to close');
      self.transport.close();
    }

    function cleanupAndClose() {
      self.removeListener('upgrade', cleanupAndClose);
      self.removeListener('upgradeError', cleanupAndClose);
      close();
    }

    function waitForUpgrade() {
      // wait for upgrade to finish since we can't send packets while pausing a transport
      self.once('upgrade', cleanupAndClose);
      self.once('upgradeError', cleanupAndClose);
    }

    if (this.writeBuffer.length) {
      this.once('drain', function() {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState || 'closing' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","./transports":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","indexof":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js","parsejson":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parsejson/index.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","parseuri":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseuri/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/index.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
    xs = opts.secure != isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling-jsonp":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-jsonp.js","./polling-xhr":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-xhr.js","./websocket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/websocket.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-jsonp.js":[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling-xhr.js":[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
    this.xs = opts.secure != isSSL;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(){
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.hasXDR()) {
      xhr.onload = function(){
        self.onLoad();
      };
      xhr.onerror = function(){
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function(){
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(fromError){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch(e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function(){
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        data = 'ok';
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function(){
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./polling":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/polling.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest');
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","xmlhttprequest":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transports/websocket.js":[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = require('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/transport.js","component-inherit":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js","engine.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js","parseqs":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js","ws":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/ws/lib/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/lib/xmlhttprequest.js":[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' != typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-emitter/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/component-inherit/index.js":[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/browser.js":[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // This hackery is required for IE8,
  // where the `console.log` function doesn't have 'apply'
  return 'object' == typeof console
    && 'function' == typeof console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      localStorage.removeItem('debug');
    } else {
      localStorage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = localStorage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/debug.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/debug.js":[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/node_modules/ms/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/debug/node_modules/ms/index.js":[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/browser.js":[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var hasBinary = require('has-binary');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      try {
        data = utf8.decode(data);
      } catch (e) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./keys":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/keys.js","after":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/after/index.js","arraybuffer.slice":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/arraybuffer.slice/index.js","base64-arraybuffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js","blob":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/blob/index.js","has-binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/index.js","utf8":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/utf8/utf8.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/lib/keys.js":[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/after/index.js":[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/arraybuffer.slice/index.js":[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/blob/index.js":[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob(['hi']);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/index.js":[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (obj.hasOwnProperty(key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/utf8/utf8.js":[function(require,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return 'U+' + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = require('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/node_modules/global/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/has-cors/node_modules/global/index.js":[function(require,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js":[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parsejson/index.js":[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseqs/index.js":[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/parseuri/index.js":[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/ws/lib/browser.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/index.js":[function(require,module,exports){
'use strict';

module.exports = require('./lib/core.js')
require('./lib/done.js')
require('./lib/es6-extensions.js')
require('./lib/node-extensions.js')
},{"./lib/core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","./lib/done.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/done.js","./lib/es6-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/es6-extensions.js","./lib/node-extensions.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/node-extensions.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js":[function(require,module,exports){
'use strict';

var asap = require('asap')

module.exports = Promise;
function Promise(fn) {
  if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new')
  if (typeof fn !== 'function') throw new TypeError('not a function')
  var state = null
  var value = null
  var deferreds = []
  var self = this

  this.then = function(onFulfilled, onRejected) {
    return new self.constructor(function(resolve, reject) {
      handle(new Handler(onFulfilled, onRejected, resolve, reject))
    })
  }

  function handle(deferred) {
    if (state === null) {
      deferreds.push(deferred)
      return
    }
    asap(function() {
      var cb = state ? deferred.onFulfilled : deferred.onRejected
      if (cb === null) {
        (state ? deferred.resolve : deferred.reject)(value)
        return
      }
      var ret
      try {
        ret = cb(value)
      }
      catch (e) {
        deferred.reject(e)
        return
      }
      deferred.resolve(ret)
    })
  }

  function resolve(newValue) {
    try { //Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.')
      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
        var then = newValue.then
        if (typeof then === 'function') {
          doResolve(then.bind(newValue), resolve, reject)
          return
        }
      }
      state = true
      value = newValue
      finale()
    } catch (e) { reject(e) }
  }

  function reject(newValue) {
    state = false
    value = newValue
    finale()
  }

  function finale() {
    for (var i = 0, len = deferreds.length; i < len; i++)
      handle(deferreds[i])
    deferreds = null
  }

  doResolve(fn, resolve, reject)
}


function Handler(onFulfilled, onRejected, resolve, reject){
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null
  this.onRejected = typeof onRejected === 'function' ? onRejected : null
  this.resolve = resolve
  this.reject = reject
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, onFulfilled, onRejected) {
  var done = false;
  try {
    fn(function (value) {
      if (done) return
      done = true
      onFulfilled(value)
    }, function (reason) {
      if (done) return
      done = true
      onRejected(reason)
    })
  } catch (ex) {
    if (done) return
    done = true
    onRejected(ex)
  }
}

},{"asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/done.js":[function(require,module,exports){
'use strict';

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise
Promise.prototype.done = function (onFulfilled, onRejected) {
  var self = arguments.length ? this.then.apply(this, arguments) : this
  self.then(null, function (err) {
    asap(function () {
      throw err
    })
  })
}
},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/es6-extensions.js":[function(require,module,exports){
'use strict';

//This file contains the ES6 extensions to the core Promises/A+ API

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

function ValuePromise(value) {
  this.then = function (onFulfilled) {
    if (typeof onFulfilled !== 'function') return this
    return new Promise(function (resolve, reject) {
      asap(function () {
        try {
          resolve(onFulfilled(value))
        } catch (ex) {
          reject(ex);
        }
      })
    })
  }
}
ValuePromise.prototype = Promise.prototype

var TRUE = new ValuePromise(true)
var FALSE = new ValuePromise(false)
var NULL = new ValuePromise(null)
var UNDEFINED = new ValuePromise(undefined)
var ZERO = new ValuePromise(0)
var EMPTYSTRING = new ValuePromise('')

Promise.resolve = function (value) {
  if (value instanceof Promise) return value

  if (value === null) return NULL
  if (value === undefined) return UNDEFINED
  if (value === true) return TRUE
  if (value === false) return FALSE
  if (value === 0) return ZERO
  if (value === '') return EMPTYSTRING

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then
      if (typeof then === 'function') {
        return new Promise(then.bind(value))
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        reject(ex)
      })
    }
  }

  return new ValuePromise(value)
}

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr)

  return new Promise(function (resolve, reject) {
    if (args.length === 0) return resolve([])
    var remaining = args.length
    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then
          if (typeof then === 'function') {
            then.call(val, function (val) { res(i, val) }, reject)
            return
          }
        }
        args[i] = val
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex)
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i])
    }
  })
}

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) { 
    reject(value);
  });
}

Promise.race = function (values) {
  return new Promise(function (resolve, reject) { 
    values.forEach(function(value){
      Promise.resolve(value).then(resolve, reject);
    })
  });
}

/* Prototype Methods */

Promise.prototype['catch'] = function (onRejected) {
  return this.then(null, onRejected);
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/node-extensions.js":[function(require,module,exports){
'use strict';

//This file contains then/promise specific extensions that are only useful for node.js interop

var Promise = require('./core.js')
var asap = require('asap')

module.exports = Promise

/* Static Functions */

Promise.denodeify = function (fn, argumentCount) {
  argumentCount = argumentCount || Infinity
  return function () {
    var self = this
    var args = Array.prototype.slice.call(arguments)
    return new Promise(function (resolve, reject) {
      while (args.length && args.length > argumentCount) {
        args.pop()
      }
      args.push(function (err, res) {
        if (err) reject(err)
        else resolve(res)
      })
      var res = fn.apply(self, args)
      if (res && (typeof res === 'object' || typeof res === 'function') && typeof res.then === 'function') {
        resolve(res)
      }
    })
  }
}
Promise.nodeify = function (fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments)
    var callback = typeof args[args.length - 1] === 'function' ? args.pop() : null
    var ctx = this
    try {
      return fn.apply(this, arguments).nodeify(callback, ctx)
    } catch (ex) {
      if (callback === null || typeof callback == 'undefined') {
        return new Promise(function (resolve, reject) { reject(ex) })
      } else {
        asap(function () {
          callback.call(ctx, ex)
        })
      }
    }
  }
}

Promise.prototype.nodeify = function (callback, ctx) {
  if (typeof callback != 'function') return this

  this.then(function (value) {
    asap(function () {
      callback.call(ctx, null, value)
    })
  }, function (err) {
    asap(function () {
      callback.call(ctx, err)
    })
  })
}

},{"./core.js":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/lib/core.js","asap":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/node_modules/asap/asap.js":[function(require,module,exports){
(function (process){

// Use the fastest possible means to execute a task in a future turn
// of the event loop.

// linked list of tasks (single, with head node)
var head = {task: void 0, next: null};
var tail = head;
var flushing = false;
var requestFlush = void 0;
var isNodeJS = false;

function flush() {
    /* jshint loopfunc: true */

    while (head.next) {
        head = head.next;
        var task = head.task;
        head.task = void 0;
        var domain = head.domain;

        if (domain) {
            head.domain = void 0;
            domain.enter();
        }

        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function() {
                   throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    flushing = false;
}

if (typeof process !== "undefined" && process.nextTick) {
    // Node.js before 0.9. Note that some fake-Node environments, like the
    // Mocha test runner, introduce a `process` global without a `nextTick`.
    isNodeJS = true;

    requestFlush = function () {
        process.nextTick(flush);
    };

} else if (typeof setImmediate === "function") {
    // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
    if (typeof window !== "undefined") {
        requestFlush = setImmediate.bind(window, flush);
    } else {
        requestFlush = function () {
            setImmediate(flush);
        };
    }

} else if (typeof MessageChannel !== "undefined") {
    // modern browsers
    // http://www.nonblocking.io/2011/06/windownexttick.html
    var channel = new MessageChannel();
    channel.port1.onmessage = flush;
    requestFlush = function () {
        channel.port2.postMessage(0);
    };

} else {
    // old browsers
    requestFlush = function () {
        setTimeout(flush, 0);
    };
}

function asap(task) {
    tail = tail.next = {
        task: task,
        domain: isNodeJS && process.domain,
        next: null
    };

    if (!flushing) {
        flushing = true;
        requestFlush();
    }
};

module.exports = asap;


}).call(this,require('_process'))

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/index.js":[function(require,module,exports){

module.exports = require('./lib/');

},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/manager.js","./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js","./url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/manager.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var object = require('object-component');
var debug = require('debug')('socket.io-client:manager');
var indexOf = require('indexof');
var Backoff = require('backo2');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = [];
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function(){
  for (var nsp in this.nsps) {
    this.nsps[nsp].id = this.engine.id;
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function(v){
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      socket.id = self.engine.id;
      if (!~indexOf(self.connected, socket)) {
        self.connected.push(socket);
      }
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  var index = indexOf(this.connected, socket);
  if (~index) this.connected.splice(index, 1);
  if (this.connected.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.backoff.reset();
  this.readyState = 'closed';
  this.engine && this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};

},{"./on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js","./socket":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js","./url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js","backo2":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/backo2/index.js","component-bind":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","engine.io-client":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/index.js","indexof":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/indexof/index.js","object-component":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/object-component/index.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js":[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/socket.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  if (this.io.autoConnect) this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

},{"./on":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/on.js","component-bind":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","has-binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/index.js","socket.io-parser":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js","to-array":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/to-array/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/lib/url.js":[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('/' == uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","parseuri":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/parseuri/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/backo2/index.js":[function(require,module,exports){

/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};


},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-bind/index.js":[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/cloud/emitter.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js":[function(require,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/index.js":[function(require,module,exports){
(function (global){

/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/has-binary/node_modules/isarray/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/indexof/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/indexof/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/object-component/index.js":[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/parseuri/index.js":[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/binary.js":[function(require,module,exports){
(function (global){
/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = require('isarray');
var isBuf = require('./is-buffer');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./is-buffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js","isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/index.js":[function(require,module,exports){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('component-emitter');
var binary = require('./binary');
var isBuf = require('./is-buffer');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
}

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

},{"./binary":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/binary.js","./is-buffer":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js","component-emitter":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/component-emitter/index.js","debug":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/debug/debug.js","isarray":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js","json3":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/json3/lib/json3.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/is-buffer.js":[function(require,module,exports){
(function (global){

module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/isarray/index.js":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/engine.io-client/node_modules/engine.io-parser/node_modules/has-binary/node_modules/isarray/index.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/socket.io-parser/node_modules/json3/lib/json3.js":[function(require,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/socket.io-client/node_modules/to-array/index.js":[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/array.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  object = require('./');

util.define(object,
  /**
   * V.Object's equivalent to Array.push()
   * @method push
   * @param  {Arguments}  The item(s) to add to the array
   * @return {Number}     The new length of the array
   */
  'push', function() {
    if (this.__t === 1) {
      if (this.length === void 0) {
        this.length = 0;
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        this._push(arguments[i]);
      }
      return this.length;
    }
  },
  '_push', function(val, vobj, stamp, noupdate, from) {
    //ame, val, vobj, stamp, noupdate, from
    this.length++;
    this.set((this.length - 1), val, vobj, stamp, noupdate, from);
    return this[this.length - 1];
  },
  /**
   * V.Object's equivalent to Array.pop()
   * @method pop
   * @return {*}  The removed array item
   */
  'pop', function() {
    if (this.__t === 1) {
      var l = this.length
      if(l !== 0){
        t = this[l - 1];
        this.length--;
        t.remove();
      }
      // return t; //pretty weird since this object always has value null;
    }
  },
  /**
   * V.Object's equivalent to Array.splice()
   * @method splice
   * @param  {Number}    index   An integer that specifies at what position to add/remove items, Use negative values to specify the position from the end of the array
   * @param  {Number}    howmany The number of items to be removed. If set to 0, no items will be removed
   * @param  {Arguments}         The new item(s) to be added to the array
   * @return {Array}             A new array containing the removed items, if any
   */
  'splice', function(index, howmany) { //can become shorter;
    if (index > -1 && this.__t === 1) { //how many and -i are ignored
      for (var i = 0, l = this.length, shift; i < l; i++) {
        if (shift) {
          if (i === l - 1) {
            // this.length--;
            this[i] = null;
          } else {
            this[i] = this[i + 1];
            this[i]._name = i;
          }
        } else {
          if (i === index) {
            if (i === l - 1) {
              this.pop();
            } else {
              shift = true;
              this.length--;
              this[i].remove();
              this[i] = this[i + 1];
              this[i]._name = i;
            }
          }
        }
      }
    }
  },
  /**
   * Adds value to array if it is not contained in array, executes handler on encountering val in array
   * @method include
   * @param  {*}         val       Value to add
   * @param  {Function}  [handler] Function to execute on encountering val in array
   * @return {Boolean}             True/false
   */
  'include', function(val, handler, arr) {
    return util.include(this, val, handler, arr);
  },
  'concat', function(val) { 

    // if(!val) {
    //   return
    // }
    
    var arr = this
    var ll = arr.length;
    for (var i = 0, l = val.length; i < l; i++) {
      arr._push(val[i], false, false, true);
    }
    arr._update(val);
    return arr;
  },
  'moveItem', function(from, to) { var arr = this
    if(to === void 0) to = arr.length - 1
    if(from === to) return
    var mover = arr[from]
    if(!mover) return
    var step = from < to ? 1 : -1
    do {
      arr[from] = null
      arr.set(from, arr[from + step], true)
      from += step
    } while(from !== to)
    arr[to] = null
    arr.set(to, mover, true)
  }
)

},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/compound.js":[function(require,module,exports){


var VObject = require('vigour-js/object').inject(
    require('vigour-js/value/length')
  ),
  util = require('vigour-js/util'),
  uid = require('vigour-js/util/id')

var SAMEPATH = 'could not create compound of two Objects with the same path'

// function Compound(val){
//   var compound = this
//   compound.$sources = new SourceList(compound, val)
//   this.__t = 2
// }

// var Data = require('vigour-js/data')

var Compound = VObject.new(void 0, function(val){
  var compound = this
  compound.$sources = new SourceList(compound, val)
  this.__t = 2
  return false
})
util.define(Compound, '_class', VObject)


module.exports = Compound
// Compound.prototype = new VObject()

Compound.prototype._blacklist.push(
  '$sources'
)

util.define( Compound,
  '_absorb', function _absorb(entry) {
    var compound = this
    var source = entry.source
    var prefix = entry.name
    
    var endpoint = source
    while(endpoint && endpoint.__t === 4 && !endpoint._filter) {
      endpoint = endpoint._val
    }
    entry.endpoint = endpoint
    
    if(endpoint) {
      endpoint.each(function absorbEach(){
        compound.set(prefix + '-' +this._name, this)
      })
    }

    compound.each(function cleanOld(){
      var pointer = this
      var pointed = pointer._val

      // skip cleanup check on construction
      if(!compound.$sources) {
        return
      }

      // TODO: find a better way to check if thing is still in an enpoint
      // get the endpoint the item should be in
      var sourcename = pointer._name.split('-')[0]
      var ep = compound.$sources[sourcename].endpoint
      var ok
      ep.each(function okCheck(){
        if(this === pointed) {
          return ok = true
        }
      })
      if(!ok) {
        pointer.remove()
      }
    })
  },
  '_addCompoundListener', function _addCompoundListener(entry) {
    var compound = this
    entry.source.on(function compoundListener(){
      // console.log('change in source, run absorb on', entry, 
      //   '\nval', arguments[0],
      //   '\nstamp', arguments[1]
      // )
      compound._absorb(entry)
    })
  }
)

function SourceList(compound, val) {
  var sourcelist = this
  sourcelist._parent = compound
  if(val){
    if(!(val instanceof Array)) {
      val = [val]
    }
    this.push.apply(this, val)
  }
}

SourceList.prototype.push = function pushSource(){
  var sourcelist = this
  var compound = sourcelist._parent

  // console.log('push dat sources', arguments.length)
  var al = arguments.length
  for(var i = 0, source; source = arguments[i] ; i++){

    var sourcename = uid()

    // console.log('SOURCENAME IS', sourcename)

    var entry = sourcelist[sourcename] = {
      name: sourcename,
      source: source
    }

    compound._absorb(entry)
    compound._addCompoundListener(entry)

  }
}




},{"vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/util/id":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js","vigour-js/value/length":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')

/**
 * Flags are special properties where a function is called
 * different from operators since flags may have nothing to do with value calculation
 * extends default set from V.Object
 * @property
 */
/**
 * Adds new flags to V.Object
 * @method extend
 * @param  {Object}   object V.Object to extend flags to
 * @param  {Function} [set]  [description]
 * @return {[type]}          [description]
 */
exports.extend = util.extend(function(object, set) {
  
  //multiple flags 
  
  // abstract flags array away!
  // 
  // flags object --> field
  // 
  // check /w cases
  // check /w parent
  // flag4 is dynamic has stack as option
  
  var _proto = object.prototype
    , _convert = _proto.convert
    , _set = _proto._set
    , _remove = _proto._remove
    , _check = function(name) {
      var f;
      for (var i in object.flags.dynamic) {
        f = object.flags.dynamic[i](name)
        if(f) break
      }
      return f
    }
    , checkIfFlagOverwrite = function(val) {
      for(var i in val) {
        if(object.flags[i] || _check(i)) return true
      }
    }

  if (!set) set = _proto.set

  _proto._blacklist.push('_flag');
  util.define(object,
    /**
     * [description]
     * @method convert
     * @param  {[type]} val [description]
     * @return {[type]}     [description]
     */
    'convert', function(val) {

      //hier ook weer for
      var obj = _convert.call(this, val);

      // console.log('I SHOULD BE CONVERTING!', val, obj, this._flag)





      if (this._flag && (!val || !util.isObj(val) || val.val || checkIfFlagOverwrite(val) )) {

        // console.log('I SHOULD BE CONVERTING! step 2')

        //ff useVal gebruiken

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (!flag[4] || !flag[4].stack) {

            // console.log('CONVERT NEEDS FIX'.red.bold.inverse)

            if (obj === flag[1]) {
              // console.log('2 CONVERT NEEDS FIX'.red.bold.inverse)
              obj = {};
            }
            if (obj.val === flag[1]) {
              // console.log('3 CONVERT NEEDS FIX'.red.bold.inverse)
              delete obj.val;
            }


            obj[flag[0]] = flag[2]
          }
          else {
            //still have to take care of this situation
            // console.error('trying convert a stack-dynamic flag', flag);
          }
        }

        // console.log('CONVERTED ---->',obj)

      }
      return obj;
    },
    /**
      @property __flags__
    */
    '__flags__', {},
    /**
     * [description]
     * @method remove
     * @param  {[type]} from   [description]
     * @param  {[type]} update [description]
     * @param  {[type]} stamp  [description]
     * @return {[type]}        [description]
     */
    '_remove', function(from, update, stamp) {

      if(this._flag) {
        for(var i in this._flag) {
          // console.log(i, this._flag)
          var flag = this._flag[i]
          //for 
          // console.log('_remove')
          if (flag) {
            //dit moet wel ff lukken
            if (object.flags[flag[0]]) {
              object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag);
            } else {
              flag[4].remove.call(this, flag);
            }
          }
        }
        this._flag = null
      }

      _remove.call(this, from, update, stamp);
    },
    /**
     * [description]
     * @method _set
     * @param  {[type]} val      [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} from     [description]
     * @param  {[type]} remove   [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    '_set', function(val, stamp, from, remove, noupdate) {
      // console.log('make _set',this._name,val);
      _set.call(this, val, stamp, from, remove, noupdate)

      //flag moet dus ook meer een copied value worden

      // console.log('_set', this._flag, val)


      if(this._flag) {

        // console.log('overwrite>?----', this._flag, val)

        for(var i in this._flag) {
          var flag = this._flag[i]
          if (flag) {
            var setFl = object.flags[flag[0]] || flag[4]
            //what to do with reset?
            //change fixen bij cases?
            
            // console.log('2 overwrite>?----', flag, this._val, this._val !== flag[1])
            
            if (this._val !== flag[1] && setFl.useVal) {

              // nu ff hier ook nog!

              if (object.flags[flag[0]]) {

                // console.log('remove flag normal',flag, flag[4], i, this)

                object.flags[flag[0]].remove && object.flags[flag[0]].remove.call(this, flag)
                //if this empty
                // delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
                // this._update()
              } else if (!flag[5]) {
                // console.log('remove flag /w flag[4] and not flag[5]',flag, flag[4], i)
                flag[4].remove.call(this, flag);
                // if(this.)
                //delete this._flag;
                delete this._flag[i]
                if(util.empty(this._flag)) {
                  delete this._flag
                }
              }
            } else if (object.flags[flag[0]] && object.flags[flag[0]].reset && flag[3] !== this) {
              // console.error('RESETTING -- ingnore /w a clear!',flag[0]) 
              object.flags[flag[0]].set.call(this, flag[2], stamp, true, this._name)
            }
          }
        }
      }

    },
    /**
     * [description]
     * @method set
     * @param  {[type]} name     [description]
     * @param  {[type]} val      [description]
     * @param  {[type]} vobj     [description]
     * @param  {[type]} stamp    [description]
     * @param  {[type]} noupdate [description]
     * @return {[type]}          [description]
     */
    'set', function(name, val, vobj, stamp, noupdate) {
      var fl = object.flags[name] || _check(name)
        , r
        , same

        // console.log(name, val, vobj)

      if (fl) {

        // console.log('set>?----', name, val, this._flag)
       
      if(val===false) {
          //stack -- alle flags name providen!
          var i = fl.stack||name 
            , flag = this._flag && this._flag[i]
          if(flag && fl.remove) {
            var d = fl.remove.call(this, flag, name)
            // console.log('REMOVE FLAG FROM FALSE'.inverse, fl, name, val, stamp, this)
            if(!d) {
              delete this._flag[i]
              if(util.empty(this._flag)) {
                // console.log('flag is empty, delete')
                delete this._flag
              }
            }
          } 
          r = true
          // if(this._flag)
      } else {
       if(this._flag) {
          //check if need to remove! -- only in case
          for(var i in this._flag) {
            var flag = this._flag[i]
            if (flag && fl.remove) {

              if(!fl.stack && name === flag[0]) {
                // console.log('--->',flag[0])
                if(val!==flag[2]) {
                  // console.log('remove flag! ---> overwrite bymyself --->', flag[0],  setFl, 'by:' ,name, fl, val, flag[2])
                  fl.remove.call(this, flag);
                } else {
                  same = true
                }

              } else if (!fl.stack || fl.stack !== flag[0]) {

                //this._flag

                //if val:true 
                //go check if you need to remove mofos

                var setFl = object.flags[flag[0]] || flag[4]

                if(setFl.useVal && fl.useVal) {

                  // console.log('remove flag! -- clearly has some useVal', flag[0],  setFl, 'by:' ,name, fl)

                  setFl.remove.call(this, flag);
                  delete this._flag[i]
                  if(util.empty(this._flag)) {
                    // console.log('flag is empty, delete')
                    delete this._flag
                  }
                }


                // console.log('remove flag!', flag, flag[0], flag[4],  object.flags[flag[0]]  , fl, name) //check if it needs to be removed
                // var fl 
                
                //fl = object.flags[name] || _check(name)
                //
                //hier iets mee doen weer zoeken naar flag set


                //do the special check if value is tight to flag check (for both! fl.value)

                // fl.remove.call(this, flag);
              }
            }
          }
        }

      if(!same) {
          // console.log('SET FLAG'.inverse, name, val, stamp, this)
          fl.set.call(this, val, stamp, false, name);
          r = true //niet altijd waar ofcourse!
          // console.log('---------')
        } else {
          // console.log('FLAG IS SAME'.red.inverse, name, val, stamp, this)
        }
      }
        this[name] && this[name].remove(false, false, false, false, false, true);
      } else {
        r = set.call(this, name, val, vobj, stamp, noupdate);
      }
      return r;
    });
  object.flags = _proto.__flags__;
  util.define(object.flags, 'dynamic', {});
})
},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/hashpath.js":[function(require,module,exports){
var util = require('../util')
  , hash = require('../util/hash')

exports.extend = util.extend(function(base) {
  base.prototype._blacklist.push('__hp')
  util.define( base
  , '_hashpath', {
      get: function() {
        return this.__hp || (this.__hp = hash(this._path.toString()))
      }
    }
  )
})
},{"../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/hash":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util')
  , vigour = require('../')
  , inject = require('../util/inject')
/**
 * V.Objects are used instead of normal objects in vigour listeners are automatically added and removed
 * type: __t : 1 = array , 2 = object , 3 = has field (can never be an array) , 4 = field ref to other V.Object
 * note you can make an object out of a field or field ref the type will be 3 or 4 though!
 * @constructor
 * @param  {*}      [val]    Value
 * @param  {Object} [parent] Parentobject
 */
var object = module.exports = exports = vigour.Object = function(val, hook, parent) {
  if (parent) this._parent = parent
  if (hook && this._hook) this._hook(val, hook)
  if (val !== void 0) this.val = val
}
object.inject = inject
/**
 * Used to set .val
 * @method _set
 * @param  {*}              val                  [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Object|Boolean} [from]               [description]
 * @param  {Boolean}        [noupdate]           When true, no updates
 * @param  {Boolean}        [add]                When true, this is an add
 */
var _set = function(val, stamp, from, noupdate, add) {

  if(val===null) {
    if (!stamp) stamp = this.stamp()
    this.remove(false, false, false, from, stamp, noupdate)
  }

  if (!this.__t || this.__t < 3 || ( val !== this._val || this._ignoreValue ) ) {

    // console.error(this)
    if(!this.stamp) {
      //moet allemaal event emitters worden (on('error'))
      //this._update('error') en anders V.debug.error._update( 'object' )
      console.error( 'ERROR in vigour-js/object,  OBJECT no .stamp', this )
      return
    }

    if (!stamp) stamp = this.stamp()

    var oldval = this._val
      , nestedval
      , noset
      , isSet
      , isArray
      , valIsSet

    if (this._changevobj 
      && ((this.__t < 4 && val instanceof object) 
      || this.__t === 4 && ((!this._mixed||this._mixed===4) || val instanceof Array 
        || (val instanceof Object 
          && (val instanceof object || val.val))))) { //try to make this shorter
         this._changevobj(val, stamp)
         if(this._mixed===4) this._val = null
    }

    if (vigour.Base && (val instanceof vigour.Base)) {
      this.remove(true, true, false, false, stamp)
      this.__t = 5
      this._val = val
    } else if (val instanceof object) {
      if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
        this.remove(true, true, false, void 0, stamp) //check if 2nd param true is absolutely nessecary (else it will be removed)
      }
      this._val = val
      this.__t = 4
      if (this._setvobj) this._setvobj(val)
    } else {

      if (val instanceof Object && typeof val !== 'function') {
        if (val instanceof Array) {
          this._val = void 0
          this.__t = 1
          this.length = val.length
          noset = this.remove(true, true, val, false, stamp)
          for (var i = 0, l = this.length; i < l; i++) {
            if (!this.set(i, val[i], false, stamp, noupdate, true) && noset !== false) {
              noset = true
            } else {
              noset = false
            }
          }
        } else {

          //normal object

          if (val.clear) {
            noset = this.remove(true, true, false, false, stamp)
            delete val.clear
          } else {

            if (this.__t === 1) {
              if (this._mixed !== 1 && this._mixed!==4) {
                this.remove(true, true, false, false, stamp) //ommiting stamp can be a problem
              } else {
                isArray = true
              }
            } else if (!this._merge && (!this._mixed || this.__t === 2)) {
              noset = this.remove(true, true, val, false, stamp)
            }
          }
          if (val.val && util.isObj(val.val)) {
            valIsSet = true
            this._$setVal( new this._class(val.val, false, this), stamp, from, true)
            this._val._contained = true
          } else if (!this._mixed) {
            this._val = void 0 //this messes up property updates!! (youri)
          }

          if (!isArray) this.__t = 2

          for (var j in val) {
            if (!util.checkArray(this._blacklist, j)) {
              if (j === 'val') {
                if(!valIsSet) isSet = this._$setVal( val.val, stamp, from, true )
                nestedval = true;
              } else {
                //do not always ignore updates at this point
                if (!this.set(j, val[j], false, stamp, noupdate, true) && noset !== false) {
                  noset = true
                } else {
                  noset = false //this is the place where set is passed
                }
              }
            }
          }
        }

      } else {
        if ((this.__t < 3 && !this._mixed) || this.__t === 1) {
          this.remove(true, true, false, false, stamp)
          if (this.__t === 1) delete this.length
        }
        if (val === this._val && !this._ignoreValue ) {
          //maybe use stamp for ignoreValue as well?
          if (noset !== false) {
            this.__t = 3
            return false
          }
        } else {
          this._val = val
          this.__t = 3
        }
      }
    }
    if (nestedval) {

      if (this._set && (isSet !== false || noset === false)) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      }
    } else if (this._set) {
      if (!noset) {
        this._set(val, stamp, from, false, noupdate, add, oldval)
      } else {
                    // if(window.smut) console.log('!1',arguments)

        return false;
      }
    }
  } else {
                        // if(window.smut) console.log('!1',arguments)

    return false;
  }

},
/**
 * stamp
 * paint the set origin
 * @method
 */
_stamp = 0,
_params = function(params, list) {
  for (var i = list.length - 1, p; i >= 0; i--) {
    if (params && params[list[i]]!==void 0) {
      p = '_' + list[i]
      util.define(this, p, params[list[i]])
    }
  }
}
/**
* Generates unique stamp
* @method stamp
* @return {Number} Returns stamp
*/
exports.stamp = function() {
//if stamp > x reset ?
return _stamp++
}

exports.set = _set

// objectUtils.extend(exports);  
/**
 * Creates a new constructor based on a V.Object
 * Params can be passed
 * Mixed creates mixed types for the new class i.e having a string and properties
 * @method new
 * @param  {Object} params Parametersobject
 * @return {Object}        Returns V.Object
 */
// window.cnt = 0
// setTimeout(function() {
//   window.smut = true
// },2000)

object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      var conresult
      if (constructor) {
        conresult = constructor.apply(this,arguments)
      }
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)

      if(val !== void 0 && conresult !== false) {
        this.val = val
      }
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  vObj.inject = inject //not handeled well yet
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

util.define(object,

// '_set, set , '

 '_$setVal', _set,

/**
 * Items in the blacklist skipped in each function
 * @method _blacklist
 */
'_blacklist', ['_', '__', '__t', '_val', 'length', '_name', '_parent', '_contained', '_removed','extensions', '__cachedPath', '_ignoreValue', '_indexCache'],
/**
 * Replaces default constructor property ,necessary for classes made with V.Object.new
 * @constructor _class
 */
'_class', object,
/**
 * Stamp is a method of VObject so that it can be extended in subclasses
 * @return {*} a unique identifier for a mutation
 */
'stamp', object.stamp,
/**
 * Used to get .val which returns field values i.e. a string
 * @method _get
 * @return {*} Returns value
 */
'_get', function() {
  var self = this
    , type = self.__t
    , val

  if (type < 3) {
    return self
  } else {
    val = self._val
    return (type !== 4) ? val : val && val._get()
  }
},
/**
 * Used to get .val which returns field values i.e. a string
 * Set creates instances of the _class for nested properties
 * @property
 */
'val', {
  set: function(val) {
    // window.cnt++
    // if(window.smut) {
      // console.error(window.cnt, 'whats happening', this._path, this._prop && this._prop.name, this, this._updateOrigin)
    // }
    return this._$setVal(val)
  },
  get: function() {
    return this._get()
  }
},
/**
 * Add a property to a object
 * @method set
 * @param  {String}  name                [description]
 * @param  {*}       val                 [description]
 * @param  {Boolean} [vobj]              [description]
 * @param  {Number}  [stamp = new stamp] [description]
 * @param  {Boolean} [noupdate]          [description]
 * @return {Boolean}                     [description]
 */
'set', function( name, val, vobj, stamp, noupdate, from ) {

  //function( name, val, vobj, stamp, noupdate, from ) 

  // console.log(name, stamp)

  from = from && this
  if (!vobj && (this[name] instanceof object)) {
    if (this._$setVal.call(this[name], val, stamp, from, noupdate) === false && stamp) {
      return false
    }
  } else {
    if (vobj) {
      if(this[name]) this[name].remove()
      this[name] = val
      this[name]._name = name
      this[name]._parent = this
      if(!noupdate) val._update(val, stamp || this.stamp(), from, void 0, true)
    } else {
      this[name] = new this._class(void 0, false, this)
      this[name]._name = name
      this._$setVal.call(this[name], val, stamp, from, noupdate, true)
    }
    if (this.__t === 1 && this._setArrayItem) {
      this._setArrayItem( this[name], val )
    }
  }
  return true
},
/**
 * Removes a V.Object including all nested fields and values
 * @method remove
 * @param  {Boolean}        [nested]             When true remove nested objects
 * @param  {Boolean}        [bl]                 When true doesn't remove blacklisted items
 * @param  {Boolean}        [not]                [description]
 * @param  {Boolean|Object} [from]               [description]
 * @param  {Number}         [stamp = new stamp]  [description]
 * @param  {Boolean}        [noupdate]           [description]
 * @return {Boolean}                             [description]
 */
 //    this.remove(false, false, false, from, stamp, noupdate)

'remove', function(nested, bl, not, from, stamp, noupdate) { //no update first > (extended in selection.js)
  if (!nested) this._removed = true
  var r, i, oldval
  if (!stamp) stamp = this.stamp()
  // console.log('START',stamp,this._name);
  if (!nested) {
    if (this._parent) {
      this._parent[this._name] = null
      delete this._parent[this._name]
    }
    if (this._val !== void 0) {
      if (this._val instanceof object && this._val._contained) {
        this._val.remove(false, false, false, from || this, stamp, noupdate)
      }
      oldval = this._val
      this._val = null
    }
  }
  for (i in this) {
    if ((!not || !not[i]) && !util.checkArray(this._blacklist, i)) {
      if (this[i] instanceof object) {
        r = false
        // console.log('DELETE',stamp,i,this[i]);
        this[i].remove(false, false, false, from || this, stamp, noupdate)
      }
      this[i] = null
      delete this[i] //delete is pretty nasty for performance
    }
  }
  if (!nested) {
    if (this._remove) {
      //r
      this._remove(from, noupdate ? false : from /*||r*/ , stamp, oldval);
      if (!bl) {
        for (var j in this) {
          if (this[j] !== void 0) {
            if (j !== '_parent' && this[j] instanceof object && this[j]._contained) {
              this[j].remove()
            }
            this[j] = null
            delete this[j]
          }
        }
      }
    }
    this._removed = true
  }
  return r
})


//----this has to be initialized after defining the blacklist property;
exports.listen = require('./listen')
require('./array')
require('./util')
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../util/inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./array":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/array.js","./listen":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/listen.js","./util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/listen.js":[function(require,module,exports){
var util = require('../util')
  , vObject = require('./')
  , V = require('../')
  //TODO: this is a temp fix to emulate on next tick
  , raf = require('vigour-js/browser/animation/raf')
  , Promise = require('promise')

function _addListener( obj, fn, mark, original ) {
  //val, mark, skipcheck, ignoreval, orginal
  if( mark ) 
  {
    // console.log('hey got orginal!', original)
    //n( val, mark, skipcheck, ignoreval, original )
    obj.addListener([ fn, mark ], true, false, false, original  )
  } 
  else 
  {
        // console.log('hey got orginal!', original)

    obj.addListener( fn, false, false, false, original )
  }
}

/*
  _update calls listeners on a given Object (listeners include linking fields in other V.Objects)
  V.Object._update can be modified to change update behavior:
    - standard: update Object and it's parents / ancestors recursively.
    - parentOnly: update Object and only its direct parent.
    - just _update: update only the Object.
*/
var _update = exports._update = function(val, stamp, from, remove, added, oldval, test) {

  // if(window.here) console.log('UPDATE!',this._path)

  var _l = this._listeners
    , i
    , listener

  if (_l) {
    for (i = _l.length; listener = _l[--i];) { //order is irrelevant
      if (listener instanceof vObject) {

        // console.log('update?????', listener._path, this._path, from)

        // if (from) {
        listener._lfrom = from || this
          // }

        listener._update(val, stamp, false, remove, added, oldval)

        if (listener) listener._lfrom = null

      } else if (listener[0]) {
        if(!test || !test(listener)) {
          if (listener.length > 2) {
            for (var l = listener.length - 2
              , l2 = arguments.length
              , a = [], j = -1
              , la = l + l2
              ; j < la
              ; a[++j] = j < l
                ? listener[j + 2]
                : j === l ? this : arguments[j - l - 1]
              );

            listener[0].apply(listener[1], a)
          } else {
            listener[0].call(listener[1], this, val, stamp, from, remove, added, oldval)
          }
        }
      } else {
        listener.call(this, val, stamp, from, remove, added, oldval)
      }
    }
  }
}


// util.define(vObject, 
//   '_nodePath_', function() {
//     if(this._caller) {

//       var arr = []
//       var p = this._caller

//       while(p) {
//         arr.push( p._name || p._node && p._node.className )
//         p = p._node && p.parent
//       }
//       arr.reverse()
//       return arr


//     }
//   }

// )


vObject.prototype._blacklist.push('_listeners', '_listens', '_lfrom', '_listenMap');

util.define(vObject,
  /**
   * _set
   * is called when a value is set
   * @method
   */
  '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
    if (!noupdate) {
      // console.log(this._path, val)
      this._update(val, stamp, from, remove, added, oldval);
    }
  },

  'is', function (val, cb, nextTick ) {

    //on removal of promise remove listener

    if(!cb || ( typeof cb !== 'function')) {
      var _this = this
      nextTick = cb
      // console.error('my mofo', nextTick)
      return new Promise(function( resolve, reject ) {
        // console.log('312123123213', val)
        _this.is( val, function() {
          resolve.apply(this, arguments)
        }, nextTick)
      })
    } else {
      // console.error('lezzgo')
      var cbx = nextTick ? function() {
        var args = util.arg(arguments)
          , _this = this
        raf(function() {
          cb.call(_this)
        })
      } : cb
      //TODO: add original if its not 
          // console.error('--------------', val)

      if(val==='loaded') {
        if(this.$loaded || this.from.$loaded) {
          cbx.call(this)
        } else {
          this.once('loaded', cbx)
        }
      } else {
        var ret
        // var ignore
        // console.error('1!@#@#!!@#', ret, val)

        if(this.val == val ) {
          // console.error('2!@#@#!!@#', ret, val)

          return cbx.call(this)
        } else {
          // console.error('!@#xxxxx12121212122112@#!!@#', ret, val)

          ret = (typeof val === 'function') && val.call(this)
          // ignore = true
          // console.error('2222222222!@#@#!!@#', ret, val)
        }
        if(ret) {
          if( ret instanceof Promise ) {
            // console.error('promise')
            return ret
          } else {
            // console.log('????!!!')
            return cbx.call(this)
          }
        } else {
          // console.error('22222!@!@#!@#', val)
          if(typeof val === 'function') {
            this.once(val, cbx)
         } else {
            this.once({
              $val: val
            }, cbx)
         }
        }
      }
      return this
    }
  },
  /**
   * __update
   * calls listeners attached to the Object
   * types -- function or V.Object
   * @method
   */
  '__update', _update,
  /**
   * _update
   * escalates an update up it's structure and calls __update to call listeners
   * types -- function or V.Object
   * @method
   */
  '_update', function(val, stamp, from, remove, added, oldval, test) { //here you can see if its an update from another object (from)
    // console.log('V.Object OG _update', val, stamp, from, remove, added, oldval)
    var curr = this,
    s = true

    while (curr) {
      // var p = curr._path
      // _update ["clients", "V_2pxcewv3g4k"] 
      // console.log('_update', p, val, from || ((!s && this) ? this : void 0, this) )

      //TODO 10 double check this
      curr.__update(val, stamp, from || (s!==true) ? this : false , remove, added, oldval, test)
      curr = from ? false : curr._parent
      s = false
      if (remove) remove = 1
    }
  },
  /**
   * _remove
   * called on remove
   * @method
   */
  '_remove', function(from, update, stamp, oldval) {
    if (update !== false) {
      this._update(null, stamp, from, true, false, oldval);
    }
    this.removeListener();
    var _l = this._listens,
      i, listener;
    if (_l) {
      //optimize later
      //this,this is weird to always use this...
      for (i = _l.length - 1; i >= 0; _l[i--].removeListener(this, void 0, false, true));
    }
  },
  /**
   * _setvobj
   * if a value is set to a V.Object
   * @method
   */
  '_setvobj', function(val) {
    val.addListener(this);
  },
  /**
   * _changevobj
   * if a value is changed from a V.Object
   * @method
   */
  '_changevobj', function(val) {
    if (this.__t === 4) {
      var _l = this._listens,
        _val = this._val,
        i;
      if (_l) {
        for (i = _l.length; i >= 0; _l[--i] && _l[i].removeListener(this, this));
      }
      if (_val instanceof vObject && _val._contained) {
        _val.remove();
      }
    }
  },
  /**
   * addListener
   * adds a listener to an object can be a function or V.Object
   * @method
   */
  'addListener', function( val, mark, skipcheck, ignoreval, original ) {
    var _l = this._listeners || (this._listeners = []),
      target, g;

    if(original) {
      // console.log('ORGINAL!', original)
      if(!this._listenMap) {
        this._listenMap = []
      }
    }

    //more speed voor checkarray
    if (mark) {
      g = util.checkArray(_l, val[1], 1);
      if (g === false
        || !ignoreval && util.checkArray(_l, val[0], 0) === false
        || (mark !== true && mark.call(this, _l[g], _l, g, val) === true)) {
        
        //TODO: fix this ultra dirty stuff
        if( original && val !== orginal ) {
          this._listenMap.push([ orginal, val ])
        }

        _l.push(val);
      } else  {
         return _l[g];
      }
    } else if (!val.__t || !util.checkArray(_l, val)) {

      if( original && val !== original ) {
        this._listenMap.push([ original, val ])
      }

      _l.push(val);
    }
    if (mark || val instanceof vObject) {
      target = mark ? val[1] : val;
      if (target instanceof vObject) {
        _li = target._listens || (target._listens = []);
        if (skipcheck || !util.checkArray(_li, this)) {

          if( original && val !== original ) {
            this._listenMap.push([ original, val ])
          }

          _li.push(this);
        }
      }
    }
  },
   'once', function( val, method, mark ) {

    //val, mark, skipcheck, ignoreval, orginal

    //TODO:unify /w on
    var mval

    var listen = function() {
      
      this.removeListener( mval, mark )
      // this.removeListener( listen )

      mval.apply( this, arguments )
      //original perhaps????
    }

    if( method ) {
      mval = method
      this.on( val, listen, false, mval ) //deze fn moet wel geremoved worden gebeurd nu niet!
    } else {
      mval = val
      this.on( listen, false, false, mval )
    }

    return this

  },
  'on', function( val, method, mark, original ) {
      /**
        * val can be a condition or a comparison or a method
      **/
      if( V.Base && method instanceof V.Base ) 
      {
        mark = method //make exception for values!
        method = null
      }

      if(!original) {
        original = method
      } else {
        // console.log('set original!', original, method )
      }

      if( !method ) 
      {
        _addListener( this, val, mark, original )
      }
      else 
      {
        if( util.isObj( val ) )
        {
          // console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          //Has to become a condition
          if(val.$val) {
            _addListener( this, function( nval ) {
              if( this.val === val.$val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          } else {
            console.warn('this will become a condition later on for now its not supported!, conditions will be used eveyrwhere')
          }
          //Has to become a condition


        }
        else if( typeof val === 'function' )
        {
          _addListener( this, function( nval ) {
            if( val.apply( this, arguments ) ) //more checks
            {
              method.apply( this, arguments )
            }
          }, mark, original )
        }
        else 
        {

          if( util.isObj( method ) )
          {

            mark = val

            console.warn('untested -- add as mark')
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )


          }
          else if( val === 'remove' )
          {
            //val, stamp, false, remove, added, oldval
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              if( remove ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          //TODO: in redo this will be done differently (event types are special done)
          else if( val === 'loaded' ) {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              //__frommethod

              if( this.$loaded || this.from.$loaded ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'added' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;
              if( added ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else if( val === 'self' )
          {
            _addListener( this, function( nval, stamp, from, remove, added, oldval ) {
              // console.log( added ) //werkt niet!;

              //TODO: put on in a different file
              // console.log('SHOULD DO SELF!', arguments, from ) //zo wrong!

              if( this._val === nval 
              || !val && this._updateOrigin===this //pretty slow check , its there to check when someone call .update for example
              ) 
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
          else
          {
            _addListener( this, function( nval ) {
              if( nval === val || this.val === val || this._val === val ) //more checks
              {
                method.apply( this, arguments )
              }
            }, mark, original )
          }
        }
      }
      return this
    },

  /**
   * removeListener
   * if no val removes all listeners
   * mark checks in array on position 1 for uniqueness
   * remove is used in combination with mark
   * @method
   */
  'removeListener', function(val, mark, remove, nobreak) {
    // console.log('removeListener!', this._path, this._listeners && this._listeners.length
    //   , '\nmark:\n', mark && mark.raw
    //   , '\nval:\n', val && val.name
    //   , '\nval:\n', val
    // )
    var _l = this._listeners,
      i;
    if (_l) {
      for (i = _l.length - 1; i >= 0; i--) {
        //maybe checking mark all the time is too slow?
        var listener = _l[i]
        if (
          (!mark && !val)
          || (val && listener === val) //false voor mark
          || (mark!==false && ((listener instanceof Array) && ((mark && listener[1] === mark && (!val||listener[0]===val)) || val && listener[1] === val))
            && (!remove
              || (remove === true  //dit moet later weg is dan alleen een functie is nu overbodig (check boven)
                ? listener[0] === val
                : remove.call(this, listener, mark))))
        ) {
          // console.log('mark._listens?', !!(mark && mark._listens)
          //     , '\nis vObject?', listener instanceof vObject
          //     , '\nis marked?', listener instanceof Array
          //   )
          var focus = mark
            ? mark
            : listener instanceof vObject
              ? listener
              : listener instanceof Array
                ? listener[1]
                : false
          var listens = focus && focus._listens
          if(listens){
            for(var j = listens.length-1 ; j >= 0 ; j--){
              if(listens[j] === this){
                listens.splice(j, 1)
                if(listens.length === 0)
                  focus._listens = null
                if(focus.__t === 4 && listener._val === this)
                  listener._val = void 0
                break
              }
            }
          }
          _l.splice(i, 1)
          if (_l.length === 0) this._listeners = null;
          if (val && !nobreak) break
        }
      }

      //TODO: this has to be refactored ASAP! do when new design phase for vobject+base is going down
      if( this._listenMap && val ) {
        // console.log('im here!', val)
        var piv
        for(var i = 0, _len = this._listenMap.length; i < _len; i++ ) {
          if( this._listenMap[i][0] === val ) {
             // console.log('hey its the listenmap!', val)
             this.removeListener( this._listenMap[i][1] )
             piv = i
             break;
          }
        }
        if( piv !== void 0 ) {
          this._listenMap.splice(piv, 1)
          if(this._listenMap.length === 0) {
            this._listenMap = false
          }
        }
      }

    }
  });
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","promise":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/promise/index.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = require('../util'),
  VObject = require('./'),
  V = require('../')
  _c = util.checkArray

/**
 * Gets/sets VObject origin
 * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
 * @method from
 * @param  {Object} obj [description]
 * @return {Object}     [description]
 */
var _coreSet = VObject.set,
  _from = this.from = function(obj) {
    var val = obj,
      last;

    while (val instanceof VObject) {
      // console.log(val)
      if(val._filter) {
        // console.error('IS SELECITON', val)
      }
      last = val;
      val = val._val;
    }
    return last !== obj ? last : false;
  },
  _lastLFrom = function(obj) {
    while (obj && obj.__t === 4) {
      if (obj._lfrom) {
        return obj._lfrom;
      } else {
        obj = obj._val;
      }
    }
  },
  /**
   * Returns path
   * @method _updatePath
   * @param  {Object}    till [description]
   * @return {Object}         Returns path
   */
  _updatePath = function(till, start) {
    var parent = this,
      lfrom,
      path = []; //reduce amount of new arrays
    while (parent && (parent._name !== void 0 || start)) {
      lfrom = parent._lfrom || _lastLFrom(parent)
      if (lfrom) {
        var a = _updatePath.call(lfrom),
          c = parent.from._name;
        util.add(a, path);
        path = a;
        if (c) {
          c = a.indexOf(c);
          a.splice(c, a.length - c);
        }
      }
      if (parent !== till) {
        path.push(parent._name);
        parent = parent._parent;
      } else {
        parent = false;
      }
    }
    // console.log('----->',path)
    return till ? path.reverse() : path;
  }

util.define(VObject,
  /**
   * Removes all linked containers, uses slice on arrays
   * Removes all _listeners
   * @method destroy
   */
   'toString', function( compressed ) {
      return compressed 
             ? JSON.stringify( this.raw ) 
             : JSON.stringify( this.raw, false, 2 )
   },
   'referenceLevel', function(linked) {
      var link = this
      var cnt = 0

      // console.log(link, link.__t)

      while(link && link.__t) {
        if(link===linked) {
          return cnt
        }
        link = link._val
        cnt++
      }
      return false
   },
  'destroy', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    this._removed = true
    this.destroyReferences(nested, bl, not, from, stamp, noupdate)
    this.remove(nested, bl, not, from, stamp, noupdate)
  },
  'destroyReferences', function(nested, bl, not, from, stamp, noupdate) {
    if(!stamp)
      stamp = this.stamp()

    var _l = this._listeners
      , parent
      // , item
    if (_l) {
      for (var i = _l.length, ref; ref = _l[--i];) {
        // if(listener instanceof Array){
        //   if(listener)
        // }
        // ref =  instanceof Array ? _l[i][1] : _l[i];
        if (ref instanceof VObject) {
          parent = ref._parent;
          if (parent && parent.__t === 1) {
            parent.splice(ref._name, 1);
          } else {
            ref.remove(nested, bl, not, from, stamp, noupdate);
          }
        }
      }
    }
  },
  /**
   * Performs passed function on each item.
   * Skips items in the blacklist.
   * @method
   * @param  {Function}  fn   function to perform on each
   * @param  {Boolean}   deep If true, repeats eachmethod on nested fields
   * @param  {Arguments} arg  Arguments to pass to the function
   * @return {Boolean}        [description]
   */
  'each', function(fn, deep, arg) {
    //try to make this a lot shorter
    var i, item;
    if (arg !== void 0) {
      arg = util.arg(arguments, 2);
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.apply(item, arg)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each.apply(item, arg)) {
              return true;
            }
          }
        }
      }
    } else {
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          item = this[i];
          if (fn.call(item, i)) {
            return true;
          }
          if (deep && (item.__t !== 4 || item._contained)) {
            if (item.each(fn, deep, arg)) {
              return true;
            }
          }
        }
      }
    }
  },
  /**
   * Returns the real path
   * @attribute _path
   */
    '_path', {
      get: function() {
        var parent = this
          , path = []

        while (parent && parent._name !== void 0) {
          path.push(parent._name);
          parent = parent._parent;
        }

        return path.reverse();
      }
    },
    '_cachedPath', {
      get: function() {
        return this.__cachedPath || (this.__cachedPath = this._path.join('.'))
      }
    },
  /**
   * Returns the update path
   * @attribute updatePath
   */
  'updatePath', {
    get: function() {
      var a = _updatePath.call(this, this, true),
        name = this._name;
      name !== void 0 && a.unshift(name);
      return a;
    }
  },
  /**
   * Returns the keys of an object
   * @attribute keys
   */
  'keys', {
    get: function() {
      var i, arr = [];
      for (i in this) {
        if (!_c(this._blacklist, i)) {
          arr.push(i);
        }
      }
      return arr;
    }
  },
  /**
   * Returns true if object is Ancestor
   * also return true when object is object to be compared to
   * @attribute keys
   */
  //t._d === from._parent || t._d === from
  '_ancestor', function(obj) {
    // console.log('ANCESTOR'.red.inverse, obj, this)
    var p = this
    while (p) {
      if (obj === p) return true
      p = p._parent
    }
  },
  /**
   * Get a field at first occurence in the parent chain
   * @method checkParent
   * @param  {String}  field [description]
   * @param  {Boolean} get   When true returns found instead of current
   * @return {Object}        [description]
   */
  'checkParent', util.checkParentFactory('_parent'),
  /**
   * Returns a normal object, and keeps links to V.Objects
   * @method
   * @param  {*}      [val] [description]
   * @return {Object}       [description]
   */
  'convert', function(val) {
    var obj = {}, l = 0
    if (!val || val.val) obj.val = this._val
    if (this.__t === 1) {
      obj = []
      for (var i = 0; i < this.length; i++) {
        l++
        obj[i] = this[i].convert()
      }
    } else {
      this.each(function(i) {
        if (!val || val[i]!==void 0) {
          l++
          obj[i] = this.convert()
        }
      })
    }
    if (val) {
      for (var i in val) {
        if (obj[i] === void 0) obj[i] = void 0
        l++
      }
    }
    if (!l && (!val || val.val)) obj = obj.val
    return obj
  },
  /**
   * Returns a normal object
   * @attribute raw
   */
  'raw', {
    get: function() {
      var self = this,
        type = self._filter ? 2 : self.__t,
        obj, i, l;
      if (type === 4) {
        return self._val && self._val.raw;
      } else if (type === 3) {
        return self.val; //when the type is mixed always uses val
      } else {
        if (type === 1) {
          obj = [];
          for (i = -1, l = self.length - 1; i < l; self[++i] && obj.push(self[i].raw));
        } else {
          obj = {};
          for (i in self) {
            if (!_c(self._blacklist, i) && self[i]) {
              obj[i] = self[i].raw;
            }
          }
        }
        return obj;
      }
    }
  },
  /**
   * Gets/sets object origin
   * In a chain of V.Objects e.g. x.val = y, y.val = z ---> x.from returns z;
   * @attribute from
   */
  'from', {
    set: function(val) {
      var found = _from(this)
      _coreSet.call(found || this, val)
    },
    get: function() {
      return _from(this) || this
    }
  },
  /**
   * Merge any object into another object
   * Shallow for a shallow merge
   * @method merge
   * @param  {Object}  obj      [description]
   * @param  {Boolean} shallow  [description]
   * @param  {Number}  stamp    [description]
   * @param  {Boolean} noupdate [description]
   * @return {Object}           [description]
   */
  'merge', function merge( obj, shallow, stamp, noupdate, block, sorted, deferUpdates ) {

    // console.log('MERGE---->', obj )

    var mergeArray = this._mergeArray
      , r
      , i
      , stop
      , rt
      , cobj
      , tobj
      , topLevel

    if(!deferUpdates) {
      // console.log('NO deferUpdates'.yellow.inverse)
      topLevel = true
      deferUpdates = []
    }
    //FIXME: make it better long names etc, code formatting

    if ( !stamp ) stamp = this.stamp()

    if ( this.__t === 1 ) {
      if (mergeArray) {
        mergeArray( obj, stamp, noupdate ) //hier moet ook ff deferUpdates
      } else {
        for (var j in obj) {
          cobj = obj[j]
          tobj = this[j]
          if ((j = Number(j)) > -1) {
            r = true
            if (tobj) {
              tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
            } else {
              if (j > this.length - 1) this.length = j + 1
              this.set(j, cobj, false, stamp, true, true)
            }
          }
        }
      }
    } else {
      for (i in obj) {
        stop = true
        cobj = obj[i]
        tobj = this[i]
        if (i !== 'val' && !_c(this._blacklist, i)) {
          if (!shallow && tobj && util.isObj(cobj)) { //cobj instanceof Object && (typeof cobj !== 'function') && cobj.__t !== 3)
            if (cobj.clear) {
              _coreSet.call(tobj, cobj, stamp, false, true)
              r = true
            } else {

              // console.error('---- merge /w update thats mos def wrong!', i, deferUpdates)
              //deferUpdates

              rt = tobj.merge(cobj, false, stamp, true, block, sorted, deferUpdates )
              if (r !== true) r = rt

              if (!rt) 
              {
                // console.log('0000')
                obj[i] = void 0
              }
            }
          } else {

            if (tobj && tobj._val === cobj) { //changed to differentiate between 0 and false, now also differentiates between 1 and '1'
                // console.log('---- 2 update thats mos def wrong!', i)

              if (r !== true) r = false
              // console.log('???????')
              obj[i] = void 0
            } else {
              // console.log('---- 3 update thats mos def wrong!', i)
              if(cobj===null && this[i]) {
                this[i].remove( false, false, false, void 0, stamp )
              } else {
                // console.log('!?'.bold, i, this[i])
                //name, val, vobj, stamp, noupdate, from
                this.set( i, cobj, false, stamp, true )
                // console.log('!xxxx?', i)
                if(this[i] && this[i]._listeners) {
                  // console.log('push push'.green,  JSON.stringify(obj) )
                  deferUpdates.push( [this[i], cobj] )
                }
                //add dit naar list
              }
              if (!r) r = rt;

              // console.warn(r, rt)

              if (!rt) 
              {
                //TODO: TEMP FIX DONT KNOW IF THIS WORKS!
                // console.log('???????22222')
                // obj[i] = void 0
                // console.warn('cant be right!')
                //SUPER CAREFULL WITH THIS R THING!!!!!
                r = true
              }
            }
          }
        }
      }
      if (obj.val) {
        rt = _coreSet.call(this, obj.val, stamp, false, true)
        if (!r) {
          r = rt
        }
        if (!rt) {
          obj.val = void 0
        }
      } else if (!stop) {
        if (!r) {
          r = false;
        }
      }
      r = (r !== false) || r
    }

    if (r) {
      if (!block) {
        // alert(noupdate)
        if (noupdate) {

          // console.log('!!??????????? NOUPDATE'.blue, JSON.stringify(obj))

          if(topLevel) {
            // console.log('UPDATE>?'.magenta.inverse, obj, JSON.stringify( obj ), noupdate, stamp)
            this._update(obj, stamp)
          }
          else {
            this.__update(obj, stamp)
            deferUpdates.push([ this, obj ])
          }
        } else {
          
          // console.log('2UPDATE>?'.cyan.inverse, topLevel, deferUpdates, obj, noupdate, stamp)

          this._update( obj, stamp )
        }
      }
    }
   

    if(topLevel && deferUpdates) {
      // console.log( 'defered updace', topLevel, deferUpdates)
      for(var df in deferUpdates) {
        if( deferUpdates[df][0] && deferUpdates[df][0].__update ) {
          // console.log('DEFERED!!!!'.cyan.inverse, df, deferUpdates[df][1], stamp )
          deferUpdates[df][0].__update( deferUpdates[df][1], stamp )
        }
      }
    }
    return r
  },
  /**
   * Copies an object and returns a new one, can also pass a merge object
   * @method
   * @param  {Object}        obj       Object to copy
   * @param  {Boolean}       [shallow] [description]
   * @param  {Array|Object}  [list]    Takes any object with .length
   * @param  {Object}        [parent]  [description]
   * @return {Object}                  [description]
   */
  'clone', function(obj, shallow, list, parent) { //support shallow!; check obj copy only what is nessecary added makeshort , made parent shorter
    var copy = new this._class(),
      _val = this._val,
      i;
    if (parent) {
      copy._parent = parent;
    }
    copy.__t = this.__t;
    if (this.__t === 1) {
      copy.length = this.length;
    }
    if (list) {
      //list
      for (var j = list.length - 1, item; j >= 0; j--) {
        item = list[j];

        if (item instanceof Array && this[item[0]]) {
          if(item[1] === true) {
            copy[item[0]] = util.clone(this[item[0]], false, true)
          } else {
            copy[item[0]] = item[1];
          }
        } else if (this[item]) {
          // console.log(item)
          copy[item] = this[item];
        }
      }
    }
    if (_val && (_val instanceof VObject && _val._contained)) {
      copy.val = _val.clone(copy, false, list, copy);
      copy._val._contained = true;
    } else {
      VObject.set.call(copy, _val, false, false, true);
    }
    for (i in this) {
      if (!_c(this._blacklist, i)) {
        // console.log(i)
        if (!shallow) {
          if (this[i] instanceof VObject) {
            //function( name, val, vobj, stamp, noupdate, from )

            // console.log('----->1', i, this[i].clone(void 0, false, list, copy))
            //stamp void 0
            copy.set(i, this[i].clone(void 0, false, list, copy), true, false, true)
          } else {

            // console.log('----->2', i, util.clone(this[i]))

            copy[i] = util.clone(this[i]);
          }
        } else {
          //function( name, val, vobj, stamp, noupdate, from )
          copy.set(i, this[i], false, false, true);
        }
      }
    }
    if (obj !== void 0) {
      if (util.isObj(obj)) {
        // console.log('MERGE----->', obj, shallow)
        copy.merge(obj, shallow);
      } else {
        VObject.set.call(copy, obj, false, false, true)
      }
    }
    copy.__t = this.__t;
    return copy;
  },
  /**
   * Returns object on the end of a defined path
   * @method path
   * @param  {Array}     path           Array of fields in path
   * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
   * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
   * @param  {Function}  [writeHandler] Callback on write
   * @return {*}                        Object on the end of a defined path
   */
  'path', function(path, val, overwrite, writeHandler, vobj, stamp, noupdate, self) {
    if(!(path instanceof Array)) path = path.split('.');
    return util.path(this, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self);
  },
  /**
   * Gets object from specified path. When path is a string checks for 'dotnotation'.
   * @method get
   * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
   * @return {*}                 obj[path]|nested object/value
   */
  'get', function(path, self) { //get does not need an array as path
    return util.get(this, path, self);
  },

  //(val, stamp, from, noupdate, add)
  // '$set', function( val, stamp, from, update ) { //get does not need an array as path

  //   return VObject.set.call( this, val, stamp, from, !update )
    
  //     '_set', function(val, stamp, from, remove, noupdate, added, oldval) {
  //   if (!noupdate) {
  //     (val, stamp, from, noupdate, add)
  //     // console.log(this._path, val)
  //     this._update(val, stamp, from, remove, added, oldval);
  //   }
    

  // },
  /**
   * Check if obj is empty exclude field names passed to list
   * @method empty
   * @return {Boolean} True/false
   */
  'empty', {
    get: function() {
      return util.empty(this, this._blacklist);
    }
  },
  '$empty', function( excludes, update ) {
      //get does not need an array as path
      var _this = this
      this.each( function( key ) {
        if( 
            !excludes 
              || typeof excludes === 'string'  
                 ? key !== excludes 
                 : !util.checkArray( excludes, key ) 
          )
        {
          if( this.remove ) 
          {
            this.remove( false, false, false, false, false, true )
          } 
          else 
          {
            // console.warn( '$empty non-vObject object.util remove', this, key )
            _this[key] = null
          }
        }
      })
    
      if( this.clearCache ) this.clearCache()

      if( update )
      {
        this._update('empty')
      }
  },
  /**
   * Returns the V.Object from which the current update originated.
   * @method _updateOrigin
   * @return {V.Object} origin of the update
   */
  '_updateOrigin', {
    get: function() {
      var mark = this;
      // console.error('get UPDATE ORIGIN', this._path, this._lfrom)
      while (mark._lfrom) {

        //if V.CloudData
       // console.error( '_update that origin!', mark._path )
        mark = mark._lfrom;
      }
      return mark;
    }
  },
  '_origin', {
    get: function() {
      var mark = this;
      while (mark && mark.__t === 4) {
        mark = mark._val;
      }
      return mark;
    }
  }
)


//add find


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js":[function(require,module,exports){
(function (__dirname){
var util = require('../')
  , ajax
  , PACKAGE = '/package.json'

module.exports = exports = function( callback, params, packageFile, noReplace ) {

  packageFile = packageFile || ( util.isNode ? {} : window.package )

  var obj = {}
    , req = module.exports
    , cb = callback && function( pckg ) {

      obj = pckg.vigour
      req.parse( obj, packageFile, req._checks )

      if(!noReplace) module.exports = obj
      callback(obj)
    }

  //default option add more!
  if(!params) {
    exports.options.val(obj, cb, false, packageFile )
  } else if(exports.options[params]) {
    exports.options[params](obj, cb, false, packageFile )
  } else {
    exports.options.val(obj, cb, params, packageFile )
  }
  return obj
}

if(util.isNode) {
  exports.options = {
    val:function( obj, callback, params, pckg ) {
      callback( pckg )
    }
  }
} else {
  ajax = require( '../../browser/network/ajax' )
  exports.options = {
    val:function(obj, callback, params) {
      if( !window.package ) {
        var domain = !window.cordova && String(window.location)
            .match(/https?:\/\/([^\/]+)/)

        if(domain) domain = domain[0]
         
        ajax({
          url:params && params.url ? params.url : domain+PACKAGE,
          fallback: [
              { url: PACKAGE } //for testing
            , params && params.fallback ? params.fallback : { url: __dirname+PACKAGE }
            , { url: '../'+PACKAGE }
            , { url: '../../'+PACKAGE }
            , { url: '../../../'+PACKAGE }
          ],
          complete:function(data) {
            window.package = data
            if(callback) callback(data)
          }
        })
      } else if(callback) {
        callback(window.package)
      }
    }
  }
}

exports.inject = function() {
  exports._checks = util.arg(arguments)
  return exports
}

exports.loop = function(obj, option, pckgval, merge, fn, params ) {
  if(fn) {
    var val = option(obj,pckgval,merge, params)
    if(val) { util.merge(obj,val) }
  } else {
    for(var h in obj[option]) {
      if((pckgval===h)) {
        util.merge(obj,merge[h])
        break
      }
    }
  }
}

exports.parse = function( obj, pckg, options, params ) {
 if(!(options instanceof Array)) {
    options = [options]
 }

 for(var i in options) {
    for(var check in options[i]) {
      var pckgval = util.get(pckg,check)
        , option = options[i][check]

      exports.loop(obj, option, pckgval, obj[options[i][check]], typeof option === 'function',params)
    }
  }
  return obj
}

}).call(this,"/node_modules/vigour-js/util/config")

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../browser/network/ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/ua.js":[function(require,module,exports){
var ua = require('../../browser/ua')
  , util = require('../')
  , Data = require('../../data').inject(require('../../data/selection'))
/*
selection!

*/
bla = exports

exports.parse = function(obj, pckgval, merge, params) {
  var _ua = ua

  if(params && params.ua) {
    _ua = ua.parse(params.ua.toLowerCase(),{})
  }

  // console.log('HERE!',obj,pckgval,merge)
  var cond
    , uaclone = new Data({bla:util.clone(_ua)})

  if(obj.ua) {
    for(var i in obj.ua) {
      if(_ua.platform===i||_ua.device===i||_ua.browser===i) {
        return obj.ua[i]
      } else if(obj.ua[i].condition) {
        if(!cond) {
          cond = new Data(uaclone, obj.ua[i])
        } else {
          cond.filter = obj.ua[i]
        }
        if(cond.length) {
          delete obj.ua[i].condition
          cond.remove()
          return obj.ua[i]
        }
      }
    }
  }


  //blabla

  // console.log('SUBOBJ???',obj)


  delete obj.subsObj

  if(cond) cond.remove()
}


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js","../../data":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/index.js","../../data/selection":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/data/selection.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js":[function(require,module,exports){
(function (process){
var debug = exports

DEBUG$ = debug

/*
  console.log('util/test \n\nif you want to check memory usage start chrome using: \n\n open -a Google\\ Chrome --args --enable-memory-info \n')
*/
var util = require('../')
  , isNode = util.isNode //has to become part of util
  , V = require('../../')
  , log = debug.log = require('./log')
  , debuglog = log.logger('DEBUG$', 'rainbow')

debug.perf = debug.performance = require('./performance')

//------------------------------------------------------------------------------

if(!isNode) {
  debug.cases = require('../../browser/cases/')
  exports.body = document.body.base
  Object.defineProperty(module.exports, 'domain', {
    get: function() {
      //debugger --- can go away with a transform
      return String(window.location)
        .match(/https?:\/\/([^\/]+)/)[1]
        .replace(/:.+/, '')
    }
  })

} else {
  var DEBUG = process.env.DEBUG
  if(DEBUG){
    var levels = DEBUG.split(',')
    for(var l in levels){
      var two = levels[l].split(':')
      DEBUG$.level[two[0]] = two[1] ? Number(two[1]) : 3
    }
  }
}

//------------------------------------------------------------------------------

exports.int = function(rand, fn) {
  function func() {
    rand = rand||1000
    return ~~(Math.floor(Math.random()*rand))
  }
  return fn ? func() : func
}

exports.text = function (length, fn, str, nolines, strict) {
  if (fn) {
    return function() {
      return exports.text(
        Math.round(Math.random() * length) + 1, false, str, nolines, strict
      )
    }
  }
  else {
    var s = ['.', '.', '.', ';', ',']
      , b = ['ab', 'able', 'zo', 'x', 'lax', 'bur', 'rem', 'lur', 'fur', 'jur', 'lex', 'rex', 'wurd',
        'shur', 'burn', 'heps', 'a', 'i', 'y', 'u', 'e', 'p', 'l', 'splurf']
      , output = ''
      , nospace = 0

    if (str) b = str

    str = function () {
      return b[Math.round(Math.random() * (b.length - 1))]
    }
    if (!length) length = ~~ (Math.random() * 101)
    for (var i = 0, g; i < length; i++) {
      if ( !strict && (!output[output.length - 1]
        || output[output.length - 2] === '.'
        || output[output.length - 2] === '\n')
      ) {
        g = str()
        output += g[0].toUpperCase() + g.slice(1)
      }
      else {
        output += str()
      }
      nospace++
      if (!strict && ~~(Math.random() * (nospace / 2))) {
        var br = false
          , v
        if (!nolines && ~~(Math.random() * 21) > 17) {
          v = s[~~(Math.random() * (s.length - 1))]
          output += v
          if (v === '.' && ~~(Math.random() * 11) > 6) {
            br = true
            output += '\n'
            if (~~(Math.random() * 11) > 7) output += '\n';
          }
        }
        if (!br) output += ' '
        nospace = 0
      }
    }
    return output
  }
}

exports.data = function (populate, level, obj, cnt, prev) {
  if (!obj) obj = {}
  if (!cnt) cnt = 0
  if (!level) level = 0
  for (var i in populate) {
    if ((populate[i] instanceof Object)
      && populate[i].length && populate[i].val
    ) {
      if (populate && populate[i]) {
        obj[i] = []
        for (var j = 0; j < populate[i].length; j++) {
          obj[i][j] = typeof populate[i].val === 'function'
            ? populate[i].val()
            : exports.data(populate[i].val, (level + 1), false, j + 1, obj)
        }
      }
    }
    else if ((populate[i] instanceof Object)
      && (typeof populate[i] !== 'function')
    ) {
      obj[i] = exports.data(populate[i], (level + 1), obj[i], false, cnt, obj)
    }
    else if (populate && populate[i]) {
      obj[i] = (typeof populate[i] === 'function')
      ? populate[i].call(obj, cnt, prev)
      : populate[i];
    }
  }
  return obj;
};

//------------------------------------------------------------------------------
debug.download = function(filename, text) {
  var pom = document.createElement('a');
  pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  pom.setAttribute('download', filename);
  pom.click();
}

//------------------------------------------------------------------------------
debug.remote = function(id) {
  var fileref = document.createElement('script')
  fileref.setAttribute("type", "text/javascript")
  fileref.setAttribute("src", 'http://jsconsole.com/remote.js?'+id)
  document.getElementsByTagName("head")[0].appendChild(fileref)
}

debug.findScript = function(node,name,strict) {

  var children = node.childNodes
    , extension = name.match(/\.([a-zA-Z0-9]{1,30})$/)[1]
    , regExp = !strict && new RegExp(name+'$')
    , field = extension === 'js' ? 'src' : 'href'

  for(var i in children) {

    if(strict ? children[i][field]===name : regExp.test(children[i][field])) {
      return children[i]
    }

  }

  // console.log('notfound', name)
}

function prompty (msg, value, cb) {
    var dialog = document.createElement("div")
        , p = document.createElement("p")
        , input = document.createElement("input")
        , ok = document.createElement("button")
        , cancel = document.createElement("button")
    p.appendChild(document.createTextNode(msg))
    input.type = "text"
    input.value = value
    input.style.display = "block"
    ok.appendChild(document.createTextNode("OK"))
    cancel.appendChild(document.createTextNode("Cancel"))
    ok.addEventListener('click', function () {
        hideDialog()
        cb(input.value)
    })
    cancel.addEventListener('click', function () {
        hideDialog()
        cb(null)
    })
    dialog.appendChild(p)
    dialog.appendChild(input)
    dialog.appendChild(ok)
    dialog.appendChild(cancel)
    dialog.style.position = "absolute"
    dialog.style.top = 25 + "px"
    dialog.style.left = 50 + "px"
    dialog.style.zIndex = 1000
    dialog.style.fontSize =  24 + 'px'
    dialog.style.backgroundColor = "white"
    document.body.appendChild(dialog)
    function hideDialog() {
        dialog.parentNode.removeChild(dialog)
    }
}

debug.native = function(def, parse, cb, file) {
  if(!document.getElementById('dev')) {
    var elem = document.createElement('div')
    elem.id = 'dev'
    elem.style.zIndex = 9999999
    elem.style.position = 'absolute'
    elem.style.left = '2px'
    elem.style.top = '80px'
    elem.style.padding = '15px'
    elem.style.backgroundColor = 'rgba(50,50,50,0.8)'
    elem.style.borderRadius = '50%'
    elem.addEventListener('click',function() {
      prompty('IP', localStorage.getItem('devip') || def || 'http://10.0.1.2:8080', function (ip) {
        if (ip) {
          localStorage.setItem('devip',ip)
           window.location.reload()
        } else {
          // alert('x')
          localStorage.removeItem('devip')
          window.location.reload()
        }
      })
    })
    document.body.appendChild(elem)
  }

  if(!file) {
    file = 'build'
  }

  if( localStorage.getItem('devip') ) {
    DEBUG$.remoteResource(localStorage.getItem('devip')+'/bundle.css',file+'.css',false)
    if(DEBUG$.remoteResource(localStorage.getItem('devip')+'/bundle.js',file+'.js',false)) {
      document.getElementById('dev').style.backgroundColor = 'rgba(0,255,0,0.8)'
      if(cb) cb(localStorage.getItem('devip'))
      return true
    } 
  }
}

//hier remoteresource gebruiken
debug.remoteResource = function(src, replace, strict) {
  console.log('remote resource',src)
  var strict = strict !== void 0 ? strict : true
    , extension = src.match(/\.([a-zA-Z0-9]{1,30})$/)[1]
    , fileref = document.createElement(extension==='js' ? 'script' : 'link')
    , head =  document.getElementsByTagName("head")[0]
    , body = document.body
    , found
    , fileSrc

  if(!replace) {
    strict = false
    replace = src.match(extension==='js'
      ? /(\/)([a-zA-Z0-9-_+$]){0,30}\.js$/
      : /(\/)([a-zA-Z0-9-_+$]){0,30}\.css$/
    )[0].slice(1)


  }

  fileSrc = src+'?'+ ~~(Math.random()*9999999)

  if(extension==='js') {
    fileref.setAttribute("type", "text/javascript")
    fileref.setAttribute("src", fileSrc)
  } else {
    fileref.setAttribute("type", "text/css")
    fileref.setAttribute("rel", "stylesheet")
    fileref.setAttribute("href", fileSrc)
    fileref.setAttribute("id", fileSrc)
  }

  found = debug.findScript(head,replace,strict)

  if(!found) {
      console.log(body, found, '!@!@#!@#JS')

    found = debug.findScript(body,replace,strict)
  }
  if(found) {

    console.log('remote resource found:',found, found.src , fileSrc, src)

    var parent = found.parentNode
    if(String(found.src).indexOf(src)>-1) {
      return
    }

    parent.removeChild(found)
    parent.appendChild(fileref)
    return true
  }
}

}).call(this,require('_process'))

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../../browser/cases/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","./log":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/log.js","./performance":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/performance.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/log.js":[function(require,module,exports){
var debug = require('./') 
  , util = require('../') 
  , isNode = util.isNode //has to become part of util
  , V = require('../../')
  , repl
  , colors
  , origConsole = console
  , colors = {
      green:'#56db68',
      red:'#ff0000',
      grey:'#ccc',
      yellow:'#e0e67c',
      cyan:'#00ffff',
      magenta:'#ff00ff',
      blue:'#1111ff',
      white:'#fff'
    }
  , styles = {
      bold:'font-weight:bold;font-size:16px;line-height:15px',
      underline:'border-bottom:1px solid',
      italic:'font-style:italic',
      inverse:function(color) {
        if(color) {
          return color+';background-color:#333;padding:5px;line-height:20px'
        } else {
          return 'color:'+colors.white+';background-color:#333;padding:5px;line-height:20px'
        }
      }
    }

debug.level = 
{ DEBUG$: Infinity
, test:2
}



/*
bold
italic
underline
inverse
yellow
cyan
white
magenta
green
red
grey
blue
rainbow
zebra
random
*/

//------------------------------------------------------------------------------

var logObject
  , parseObject
  , LOG
  , INFO
  , ERROR
  , DETAIL

if (!isNode) { 

  LOG = ':'
  INFO = '::'
  ERROR = 'ERREX!'
  DETAIL = ':::'

  // console = {}
  function loglink(i) {
    return function() {
      // console.log(i, arguments)
      // console.log(new Error().stack)

      origConsole[i].apply(origConsole, arguments)
    }
  }

  // for(var i in origConsole) {
  //   if(i !== 'log') console[i] = loglink(i)
  // }

  var Color = function(val,code,s) {
    this.color =  (s ? code : 'color: '+code)+';'
    this.val = new String('%c'+val)
  }
  
  // console.log = function() {

  //   var next = false

  //   for(var i=0, arg, rargs=[], args = arguments,len = args.length;i<len;i++) {
  //     arg = args[i]
  //     if(arg instanceof Color) {
  //       if(rargs.length){
  //         next = util.arg(args, i)
  //         break
  //       }else{
  //         rargs.push(arg.val.valueOf(), arg.color)
  //       }
  //       // logger(arg.val.valueOf(), arg.color)
  //     } else {
  //       rargs.push(arg)
  //     }
  //   }
  //   // logger('now log', rargs)
  //   if(rargs.length) logger.apply(origConsole,rargs)
  //   // logger('next', next)
  //   if(next.length) console.log.apply(null,next)

  // }

  function color(i, Class, style) {
    util.define(Class || String,i,{
      get:function() {
        if(Class) {
          if(typeof style === 'function') {
            this.color = style(this.color)
          } else {
            this.color+=(style||('color:'+colors[i]))+';'
          }
          return this
        } else {
          var s = colors[i]
          if(style) {
            if(typeof style === 'function') {
              s = style()
            } else {
              s=style
            }
          }
          return new Color(this,s,style)
        }
      }
    })
  }

  // function logger() {


  //   origConsole.log.apply(origConsole,arguments)


  // }

  // for(var i in colors) { color(i) }
  // for(var i in styles) { color(i, false, styles[i]) }  
  // for(var i in colors) { color(i, Color) }
  // for(var i in styles) { color(i, Color, styles[i]) }  

  parseObject = function(obj) {
    if(typeof obj === 'string') return obj
    var str = ''
    for(var i in obj) {
      str += i + ' : ' + (typeof obj[i] === 'string' 
        ?  obj[i] 
        : JSON.stringify(obj[i],false,2)) 
      + '\n'
    }
    return str.inverse.green
  }
  
  logObject = function(obj) {
    console.log(parseObject(obj))
  }
  
} else {
  repl = require('repl')
  colors = require('colors')

  LOG = 'log  '.grey
  INFO = 'info '.green
  ERROR = 'error'.red
  DETAIL = '-----'.grey

  debug.repl = function() {
    repl.start('>')
    return debug
  }
  if(repl.context) repl.context.DEBUG$ = DEBUG$

  console.group = function() {
    console.log('\n____________________________________________________'.grey)
  }      
  console.groupEnd = function() {
    console.log('____________________________________________________\n'.grey)
  }
  var n_util = require('util')
  parseObject = function(obj){
    return n_util.inspect(obj,{colors:true, depth: 50})
  }
  logObject = function(obj){
    console.log(parseObject(obj))
  }
}

//------------------------------------------------------------------------------

util.define(Object,'DEBUG$log', function(msg,s) {
  if(console.group) console.group()
  if(typeof msg === 'string') {
    msg = msg
  } else {
    msg = false
  }
  var h = 'JSON '+(msg||' normal')
  debug.log.header(h)
  if(debug.level.test>1) console.log(JSON.stringify(this,false,2))
  if(s) {
    console.log('\n')
    debug.log.fn.apply(this,util.arg(arguments,1)) 
  }
  // debug.log.end(h)
  if(console.group) console.groupEnd()
  return JSON.stringify(this,false,2)
})

if(!isNode && localStorage) {
  util.define(localStorage,'DEBUG$log', function(msg,s) {
    if(console.group) console.group()
    if(typeof msg === 'string') {
      msg = msg
    } else {
      msg = false
    }
    var h = 'localStorage '+(msg||' normal')
    debug.log.header(h)

    var obj = {}
    for(var i in this) {
      // console.log(i, this)
       try { obj[i] =JSON.parse(this[i]) } catch(e){
        obj[i] = this[i]
       }
    }

    // console.log()

    if(debug.level.test>1) console.log(JSON.stringify(obj,false,2))
    if(s) {
      console.log('\n')
      debug.log.fn.apply(this,util.arg(arguments,1)) 
    }
    // debug.log.end(h)
    if(console.group) console.groupEnd()
    return obj
  })
}

//------------------------------------------------------------------------------

var log = module.exports = exports = {
  stack: false,
  i:function(nr) {
    nr = this.indent
    var str = ''
    for(var i in nr) {
      str+='  '
    }
    return str
  },
  parse: parseObject,
  object: logObject,
  default: function(label, level){
    if(label instanceof Object)
      for(var l in label)
        setDefault(l, label[l])
    else
      setDefault(label, level)
  },
  logger:function(label, color, level){
    log.default(label, level || 1)
    
    function logger(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 2) {
//         console.log.apply(null, [label[color].bold, LOG].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
    }

    logger.info = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 1) {
        console.log.apply(null, [label[color].bold, INFO].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
        
    }
    logger.error = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 0) {
        console.log.apply(null, [label[color].bold, ERROR].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }
    }
    logger.detail = function(){
      var level = debug.level.global !== undefined ? debug.level.global : debug.level[label]
      if(level > 3) {
        console.log.apply(null, [label[color].bold, DETAIL].concat(util.arg(arguments)))
        if(log.stack) console.log(smallStack(log.stack).grey)
      }      
    }
    logger.parse = parseObject
    return logger
  },
  label: function(label, style, log){
      if(isNode) {
        console.log.apply(null, log)
      } else {
        console.log.apply( null
          , ['%c '+label+' ', style].concat(log)
        )
      }
  },
  header:function(msg) {
    this._lh = msg
    console.log(msg.inverse)
  },
  header2:function(msg) {
    this._lh = msg
    console.log(msg.grey.inverse)
  },
  end:function(msg) {
    console.log(('end ['+msg+']').grey.inverse)
  },
  level:function(level,field) {
    if(level >= debug.level.test 
      ||  debug.level[level] 
      || field && debug.level[level]>=field ) 
      console.log.apply(this,util.arg(arguments,1))
  },
  fn:function(arg) {
    debug.log.indent++
    if(typeof arg === 'function') {
      arg.call(this,util.arg(arguments,1))
    } else {
      console.log(arguments)
//       console.log.apply(this,arguments)
    }
    debug.log.indent--
  },
  indent:0
}

//------------------------------------------------------------------------------
function smallStack(lines){
  if(!lines) lines = 1
  var stack = new Error().stack.split('\n')
    , l = 3
    , result = []
    , end

  while(lines--){
    line = stack[l++]
    end = line[line.length-1] === ')' ? line.length-1 : line.length
    result.push(line.slice(line.indexOf('/'), end))
  }

  return result.join('\n').grey
  
}

function setDefault(label, level){
  if(debug.level[label] === void 0) debug.level[label] = level
}

setTimeout(function() {
//   console.log('log levels:\n', log.parse(debug.level))
},0)

//Localstorage

/*
var localStorageSpace = function(){
        var allStrings = '';
        for(var key in window.localStorage){
            if(window.localStorage.hasOwnProperty(key)){
                allStrings += window.localStorage[key];
            }
        }
        return allStrings ? 3 + ((allStrings.length*16)/(8*1024)) + ' KB' : 'Empty (0 KB)';
    };

*/

util.define(debug,'localStorageSize', {
  get:function() {
  var total = 0
  for(var x in localStorage) {
    var kbytes = (((x.length+localStorage[x].length))/(1024))
    total+=kbytes
    // console.log((x+":"+kbytes.toFixed(10)+" KB").grey)
  }
  console.log('LOCAL STORAGE SIZE TOTAL'.inverse.green, (total/1024).toFixed(5)+' MB')
  return total*1024
}
})

util.define(debug,'localStorageKeysSize', {
  get:function() {
  var total = 0
  for(var x in localStorage) {
    var kbytes = (((x.length))/(1024))
    total+=kbytes
    // console.log((x+":"+kbytes.toFixed(10)+" KB").grey)
  }
  console.log('LOCAL STORAGE KEY SIZE TOTAL'.inverse.green, (total/1024).toFixed(5)+' MB')
  return total*1024
}
})



},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js","colors":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/node_modules/colors/colors.js","repl":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js","util":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/util/util.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/performance.js":[function(require,module,exports){
(function (process){
var util = require('../') 
  , debug = require('./') 
  , isNode = util.isNode //has to become part of util
  , os

if (isNode) { 
  os = require('os')
} else {
  console.log('DEBUG \n\nif you want to check memory usage start chrome using: \n\n open -a Google\\ Chrome --args --enable-memory-info --js-flags="--expose-gc"\n'.grey)
}

function _test(method, name, complete, call, args, nolog) {
  var start = exports.now()
    , memorystart = exports.memory()
    , memoryend
    , mem
    , time
    , end
    , sub 
  if (!name) name = 'TEST PERFORMANCE'
  if (call) {
    sub = method.apply(call, args)
  } 
  else {
    sub = method.apply(this, args)
  }
  end = exports.now()
  memoryend = exports.memory()
  mem = (memoryend - memorystart)
  time = end - start - (sub || 0)
  if (complete) {
    complete(((time) / 1000), (memoryend - memorystart))
  } 
  else if (!nolog) {
    if(debug.level.test>0) {
      console.log( 
        name.inverse , '\nparse time: ' 
        + ((end - start) / 1000) 
        + ' sec' + (mem ? '\nmemory used (approximate): ' 
        + mem + ' bytes' : '')
      )
    }
  }
  return time
}



var oldCheck = []
debug.countNewListeners = function( obj, amount ) {
  
  amount = {val:0}

  var checknow = []

  debug.countListeners( obj, amount, checknow ) 

  var newlistners = []

  for( var i in checknow ) {

    if( util.checkArray( oldCheck, checknow[i] ) === false ) {
      // console.log(checknow[i])
      // if( typeof checknow[i] === 'object' || typeof checknow[i] === 'function' ) {
        // console.log('lets push')
        // if(!util.empty(checknow[i])) {
        newlistners.push( checknow[i] )
        // }
      // }
    }
  }

  oldCheck = checknow

  return {
    amount: amount.val
  , newchecks: newlistners
  }

}


debug.countListeners = function(obj, amount, checked) {
  var amount 
    , checked 

  if(!checked) {
    checked = []
  }

  if(util.checkArray(checked, obj)!==false || !obj) {
    return amount.val
  }
  checked.push(obj)

  if(!amount) amount = {val:0}
  if(obj._listeners) {
    amount.val+=obj._listeners.length
  }

  if(!obj.each) {

    if(obj instanceof Object) {
      for(var i in obj) {
        if(obj[i] && ( obj[i].__t || obj[i]._from || obj._from && i ==='cloud') ) debug.countListeners(obj[i],amount,checked)
      }
    }

  } else {

    obj.each(function(i) {
      debug.countListeners(this,amount,checked)
    })

  }

  return amount.val
}

debug.countSubs = function(obj, amount, key) {
  var amount 
  if(!amount) amount = {val:0}
  if(obj._subs) {
    console.log('!!!!!SUB', obj._path, obj._subs)
    amount.val+=obj._subs.length
  }
    
  if(!obj.each) {
    console.log('no EACH!', key)
  }
  // console.log(obj, obj._subs)
  obj.each(function(i) {
    debug.countSubs(this,amount,i)
  })
  return amount.val
}

function _done(params, time, mem) {
  if (params.complete) {
    params.complete(time, mem, params, exports.average(time)[0], exports.average(time)[1])
  } else {
    if(debug.level.test>0) {
      console.log(
        params.name.inverse 
        , ' n=' + params.loop 
        + '\nparse time:' 
        + (params.extensive 
          ? (' \n\n' + time.join(' sec\n') + ' sec\n\n') 
          : '') 
        + 'average: ' + exports.average(time)[1] 
        + ' sec\ntotal: ' 
        + exports.average(time)[0] + ' sec')
    }
    //+(mem.length>0 ? '\nmemory used (approximate): '+mem+' kb' : '');
  }
}

module.exports = exports = function (params, fn) {
  if (fn && typeof params === 'string') {
    return _test(fn, params)
  } 
  else if (typeof params === 'function') {
    return _test(params)
  } 
  else if (params instanceof Object) {
    if(!params.name) params.name = 'performance test'

    if (params.loop) {
      //testing memory in loop is hard since the gc almost never makes it before next iteration;
      var time = []
        , mem = []
        , callback = function (_time, memory) {
          time.push(_time)
          if (memory) mem.push(memory)
        }

      if(params.interval) {
        var cnt = 0
          , interval = setInterval(function() {
              cnt++
              if(cnt===params.loop-1) {
                 clearInterval(interval)
                 _done(params, time, mem) 
              } else {
                _test(params.method, false, callback)
              }
            },params.interval)
      } else {
        for (var i = params.loop; i > 0; i--) {
          _test(params.method, false, callback)
        }
        _done(params, time, mem) 
      } 
      return exports.average(time)
    } 
    else {
      return _test(params.method
        , params.name
        , params.complete
        , params.call
        , params.args
        , params.nolog)
    }
  }
}

if(debug.log) debug.log.default('test', 4)

exports.now = function () {
  return isNode
    ? process.hrtime()[0] * 1000 + process.hrtime()[1] * 0.000001 
    : (window.performance && window.performance.now 
      ? window.performance.now() 
      : new Date().getTime())
}

exports.memory = function () {
  return isNode 
    ? process.memoryUsage().heapUsed 
    : (window && window.performance && window.performance.memory 
      ? window.performance.memory.usedJSHeapSize * 0.000976562 
      : 0)
}

exports.average = function (array) {
  var number = 0
  for (var i = array.length - 1; i >= 0; i--) {
    number += array[i]
  }
  return [number, number / array.length]
}

}).call(this,require('_process'))

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/debug/index.js","_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js","os":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/os-browserify/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/global.js":[function(require,module,exports){
(function (process,global){
var g = typeof window !== 'undefined'
        ? window
        : typeof global !== 'undefined'
          ? global
          : false
  , hasLS = typeof localStorage !== 'undefined'
  , hasPR = typeof process !== 'undefined'

var G = module.exports = 
  { session: function(key, val){
      return getSet(g, key, val)
    }
  , env: function(key, val){
      if(hasLS)
        return getSet(localStorage, key, val, 'getItem', 'setItem')
      else if(hasPR)
        return getSet(process.env, key, val)
    }
  }

function getSet(thing, key, val, getter, setter){
  if(!thing)
    return

  if(val === void 0){
    if(getter)
      return thing[getter](key)
    else
      return thing[key]
  }else{
    if(setter){
      thing[setter](key, val)
      return val
    }else{
      return thing[key] = val
    }
  }
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"_process":"/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/node_modules/process/browser.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/hash.js":[function(require,module,exports){
//check this for more compression http://www.htmlgoodies.com/html5/client/optimizing-websockets-bandwidth.html#fbid=6QZx8napu20

/*
var crcTable
  , create = function () {
      crcTable = []
      for (var c, n = 0, k; n < 256; c = ++n) {
        for (k = 0; k < 8; k++, c = ((c & 1) ? ((0xEDB88320) ^ (c >>> 1)) : (c >>> 1)));
        crcTable[n] = c
      }
      return crcTable
    }

exports = module.exports = function (str) {
  for (var tab = crcTable || create(), crc = -1, i = 0, l = str.length; i < l; i++) {
    crc = (crc >>> 8) ^ tab[(crc ^ str.charCodeAt(i)) & 0xFF]
  }
  return exports.encode(((crc ^ (-1)) >>> 0))
}


*/

exports = module.exports = function(key, seed) {
  var remainder, bytes, h1, h1b, c1, c1b, c2, c2b, k1, i;
  seed = 1

  remainder = key.length & 3; // key.length % 4
  bytes = key.length - remainder;
  h1 = seed;
  c1 = 0xcc9e2d51;
  c2 = 0x1b873593;
  i = 0;
  
  while (i < bytes) {
      k1 = 
        ((key.charCodeAt(i) & 0xff)) |
        ((key.charCodeAt(++i) & 0xff) << 8) |
        ((key.charCodeAt(++i) & 0xff) << 16) |
        ((key.charCodeAt(++i) & 0xff) << 24);
    ++i;
    
    k1 = ((((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16))) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = ((((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16))) & 0xffffffff;

    h1 ^= k1;
        h1 = (h1 << 13) | (h1 >>> 19);
    h1b = ((((h1 & 0xffff) * 5) + ((((h1 >>> 16) * 5) & 0xffff) << 16))) & 0xffffffff;
    h1 = (((h1b & 0xffff) + 0x6b64) + ((((h1b >>> 16) + 0xe654) & 0xffff) << 16));
  }
  
  k1 = 0;
  
  switch (remainder) {
    case 3: k1 ^= (key.charCodeAt(i + 2) & 0xff) << 16;
    case 2: k1 ^= (key.charCodeAt(i + 1) & 0xff) << 8;
    case 1: k1 ^= (key.charCodeAt(i) & 0xff);
    
    k1 = (((k1 & 0xffff) * c1) + ((((k1 >>> 16) * c1) & 0xffff) << 16)) & 0xffffffff;
    k1 = (k1 << 15) | (k1 >>> 17);
    k1 = (((k1 & 0xffff) * c2) + ((((k1 >>> 16) * c2) & 0xffff) << 16)) & 0xffffffff;
    h1 ^= k1;
  }
  
  h1 ^= key.length;

  h1 ^= h1 >>> 16;
  h1 = (((h1 & 0xffff) * 0x85ebca6b) + ((((h1 >>> 16) * 0x85ebca6b) & 0xffff) << 16)) & 0xffffffff;
  h1 ^= h1 >>> 13;
  h1 = ((((h1 & 0xffff) * 0xc2b2ae35) + ((((h1 >>> 16) * 0xc2b2ae35) & 0xffff) << 16))) & 0xffffffff;
  h1 ^= h1 >>> 16;

  return (h1 >>> 0).toString(36)
}

// exports = module.exports = function( str )
// {
//   var FNV1_32A_INIT = 0x811c9dc5;
//   var hval = FNV1_32A_INIT;
//   for ( var i = 0; i < str.length; ++i )
//   {
//     hval ^= str.charCodeAt(i);
//     hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
//   }
//   return hval >>> 0;
// }

/**
 * Encode to base 62 (url save)
*/
exports.encode = function c (a, b) {
  b = b || ""
  return ~~ a 
       ? c(a / 62, String.fromCharCode(((a %= 62) > 9 
          ? a > 35 ? 29 : 87 
          : 48) + a) + b) 
       : b
}

/**
 * decode base 62
*/
exports.decode = function (a, b, c, d) {
  for (b = c = 0; d = a.charCodeAt(c++); b = b * 62 + d - [ , 48, 29, 87][d >> 5]);
  return b
}


// exports.decode64

},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/id.js":[function(require,module,exports){
module.exports = function id(pre, level){
  var r = rnd()
  if(level) 
    while(level--){
      r += rnd()
    }
  return pre ? pre + r : r
}

function rnd(){
  return Number(String(Math.random()).slice(2)).toString(36)
}
},{}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
require('./object') //these things add extra methods to util for readability in a seperate module
require('./prop')


exports.isNode = (typeof window === 'undefined') ? true : false

/**
 * Add is similar to .push it returns the array instead of length
 * Can be extended to support more types e.g. add an object to another
 * @method add
 * @param  {Array}  obj Target
 * @param  {Object} add Object to add
 * @deprecated
 */
exports.add = function (obj, add) {
  if (add) obj.push.apply(obj, add);
  return obj
}

/**
 * Finds items in an array
 * @method checkArray
 * @param  {Object|Array}                 list  Defines the list where you want to search through, only uses .length field
 * @param  {Object}                       val   Defines the value you want to search for
 * @param  {Boolean|String|Number}        [index] When index is true return the index instead of true or false, when index and index !== true index is used as a field in objects in the array
 * @param  {String}                       [field] When field return field instead of index or true
 * @return {*}
 */
exports.checkArray = function (list, val, index, field) {
  var arr = index instanceof Array
  if(!list) return false
  for (var i = 0, l = list.length, t; i < l; i++) {
    t = list[i]
    if (index !== void 0) {
      if (index === true) {
        if (t === val) return i
      } else if (arr ? exports.path(t,index)===val : t[index] === val) return field ? t : i
    } else {
      if (t === val) return true
    }
  }
  return false
}

/**
 * Pass arguments (arguments) and return a new array, when index return a new array sliced from index
 * @method arg
 * @param  {Arguments} args        Arguments
 * @param  {Number}    [index = 0] When index return a new array sliced from index
 * @return {Array}
 */
exports.arg = function (args, index) {
  return Array.prototype.slice.call(args, !index ? 0 : index)
}

/**
 * Check if obj is empty exclude field names passed to list
 * @method empty
 * @param  {Object}       obj  Object
 * @param  {Object|Array} list Takes any object with .length
 * @return {Boolean}           True/false
 */
exports.empty = function (obj, list) {
  for (var i in obj) {
    if (!list || !this.checkArray(list, i)) return false
  }
  return true
}

exports.inject = require('./inject')

},{"./inject":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js","./object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js","./prop":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/prop.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/inject.js":[function(require,module,exports){

var V = require('../')
  , util = require('./')

var $TEST
if(!util.isNode) {
  $TEST = window.$TEST
}



module.exports = exports = function(extend) {

  var args = arguments

  if(args[0]&&args[0].$TEST) {
     $TEST = window.$TEST = true
  }

  if( (typeof this === 'function') || (V.Base && (this instanceof V.Base)) || typeof this === 'object') {
    if((V.Base 
        && (this===V.Base 
        || (this.prototype instanceof V.Base)
        || (this instanceof V.Base))
      )) { 
      args = util.arg(args)
      args.unshift(this)
      extend = this
    } else {
      return inject.apply(this,args)
    }
  }
  for(var i = 1; i < args.length; i++) {
   makeExtend(extend, args[i])
  }
  return extend
}

function makeExtend(extend, module) {
  if($TEST) console.log('9', module, extend)
  if(module.extend) {
    if($TEST) console.log('9.1', extend)
     module.extend(extend)
  } else if(module instanceof Array) {
    var arr = module.concat()
      , mod = arr[0]
    arr[0] = extend
     if($TEST) console.log('9.2')
    mod.extend.apply(mod,arr)
  } 
} 

function inject() {
  if($TEST) console.log('5')
  //do special stuff voor blacklist
  // Custom.prototype = new this() //lighter
  var Custom
    , extendResidue = []
    , Aspects = [this]

  for (var i = 0, Aspect, args = arguments, len = args.length; i < len; i++) {
    
    Aspect = args[i]

    if(typeof Aspect === 'function') {
      if(!Custom) {
        Custom = function() {
          for (var j = 0, len = Aspects.length; j < len;  j++) {
            Aspects[j].apply(this, arguments)
          }
        }
        inherits( Custom, this )
      }
      Aspects.push(Aspect)
      for (var method$ in Aspect.prototype) if ({}.hasOwnProperty.call(Aspect.prototype, method$)) {
        if (method$ === 'constructor') continue
        Custom.prototype[method$] = Aspect.prototype[method$]
      }
    } else {
      if($TEST) console.log('6')
      if(Custom) {
              if($TEST) console.log('7')

       makeExtend(Custom , Aspect)
      } else {
        // if($TEST) console.log('8')
        extendResidue.push(Aspect)
      }
    }
  }

  if(!Custom) Custom = this
  
  for(var j in extendResidue) {
    // console.log('8.'+j, extendResidue[j], Custom)
    makeExtend(Custom,extendResidue[j])
  }

  return Custom
}

function inherits(ctor, superCtor) {
  ctor.super_ = superCtor
  ctor.prototype = Object.create
    ( superCtor.prototype
    , { constructor: 
        { value: ctor
        , enumerable: false
        , writable: true
        , configurable: true
        }
      }
    )
}

/*
 Dit moet worden geadd voor V.Objects
/*
  object.new = function(params, constructor) {
  var vObj = function(val, hook, parent) {
      if (parent) this._parent = parent
      if (hook && this._hook) this._hook(val, hook)
      if (this._onConstruct) this._onConstruct(val, hook)
      if (val !== void 0) this.val = val
      // console.log(constructor)
      if(constructor) constructor.apply(this,arguments)  
    },
    proto = vObj.prototype = new this()
  vObj.new = object.new
  util.define(vObj, '_blacklist', proto._blacklist.concat())
  _params.call(vObj, params, ['mixed', 'merge'])
  util.define(vObj, '_class', vObj)
  return vObj
}

veel dingen werken als extension niet als losse class -- 

*/


},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/object.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , vigour = require('../') //only here to be able to use util without vigour.Object maybe refactor this away?
  , DOT = '.'

/**
 * lookup
 * polyfill if __lookupSetter__ does not exist;
 */
exports.lookup = Object.__lookupSetter__ || function (i) {
  var t = this
    , a
  while (t) {
    a = Object.getOwnPropertyDescriptor(t, i)
    if (a && a.set) return true
    t = Object.getPrototypeOf(t)
  }
  return false
}

/**
 * Used to set a val to an field on a object, whether it is a vigour.Object or a regular object
 * @method set
 * @param {Object} obj   Defines target Object
 * @param {String} field Target field
 * @param {*}      val   Value to set
 * @todo                 Move this function to a different module (e.g. 'convenience' module)
 */
exports.set = function (obj, field, val, vobj, stamp, noupdate) {
  return (vigour.Object && (obj instanceof vigour.Object))
    ? obj.set(field, val, vobj, stamp, noupdate)
    : (obj[field] = val)
}


/**
 * Returns object on the end of a defined path
 * @method path
 * @example
 * // returns obj.a.b.c
 * var obj = { a: { b: { c: 1 }}}
 * V.util.object.path(obj,['a','b','c'])
 * @param  {Object}    obj            Object to search
 * @param  {Array}     path           Array of fields in path
 * @param  {*}         [val]          When defined, val will be set on endpoint of path if not already defined
 * @param  {Boolean}   [overwrite]    If true, val WILL overwrite existing value on endpoint of path when already defined
 * @param  {Function}  [writeHandler] Callback on write
 * @param  {Boolean}   [noupdate]     When true, updates will be skipped on write
 * @param  {Number}    [i = 0]        Starting point for searching through path
 * @return {*}                        Object on the end of a defined path
 */

exports.path = function ( obj, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, i ) {
  if (!i) i = 0

  var field = path[i]
    , result
    , c
    , target = (!self && obj && obj.__t === 4) ? obj.from[field] : obj && obj[field]
    , l = i < path.length - 1

  // if(field === void 0) {
  //   throw new Error('path must not contain undefined')
  // }

  if (l && !(target instanceof Object)) target = void 0

  if ((val !== void 0) && (target === void 0 || (!l && overwrite))) {
    c = true
    exports.set(obj, field, l ? {} : val, l ? false : vobj, stamp, noupdate)
    target = obj[field]
  }

  if (l) {
    result = target
      ? this.path(target, path, val, overwrite, writeHandler, vobj, stamp, noupdate, self, uid, ++i)
      : target
  } else {
    result = (!self && target && target.__t === 4) ? target.from : target;
    if (c && writeHandler) writeHandler(result)
  }

  return result
}

/**
 * Adds path using 'dot-notation'
 * @method dotField
 * @example
 * // returns blur:{d:{a:{s:{}}}}
 * var blur = {};
 * V.util.object.dotField(blur,'d.a.s');
 * @param  {Object} obj   Object where field will be added
 * @param  {String} field String using 'dot-notation'
 * @return {Object}       Returns field
 */
exports.dotField = function (obj, field) {
  if (~field.indexOf(DOT)) {
    var path = field.split(DOT)
      , first = path.shift()
      , val = {}
    this.path(val, path, obj[field])
    delete obj[field]
    obj[first] = val
    field = first
  }
  return field
}

/**
 * Checks if two lists contain identical content
 * @method compareArrays
 * @param  {Array|Object} a         Takes any object with .length
 * @param  {Array|Object} b         Takes any object
 * @param  {Boolean}      keys      use Object.keys for b
 * @return {Boolean}      True/false
 * @todo                  Maybe change title => compareLists
 */
exports.compareArrays = function(a, b, keys) {
  var bl = keys ? Object.keys(b).length : b.length
  if (a.length !== bl) return false
  for (var i = a.length - 1; i >= 0; i--) {
    if (a[i] != b[i]) return false
  }
  return true
}

/**
 * Gets object from specified path. When path is a string checks for 'dotnotation'.
 * @method get
 * @example
 * // returns 'foo'
 * var a = {b:{c:'foo'}}
 * V.util.object.get(a,'b.c')
 * @param  {Object}       obj  Defines object or V.Value
 * @param  {String|Array} path Defines field {string} or path {array|'dot-notation'}
 * @return {*}                 obj[path]|nested object/value
 */
exports.get = function (obj, path, self) {
  //TODO: make one interface for get

  if (!obj || !path) return
  if (!self && obj.__t === 4 && !obj._filter) obj = obj.from
  if (!(path instanceof Array)) {
    if (~path.indexOf(DOT)) {
      path = path.split(DOT)
    } else {
      return (!self && obj[path] && obj[path].from) || obj[path]
    }
  }
  //self is too far away in the arguments
  return this.path(obj, path, void 0, false, false, false, false, false, self)
}

/**
 * Returns true if an object is an instance of an object and not a function , V.Object or V.Base
 * @method isObj
 * @param  {Object}  obj Object to inspect
 * @return {Boolean}     True/False
 */
exports.isObj = function (obj) {
  return (obj instanceof Object
    && typeof obj !== 'function'
    && (!vigour.Object || !(obj instanceof vigour.Object))
    && (!vigour.Base || !(obj instanceof vigour.Base)))
}

/**
 * Creates new object with the same value , takes custom objects into account (new obj.constructor())
 * @method clone
 * @param  {Object} obj Object to clone
 * @return {Object}     Returns clone
 */
exports.clone = function (obj, exclude, shallow) {
  if (this.isObj(obj)) {
    var copy = new obj.constructor()
    for (var i in obj) {
      if(!exclude || !exclude[i])
        copy[i] = !shallow
          ? this.clone(obj[i], exclude)
          : obj[i]
    }
    return copy
  }
  return obj
};

/**
 * Merges object b into object a and returns object a
 * @method merge
 * @param  {Object} a Object a
 * @param  {Object} b Object b
 * @return {Object}   Object a
 */
exports.merge = function (a, b, norefs, overwrite) {
  for (var i in b) {
    var aisobj = util.isObj(a[i])
      , bisobj = util.isObj(b[i])

    if (aisobj && bisobj) {
      util.merge(a[i], b[i], norefs, overwrite)
    } else if(!norefs || !bisobj){
      if( overwrite === void 0
       || !(i in a)
       || typeof overwrite === 'function' && overwrite(a[i], b[i])
        ){
        a[i] = b[i]
      }

    }else{
      a[i] = b[i] instanceof Array ? [] : {}
      util.merge(a[i], b[i], norefs, overwrite)
    }
  }
  return a
}

// exports.resolve = function(a, b, bFrom, j) {
//   var same = true;
//   if(b instanceof Object) {
//     for(var i in b) {
//       if(a[i]!==void 0) {
//         if(exports.resolve(a[i],b[i],bFrom ? bFrom[i] : b[i],i)) {
//           if(bFrom) {
//             delete bFrom[i]
//           }
//         } else {
//           same = false
//         }
//       } else {
//         same = false
//       }
//     }
//     if(same) {
//       if(!(bFrom&&j!==void 0)) return true
//       delete bFrom[j]
//     }
//     return same;
//   } else {
//     if(a==b) {
//       if(bFrom&&j!==void 0) {
//         delete bFrom[j]
//       }
//       return true
//     }
//   }
// }

exports.resolve = function(a, b, bFrom, j) {
  // console.log('lolresolve\n',bFrom)
  var same = true;
  if(b instanceof Object) {
    for(var i in b) {
      if(a[i]!==void 0) {
        if(exports.resolve(a[i],b[i],(bFrom!==void 0 && bFrom!==null) ? bFrom[i] : b[i],i)) {
          if(bFrom!==void 0 && bFrom!==null) {
            if(bFrom[i]===null) {
              same = false
            } else {
              delete bFrom[i]
            }
          }
        } else {
          same = false
        }
      } else {
        same = false
      }
    }
    if(same) {
      if(!(bFrom&&j!==void 0)) return true
      delete bFrom[j]
    }
    return same;
  } else {
    if(a==b) {
      if(bFrom&&j!==void 0) {
        delete bFrom[j]
      }
      return true
    }
  }
}

/**
 * Adds value to array if it is not contained in array, executes handler on encountering val in array
 * @method include
 * @param  {Object|Array}   obj       Takes any object with .length
 * @param  {*}              val       Value to add
 * @param  {Function}       [handler] Function to execute on encountering val in array
 * @param  {Boolean}        arr       Include elements of val separately rather than including val itself
 * @return {Boolean}                  True/false
 */
exports.include = function (obj, val, handler, arr) {

  if(arr && val instanceof Array) {
    var ret = false
    for(var i = 0 , len = val.length; i < len; i++) {
      ret = exports.include(obj, val[i], handler)
    }
    return ret
  }

  var i = 0
    , l = obj.length
    , field
    , check

  if (obj.__t === 1) {
    for (;i < l; i++) {
      field = check = obj[i]
      if (check.__t === 4) check = check.from
      if (check === val || check.val === val) {
        if (handler) handler(field)
        return false
      }
    }
    obj.push(val)
    return true
  } else if (obj instanceof Array) {
    for (;i < l; i++) {
      if (obj[i] === val) {
        return false
      }
    }
    obj.push(val)
    return true
  }
}

exports.changeType = function( obj ) {
  var result
  if(obj instanceof Array) {
    result = {}
    for(var i=0,len=obj.length;i<len;i++) {
      result[i]=obj[i]
    }
  } else {
    result = []
    for(var i in obj) {
      result.push(obj[i])
    }
  }
  return result
}

/**
 * Ensures a value is not or contains no V.Objects, only their "raw" versions
 * This needs to be unified with convert, or at least get a better name.
 * @method raw
 * @param  {*}   val   the value to be processed
 * @return {*}         the processed value
 */
exports.raw = function( val, rparams ) {
  if (val instanceof Object) {
    if (val instanceof vigour.Object) {
      return val.raw
    } else {
      var result
      if (val instanceof Array) {
        result = []
        for (var i = 0, l = val.length; i < l; i++) {
          result[i] = this.raw(val[i], rparams)
        }
      } else {
        result = {}
        for (var f in val) {
          result[f] = this.raw(val[f], rparams)
        }
      }
      return result
    }
  } else {
    return val
  }
}

//add level and stops for certain branches
exports.walk = function(obj, fn ) {
  for(var i in obj) {
    if(obj[i] instanceof Object) {
      if(!fn(i, obj[i], obj, true)) {
        if(exports.walk(obj[i], fn)) return true
      } else {
        return true
      }
    } else {
      if(fn(i, obj[i], obj)) {
        return true
      }
    }
  }
}

exports.checkParentFactory = function( parentField ) {
  return function(field, get, links, match) {
    if(get&&get!==true) {
      match = get
      get = false
    }
    var fields = field instanceof vigour.Object ? false : field,
      curr = this,
      found;
    while (curr) {
      found = fields === false ? curr === field : exports.get(curr, fields, !links);
      if (found) {
        if(match) {
          if(match === found || (found instanceof vigour.Object) && found.val === match) {
            return !get && fields ? curr : found;
          }
        } else {
          return !get && fields ? curr : found;
        }
      }
      curr = curr[parentField];
    }
  }
}

exports.disjoin = function disjoin(a, b, check) {
  // console.log('disjoin!')
  var fncheck = typeof check === 'function'
  
  a = getEndpoint(a)
  b = getEndpoint(b)

  a.each(function(){
    var item_a = this
    var item_a_from = item_a.from
    var remove
    b.each(function(){
      var item_b = this
      var item_b_from = item_b.from
      
      
      if(fncheck){
        remove = check(item_a_from, item_b_from)
      } else if(check === true){
        remove = item_a_from === item_b_from
      } else {
        // console.log('compare a', item_a_from.raw, 'to b', item_b_from.raw)
        // console.log('field', check)
        // console.log('a:', item_a_from[check].val)
        // console.log('b:', item_b_from[check].val)
        // console.log('same:', item_a_from[check].val === item_b_from[check].val)

        remove = item_a_from[check] && item_b_from[check] &&
          item_a_from[check].val === item_b_from[check].val
      }
      return remove
    })
    if(remove){
      // console.log('YES CHECK REMOVE')
      // TODO: 
      item_a.remove()
    }
  })

}

function getEndpoint(obj){
  while(obj && obj.__t === 4 && !obj._filter){
    obj = obj._val
  }
  return obj
}

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/process.js":[function(require,module,exports){
//processes
var vObject = require('../object')

// console.log('init process!')

module.exports = {}

},{"../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/prop.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var util = module.exports = exports = require('./')
  , V = require('../')
/**
 * Setstores are used to avoid updates troughout prototype chains for changes of fields on objects
 * It uses two fields
 *   .__ to indicate own values for pieces of an object inherited trough the prototype chain
 *   ._ is the refence back to the objects as ste in the prototype
 * @constructor setstore
 */
exports.setstore = function() {
  if ( !this.__ ) this.__ = {}
}

//TODO: reconstruct value using pieces of objects in __

exports.getStore = function( name ) {
  return this.__ 
          ? ( this.__[name] !== void 0 
            ? this.__[name] 
            : this._[name]
            ) 
          : this._ && this._[name]
}

function extensions( extend, fn, base, args, extended ) {
    
  if(window.$TEST) {
    console.log(12, extend)
  }

  if( !extend.extensions ) 
  {
    if(base) {
      extend.extensions = []
    } else {
      // console.log(extend)
      if(V.Object && extend instanceof V.Object ) {
        util.define( extend, 'extensions',[])
      } else {
        //gebruik deze extension stylo
        util.define( extend, 'extensions',{val:[], setClass:true} )
      }
    }
  }

  // console.log( 'EXTEND'.red, extend.extensions, base, fn, this, extended )

  if( util.checkArray( extend.extensions, this )===false ) 
  {

    // console.log( 'EXTEND -2'.red, this )

    if( !extended ) extend.extensions = [ this ].concat( extend.extensions ) 

      // console.log( 'EXTEND -3'.red, extend.extensions )
      //somethin weird!

    // console.log( 'EXTEND -3'.red, this, extend, extend.extensions.length )

    var myArgs = util.arg( args )
    if( base && !extended ) {
      myArgs[0] = base
    }
    if(window.$TEST) console.error('??xxx?', myArgs, fn, this)
    var ret = fn.apply( this, myArgs ) //this is the app, extend is the extension 
    if(window.$TEST, ret)
    return ret
  } else {
    if(window.$TEST) console.error('???')
  }

}

exports.extend = function() {


  var extendArray = util.arg( arguments )

  return function(extend) {

    if(window.$TEST) console.log('10 --->', extend)

    var base
      , proto

    if( typeof extend === 'function' ) 
    {
      if( V.Base && ( extend.prototype instanceof V.Base ) ) {
        base = extend.base
        proto = true
      } else {
        proto = extend.prototype
      }
    } else if( V.Base && ( extend instanceof V.Base ) ) 
    {
      proto = extend
    }

    for
    ( 
      var fn
        , ret
        , args = util.arg( arguments )
        , extendArr
        , xArg
        , i = 0
        , len = extendArray.length
        ; i < len
        ; i ++ 
    ) 
    {    
      if(extendArray[i] instanceof Array) 
      {
        extendArr = extendArray[i][0]
        xArg = util.arg(extendArray[i],1)
        xArg.unshift(extend)
      } else 
      {
        xArg = args
        extendArr = extendArray[i]
      }

      if(window.$TEST) {
        console.log('11',  extendArr.extend ?  extendArr : this, base || proto  )
      }

      ret = extensions.call 
      ( extendArr.extend ?  extendArr : this 
      , base || proto || extend
      , extendArr.extend ||  extendArr
      , base
      , xArg
      , extendArr.extend ? true : false 
      ) 
      || extend

    }
    return ret
  }

}

/**
 * Add is used as a shortcut method for Object.defineProperty and extends setstore functionality to normal prototypes
 * @method add
 * @param  {Object}          obj  When obj is a constructor it selects obj.prototype, when obj is a normal object this is used instead
 * @param  {String|Array}    name When name is a string it adds the name for the object, when name is a array do the same setting for each name
 * @param  {Object|Function} val  When val is an object , use this object for Object.defineProperty with default for enummerable:false, when object is empty adds {value:{},ennumerable:false}, when val is a function it automatically wraps a property definition object with {value: val , enummerable:false}, when val is not a function and not an object (boolean, string, number) adds special setstore value
 * @param  {Function}        [set]  Adds custom setters to a setstore object, when set is a string the add functions interprets the arguments as name : property definition pairs
 * @param  {Function}        [get]  Adds custom getters to a setstore object
 * @
 */
exports.define = function (obj, name, val, set, get, id) {
  if (typeof set === 'string') {
    var _args = util.arg(arguments)
    for (var i = 1, l = _args.length; i < l; i += 2) {
      exports.define(obj, _args[i], _args[i + 1])
    }
  } else {
    if (name instanceof Array) {
      for (var i = 0, l = name.length; i < l; i++) {
        exports.define(obj, name[i], val)
      }
    } else {
      if (typeof val === 'function' || val instanceof Array) {
        val = {
          enumerable: false,
          value: val,
          configurable: true
        }
      } else if (!val || ( !(val instanceof Object) || val.setClass  )) {

        if( val && val.setClass ) {
          val = val.val
        }

        var proto = obj.prototype || obj


        //

        //TODO: not a good solution -- has to redefine constantly ( too heavy )
        // if( proto !== obj.prototype && proto._ ) {
        //    //TODO: this can go completely wrong when you expect inheritance not to break when making a new class!
        //    if( proto.constructor.prototype._ === proto._ ) {
        //       var old = proto._
        //       proto._ = {}
        //       for(var key in old) {
        //         proto._[key] = old[key]
        //       }
        //    }
        // }
        
        //maybe make into a method
        if( id) {
          // console.log('DEFINE! DO IT'.red.inverse, name, id, proto)
          if (!proto.__) proto.__ = {}
          proto.__[name] = val
        } else {
          if (!proto._) proto._ = {}
          proto._[name] = val
        }



      

        //if proto is not a prototype (how to check?) then use __ perhaps?

        //moet hier niet altijd ze eiguh worden gemaakt?

       //default dit is eigenlijk het enige dat mis gaat

        var setter = function(val) {
              exports.setstore.call(this)
              //TODO: fix closure for val
              if (val || val === 0 || val === false) this.__[name] = val
            }
          , wset = function(val) {
              val = set.call(this, val);
              setter.call(this, val);
            }
          , getter = function() {
              return exports.getStore.call(this, name);
            }
          , wget = function() {
              var prop = getter.call(this);
              return get.call(this, prop);
            }

        val = {
          enumerable: false,
          configurable: true,
          get: get ? wget : getter,
          set: set ? wset : setter
        }

      } else if (!val.enumerable) {
        if (util.empty(val)) val.value = {}
        val.configurable = true
        val.enumerable = false
      }

      Object.defineProperty(obj.prototype || obj, name, val)

      // Object.defineProperty(obj.prototype || obj, name, val)
      //mayeb do both?
    }
  }
}
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var base = require('../base')
  , Value = require('./')
  , objectSet = require('../object').set
  , util = require('../util')
  // , raf = require('../browser/animation/raf')

exports.clonelist = [
  [ '_base', false ], '_caller', '_prop', '_name', '_skip'
]

function resolveListener( listener, val, prop, instance ) {
  if (listener) {
    if ( listener._bind === instance && listener.__t === 4 ) {
      // console.log('bind resolve'.red.bold, val )
      listener.val = val
    }
    else if (!listener._bind ) { 

      if( listener.__t === 4 && listener._val === prop )
      {
        // listener.val = 
        listener.val = val
        console.log('----------', listener.__t )
      }
      else
      {
        // console.log('ultimate ugly!')
        val.addListener(listener) //dit fixed  
      }

      //TODO: implement this later
      // if( listener instanceof Array ) {
      //   var mark = listener[1]
      //   if( mark ) {
      //     if( mark === prop._base || mark === instance || instance instanceof mark._class ) {
      //       //TODO: propably need to check for inheritance ( mark instance of prop._base)
      //       // console.log('mark resolve'.green.inverse, listener)
      //       // val.addListener([ listener[0] , instance ], true)
      //     }
      //   }
      // }

      
      // val.addListener(_listeners[i])
    }
  }
}

// function resolveListener( ) {

// }

/**
 * V.value.base.type
 * Defines the base type used in V.Value
 * @type
 */
exports.type = {
  type: Value,
  /**
   * Defines what this type will do on creation.
   * @method create
   * @param  {*} val              Value
   * @param  {[type]}  [prop]     [description] //WORDT NIET GEBRUIKT
   * @param  {Object}  [settings] Settingobject
   * @param  {Boolean} [noupdate] When true, doesn't update the V.Value
   * @return {Object}             Returns the V.Value
   */
  create: function(val, prop, settings, noupdate) {
    var v = new Value()
    v._base = this
    v._caller = v._base
    v._prop = settings
    // console.log('set')
    objectSet.call(v, val, false, false, true)
    // console.log('done setting')
    if (this._class) this._class.prototype._[settings.name] = v
    if (settings.set) {
      if (!settings._vset) {
        settings._vset = function(stamp, from, remove, cval) {
          // var t = this
          // t.__s = true
          // if(!t._s) {
            // raf(function() {
              // console.log('IM HERE?')
              // t.__s = null
              settings.set.call(
                   this._caller
                || this._base
                || this, this, stamp, from, remove, cval
              )
            // })
          // }

        }
      }
      if (!noupdate) {
        // console.log('UPDATE creation')
        v._update(val)
      }
    }
    return v
  },
  /**
   * Defines what this type will do on set.
   * @method set
   * @param  {*}      val      Value
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingsobject
   * @return {*}               Returns value
   */
  set: function(val, prop, settings) {

    if(!prop) return
    // console.log('SET FUN!')
    prop._caller = this
    //deze bind zou alleen moeten werken voor als je iets op het exact goede momment changed!

    prop._bind = false
    if (this !== prop._base) {
      var _listeners = prop._listeners
        , _b = prop._base
        , i
        , _this = this

      util.setstore.call(this)
      exports.clonelist[0][1] = this //beetje dirty...

      //clone is always used to get rid of flags
      if (val !== void 0 && !val.clear) {
        val = prop.clone(val, false, exports.clonelist)
      } else {
        // if(prop._flag) {
        //   value.flags[prop._flag[0]].remove && value.flags[prop._flag[0]].remove.call(this,prop._flag)
        // }
        //listener on nested child on parent

         //--->  new width for this one
         // --->  hey a listener on me /w a bind on my instance!
         //  ----> add listener to me (listener on class prop)
         //   -----> hey lets reset this little guys width
         //    ------>  lets add Listener
         //     -------->  double listeners on this one
        var v = new Value()
        v._base = this
        v._prop = settings
        v._caller = this

        // clean FLAGS from node!
        if(val) delete val.clear
        v.val = val
        val = v
      }

      this.__[settings.name] = val

      if( this._class ) this._class.prototype._[settings.name] = val

      // for each field (only 1 level deep for now)
      prop.each
      ( 
        function(key) {
          // console.log('resolve', prop._prop.name, key)
           if( this._listeners ) {
            for (i =  this._listeners.length - 1; i >= 0; i--) {
              resolveListener( this._listeners[i], val[key], prop, _this )
            }
            //TODO: check if this is nessecary
            if(val[key].val !== this.val)
            {
              // console.log(val[key]) 
              // val[key]._update()
            }
          }
        }
      )

      if( _listeners ) {

        for (i = _listeners.length - 1; i >= 0; i--) {
          resolveListener( _listeners[i], val, prop, _this )
        }

      }

      val = null
      // console.log('UPDACE ----'.yellow)
      this[settings.name]._update(val)
    }

    return val
  },
  /**
   Defines what this type will do on get.
   * @method get
   * @param  {Object} prop     Properties
   * @param  {Object} settings Settingobject
   * @return {Object}          [description]
  */
  get: function(prop, settings) {
    // console.log('GETTING!', prop, settings.name)
    if (prop) prop._caller = this
    if (settings.get) return settings.get.call(this, prop)
    return prop
  }
}
},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/data.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./'),
  util = require('../../util'),
  object = require('../../object'),
  ownModel = function(base) {
    if (!base.__ || !base.__.model) { //maybe a utility? use it at different spots like settings
      base.model = {};
      if (!base._.model) {
        base._dListen();
      }
    }
    return base.model;
  };
/**
 * data
 * data adds a reference to the data property of the current base class;
 * if there is not _base.model use data.base.extend(baseClass);
 * @flag
 */
flags.data = {
  useVal:true, //(reset???)
  set: function(val, stamp, reset) {

    var current = this.checkParent('_prop.name'),
      name = current._prop.name,
      base = current._base,
      model = ownModel(base);
    if (model.flags && model.flags[name]) {
      if (!(model.flags[name] instanceof Array)) {
        model.flags[name] = [model.flags[name]];
      }
      if (!util.checkArray(model.flags[name], this)) {
        model.flags[name].push(this);
      }
    } else {
      if (!base.model.flags) {
        base.model.flags = {};
      }
      base.model.flags[name] = this;
    }

    // console.log('LEZZ SET IT!', val, stamp, reset, current)

    var getData = function() {
      var data = this._d;
      if (data === void 0) {
        var parent = this;
        while (data === void 0 && parent) {

          // if(parent.model && (!parent.model.inherit || parent.model.inherit.val!==false)) {
          //   return data
          // }

          // console.error('set it /w parent!', this.name, parent.name)

          if (parent._d) {

            if(parent.model && parent.model.field && parent.model.field.val !== parent.modelParsed) {
              parent._d = parent._d[parent.model.field.val] || parent._d.from[parent.model.field.val]
              console.error('het hey its parent model', parent.model.field.val)
              // parent.model = {}
              parent.modelParsed = parent.model.field.val
            }

            // if(par)

            if(this.model&&this.model.field && this.modelParsed !== this.model.field.val) {
              console.error('hey hey hey! i got a model myself!', this.model.field.val, parent._d.keys, parent._d)

              data = this._dSet(parent._d[this.model.field.val] || parent._d.from[this.model.field.val], true);
              // this.model = {}
              this.modelParsed = this.model.field.val
              // this.model.parsed = this.model.field.val
            } else {
              data = this._dSet(parent._d, true);
            }


            // if(parent.model && parent.model.field) {
            //   console.error('it is a field!', parent.model.field.val)
            // }
          } else {
            parent = parent.node.parentNode;
            if (parent) {
              parent = parent.base;
            }
          }
        }
      }
      return data;
    };
    if (val instanceof Object) {
      var v = val.val || val;
      this._val = function() {
        var data = getData.call(this);
        // console.log('---->',v,data)
        return data && v.call(this, data);
      };
      val = val.listen || true;
    } else {
      this._val = function() {
        var data = getData.call(this),
          ret;
        data = val === true ? data : util.get(data, val);
        if (data !== void 0) {
          ret = data.__t && !data._filter && data.val;
          if (!ret && ret !== 0 && ret !== '') { //weird
            ret = data;
          }
        } else {
          ret = '';
        }
        return ret;
      };
    }
    if(!this._flag) this._flag = {}

    // this.__lval = false
    // current._caller.setSetting({
    //   name: name,
    //   parent: function(parent) {
    //     console.log('!@#!@#!@#')
    //     this.updateData()
    //   }
    // });

    this._flag.data = ['data', this._val, val, name];
  },
  remove: function() {
    var current = this.checkParent('_prop.name'),
      model = ownModel(current._base),
      t = this;
    if (model && model.flags) {
      for (var i in model.flags) {
        if (i === current._prop.name) {
          var item = model.flags[i];
          if (item instanceof object || item.length === 1) {
            model.flags[i] = null;
            delete model.flags[i];
          } else {
            model.flags[i].splice(util.checkArray(item, t), 1);
          }
        }
      }
    }
    this._update() //pas hiermee op!
    // var t = this
    setTimeout(function() {
      //deze pas uitvoeren nadat alle klaar is! dit is dirty!
      t._update()
    },0)
  }
};
},{"../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var value = require('../'),
    base = require('../base'),
    flags = require('../../object/flags');
    
    base.clonelist.push(['_flag', true]); //true clone!
    flags.extend(value);
    module.exports = value.flags;
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../object/flags":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/flags.js","../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/base.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/parent.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./')
  , value = require('../')
  , util = require('../../util')
  , vObject = require('../../object')


//todo add element signature in from so it can travel trough updates --- if parent (need less funky things)

/**
 * parent
 * parent makes it possible to add listeners to parent properties
 * using multiple parent properties in one property is still very wrong
 * @flag
 */
value.prototype._blacklist.push('_parentStore')

function baseReset(base,name) {
  if(base && base.node) {
    if(name==='x' || name ==='y') base.cleanCoordinates(name)
    if(base[name]) {
      base[name]._prop._vset.call(base[name])
    }
  }
}


// window.pcheck = 0

// window.pprops = {}

//base,vset,t,type,mparent,fbase, v, val, stamp, from, remove, added, oldval, true, firstSkip
function checker(vset, t, type, mparent, fbase, v, val, stamp, from, remove, added, oldval, first, firstSkip, p) {
  if(p&&(this.parent instanceof mparent) ||  (!p && this.parent===mparent) || firstSkip ) {

    // pcheck++

    var s
      , base = this._from.base.node && this._from.base
      , name = t._prop.name

    // if(!window.pprops[name]) window.pprops[name] = 0

    // window.pprops[name]++


    t._caller = this

    //gaurd voor changes -- if no change -- do nothing
    vset.call(t, stamp, from, remove, val)

    if(base&&base[name]&&base[name+'__p']!==stamp) {
      t._caller = base
      t._caller[name+'__p'] = stamp
      vset.call(t, stamp, from, remove, val)
      t._caller = this
      s=true
    }

    // console.log(this.node)
    for(var i in t._listeners) {
      if(t._listeners[i].pop && t._listeners[i][2]==='parent') {
        if(t._listeners[i][1]._lstamp===stamp) {
          t._listeners[i][1]._lstamp=null
        }
        t._listeners[i][0].call(t._listeners[i][1], type, this, base, v, val, stamp, from, remove, added, oldval, true)
      }
    }

    //reset this._from.base[t._prop.name]===t
    if(s) baseReset(base, name)

  }
}

function updateHandler(type,mparent,fbase,v, val, stamp, from, remove, added, oldval,firstSkip,inherit) {

  var t = this

  this._parentStore[0] = mparent

  this._update(val, from ? this.stamp() : stamp, from, remove, added, oldval, false, false, function() {
    var vset =  this.checkParent('_prop._vset', true)
      , base = this.checkParent('_base', true)
      , complexParent = true
      , p

    if( (mparent===base.parent && from)  ) {
      p = true
    }

    checker.call(base,vset,t,type,mparent,fbase, v, val, stamp, false, remove, added, oldval, true, firstSkip)

    base.eachInstance(function() {
     checker.call(this, vset, t,type, mparent,fbase, v, val, stamp, false, remove, added, oldval, false, p)
    }, t._prop.name)

    vObject.prototype._update.call(this, val, stamp, false, remove, added, oldval, function(l) {
      return l[2]==='parent'
    })

    if(!inherit && v._caller && mparent!==v._caller) {
      updateHandler.call(this,type,v._caller,fbase, v, val, stamp, false, remove, added, oldval,firstSkip,true)
    }

  })
}

function _parent(parent, noupdate, prop, flag, reset) {

  // console.log('_parent call'.cyan.inverse, flag)

  var _lparent = prop._parentStore[0]
    , pname = flag[2]   //flags.parent.val
    , pprop = parent[pname]
    , fbase = this._from.base
    , newP
    , baseSet

  if (!pprop) return

  // console.log('ADD LISTENER TO PARENT')

  pprop.addListener(
    [ updateHandler
    , prop
    , 'parent'
    , parent
    , this //fbase
  ], function(l,listeners,index) {

    if(l[3]!==parent &&  _lparent!==parent && l[4]!==fbase) {
      prop._parentStore[0] = parent
      l[4] = fbase
      newP = true //hoe deze smart afvangen?
    }
  }, false, true)

  // if(reset) {
  //   for(var i in pprop._listeners) {
  //     if(pprop._listeners[i].pop && pprop._listeners[i][1]===fbase[prop._prop.name]) {
  //       if(pprop!==parent._from.base[pname]) {
  //         pprop._listeners.splice(i,1)
  //         break;
  //       }
  //     }
  //   }
  // }

  if (newP || (!_lparent || (_lparent !== parent && _lparent[pname] !== pprop) ) ) {
    prop._parentStore[0] = parent
    if (!noupdate) {
      prop._caller = (baseSet = fbase.node && fbase || prop._base)
      prop._prop._vset.call(prop, prop)
      prop._caller = this
      updateHandler.call(prop,'parent',parent,fbase,pprop,false,vObject.stamp(),false,false,false,false,true,true)
      baseReset(baseSet,prop._prop.name)
    }
  }
}

function _init(val, flag, reset) {
  var parent = this.parent
  // console.log('try parent', flag, parent)
  if (parent) _parent.call(this, parent, true, val, flag, reset)
}

function _val(val) {
  var parent = this.parent || val.checkParent('_parentStore.0', true)
  //flags.parent.val
  if(parent && !val._flag.parent) {
    console.error('NO PARENT FLAG!')
    return
  }
  // console.log('---->',val._flag.parent[2])
  if (parent ) return parent[val._flag.parent[2]].val
}

flags.parent =
{ reset: true
, useVal: true
, set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name'),
      name = current._prop.name
    //flags.parent.val
    if(!this._flag) this._flag = {}

      //overwriting previous parent
      //
    // console.log('SET PARENT---->')
    this._flag.parent = ['parent', _val, val, this]
    if (!current._parentStore) current._parentStore = [false]

    // console.log('GOTS PARENTSTORE!', reset, current._parentStore, this._flag.parent)

    current._parentStore.push(this)
    //setParent settings
    // console.log('---> CREATE SETTING'.yellow.inverse)
    current._caller.setSetting({
      name: name,
      parent: function(parent) {

        // console.log('---> SET SETTING'.yellow.inverse)

        for (var store = this[name]._parentStore, i = store ? store.length - 1 : 0; i > 0; i--) {
          if(store[i]._flag.parent) {
            _parent.call(this, parent, false, this[name], store[i]._flag.parent)
          } else {
            console.error('2 NO PARENT FLAG!')
          }
        }
      }
    });
    //try to minimize val calulations
    this._val = _val
    this._skip = true
    //onInit (if it already has some parents)
    _init.call(current._base, current, this._flag.parent, reset)
    //reAttach listeners for instances
    current._base.eachInstance(_init, name, current, this._flag.parent)
  }
, remove: function(flag) {

    // console.log('REMOVE PARENT'.cyan.inverse)

    var current = this.checkParent('_prop.name'),
      base = current._base,
      listens = current._listens,
      name = current._prop.name,
      val = flag[2],  //flags.parent.val
      parentStore = current._parentStore,
      removelistener = function() {
        var parent = this.parent
        if (parent && parent[val]) {
          if (listens.length > 0) {
            if (util.checkArray(listens, parent[val])) {
              // console.log('REMOVE LISTENER!', parent[val], listens.length, parent[val]._listeners.length, parent[val]._listeners , current)


              //more specific only remove if val matches --- store function
              parent[val].removeListener( false, current )

              //mark = false


              // console.log('REMOVE LISTENER! -- result -- no update?', listens.length)

            }
          } else {
            return true
          }
        }
      }

    this._val = 0

    if (listens && !removelistener.call(base)) {
      base.eachInstance(removelistener, name)
    }

    // console.log('PARENTSTORE', parentStore, current)
    parentStore.splice(util.checkArray(parentStore, this, true), 1)

    if (parentStore.length === 1) {
      // console.log('---> REMOVE SETTING'.yellow.inverse, parentStore)
      base.removeSetting(name, 'parent') //ff corigeren voor andere parent settings!!! op andere fields
      //dit maakt het helemaal kapot!
      // console.warn('REMOVE PARENTSTORE!')
      current._parentStore = null
    }
  }
}
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/process.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

//TODO: flags on the basis of path ( similair to cases )

//TODO: make Value flags more injectable
var flags = module.exports = require( './' )
  , processes = require( '../../util/process' )
  , Value = require( '../' )
  , util = require( '../../util' )
  , ajax = require('../../browser/network/ajax')
  , vObject = require('../../object')

//TODO: maybe add promise

exports.create = function( flag, settings, Constructor, extendflags ) {

  if( !extendflags ) extendflags = flags
  if( !Constructor ) Constructor = Value

  var tempStore = '__temp'+flag+'__'
    , inProgress =  '__inprogress'+flag+'__'
    , origUpdate = Constructor.prototype._update
    , once = settings && settings.once
    , deferMethod = settings && settings.deferMethod
    , origSet
    , origRemove
    , deferflag = 
      { reset: true
      , set: function( val, stamp, reset ) {
          if( !this._flag ) this._flag = {}
          this._flag[flag] = [ flag, false, val, this ]
        }
      , remove: function() {
          var defer = this._flag && this._flag[flag]
            , vobj

          if( defer && defer[1] )
          {

            // if( deferMethod ) 
            // {
              // vobj = deferMethod.call( _this, arr, defer[2], _this[tempStore], origUpdate, Constructor )
            // }
            // if() {
              vobj = typeof defer[2] === 'string'
                   ? processes[defer[2]]
                   : typeof defer[2] !== 'function' && defer[2]
            // }

            if( vobj && vobj.removeListener )
            {
              vobj.removeListener( defer[1] )
            }
            else if( vobj && vobj !== true )
            {
              for( var vobj$ in vobj )
              {
                vobj.removeListener( vobj[vobj$] )
              }
            }
          }
        }
      }


  Constructor.prototype._blacklist.push
  ( tempStore
  , inProgress
  , '_history'
  // , '_initialised'
  )

  if( deferMethod ) {
    settings.deferMethod = null
  }

   if( once ) {
    settings.once = null
    Constructor.prototype._blacklist.push( once )
  }

  if( settings ) {
    for( var key in settings )
    {
      if( key === 'set' )
      {
        origSet = deferflag.set
        deferflag.set = function( val, stamp, reset ) {
          settings.set.call( this, origSet, arguments )
        }
      }
      else if( key === 'remove' )
      {
        origRemove = deferflag.remove
        deferflag.remove = function( val, stamp, reset ) {
          settings.remove.call( this, origRemove, arguments )
        }
      }
      else 
      {
        deferflag[key] = settings[key]
      }
    }
  }

  extendflags[flag] = deferflag

  //extend update
  util.define
  ( Constructor
  , '_update'
  , function( val, stamp ) {



      if( ( this._flag && this._flag[flag] ) && ( !once || !this[once] ) ) //&& !this._initialised 
      {

        // this.clearCache()

        // console.error('_updace', val, this._path)

        // console.error( '$EEEEE1', this._path)

        // console.log(this._path, val, stamp)
        var _this = this
          , defer = _this._flag && _this._flag[flag]
          , tempdefer = _this[tempStore]
          , add
          , arr
          , vobj
          , recur
          , fn

        if( !tempdefer )
        {
          _this[tempStore] = tempdefer = []
          add = true
        } else {
          //TODO: fix caching stamp, most efficient but may break things /w instances etc
          // console.log('stamp cahcing', this._path)

          if( stamp && tempdefer[0][1] !== stamp )
          {

            // tempdefer.push(util.arg( arguments ))
            // console.log('stamp cahcing pass' , this._path, tempdefer)
            // tempdefer[0][0] = val
            // tempdefer[0][1] = stamp
            var arg = util.arg(arguments)
            for(var i in arg) {
              tempdefer[0][i] = arg[i]
            }
          }


        // console.error('_updace 3', val, this._path)

         // if(this._name === '$test') console.log('stop its')
          return
        }

        arr = util.arg( arguments )

        // console.error('_updace 2', val, this._path)

        tempdefer.push( arr )

        if( add )
        {
          // if(this._name === '$test') console.error('do it 1')

          if( deferMethod ) 
          {
            vobj = deferMethod.call( _this, arr, defer[2], tempStore, origUpdate, Constructor, inProgress )
          }
          else 
          {
            vobj = typeof defer[2] === 'string'
               ? processes[defer[2]]
               : defer[2]
          }

          if( vobj )
          {

              // console.log('heyho2!!!!!', val,this._path)

          
            //TODO: replace with a standard function, lose the extra closure!
            recur = function() {

              if( once ) 
              {
                _this[once] = true
              }
              //dit ook kunnen meegeven
                // console.error('LETS TRY')

              //TODO: using a closure here may not be nessecary anymore, use another identifier
              for( var i = 0; i < tempdefer.length; i++ ) { //length needs to update
                // _this._caller = tempdefer[i].splice( tempdefer[i].length-1, 1 )
                // tempdefer[i][1] = this.stamp()
                // try{
                  // console.error('LETS TRY go go go',val, i, tempdefer[i])
                  // var stampx = tempdefer[i][1]
                    // , valx = tempdefer[i][0]

                  origUpdate.apply( _this, tempdefer[i] )  

                  // if( (tempdefer[i][1] && tempdefer[i][1]!==stampx) || (tempdefer[i][0] && tempdefer[i][0]!==valx) ) {
                  //   console.warn('defer new update within the loop now it fires! -- be carefull may break')
                  //   var ref = tempdefer[i]
                  //   // setTimeout( function() { 
                  //     _this.clearCache()
                  //     _this[tempStore] = null
                  //     _this[inProgress] = null
                  //     _this.clearReferencesCache()
                  //     // console.log('?????',ref)
                  //     _this._update.apply( _this, ref ) 
                  //   // } ,100) 
                  //   // alert('new update set within loop!')

                  // }
                // }catch(e){console.error('WA', e)}
                
              }

              //listener gets removed but order is different
              if( this.removeListener ) this.removeListener( recur )

              _this[tempStore] = null
            }

            if( typeof vobj === 'function' )
            {

              if( !_this[inProgress] )
              {
               
                fn = function( val ) {
                  
                  if( val!==true && _this[inProgress] ) {
                    _this[inProgress]()
                  }
                  _this[inProgress] = null
                  _this[tempStore] = null
                }

                _this[inProgress] = recur

                if( vobj.call( this, fn , arr, tempdefer ) === true )
                {
                  _this[tempStore] = null
                  _this[inProgress] = null
                }
                // else
                // {
                //   console.log( '?' )
                //   //TODO: check if this is the best way, (updating recur, or mayeb just use the same recur)
                //   _this._deferinprogress = recur
                // }

              }

            }
            else if( vobj === true )
            {

              if( this.val || this.val === 0 )
              {
                origUpdate.apply( _this, arr )
                _this[tempStore] = null
              }  
              else
              {
                console.error( 'no value! from defer type:', flag)
              }
            }
            else if( !vobj.addListener )
            {
              for( var vobj$ in vobj )
              {
                vobj[vobj$].addListener( recur )
              }
            }
            else
            {

              vobj.addListener( recur )
            }

            defer[1] = recur
          }
        }

      }
      else
      {
        // console.log( flag, once, 'should do orig update bitches!', arguments, this )
        origUpdate.apply( this, arguments )
      }

    }
  )

} 

//TODO: injectable
//TODO:_tempdefer hoeft niet altijd maak create -- update type flag
//always update method
// exports.create( 'force', 
// { deferMethod: function( args, vobj, tempStore, update ) {
//     var _this = this
//     //dit zit natuurlijk dieper!
//     _this._skip = true //maybe check if it rly gets reset?
//     _this._ignoreValue = true
//     _this.clearCache()
//     _this[ tempStore ] = null
//     update.apply( _this, args )
//   }  
// })
//deze moet nog wat dieper

// exports.create( 'history', 
// { deferMethod: function( args, vobj, tempStore, update, Constructor ) {
//     //vobj option voor flag
//     if(!this._history) this._history = []

//     this._history.unshift( args )
//     this[tempStore] = null //total control! (old including arguments)

//     //allright that works this.clearCache() //cache dingen adden
//     update.apply( this, args )
//   }
// })

// exports.create( '$type', 
// { deferMethod: function( args, vobj, tempStore, update ) {
//     var _this = this
//       , haveToUpdate

//     //arrays etc
//     _this.clearCache()

//     if( vobj === true )
//     {
//       if( _this.val ) haveToUpdate = true
//     }
//     else if( vobj === 'string' )
//     {
//       if( typeof _this.val === 'string' ) haveToUpdate = true
//     }
//     else if( vobj === 'number' )
//     {
//       if( typeof _this.val === 'number' ) haveToUpdate = true
//     }
//     else if( typeof vobj === 'function' )
//     {
//       if( vobj.apply( _this, args ) ) haveToUpdate = true
//     }

//     if( haveToUpdate ) {
//       _this[tempStore] = null
//       update.apply( _this, args )
//     }
//   }  
// })

exports.create( '$bubble', { 
  deferMethod: function( args, vobj, tempStore, update ) {
    var _this = this
    var doUpdate
    var references
    _this[tempStore] = null

    if( vobj ) {
      if(references = vobj.references) {
        if(references instanceof Object) {
          if(references.$lte 
            && _this.referenceLevel(_this._updateOrigin) <= references.$lte 
          ) {
            doUpdate = true
          }
        } else if(references > -1) {
          //also maximum for example
          // console.error(_this._path, _this.referenceLevel(_this._updateOrigin), 'uOriginPath', _this._updateOrigin._path, '._val',_this._val._path,  'cloud', !!_this._val.cloud)
          if( _this.referenceLevel(_this._updateOrigin) === references ) {
            doUpdate = true
          } 
        } 
        // else if(references === true) {
        //   //only if refference
        //   if(_this.referenceLevel(_this._updateOrigin)!==false) {
        //     doUpdate = true
        //   } 
        
        // }

      } else if( vobj && vobj.self === true ){

          if( args[2] === void 0 || this._val === args[0] || !args[0] && this._updateOrigin===this) {
            doUpdate = true
          }
        }
        
        if(doUpdate) {  
          update.apply(_this, args)
        } else {
          _this.clearReferencesCache()
        }

      } else {
        update.apply(_this, args)
      }

   
  }  
})

exports.create( 'defer' )

//TODO: vObj flag ( accessable trough object[flag] )

Value.operators.responseData = function( val, operator ) {
  return operator===false ? val : operator
}

//vobj parser!

exports.create( 'ajax', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
//     console.log('set ajax defer')
    if( ! this.loading ) {
      //name, val, vobj, stamp, noupdate, from
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor ) {
    var _this = this  

    return vobj && function( update, args ) {

      var origu = update

      update = function( type, kill ) {
        _this.clearCache()
        _this._skip = true
        _this._ignoreValue = true
        if( type ) {
          args[0] = type
          if(! ( _this._val instanceof vObject ) ) {
            _this.val = type
          } 
        }
        if( _this.loading ) _this.loading.val = false
        origu( kill )
        _this._ignoreValue = null
      }

      if( typeof vobj === 'object' )
      {
        var params = vobj
        vobj = {}
        for( var key in params ) {
          if( key === 'defer' ) {
            vobj[key] = params[key]
          } else {
            if(!vobj[key]) {
              if( key !== 'complete' && key !== 'error' && typeof params[key] === 'function' ) {
                vobj[ key ] = params[ key ].call( _this, vobj, args[0], args )
                if( !vobj[key] ) {
                  return true
                }
              } else {
                vobj[key] = params[key]
              }

              if( vobj[key] instanceof vObject ) {
                vobj[key] = vobj[key].val //custom get or raw
              } 
            }
          }
        }
      }

      if( typeof vobj === 'function' ) 
      {
        vobj = vobj.call( _this, vobj, args[0], args )
        if(!vobj) return true
      }

      if( typeof vobj === 'string' ) 
      {
        vobj = { url: vobj }
      }

      if( vobj.url instanceof vObject ) {
        vobj.url = vobj.url.val
      }

      if( !vobj || !( vobj.url || vobj.api ) ) 
      {
        return true
      }

      var complete = vobj.complete
        , error = vobj.error

      vobj.complete = function( data ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, null, data, vobj )
        }
        else
        {
          if(!_this.responseData) {
            _this.set( 'responseData', data )
          }
          else {
            _this.responseData.merge( data )
          }
          ;complete && complete( data )
          update( 'success' )
        }
      }

      vobj.error = function( err ) {
        if( vobj.defer ) 
        {
          vobj.defer.call( _this, update, args, err, vobj )
        }
        else
        {
          if( _this.responseData )
          { 
            _this.responseData.each( function( key ) {
              if( !Constructor.operators[key] && !Constructor.flags[key] )
              {
                this.remove()
              }
            })
          }
          _this.set( 'responseData' , void 0 )
          if( error ) error( data )
          update( 'error' )
        }
      }

      if( _this.loading ) {
        //TODO:correct responses managemet -- pretty easy todo
        _this.loading.val = true
      }

      ajax( vobj ) //TODO: let it return a promise
    }  
  }
})

//temp args 

//TODO: dit later vervangen met local flags (api)
//TODO: unify ajax hiermee voor oncsitent error handeling -- of extension op ajax
exports.create( 'apiDefer', 
{ remove: function( remove, args ) {
    //TODO: ajax call stop
    remove.apply( this, args )
  }
, set:function( set, args) {
    if(! this.loading ) {
      this.set( 'loading', false, false, false, true )
    }
    set.apply( this, args )
  }
, deferMethod: function( args, vobj, tempStore, update, Constructor, inProgress ) {
    var _this = this  
   
    return vobj && function( update, args ) {

      if( !args[0] || args[0].apiDefer ) return true

      var wrappedUpdate = function( val, kill ) {

        // console.error('DO DO DO', val, _this, tempStore, _this[tempStore])

        // _this[tempStore] = null
           
        // _this[inProgress] = null


        _this.loading.val = false
        if( val && val!==true ) 
        {
          _this.val = args[0] = val
          try {
            update( val ) //val -- val
          } catch( err ) {
            // console.error( 'DEEPER ERROR IN API DEFER , SOMETHING WRONG /w this API', val )
            //best example is facebook login true and gone but only weh the .loading is there
            //most be a very deep issues i geuss... hard to recreate 
            _this.type = err

            //this is wrong misses _this call and other args
            update( 'error' )
          }

          _this.clearCache()
          _this._val = false
        }
        else 
        {
          //this is wrong misses _this call and other args
          update( val )
        }
      }
      
      _this.loading.val = true
      var api = _this.checkParent( 'api', true )

      if( api && api.val !== true ) 
      {

        api.once(function( val ) {
          if( val === 'error' ) 
          {
            _this.clearCache() //hier ff een functie voor maken!
            _this.val = args[0] = 'error'
            _this.type = this.type || 'api'
            _this.loading.val = false
            wrappedUpdate()
          }
          else if( val === true )
          {
            vobj.call( _this, wrappedUpdate, args )
          }
        })
        api.val = true
      } 
      else
      {
        vobj.call( _this, wrappedUpdate, args )
      }
    }
  }
})

exports.create( 'init', 
{ set: function( set, args ) {
    if( !this.initialised )
    {
      set.apply( this, args ) //niet nodig!
    }
  }
, remove: function( remove, args ) {
    remove.apply( this, args )
    this.initialised = null
  }
, once: 'initialised'
})

module.exports = exports

},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js","../../browser/network/ajax":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/ajax.js","../../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","../../util/process":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/process.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/self.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var flags = module.exports = require('./');

/**
 * self
 * @flag
 */
flags.self = {
  reset: true,
  useVal:true,
  set: function(val, stamp, reset) {
    var current = this.checkParent('_prop.name')
    if (current._base && current._base[val]) {
      current._base[val].addListener(this)
      this._val = function() {
        return this[val] && this[val].val
      }
      if(!this._flag)  this._flag = {}
      this._flag.self = ['self', this._val, val, this]
    }
  }
};

},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/util.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

var flags = module.exports = require('./')
/**
 * listen
 * adds listeners to a V.Value
 * @property
 **/
flags.listen = {
  reset:true,
  set: function(val, stamp, reset) {
    if(!val)
    {
      console.error('no val in flags listen!')
//       debugger
      return
    }
    if(!this._flag) this._flag = {}
    //eventueel mergen!
      
    // console.log('listen'.cyan.inverse, reset, val)
    //if reset make sure its resetted correctly!
    this._flag.listen = ['listen', false, val, this ] 
    if (val instanceof Array) {
      for (var i = val.length - 1; i >= 0; val[i--].addListener(this));
    } else {
      //ok
      var _this = this
      // val.addListener(function() {
      //   console.log('TROUGH LISTEN!!!!'.magenta.inverse, val._path)
      //   // _this._update.apply(_this, arguments)
      // }) 
      val.addListener(this) //dit moet beter (remove listener if possible)
    }
  },
  remove:function() {
    if(this._flag&&this._flag.listen) {
      var val = this._flag.listen[2]
      if (val instanceof Array) {
        for (var i = val.length - 1; i >= 0; val[i--].removeListener(this));
      } else {
        val.removeListener(this) //dit moet beter (remove listener if possible)
      }
    }
  }
}

},{"./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/flags/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */
var object = require( '../object' )
  , util = require( '../util' )
  , vigour = require( '../' )

/**
 * vigour.Value
 * v values are optimized for use in combination /w instances of vigourBase, have operators and support method values
 * @Class
 */
module.exports = exports = vigour.Value = object.new(
{ mixed: true
, merge: true
})

//parent problems

var _getOperator = function( val, force, i, t, bind, operators ) {
  var f = t[i]._get(bind, force, val);
  if (f !== void 0 && f !== null) {
    val = operators[i](val || ((typeof f === 'string') ? '' : 0), f);
  }
  return val;
};

exports.prototype._blacklist.push('_lstamp', '_clearCache', '_lval', '__lval','___lval', '_base', '_caller', '_bind', '_prop', '_instances', '_skip', '_overwrite')
//_caller stamp for get for lvals (last values)
util.define(exports,
  'clearCache', function() {
    this.___lval = null
    this.__lval = null
    this._lval = null 
  },
  'clearReferencesCache', function() {
    from = this._val
    while(from) {
      if(from.clearCache) from.clearCache()
      if(from && from._val) {
        from = from._val
      } else {
        from = null
      }
    }
  },
  'ignoreCache', { get:function() {
      var t = this
      while(t) {
        // console.log('hoe zit het??',t )
        if( t._prop && t._prop.cache === false ) return true
        t = t._parent
      } 
    } 
  },
  /**
   * Used to get .val which calculates a constructed value
   * _bind is very important binds listeners to specific instances
   * @method _get
   * @param  {[type]} bind  [description]
   * @param  {[type]} force [description]
   * @return {[type]}       [description]
   */
   '_get', function(bind, force, currentVal) {

    if(this._clearCache) {
      this.clearCache()
    }

    // console.log('_get',this._name, this._val,this);
    if (this._overwrite) {
      return this._overwrite;
    }
    if (!this._lval && this._lval !== 0 || force) {
      var val = this._val,
        nolval,
        operators = this.operators;

      if (val instanceof object) {
        val = val._get(this._bind || bind, force, currentVal);
      } else if (typeof val === 'function') {

        // console.log('RIGHT HERE', currentVal)
        var a = this;
        if (!bind) {
          while (a._parent && !a._caller) {
            a = a._parent;
          }
        }
        val = val.call(bind || a._caller || a._base || this, this, currentVal); //if currentval else something else;
        nolval = true;
        //for functions you need to clear _lval since you never know if there is something in the function updated
      }
      if (operators) {
        if (this.__t === 1 && operators[this._name]) { 
          //operator is an array
          val = 0; //string
          for (var j = 0, l = this.length; j < l; j++) {
            if (this[j]) {
              vj = this[j]._get(bind, false, (currentVal || 0) + val);
              if (!vj) {
                vj = 0; //string
              }
              if (typeof vj === 'string' && val === 0) {
                val = '';
              }
              val += vj; //only add no operator stuff
              if (!this[j]._lval) {
                nolval = true;
              }
            }
          }
        } else {
          //also add before
          var ordered;
          for (var i in this) {
            if (operators[i]) {
              if (!operators[i].order) {
                if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) {
                  force = true;
                }
                val = _getOperator(val, force, i, this, bind, operators);
                if (!nolval && !this[i]._lval) {
                  nolval = true;
                }
              } else {
                if (ordered) {
                  if (!ordered.pop) {
                    ordered = [ordered];
                  }
                  var o = operators[i].order,
                    ol = ordered.length - 1;
                  for (var h = 0; h !== true && h <= ol; h++) {
                    if (h === ol) {
                      if (o < operators[ordered[h]].order) {
                        var a = ordered[h];
                        ordered[ol] = i;
                        ordered.push(a);
                      } else {
                        ordered.push(i);
                      }
                      h = true;
                    } else if (h === ol && o > operators[ordered[h]].order) {
                      ordered.push(i);
                      h = true;
                    }
                  }
                } else {
                  ordered = i;
                }
              }
            }
          }
          //shorter
          if (ordered) {
            // console.log(ordered);
            var x;
            i = ordered.pop ? (x = 1) && ordered[0] : ordered;
            while (i && this[i]) {
              if (!force && this[i]._lstamp !== this._lstamp && this[i].__t === 1) force = true
              val = _getOperator(val, force, i, this, bind, operators);
              if (!nolval && !this[i]._lval) nolval = true
              i = ordered[x++];
            }
          }
        }
      }
      if (!nolval && !force) {
        this._lval = val;
        this.__lval = val;
      } else if (!(this._base && this._base.instances)) {
        this.__lval = val;
      }
      return val;
    } else {
      return this.__lval;
    }
  },
  /**
   * Fires all listeners
   * @method update
   * @param  {[type]} instance    [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @return {[type]}             [description]
   */
  'update',
  function(instance, noinstances, instancesUpdates, stamp, from, remove, added) {
    //is this really nessecary?
    this._update.call( this, void 0, stamp || this.stamp(), from, remove, false, false, noinstances, instance, instancesUpdates  ); //this.val
    return this;
  },
  /**
   * Extends vigourObject._update
   * Adds loads of stuff to optimize updates for calculations
   * @method _update
   * @param  {[type]} val         [description]
   * @param  {[type]} stamp       [description]
   * @param  {[type]} from        [description]
   * @param  {[type]} remove      [description]
   * @param  {[type]} added       [description]
   * @param  {[type]} noinstances [description]
   * @param  {[type]} instance    [description]
   * @return {[type]}             [description]
   */
  '_update',
  function( val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates ) {

    var t = this,
      base = t._base;

    if (val instanceof exports && !t._bind) 
    {
      if (val._caller) {
        t._bind = val._caller;
      }
    }

    if ( (!t._lstamp) || t._lstamp !== stamp  ) {

    // var operators = t.operators
    // var lval 
    // var calcVal
    // var passValueCache 

    // if( !t.ignoreCache ) {
    //   //TODO: this is a temporary fix needs to be faster
    //   //make this a method
    //   function cleanup(t) {
    //   	t._lval = void 0
    //   	t.__lval = void 0 
    //   	if(t._val instanceof object ) {
    //   		//TODO: if stuff doesnt update uncomment this line
    //   		// cleanup(t._val)
    //   	}
  	 //    for(var $field in t) {
  	 //    	if(operators[$field]) {
  	 //    		cleanup(t[$field])
  	 //    	} else if($field > -1) {
  	 //    		cleanup(t[$field])
  	 //    	}
  	 //    }
    // 	}
    //   cleanup(t)

    //   lval = t.___lval
    //   calcVal = t.val
    //   passValueCache = lval === void 0 || lval !== calcVal
    //   t.___lval = calcVal

    // } else {

      // t.clearCache()
      // passValueCache = true
    // }

     // if (  passValueCache || ( base && base.instances ) || t._skip ) { //pass this calculation to vset else its too heavy;

    t._lval = false  
    // t._skip = true
    if(base && base.instances || t._skip || t.__lval === void 0 || t.___lval !== t.val ) {

      // if(window.smut) {
        // console.log('wtf is happening!!!!', t._path, t, t._updateOrigin, arguments)
      // }

        var prop = t._prop,
          parent = t._parent,
          vset = prop && prop._vset;

        var operators = t.operators
  
        //make this better
        if (!(from && remove) && operators && (operators[t._name] || (parent && parent.__t === 1 && operators[parent._name] && (!from || t._name == parent.length - 1)))) {
          //works for arrays since arrays are always replaced on update , updating an individual item using .set will not result in an update at this pont which has to be resolved
          var _op = this._parent;
          while (operators[_op._name]) {
            _op._lval = false; //if no change to lval can go wrong...
            _op = _op._parent;
          }
          if (_op) {
          	//this geatly increases updates may be important for animation but not nessecary for anything else!
            _op._update(val, stamp, this, remove, added, oldval, noinstances, instance, instancesUpdates);
          }
        }

        if (instancesUpdates) {
          instancesUpdates.call(t, val, stamp, from, remove, added, oldval, noinstances, instance, instancesUpdates);
        } else {
          if (instance) {
            base = instance;
          }
          if (vset) {
            t._caller = base;
            vset.call(t, stamp, from, remove, val);
          }
          if (base && vset && base.instances && !noinstances && prop.updateinstances !== false) {
            base.eachInstance(function() { //look for current caller instance perhaps?
              t._caller = this;
              vset.call(t, stamp, from, remove, val);
            }, prop.name, t);
            t._caller = base;
          }
          //form gone lets see!
          //from self doorgeven in chain ==-- if ! not from from ---> , extra arg
          object.prototype._update.call(t, val, stamp, from || t, remove, added, oldval)
        }

        //pas op met deze!
        t._lstamp = stamp;
    }
    else {
      // if(window.smut) console.log('catch it!', arguments)
    }


    }
  })

//requiring operators does not automaticly require vigourValue, may be handy?
util.define(exports, 'operators', {
  value: exports.operators = require('./operators')
})




},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./operators":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/length.js":[function(require,module,exports){
var Value = require('vigour-js/value'),
  util = require('vigour-js/util'),
  VObject = require('vigour-js/object')

exports.extend = util.extend(
  function(Target){
    if( Target.prototype instanceof VObject || Target === VObject) {
      // TODO: fix this to affect all VObject blacklists...
      Target.prototype._blacklist.push('_$length')

      util.define( Target,
        '$length', {
          get: function () {
            // TODO: ...so we dont have to do blacklist check:
            util.include(this._blacklist, '_$length')
            return this._$length || (this._$length = makeLength(this))
          }
        }
      )
    } else {
      throw new Error('cannot extend "$length" on non VObject Class')
    }
  }
)

function makeLength(instance) {
  var $length = new Value({
    val: function(){
      return getLength(instance)
    }
  })

  instance.on(function(val){

    // var identifier = instance._path.length 
    //   ? instance._path
    //   : instance._prop && instance._prop.name
    // console.log('UPDATE ON', identifier, 'SHINE DAT LENGTH?!', $length.val
    // )
    // TODO: only update if added or removed
    $length._update.apply($length, arguments)
  })

  return $length
}

function getLength (current) {
  if(!current){
    return 0
  } if (current._filter) {
    return current.length
  } else if (current.__t === 4) {
    return getLength(current._val)
  } else if (current.__t < 3) {
    return current.keys.length
  } else if (typeof current._val === 'string') {
    return current._val.length
  } else {
    return 0
  }
}

},{"vigour-js/object":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/object/index.js","vigour-js/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/on.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2014, Vigour. All rights reserved.
 * @author: Jim de Beer, jim@vigour.io
 */

  /*
    Extension for Base classes to create an inheritable on - value
  */

var Value = require('./')
  , util = require('../util')
  , Base = require('../base')

exports.extend = util.extend
( function(base)
  {
    if( base instanceof Base )
    {

      base.extend
      (
        {
          name:'on',
          set:function(val) {
            
          },
          remove:function(val) {
            //remove
            // console.log('im being removed!')
             if(this.on.$remove) {
              this.on.$remove.update()
            }
          },
          new:function(val) {
            //init
            // console.log('INIT!----', this, val, arguments)
            if(this.on.$new) {
              this.on.$new.update()
            }
          },
          parent:function(val) {
            //init
            if(this.on.$parent) {
              this.on.$parent.update()
            }
          },
          render:function(val) {
            //init
            // console.log('RENDER!----', this, val, arguments)
            if(this.on.$render) {
              this.on.$render.update()
            }
          }
        }
      )

    }
    else
    {
      throw new Error('cannot extend "on" on non Base Class')
    }
  }
)

},{"../base":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/base/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js","./":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/operators.js":[function(require,module,exports){
/**
 * operators
 * operators can be set on V.Value.operators
 * define operators on this module
 * @property
 */
var util = require('../util')
  , V = require('../')
  
exports.add = function( val, operator ) {
  return val + operator
}
exports.sub = function( val, operator ) {
  return val - operator
}
exports.multiply = function( val, operator ) {
  return val * operator
}
exports.divide = function( val, operator ) {
  return val / operator
}
exports.max = function( val, operator ) {
  return val > operator ? operator : val
}
exports.min = function( val, operator ) {
  return val < operator ? operator : val
}
exports.transform = function( val, operator ) {
  return operator === false ? val : operator
}
exports.abs = function( val, operator ) {
  return operator ? Math.abs(val) : val
}
exports.floor = function( val, operator ) {
  return val | 0
}
exports.ceil = function ( val, operator ) {
  return Math.ceil( val )
}
exports.prepend = function( val, operator ) {
  return operator + val
}
exports.or = function ( val, operator ) {
  return val || operator
}
exports.when = function( val, operator ) {
  return operator && val
}
exports.$convertType = function ( val, operator ) {
  //convertType
  if( operator === 'boolean' )
  { 
    return val ? true : false
  } 
  else if( operator === 'number' )
  {
    //do isNan start using loDash for this kind of stuff ( almost nothing )
    //convert falsy or NaN values to 0
    return Number( val )
  }
}

exports.$convertTime = function( time, decimals ) {
  var hrs = ~~ (time / 3600)
  var mins = ~~ ((time % 3600) / 60)
  var secs = !isNaN(parseFloat(decimals)) && isFinite(decimals)
      ? (time % 60).toFixed(decimals) : ~~(time % 60)

  ret = "";
  if (hrs > 0) ret += "" + hrs + ":" + (mins < 10 ? "0" : "");
  ret += "" + mins + ":" + (secs < 10 ? "0" : "");
  ret += "" + secs;
  return ret || 0;
};

exports.default = function( val, operator ) {

// console.log( '????', val )
  
  //pas op met die 0
  if( (!val && val !== 0) || val._val === false || val === 'error' || val === 'success' )
  {
    //TODO: Arrays for default operator
    return operator
  }
  return val
}

exports.default.order = 1000
},{"../":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/index.js","../util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/index.js":[function(require,module,exports){
module.exports = exports = require('./lib/')
},{"./lib/":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/lib/index.js"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/lib/index.js":[function(require,module,exports){
var pkg = require('../package.json')
  , pluginId = pkg.plugin.id

module.exports = exports = {}

exports.get = function (opts, cb) {
  if (!cb) {
    cb = opts
    opts = {}
  }
  try {
    window.vigourNative.bridge(pluginId, 'get', opts, cb)
  } catch (e) {
    cb(e)
  }
}

exports.set = function (opts, cb) {
  if (!cb) {
    cb = opts
    opts = {}
  }
  try {
    window.vigourNative.bridge(pluginId, 'set', opts, cb)
  } catch (e) {
    cb(e)
  }
}
},{"../package.json":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/package.json"}],"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/package.json":[function(require,module,exports){
module.exports={"name":"vigour-native-statusBar","version":"2015/06/10 15:33:16 UTC (0.0.1)","author":{"name":"Shawn Inder","email":"shawn@vigour.io"},"repository":{"type":"git","url":"git+https://github.com/vigour-io/vigour-native-statusBar.git","branch":"shawn-dev"},"engines":{"node":">=0.10.0"},"main":"index.js","scripts":{"start":"gaston","test":"test/test.js"},"description":"Allows one to control the native status bar from a web app","keywords":["vigour","native","plugin","statusBar"],"bugs":{"url":"https://github.com/vigour-io/vigour-native-statusBar/issues"},"homepage":"https://github.com/vigour-io/vigour-native-statusBar","dependencies":{"gaston":"git+ssh://git@github.com/vigour-io/gaston.git","vigour-native":"git+ssh://git@github.com/vigour-io/vigour-native.git","vigour-fs":"git+ssh://git@github.com/vigour-io/vigour-fs.git","vigour-dev-tools":"git+ssh://git@github.com/vigour-io/vigour-dev-tools.git"},"optionalDependencies":{},"devDependencies":{"npm":"^2.7.6","npmlog":"^1.2.0"},"plugin":{"id":"statusbar","android":{"className":"io.vigour.plugin.statusbar.StatusBarPlugin","instantiation":"new StatusBarPlugin(this, webView)","libName":"statusbar-debug.aar"}},"gitHead":"588de4723cbde673fb22b4a28b70472045d3c8ff","readme":"# vigour-native-statusBar\nAllows one to control the native status bar from a web app\n\n##Install\n`npm i vigour-native-statusBar`\n\n##Usage\nSee [test/index.js](test/index.js)\n\n##Building a set of native apps from your codebase\n- `npm run build`\n- `npm run build -- ios android`","readmeFilename":"README.md","_id":"vigour-native-statusBar@0.0.1","_shasum":"81cc25910be7f1595417c3b8fdfb8382b1247f47","_from":"git+ssh://git@github.com/vigour-io/vigour-native-statusBar.git","_resolved":"git+ssh://git@github.com/vigour-io/vigour-native-statusBar.git#588de4723cbde673fb22b4a28b70472045d3c8ff","sha":"0.0.1"}
},{}],"/Users/shawn/Work/directv-fl/src/app/index.js":[function(require,module,exports){
var app = module.exports = require( 'vigour-js/app' )
  .inject(
    require( 'vigour-js/app/content' ),
    require( 'vigour-js/app/user' )
  )

require( './user' )
require( './values' )
require( './playback')
require( './init' )

window.a = app

},{"./init":"/Users/shawn/Work/directv-fl/src/app/init.js","./playback":"/Users/shawn/Work/directv-fl/src/app/playback.js","./user":"/Users/shawn/Work/directv-fl/src/app/user.js","./values":"/Users/shawn/Work/directv-fl/src/app/values.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/content":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/content.js","vigour-js/app/user":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/index.js"}],"/Users/shawn/Work/directv-fl/src/app/init.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var config = require( 'vigour-js/util/config' )
var user = app.user

// preloader
app.css = {
  addClass: 'preload'
}

user.data.is( 'loaded' )
  //do this later when content gets bound
  .then( function() { 
    app.ready.val = true
    //add this later
    // return app.content.is( 'loaded' ) 
  })
  .done( function() {
    app.css = {
      removeClass: 'preload'
    }
  })



app.initialised.once(true, function() {
  // console.log(document.domain.replace(/\:\d\d\d\d/, ':10001'))

  app.cloud = config.cloud === 'domain' ? document.domain+ ':10001'  : config.cloud
// =======
  // if(window.gaston && window.gaston.serverAddress.indexOf('{') === -1) {
  //   app.cloud = 'ws://' +
  //     window.gaston.serverAddress.split('//')[1].split(':')[0] + 
  //     ':10001'
  // } else {
  //   app.cloud = 'ws://' + config.cloud
  // }
  
// >>>>>>> dev
  user.token.val = 'futureland'
})

/*   
'ws://' 
  + window.gaston.serverAddress.split('//')[1].split(':')[0]
  + ':10001'//
*/

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/app/playback.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var Value = require( 'vigour-js/value' )
var cases = app.cases
var user = app.user

app.isPlaying.val = {
  val: false,
  $isReceiver:user.receiver.playing
}

app.volume = {
  val:1,
  $isReceiver: user.receiver.volume
}

cases.$isPlaying = app.isPlaying

if(cases.$isPhone) {
  app.popup.on(function(val) {
    if(val) {
      if(app.isPlaying.val===true) {
        app.isPlaying.from.val = false
        app.popup.is(function() {
          return this.val === false
        }, function() {
          app.isPlaying.from.val = true
        })
      }
    }
  })
}

cases.$isFullscreen = new Value( {
  val: function() {
    return app.state.val === 'player'
  },
  listen: app.state
} )

// cases.$isLoadingVideo = new Value( {
//   val: false,
//   defer: function( update ) {
//     var _this = this
//     if ( this._timer ) {
//       clearTimeout( this._timer )
//       this._timer = null
//     }
//     if ( this._val ) {
//       this._timer = setTimeout( function() {
//         _this.val = false
//         _this._timer = null
//       }, 2000 )
//     }
//     update()
//   }
// } )

// app.isPlaying.on( function( val ) {
//   if ( cases.$isLoggedIn.val ) {
//     if ( val === true ) {
//       // TODO: this crashes now, so i commented it out
//       // var media = app.user.navigation.media.from
//       // if ( media._parent._name !== 'channels' ) {
//       //   var epi = app.user.usage.from.get( media._contentPath ),
//       //     show = epi._parent._parent._parent._parent

//       //   if ( show ) {
//       //     show.set( 'media', media )
//       //   }
//       // }
//     }
//   }
// })

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/app/user.js":[function(require,module,exports){
var app = require('vigour-js/app')
var user = app.user.inject(
  require('vigour-js/app/user/token'),
  require('vigour-js/app/user/usage'),
  require('vigour-js/app/user/navigation'),
  require('vigour-js/app/user/multiscreen')
)

user.set({
  search: false,
  focus_row: 'spotlight',
  // focus_channels:0,
  focus_actor:0,
  focus_channels:0,
  focus_spotlight:0,
  focus_watching:0,
  focus_recommended:0,
  focus_releases:0,
  recentSearches: {},
  popup:0,
  trailerMuted:true
  // url: require( 'vigour-js/browser/network/url' )
})

app.popup.val = user.popup

var Value = require('vigour-js/value')

app.deviceMessage = new Value({
  val: user.receiverClient,
  transform: function( c, cv ){
    var title = cv && cv.from && cv.from.title && cv.from.title.val
    // console.error('deviceMessage! ', title)
    return title ? 'Connected to ' + title : 'Not Connected'
  }
})

},{"vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/user/multiscreen":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/multiscreen/index.js","vigour-js/app/user/navigation":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/navigation.js","vigour-js/app/user/token":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/token.js","vigour-js/app/user/usage":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/user/usage.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/app/values.js":[function(require,module,exports){
var app = require('./')
var user = app.user
var cases = app.cases
var Value = require('vigour-js/value')
  // TODO: base this on device role
// app.state.val = {
//   default: 'first'
// }

app.state.val = cases.$isPhone ? 'first' : 'second'

app.current = new Value({
  val: user.navigation.last,
  transform: function(v, last) {
    var key = last.key && last.key.val
    return key === 'page' ? user.navigation.page.val : key
  },
  listen: [
    user.navigation.content,
    user.navigation.page
  ]
})

app.previous = new Value({
  val:app.current,
  defer:function(update,args){
    var val = this._val.val
    if(typeof val === 'string' && val !== this.current){
      this.prev = this.current
      this.current = val
    }
    update()
  },
  transform:function(val){
    return val._parent.prev || 0
  }
})

app.secondPopup = new Value(false)

app.hideStatusbar = new Value({
  val: false,
  transform: app.isPlaying
})

cases.$hasReceiver.on(function() {
  app.css = this.val ? {
    addClass: 'hasReceiver'
  } : {
    removeClass: 'hasReceiver'
  }
})

if(!cases.$isPhone){
  cases.$isReceiver.on(function(){
    app.state.val = this.val ? 'second' : 'inactive'
  })
}
},{"./":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/value":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/value/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/channel/index.js":[function(require,module,exports){
require('./style.less')

var Actors = require('/Users/shawn/Work/directv-fl/src/components/shared/actors')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')
var Progress = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar').Bar
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Poll = require('/Users/shawn/Work/directv-fl/src/components/shared/poll')
var Statistics = require('/Users/shawn/Work/directv-fl/src/components/shared/statistics')
var Trivia = require('/Users/shawn/Work/directv-fl/src/components/shared/trivia')
var Content = require('../content')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/bar')
var Tweets = require('/Users/shawn/Work/directv-fl/src/components/shared/tweets')

module.exports = new Content({
  'holder.page': {
    container:{
      'model.field':'guide.0',
      titlebar:new Bar({
        css: 'ui-bar',
        accent: {},
        left: {
          title:new Title(),
          timefiller: {
            'left.text.data':'start-time',
            'middle.filler': new Progress({
              'seek.w': '75%'
            }),
            'right.text.data':'end-time'  
          }  
        }
      }),
      description:new Description({
        display:{
          data:'description',
          transform:function(v,cv){
            return cv ? 'block' : 'none'
          }
        }
      }),
      actors:new Actors(),
      poll:new Poll(),
      statistics:new Statistics(),
      trivia:new Trivia(),
      tweets:new Tweets(),
    },
    collection:{
      data:'guide',
      element:new Bar({
        left: {
          title:new Title(),
          info: {
            'left.text':{
              data:'start-time',
              add:[
                ' - ',
                {data:'end-time'}
              ]
            }
          }  
        }
      })
    }
  }
}).Class

},{"../content":"/Users/shawn/Work/directv-fl/src/components/active/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/channel/style.less","/Users/shawn/Work/directv-fl/src/components/shared/actors":"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js","/Users/shawn/Work/directv-fl/src/components/shared/bar":"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/poll":"/Users/shawn/Work/directv-fl/src/components/shared/poll/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/statistics":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","/Users/shawn/Work/directv-fl/src/components/shared/trivia":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js","/Users/shawn/Work/directv-fl/src/components/shared/tweets":"/Users/shawn/Work/directv-fl/src/components/shared/tweets/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/channel/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/content/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Player = require('/Users/shawn/Work/directv-fl/src/components/active/player')
var Topbar = require('/Users/shawn/Work/directv-fl/src/components/active/topbar')

module.exports = new Element({
  css: 'content-item',
  x: {
    translate: true
  },
  scrollbar: 'y',
  holder: {
    y: {
      val: 0,
      animation: {
        time: 18,
        easing: 'outCubic',
        complete: function() {
          var _this = this
          if (this.y.val === -this.player.h.val - 1) {
            if (!_this.isSwipedup.val) {
              _this.swipeup.display = 'none'
            }
            if (!_this.timeouty) {
              _this.timeouty = setTimeout(function() {
                if (_this.isSwipedup.val) {
                  _this.swipeup.display = 'block'
                }
                _this.timeouty = false
                _this.y.val = _this.isSwipedup.val ? -_this.player.h.val + 30 : 0
              }, 0)
            }
          }
        }
      }
    },
    player: new Player(),
    swipeup: {
      display: 'none',
      nested: {
        position: 'absolute',
        w: app.w,
        h: app.h,
        msg:{
          icon:new Icon({
            icon:'pullback'
          }),
          text: 'Resume Here'
        },
        'events.click': function() {
          app.user.receiver.media.$userOrigin = false
        }
      },
      y: {
        val: app.h,
        multiply: -1
      },
      h: app.h
    },
    extend: {
      isSwipedup: function(val) {
        if (!this.rendered && val && val.val) {
          this.swipeup.display = 'block'
          this.y = -this.player.h.val + 30
        } else if (this.swipeup.display.val === 'block') {
          this.y = -this.player.h.val - 1
        } else {
          this.y = val.val === true ? -this.player.h.val - 1 : 0
        }
      },
      receiverMedia: function(val) {
        var data = this.parent.data
        if(data){
          var swipeup = this.isSwipedup = val.from === data.from
          if (swipeup) {
            this.player.playing.from = false
          } else {
            var time = data.from.get('time')
            if (time.val < 0) {
              data.from.get('time').val = Math.abs(time.val)
            }
          }
        }
      }
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/active/content/style.less","/Users/shawn/Work/directv-fl/src/components/active/player":"/Users/shawn/Work/directv-fl/src/components/active/player/index.js","/Users/shawn/Work/directv-fl/src/components/active/topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/content/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/discover/index.js":[function(require,module,exports){
require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var _focused = require('/Users/shawn/Work/directv-fl//src/components/util').focused
var List = require('/Users/shawn/Work/directv-fl//src/components/shared/list')

var ListHolder = new Element( {
  'header.text':{data:'title'},
  'events.down': function( e ) {
    var _this = this
    var holder = this.parent
    var eY = e.y
    var eX = e.x
    var id = 'passCheck'

    this.addEvent( 'move', function( e ) {
      var dY = e.y - eY
      var dX = e.x - eX
      if ( Math.abs( dX ) > Math.abs( dY ) ) {
        holder.$focus.$userOrigin = _this.name
      }
      _this.removeEvent( false, id )
    }, id )

    this.addEvent( 'up', function( e ) {
      _this.removeEvent( false, id )
    }, id )
  }
} ).Class

module.exports = new Element( {
  css: 'first-discover',
  spotlight: new ListHolder( {
    header:false,
    list: new List.Spotlight({'model.field':'spotlight'}),
    dots: new List.Dots()
  } ),
  channels: new ListHolder({
    model:{field:'channels'},
    list: new List.Channel()
  } ),
  watching: new ListHolder( {
    model:{field:'watching'},
    list: new List.Watching()
  } ),
  releases: new ListHolder( {
    model:{field:'releases'},
    list: new List.Poster()
  } ),
  recommended: new ListHolder( {
    model:{field:'recommended'},
    list: new List.Poster()
  } ),
  extend:{
    $focus: function( val ) {
      var child = typeof val.val === 'string'
        ? this[val.val]
        : this.children[ val.val || 0 ]
      _focused( this, child )
    }
  },
  scrollbar: 'y',
  'events.scroll': function( e ) {
    if(exports.ignoreScroll) return
    var node = this.node
    var fraction = (exports.scrollTop = node.scrollTop) / ( node.scrollHeight - node.offsetHeight )
    var index = Math.round( fraction * ( this.children.length - 1 ) )
    var name = this.children[index].name
    this.$focus.$userOrigin = name
  },
  setSetting: {
    name: 'prepValues',
    parent: function() {
      var children = this.children
      var child
      var field
      var length = children.length
      var i = length - 1
      var obj

      for ( ; i >= 0; i-- ) {
        child = children[i]
        field = 'focus_' + children[i].name
        if ( !app.user[ field ] ){
          obj = {}
          obj[ field ] = 0
          app.user.set( obj )
        }
        child.list.$focus = app.user[ field ]
        if(child.dots) child.dots.container.$focus = app.user[ field ]
      }

      if(exports.scrollTop){
        exports.ignoreScroll = true
        this.node.scrollTop = exports.scrollTop
        window.requestAnimationFrame(function(){
          exports.ignoreScroll = false
        })
      }else{
        var _this = this
        exports.ignoreScroll = true
        window.requestAnimationFrame(function(){
          exports.ignoreScroll = false
          var node = _this.node
          if(node){
            var focus = _this.$focus.val
            var index = getIndex(_this[focus])
            node.scrollTop = index/(length - 1) * ( node.scrollHeight - node.offsetHeight )
          }
        })
      }

    }
  }
} ).Class

function getIndex( _this ){
  if (_this._index === void 0) {
    var siblings = _this.parent.children
    for (var i = siblings.length - 1; i >= 0; i--) {
      siblings[i]._index = i
    }
  }
  return _this._index
}

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/active/discover/style.less","/Users/shawn/Work/directv-fl//src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/discover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/episode/index.js":[function(require,module,exports){
require('./style.less')

var Movie = require('../movie')

module.exports = new Movie({
  'holder.page': {
    'actors.body.collection.data':'show.actors',
    'recommendations.body.collection.data':'show.recommendations'
  }
}).Class


},{"../movie":"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/episode/style.less"}],"/Users/shawn/Work/directv-fl/src/components/active/episode/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var cases = app.cases
var Topbar = require('./topbar')
var Menu = require('./menu')
var Remote = require('./remote')
var Popup
var First

//app alleen maar zo requiren zodat je erbij kan vars moeten altijd megegevb wirden
//app kan je usen voor dingen als app.w, app.h of default cases

if ( cases.$isPhone ) {

  var Switcher = require( './switcher' )

  First = new Element({
    // w:app.w,
    y:{val:0,translate:true},
    // h:app.h,
    css: 'first-state',
    menu: new Menu({
      menu: app.menu
    }),
    on: {
      //replace on with extended vars (nicer) maybe make a type for this (value that also tries to get parent if its no full)
      //value that has a function on it thats just the defer?
      popup:{
        defer:function(update) {
          this.clearCache()
          var caller = this._parent._caller
          if(typeof this.val === 'string' || this.from._contentType === 'actors') {
            if(!caller.popup) {
              Popup = Popup || require('./popup')
              caller.set({
                popup: new Popup({
                  popup:this._val
                })
              })
            }
          }
          update()
        }
      },
      secondPopup:{
        defer:function(update) {
          this.clearCache()
          var caller = this._parent._caller
          if(typeof this.val === 'string' || this.from._contentType === 'actors') {
            if(!caller.volume) {
              Popup = Popup || require('./popup')
              caller.set({
                volume: new Popup({
                  popup:this._val
                })
              })
            }
          }
          update()
        }
      }
    },
    holder: {
      css:{
        val: app.menu, 
        transform: function(val, cv) {
          return cv ? 'open' : ''

        }
      },
      x:{ 
        val: app.menu,
        multiply:325,
        animation:{ time: 12, easing:'outCubic' } 
      },
      topbar: new Topbar(),
      // w: {
      //   parent: 'w'
      // },
      // h:{
      //   parent: 'h'
      // },
      events: {
        down:function(e) {
          if(app.menu.val) {
            e.prevent = true
            app.menu.val = false
          }
        }
      },
      switcher: new Switcher({
        // w:app.w,
        // h:{ val:app.h,sub:Topbar.base.h }
      }),
      miniplayer: new Remote({
        
      }) 
    }
  }).Class

} else {

  First = new Element({
    text: 'oops not phone in firstscreen'
  }).Class

}

module.exports = First
},{"./menu":"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js","./popup":"/Users/shawn/Work/directv-fl/src/components/active/popup/index.js","./remote":"/Users/shawn/Work/directv-fl/src/components/active/remote/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/style.less","./switcher":"/Users/shawn/Work/directv-fl/src/components/active/switcher/index.js","./topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js":[function(require,module,exports){
require('./style.less')
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')

var MenuItem = new Element({
	icon: new Icon({icon:'search'}),
	css:'menu-item',
	title:{}
}).Class

module.exports = exports = new Element({
	w:app.w,
	h:app.h,
	logo: {},
	css:'menu',
	extend: {
		menu:function(){},
		navigation:function(){}
	},
	// scrollbar:'y',
	append: [
		MenuItem,
		{ 'title.text':'search',
			'icon.icon': 'searchMenu',
			'events.click':function() {
				this.parent.navigation.from.page.$userOrigin = 'search'
				this.parent.menu.from.val = false
			}
		},
		{ 'title.text':'discover',
			'icon.icon': 'discover',
		 'events.click':function() {
				this.parent.navigation.from.page.$userOrigin = 'discover'
				this.parent.menu.from.val = false
			}
		},
		{
			'title.text':'on demand',
			'icon.icon': 'shows',
			css:'menu-item inactive'
		},
		{
			'title.text':'live tv',
			'icon.icon': 'tv',
		  css:'menu-item inactive'
		},
		{
			'title.text':'guide',
			'icon.icon': 'epg',
			css:'menu-item inactive'
		}
	],
	footer: {
		profile:{},
		title: {
			text:'Kevin Tague'
		},
		settings: new Icon({
			icon:'settings'
		})
	}
}).set({
	navigation:{
		defer:function(update) {
			if(this.from.page) {
				for(var i in this._caller.children) {
					var child = this._caller.children[i]
					var title = child.title &&  child.title.text.val
					var page = this.from.page.val

					if( title && title===page && this._focused!==child) {
						if(this._focused) {
							this._focused.css ='menu-item'
						}

						this._focused = this._caller.children[i]
						this._focused.css = 'menu-item focused' 
						break;
					}
				}
			}
			update()
		}
	}
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/menu/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/menu/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js":[function(require,module,exports){
require('./style.less')

var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/bar')
var Actors = require('/Users/shawn/Work/directv-fl/src/components/shared/actors')
var Recommendations = require('/Users/shawn/Work/directv-fl/src/components/shared/recommendations')
var Content = require('../content')
var Mpaa = require('/Users/shawn/Work/directv-fl/src/components/shared/mpaa')
var Rating = require('/Users/shawn/Work/directv-fl/src/components/shared/rating')

module.exports = new Content({
  'holder.page': {
    titlebar:new Bar({
      left:{
        title:new Title(),
        subtitle:new Subtitle()
      },
      right:{
        mpaa:new Mpaa(),
        rating:new Rating()
      }
    }),
    description: new Description(),
    actors:new Actors(),
    recommendations:new Recommendations()
  }
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/active/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/movie/style.less","/Users/shawn/Work/directv-fl/src/components/shared/actors":"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js","/Users/shawn/Work/directv-fl/src/components/shared/bar":"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mpaa":"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js","/Users/shawn/Work/directv-fl/src/components/shared/rating":"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js","/Users/shawn/Work/directv-fl/src/components/shared/recommendations":"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/movie/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/player/fullscreen.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')

var Fullscreen = new Element({
  icon: new Icon({ icon: 'fullscreen' }),
  events: {
    click: function(){
      console.log('go fullscreen!')
    }
  }
}).Class

module.exports = Fullscreen

},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/player/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Video = require('vigour-js/browser/element/video')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var app = require('vigour-js/app')
var Fullscreen = require('./fullscreen')
var Seekbar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar')

var postpone = require('vigour-js/browser/events/util').postpone

var ASSETS = require('vigour-js/util/config').pointers.assets

var cases = require('vigour-js/browser/cases')

var Loader = require('/Users/shawn/Work/directv-fl/src/components/shared/loader')

var Player = new Element({
  css:'first-player',
  video: new Video({
    player: require( 'vigour-js/browser/element/video/html5' ),
    src: { data: 'video', prepend: ASSETS },
    duration: { data: 'duration' },
    volume: 1,
    time: { data: 'time' },
    events:{
      stalled:function() {
        if( this.rendered ) this.parent.preload(true)
      },


      play: function() {

        // if(gaston) gaston.log('hey play!')

        if(this.rendered && this.getBuffer()<0.001) {
          this.parent.preload(true)
        }
      },
      canplay:function() {
        this.parent.preload(false)
      },
      progress: function(p, b) {

        //better to check if its increased
        // if(this.preloading && (b-p)*this.duration.val > 20) {

        // this.parent.text = p + ' ' + this.prev

        if(this.prev && p > this.prev ) {
          this.parent.preload(false)
        } 

        this.prev = p

        //dit gaat eruit
        if(this.data._contentType!=='channels') {
          this.data.from.set('time', -Math.abs(p))
        }
      }
    }
  }),
  h:210,
  // loader: {
  //   'w,h':200,
  // },
  overlay: {
    middle: {
      left: { play: {
          icon: new Icon({ 
            icon: {
              val: 'play',
              $isPlaying: 'pause'
            } 
          }),
          subtitle: {
            text: {
              val: 'Play',
              $isPlaying: 'Pause'
            }
          },
          events: {
            down: function(e){
              if(this.checkParent('overlay',true).opacity.val > 0.5) {
                var playing = this.checkParent('overlay').playing.from
                playing.val = !playing.val
                // e.tempPrevent = true
                e.prevent = true
              }
            }
          }
        }
      },
      middle: { 
        line: {},
        display: {
          val: 'none',
          $hasReceiver: 'table-cell',
          transform: function(){}
        }
      },
      right: { 
        swipeup: {
          icon: new Icon({ icon: 'swipeup' }),
          subtitle: {
            text: 'Play on '
          },
          events: {
            down: function(e){
              if(this.checkParent('overlay',true).opacity.val > 0.5) {
                app.user.receiver.playing.$userOrigin = true
                app.user.receiver.media.$userOrigin = this.checkParent('data',true).from
                e.prevent = true
              }
            }
          }
        },
        display: {
          val: 'none',
          $hasReceiver: 'table-cell',
          transform: function(){}
        }
      }
    },
    bottom: {
      left: { 
        table: {
          display: {
            data:function(data) {
              return data._contentType==='channels' ? 'none' : 'table'
            }
          },
          time:{ holder: { text:{data:'time', multiply: { data:'duration'}, abs:true, $convertTime:true } } },
          holder :{
            seekbar: new Seekbar({
             button:{y:{val:-8,translate:true}}
            })
          },
          duration:{ text:{ data:'duration', $convertTime:true } }
        }
      },
      right: { fullscreen: new Fullscreen() }
    },
    opacity: {
      val:1, animation:{
        time:18,
        easing:'outCubic'
      }
    }
  },
  define: {
    preload: function(val) {
      if(val===true && this.rendered) {
       this.preloading = true
       this.overlay.bottom.left.table.holder.seekbar.css = 'ui-seekbar loading'
       this.overlay.opacity = 1
      } else {
        this.overlay.bottom.left.table.holder.seekbar.css = 'ui-seekbar'


        if(this.video.$playing.val===true && this.preloading) {
          this.overlay.opacity = 0
        }
        this.preloading = false
      }
    },
    fadeOut:postpone(function() {
      if(this.playing && this.playing.val===true && !this.preloading) {
        this.overlay.opacity = 0
      }
    },3000)
  },
  events: {
    down: function(e) {
      if(this.overlay.opacity.val===0 || e.tempPrevent) {
        this.overlay.opacity = 1 
        if(this.playing.val===true) {
          this.fadeOut()
        }
      } else if(this.playing.val===true && !e.tempPrevent) {
        this.overlay.opacity = 0
      }
    },
    move:function() {
      if(this.playing.val===true) {
        this.fadeOut()
      }
    }
  },
  extend:{
    playing: {
      set:function(val) {
        this.video.$playing = val
        if(val.val===true) {
          this.overlay.opacity = 0
        } else {
          this.overlay.opacity = 1
        }
      // if()
      },
      remove:function() {
        app.isPlaying.from = false
      }
    },
    receiver: function(val, stamp) {
      if(cases.$hasReceiver.val) {
        var receiverClient = val.from
      }
    }
  }
}).Class

module.exports = Player

},{"./fullscreen":"/Users/shawn/Work/directv-fl/src/components/active/player/fullscreen.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/player/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/loader":"/Users/shawn/Work/directv-fl/src/components/shared/loader/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/player/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/index.js":[function(require,module,exports){
require('./style.less')

var Page = require('../page.js')
var app = require('vigour-js/app')
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var List = require('/Users/shawn/Work/directv-fl/src/components/shared/list')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var Trivia = require('/Users/shawn/Work/directv-fl/src/components/shared/trivia')
var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')

module.exports = exports = new Page({
  w: app.w,
  h: {
    val: app.h,
    sub: 60
  },
  scrollbar: 'y',
  carousel: {
    container: new List.Carousel({
      collection: {
        data: 'img.cover',
        element: new Element({
          css: 'focus-item',
          img: new Img({
            overlay: {},
            'background.data': true
          })
        })
      },
      $focus: {
        data: 'focus'
      }
    }),
    dots: new List.Dots({
      container: {
        collection: {
          data: 'img.cover',
          element: new Element()
        },
        $focus: {
          data: 'focus',
          default:0
        }
      }
    }),
    'model.subscription': {
      img: {
        cover: {
          $: true
        }
      }
    }
  },
  bio: new Description({
    'header.text': 'bio',
    'body.text.data': 'bio'
  }),
  famous: {
    'header.text': 'Famous For',
    collection: {
      data: 'catalog',
      element: new Poster({
        'events.click': function() {
          app.popup.$userOrigin = false
          app.user.navigation.content.$userOrigin = this.data.from
        }
      })
    }
  },
  trivia: new Trivia({
    model: {
      field: 'trivia'
    }
  }),
  on: {
    $parent: {
      defer: function(update) {
        this._parent._caller.parent.parent.topbar.middle.text = this._parent._caller.data.get('title')
        update()
      }
    }
  }
}).Class

},{"../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/style.less","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl/src/components/shared/trivia":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var cases = require( 'vigour-js/browser/cases' )
var ua = require( 'vigour-js/browser/ua' )

var raf = require( 'vigour-js/browser/animation/raf' )
var app = require( 'vigour-js/app' )
var Icon = require( '../../../shared/icon' )

var Device = new Element({
  css: 'device',
  icon: new Icon({ icon: { 
    data: 'device'
  } }),
  info: {
    title: { text: { data: 'title'} },
    subtitle: { text: { data: 'info' } }
  }
}).Class

module.exports = exports = new Element( {
  css: 'active devices',
  myDevice: new Device({
    model: { inherit: false },
    on: {
      $new: {defer: function(update){
        this._parent._caller.data = app.cloud.client
        update()
      }}
    },
    info: {
      title: { text: 'This Device' },
      subtitle: { text: { data: 'title' } }
    }
  }),
  listTitle: { text: 'Available Devices' },
  middle: {
    display: {
      val: 'block',
      $hasDevices: 'none'
    },
    text: 'No Devices Available'
  },
  list: {
    display: {
      val: 'none',
      $hasDevices: 'block'
    },
    collection: {
      element: new Device( {
        css: 'device',
        model: function( data ) {
          if( data && data.from && data.from.device && 
              /(phone)/.test(
                data.from.device.val 
              )
            ) {
            this.opacity = 0.5
          }
        },
        events: {
          click: function() {
            var user = app.user//this.checkParent( 'on.user', true )._val
            var client = this.data.from
            if( /(tv)|(tablet)|(IFE)/.test( 
                  client.device.val 
                ) 
              ) {
              user.setReceiver( client )
            }
          }
        }
      } ),
      data: true
    }
  },
  on: {
    $render: {
      defer: function(update) {
        // ff binden nog
        var caller = this._parent._caller
        caller.on.devices._val._update()
        update()
      }
    },
    $parent:{
      defer:function(update) {
        this._parent._caller.parent.parent.topbar.middle.text = 'devices'
        update()
      }
    },
    devices: {
      defer: function( update ) {
        var caller = this._parent._caller
        caller.on.receiver._update()
        caller.data = this.from
        update()
      }
    },
    receiver: {
      defer: function( update ) {
        var _this = this
        // TODO: get rid of this raf
        raf( function() {
          if ( _this._parent ) {
            var caller = _this._parent._caller
            var receiver =  _this.from
              
            var elem = caller.list.find( '_d.from', receiver.from )
            if ( elem ) {
              if ( _this.focus && _this.focus._node ) {
                _this.focus.css = {
                  removeClass: 'focused'
                }
              }
              _this.focus = elem
              elem.css = {
                addClass: 'focused'
              }
            } else if ( _this.focus ) {
              if ( _this.focus && _this.focus._node ) {
                _this.focus.css = {
                  removeClass: 'focused'
                }
                _this.focus = null
              }
            }
          }
          update()
        } )
      }
    }
  }
} ).Class

},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/animation/raf":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/animation/raf.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')

var Popup = require('../../shared/popup')

var Actor
var Volume
var Devices
var Remote

//basis of popup is shared (also used for remote? or is remote a popup thing?)

module.exports = exports = new Popup({
  popup:{
    // misc:function(update) {
    //  var val = this.val
    //  //dit is gedeeld -- zou ook vanuit app kunnen eventueel
    // },
    defer:function(update,args) {

      this.clearCache()
      
      var val = this.val
      var element
      var switcher = this._caller && this._caller.switcher
      var params = {}
      var topbarParams

      if(!switcher) {
        return true
      }

      if(val === false) {
        // console.error('wtf is happenin????')
        this._caller.y = app.h.val
      } else if(this.from._contentType === 'actors') { //listen to misc different!
        //word if this._contentType === 'actor' // doe dit -- popup.val word op gelistend in app
        element = Actor = Actor || require('./actor')
        params = { 
          // carousel:{
          //   container:{
          //     $focus: this.from.get('focus',2)
          //   },
          //   dots:{
          //     container:{
          //       $focus: this.from.get('focus',2)
          //     }
          //   }
          // },
          data: this.from
        }
      } else if(val === 'volume') { //listen to misc different!
        element = Volume = Volume || require('./volume')
      } else if(val === 'devices') { //listen to misc different!
        // topbar.middle.text.val = app.deviceMessage
        element = Devices = Devices || require('./devices')

        var user = app.user

        params = {
          on: {
            devices: user.devices,
            receiver: user.receiverClient
          }
        }
      } else if(val === 'remote') { //listen to misc different!
        element = Remote = Remote || require('./remote')
        topbarParams = {
          // left:{
          //   icon:'navDown'
          // },
          middle:{
            text:{data:'title'},
            data:app.user.receiver.media
          }
          // right:{
          //   display:'none'
          // }
        }
      } 

      if(element) {
        switcher.transition = {
          element: element,
          $params: params
        }
      }

      if(topbarParams){
        switcher.parent.topbar.set(topbarParams)
      }

      update()
    }
  }
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../shared/popup":"/Users/shawn/Work/directv-fl/src/components/shared/popup/index.js","./actor":"/Users/shawn/Work/directv-fl/src/components/active/popup/actor/index.js","./devices":"/Users/shawn/Work/directv-fl/src/components/active/popup/devices/index.js","./remote":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/style.less","./volume":"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

//maybe add scroll, only when list is too large
module.exports = new Element({
// x:{translate:true}
// , scrollbar:'y'
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/carousel.js":[function(require,module,exports){
var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('../../../shared/icon')
var List = require('../../../shared/list')
var offset = require('vigour-js/browser/events/offset')

var thumb = new List.Item.Info({
	css:'carousel-item',
	scale:{
		parent:'x',
		transform:function(){
			var rect = this.node.getBoundingClientRect()
			var left = rect.left
			var right = rect.right
			var middle = app.w.val/2
			var width = rect.width
			var val = Math.max(1 - Math.abs((left + width/2) - middle)/1000,0.8)
			this.css = left <= middle && right >= middle
				?	'carousel-item front'
				: 'carousel-item'
			return val
		}
	},
  'events.click':function() {
  	app.popup.$userOrigin = false
    app.user.navigation.content.$userOrigin = this.data.from
  }
})

module.exports = exports = new Element({
	w:app.w,
	h:240,
	extend: {
		media: function(val) {
			//look for focus
			//doe dat pas on is loaded
			// if(val.from._contentType==='channels') {

			var _this = this
			var slider = this.slider
			var children = slider.children

			for(var i in children) {
				var child = children[i]
				if(child.data === val.from && this.focused !== child) {
					if(!slider._check && children.length > 1){
						slider.x._p = true
						slider.$focus = i
						slider.x._p = null
						slider._check = true
					}else{
						slider.$focus = i
					}
					if(!this.listenFocus) {
						this.listenFocus = true
						slider.$focus.on(function() {
							var focus = slider.children[this.val].data
							if(val.from!==focus && focus) {
								//nu moet er een once listener op time
								app.user.receiver.media.$userOrigin = focus
								app.user.navigation.content.$userOrigin = focus
								focus.get('time').is('loaded', function() {
									if(app.user.receiver.media.from===focus) {
										this.val = Math.abs(this.val)
									}
								})
							}
						})
					}
				}
			}
			// }
		}
	},
	slider: new List.Carousel({
		x:{val:280-30+2},
		collection: {
			data:true,
			filter:true,
			element:thumb
		},
		model:{
			complete:function(){
				if(this.children[1] && this.parent.media){ // force an update when children are ready
					this.x._p = true
					this.parent.media.update()
					this.model = false
					this.x._p = null
				}
			}
		}
	})
}).Class


},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../../shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/offset":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/index.js":[function(require,module,exports){
require('./style.less')

var Page = require( '../page.js' )
var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Seekbar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar')

var Carousel = require('./carousel')

var Description = require('/Users/shawn/Work/directv-fl/src/components/shared/description')

var Guide = new Element({
	'header.text': 'Up Next',
	items: {
		collection: {
			data:'guide',
			element: new Element({
				css:'body',
				title: { text: { data:'title' } },
				subtitle: {
					text: {
						data:'start-time',
						add:[
							' - ',
							{ data:'end-time' }
						]
					}
				}
			})
		}
	}
}).Class

module.exports = exports = new Page({
	css:'remote',
	// text:{val:'remoteit!'},
	carousel: new Carousel(),
	info: {

	},
	controls: {
		title: { text:{ data:'guide.0.title', default:{data:'title'} }},
		seekbar: new Seekbar(),
		buttons: {
			left: new Icon({
				icon:'rewind'
			}),
			play: new Icon({
				extend: {
					playing: function(val) {
						this.icon = val.val === true ? 'pause' : 'play'
					}
				},
				icon:'play',
				'events.click':function() {
					this.playing.$userOrigin = !this.playing.val
				}
			}),
			right: new Icon({
				icon:'fastforward'
			}),
			volume: new Icon({
				icon:'volume',
				'events.click': function() {
					app.secondPopup.val = 'volume'
				}
			})
		}
	},
	extend: {
		receiverMedia: function(val) {
			var info = this.info
			var from = val.from
			this.controls.data = val.from
			
			//bug fix
			var seek = this.controls.seekbar.seek
			seek.w.update(seek)

			if(from._contentType==='channels') {
				if(info.guide&&info.guide.data !== from) {
					info.empty()
				}
				if(!info.guide) {
					info.empty()
					info.set({
						guide: new Guide({data:from})
					})
					this.carousel.data = app.content.get('channels')
				}
				this.carousel.media = from

			} else if( from._contentType !== 'receiver') {
				if(info.description && info.description.data !== from) {
					info.empty()
				}
				if(!info.description) {
					info.empty()
					info.set({
						description: new Description({data:from})
					})
					if(from._contentType==='movies') {
						this.carousel.data = app.content.get('movies')
						//focus gaat weird!
					} else if(from._contentType === 'series') {
						//content type word episode ---
						//harder to do
						this.carousel.data = app.content.get('series')
					}

				}
				this.carousel.media = from
			}
		}
	},
	on: {
		$parent:{defer:function(update) {
			this._parent._caller.parent.parent.topbar.middle.text = 'remote'
			update()
		}},
		$new:{defer:function(update) {
			this._parent._caller.receiverMedia = app.user.receiver.media
			this._parent._caller.controls.buttons.play.playing = app.user.receiver.playing
			update()
		}}
	}
}).Class



},{"../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./carousel":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/carousel.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/style.less","/Users/shawn/Work/directv-fl/src/components/shared/description":"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/remote/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Page = require( '../page.js' )
var Icon = require('../../../shared/icon')
var offset = require('vigour-js/browser/events/offset')

require('./style.less')

module.exports = exports = new Page({
	w:app.w,
	css:'volume',
	top: {
		title: { text: '100%' },
		volume: new Icon({
			icon:'volume', 
			'events.click': function() {
				this.parent.parent.volume.$userOrigin = 1
			}
		})
	},
	extend: {
		volume:function(val) {
			if(!this._volset && val.from!==val) {
				this._volset = true
				this.slider.block.y = val
				this.slider.block.middle.text = val
			}
		}
	},
	on: {
		$new:{ 
			defer:function(update) {
				var caller = this._parent._caller
				if(!caller.volume) {
					caller.volume = app.user.receiver.volume
				}
				update()
			} 
		},
		$parent:{
			defer:function(update) {
				this._parent._caller.parent.parent.topbar.middle.text.val = 'volume'
				update()
			}
		}
	},
	slider: {
		w: app.w,
		h:{val:app.h,sub:350},
		x:{max:0,min:0},
		block: {
			y:{ 
				transform: function(v,cv) {
					cv = cv>-1 ? cv : 1
					return (this.parent && (this.parent.h.val-30)-60)*( 1-cv )+30
				}
			},
			events: {
				drag:function(e) {

					if( !this._offset ) {
						this._offset = offset.y(this.parent)
					}
					//dragstart
					if(!this._draginfos) {
						this._draginfos = e.y-offset.y(this)+this._offset
					}
				
					var calc = 1 - ( e.y - this._draginfos ) / (this.parent.h.val-30)
					if(calc>1) calc = 1
					if(calc<0) calc = 0
					this.parent.parent.volume.$userOrigin = calc
				},
				up:function() {
					this._draginfos = false
				}
			},
			left: new Icon({
				icon: 'menu'
			}),
			middle: {
				text: { 
					transform: function(c, cv) {
						return Math.round(cv*100)+'%'
					}
				}
			},
			right: new Icon({
				icon: 'menuRight'
			}),
			// w:{val:app.w,sub:30},
			h:60
		}
	},
	mute: {
		muted: new Icon({icon:'muted'}),
		'events.click':function() {
			this.parent.volume.$userOrigin = 0
		}
	}
}).Class



},{"../../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../page.js":"/Users/shawn/Work/directv-fl/src/components/active/popup/page.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/offset":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/offset.js"}],"/Users/shawn/Work/directv-fl/src/components/active/popup/volume/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/remote/index.js":[function(require,module,exports){
require('./style.less')

var app = require( 'vigour-js/app' )
var config = require('vigour-js/util/config')
var Element = require('vigour-js/app/ui/element')
var Icon = require('../../shared/icon')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')

module.exports = exports = new Element({
	css:'mini-remote',
	y:{val:0,animation:{ time:10, easing:'outCubic'}},
	extend: {
		playing: function(val) {
			this.right.icon = val.val === true ? 'pause' : 'play'
		},
		media: function(val) {
			var type = val.from._contentType
			if( type === 'movies' || type === 'channels' || type === 'series' || type === 'episodes' ) {
				var _this = this
				// setTimeout(function() {
				// 	_this.parent.switcher.h = { add:-50 }
				// },500)

				this.y = 0
				if(this.data!==val.from) {
					this.data = val.from
				}
			} else {
				// this.parent.switcher.h = { add:0 }
				this.y = 50
			}
		}
	},
	left: {
		background: {
			val:config.pointers.img,
			add: { data: 'img.thumb' }
		}
	},
	middle: {
		title: {
			text:{data:'title'}
		},
		info:new Subtitle()
	},
	right: new Icon({
		icon:'play',
		'events.click':function(e) {
			e.prevent = true
			this.parent.playing.$userOrigin = !this.parent.playing.val
		}
		//hier ff die listening
	}),
	'events.click': function(e) {
		app.popup.$userOrigin = 'remote'
	}
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/remote/style.less","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/remote/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/search/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
// var Input = require('./input')
var postpone = require('vigour-js/browser/events/util').postpone
var timestamp = require('monotonic-timestamp')
var config = require('vigour-js/util/config')
var Topbar = require('../topbar')
var search = require('/Users/shawn/Work/directv-fl/src/components/shared/search')

//TODO: use data bound to display instead of the big if statement

module.exports = exports = new Element({
  css:'first-search',
  extend: {
    search: function(){}
  },
  define: {
    addRecentSearch: postpone(function(srch) {
      if(!this.node) return
      if(!this.page || !this.page.recent.data) return
      var keys = this.page.recent.holder.data.keys
      var recents = this.page.recent.holder.data.$userOrigin
      if(keys.length>5) {
        recents[keys[0]].remove()
      }
      var found
      if(recents) {
        recents.each(function() {
          if(this.title.val === srch) {
            found = true
            return true
          }
        })
      }
      if(!found) {
        recents.set(timestamp(),{title:srch})
      }
    },1000)
  },
  // topbar: {
  //   left: new Icon({
  //     icon:'menu',
  //     events: {
  //       down:function(e) {
  //         e.prevent = true
  //         app.menu.val = !app.menu.val
  //       }
  //     }
  //   }),
  //   field: new Input({
  //     events: {
  //       focusout: function(e) {
  //         var overlay = this.parent.parent.overlay
  //         overlay.display = 'none'
  //       },
  //       focus:function(e) {
  //         this.parent.parent.overlay.set({
  //           display:'block'
  //         })
  //       }
  //     }
  //   })
  // },
  page:new search.ResultList({
    scrollbar:'y',
    append:{
      val:[
        new Element({
          name:'noResults',
          display:'none',
          icon: new Icon({icon:'wrong'}),
          'title.text':'No results!',
          'body.text':'Please try to refine your query'
        }),
        new search.TopResult({
          name:'topresult'
        }),
        new Element({
          name:'recent',
          model: {
            inherit:false,
            complete:function() {
              if(this.data.keys.length) {
                this.noRecent.display = 'none'
                this.holder.display = 'block'
              } else {
                this.noRecent.display = 'block'
                this.holder.display = 'none'
              }
            }
          },
          noRecent:{
            icon: new Icon({icon:'searchMenu'}),
            title: {
              text:'Start Searching!'
            },
            body: {
              text:'Find your favorite movies, shows and channels.'
            }
          },
          holder: new search.Results({
            title: {
              text:'recent searches'
            },
            collection: {
              data:true,
              element: new search.Result({
                'events.click':function(e) {
                  this.checkParent('search',true).$userOrigin = this.data.title.val
                }
              }),
              filter: {
                sort:{ field:'_name', order:'z-a'}
              }
            }
          })
        })
      ],
      before:'movies'
    }
  }),
  overlay: {
    display:'none'
  },
  search:{
    defer:function(update, args) {

      if(!this.from.cloud) return true

      var caller = this._caller
      var elem$

      var list = [
          caller.page.movies,
          caller.page.series,
          caller.page.channels,
          caller.page.actors
        ]

      // if(!caller.topbar.field.data) {
      //   caller.topbar.field.data = this._val
      // }
      
      this.clearCache()

      if(this.val) {
        var srch = search.parseSearch( this.val )
        if( srch!==false ) {
          caller.addRecentSearch(srch)
          for(var i in list) {
            search.filterCollection( list[i], srch )
          }

          caller.page.recent.display = 'none'

          caller.data.get('movies').is(function() {
            return this.keys && this.keys.length>2 
                && this.from[0] && this.from[0].actors
          }, true).then(function() {
            if(caller._node) {
              for(elem$ in list) {
                list[elem$].display = list[elem$].filter.length > 0 
                  ? 'block' 
                  : 'none'  
              }
              
              var result = search.topResult( list ) 
              caller.page.topresult.data = result || false
              caller.page.topresult.display = result ? 'block' : 'none'
              caller.page.noResults.display = result ? 'none' : 'block'
              //if no result then ----
            }
          })
        } else {
          for(elem$ in list) {
            list[elem$].display = 'none'
          }
          caller.page.topresult.display = 'none'
          caller.page.noResults.display = 'none' 
          caller.page.recent.display = 'block'  
        }
          
      } else {
        for(elem$ in list) {
          list[elem$].display = 'none'
        }
        caller.page.topresult.display = 'none'
        caller.page.noResults.display = 'none' 
        caller.page.recent.display = 'block'
      }
      update()
    }
  }
}).Class

},{"../topbar":"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/search/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/search":"/Users/shawn/Work/directv-fl/src/components/shared/search.js","monotonic-timestamp":"/Users/shawn/Work/directv-fl/node_modules/monotonic-timestamp/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/search/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Icon = require('../../shared/icon')
var Menu = require('../menu')
var Discover
var Search
var Channel
var Episode
var Movie
var cases = app.cases

module.exports = exports = new Switcher({
  css: 'first-switcher',
  'extend.navigation': function() {},
  onTransition: 'slide',
  loader: new Element({
    css: 'first-loader',
    x: {
      translate: true
    },
    loadicon: new Icon({
      icon: 'error'
    })
  }),
  navigation: {
    defer: function(update, args) {
      var nav = this.from

      if (!nav || !nav.last || !nav.last.from.key) return true

      var field = nav.last.from.key.val
      var page
      var element
      var switcher = this._caller
      var params
      var options
      nav = nav[field]

      if (field === 'page') {

        var page = nav.val

        if (page === 'discover') {
          element = Discover = Discover || require('../discover')
          params = {
            $focus: app.user.focus_row,
            data: app.content.get('discover')
          }
        } else if (page === 'search') {
          element = Search = Search || require('../search')
          params = {
            data: app.cloud.data,
            search: app.user.search,
            page: {
              recent: {
                data: app.user.recentSearches.from
              }
            }
          }
        }

      } else if (field === 'content') {
        if (!switcher._swElem || switcher._swElem.data !== nav.from) {

          var type = nav._contentType

          if (type === 'movies') {
            element = Movie = Movie || require('../movie')
          } else if (type === 'episodes') {
            element = Episode = Episode || require('../episode')
          } else if (type === 'channels') {
            element = Channel = Channel || require('../channel')
          }

          options = {
            force: true
          }
          params = {
            data: nav.from,
            holder: {
              player: {
                playing: app.isPlaying,
                receiver: app.user.receiver
              },
              receiverMedia: app.user.receiver.media
            }
          }
        }

      }

      if (element) {
        switcher.transition = {
          element: element,
          $params: params,
          direction: app.menu.val ? 0 : field === 'content' ? 1 : -1,
          $options: options
        }

      }

      update()
    }
  }
}).Class

},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../channel":"/Users/shawn/Work/directv-fl/src/components/active/channel/index.js","../discover":"/Users/shawn/Work/directv-fl/src/components/active/discover/index.js","../episode":"/Users/shawn/Work/directv-fl/src/components/active/episode/index.js","../menu":"/Users/shawn/Work/directv-fl/src/components/active/menu/index.js","../movie":"/Users/shawn/Work/directv-fl/src/components/active/movie/index.js","../search":"/Users/shawn/Work/directv-fl/src/components/active/search/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/switcher/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/index.js":[function(require,module,exports){
require('./style.less')
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var user = app.user
var Icon = require('../../shared/icon')
var Title = require('../../shared/title')
var Input = require('./input')

var searchField = new Input({
  events: {
    focusout: function(e) {
      // var overlay = this.parent.parent.overlay
      // overlay.display = 'none'
    },
    focus:function(e) {
      // this.parent.parent.overlay.set({
      //   display:'block'
      // })
    }
  }
}).Class

module.exports = exports = new Element({
	css:'topbar',
	extend:{
		$current:function(val){
			var current = val.val
			if(current === 'search'){
				if(!this.search){
					this.set({
						css:'topbar searching',
						add:[
							new searchField({
								name: 'search',
								data:app.user.search
							}),
							'middle'
						]
					})
				}
			}else if(this.search){
				this.search.remove()
				this.css = 'topbar'
			}

			if( current === 'content' ){
				this.middle.data = user.navigation.content.from
			}else if( current === 'discover' ){
				this.middle.data = { title:current }
			}

		}
	},
	left: new Icon({ 
		icon:{
			val:app.current,
			transform:function(v,current){
				return current === 'content' ? 'back' : 'menu'
			}
		},
		events: {
			down:function(e) {
				e.prevent = true
				if( this.icon.val === 'menu' ){
					app.menu.val = !app.menu.val
				}else{
					user.navigation.page.$userOrigin = app.previous.val || 'discover'
				}
			}
		} 
	}),
	middle:new Title.Show(),
	right: new Icon({
		icon:'cast',
		'events.click':function() {
			app.popup.$userOrigin = 'devices'
		}
	})
})

module.exports = exports.Class


},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","../../shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","./input":"/Users/shawn/Work/directv-fl/src/components/active/topbar/input.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/active/topbar/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/input.js":[function(require,module,exports){
require('./reset.less')

var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var events = require('vigour-js/browser/events')
var cases = require('vigour-js/browser/cases')
var app = require('vigour-js/app/')

module.exports = new Element({
  node: 'form',
  name: 'search',
  css: 'search-field',
  model: {
    inherit: false,
    complete: function() {
      this.table.clear.display = this.data.val ? 'table-cell' : 'none'
    }
  },
  table: {
    lefticon: new Icon({
      icon: 'search'
    }),
    inputField: {
      node: 'input',
      attr: {
        type: 'text',
        name: 'search',
        placeholder: 'Search'
      },
      text: {
        data: true
      },
      events: {
        keydown: function(e) {
          if (e.keyCode == 13) e.preventDefault()
        },
        keyup: function(e) {
          if (e.keyCode !== 9) {
            var srch = this.node.value.length ? this.node.value.trim() : ''
            this.data.$userOrigin = srch
          }
        }
      }
    },
    clear: new Icon({
      icon: 'closeSmall',
      display: 'none',
      events: {
        down: function(e) {
          e.prevent = true
          this.parent.fromDown = true
            //TODO: figure out why this.parent does not have data bound to it!
          this.parent.inputField.data.$userOrigin = ''
            // focusout.call(this.parent.parent,e)
        }
      }
    })
  },
  events: {
    focusin: focus
  }
}).Class

function focus(e) {
  console.log('wtf wtf wtf', this.parent)
  if (this.events.focus) {
    this.events.focus._val.call(this, e)
  }
}

function focusout(e) {
  if (this.events.focusout) {
    this.events.focusout._val.call(this, e)
  }
}

},{"./reset.less":"/Users/shawn/Work/directv-fl/src/components/active/topbar/reset.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/events":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/index.js"}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/reset.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/active/topbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/bio/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

module.exports = new Element({
  css:'second-bio',
  'extend.$focus':function(val){
    var index = val.val
    if(index !== this._index){
      var data = this.data
      if(data){
        this.switcher.transition = {
          element:Img,
          $params:{
            opacity:0,
            background:data.from.get(['img','cover',index || 0],'')
          },
          $options:{
            force:true
          }
        }
        this._index = index
      }
    }
  },
  $focus:{
    data:'focus'
  },
  switcher:new Switcher({
    onTransition:'fade',
    // add:new Img({
    //   'background.data':'img.cover.0'
    // }),
  }),//will switch between images
  overlay:{
    'header.text.data':'title',
    bio:{
      'header.text':'Bio',
      'body.text.data':'bio'
    }
  },
  model:{
    subscription:{
      img:{
        cover:{
          $:true
        }
      }
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/bio/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/bio/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/channel/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var Widget = require('/Users/shawn/Work/directv-fl//src/components/inactive/widget')
var Content = require('../content')
var Trailer = require('../trailer')

module.exports = exports = new Content({
  css: 'second-channel',
  container: {
    left: {
      trailer: new Trailer({
        'video.src.data':'video'
      })
    },
    middle:{
      guide: new Widget.Guide()
    },
    right: new Switcher({
      onTransition: function(current, last) {
        if(last) last.remove()
        this.add(current)
      },
      model:{
        subscription:{
          guide:{
            0:{
              statistics:{
                title:true
              }
            }
          }
        },
        val:function(data){
          var widgetData = data.guide && data.guide[0]
          if(widgetData){
            this.transition = {
              element: widgetData.statistics ? Widget.Stats : Widget.About,
              $params:{ data:data }
            }
          }
        }
      }
    })
  },
  'extend.$complete':function(val){
    var complete = val.val
    if(complete === true){
      this.container.set({
        left:{
          twitter: new Widget.Twitter({
            data:this.data
          })
        }
      })
    }else if(complete === false){
      // this.container.set({
      //   left:{
      //     twitter: false
      //   }
      // })
    }
  }
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","../trailer":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/channel/style.less","/Users/shawn/Work/directv-fl//src/components/inactive/widget":"/Users/shawn/Work/directv-fl/src/components/inactive/widget/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/channel/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js":[function(require,module,exports){
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Cover = require('../cover')
var Channel
var Vod

module.exports = exports = new Element({
  cover: new Cover(),
  'extend.$active': function(val) {
    var active = val.val
    if (active !== void 0) {
      var bg = this.cover.bg
      var info = this.info
      if (active) {
        if (bg._loaded) bg.opacity = false
        bg.$wait = false
      } else {
        bg.$wait = true
        bg.opacity = 0
      }
    }
  },
  $active: true
}).Class

exports.select = function(data, type) {
  if (!type) type = data._contentType

  return type === 'channels' ? {
    element: Channel = Channel || require('../channel'),
    $params: {}
  } : {
    element: Vod = Vod || require('../vod'),
    $params: {
      $popup: app.popup
    }
  }
}

},{"../channel":"/Users/shawn/Work/directv-fl/src/components/inactive/channel/index.js","../cover":"/Users/shawn/Work/directv-fl/src/components/inactive/cover/index.js","../vod":"/Users/shawn/Work/directv-fl/src/components/inactive/vod/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/cover/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

module.exports = new Element({
  css:'second-cover',
  bg:new Img({
    opacity:0,
    $wait:true,
    background:{
      data:'img.cover.0',
      add:{
        data:'show.img.cover.0'
      }
    }
  }),
  overlay:{}
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/cover/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/cover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/discover/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var app = require('vigour-js/app')
var postpone = require('vigour-js/browser/events/util').postpone
var Content = require('../content')

var _preview = postpone(function(switcher,focusIndex) { //move this to app control stuff
  if(focusIndex !== void 0){
    var clouddata = app.cloud.data
    var focusrow = app.user.focus_row.val
    var data = clouddata.get(['discover',focusrow,'items',focusIndex])
    app.preview.val = data
    if(switcher._swElem) switcher._swElem.$active.val = true
  }
},400)

module.exports = new Switcher({
  css: 'second-discover',
  extend:{
    $highlight:function(val){
      var index = val.val
      var last = this.last
      if(index !== false){
        if(!this.fromContent){
          if(this._swElem) this._swElem.$active = false
          _preview(this,index)
          this.last = void 0
        }else{
          this.fromContent = false
        }
      }
    },
    $preview:function(val){
      val = val.val
      if(val){
        var data = val.from
        var transition = Content.select(data)
        transition.$params.data = data
        transition.$params.$complete = false
        this.transition = transition
      }
    },
    $content:function(val){
      val = val.val
      if(val){
        var data = val.from
        var transition = Content.select(data)
        transition.$params.data = data
        transition.$params.$complete = true
        this.transition = transition
        this.fromContent = true
        app.preview.val = data
      }
    }
  },
  onTransition:'fade'
}).Class
},{"../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/discover/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/discover/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
  , Element = require('vigour-js/app/ui/element')
  , Discover = require('./discover')
  , Search = require('./search')
  , Statusbar = require('./statusbar')
  , app = require('/Users/shawn/Work/directv-fl//src/app')
  , Navigation = require('./navigation')
  , Player = require('./player')
  , Content = require('./content')

//secondscreen toplevel
module.exports = exports = new Element({
  css:'second-state',
  y:{translate:true,val:0},
  switcher:new Switcher({ // switches between main and search
    onTransition:'fade'
  }),
  navigation:new Navigation(),
  statusbar:new Statusbar(),
  search:new Search(),
  extend:{
    $highlight:function( val ){},
    $preview:function( val ){},
    $page:function( val, stamp ){


      if(this.$media.val || !stamp) return
      var page = val.val

      app.user.trailerMuted.$userOrigin = true
      app.hideStatusbar.val = false
      
      if( page === 'discover' ){
        this.set({
          y:0,
          switcher:{
            transition:{
              element:Discover,
              $params:{
                $preview:this.$preview._val,
                $highlight:this.$highlight._val,
                $content:false
              }
            }
          },
          navigation:{
            container:{
              y:0
            }
          }
        })
      }else if(page === 'search'){
        this.set({
          y: -app.h.val + 80,
          search:{
            $search:app.user.search,
            $muted:app.user.trailerMuted,
            data:app.cloud.data
          }
        })
      }

    },
    $content:function( val,stamp ){

      // if(this.$media.val || !stamp) return
      // var data = val.from
      if(this.$media.val || !stamp) return

      app.hideStatusbar.val = false

      this.set({
        y:0,
        switcher:{
          transition: {
            element:Discover,
            $params:{
              $preview:false,
              $highlight:false,
              $content:val
            }
          }
        },
        navigation:{
          container:{
            y:420
          }
        }
      })
    },
    $media:function( val, stamp ){
      if(val.val){
        this.set({
          y:0,
          switcher:{
            transition:{
              element:Player,
              $params:{
                overlay:{
                  $volume:app.volume,
                  $time:val.val.get('time')
                },
                playing:app.isPlaying,
                data:val.$userOrigin,
                video: {
                  volume: app.volume
                }
              }
            }
          },
          navigation:{
            container:{
              y:460 + 80
            }
          }
        })
      }else{
        app.user.updateNavigation()
      }
    }
  },
  setSetting:{
    name:'updateNav',
    parent:function(){
      app.user.updateNavigation()
    }
  }
}).Class
},{"./content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./discover":"/Users/shawn/Work/directv-fl/src/components/inactive/discover/index.js","./navigation":"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/index.js","./player":"/Users/shawn/Work/directv-fl/src/components/inactive/player/index.js","./search":"/Users/shawn/Work/directv-fl/src/components/inactive/search/index.js","./statusbar":"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/index.js":[function(require,module,exports){
require('./style.less')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Element = require('vigour-js/app/ui/element')
var List = require('/Users/shawn/Work/directv-fl//src/components/shared/list')
var postpone = require('vigour-js/browser/events/util').postpone
var Switcher = require('vigour-js/app/ui/switcher')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')
var Progress = require('/Users/shawn/Work/directv-fl//src/components/inactive/progress')

var yElement = new Element({
  y: {
    translate: true,
    val:420
  }
}).Class

var titleElement = new yElement({
  'text.data': 'title'
}).Class

var map = {
  spotlight: {
    index: 0,
    list: List.Watching
  },
  channels: {
    index: 1,
    list: List.Channel
  },
  watching: {
    index: 2,
    list: List.Watching
  },
  releases: {
    index: 3,
    list: List.Poster
  },
  recommended: {
    index: 4,
    list: List.Poster
  }
}

var switchFocus = function(_this, index, focused, type) {
  var direction = index > _this.index ? -1 : 1
    //switch the title

  _this.container.set({
    bar: {
      title: {
        transition: {
          element: titleElement,
          direction: direction,
          $params: {
            data: focused
          },
          $options: {
            force: true
          }
        }
      },
      arrows: {
        up: {
          opacity:index === 0 ? 0.5 : 1
        },
        down: {
          opacity:index === 4 ? 0.5 : 1
        }
      }
    }
  })

  _this.index = index

  listFocus(_this, index, focused, type, direction)
}

var listFocus = postpone(function(_this, index, focused, type, direction) {
  var lists = _this.container.lists
  var focusItem = app.user['focus_' + type]

  if(lists){
    lists.transition = {
      element: map[type].list,
      direction: direction,
      $params: {
        data: focused,
        $focus: app.highlight.val = focusItem
      },
      $options: {
        force: true
      }
    }
  }
}, 200)

module.exports = new Element({
  css: 'second-navigation',
  container: new yElement({
    progress: new Progress({
      percentage:{
        text:{
          val:{
            parent:'on',
            animation:{
              easing:'outCubic',
              time:18
            }
          },
          transform:function(v,cv){
            return ~~cv + '%'
          }
        }
      },
      model:{
        complete:function(data){
          this.on.update(this)
        },
        inherit:false
      },
      on:{
        data:'time',
        defer:function(update){
          if(~~this.from.val){
            this._caller.opacity = 1
            update()
          }else{
            this._caller.opacity = 0
            return true
          }
        },
        multiply:100
      }
    }),
    bar: {
      title: new Switcher({
        onTransition: function(current, last, direction) {
          _transition(this, 40, current, last, direction)
        }
      }),
      arrows: {
        up:new Icon({
          icon:'upNav',
          opacity:0.1
        }),
        down: new Icon({
          icon:'downNav'
        })
      }
    },
    lists: new Switcher({
      onTransition: function(current, last, direction) {
        _transition(this, 400, current, last, direction)
      }
    })
  }),
  'model.subscription.$.$': true,
  extend:{
    $focus: function(val) { //val === 'spotlight'/'recommended' etc
      var _this = this
      var data = this.data
      if(!data) return
      
      if(!data.$length.val) {
        data.$length.once(function() {
          _this.$focus.update()
        })
        return
      }

      var focused = data[val.val]
      if(focused) {
        switchFocus(_this, map[val.val].index, focused, val.val)
      }
    }
  },
  setSetting: {
    name: 'prepValues',
    parent: function() {
      for(var type in map) {
        var field = 'focus_' + type
        if(!app.user[field]) {
          var obj = {}
          obj[field] = 0
          app.user.set(obj)
        }
      }
    }
  }
}).Class

function _transition(_this, delta, current, last, direction) {
  if(last) {
    last.y = delta * direction // should still remove
    current.y = delta * -direction
  }
  _this.add(current)
  if(_this._timer) {
    clearTimeout(_this._timer)
    _this._timer = null
  }
  _this._timer = setTimeout(function() {
    _this._timer = null
    doit()
  }, 50)

  function doit(){
    if(!current._blocked) current.y = 0
    else window.requestAnimationFrame(doit)
  }
}

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl//src/components/inactive/progress":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl//src/components/shared/list":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/navigation/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/player/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Video = require('vigour-js/browser/element/video')
var Progress = require('/Users/shawn/Work/directv-fl//src/components/inactive/progress')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var postpone = require('vigour-js/browser/events/util').postpone
var config = require('vigour-js/util/config')

var fadeIcon = postpone(function(_this, force) {
  var icon = _this._swElem && _this._swElem.icon
  if (icon) {
    icon.css = 'ui-icon fade-out'
    icon.opacity = 0
  }
}, 1000)

var fadeOverlay = postpone(function(_this, force) {
  if (app.isPlaying.val) _this.opacity = 0

}, 1000)

var updatePlay = postpone(function(_this) {
  app.hideStatusbar.val = false
  if (_this.$playing) _this.$playing.update()
}, 1000)

var Overlay = new Element({
  css: 'player-overlay',
  opacity: 0,
  icon: new Icon({
    opacity: 0,
    icon: {
      val: 'pause',
      $isPlaying: 'play'
    }
  }),
  info: {
    poster: {
      img: new Img({
        'background.data': 'img.poster'
      })
    },
    titles: {
      'nowplaying.text': 'Now Playing',
      'title.text.data': 'title',
      'subtitle.text.data': 'subtitle'
    }
  },
  recommended: {
    'header.text': 'Recommended',
    thumb:{
      img:new Img({
        background:{
          data:'recommendations.0.img.spotlight',
          add:{
            data:'show.recommendations.0.img.spotlight'
          }
        },
        display:{
          val:'block',
          when:{self:'background'},
          or:'none'
        }
      })
    }
  }
}).Class

var BarOverlay = new Element({
  opacity:0,
  container: {
    txt: {},
    progress: new Progress({
      display:false
    })
  },
  'extend.$value': function(val) {
    this.container.set({ //change this for data
      txt: {
        value: {
          text: val.val
        }
      },
      progress: {
        on: val.val
      }
    })
  }
}).Class

var SeekOverlay = new BarOverlay({
  css: 'seek-overlay',
  'container.txt': {
    text: 'SEEKING ',
    'value.text': {
      data: 'time',
      multiply: {
        data: 'duration'
      },
      $convertTime: true, //{data:'duration'},
    }
  }
}).Class

var VolumeOverlay = new BarOverlay({
  css: 'volume-overlay',
  'container.txt': {
    text: 'VOLUME ',
    'value.text': {
      val: 0,
      transform: function(v, cv) {
        return Math.round(cv * 100 || 0) + '%'
      }
    }
  }
}).Class

var OverlaySwitcher = new Switcher({
  extend: {
    $playing: function(val) {
      this.opacity = 1
      this.transition = {
        element: Overlay,
        $params: {
          data: this.parent.data,
          icon: {
            css: 'ui-icon fade-in',
            opacity: 1
          }
        }
      }
      if (app.isPlaying.val) fadeOverlay(this)
      fadeIcon(this)
    },
    $time: function(val) {
      if (arguments[2] === void 0 || val.val < 0 || app.user.receiver.media._contentType === 'channels') return
      this.opacity = 1
      this.transition = {
        element: SeekOverlay,
        $params: {
          $value: val.val
        }
      }
      app.hideStatusbar.val = true

      if (app.isPlaying.val) {
        fadeOverlay(this)
      } else {
        updatePlay(this)
      }

    },
    $volume: function(val) {
      if (arguments[2] === void 0) return
      this.opacity = 1
      this.transition = {
        element: VolumeOverlay,
        $params: {
          $value: val.val
        }
      }
      app.hideStatusbar.val = true
      if (app.isPlaying.val) fadeOverlay(this)
      else updatePlay(this)
    }
  },
  onTransition: function(current, last) {
    if (last) last.remove()
    current.$timeout = {
      50: function() {
        this.opacity = 1
      }
    }
    this.add(current)
  }
}).Class

module.exports = new Element({
  css: 'second-player',
  video: new Video({
    player: require('vigour-js/browser/element/video/html5'),
    duration: {
      data: 'duration'
    },
    time: {
      data: 'time'
    },
    src: {
      prepend: config.pointers.assets,
      data: 'video'
    },
    events: {
      progress: function(p) {
        this.data.from.set('time', -Math.abs(p))
      }
    }
  }),
  overlay: new OverlaySwitcher(),
  extend: {
    playing: function(val) {
      this.overlay.$playing = val
      this.video.$playing = val
    }
  }
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/player/style.less","/Users/shawn/Work/directv-fl//src/components/inactive/progress":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/browser/events/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/events/util.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/player/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/progress/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
	css:'second-progress',
  on:{
    data:'time',
  	abs:true,
    multiply:100
  },
  display:{
    val:app.preview,
    transform:function(v,cv){
      var popup = app.popup.val
      return (cv && cv._contentType === 'channels') || (popup && typeof popup !== 'string') ? 'none' : 'block'
    },
    listen:app.popup
  },
  w:{
    self:'on',
    transform:function(v,cv){
      return Math.max(~~cv,3) + '%'
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/progress/style.less","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/progress/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/search/index.js":[function(require,module,exports){
require('./style.less')

var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')
var Trailer = require('../trailer')
var search = require('/Users/shawn/Work/directv-fl//src/components/shared/search')
var when = require('promise').all
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')

var NoResults = new Element({
  container:{
    'title.text':'No Results!',
    'subtitle.text':'Please try to refine your query'
  }
}).Class

var StartSearching = new Element({
  container:{
    'title.text':'Start Searching!',
    'subtitle.text':'Find your favorite movies, shows and channels'
  }
}).Class

module.exports = new Element({
  css: 'second-search',
  extend:{
    $search:function( val ){
  	  var _this = this
    	var results = this.results
    	var children = results.list.children
    	var query = search.parseSearch( val.val )
    	var content = app.content

    	this.searchbox.query.text = query

    	if(query !== false){
    		for (var i = children.length - 1; i >= 0; i--) {
    			search.filterCollection( children[i], query )
    		}
    	}

      if(query){
        function loaded(){
          var keys = this.keys
          var from = this.from
          return keys && keys.length > 2
        }

        function done(){
          for (var j = children.length - 1; j >= 0; j--) {
            var child = children[j]
            child.display = child.filter.length ? 'block' : 'none'
          }
          var topResult = search.topResult( children )
          if( topResult ){
            results.display = 'block'
            results.topresult.data = topResult
            if(_this.message){
              _this.message.remove()
            }
          }
          else{
            results.display = 'none'
            _this.set({
              message:new NoResults()
            })
          }
        }

        when([
          content.get('movies').is(loaded),
          content.get('actors').is(loaded),
          content.get('series').is(loaded),
          content.get('channels').is(loaded)
        ]).done(done)
      }else{
        results.display = 'none'
        this.set({
          message:new StartSearching()
        })
      }

    },
    $muted:function(val){
      this.results.topresult.body.container.trailer.$muted = val.val
    }
  },
  searchbox:{
  	searchicon:new Icon({
  		icon:'search'
  	}),
  	'query.text':''
  },
  results:{
  	list:new search.ResultList(),
  	topresult:{
  		model:{inherit:false},
  		header:{
  			text:{
  				// data:'title',
  				prepend:'Top Result'// - '
  			}
  		},
  		body:{
  			container:{
  				trailer:new Trailer(),
  				info:{
  					'title.text.data':'title',
            subtitle:new Subtitle()
  				}
  			},
  			'description.text.data':'description'
  		}
  	}
  }
}).Class

},{"../trailer":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/search/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl//src/components/shared/search":"/Users/shawn/Work/directv-fl/src/components/shared/search.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","promise":"/Users/shawn/Work/directv-fl/node_modules/promise/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/search/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/index.js":[function(require,module,exports){
require('./style.less')

var Switcher = require('vigour-js/app/ui/switcher')
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')

module.exports = app.cases.$isTablet 
? new Element({
    css:'second-statusbar branded',
    y:{
      translate:true,
      val:80,
      multiply:app.hideStatusbar
    },
    partner:{
      logo:{}
    },
    weather:{
      add:new Icon({icon:'weather'}),
      text:'Partially Clouded'
    },
    eta:{
      add:new Icon({icon:'airplane'}),
      text:'Time to Los Angeles: 6hr'
    },
    between:{},
    directv:{
      logo:{}
    }
  }).Class
: new Element({
    css:'second-statusbar',
    y:{
    	translate:true,
      val:80,
      multiply:app.hideStatusbar
    },
    directv:{
      logo:{}
    },
    sender:{
      icon:new Icon({icon:'phone'}),
      title:{text:'controlled by iPhone'}
    }
  }).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/statusbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var Video = require('vigour-js/browser/element/video')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var ASSETS = require('vigour-js/util/config').pointers.assets
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Mute = require('/Users/shawn/Work/directv-fl/src/components/shared/mute')

module.exports = new Element({
  css: 'second-trailer',
  'extend.$muted':function(){},
  $muted:true,
  video:new Video({
    player: require('vigour-js/browser/element/video/html5'),
    src:{
      data: 'trailer',
      prepend: ASSETS
    },
    duration: true,
    volume:{
      parent:'$muted',
      multiply:-1,
      add:1
    },
    loop: true,
    autoplay: true
  }),
  logo:new Img({
    'background.data':'img.logo'
  }),
  muted:new Mute({
    icon:{
      parent:'$muted'
    }
  })
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mute":"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js","vigour-js/browser/element/video/html5":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/html5.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/trailer/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/vod/index.js":[function(require,module,exports){
require('./style.less')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Element = require('vigour-js/app/ui/element')
var Switcher = require('vigour-js/app/ui/switcher')
var Item = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Content = require('../content')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Bio = require('../bio')

var Overview = new Content({
  css:'overview',
  container:{
    top: {
      'left.poster':new Item.Poster({
        'img.background':{
          add:{
            data:'show.img.poster'
          }
        },
      }),
      right: {
        title:new Title(),
        subtitle:new Subtitle()
      }
    },
    'description.text.data': 'description',
    starring: {
      display:{
        val:'block',
        when:{data:'actors'},
        or:'none'
      },
      'header.text': 'Starring',
      'actors.collection': {
        data: 'actors',
        element: Item.Poster
      }
    }
  }
}).Class

var Preview = new Content({
  css:'preview',
  'cover.bg.background':{
    data: 'img.cover.1',
    add:{
      data:'show.img.cover.2'
    }
  },
  'container.info': {
    title:new Title.Show(),
    subtitle:new Subtitle(),
    'description.text.data': 'description'
  }
}).Class

module.exports = new Switcher({
  css: 'second-vod',
  onTransition:'fade',
  extend:{
    $active:function(val){
      if(this._swElem) this._swElem.$active = val.val
    },
    $complete: function(val) {
      var complete = val.val
      var data = this.data
      var isEpisode = data._contentType === 'episodes'

      var params = {
        data: data.from,
        $active:this.$active
      }

      if (complete === true) {
        this.transition = {
          // element: isEpisode ? EpisodeOverview : Overview,
          element: Overview,
          $params: params
        }
      } else if (complete === false) {
        this.transition = {
          // element: isEpisode ? EpisodePreview : Preview,
          element: Preview,
          $params: params
        }
      }
    },
    $popup:function(val){
      var data = val.val
      if(data && typeof data !== 'string'){
        this.transition = {
          element:Bio,
          $params:{
            data:data.from
          }
        }
      }else{
        if(this.$complete) this.$complete.update()
      }
    },
    data:function(val){
      if(this._swElem && !this._swElem.switcher){
        this._swElem.data = val.val
      }
    }
  },
  $active:true
}).Class

},{"../bio":"/Users/shawn/Work/directv-fl/src/components/inactive/bio/index.js","../content":"/Users/shawn/Work/directv-fl/src/components/inactive/content/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/inactive/vod/style.less","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js"}],"/Users/shawn/Work/directv-fl/src/components/inactive/vod/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/inactive/widget/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')
var Video = require('vigour-js/browser/element/video')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Mpaa = require('/Users/shawn/Work/directv-fl/src/components/shared/mpaa')
var Rating = require('/Users/shawn/Work/directv-fl/src/components/shared/rating')
var Score = require('/Users/shawn/Work/directv-fl/src/components/shared/statistics').Score

exports.Twitter = new Element({
  css: 'twitter-widget',
  'header.text': 'Tweets',
  'tweets.collection': {
    data: 'guide.0.tweets',
    element: new Element({
      css: 'tweet',
      bird: new Icon({icon:'twitter'}),
      'author.text.data': 'author',
      'body.text.data': 'body'
    })
  }
}).Class

exports.Guide = new Element({
  css: 'guide-widget',
  'header.text': 'Guide',
  'programs.collection': {
    data: 'guide',
    element: new Element({
      css: 'program',
      'title.text.data': 'title',
      progress: {
        'start.text.data': 'start-time',
        'dash.text': ' - ',
        'bar.seek': {},
        'end.text.data': 'end-time'
      }
    })
  }
}).Class

var Poller = new Element({
  css: 'poller',
  'left.logo': new Img(),
  right: {
    'title.text.data': 'title',
    bar: {
      'extend.$borderTopColor': function(val) {
        if(val.val) this.node.style.borderTopColor = val.val
      },
      '$borderTopColor.data': 'color',
      w: {
        data: 'votes',
        divide: 10000,
        multiply: 100,
        add: '%'
      }
    },
    'subtitle.text': {
      data: 'votes',
      add: ' VOTES'
    }
  },
  setSetting: {
    name: 'bindvotes',
    parent: function(parent) {
      this.right.bar.w = {
        divide: parent.on
      }
    }
  }
}).Class

var Poll = new Element({
  on: { // store the totalvotes
    data: 'poll.0.votes',
    'add.data': 'poll.1.votes'
  },
  append: [
    Poller, {
      'model.field': 'poll.0'
    }, {
      'model.field': 'poll.1'
    }
  ]
}).Class

exports.Stats = new Element({
  css: 'stats-widget',
  'header.text': 'Statistics',
  container: {
    model:{field:'guide.0'},
    score: new Score(),
    info: {
      'title.text': 'Who will win?',
      'subtitle.text': 'Use phone to vote'
    },
    poll: new Poll()
  }
}).Class

exports.About = new Element({
  css: 'about-widget',
  'header.text': 'About the Show',
  container: {
    img:new Img({
      'background.data':'img.thumb'
    }),
    info:{
      'model.field':'guide.0',
      titles:{
        'title.text.data': 'title',
        'subtitle.text.data': 'subtitle'
      },
      stickers:{
        mpaa:new Mpaa(),
        rating: new Rating()
      }
    },
    'description.text.data':'guide.0.description'
  }
}).Class
},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mpaa":"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js","/Users/shawn/Work/directv-fl/src/components/shared/rating":"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js","/Users/shawn/Work/directv-fl/src/components/shared/statistics":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/video":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/actors/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var app = require('vigour-js/app')

module.exports = new Element({
  css:'ui-actors',
  display:{
    data:'actors',
    transform:function(v,cv){
      return cv ? 'block' : 'none'
    }
  },
  header: { text: 'Starring' },
  body: {
    scrollbar: 'x',
    collection: {
      data: 'actors',
      element: new Poster({
        'events.click':function() {
          app.popup.$userOrigin = this.data.from
        }
      })
    }
  }
}).Class


},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/actors/style.less","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/actors/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/bar/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

module.exports = exports = new Element({
  css:'ui-bar'
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/bar/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/bar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/description/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

var Description = new Element({
	css:'ui-description',
  header: { text: 'Description' },
  body: {
    text: { data: 'description' }
  }
}).Class

module.exports = Description

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/description/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/description/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
  , cases = require('vigour-js/browser/cases')
  , icon = new Element({ css:'ui-icon' })
  , map =
    { discover:'\ue600'
    , shows:'\ue601'
    , tv:'\ue602'
    , settings:'\ue603'
    , cast:'\ue604'
    , desktop:'\ue602'
    , play:'\ue605'
    , pause:'\ue606'
    , fullscreen:'\ue607'
    , exitfullscreenAlt:'\ue608'
    , pullback:'\ue609'
    , swipeup:'\ue60a'
    , allChannels:'\ue60b'
    , disconnected:'\ue60c'
    , menu:'\ue60d'
    , IFE:'\ue60e'
    , back:'\ue60f'
    , closeSmall:'\ue610'
    , close:'\ue611'
    , wrong:'\ue612'
    , correct:'\ue613'
    , facebook:'\ue614'
    , twitter:'\ue615'
    , phone:'\ue616'
    , tablet:'\ue617'
    , volume:'\ue618'
    , muted:'\ue619'
    , pauseAlt:'\ue61a'
    , playAlt:'\ue61b'
    , rewind:'\ue61c'
    , fastforward:'\ue61d'
    , profile:'\ue61e'
    , dropdown:'\ue61f'
    , rightNav:'\ue620'
    , leftNav:'\ue621'
    , right:'\ue622'
    , search:'\ue623'
    , noResult:'\ue624'
    , searchMenu:'\ue625'
    , epg:'\ue626'
    , upNav:'\ue627'
    , downNav:'\ue628'
    , menuRight:'\ue629'
    , airplane:'\ue62a'
    , mutedAlt:'\ue62b'
    , locked:'\ue62c'
    , weather:'\ue62d'
    , empty:' '
    }

icon.extend({
  icon: function(val) {
    var name = map[val.val]
    if(name) {
      var v = '<span>' + name + '</span>',
        value = this.node.innerHTML,
        divindex = value.indexOf('<div')
      if(~divindex) v += value.slice(divindex)
      this.html = v;
    } else {
      console.error('icon error: ', val.val, ' is not defined')
    }
  }
})

module.exports = exports = icon.Class
exports.map = map

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/icon/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/icon/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')
var ASSETS = require('vigour-js/util/config').pointers.assets

module.exports = new Element({
  opacity: 0,
  background: {
    data:'img',
    prepend:ASSETS,
    load: function(t) {
      if(this.$wait && this.$wait.val){
        this.$wait.once(false,function(){
          this.opacity = false
        })
      }else{
        this.opacity = false
      }
      this._loaded = true
      t._loaded = true
    }
  },
  'extend.$wait':function(){}
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/channel.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')

module.exports = new List({
  collection: {
    data: 'items',
    element:Item.Channel
  }
}).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/dots.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var _focused = require('/Users/shawn/Work/directv-fl//src/components/util').focused

module.exports = new Element({
  css:'list-dots',
  container:{
    collection:{
      data:'spotlight.items',
      element:new Element()
    },
    'extend.$focus': function( val ) {
      // alert(typeof val.val === 'string')
      var child = typeof val.val === 'string'
        ? this[val.val]
        : this.children[ val.val || 0 ]
      _focused( this, child )
    },
    model:{ complete:function(){
      if( this.children[0] ){
        if(this.$focus) this.$focus.update()
        this.model = { complete:null }
      }
    }}
  }
}).Class
},{"/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js":[function(require,module,exports){
require( './style.less' )

var cases = require( 'vigour-js/browser/cases' )
var Element = require( 'vigour-js/app/ui/element' )
var util = require('/Users/shawn/Work/directv-fl//src/components/util')
var _focused = util.focused
var _preventAnimation = util.preventAnimation

var Base = new Element( {
  css: 'base-list',
  model: function() {

    if ( this.children[ 0 ] ) {
      if( !this.$focus ) {
        console.error('this list needs a $focus value!')
        // this.$focus = 0
      }
      _updateX(this)
      this.$focus.update()
      this.model = false
    }
  },
  setSetting: {
    name: 'updateX',
    parent: function() {
      _updateX(this)
    }
  },
  'events.click':function(){
    var parent = this.parent
    if(parent.parent.$focus) parent.parent.$focus.from = parent._name
    // console.error('this!',this.parent.parent)
  }
} ).Class

var List = new Base( {
  'extend.$focus': function( val ) {
    var _this = this
    var n = val.val || 0
    var parent = this.parent
    
    _focused( this, this.children[ n ] )
    _bounce( this )

    if( !cases.$isPhone && parent ){
      
      var node = this.node
      var parentTop = parent.node.getBoundingClientRect().top
      if(_this.rafId) window.cancelAnimationFrame(_this.rafId)
      function check(){
        var top = node.getBoundingClientRect().top
        if(!top || top === parentTop) {
          _this.x = {
            multiply: -n
          }
          _this.rafId = null
        }else{
          _this.rafId = window.requestAnimationFrame(check)
        }
      }
      check()

    }else{
      this.x = {
        multiply: -n
      }
    }
  },
  x: {
    translate: true,
    val:0,
    multiply: 0,
    defer: _defer
  },
  y:{
    translate:true,
    val:0
  },
  $isPhone: {
    x: {
      animation: {
        time: 24,
        easing: 'outCubic'
      }
    },
    'events.grab': {
      x: true,
      pass: _pass,
      move: _highlight,
      up: _position
    }
  }
} ).Class

module.exports = exports = cases.$isPhone ? new Base( {
  // model:function(){
  //   if ( this.children[ 0 ] ) {
  //     var name = this.parent._name
  //     var scrollLeft = exports[name] && exports[name].scrollLeft
  //     if(scrollLeft){
  //       exports[name].ignoreScroll = true
  //       this.node.scrollLeft = scrollLeft
  //       exports[name].ignoreScroll = false
  //     }else{
  //       if( !this.$focus ) {
  //         console.error('this list needs a $focus value!')
  //         // this.$focus = 0

  //       }
  //       _updateX(this)
  //       this.$focus.update()
  //     }
  //     this.model = false
  //   }
  // },
  'extend.$focus': function( val ) {
    var children = this.children
    _focused( this, children[ val.val || 0 ] )
    if ( !this.node.scrollLeft && val.val ) {
      this.node.scrollLeft = val.val * _step( this, children )
    }
  },
  scrollbar: 'x',
  'events.scroll': function( e ) {
    // var name = this.parent._name
    // if(!exports[name]) exports[name] = {}
    // else if(exports[name].ignoreScroll) return

    if(!this._checked){ //block the first
      this._checked = true
      return
    }

    var _this = this
    var node = this.node
    var scrollLeft = node.scrollLeft
    var fraction = scrollLeft / ( node.scrollWidth - node.offsetWidth )
    var index = Math.round( fraction * ( _length( this ) - 1 ) )
    // exports[name].scrollLeft = scrollLeft
    _this.$focus.from = index
  }
} ).Class : List

exports.Carousel = List
exports.Spotlight = require( './spotlight' )
exports.Channel = require( './channel' )
exports.Poster = require( './poster' )
exports.Watching = require( './watching' )
exports.Dots = require( './dots' )
exports.Item = require( './item' )

var treshold = 60
var flick = 10

function _bounce( list ) {
  if ( list.x._e ){
    list.x = {
      _esub: list.x._e._val
    }
    list.x.update()
  }
}

function _highlight( e, d){
  var length = _length( this )
  var step = _step( this )
  var oldpos = this._start
  var newpos = oldpos
  if ( d.x < -treshold ) {
    newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
  } else if ( d.x > treshold ) {
    newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
  }
  if(-newpos !== this.$focus.val) _set( this, newpos )
}

function _pass( e, d ) {
  if(Math.abs( d.x ) > Math.abs( d.y )){
    this._start = -this.$focus.val || 0
    return true
  }
}

function _position( e, d, ld ) { // unify with switcher
  var children = this.children
  var length = _length( this )
  var oldpos = this._start || 0
  var newpos
  var step = _step( this, children )

  if ( Math.abs( ld.x ) > flick ) {
    if ( ld.x < 0 && d.x < treshold ) {
      newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
    } else if ( ld.x > 0 && d.x > -treshold ) {
      newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
    }
  } else {
    if ( d.x < -treshold ) {
      newpos = Math.max( oldpos - Math.ceil( ( -d.x ) / step ), -length + 1 )
    } else if ( d.x > treshold ) {
      newpos = Math.min( oldpos + Math.ceil( d.x / step ), 0 )
    }
  }

  if ( newpos !== void 0 && -newpos !== this.$focus.val ) _set( this, newpos )
  
  _bounce( this )
}

function _step( list, children, corrected ) { // this can be cleaner
  var node

  if ( !children ) children = list.children
  if ( children[ 0 ] ) {
    if ( !list._step ) {
      node = list.node
      list._step = node.scrollWidth / _length( list ) // 
    }
    if ( corrected ) {
      node = list.node
      return ( node.scrollWidth - node.offsetWidth ) / ( _length( list ) - 1 )
    }
    return list._step
  }
}

function _length( _this ){
  return _this.children.length //_this._length || ( _this._length = _this.children.length )
}

function _defer( update, args ) {
  var list = this._caller
  var step = _step( list, null, true )
  if ( step ) {
    if(!this._val) this.val = step
    this._flag = null
  }
  update()
}

function _updateX( _this ){
  if( _this.x ){
    _preventAnimation(_this,function(){
      _this.x._p = true
      _this.x.update()
      _this.x._p = null
    })
  }
}

function _set( _this, newpos ){
  var field = _this.$focus._flag && _this.$focus._flag.data[2]
  var data = _this.data
  if( field && data ){
    data.from.set(field,-newpos)
  }else _this.$focus.from = -newpos
}
},{"./channel":"/Users/shawn/Work/directv-fl/src/components/shared/list/channel.js","./dots":"/Users/shawn/Work/directv-fl/src/components/shared/list/dots.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","./poster":"/Users/shawn/Work/directv-fl/src/components/shared/list/poster.js","./spotlight":"/Users/shawn/Work/directv-fl/src/components/shared/list/spotlight.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/list/style.less","./watching":"/Users/shawn/Work/directv-fl/src/components/shared/list/watching.js","/Users/shawn/Work/directv-fl//src/components/util":"/Users/shawn/Work/directv-fl/src/components/util/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js":[function(require,module,exports){
var app = require('vigour-js/app')
var Element = require('vigour-js/app/ui/element')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Title = require('/Users/shawn/Work/directv-fl/src/components/shared/title')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var blocked = 'blocked'

module.exports = exports = new Element({
  img: new Img(),
  'events.click': function() {
    var focus = this.parent.$focus
    if (focus) focus.from = this.$index
    app.user.navigation.content.$userOrigin = this.data.from
  },
  extend: [{
      name: '$index',
      type: false,
      get: function() {
        if (this._index === void 0) {
          var siblings = this.parent.children
          for (var i = siblings.length - 1; i >= 0; i--) {
            siblings[i]._index = i
          }
        }
        return this._index
      }
    }, {
      $blocked: _blocked
    }],
  '$blocked.data':blocked
}).Class

exports.Info = new exports({
  css: 'info-item',
  'img.background.data': 'img.thumb',
  info: {
    title: new Title.Show(),
    subtitle: new Subtitle()
  }
}).Class

exports.Poster = new exports({
  css: 'poster-item',
  'img.background.data': 'img.poster',
}).Class

exports.Channel = new exports.Info({
  'logo': new Img({
    'background.data': 'img.logo'
  }),
  'info.title.text.data': 'guide.0.title'
}).Class

exports.Carousel = new Img({
  css: 'spotlight-item',
  'extend.$blocked': _blocked,
  'events.click': function() {
    app.user.navigation.content.$userOrigin = this.data.from
  },
  background: {
    data: 'img.spotlight'
  },
  '$blocked.data':blocked
}).Class

function _blocked(val){
  if(val.val){
    this.addEvent('click',function(){
      // new Audio('http://www.noiseaddicts.com/samples_1w72b820/3739.mp3').play()
      alert('This item is not available')
    },blocked)
    this.css = { addClass:blocked }
    this.set({
      lock:new Icon({icon:'locked'})
    })
  }else{
    if(this.lock){
      this.removeEvent(false, blocked)
      this.css = { removeClass:blocked }
      this.lock.remove()
    }
  }
}

},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","/Users/shawn/Work/directv-fl/src/components/shared/title":"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/poster.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Img = require('/Users/shawn/Work/directv-fl//src/components/shared/img')
var app = require('vigour-js/app')
var Item = require('./item')

List.Poster = module.exports = exports = new List({
  collection: {
    data: 'items',
    element:new Item.Poster()
  }
}).Class

// exports.element = element
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl//src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/spotlight.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')
var Img = require('/Users/shawn/Work/directv-fl//src/components/shared/img')
var app = require('vigour-js/app')

module.exports = new List.Carousel( {
  collection: {
    data: 'items',
    element:Item.Carousel
  }
} ).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","/Users/shawn/Work/directv-fl//src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/list/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/list/watching.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var List = require('./')
var Item = require('./item')
var app = require('vigour-js/app')

module.exports = new List({
  collection: {
    data: 'items',
    element:new Item.Info({
      bar:{
        w:{
          data:'time',
          multiply:100,
          abs:true,
          add:'%'
        }
      }
    })
  }
}).Class
},{"./":"/Users/shawn/Work/directv-fl/src/components/shared/list/index.js","./item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/loader/index.js":[function(require,module,exports){
require('./style.less')

var Sprite = require('vigour-js/app/ui/sprite')
  , Element = require('vigour-js/app/ui/element')
  , cases = require('vigour-js/browser/cases')

module.exports = new Sprite(
{ css:'ui-loader'
, w:30
, h:30
, params:{ cols:1, rows:26 } // once:true }
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/loader/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/sprite":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/sprite/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/loader/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/mpaa/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  background:{
    data:'mpaa',
    add:{data:'show.mpaa'},
    transform:function(v, mpaa){
      if( mpaa ) return 'assets/img/app/mpaa_' + mpaa.toLowerCase() + '.png'
    }
  }
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js":[function(require,module,exports){
require('./style.less')

var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
module.exports = new Icon({
  css:'ui-icon shared-mute',
  icon:{
    transform:function(v,cv){
      return cv ? 'mutedAlt' : 'volume'
    }
  }
}).Class
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/mute/style.less","/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/mute/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/poll/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var config = require('vigour-js/util/config')
var Bar = require('/Users/shawn/Work/directv-fl/src/components/shared/seekbar').Bar

var VoteRow = new Element({
  css: 'ui-voterow',
  left: {
    logo: { 
      background: { 
        data: 'img',
        prepend: config.pointers.assets
      },
      'events.click': function(){
        this.data.votes.val += 1
      }
    }
  },
  right: {
    count: {
      model:function(data){
        if(data._parent){
          this.model = false
          this.votefiller.data = data._parent
        }
      },
      team: { text: { data: 'title' } },
      votes: { text: { data: 'votes' ,add: ' VOTES' } },
      votefiller: new Bar({
        seek: {
          w:{
            data:true,
            transform: function( c, cv ){
              var count = this.parent.parent
              var myvotes = count.data && count.data.votes && count.data.votes.val
              if(myvotes) {
                var v1 = cv[0].votes.val
                var v2 = cv[1].votes.val
                var total = v1 + v2
                return ( myvotes / total ) * 100 + '%'
              }
            }
          },
          'extend.$backgroundColor': function( val ){
            var count = this.parent.parent
            var mycolor = count.data && count.data.color && count.data.color.val
            if(mycolor) {
            this.node.style.backgroundColor = mycolor
            }
          },
          '$backgroundColor.data': true
        }
      })
    }
  }
}).Class

var Poll = new Element({
  css: 'ui-poll',
  display:{
    val:'block',
    when:{data:'poll.0.title'},
    or:'none'
  },
  header: { text: { data: 'poll.title' } },
  first: new VoteRow({
    model: { field: 'poll.0' }
  }),
  second: new VoteRow({
    model: { field: 'poll.1' }
  })
}).Class

module.exports = Poll

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/poll/style.less","/Users/shawn/Work/directv-fl/src/components/shared/seekbar":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/poll/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/popup/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )
var app = require( 'vigour-js/app' )
var Icon = require('../../shared/icon')
var Switcher = require( 'vigour-js/app/ui/switcher' )
    .inject( require( 'vigour-js/app/ui/switcher/transitions' ) )

module.exports = exports = new Element({
  css:'popup',
  topbar:{
    left:new Icon({icon:'left'}),
    middle: { text:'popup' },
    right:new Icon({
      icon:'close',
      events: {
        click:function() {
          this.parent.parent.popup.$userOrigin = false
        }
      }
    })
  },
  w:app.w,
  h:app.h,
  y:
  { val:0, 
    animation:
    { time:app.h.val / 30
    , start:app.h
    , easing:'outCubic'
    , done:function(cv) {
        var t = this
        if(cv>=100) t.remove()
      }
    }
  },
  switcher:new Switcher({
    onTransition: {
      val:'fade',
      $hasTouch: 'slide'
    },
    backFallback: function() {
      console.error('wtf moet hier...backfallback')
    }
  }),
  extend:{
    popup:function(){}
  }
}).Class



},{"../../shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/app/ui/switcher/transitions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/rating/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  text:{data:'rating',add:{data:'show.rating'}}
}).Class
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var Poster = require('/Users/shawn/Work/directv-fl/src/components/shared/list/item').Poster
var app = require('vigour-js/app')

var Recommendations = new Element({
  css: 'ui-recommendations',
  display:{
    val:'block',
    when:{data:'recommendations'},
    or:'none'
  },
  header: { text: 'You\'ll love these' },
  body: {
    scrollbar: 'x',
    collection: {
      data: 'recommendations',
      element: Poster
    }
  }
}).Class

module.exports = Recommendations

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/style.less","/Users/shawn/Work/directv-fl/src/components/shared/list/item":"/Users/shawn/Work/directv-fl/src/components/shared/list/item.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/recommendations/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/search.js":[function(require,module,exports){
var app = require('vigour-js/app/')
var Element = require('vigour-js/app/ui/element')
var display = require('vigour-js/browser/element/properties/collection/display')
var Icon = require('/Users/shawn/Work/directv-fl/src/components/shared/icon')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')
var Subtitle = require('/Users/shawn/Work/directv-fl/src/components/shared/subtitle')
var Mute = require('/Users/shawn/Work/directv-fl/src/components/shared/mute')
var config = require('vigour-js/util/config')

var Result = exports.Result = app.cases.$isPhone 
? new Element({
    css:'search-result',
    body: {
      title: {
        text:{data:'title'},
      },
      arrowRight: new Icon({ icon:'right' })
    },
    'events.click':function(e) {
      app.user.navigation.content.$userOrigin = this.data
     }
  }).Class
: new Element({
    css:'search-result',
    'poster.container':new Img({
      'background.data':'img.poster'
    }),
    body:{
      'title.text.data':'title',
      subtitle:new Subtitle()
    }
  }).Class

var Results = exports.Results = new Element({
  css:'search-results',
  title: {
    text:'recent searches'
  },
  collection: {
    option:display,
    element:Result
  }
}).Class

var TopResult = exports.TopResult = new Element({
  title: {text:'top result'},
  css:'search-top-result',
  body: {
    poster:{
      img: {
        background: {
          val: config.pointers.img,
          add: { data:'img.poster' }
        },
        backdrop:{},
        mute:new Mute({
          display:{
            val:'none',
            $hasReceiver:'block'
          },
          icon:{
            val:app.user.trailerMuted
          },
          'events.click':function(e) {
            app.user.trailerMuted.$userOrigin = !app.user.trailerMuted.val
          }
        })
      }
    },
    textHolder:{
      title: { text:{ data:'title' } },
      info: { text:'112 minutes' },
      rating: {
        text: { data:'rating'}
      },
      description: { text: { data: 'description'} },
      'events.click':function(e) {
        app.user.navigation.content.$userOrigin = this.title.data
      }
    }
  },
  model: { inherit: false }
  // 'model.field':'movies.0' //deze moet dynamicly changen :(
}).Class

exports.ResultList = new Element({
  movies: new Results({
    title: {
      text:'movies'
    },
    collection: {
      element: new Result({
        model: {
          subscription: {
            title:true,
            actors:{
              $:{
                title:true
              }
            }
          }
        }
      }),
      data:'movies'
    }
  }),
  series: new Results({
    title: {
      text:'series'
    },
    collection: {
      data:'series'
    }
  }),
  channels: new Results({
    title: {
      text:'channels'
    },
    collection: {
      data:'channels'
    }
  }),
  actors: new Results({
    title: {
      text:'actors'
    },
    collection: {
      data:'actors',
      element: new Result({
        model: {
          subscription: {
            title:true,
            catalog:{
              $:{
                title:true
              }
            }
          }
        },
        'events.click':function(e) {
          //misc
          // alert('?')
          app.popup.$userOrigin = this.data.from
        }
      })
    }
  })
}).Class

exports.filterCollection = function( element, srch, filter) {
  filter = filter || {
    condition: {
      $or: [
      { title:{ $contains:srch } },
      { catalog:{ $: { title: { $contains:srch } } } },
      { actors:{ $: { title: { $contains:srch } } } }
      ]
    }
  }
  if( element.filter ) {
    element.filter.filter = filter
  } else {
    element.collection = { filter: filter }
  }    
}

exports.topResult = function( list ) {
  for(var i in list) {
    if( list[i].filter && list[i].filter[0] ) {
      return list[i].filter[0]
    }
  }
}

exports.parseSearch = function(val) {
  if(val && val.__t === 2) {
    return ''
  }
  val = val && val.trim() || ''
  var str = '';
  return val
}
},{"/Users/shawn/Work/directv-fl/src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","/Users/shawn/Work/directv-fl/src/components/shared/mute":"/Users/shawn/Work/directv-fl/src/components/shared/mute/index.js","/Users/shawn/Work/directv-fl/src/components/shared/subtitle":"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/element/properties/collection/display":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/properties/collection/display.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/index.js":[function(require,module,exports){
require('./style.less')

var Element = require('vigour-js/app/ui/element')
var app = require('vigour-js/app/') //  replace app stuff with parent
var ua = require('vigour-js/browser/ua')
var cases = require('vigour-js/browser/cases')
var videoUtil = require('vigour-js/browser/element/video/util')
var Icon = require('../icon')
var _limitUpdates = ua.platform === 'ios' || ua.platform === 'android'

var Bar = new Element({
  css:'ui-seekbar',
  bg:{},
  seek:{}
}).Class

var seekbar = new Bar({ 
  'seek.w':{ 
    data:'time',
    transform:function(v,cv){
      return Math.abs(cv) * 100 + '%'
    }
  },
  bg: {
    loaderbar: {
      // append:[Element,{},{},{},{},{},{},{},{}]
    }
  },
  events:
  { down: function(e) { 
      e.tempPrevent = true
      setTime.call(this, e)
    },
    drag: setTime,
    up:cases.touch
    ? function(e){
        var overlayOpacity = this.parent.parent.parent.opacity
        if(!this._skipUp) setTime.call(this, e)
        else this._skipUp = null
      }
    : setTime
  }
})

module.exports = exports = seekbar.Class

exports.Bar = Bar

function setTime(e) {

  // console.error('xxxx')

  var rect = this.node.getBoundingClientRect()
    , x
    , nr

  if(this._left){
    x = rect.top
    nr = (e.y-x)/rect.height
  }else if(this._right){
    x = rect.top
    nr = (rect.height-(e.y-x))/rect.height
  }else{
    x = rect.left
    nr = (e.x-x)/(rect.right-x)
  }

  var val = nr > 1 ? 1 : nr < 0 ? 0 : nr
  if( val !== this._prevVal )
  {
    this.seek.data.from.set('time',val)
    this._prevVal = val
  }
}
},{"../icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/style.less","vigour-js/app/":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/element/video/util":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/element/video/util.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/seekbar/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/statistics/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var config = require('vigour-js/util/config')
var Img = require('/Users/shawn/Work/directv-fl/src/components/shared/img')

var Score = new Element({
  css:'ui-score',
  top: {
    info: {
      'title.text.data': 'statistics.title',
      'subtitle.text.data': 'statistics.date'
    },
    teams: {
      left: new Img({
        'background.data': 'statistics.left.img'
      }),
      right:new Img({
        'background.data': 'statistics.right.img'
      })
    }
  },
  body: {
    'left.text.data': 'statistics.left.points',
    middleleft: {
      'title.text.data': 'statistics.left.acronym',
      'subtitle.text.data': 'statistics.left.innings'
    },
    middleright: {
      'title.text.data': 'statistics.right.acronym',
      'subtitle.text.data': 'statistics.right.innings'
    },
    'right.text.data': 'statistics.right.points',
  }
}).Class

module.exports = exports = new Element({
  css: 'ui-statistics',
  display:{
    data:'statistics.title',
    transform:function(v,cv){
      return cv ? 'block' : 'none'
    }
  },
  'header.text': 'Statistics',
  body:new Score()
}).Class

exports.Score = Score
},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/statistics/style.less","/Users/shawn/Work/directv-fl/src/components/shared/img":"/Users/shawn/Work/directv-fl/src/components/shared/img/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/statistics/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/subtitle/index.js":[function(require,module,exports){
var Element = require('vigour-js/app/ui/element')

module.exports = new Element({
  text: {
    data: 'subtitle',
    add: [
      '.', {
        data: 'year',
        add: [' - ', {
          data: 'duration',
          divide: 60,
          floor: true,
          add: ' Minutes'
        }]
      },
      '.', {
        data: 'guide.0.start-time',
        add: [' - ', {
          data: 'guide.0.end-time'
        }]
      }
    ],
    transform: function(v, cv) {
      var arr = cv.split('.')
      var l = arr.length - 1
      var str = arr[l]
      while (str[1] === '-' || (str[5] === '-' && str[7] === ' ')) { //dirty!
        str = arr[--l]
      }
      if (str) return str

      var from = this.data && this.data.from
      if (from) {
        var episode = (from._name | 0) + 1
        var season = (from._parent._parent._name | 0) + 1
        return 'Season ' + season + ' - ' + 'Episode ' + episode
      }
    }
  }
}).Class

},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/title/index.js":[function(require,module,exports){
var Element = require( 'vigour-js/app/ui/element' )

module.exports = exports = new Element({
  'text.default.data':'title'
}).Class

exports.Show = new exports({
  'text.data':'show.title'
}).Class

// exports.Program = new exports({
//   'text.data':'guide.0.title'
// }).Class
// exports.Topbar = new exports.Show({

// })
},{"vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/trivia/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )
var ASSETS = require('vigour-js/util/config').pointers.assets

module.exports = new Element({
  css: 'ui-trivia',
  'header.text': 'Trivia',
  display:{
    data:'trivia.title',
    transform:function(v,cv){
      return cv ? 'block' : 'none'
    }
  },
  body: {
    background: { 
      data: 'img',
      prepend: ASSETS
    },
    'title.text.data': 'trivia.title',
    'subtitle.text.data': 'trivia.subtitle',
    'description.text.data': 'trivia.description'
  }
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/trivia/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/util/config":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/util/config/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/trivia/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/tweets/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

var Icon = require('/Users/shawn/Work/directv-fl//src/components/shared/icon')

var app = require('vigour-js/app')

var tweet = new Element({
  css: 'tweet',
  icon: new Icon({icon:'twitter'}),
  from: { text: { val: '@', add: { data: 'author' } } },
  msg: { text: { data: 'body' } },
  retweet: { text: 'RETWEET' }
})

var Tweets = new Element({
    css: 'ui-tweets',
    display:{
      data:'tweets',
      transform:function(v,cv){
        return cv ? 'block' : 'none'
      }
    },
    header: { text: 'Tweets' },
    holdert: { //weird name.... holder is a class
      scrollbar: 'x',
      body: {
        collection: {
          data: 'tweets',
          element: tweet
        }
      }
    }
}).Class

module.exports = Tweets

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/tweets/style.less","/Users/shawn/Work/directv-fl//src/components/shared/icon":"/Users/shawn/Work/directv-fl/src/components/shared/icon/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/tweets/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/index.js":[function(require,module,exports){
require('./style.less')

var Element = require( 'vigour-js/app/ui/element' )

module.exports = new Element({
  css:'ui-wallpaper'
}).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/style.less","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js"}],"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/switcher/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */

require( './style.less' )

var Element = require( 'vigour-js/app/ui/element' )
var Switcher = require( 'vigour-js/app/ui/switcher' )
    .inject( require( 'vigour-js/app/ui/switcher/transitions' ) )
var app = require( 'vigour-js/app' )
var cases = app.cases
var Wallpaper = require('/Users/shawn/Work/directv-fl/src/components/shared/wallpaper')

module.exports = exports = new Switcher( {
  css:'app-switcher',
  on: {
    state: { //state lekker extended
      defer: function( update ) {
        var on = this._parent
        var switcher = on._caller
        var state = this.from.val
        
        if( state==='second' ) {

          switcher.transition = {
            element:require('/Users/shawn/Work/directv-fl//src/components/inactive'),
            $params:{ 
              $highlight:on.highlight._val,
              $preview:on.preview._val,
              $media:app.user.receiver.media,
              $page:on.navigation._val.page,
              $content:on.navigation._val.content,
              navigation:{
                data:app.content.get('discover'),
                $focus:on.focus._val,
                container:{
                  progress:{
                    data:on.preview._val
                  }
                }
                // $progress:app.progress
              }
            }
          }

        } else if( state==='first' ) {

          switcher.transition = {
            element:require('/Users/shawn/Work/directv-fl//src/components/active'),
            $params:{
              menu: {
                navigation: app.user.navigation
              },
              on:{
                focus:on.focus._val,
                popup:on.popup._val,
                secondPopup:on.secondPopup._val
              },
              holder:{
                topbar:{
                  $current: app.current,
                },
                switcher:{
                  navigation: app.user.navigation
                },
                miniplayer:{
                  media:app.user.receiver.media,
                  playing:app.user.receiver.playing
                }
              }
            }
          }

        } else if( state === 'inactive'){
        
          switcher.transition = {
            element:Wallpaper,
            $params:{}
          }

        }

        update()
      }
    }
  },
  onTransition:'fade'
} ).Class

},{"./style.less":"/Users/shawn/Work/directv-fl/src/components/switcher/style.less","/Users/shawn/Work/directv-fl//src/components/active":"/Users/shawn/Work/directv-fl/src/components/active/index.js","/Users/shawn/Work/directv-fl//src/components/inactive":"/Users/shawn/Work/directv-fl/src/components/inactive/index.js","/Users/shawn/Work/directv-fl/src/components/shared/wallpaper":"/Users/shawn/Work/directv-fl/src/components/shared/wallpaper/index.js","vigour-js/app":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/index.js","vigour-js/app/ui/element":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/element/index.js","vigour-js/app/ui/switcher":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/index.js","vigour-js/app/ui/switcher/transitions":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/app/ui/switcher/transitions.js"}],"/Users/shawn/Work/directv-fl/src/components/switcher/style.less":[function(require,module,exports){
arguments[4]["/Users/shawn/Work/directv-fl/node_modules/gaston/node_modules/browserify/lib/_empty.js"][0].apply(exports,arguments)
},{}],"/Users/shawn/Work/directv-fl/src/components/util/index.js":[function(require,module,exports){
/*!
 * @license Copyright (c) 2012-2015, Vigour. All rights reserved.
 * @author: Youri Daamen, youri@vigour.io
 */
exports.focused = function( holder, focused, method ) {
  if ( focused ) {
    
    var previous = holder._focused

    if ( previous !== focused ) {

      if ( previous ) {
        previous.css = {
          removeClass: 'focused'
        }
        previous.$focused = false
      }

      focused.css = {
        addClass: 'focused'
      }

      focused.$focused = true

      if ( method ) method( focused, previous )

      holder._focused = focused
    }

  }
}

exports.preventAnimation = function( _this, method, done ){
  _this._blocked = true
  _this.css = {addClass:'dontAnimate'}
  window.requestAnimationFrame(function(){
    method()
    window.requestAnimationFrame(function(){
      _this.css = {removeClass:'dontAnimate'}
      _this._blocked = null
      if( done ) done()
    })
  })
}
},{}],"/Users/shawn/Work/directv-fl/src/main/clienthack.js":[function(require,module,exports){
var app = require('/Users/shawn/Work/directv-fl/src/app')
var url = require('vigour-js/browser/network/url')
var ua = require('vigour-js/browser/ua')
var device = url.params.device && url.params.device.val || ua.device

var clientinfo = {
  phone: {
    title: 'Kevin\'s iPhone',
    info: 'iPhone 6'
  },
  ipad: {
    title: 'Kevin\'s iPad',
    info: 'iPad 2',
    device: 'tablet'
  },
  tv: {
    title: 'Sharp',
    info: '52" LED TV',
    device: 'tv'
  },
  tablet: {
    title: 'United Airlines',
    info: 'In Flight Entertainment',
    device: 'IFE'
  },
  def: {
    title: ua.platform+' '+device,
    info: ua.platform+' '+device,
    device:device
  }
}

app.cloud.client.val = clientinfo[device] || clientinfo.def
},{"/Users/shawn/Work/directv-fl/src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","vigour-js/browser/network/url":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/network/url.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"/Users/shawn/Work/directv-fl/src/main/index.js":[function(require,module,exports){
require('./uahack')

var app = require('/Users/shawn/Work/directv-fl//src/app')
var Switcher = require('/Users/shawn/Work/directv-fl//src/components/switcher')
var user = app.user

if(app.cases.$isNative){
  var statusBar = require('vigour-native-statusBar')
  statusBar.set({
    style:'light',
    visibility:'overlay'
  }, function (err) {
    if (err) alert("error setting statusBar: " +err)
  })
}

// switcher between first/second/player

// app.ready.once(true,function(){

require('./clienthack')

// app.ready.once(true,function(){

app.set({
  switcher: new Switcher( {
    on: {
      navigation: user.navigation,
      play: app.playing,
      receiver: user.receiver,
      usage: user.usage,
      content: app.content,
      search: user.search,
      focus: user.focus_row,
      preview: app.preview,
      highlight: app.highlight,
      popup:app.popup,
      secondPopup:app.secondPopup,
      //nav word different
      // watched: user.watched.from,
      state: app.state,
      overlay: app.overlay,
      loading: app.loading,
      activeClient: user.activeClient,
      volume: app.volume
    }
  })
})


// TODO: rename app.initialized?

// app.popup.val = 'actor'
// app.menu.val = true
// })

app.initialised.val = true


// app.ready.is(true,function(){
//   app.secondPopup.val = 'volume'
// },true)
},{"./clienthack":"/Users/shawn/Work/directv-fl/src/main/clienthack.js","./uahack":"/Users/shawn/Work/directv-fl/src/main/uahack.js","/Users/shawn/Work/directv-fl//src/app":"/Users/shawn/Work/directv-fl/src/app/index.js","/Users/shawn/Work/directv-fl//src/components/switcher":"/Users/shawn/Work/directv-fl/src/components/switcher/index.js","vigour-native-statusBar":"/Users/shawn/Work/directv-fl/node_modules/vigour-native-statusBar/index.js"}],"/Users/shawn/Work/directv-fl/src/main/uahack.js":[function(require,module,exports){
var ua = require('vigour-js/browser/ua')
var cases = require('vigour-js/browser/cases')

console.log('---------------- ua hacking that!', ua)


if(ua.device === 'desktop') {
  console.log('hack dat desktop')
  ua.device = 'tv'
  ua.platform = 'fancy'
  cases.$isDesktop = false
  console.log('lol set dat tv treus')
  cases.$isTv = true

  window.INACTIVE = true
} else if(ua.device === 'ipad') {
  window.INACTIVE = true

}

},{"vigour-js/browser/cases":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/cases/index.js","vigour-js/browser/ua":"/Users/shawn/Work/directv-fl/node_modules/vigour-js/browser/ua.js"}],"package.json":[function(require,module,exports){
module.exports={"name":"directv-fl","version":"2015/06/10 15:33:16 UTC (1.0.3)","description":"","main":"index.js","scripts":{"startGaston":"./node_modules/.bin/gaston dev","start":"npm run startGaston","test":"echo \"Error: no test specified\" && exit 1","symlink":"mkdir -p node_modules; ln -sf $(pwd) $(pwd)/node_modules","startHub":"./node_modules/vigour-hub/bin/hub -d -c directv","prestart":"npm run startHub &","build":"vNative build","release":"packer -r -c package.json,.package.json"},"repository":{"type":"git","url":"https://github.com/vigour-io/directv-fl.git","branch":"shawn-dev"},"author":"Vigour","bugs":{"url":"https://github.com/vigour-io/directv-fl/issues"},"homepage":"https://github.com/vigour-io/directv-fl","dependencies":{"through2":"*","lodash":"3.2.0","monotonic-timestamp":"0.0.9","promise":"^7.0.1","vigour-js":"git+ssh://git@github.com:vigour-io/vigour-js.git#directv"},"devDependencies":{"vigour-native":"git+ssh://git@github.com:vigour-io/vigour-native.git","vigour-native-statusBar":"git+ssh://git@github.com:vigour-io/vigour-native-statusBar.git","vigour-packer-server":"git+ssh://git@github.com:vigour-io/vigour-packer-server.git","vigour-hub":"git+ssh://git@github.com:vigour-io/vigour-hub.git#directv","gaston":"git+ssh://git@github.com:vigour-io/gaston.git"},"vigour":{"cloud":"http://directv2.dev.vigour.io:80","branches":{"youzi-dev":{"cloud":"http://localhost:10001","pointers":{"img":"http://localhost:8080/","assets":"http://localhost:8080/"}},"marcus-dev":{"cloud":"http://10.0.1.199:10001"},"shawn-dev":{"cloud":"http://directv2.dev.vigour.io:80"}},"development":{"button":false},"pointers":{"img":"http://devassets.vigour.io/","assets":"http://devassets.vigour.io/"},"packer":{"web":"index.html","assets":{"bundle.js":true,"bundle.css":true,"index.html":true,"assets":"*","fonts.css":true},"git":{"owner":"vigour-io","repo":"directv-fl"},"mail":{"fromAddress":"shawn@vigour.io","to":"shawn@vigour.io"},"slack":{},"server":{}},"native":{"platforms":{"ios":{"productName":"Direct TV - Future Land","organizationName":"Vigour","organizationIdentifier":"io.vigour.directv-fl","buildNumber":"1","appIndexPath":"index.html","appUrlIdentifier":"com.directv-fl.org","appUrlScheme":"directv-fl"}}}},"gaston":{"browserify-transforms":[{"path":"vigour-js/util/inform-transform","options":{"global":"false"}}],"require-paths":{"dtv":"src","shared":"src/components/shared","dtv-components":"src/components","dtv-active":"src/components/active","dtv-item":"src/components/active/content-item","dtv-channel":"src/components/active/content-item/channel","dtv-episode":"src/components/active/content-item/episode","dtv-movie":"src/components/active/content-item/movie"}},"sha":"1.0.3"}
},{}]},{},["/Users/shawn/Work/directv-fl/index.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsImNvbmZpZy5qcyIsImluZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZG9tYWluLWJyb3dzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2FzdG9uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dhc3Rvbi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL29zLWJyb3dzZXJpZnkvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9nYXN0b24vbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ2FzdG9uL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJub2RlX21vZHVsZXMvbW9ub3RvbmljLXRpbWVzdGFtcC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2NvcmUuanMiLCJub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZG9uZS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9lczYtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9maW5hbGx5LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL25vZGUtZXh0ZW5zaW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItYXNhcC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9taXNlL25vZGVfbW9kdWxlcy9hc2FwL2Jyb3dzZXItcmF3LmpzIiwibm9kZV9tb2R1bGVzL3Byb21pc2Uvbm9kZV9tb2R1bGVzL2FzYXAvcmF3LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvY2xvdWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC9jb250ZW50LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91aS9lbGVtZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdWkvc3ByaXRlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlci90cmFuc2l0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvaWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdXNlci9tb2NrZGF0YS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvbXVsdGlzY3JlZW4vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL25hdmlnYXRpb24uanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC91c2VyL29yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvc2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9hcHAvdXNlci90b2tlbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvdHlwZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYXBwL3VzZXIvdXNhZ2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2FwcC92YWx1ZXMuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jhc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jhc2Uvc2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL2Vhc2luZy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vZnJhbWUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9yYWYuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jYXNlcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9jYXNlcy9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvY3NzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2NvbGxlY3Rpb24vZGlzcGxheS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvY29sbGVjdGlvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvY29sbGVjdGlvbi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvcHJvY2Vzcy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3Byb3BlcnRpZXMvc2Nyb2xsYmFyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvc2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8vaHRtbDUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlby9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL2FkdmFuY2VkLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy9iYXNpYy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9ldmVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL29mZnNldC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2FqYXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9hdXRoZW50aWNhdGUuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9kYXRhLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvZGF0YWNsb3VkLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2Nsb3VkL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQvc29ja2V0LmlvLm1pbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2RhdGEvZWxlbWVudC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2RhdGEvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay91cmwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2Jyb3dzZXIvdWEuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL2RhdGEvYmFzZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvZGF0YS9jb25kaXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9kYXRhL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9kYXRhL3NlbGVjdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9jb2xvcnMvY29sb3JzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy1qc29ucC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3dlYnNvY2tldC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWluaGVyaXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZGVidWcvZGVidWcuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL2xpYi9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2FmdGVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYXJyYXlidWZmZXIuc2xpY2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2Jsb2IvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeS9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL3V0ZjgvdXRmOC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2hhcy1jb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvaGFzLWNvcnMvbm9kZV9tb2R1bGVzL2dsb2JhbC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZWpzb24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3Byb21pc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9wcm9taXNlL2xpYi9jb3JlLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvZG9uZS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3Byb21pc2UvbGliL2VzNi1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9saWIvbm9kZS1leHRlbnNpb25zLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvcHJvbWlzZS9ub2RlX21vZHVsZXMvYXNhcC9hc2FwLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvc29ja2V0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvYmFja28yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2hhcy1iaW5hcnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9vYmplY3QtY29tcG9uZW50L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2V1cmkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2lzLWJ1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2pzb24zL2xpYi9qc29uMy5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3RvLWFycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9vYmplY3QvYXJyYXkuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL29iamVjdC9jb21wb3VuZC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L2ZsYWdzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy9vYmplY3QvaGFzaHBhdGguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL29iamVjdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L2xpc3Rlbi5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvb2JqZWN0L3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvY29uZmlnL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL2NvbmZpZy91YS5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9kZWJ1Zy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9kZWJ1Zy9sb2cuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvZGVidWcvcGVyZm9ybWFuY2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL2hhc2guanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaWQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3V0aWwvaW5qZWN0LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL29iamVjdC5qcyIsIm5vZGVfbW9kdWxlcy92aWdvdXItanMvdXRpbC9wcm9jZXNzLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy91dGlsL3Byb3AuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2Jhc2UuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL2RhdGEuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9mbGFncy9wYXJlbnQuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3NlbGYuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3V0aWwuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9sZW5ndGguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLWpzL3ZhbHVlL29uLmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1qcy92YWx1ZS9vcGVyYXRvcnMuanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyL3BhY2thZ2UuanNvbiIsInNyYy9hcHAvaW5kZXguanMiLCJzcmMvYXBwL2luaXQuanMiLCJzcmMvYXBwL3BsYXliYWNrLmpzIiwic3JjL2FwcC91c2VyLmpzIiwic3JjL2FwcC92YWx1ZXMuanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvY2hhbm5lbC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9jb250ZW50L2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2Rpc2NvdmVyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2VwaXNvZGUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvbWVudS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9tb3ZpZS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wbGF5ZXIvZnVsbHNjcmVlbi5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wbGF5ZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvYWN0b3IvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvZGV2aWNlcy9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9wYWdlLmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3BvcHVwL3JlbW90ZS9jYXJvdXNlbC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9wb3B1cC9yZW1vdGUvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvcG9wdXAvdm9sdW1lL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3JlbW90ZS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2FjdGl2ZS9zZWFyY2gvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvc3dpdGNoZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9hY3RpdmUvdG9wYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvYWN0aXZlL3RvcGJhci9pbnB1dC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2Jpby9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2NoYW5uZWwvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9pbmFjdGl2ZS9jb250ZW50L2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvY292ZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9pbmFjdGl2ZS9kaXNjb3Zlci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvbmF2aWdhdGlvbi9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3BsYXllci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3Byb2dyZXNzL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvc2VhcmNoL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvc3RhdHVzYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvdHJhaWxlci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3ZvZC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL2luYWN0aXZlL3dpZGdldC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9hY3RvcnMvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvYmFyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2Rlc2NyaXB0aW9uL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24vaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QvY2hhbm5lbC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2RvdHMuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2l0ZW0uanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9wb3N0ZXIuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9zcG90bGlnaHQuanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC93YXRjaGluZy5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9sb2FkZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvbXBhYS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9tdXRlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3BvbGwvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvcG9wdXAvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvcmF0aW5nL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3JlY29tbWVuZGF0aW9ucy9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9zZWFyY2guanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2Jhci9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC9zdGF0aXN0aWNzL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3N1YnRpdGxlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3RpdGxlL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc2hhcmVkL3RyaXZpYS9pbmRleC5qcyIsInNyYy9jb21wb25lbnRzL3NoYXJlZC90d2VldHMvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy9zaGFyZWQvd2FsbHBhcGVyL2luZGV4LmpzIiwic3JjL2NvbXBvbmVudHMvc3dpdGNoZXIvaW5kZXguanMiLCJzcmMvY29tcG9uZW50cy91dGlsL2luZGV4LmpzIiwic3JjL21haW4vY2xpZW50aGFjay5qcyIsInNyYy9tYWluL2luZGV4LmpzIiwic3JjL21haW4vdWFoYWNrLmpzIiwicGFja2FnZS5qc29uIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25SQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2piQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25MQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2h4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4akJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvVUE7QUFDQTtBQUNBOzs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0tBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGpCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RWQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDek9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqSEE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqWUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaFpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzcxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUNyTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ3aW5kb3cubmFtZSA9ICdkaXJlY3R2LWZsJ1xuXG4vLyB3aW5kb3cucGFja2FnZSA9IHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpXG4vLyBjb25zb2xlLmxvZygnd3RmLi4uJywgd2luZG93LnBhY2thZ2UpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHJlcXVpcmUoICd2aWdvdXItanMvdXRpbC9jb25maWcnIClcbiAgICAgICAgICAgICAgLmluamVjdFxuICAgICAgICAgICAgICAoIHsgJ3JlcG9zaXRvcnkuYnJhbmNoJzogJ2JyYW5jaGVzJyB9XG4gICAgICAgICAgICAgICwgcmVxdWlyZSggJ3ZpZ291ci1qcy91dGlsL2NvbmZpZy91YScgKVxuICAgICAgICAgICAgICApXG5cbmV4cG9ydHMoIGZ1bmN0aW9uKCByZXN1bHQgKSB7XG4gIGZvcih2YXIga2V5IGluIHJlc3VsdCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdcXG4nLCBpLCByZXN1bHRbaV0pXG4gICAgZXhwb3J0c1trZXldID0gcmVzdWx0W2tleV0gXG4gIH1cbiAgZXhwb3J0cy5wYXJzZWQgPSB0cnVlXG5cbn0sIGZhbHNlLCB3aW5kb3cucGFja2FnZSwgdHJ1ZSApIiwiXG5cbi8vIHdpbmRvdy5fX3VhX18gPSB7XG4vLyAgIGRldmljZTondGFibGV0J1xuLy8gfVxuXG53aW5kb3cucGFja2FnZSA9IHJlcXVpcmUoJ3BhY2thZ2UuanNvbicpO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL2NvbmZpZycpXG4gICwgcmVtb3RlXG5cblxuaWYoIGNvbmZpZy5kZXZlbG9wbWVudCAmJiBjb25maWcuZGV2ZWxvcG1lbnQuYnV0dG9uIClcbntcbiAgcmVtb3RlID0gcmVxdWlyZSggJ3ZpZ291ci1qcy91dGlsL2RlYnVnJyApXG4gICAgICAgICAgICAubmF0aXZlKCBmYWxzZSwgZmFsc2UsIGZ1bmN0aW9uKHVybCkge30gLCAnYnVuZGxlJyApXG59XG5cbmlmKCAhcmVtb3RlICkgXG57XG4gIHZhciBjYXNlcyA9IHJlcXVpcmUoICd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycgKVxuICAgICwgdWEgPSByZXF1aXJlKCAndmlnb3VyLWpzL2Jyb3dzZXIvdWEnIClcblxuICAvLyBpZih1YS5kZXZpY2UgPT09ICd0YWJsZXQnKXtcbiAgLy8gICB2YXIgdmlld3BvcnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibWV0YVtuYW1lPXZpZXdwb3J0XVwiKVxuICAvLyAgIHZpZXdwb3J0LnNldEF0dHJpYnV0ZSgnY29udGVudCcsICd3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MC42LCBtYXhpbXVtLXNjYWxlPTEuMCwgdXNlci1zY2FsYWJsZT0wJyk7XG4gIC8vIH1cblxuICByZXF1aXJlKCAnLi9zcmMvbWFpbicgKVxuICBcbn0iLG51bGwsIi8qZ2xvYmFsIGRlZmluZTpmYWxzZSByZXF1aXJlOmZhbHNlICovXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpe1xuXHQvLyBJbXBvcnQgRXZlbnRzXG5cdHZhciBldmVudHMgPSByZXF1aXJlKCdldmVudHMnKVxuXG5cdC8vIEV4cG9ydCBEb21haW5cblx0dmFyIGRvbWFpbiA9IHt9XG5cdGRvbWFpbi5jcmVhdGVEb21haW4gPSBkb21haW4uY3JlYXRlID0gZnVuY3Rpb24oKXtcblx0XHR2YXIgZCA9IG5ldyBldmVudHMuRXZlbnRFbWl0dGVyKClcblxuXHRcdGZ1bmN0aW9uIGVtaXRFcnJvcihlKSB7XG5cdFx0XHRkLmVtaXQoJ2Vycm9yJywgZSlcblx0XHR9XG5cblx0XHRkLmFkZCA9IGZ1bmN0aW9uKGVtaXR0ZXIpe1xuXHRcdFx0ZW1pdHRlci5vbignZXJyb3InLCBlbWl0RXJyb3IpXG5cdFx0fVxuXHRcdGQucmVtb3ZlID0gZnVuY3Rpb24oZW1pdHRlcil7XG5cdFx0XHRlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVtaXRFcnJvcilcblx0XHR9XG5cdFx0ZC5iaW5kID0gZnVuY3Rpb24oZm4pe1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZuLmFwcGx5KG51bGwsIGFyZ3MpXG5cdFx0XHRcdH1cblx0XHRcdFx0Y2F0Y2ggKGVycil7XG5cdFx0XHRcdFx0ZW1pdEVycm9yKGVycilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkLmludGVyY2VwdCA9IGZ1bmN0aW9uKGZuKXtcblx0XHRcdHJldHVybiBmdW5jdGlvbihlcnIpe1xuXHRcdFx0XHRpZiAoIGVyciApIHtcblx0XHRcdFx0XHRlbWl0RXJyb3IoZXJyKVxuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRmbi5hcHBseShudWxsLCBhcmdzKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoZXJyKXtcblx0XHRcdFx0XHRcdGVtaXRFcnJvcihlcnIpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGQucnVuID0gZnVuY3Rpb24oZm4pe1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Zm4oKVxuXHRcdFx0fVxuXHRcdFx0Y2F0Y2ggKGVycikge1xuXHRcdFx0XHRlbWl0RXJyb3IoZXJyKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9O1xuXHRcdGQuZGlzcG9zZSA9IGZ1bmN0aW9uKCl7XG5cdFx0XHR0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH07XG5cdFx0ZC5lbnRlciA9IGQuZXhpdCA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHRyZXR1cm4gZFxuXHR9O1xuXHRyZXR1cm4gZG9tYWluXG59KS5jYWxsKHRoaXMpIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIHRocm93IFR5cGVFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4nKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIHZhciBtO1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gMDtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbihlbWl0dGVyLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IDE7XG4gIGVsc2VcbiAgICByZXQgPSBlbWl0dGVyLl9ldmVudHNbdHlwZV0ubGVuZ3RoO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCJleHBvcnRzLmVuZGlhbm5lc3MgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnTEUnIH07XG5cbmV4cG9ydHMuaG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uLmhvc3RuYW1lXG4gICAgfVxuICAgIGVsc2UgcmV0dXJuICcnO1xufTtcblxuZXhwb3J0cy5sb2FkYXZnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy51cHRpbWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbmV4cG9ydHMuZnJlZW1lbSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRTtcbn07XG5cbmV4cG9ydHMudG90YWxtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLmNwdXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBbXSB9O1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnQnJvd3NlcicgfTtcblxuZXhwb3J0cy5yZWxlYXNlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gbmF2aWdhdG9yLmFwcFZlcnNpb247XG4gICAgfVxuICAgIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubmV0d29ya0ludGVyZmFjZXNcbj0gZXhwb3J0cy5nZXROZXR3b3JrSW50ZXJmYWNlc1xuPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7fSB9O1xuXG5leHBvcnRzLmFyY2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnamF2YXNjcmlwdCcgfTtcblxuZXhwb3J0cy5wbGF0Zm9ybSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdicm93c2VyJyB9O1xuXG5leHBvcnRzLnRtcGRpciA9IGV4cG9ydHMudG1wRGlyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnL3RtcCc7XG59O1xuXG5leHBvcnRzLkVPTCA9ICdcXG4nO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50UXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtpXSgpO1xuICAgICAgICB9XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbn1cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgcXVldWUucHVzaChmdW4pO1xuICAgIGlmICghZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uKGYpIHtcbiAgaWYgKCFpc1N0cmluZyhmKSkge1xuICAgIHZhciBvYmplY3RzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIG9iamVjdHMucHVzaChpbnNwZWN0KGFyZ3VtZW50c1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0cy5qb2luKCcgJyk7XG4gIH1cblxuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHZhciBzdHIgPSBTdHJpbmcoZikucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uKHgpIHtcbiAgICBpZiAoeCA9PT0gJyUlJykgcmV0dXJuICclJztcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xuICAgIHN3aXRjaCAoeCkge1xuICAgICAgY2FzZSAnJXMnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVqJzpcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgfSk7XG4gIGZvciAodmFyIHggPSBhcmdzW2ldOyBpIDwgbGVuOyB4ID0gYXJnc1srK2ldKSB7XG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcbiAgICAgIHN0ciArPSAnICcgKyB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblxuLy8gTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbi8vIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuZXhwb3J0cy5kZXByZWNhdGUgPSBmdW5jdGlvbihmbiwgbXNnKSB7XG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSByZXF1aXJlKCcuL3N1cHBvcnQvaXNCdWZmZXInKTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuZXhwb3J0cy5fZXh0ZW5kID0gZnVuY3Rpb24ob3JpZ2luLCBhZGQpIHtcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxuICBpZiAoIWFkZCB8fCAhaXNPYmplY3QoYWRkKSkgcmV0dXJuIG9yaWdpbjtcblxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XG4gIH1cbiAgcmV0dXJuIG9yaWdpbjtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG4iLCIvLyBJZiBgRGF0ZS5ub3coKWAgaXMgaW52b2tlZCB0d2ljZSBxdWlja2x5LCBpdCdzIHBvc3NpYmxlIHRvIGdldCB0d29cbi8vIGlkZW50aWNhbCB0aW1lIHN0YW1wcy4gVG8gYXZvaWQgZ2VuZXJhdGlvbiBkdXBsaWNhdGlvbnMsIHN1YnNlcXVlbnRcbi8vIGNhbGxzIGFyZSBtYW51YWxseSBvcmRlcmVkIHRvIGZvcmNlIHVuaXF1ZW5lc3MuXG5cbnZhciBfbGFzdCA9IDBcbnZhciBfY291bnQgPSAxXG52YXIgYWRqdXN0ZWQgPSAwXG52YXIgX2FkanVzdGVkID0gMFxuXG5tb2R1bGUuZXhwb3J0cyA9XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIC8qKlxuICBSZXR1cm5zIE5PVCBhbiBhY2N1cmF0ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCB0aW1lLlxuICBTaW5jZSBqcyBvbmx5IG1lYXN1cmVzIHRpbWUgYXMgbXMsIGlmIHlvdSBjYWxsIGBEYXRlLm5vdygpYFxuICB0d2ljZSBxdWlja2x5LCBpdCdzIHBvc3NpYmxlIHRvIGdldCB0d28gaWRlbnRpY2FsIHRpbWUgc3RhbXBzLlxuICBUaGlzIGZ1bmN0aW9uIGd1YXJhbnRlZXMgdW5pcXVlIGJ1dCBtYXliZSBpbmFjY3VyYXRlIHJlc3VsdHNcbiAgb24gZWFjaCBjYWxsLlxuICAqKi9cbiAgLy91bmNvbW1lbnQgdGhpcyB3ZW5cbiAgdmFyIHRpbWUgPSBEYXRlLm5vdygpXG4gIC8vdGltZSA9IH5+ICh0aW1lIC8gMTAwMCkgXG4gIC8vXl5edW5jb21tZW50IHdoZW4gdGVzdGluZy4uLlxuXG4gIC8qKlxuICBJZiB0aW1lIHJldHVybmVkIGlzIHNhbWUgYXMgaW4gbGFzdCBjYWxsLCBhZGp1c3QgaXQgYnlcbiAgYWRkaW5nIGEgbnVtYmVyIGJhc2VkIG9uIHRoZSBjb3VudGVyLiBcbiAgQ291bnRlciBpcyBpbmNyZW1lbnRlZCBzbyB0aGF0IG5leHQgY2FsbCBnZXQncyBhZGp1c3RlZCBwcm9wZXJseS5cbiAgQmVjYXVzZSBmbG9hdHMgaGF2ZSByZXN0cmljdGVkIHByZWNpc2lvbiwgXG4gIG1heSBuZWVkIHRvIHN0ZXAgcGFzdCBzb21lIHZhbHVlcy4uLlxuICAqKi9cbiAgaWYgKF9sYXN0ID09PSB0aW1lKSAge1xuICAgIGRvIHtcbiAgICAgIGFkanVzdGVkID0gdGltZSArICgoX2NvdW50KyspIC8gKF9jb3VudCArIDk5OSkpXG4gICAgfSB3aGlsZSAoYWRqdXN0ZWQgPT09IF9hZGp1c3RlZClcbiAgICBfYWRqdXN0ZWQgPSBhZGp1c3RlZFxuICB9XG4gIC8vIElmIGxhc3QgdGltZSB3YXMgZGlmZmVyZW50IHJlc2V0IHRpbWVyIGJhY2sgdG8gYDFgLlxuICBlbHNlIHtcbiAgICBfY291bnQgPSAxXG4gICAgYWRqdXN0ZWQgPSB0aW1lXG4gIH1cbiAgX2FkanVzdGVkID0gYWRqdXN0ZWRcbiAgX2xhc3QgPSB0aW1lXG4gIHJldHVybiBhZGp1c3RlZFxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliJylcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwL3JhdycpO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gU3RhdGVzOlxuLy9cbi8vIDAgLSBwZW5kaW5nXG4vLyAxIC0gZnVsZmlsbGVkIHdpdGggX3ZhbHVlXG4vLyAyIC0gcmVqZWN0ZWQgd2l0aCBfdmFsdWVcbi8vIDMgLSBhZG9wdGVkIHRoZSBzdGF0ZSBvZiBhbm90aGVyIHByb21pc2UsIF92YWx1ZVxuLy9cbi8vIG9uY2UgdGhlIHN0YXRlIGlzIG5vIGxvbmdlciBwZW5kaW5nICgwKSBpdCBpcyBpbW11dGFibGVcblxuLy8gQWxsIGBfYCBwcmVmaXhlZCBwcm9wZXJ0aWVzIHdpbGwgYmUgcmVkdWNlZCB0byBgX3tyYW5kb20gbnVtYmVyfWBcbi8vIGF0IGJ1aWxkIHRpbWUgdG8gb2JmdXNjYXRlIHRoZW0gYW5kIGRpc2NvdXJhZ2UgdGhlaXIgdXNlLlxuLy8gV2UgZG9uJ3QgdXNlIHN5bWJvbHMgb3IgT2JqZWN0LmRlZmluZVByb3BlcnR5IHRvIGZ1bGx5IGhpZGUgdGhlbVxuLy8gYmVjYXVzZSB0aGUgcGVyZm9ybWFuY2UgaXNuJ3QgZ29vZCBlbm91Z2guXG5cblxuLy8gdG8gYXZvaWQgdXNpbmcgdHJ5L2NhdGNoIGluc2lkZSBjcml0aWNhbCBmdW5jdGlvbnMsIHdlXG4vLyBleHRyYWN0IHRoZW0gdG8gaGVyZS5cbnZhciBMQVNUX0VSUk9SID0gbnVsbDtcbnZhciBJU19FUlJPUiA9IHt9O1xuZnVuY3Rpb24gZ2V0VGhlbihvYmopIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gb2JqLnRoZW47XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgTEFTVF9FUlJPUiA9IGV4O1xuICAgIHJldHVybiBJU19FUlJPUjtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlDYWxsT25lKGZuLCBhKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKGEpO1xuICB9IGNhdGNoIChleCkge1xuICAgIExBU1RfRVJST1IgPSBleDtcbiAgICByZXR1cm4gSVNfRVJST1I7XG4gIH1cbn1cbmZ1bmN0aW9uIHRyeUNhbGxUd28oZm4sIGEsIGIpIHtcbiAgdHJ5IHtcbiAgICBmbihhLCBiKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBMQVNUX0VSUk9SID0gZXg7XG4gICAgcmV0dXJuIElTX0VSUk9SO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcblxuZnVuY3Rpb24gUHJvbWlzZShmbikge1xuICBpZiAodHlwZW9mIHRoaXMgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3Jyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vdCBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdGhpcy5fMzIgPSAwO1xuICB0aGlzLl84ID0gbnVsbDtcbiAgdGhpcy5fODkgPSBbXTtcbiAgaWYgKGZuID09PSBub29wKSByZXR1cm47XG4gIGRvUmVzb2x2ZShmbiwgdGhpcyk7XG59XG5Qcm9taXNlLl84MyA9IG5vb3A7XG5cblByb21pc2UucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gUHJvbWlzZSkge1xuICAgIHJldHVybiBzYWZlVGhlbih0aGlzLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gIH1cbiAgdmFyIHJlcyA9IG5ldyBQcm9taXNlKG5vb3ApO1xuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gc2FmZVRoZW4oc2VsZiwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIG5ldyBzZWxmLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVzID0gbmV3IFByb21pc2Uobm9vcCk7XG4gICAgcmVzLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICBoYW5kbGUoc2VsZiwgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlcykpO1xuICB9KTtcbn07XG5mdW5jdGlvbiBoYW5kbGUoc2VsZiwgZGVmZXJyZWQpIHtcbiAgd2hpbGUgKHNlbGYuXzMyID09PSAzKSB7XG4gICAgc2VsZiA9IHNlbGYuXzg7XG4gIH1cbiAgaWYgKHNlbGYuXzMyID09PSAwKSB7XG4gICAgc2VsZi5fODkucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFzYXAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNiID0gc2VsZi5fMzIgPT09IDEgPyBkZWZlcnJlZC5vbkZ1bGZpbGxlZCA6IGRlZmVycmVkLm9uUmVqZWN0ZWQ7XG4gICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICBpZiAoc2VsZi5fMzIgPT09IDEpIHtcbiAgICAgICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl84KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBzZWxmLl84KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldCA9IHRyeUNhbGxPbmUoY2IsIHNlbGYuXzgpO1xuICAgIGlmIChyZXQgPT09IElTX0VSUk9SKSB7XG4gICAgICByZWplY3QoZGVmZXJyZWQucHJvbWlzZSwgTEFTVF9FUlJPUik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUoZGVmZXJyZWQucHJvbWlzZSwgcmV0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICAvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlOiBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHtcbiAgICByZXR1cm4gcmVqZWN0KFxuICAgICAgc2VsZixcbiAgICAgIG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJylcbiAgICApO1xuICB9XG4gIGlmIChcbiAgICBuZXdWYWx1ZSAmJlxuICAgICh0eXBlb2YgbmV3VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ2Z1bmN0aW9uJylcbiAgKSB7XG4gICAgdmFyIHRoZW4gPSBnZXRUaGVuKG5ld1ZhbHVlKTtcbiAgICBpZiAodGhlbiA9PT0gSVNfRVJST1IpIHtcbiAgICAgIHJldHVybiByZWplY3Qoc2VsZiwgTEFTVF9FUlJPUik7XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoZW4gPT09IHNlbGYudGhlbiAmJlxuICAgICAgbmV3VmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlXG4gICAgKSB7XG4gICAgICBzZWxmLl8zMiA9IDM7XG4gICAgICBzZWxmLl84ID0gbmV3VmFsdWU7XG4gICAgICBmaW5hbGUoc2VsZik7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZG9SZXNvbHZlKHRoZW4uYmluZChuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBzZWxmLl8zMiA9IDE7XG4gIHNlbGYuXzggPSBuZXdWYWx1ZTtcbiAgZmluYWxlKHNlbGYpO1xufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fMzIgPSAyO1xuICBzZWxmLl84ID0gbmV3VmFsdWU7XG4gIGZpbmFsZShzZWxmKTtcbn1cbmZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZi5fODkubGVuZ3RoOyBpKyspIHtcbiAgICBoYW5kbGUoc2VsZiwgc2VsZi5fODlbaV0pO1xuICB9XG4gIHNlbGYuXzg5ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gSGFuZGxlcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcHJvbWlzZSl7XG4gIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGw7XG4gIHRoaXMub25SZWplY3RlZCA9IHR5cGVvZiBvblJlamVjdGVkID09PSAnZnVuY3Rpb24nID8gb25SZWplY3RlZCA6IG51bGw7XG4gIHRoaXMucHJvbWlzZSA9IHByb21pc2U7XG59XG5cbi8qKlxuICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAqL1xuZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBwcm9taXNlKSB7XG4gIHZhciBkb25lID0gZmFsc2U7XG4gIHZhciByZXMgPSB0cnlDYWxsVHdvKGZuLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgIGRvbmUgPSB0cnVlO1xuICAgIHJlc29sdmUocHJvbWlzZSwgdmFsdWUpO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3QocHJvbWlzZSwgcmVhc29uKTtcbiAgfSlcbiAgaWYgKCFkb25lICYmIHJlcyA9PT0gSVNfRVJST1IpIHtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3QocHJvbWlzZSwgTEFTVF9FUlJPUik7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuUHJvbWlzZS5wcm90b3R5cGUuZG9uZSA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB2YXIgc2VsZiA9IGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnRoZW4uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHRoaXM7XG4gIHNlbGYudGhlbihudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSwgMCk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGZpbGUgY29udGFpbnMgdGhlIEVTNiBleHRlbnNpb25zIHRvIHRoZSBjb3JlIFByb21pc2VzL0ErIEFQSVxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwL3JhdycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxudmFyIFRSVUUgPSB2YWx1ZVByb21pc2UodHJ1ZSk7XG52YXIgRkFMU0UgPSB2YWx1ZVByb21pc2UoZmFsc2UpO1xudmFyIE5VTEwgPSB2YWx1ZVByb21pc2UobnVsbCk7XG52YXIgVU5ERUZJTkVEID0gdmFsdWVQcm9taXNlKHVuZGVmaW5lZCk7XG52YXIgWkVSTyA9IHZhbHVlUHJvbWlzZSgwKTtcbnZhciBFTVBUWVNUUklORyA9IHZhbHVlUHJvbWlzZSgnJyk7XG5cbmZ1bmN0aW9uIHZhbHVlUHJvbWlzZSh2YWx1ZSkge1xuICB2YXIgcCA9IG5ldyBQcm9taXNlKFByb21pc2UuXzgzKTtcbiAgcC5fMzIgPSAxO1xuICBwLl84ID0gdmFsdWU7XG4gIHJldHVybiBwO1xufVxuUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiB2YWx1ZTtcblxuICBpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBOVUxMO1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFVOREVGSU5FRDtcbiAgaWYgKHZhbHVlID09PSB0cnVlKSByZXR1cm4gVFJVRTtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSkgcmV0dXJuIEZBTFNFO1xuICBpZiAodmFsdWUgPT09IDApIHJldHVybiBaRVJPO1xuICBpZiAodmFsdWUgPT09ICcnKSByZXR1cm4gRU1QVFlTVFJJTkc7XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciB0aGVuID0gdmFsdWUudGhlbjtcbiAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UodGhlbi5iaW5kKHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJlamVjdChleCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlUHJvbWlzZSh2YWx1ZSk7XG59O1xuXG5Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSk7XG4gICAgdmFyIHJlbWFpbmluZyA9IGFyZ3MubGVuZ3RoO1xuICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBQcm9taXNlICYmIHZhbC50aGVuID09PSBQcm9taXNlLnByb3RvdHlwZS50aGVuKSB7XG4gICAgICAgICAgd2hpbGUgKHZhbC5fMzIgPT09IDMpIHtcbiAgICAgICAgICAgIHZhbCA9IHZhbC5fODtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbC5fMzIgPT09IDEpIHJldHVybiByZXMoaSwgdmFsLl84KTtcbiAgICAgICAgICBpZiAodmFsLl8zMiA9PT0gMikgcmVqZWN0KHZhbC5fOCk7XG4gICAgICAgICAgdmFsLnRoZW4oZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBwID0gbmV3IFByb21pc2UodGhlbi5iaW5kKHZhbCkpO1xuICAgICAgICAgICAgcC50aGVuKGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgcmVzKGksIHZhbCk7XG4gICAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXJnc1tpXSA9IHZhbDtcbiAgICAgIGlmICgtLXJlbWFpbmluZyA9PT0gMCkge1xuICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKTtcbiAgICB9XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3QodmFsdWUpO1xuICB9KTtcbn07XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSl7XG4gICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICB9KTtcbiAgfSk7XG59O1xuXG4vKiBQcm90b3R5cGUgTWV0aG9kcyAqL1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnY2F0Y2gnXSA9IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gZnVuY3Rpb24gKGYpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGYoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcbnJlcXVpcmUoJy4vZG9uZS5qcycpO1xucmVxdWlyZSgnLi9maW5hbGx5LmpzJyk7XG5yZXF1aXJlKCcuL2VzNi1leHRlbnNpb25zLmpzJyk7XG5yZXF1aXJlKCcuL25vZGUtZXh0ZW5zaW9ucy5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGZpbGUgY29udGFpbnMgdGhlbi9wcm9taXNlIHNwZWNpZmljIGV4dGVuc2lvbnMgdGhhdCBhcmUgb25seSB1c2VmdWxcbi8vIGZvciBub2RlLmpzIGludGVyb3BcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2U7XG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxuUHJvbWlzZS5kZW5vZGVpZnkgPSBmdW5jdGlvbiAoZm4sIGFyZ3VtZW50Q291bnQpIHtcbiAgYXJndW1lbnRDb3VudCA9IGFyZ3VtZW50Q291bnQgfHwgSW5maW5pdHk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgd2hpbGUgKGFyZ3MubGVuZ3RoICYmIGFyZ3MubGVuZ3RoID4gYXJndW1lbnRDb3VudCkge1xuICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgfVxuICAgICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSByZXNvbHZlKHJlcyk7XG4gICAgICB9KVxuICAgICAgdmFyIHJlcyA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgaWYgKHJlcyAmJlxuICAgICAgICAoXG4gICAgICAgICAgdHlwZW9mIHJlcyA9PT0gJ29iamVjdCcgfHxcbiAgICAgICAgICB0eXBlb2YgcmVzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICkgJiZcbiAgICAgICAgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nXG4gICAgICApIHtcbiAgICAgICAgcmVzb2x2ZShyZXMpO1xuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblByb21pc2Uubm9kZWlmeSA9IGZ1bmN0aW9uIChmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPVxuICAgICAgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJyA/IGFyZ3MucG9wKCkgOiBudWxsO1xuICAgIHZhciBjdHggPSB0aGlzO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKS5ub2RlaWZ5KGNhbGxiYWNrLCBjdHgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgcmVqZWN0KGV4KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXgpO1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcztcblxuICB0aGlzLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGN0eCwgbnVsbCwgdmFsdWUpO1xuICAgIH0pO1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXJyKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLy8gcmF3QXNhcCBwcm92aWRlcyBldmVyeXRoaW5nIHdlIG5lZWQgZXhjZXB0IGV4Y2VwdGlvbiBtYW5hZ2VtZW50LlxudmFyIHJhd0FzYXAgPSByZXF1aXJlKFwiLi9yYXdcIik7XG4vLyBSYXdUYXNrcyBhcmUgcmVjeWNsZWQgdG8gcmVkdWNlIEdDIGNodXJuLlxudmFyIGZyZWVUYXNrcyA9IFtdO1xuLy8gV2UgcXVldWUgZXJyb3JzIHRvIGVuc3VyZSB0aGV5IGFyZSB0aHJvd24gaW4gcmlnaHQgb3JkZXIgKEZJRk8pLlxuLy8gQXJyYXktYXMtcXVldWUgaXMgZ29vZCBlbm91Z2ggaGVyZSwgc2luY2Ugd2UgYXJlIGp1c3QgZGVhbGluZyB3aXRoIGV4Y2VwdGlvbnMuXG52YXIgcGVuZGluZ0Vycm9ycyA9IFtdO1xudmFyIHJlcXVlc3RFcnJvclRocm93ID0gcmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIodGhyb3dGaXJzdEVycm9yKTtcblxuZnVuY3Rpb24gdGhyb3dGaXJzdEVycm9yKCkge1xuICAgIGlmIChwZW5kaW5nRXJyb3JzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBwZW5kaW5nRXJyb3JzLnNoaWZ0KCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGxzIGEgdGFzayBhcyBzb29uIGFzIHBvc3NpYmxlIGFmdGVyIHJldHVybmluZywgaW4gaXRzIG93biBldmVudCwgd2l0aCBwcmlvcml0eVxuICogb3ZlciBvdGhlciBldmVudHMgbGlrZSBhbmltYXRpb24sIHJlZmxvdywgYW5kIHJlcGFpbnQuIEFuIGVycm9yIHRocm93biBmcm9tIGFuXG4gKiBldmVudCB3aWxsIG5vdCBpbnRlcnJ1cHQsIG5vciBldmVuIHN1YnN0YW50aWFsbHkgc2xvdyBkb3duIHRoZSBwcm9jZXNzaW5nIG9mXG4gKiBvdGhlciBldmVudHMsIGJ1dCB3aWxsIGJlIHJhdGhlciBwb3N0cG9uZWQgdG8gYSBsb3dlciBwcmlvcml0eSBldmVudC5cbiAqIEBwYXJhbSB7e2NhbGx9fSB0YXNrIEEgY2FsbGFibGUgb2JqZWN0LCB0eXBpY2FsbHkgYSBmdW5jdGlvbiB0aGF0IHRha2VzIG5vXG4gKiBhcmd1bWVudHMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gYXNhcDtcbmZ1bmN0aW9uIGFzYXAodGFzaykge1xuICAgIHZhciByYXdUYXNrO1xuICAgIGlmIChmcmVlVGFza3MubGVuZ3RoKSB7XG4gICAgICAgIHJhd1Rhc2sgPSBmcmVlVGFza3MucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmF3VGFzayA9IG5ldyBSYXdUYXNrKCk7XG4gICAgfVxuICAgIHJhd1Rhc2sudGFzayA9IHRhc2s7XG4gICAgcmF3QXNhcChyYXdUYXNrKTtcbn1cblxuLy8gV2Ugd3JhcCB0YXNrcyB3aXRoIHJlY3ljbGFibGUgdGFzayBvYmplY3RzLiAgQSB0YXNrIG9iamVjdCBpbXBsZW1lbnRzXG4vLyBgY2FsbGAsIGp1c3QgbGlrZSBhIGZ1bmN0aW9uLlxuZnVuY3Rpb24gUmF3VGFzaygpIHtcbiAgICB0aGlzLnRhc2sgPSBudWxsO1xufVxuXG4vLyBUaGUgc29sZSBwdXJwb3NlIG9mIHdyYXBwaW5nIHRoZSB0YXNrIGlzIHRvIGNhdGNoIHRoZSBleGNlcHRpb24gYW5kIHJlY3ljbGVcbi8vIHRoZSB0YXNrIG9iamVjdCBhZnRlciBpdHMgc2luZ2xlIHVzZS5cblJhd1Rhc2sucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgdGhpcy50YXNrLmNhbGwoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoYXNhcC5vbmVycm9yKSB7XG4gICAgICAgICAgICAvLyBUaGlzIGhvb2sgZXhpc3RzIHB1cmVseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy5cbiAgICAgICAgICAgIC8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdFxuICAgICAgICAgICAgLy8gZGVwZW5kcyBvbiBpdHMgZXhpc3RlbmNlLlxuICAgICAgICAgICAgYXNhcC5vbmVycm9yKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEluIGEgd2ViIGJyb3dzZXIsIGV4Y2VwdGlvbnMgYXJlIG5vdCBmYXRhbC4gSG93ZXZlciwgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHNsb3dpbmcgZG93biB0aGUgcXVldWUgb2YgcGVuZGluZyB0YXNrcywgd2UgcmV0aHJvdyB0aGUgZXJyb3IgaW4gYVxuICAgICAgICAgICAgLy8gbG93ZXIgcHJpb3JpdHkgdHVybi5cbiAgICAgICAgICAgIHBlbmRpbmdFcnJvcnMucHVzaChlcnJvcik7XG4gICAgICAgICAgICByZXF1ZXN0RXJyb3JUaHJvdygpO1xuICAgICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy50YXNrID0gbnVsbDtcbiAgICAgICAgZnJlZVRhc2tzW2ZyZWVUYXNrcy5sZW5ndGhdID0gdGhpcztcbiAgICB9XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFVzZSB0aGUgZmFzdGVzdCBtZWFucyBwb3NzaWJsZSB0byBleGVjdXRlIGEgdGFzayBpbiBpdHMgb3duIHR1cm4sIHdpdGhcbi8vIHByaW9yaXR5IG92ZXIgb3RoZXIgZXZlbnRzIGluY2x1ZGluZyBJTywgYW5pbWF0aW9uLCByZWZsb3csIGFuZCByZWRyYXdcbi8vIGV2ZW50cyBpbiBicm93c2Vycy5cbi8vXG4vLyBBbiBleGNlcHRpb24gdGhyb3duIGJ5IGEgdGFzayB3aWxsIHBlcm1hbmVudGx5IGludGVycnVwdCB0aGUgcHJvY2Vzc2luZyBvZlxuLy8gc3Vic2VxdWVudCB0YXNrcy4gVGhlIGhpZ2hlciBsZXZlbCBgYXNhcGAgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duIGJ5IGEgdGFzaywgdGhhdCB0aGUgdGFzayBxdWV1ZSB3aWxsIGNvbnRpbnVlIGZsdXNoaW5nIGFzXG4vLyBzb29uIGFzIHBvc3NpYmxlLCBidXQgaWYgeW91IHVzZSBgcmF3QXNhcGAgZGlyZWN0bHksIHlvdSBhcmUgcmVzcG9uc2libGUgdG9cbi8vIGVpdGhlciBlbnN1cmUgdGhhdCBubyBleGNlcHRpb25zIGFyZSB0aHJvd24gZnJvbSB5b3VyIHRhc2ssIG9yIHRvIG1hbnVhbGx5XG4vLyBjYWxsIGByYXdBc2FwLnJlcXVlc3RGbHVzaGAgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93bi5cbm1vZHVsZS5leHBvcnRzID0gcmF3QXNhcDtcbmZ1bmN0aW9uIHJhd0FzYXAodGFzaykge1xuICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHJlcXVlc3RGbHVzaCgpO1xuICAgICAgICBmbHVzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIC8vIEVxdWl2YWxlbnQgdG8gcHVzaCwgYnV0IGF2b2lkcyBhIGZ1bmN0aW9uIGNhbGwuXG4gICAgcXVldWVbcXVldWUubGVuZ3RoXSA9IHRhc2s7XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuLy8gT25jZSBhIGZsdXNoIGhhcyBiZWVuIHJlcXVlc3RlZCwgbm8gZnVydGhlciBjYWxscyB0byBgcmVxdWVzdEZsdXNoYCBhcmVcbi8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbnZhciBmbHVzaGluZyA9IGZhbHNlO1xuLy8gYHJlcXVlc3RGbHVzaGAgaXMgYW4gaW1wbGVtZW50YXRpb24tc3BlY2lmaWMgbWV0aG9kIHRoYXQgYXR0ZW1wdHMgdG8ga2lja1xuLy8gb2ZmIGEgYGZsdXNoYCBldmVudCBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLiBgZmx1c2hgIHdpbGwgYXR0ZW1wdCB0byBleGhhdXN0XG4vLyB0aGUgZXZlbnQgcXVldWUgYmVmb3JlIHlpZWxkaW5nIHRvIHRoZSBicm93c2VyJ3Mgb3duIGV2ZW50IGxvb3AuXG52YXIgcmVxdWVzdEZsdXNoO1xuLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHRhc2sgdG8gZXhlY3V0ZSBpbiB0aGUgdGFzayBxdWV1ZS4gVGhpcyBpc1xuLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4vLyBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbnZhciBpbmRleCA9IDA7XG4vLyBJZiBhIHRhc2sgc2NoZWR1bGVzIGFkZGl0aW9uYWwgdGFza3MgcmVjdXJzaXZlbHksIHRoZSB0YXNrIHF1ZXVlIGNhbiBncm93XG4vLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4aGF1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4vLyB0cnVuY2F0ZSBhbHJlYWR5LWNvbXBsZXRlZCB0YXNrcy5cbnZhciBjYXBhY2l0eSA9IDEwMjQ7XG5cbi8vIFRoZSBmbHVzaCBmdW5jdGlvbiBwcm9jZXNzZXMgYWxsIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHNjaGVkdWxlZCB3aXRoXG4vLyBgcmF3QXNhcGAgdW5sZXNzIGFuZCB1bnRpbCBvbmUgb2YgdGhvc2UgdGFza3MgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbi8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbi8vIGNvbnNpc3RlbnQgYW5kIHdpbGwgcmVzdW1lIHdoZXJlIGl0IGxlZnQgb2ZmIHdoZW4gY2FsbGVkIGFnYWluLlxuLy8gSG93ZXZlciwgYGZsdXNoYCBkb2VzIG5vdCBtYWtlIGFueSBhcnJhbmdlbWVudHMgdG8gYmUgY2FsbGVkIGFnYWluIGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duLlxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgaW5kZXggYmVmb3JlIGNhbGxpbmcgdGhlIHRhc2suIFRoaXMgZW5zdXJlcyB0aGF0IHdlIHdpbGxcbiAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBxdWV1ZVtjdXJyZW50SW5kZXhdLmNhbGwoKTtcbiAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgLy8gSWYgd2UgY2FsbCBgYXNhcGAgd2l0aGluIHRhc2tzIHNjaGVkdWxlZCBieSBgYXNhcGAsIHRoZSBxdWV1ZSB3aWxsXG4gICAgICAgIC8vIGdyb3csIGJ1dCB0byBhdm9pZCBhbiBPKG4pIHdhbGsgZm9yIGV2ZXJ5IHRhc2sgd2UgZXhlY3V0ZSwgd2UgZG9uJ3RcbiAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgcGVyaW9kaWNhbGx5IHNoaWZ0IDEwMjQgdGFza3Mgb2ZmIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKGluZGV4ID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNoaWZ0IGFsbCB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGluZGV4IGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgZm9yICh2YXIgc2NhbiA9IDAsIG5ld0xlbmd0aCA9IHF1ZXVlLmxlbmd0aCAtIGluZGV4OyBzY2FuIDwgbmV3TGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBxdWV1ZVtzY2FuXSA9IHF1ZXVlW3NjYW4gKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggLT0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBpbmRleCA9IDA7XG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuLy8gYHJlcXVlc3RGbHVzaGAgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSBzdHJhdGVneSBiYXNlZCBvbiBkYXRhIGNvbGxlY3RlZCBmcm9tXG4vLyBldmVyeSBhdmFpbGFibGUgU2F1Y2VMYWJzIFNlbGVuaXVtIHdlYiBkcml2ZXIgd29ya2VyIGF0IHRpbWUgb2Ygd3JpdGluZy5cbi8vIGh0dHBzOi8vZG9jcy5nb29nbGUuY29tL3NwcmVhZHNoZWV0cy9kLzFtRy01VVlHdXA1cXhHZEVNV2toUDZCV0N6MDUzTlViMkUxUW9VVFUxNnVBL2VkaXQjZ2lkPTc4MzcyNDU5M1xuXG4vLyBTYWZhcmkgNiBhbmQgNi4xIGZvciBkZXNrdG9wLCBpUGFkLCBhbmQgaVBob25lIGFyZSB0aGUgb25seSBicm93c2VycyB0aGF0XG4vLyBoYXZlIFdlYktpdE11dGF0aW9uT2JzZXJ2ZXIgYnV0IG5vdCB1bi1wcmVmaXhlZCBNdXRhdGlvbk9ic2VydmVyLlxuLy8gTXVzdCB1c2UgYGdsb2JhbGAgaW5zdGVhZCBvZiBgd2luZG93YCB0byB3b3JrIGluIGJvdGggZnJhbWVzIGFuZCB3ZWJcbi8vIHdvcmtlcnMuIGBnbG9iYWxgIGlzIGEgcHJvdmlzaW9uIG9mIEJyb3dzZXJpZnksIE1yLCBNcnMsIG9yIE1vcC5cbnZhciBCcm93c2VyTXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xuXG4vLyBNdXRhdGlvbk9ic2VydmVycyBhcmUgZGVzaXJhYmxlIGJlY2F1c2UgdGhleSBoYXZlIGhpZ2ggcHJpb3JpdHkgYW5kIHdvcmtcbi8vIHJlbGlhYmx5IGV2ZXJ5d2hlcmUgdGhleSBhcmUgaW1wbGVtZW50ZWQuXG4vLyBUaGV5IGFyZSBpbXBsZW1lbnRlZCBpbiBhbGwgbW9kZXJuIGJyb3dzZXJzLlxuLy9cbi8vIC0gQW5kcm9pZCA0LTQuM1xuLy8gLSBDaHJvbWUgMjYtMzRcbi8vIC0gRmlyZWZveCAxNC0yOVxuLy8gLSBJbnRlcm5ldCBFeHBsb3JlciAxMVxuLy8gLSBpUGFkIFNhZmFyaSA2LTcuMVxuLy8gLSBpUGhvbmUgU2FmYXJpIDctNy4xXG4vLyAtIFNhZmFyaSA2LTdcbmlmICh0eXBlb2YgQnJvd3Nlck11dGF0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJlcXVlc3RGbHVzaCA9IG1ha2VSZXF1ZXN0Q2FsbEZyb21NdXRhdGlvbk9ic2VydmVyKGZsdXNoKTtcblxuLy8gTWVzc2FnZUNoYW5uZWxzIGFyZSBkZXNpcmFibGUgYmVjYXVzZSB0aGV5IGdpdmUgZGlyZWN0IGFjY2VzcyB0byB0aGUgSFRNTFxuLy8gdGFzayBxdWV1ZSwgYXJlIGltcGxlbWVudGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLCBTYWZhcmkgNS4wLTEsIGFuZCBPcGVyYVxuLy8gMTEtMTIsIGFuZCBpbiB3ZWIgd29ya2VycyBpbiBtYW55IGVuZ2luZXMuXG4vLyBBbHRob3VnaCBtZXNzYWdlIGNoYW5uZWxzIHlpZWxkIHRvIGFueSBxdWV1ZWQgcmVuZGVyaW5nIGFuZCBJTyB0YXNrcywgdGhleVxuLy8gd291bGQgYmUgYmV0dGVyIHRoYW4gaW1wb3NpbmcgdGhlIDRtcyBkZWxheSBvZiB0aW1lcnMuXG4vLyBIb3dldmVyLCB0aGV5IGRvIG5vdCB3b3JrIHJlbGlhYmx5IGluIEludGVybmV0IEV4cGxvcmVyIG9yIFNhZmFyaS5cblxuLy8gSW50ZXJuZXQgRXhwbG9yZXIgMTAgaXMgdGhlIG9ubHkgYnJvd3NlciB0aGF0IGhhcyBzZXRJbW1lZGlhdGUgYnV0IGRvZXNcbi8vIG5vdCBoYXZlIE11dGF0aW9uT2JzZXJ2ZXJzLlxuLy8gQWx0aG91Z2ggc2V0SW1tZWRpYXRlIHlpZWxkcyB0byB0aGUgYnJvd3NlcidzIHJlbmRlcmVyLCBpdCB3b3VsZCBiZVxuLy8gcHJlZmVycmFibGUgdG8gZmFsbGluZyBiYWNrIHRvIHNldFRpbWVvdXQgc2luY2UgaXQgZG9lcyBub3QgaGF2ZVxuLy8gdGhlIG1pbmltdW0gNG1zIHBlbmFsdHkuXG4vLyBVbmZvcnR1bmF0ZWx5IHRoZXJlIGFwcGVhcnMgdG8gYmUgYSBidWcgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAgTW9iaWxlIChhbmRcbi8vIERlc2t0b3AgdG8gYSBsZXNzZXIgZXh0ZW50KSB0aGF0IHJlbmRlcnMgYm90aCBzZXRJbW1lZGlhdGUgYW5kXG4vLyBNZXNzYWdlQ2hhbm5lbCB1c2VsZXNzIGZvciB0aGUgcHVycG9zZXMgb2YgQVNBUC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9rcmlza293YWwvcS9pc3N1ZXMvMzk2XG5cbi8vIFRpbWVycyBhcmUgaW1wbGVtZW50ZWQgdW5pdmVyc2FsbHkuXG4vLyBXZSBmYWxsIGJhY2sgdG8gdGltZXJzIGluIHdvcmtlcnMgaW4gbW9zdCBlbmdpbmVzLCBhbmQgaW4gZm9yZWdyb3VuZFxuLy8gY29udGV4dHMgaW4gdGhlIGZvbGxvd2luZyBicm93c2Vycy5cbi8vIEhvd2V2ZXIsIG5vdGUgdGhhdCBldmVuIHRoaXMgc2ltcGxlIGNhc2UgcmVxdWlyZXMgbnVhbmNlcyB0byBvcGVyYXRlIGluIGFcbi8vIGJyb2FkIHNwZWN0cnVtIG9mIGJyb3dzZXJzLlxuLy9cbi8vIC0gRmlyZWZveCAzLTEzXG4vLyAtIEludGVybmV0IEV4cGxvcmVyIDYtOVxuLy8gLSBpUGFkIFNhZmFyaSA0LjNcbi8vIC0gTHlueCAyLjguN1xufSBlbHNlIHtcbiAgICByZXF1ZXN0Rmx1c2ggPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXIoZmx1c2gpO1xufVxuXG4vLyBgcmVxdWVzdEZsdXNoYCByZXF1ZXN0cyB0aGF0IHRoZSBoaWdoIHByaW9yaXR5IGV2ZW50IHF1ZXVlIGJlIGZsdXNoZWQgYXNcbi8vIHNvb24gYXMgcG9zc2libGUuXG4vLyBUaGlzIGlzIHVzZWZ1bCB0byBwcmV2ZW50IGFuIGVycm9yIHRocm93biBpbiBhIHRhc2sgZnJvbSBzdGFsbGluZyB0aGUgZXZlbnRcbi8vIHF1ZXVlIGlmIHRoZSBleGNlcHRpb24gaGFuZGxlZCBieSBOb2RlLmpz4oCZc1xuLy8gYHByb2Nlc3Mub24oXCJ1bmNhdWdodEV4Y2VwdGlvblwiKWAgb3IgYnkgYSBkb21haW4uXG5yYXdBc2FwLnJlcXVlc3RGbHVzaCA9IHJlcXVlc3RGbHVzaDtcblxuLy8gVG8gcmVxdWVzdCBhIGhpZ2ggcHJpb3JpdHkgZXZlbnQsIHdlIGluZHVjZSBhIG11dGF0aW9uIG9ic2VydmVyIGJ5IHRvZ2dsaW5nXG4vLyB0aGUgdGV4dCBvZiBhIHRleHQgbm9kZSBiZXR3ZWVuIFwiMVwiIGFuZCBcIi0xXCIuXG5mdW5jdGlvbiBtYWtlUmVxdWVzdENhbGxGcm9tTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjaykge1xuICAgIHZhciB0b2dnbGUgPSAxO1xuICAgIHZhciBvYnNlcnZlciA9IG5ldyBCcm93c2VyTXV0YXRpb25PYnNlcnZlcihjYWxsYmFjayk7XG4gICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICB0b2dnbGUgPSAtdG9nZ2xlO1xuICAgICAgICBub2RlLmRhdGEgPSB0b2dnbGU7XG4gICAgfTtcbn1cblxuLy8gVGhlIG1lc3NhZ2UgY2hhbm5lbCB0ZWNobmlxdWUgd2FzIGRpc2NvdmVyZWQgYnkgTWFsdGUgVWJsIGFuZCB3YXMgdGhlXG4vLyBvcmlnaW5hbCBmb3VuZGF0aW9uIGZvciB0aGlzIGxpYnJhcnkuXG4vLyBodHRwOi8vd3d3Lm5vbmJsb2NraW5nLmlvLzIwMTEvMDYvd2luZG93bmV4dHRpY2suaHRtbFxuXG4vLyBTYWZhcmkgNi4wLjUgKGF0IGxlYXN0KSBpbnRlcm1pdHRlbnRseSBmYWlscyB0byBjcmVhdGUgbWVzc2FnZSBwb3J0cyBvbiBhXG4vLyBwYWdlJ3MgZmlyc3QgbG9hZC4gVGhhbmtmdWxseSwgdGhpcyB2ZXJzaW9uIG9mIFNhZmFyaSBzdXBwb3J0c1xuLy8gTXV0YXRpb25PYnNlcnZlcnMsIHNvIHdlIGRvbid0IG5lZWQgdG8gZmFsbCBiYWNrIGluIHRoYXQgY2FzZS5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbU1lc3NhZ2VDaGFubmVsKGNhbGxiYWNrKSB7XG4vLyAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbi8vICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGNhbGxiYWNrO1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZSgwKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBGb3IgcmVhc29ucyBleHBsYWluZWQgYWJvdmUsIHdlIGFyZSBhbHNvIHVuYWJsZSB0byB1c2UgYHNldEltbWVkaWF0ZWBcbi8vIHVuZGVyIGFueSBjaXJjdW1zdGFuY2VzLlxuLy8gRXZlbiBpZiB3ZSB3ZXJlLCB0aGVyZSBpcyBhbm90aGVyIGJ1ZyBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbi8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGFzc2lnbiBgc2V0SW1tZWRpYXRlYCB0byBgcmVxdWVzdEZsdXNoYCBiZWNhdXNlXG4vLyBgc2V0SW1tZWRpYXRlYCBtdXN0IGJlIGNhbGxlZCAqYnkgbmFtZSogYW5kIHRoZXJlZm9yZSBtdXN0IGJlIHdyYXBwZWQgaW4gYVxuLy8gY2xvc3VyZS5cbi8vIE5ldmVyIGZvcmdldC5cblxuLy8gZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuLy8gICAgIHJldHVybiBmdW5jdGlvbiByZXF1ZXN0Q2FsbCgpIHtcbi8vICAgICAgICAgc2V0SW1tZWRpYXRlKGNhbGxiYWNrKTtcbi8vICAgICB9O1xuLy8gfVxuXG4vLyBTYWZhcmkgNi4wIGhhcyBhIHByb2JsZW0gd2hlcmUgdGltZXJzIHdpbGwgZ2V0IGxvc3Qgd2hpbGUgdGhlIHVzZXIgaXNcbi8vIHNjcm9sbGluZy4gVGhpcyBwcm9ibGVtIGRvZXMgbm90IGltcGFjdCBBU0FQIGJlY2F1c2UgU2FmYXJpIDYuMCBzdXBwb3J0c1xuLy8gbXV0YXRpb24gb2JzZXJ2ZXJzLCBzbyB0aGF0IGltcGxlbWVudGF0aW9uIGlzIHVzZWQgaW5zdGVhZC5cbi8vIEhvd2V2ZXIsIGlmIHdlIGV2ZXIgZWxlY3QgdG8gdXNlIHRpbWVycyBpbiBTYWZhcmksIHRoZSBwcmV2YWxlbnQgd29yay1hcm91bmRcbi8vIGlzIHRvIGFkZCBhIHNjcm9sbCBldmVudCBsaXN0ZW5lciB0aGF0IGNhbGxzIGZvciBhIGZsdXNoLlxuXG4vLyBgc2V0VGltZW91dGAgZG9lcyBub3QgY2FsbCB0aGUgcGFzc2VkIGNhbGxiYWNrIGlmIHRoZSBkZWxheSBpcyBsZXNzIHRoYW5cbi8vIGFwcHJveGltYXRlbHkgNyBpbiB3ZWIgd29ya2VycyBpbiBGaXJlZm94IDggdGhyb3VnaCAxOCwgYW5kIHNvbWV0aW1lcyBub3Rcbi8vIGV2ZW4gdGhlbi5cblxuZnVuY3Rpb24gbWFrZVJlcXVlc3RDYWxsRnJvbVRpbWVyKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHJlcXVlc3RDYWxsKCkge1xuICAgICAgICAvLyBXZSBkaXNwYXRjaCBhIHRpbWVvdXQgd2l0aCBhIHNwZWNpZmllZCBkZWxheSBvZiAwIGZvciBlbmdpbmVzIHRoYXRcbiAgICAgICAgLy8gY2FuIHJlbGlhYmx5IGFjY29tbW9kYXRlIHRoYXQgcmVxdWVzdC4gVGhpcyB3aWxsIHVzdWFsbHkgYmUgc25hcHBlZFxuICAgICAgICAvLyB0byBhIDQgbWlsaXNlY29uZCBkZWxheSwgYnV0IG9uY2Ugd2UncmUgZmx1c2hpbmcsIHRoZXJlJ3Mgbm8gZGVsYXlcbiAgICAgICAgLy8gYmV0d2VlbiBldmVudHMuXG4gICAgICAgIHZhciB0aW1lb3V0SGFuZGxlID0gc2V0VGltZW91dChoYW5kbGVUaW1lciwgMCk7XG4gICAgICAgIC8vIEhvd2V2ZXIsIHNpbmNlIHRoaXMgdGltZXIgZ2V0cyBmcmVxdWVudGx5IGRyb3BwZWQgaW4gRmlyZWZveFxuICAgICAgICAvLyB3b3JrZXJzLCB3ZSBlbmxpc3QgYW4gaW50ZXJ2YWwgaGFuZGxlIHRoYXQgd2lsbCB0cnkgdG8gZmlyZVxuICAgICAgICAvLyBhbiBldmVudCAyMCB0aW1lcyBwZXIgc2Vjb25kIHVudGlsIGl0IHN1Y2NlZWRzLlxuICAgICAgICB2YXIgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbChoYW5kbGVUaW1lciwgNTApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVRpbWVyKCkge1xuICAgICAgICAgICAgLy8gV2hpY2hldmVyIHRpbWVyIHN1Y2NlZWRzIHdpbGwgY2FuY2VsIGJvdGggdGltZXJzIGFuZFxuICAgICAgICAgICAgLy8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dEhhbmRsZSk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSGFuZGxlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vLyBUaGlzIGlzIGZvciBgYXNhcC5qc2Agb25seS5cbi8vIEl0cyBuYW1lIHdpbGwgYmUgcGVyaW9kaWNhbGx5IHJhbmRvbWl6ZWQgdG8gYnJlYWsgYW55IGNvZGUgdGhhdCBkZXBlbmRzIG9uXG4vLyBpdHMgZXhpc3RlbmNlLlxucmF3QXNhcC5tYWtlUmVxdWVzdENhbGxGcm9tVGltZXIgPSBtYWtlUmVxdWVzdENhbGxGcm9tVGltZXI7XG5cbi8vIEFTQVAgd2FzIG9yaWdpbmFsbHkgYSBuZXh0VGljayBzaGltIGluY2x1ZGVkIGluIFEuIFRoaXMgd2FzIGZhY3RvcmVkIG91dFxuLy8gaW50byB0aGlzIEFTQVAgcGFja2FnZS4gSXQgd2FzIGxhdGVyIGFkYXB0ZWQgdG8gUlNWUCB3aGljaCBtYWRlIGZ1cnRoZXJcbi8vIGFtZW5kbWVudHMuIFRoZXNlIGRlY2lzaW9ucywgcGFydGljdWxhcmx5IHRvIG1hcmdpbmFsaXplIE1lc3NhZ2VDaGFubmVsIGFuZFxuLy8gdG8gY2FwdHVyZSB0aGUgTXV0YXRpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbiBpbiBhIGNsb3N1cmUsIHdlcmUgaW50ZWdyYXRlZFxuLy8gYmFjayBpbnRvIEFTQVAgcHJvcGVyLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RpbGRlaW8vcnN2cC5qcy9ibG9iL2NkZGY3MjMyNTQ2YTljZjg1ODUyNGI3NWNkZTZmOWVkZjcyNjIwYTcvbGliL3JzdnAvYXNhcC5qc1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBkb21haW47IC8vIFRoZSBkb21haW4gbW9kdWxlIGlzIGV4ZWN1dGVkIG9uIGRlbWFuZFxudmFyIGhhc1NldEltbWVkaWF0ZSA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIjtcblxuLy8gVXNlIHRoZSBmYXN0ZXN0IG1lYW5zIHBvc3NpYmxlIHRvIGV4ZWN1dGUgYSB0YXNrIGluIGl0cyBvd24gdHVybiwgd2l0aFxuLy8gcHJpb3JpdHkgb3ZlciBvdGhlciBldmVudHMgaW5jbHVkaW5nIG5ldHdvcmsgSU8gZXZlbnRzIGluIE5vZGUuanMuXG4vL1xuLy8gQW4gZXhjZXB0aW9uIHRocm93biBieSBhIHRhc2sgd2lsbCBwZXJtYW5lbnRseSBpbnRlcnJ1cHQgdGhlIHByb2Nlc3Npbmcgb2Zcbi8vIHN1YnNlcXVlbnQgdGFza3MuIFRoZSBoaWdoZXIgbGV2ZWwgYGFzYXBgIGZ1bmN0aW9uIGVuc3VyZXMgdGhhdCBpZiBhblxuLy8gZXhjZXB0aW9uIGlzIHRocm93biBieSBhIHRhc2ssIHRoYXQgdGhlIHRhc2sgcXVldWUgd2lsbCBjb250aW51ZSBmbHVzaGluZyBhc1xuLy8gc29vbiBhcyBwb3NzaWJsZSwgYnV0IGlmIHlvdSB1c2UgYHJhd0FzYXBgIGRpcmVjdGx5LCB5b3UgYXJlIHJlc3BvbnNpYmxlIHRvXG4vLyBlaXRoZXIgZW5zdXJlIHRoYXQgbm8gZXhjZXB0aW9ucyBhcmUgdGhyb3duIGZyb20geW91ciB0YXNrLCBvciB0byBtYW51YWxseVxuLy8gY2FsbCBgcmF3QXNhcC5yZXF1ZXN0Rmx1c2hgIGlmIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG5tb2R1bGUuZXhwb3J0cyA9IHJhd0FzYXA7XG5mdW5jdGlvbiByYXdBc2FwKHRhc2spIHtcbiAgICBpZiAoIXF1ZXVlLmxlbmd0aCkge1xuICAgICAgICByZXF1ZXN0Rmx1c2goKTtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBBdm9pZHMgYSBmdW5jdGlvbiBjYWxsXG4gICAgcXVldWVbcXVldWUubGVuZ3RoXSA9IHRhc2s7XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xuLy8gT25jZSBhIGZsdXNoIGhhcyBiZWVuIHJlcXVlc3RlZCwgbm8gZnVydGhlciBjYWxscyB0byBgcmVxdWVzdEZsdXNoYCBhcmVcbi8vIG5lY2Vzc2FyeSB1bnRpbCB0aGUgbmV4dCBgZmx1c2hgIGNvbXBsZXRlcy5cbnZhciBmbHVzaGluZyA9IGZhbHNlO1xuLy8gVGhlIHBvc2l0aW9uIG9mIHRoZSBuZXh0IHRhc2sgdG8gZXhlY3V0ZSBpbiB0aGUgdGFzayBxdWV1ZS4gVGhpcyBpc1xuLy8gcHJlc2VydmVkIGJldHdlZW4gY2FsbHMgdG8gYGZsdXNoYCBzbyB0aGF0IGl0IGNhbiBiZSByZXN1bWVkIGlmXG4vLyBhIHRhc2sgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbnZhciBpbmRleCA9IDA7XG4vLyBJZiBhIHRhc2sgc2NoZWR1bGVzIGFkZGl0aW9uYWwgdGFza3MgcmVjdXJzaXZlbHksIHRoZSB0YXNrIHF1ZXVlIGNhbiBncm93XG4vLyB1bmJvdW5kZWQuIFRvIHByZXZlbnQgbWVtb3J5IGV4Y2F1c3Rpb24sIHRoZSB0YXNrIHF1ZXVlIHdpbGwgcGVyaW9kaWNhbGx5XG4vLyB0cnVuY2F0ZSBhbHJlYWR5LWNvbXBsZXRlZCB0YXNrcy5cbnZhciBjYXBhY2l0eSA9IDEwMjQ7XG5cbi8vIFRoZSBmbHVzaCBmdW5jdGlvbiBwcm9jZXNzZXMgYWxsIHRhc2tzIHRoYXQgaGF2ZSBiZWVuIHNjaGVkdWxlZCB3aXRoXG4vLyBgcmF3QXNhcGAgdW5sZXNzIGFuZCB1bnRpbCBvbmUgb2YgdGhvc2UgdGFza3MgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbi8vIElmIGEgdGFzayB0aHJvd3MgYW4gZXhjZXB0aW9uLCBgZmx1c2hgIGVuc3VyZXMgdGhhdCBpdHMgc3RhdGUgd2lsbCByZW1haW5cbi8vIGNvbnNpc3RlbnQgYW5kIHdpbGwgcmVzdW1lIHdoZXJlIGl0IGxlZnQgb2ZmIHdoZW4gY2FsbGVkIGFnYWluLlxuLy8gSG93ZXZlciwgYGZsdXNoYCBkb2VzIG5vdCBtYWtlIGFueSBhcnJhbmdlbWVudHMgdG8gYmUgY2FsbGVkIGFnYWluIGlmIGFuXG4vLyBleGNlcHRpb24gaXMgdGhyb3duLlxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgd2hpbGUgKGluZGV4IDwgcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBjdXJyZW50SW5kZXggPSBpbmRleDtcbiAgICAgICAgLy8gQWR2YW5jZSB0aGUgaW5kZXggYmVmb3JlIGNhbGxpbmcgdGhlIHRhc2suIFRoaXMgZW5zdXJlcyB0aGF0IHdlIHdpbGxcbiAgICAgICAgLy8gYmVnaW4gZmx1c2hpbmcgb24gdGhlIG5leHQgdGFzayB0aGUgdGFzayB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICBxdWV1ZVtjdXJyZW50SW5kZXhdLmNhbGwoKTtcbiAgICAgICAgLy8gUHJldmVudCBsZWFraW5nIG1lbW9yeSBmb3IgbG9uZyBjaGFpbnMgb2YgcmVjdXJzaXZlIGNhbGxzIHRvIGBhc2FwYC5cbiAgICAgICAgLy8gSWYgd2UgY2FsbCBgYXNhcGAgd2l0aGluIHRhc2tzIHNjaGVkdWxlZCBieSBgYXNhcGAsIHRoZSBxdWV1ZSB3aWxsXG4gICAgICAgIC8vIGdyb3csIGJ1dCB0byBhdm9pZCBhbiBPKG4pIHdhbGsgZm9yIGV2ZXJ5IHRhc2sgd2UgZXhlY3V0ZSwgd2UgZG9uJ3RcbiAgICAgICAgLy8gc2hpZnQgdGFza3Mgb2ZmIHRoZSBxdWV1ZSBhZnRlciB0aGV5IGhhdmUgYmVlbiBleGVjdXRlZC5cbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgcGVyaW9kaWNhbGx5IHNoaWZ0IDEwMjQgdGFza3Mgb2ZmIHRoZSBxdWV1ZS5cbiAgICAgICAgaWYgKGluZGV4ID4gY2FwYWNpdHkpIHtcbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IHNoaWZ0IGFsbCB2YWx1ZXMgc3RhcnRpbmcgYXQgdGhlIGluZGV4IGJhY2sgdG8gdGhlXG4gICAgICAgICAgICAvLyBiZWdpbm5pbmcgb2YgdGhlIHF1ZXVlLlxuICAgICAgICAgICAgZm9yICh2YXIgc2NhbiA9IDAsIG5ld0xlbmd0aCA9IHF1ZXVlLmxlbmd0aCAtIGluZGV4OyBzY2FuIDwgbmV3TGVuZ3RoOyBzY2FuKyspIHtcbiAgICAgICAgICAgICAgICBxdWV1ZVtzY2FuXSA9IHF1ZXVlW3NjYW4gKyBpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxdWV1ZS5sZW5ndGggLT0gaW5kZXg7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUubGVuZ3RoID0gMDtcbiAgICBpbmRleCA9IDA7XG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxucmF3QXNhcC5yZXF1ZXN0Rmx1c2ggPSByZXF1ZXN0Rmx1c2g7XG5mdW5jdGlvbiByZXF1ZXN0Rmx1c2goKSB7XG4gICAgLy8gRW5zdXJlIGZsdXNoaW5nIGlzIG5vdCBib3VuZCB0byBhbnkgZG9tYWluLlxuICAgIC8vIEl0IGlzIG5vdCBzdWZmaWNpZW50IHRvIGV4aXQgdGhlIGRvbWFpbiwgYmVjYXVzZSBkb21haW5zIGV4aXN0IG9uIGEgc3RhY2suXG4gICAgLy8gVG8gZXhlY3V0ZSBjb2RlIG91dHNpZGUgb2YgYW55IGRvbWFpbiwgdGhlIGZvbGxvd2luZyBkYW5jZSBpcyBuZWNlc3NhcnkuXG4gICAgdmFyIHBhcmVudERvbWFpbiA9IHByb2Nlc3MuZG9tYWluO1xuICAgIGlmIChwYXJlbnREb21haW4pIHtcbiAgICAgICAgaWYgKCFkb21haW4pIHtcbiAgICAgICAgICAgIC8vIExhenkgZXhlY3V0ZSB0aGUgZG9tYWluIG1vZHVsZS5cbiAgICAgICAgICAgIC8vIE9ubHkgZW1wbG95ZWQgaWYgdGhlIHVzZXIgZWxlY3RzIHRvIHVzZSBkb21haW5zLlxuICAgICAgICAgICAgZG9tYWluID0gcmVxdWlyZShcImRvbWFpblwiKTtcbiAgICAgICAgfVxuICAgICAgICBkb21haW4uYWN0aXZlID0gcHJvY2Vzcy5kb21haW4gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIGBzZXRJbW1lZGlhdGVgIGlzIHNsb3dlciB0aGF0IGBwcm9jZXNzLm5leHRUaWNrYCwgYnV0IGBwcm9jZXNzLm5leHRUaWNrYFxuICAgIC8vIGNhbm5vdCBoYW5kbGUgcmVjdXJzaW9uLlxuICAgIC8vIGByZXF1ZXN0Rmx1c2hgIHdpbGwgb25seSBiZSBjYWxsZWQgcmVjdXJzaXZlbHkgZnJvbSBgYXNhcC5qc2AsIHRvIHJlc3VtZVxuICAgIC8vIGZsdXNoaW5nIGFmdGVyIGFuIGVycm9yIGlzIHRocm93biBpbnRvIGEgZG9tYWluLlxuICAgIC8vIENvbnZlbmllbnRseSwgYHNldEltbWVkaWF0ZWAgd2FzIGludHJvZHVjZWQgaW4gdGhlIHNhbWUgdmVyc2lvblxuICAgIC8vIGBwcm9jZXNzLm5leHRUaWNrYCBzdGFydGVkIHRocm93aW5nIHJlY3Vyc2lvbiBlcnJvcnMuXG4gICAgaWYgKGZsdXNoaW5nICYmIGhhc1NldEltbWVkaWF0ZSkge1xuICAgICAgICBzZXRJbW1lZGlhdGUoZmx1c2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH1cblxuICAgIGlmIChwYXJlbnREb21haW4pIHtcbiAgICAgICAgZG9tYWluLmFjdGl2ZSA9IHByb2Nlc3MuZG9tYWluID0gcGFyZW50RG9tYWluO1xuICAgIH1cbn1cbiIsInZhciBDbG91ZCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvY2xvdWQnKVxuICAgIC5pbmplY3QoXG4gICAgICByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9uZXR3b3JrL2Nsb3VkL2RhdGFjbG91ZCcpLFxuICAgICAgcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9hdXRoZW50aWNhdGUnKVxuICAgICksXG4gIFZhbHVlID0gcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlJyksXG4gIERhdGEgPSByZXF1aXJlKCd2aWdvdXItanMvZGF0YScpLFxuICB1dGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwnKSxcbiAgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpLFxuICB1YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL3VhJyksXG4gIHJhZiA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9yYWYnKVxuXG4vLyB2YXIgc2VtdmVyID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvc2VtdmVyJylcblxucmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKSAvLyBtdXN0YmVjb21lIGluamVjdGFibGUgb24gb2JqZWN0ICggYWxsIHRoZXNlIGV4dGVuc2lvbiBzaG91bGQgYmUgbG9jYXRlZCBzZXBlcmF0ZWx5IClcblxuZnVuY3Rpb24gc2V0Q2xpZW50SW5mbyAoY2xvdWQsIGJhc2UpIHtcbiAgLy8gdG9kbzogbW92ZSBjbGllbnQgdG8gY2xvdWRcbiAgXG4gIHZhciBvbGRjbGllbnQgPSBjbG91ZC5jbGllbnQuZnJvbS5yYXdcbiAgdmFyIG9iaiA9IG9sZGNsaWVudCBcbiAgICA/IHsgXG4gICAgICAgIHRpdGxlOiBvbGRjbGllbnQudGl0bGUsXG4gICAgICAgIGRldmljZTogb2xkY2xpZW50LmRldmljZSxcbiAgICAgICAgaW5mbzogb2xkY2xpZW50LmluZm9cbiAgICAgIH1cbiAgICA6IHt9XG4gIGZpbHRlckVtcHR5KG9iailcblxuICB2YXIgY2xpZW50ID0gY2xvdWQuZGF0YS5nZXQoWydjbGllbnRzJywgY2xvdWQuY2xpZW50aWRdKSxcbiAgICB0aXRsZSwgZGV2aWNlLCBjYXN0SWRcblxuICB2YXIgaW5mbyA9IGNhc2VzLnRvdWNoIFxuICAgID8gdWEuZGV2aWNlICsgJyAnICsgXG4gICAgICAoIHVhLnBsYXRmb3JtID09PSAnaW9zJyA/ICdpT1MnIDogdWEucGxhdGZvcm0gKSArXG4gICAgICAoIHVhLnZlcnNpb24gPyAnICcgKyB1YS52ZXJzaW9uIDogJycgKVxuICAgIDogdWEucGxhdGZvcm0gKyAnICcgKyB1YS5icm93c2VyICsgJyAnICsgdWEudmVyc2lvblxuXG4gIGlmIChjYXNlcy4kaXNJb3MpIHtcbiAgICB0aXRsZSA9IHVhLmRldmljZSA9PT0gJ3Bob25lJyA/ICdpcGhvbmUnIDogJ2lwYWQnXG4gICAgZGV2aWNlID0gdWEuZGV2aWNlXG4gIH0gZWxzZSB7XG4gICAgaWYgKHVhLnBsYXRmb3JtID09PSAnYXBwbGV0dicpIHtcbiAgICAgIHRpdGxlID0gJ0FwcGxlIFRWJ1xuICAgICAgZGV2aWNlID0gJ2Nhc3QnXG4gICAgfSBlbHNlIGlmIChjYXNlcy4kaXNDaHJvbWVjYXN0KSB7XG4gICAgICB0aXRsZSA9ICdDaHJvbWVjYXN0J1xuICAgICAgZGV2aWNlID0gJ2Nhc3QnXG4gICAgICBjYXN0SWQgPSB3aW5kb3cuc2Vzc2lvbklkXG4gICAgfSBlbHNlIHtcbiAgICAgIGRldmljZSA9IHVhLmRldmljZVxuICAgICAgdGl0bGUgPSBjYXNlcy4kaXNEZXNrdG9wID8gdWEucGxhdGZvcm0gOiB1YS5wbGF0Zm9ybSArICcgJyArIGRldmljZVxuICAgIH1cbiAgfVxuXG4gIHV0aWwubWVyZ2UoIG9iaiwge1xuICAgIHRpdGxlOiB0aXRsZSxcbiAgICBkZXZpY2U6IGRldmljZSxcbiAgICBpbmZvOiBpbmZvXG4gIH0sIGZhbHNlLCBmYWxzZSApXG5cbiAgaWYgKGNhc3RJZCkge1xuICAgIG9iai5jYXN0SWQgPSBjYXN0SWQgfHwgZmFsc2VcbiAgfVxuXG4gIC8vIGNsaWVudC5tZXJnZShvYmosIGZhbHNlLCBmYWxzZSlcbiAgY2xpZW50LnZhbCA9IG9ialxuICBjbG91ZC5jbGllbnQudmFsID0gY2xpZW50XG5cbiAgLy8gREVCVUcgTE9HUzogXG4gIC8vIGNsb3VkLmNsaWVudC5vbihmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tKXtcbiAgLy8gICAvLyBjb25zb2xlLmxvZygnXFxuXFxuXFxuXFxudXBkYXRlIGtlbmtlcicsIHZhbCwgZnJvbSlcbiAgLy8gICB2YXIgb3JpZ2luID0gZnJvbSB8fCB0aGlzLl91cGRhdGVPcmlnaW5cbiAgLy8gICBpZih2YWwgJiYgdmFsLnRva2VuIHx8IChvcmlnaW4gJiYgb3JpZ2luLl9uYW1lID09PSAndG9rZW4nKSkge1xuICAvLyAgICAgY29uc29sZS5lcnJvcignVE9LRU5TRVRUT0tFTlNFVFRPS0VOU0VUJywgdmFsICYmICh2YWwudG9rZW4gfHwgdmFsKSApXG4gIC8vICAgfVxuICAvLyB9KVxuXG4gIC8vIHVzZXIuY2xpZW50VXNlclRva2VuID0gdXNlci5jbGllbnQuZnJvbS5nZXQoJ3VzZXJUb2tlbicpIGRlemUgaXMgZHVpZGVsaWprIGZ1Y2tlZCB1cCBhbmQgaGFzIHRvIGJlIGZpeGVkXG59XG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoIHJlcXVpcmUoJy4vdmFsdWVzJyksIGZ1bmN0aW9uIChiYXNlKSB7XG4gIHZhciBfY2xvdWQgPSBuZXcgQ2xvdWQobmV3IFZhbHVlKCkpXG4gICAgLCBfZmlyc3QgLy89IHRydWVcbiAgXG4gIGNhc2VzLiRpc0Nvbm5lY3RlZCA9IG5ldyBWYWx1ZSggX2Nsb3VkLmNvbm5lY3RlZCApXG5cbiAgLy8gdG9kbzogbW92ZSB0byBjbG91ZFxuICBfY2xvdWQuY2xpZW50ID0gbmV3IFZhbHVlKClcblxuICBfY2xvdWQub25jZSgnd2VsY29tZScsIGZ1bmN0aW9uIChpZCkge1xuICAgIHNldENsaWVudEluZm8oX2Nsb3VkLCBiYXNlKVxuICB9KVxuXG4gIC8vIF9jbG91ZC5vbigncmVjb25uZWN0JywpXG4gIC8vIGNvbnNvbGUuZXJyb3IoJz4+PiBhZGRpbmcgcmVjb25uZWN0IGxpc3RlbmVyJylcbiAgX2Nsb3VkLm9uKCdyZWNvbm5lY3QnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnPj4+PiByZWNvbm5lY3Qgc2V0IHVwIHJlc2V0IGNsaWVudCBpbmZvIScsIF9jbG91ZC5jbGllbnQuZnJvbS5yYXcpXG4gICAgdmFyIHNldE9iaiA9IHt9XG4gICAgX2Nsb3VkLmNsaWVudC5mcm9tLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgaWYoaSAhPT0gJ2tleScgJiYgaSAhPT0gJ3R5cGUnICYmIGkgIT09ICdpcCcpe1xuICAgICAgICBzZXRPYmpbaV0gPSB0aGlzLl92YWxcbiAgICAgIH1cbiAgICB9KVxuICAgIF9jbG91ZC5jbGllbnQuZnJvbS5vbigncmVtb3ZlJywgZnVuY3Rpb24oKSB7XG4gICAgICBpZihPYmplY3Qua2V5cyhzZXRPYmopLmxlbmd0aCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVzZXQgZGF0IGNsaWVudCBpbmZvJywgc2V0T2JqKVxuICAgICAgICBfY2xvdWQuZGF0YS5jbGllbnRzLnNldChfY2xvdWQuY2xpZW50aWQsIHNldE9iailcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuXG4gIGJhc2UuZGVmaW5lKHtcbiAgICBjbG91ZDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfY2xvdWRcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgaWYgKHV0aWwuaXNPYmoodmFsKSkge1xuICAgICAgICAgIGlmICh2YWwuZmFzdExvZ2luKSB7XG4gICAgICAgICAgICBfY2xvdWQuZmFzdExvZ2luLnZhbCA9IHRydWVcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodmFsLmFwaSkge1xuICAgICAgICAgICAgX2Nsb3VkLmFwaS52YWwgPSB2YWwuYXBpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHZhbC51cmwpIHtcbiAgICAgICAgICAgIF9jbG91ZC51cmwudmFsID0gdmFsLnVybFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfY2xvdWQudXJsLnZhbCA9IHZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHZhciBfdmVyc2lvbiA9IG5ldyBEYXRhKCBfY2xvdWQuZGF0YS5nZXQoJ2FwcCcpLCB7IHN1YnNjcmlwdGlvbjogeyAkOnRydWUgfSB9IClcblxuICAvL3NlbXZhciAtLSBBUFAgVkVSU0lPTiBET0VTIE5PVCBXT1JLIVxuICBiYXNlLnZlcnNpb25EYXRhID0gbmV3IFZhbHVlKHtcbiAgICB2YWw6IF92ZXJzaW9uLFxuICAgIGRlZmVyOiBmdW5jdGlvbih1cGRhdGUsIGFyZ3MpIHtcbiAgICAgIHZhciBkb1VwZGF0ZVxuICAgICAgdmFyIHRcbiAgICAgIGlmKHRoaXMuZnJvbS52ZXJzaW9uKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZXkgaGV5IGhleScpXG4gICAgICAgIGlmKCAhd2luZG93LnBhY2thZ2UgKSBcbiAgICAgICAge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdubyB3aW5kb3cgcGFja2FnZScsIHdpbmRvdy5wYWNrYWdlIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld3ZlcnNpb24gPSB0aGlzLmZyb20udmVyc2lvbi52YWxcbiAgICAgICAgICAgICwgb2xkdmVyc2lvbiA9IHdpbmRvdy5wYWNrYWdlLnZlcnNpb25cblxuICAgICAgICAgIGlmKG5ld3ZlcnNpb24gJiYgb2xkdmVyc2lvbikge1xuICAgICAgICAgICAgbmV3dmVyc2lvbiA9IG5ld3ZlcnNpb24uc3BsaXQoJy4nKVxuICAgICAgICAgICAgb2xkdmVyc2lvbiA9IG9sZHZlcnNpb24uc3BsaXQoJy4nKVxuICAgICAgICAgICAgbmV3dmVyc2lvbiA9IE51bWJlcihuZXd2ZXJzaW9uWzFdKVxuICAgICAgICAgICAgb2xkdmVyc2lvbiA9IE51bWJlcigob2xkdmVyc2lvblsxXXx8MCkpXG4gICAgICAgICAgICBpZiggbmV3dmVyc2lvbiA+IG9sZHZlcnNpb24gKSB7XG4gICAgICAgICAgICAgIGRvVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgICAgICB3aW5kb3cucGFja2FnZS52ZXJzaW9uID0gdGhpcy5mcm9tLnZlcnNpb24udmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IFxuICAgICAgdXBkYXRlKCBkb1VwZGF0ZSA/IHZvaWQgMCA6IHRydWUgKVxuICAgIH1cbiAgfSlcblxufSlcblxuXG5mdW5jdGlvbiBmaWx0ZXJFbXB0eShvYmopIHtcbiAgZm9yKHZhciBmIGluIG9iaikge1xuICAgIGlmKG9ialtmXSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxldGUgb2JqW2ZdXG4gICAgfVxuICB9XG59XG4iLCJ2YXIgVmFsdWUgPSByZXF1aXJlKCcuLi92YWx1ZScpXG4gICwgQ2xvdWREYXRhID0gcmVxdWlyZSggJy4uL2Jyb3dzZXIvbmV0d29yay9jbG91ZC9kYXRhJyApXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIHZPYmogPSByZXF1aXJlKCcuLi9vYmplY3QnKVxuXG5cbnV0aWwuZGVmaW5lXG4oIENsb3VkRGF0YVxuLCAnX2NvbnRlbnRQYXRoJ1xuLCB7IGdldDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcCA9IHRoaXMuX3BhdGhcbiAgICAgIGZvcih2YXIgaSBpbiBwICkge1xuICAgICAgICBpZiggcFtpXSA9PT0gJ3Nob3dzJyB8fCBwW2ldID09PSAnY2hhbm5lbHMnICkge1xuICAgICAgICAgIHJldHVybiBwLnNsaWNlKCBpIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmVycm9yKCdfY29udGVudFBhdGggdXNlZCBvbiBub24tY29udGVudCBkYXRhJywgdGhpcywgcClcbiAgICAgIC8vIHRocm93IG5ldyBFcnJvcignX2NvbnRlbnRQYXRoIHVzZWQgb24gbm9uLWNvbnRlbnQgZGF0YScpXG4gICAgICAvLyByZXR1cm4gdGhpcy5fcGF0aC5zbGljZSggYmFzZS5pbnN0YW5jZXNbMF0uZGF0YS5mcm9tLl9wYXRoLmxlbmd0aCApXG4gICAgfVxuICB9XG4pXG5cbnV0aWwuZGVmaW5lKFxuICB2T2JqXG4sICdfY29udGVudFR5cGUnXG4sIHsgZ2V0OmZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGZyb20gPSB0aGlzLmZyb21cbiAgICAgIGlmKCBmcm9tLmNsb3VkICYmIGZyb20uX3BhcmVudCApIHJldHVybiBmcm9tLl9wYXJlbnQuX25hbWVcbiAgICB9XG4gIH1cbilcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZCggXG4gIHJlcXVpcmUoJy4vdmFsdWVzJylcbiwgcmVxdWlyZSgnLi9jbG91ZCcpXG4sIGZ1bmN0aW9uKCBhcHAgKSB7XG4gICAgdmFyIGNvbnRlbnQgPSBhcHAuY29udGVudCA9IG5ldyBWYWx1ZSh7fSlcbiAgICAvLyB2YXIgZ2V0ID0gVmFsdWUucHJvdG90eXBlLmdldFxuICAgIHV0aWwuZGVmaW5lKGNvbnRlbnQsICdnZXQnLCBmdW5jdGlvbigpe1xuICAgICAgICBpZiggdGhpcy5fdmFsICYmIHRoaXMuX3ZhbC5jbG91ZCApIHsgXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbC5nZXQuYXBwbHkodGhpcy5fdmFsLCBhcmd1bWVudHMpIFxuICAgICAgICB9IGVsc2UgeyBcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdhcHAuY29udGVudCAsIGRvbnQgaGF2ZSBjbG91ZCBkYXRhIScpIFxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgYXBwLnJlZ2lvbi5vbihvbkNoYW5nZSlcbiAgICBhcHAubGFuZ3VhZ2Uub24ob25DaGFuZ2UpXG5cbiAgICBvbkNoYW5nZSgpXG5cbiAgICBmdW5jdGlvbiBvbkNoYW5nZSgpe1xuICAgICAgdmFyIHJlZ2lvbiA9IGFwcC5yZWdpb24udmFsXG4gICAgICAgICwgbGFuZ3VhZ2UgPSBhcHAubGFuZ3VhZ2UudmFsXG5cbiAgICAgIC8vVE9ETzptYWtlIHRoaXMgY29uZmlndXJhYmxlIGluIHRoZSBhcHBcbiAgICAgIGlmKGxhbmd1YWdlPT09J2l0Jykge1xuICAgICAgICBsYW5ndWFnZSA9ICdlbidcbiAgICAgIH1cblxuICAgICAgaWYocmVnaW9uICYmIGxhbmd1YWdlKXtcbiAgICAgICAgLy9UT0RPOiBtYWtlIG10dkRhdGEgY29uZmlndXJhYmxlXG4gICAgICAgIC8vIGNvbnRlbnQudmFsID0gYXBwLmNsb3VkLmRhdGEuZ2V0KFsnbXR2RGF0YScsIHJlZ2lvbiwgbGFuZ3VhZ2VdKVxuXG4gICAgICAgIC8vIGNvbnRlbnQudmFsID0gYXBwLmNsb3VkLmRhdGFcblxuICAgICAgfVxuICAgICAgY29udGVudC52YWwgPSBhcHAuY2xvdWQuZGF0YVxuICAgIH1cbiAgICBcbiAgfVxuKVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogXG4gKiBjb3VsZCB0aGluayBvZiBzb21ldGhpbmcgc28gc3R5bGUgcmVxdWlyZXMgYXJlIHBhcnNlZCBvcHRpb25hbHlcbiAqIG1heWJlIGluIHZpZ291ci1qcyB1c2UgZHluYW1pYyBzY3JpcHQgdGFncyBhbmQgcGFyc2UgdGhvc2UgL3cgZ2FzdG9uIGlmIHlvdSBhcmUgdXNpbmcgZ2FzdG9uXG4gKiB0aGlzIHdpbGwgbWFrZSBpdCBtb3JlIHVzYWJsZSBmb3Igb3RoZXJzIGluIHRoZSBmdXR1cmUgYW5kIG1ha2VzIGl0IGNvbXBhdGlibGUgd2l0aCBwdXJlIGJyb3dzZXJpZnlcbiAqL1xuXG5yZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxucmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL2Vhc2luZycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgnLi91aS9lbGVtZW50JylcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcbiAgLCBhbmltYXRpb24gPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24nKVxuICAsIGV2ZW50cyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy9hZHZhbmNlZCcpXG4gICwgdWEgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci91YScpXG4gICwgcmFmID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy91dGlsJylcbiAgLCBhcHBcbiAgLCBfaW9zID0gdWEucGxhdGZvcm09PT0naW9zJ1xuICAsIF93aW5kb3dzID0gdWEucGxhdGZvcm0gPT09ICd3aW5kb3dzJ1xuICAsIGFyciA9IFsncGhvbmUnLCd0YWJsZXQnLCd0dicsJ2Rlc2t0b3AnLCdpb3MnLCdhbmRyb2lkJywnd2luZG93cycsJ21hYycsJyRoYXNUb3VjaCcsJ3Nsb3cnLCdjaHJvbWVjYXN0J10gLy9tYXliZSBtYWtlIHRoaXMgY29uZmlncmFibGVcbiAgLy91aS9jYXNlcyAtLVxuICAsIGkgPSBhcnIubGVuZ3RoIC0gMVxuXG4vL2hpZXIgcHJvY2VzcyBpbiByZXF1aXJlbiBlbiBhZGRlZCAnYXBwU3RhcnQnIG9mem9pZXRzIGRlcmdlbGlqa3Ncbi8vYWRkIG9vayBwcm9jZXNzIGFhbiBiYXNlIGRpbmdlbiBkYW4gd29yZCBpZXRzIHBhcyBnZWFkZCBuYSBlZW4gYmVwYWFsZGUgcHJvY2VzcyB1cGRhdGVcbi8vdWx0cmEgbW9mbyBwb3dlcmZ1bGxcblxuY2FzZXMuJGlzSW9zQnJvd3NlciA9IF9pb3MgJiYgKCAnc3RhbmRhbG9uZScgaW4gbmF2aWdhdG9yICYmICFuYXZpZ2F0b3Iuc3RhbmRhbG9uZSApXG5jYXNlcy4kaXNJb3NGdWxsID0gKCFjYXNlcy4kaXNJb3NCcm93c2VyJiZfaW9zKSB8fCAoKF9pb3MgfHwgX3dpbmRvd3MpICYmICEhd2luZG93LmNvcmRvdmEpIHx8IGZhbHNlXG5jYXNlcy4kaXNSZXRpbmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDFcbmNhc2VzLiRpc1Nsb3cgPSAoX3dpbmRvd3MgJiYgdWEuZGV2aWNlID09PSAncGhvbmUnKSB8fCAodWEubm9SYWYmJnVhLmhhc1RyYW5zaXRpb24pIHx8IF9pb3MgJiYgKHdpbmRvdy5zY3JlZW4uaGVpZ2h0ID09PSAoOTYwIC8gMikpIHx8IHVhLmRldmljZSA9PT0gJ3R2J1xuY2FzZXMuJGlzTmF0aXZlID0gd2luZG93LmNvcmRvdmEgPyB0cnVlIDogZmFsc2VcbmNhc2VzLiRpc1dpbmRvd3NNb2JpbGUgPSB1YS5wbGF0Zm9ybSA9PT0gJ3dpbmRvd3MnICYmIHVhLmRldmljZSA9PT0gJ3Bob25lJyAmJiAhIXdpbmRvdy5jb3Jkb3ZhXG5jYXNlcy4kaXNQaG9uZUJyb3dzZXIgPSB1YS5kZXZpY2UgPT09ICdwaG9uZScgJiYgISggY2FzZXMuJGlzTmF0aXZlIHx8IGNhc2VzLiRpc0lvc0Z1bGwgKVxuLy9wYWNrZXIgY2FzZSB2b29yIHdlYiAvLyBuYXRpdmVcblxuYXBwID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gICd4LHknOnt2YWw6MCxjbGVhbjp0cnVlLHRyYW5zbGF0ZTp0cnVlfVxuLCBub2RlOiBkb2N1bWVudC5ib2R5XG4sIHc6IHdpbmRvdy5pbm5lcldpZHRoXG4sIGg6IHdpbmRvdy5pbm5lckhlaWdodFxuLCBjc3M6ICdhcHAnXG59KVxuXG4vL2lmKGNhc2VzLiRpc2lvc0Z1bGwpIHtcbiAgLy8gYXBwLnkgPSB7YWRkOjIwfVxuICAvLyBhcHAuaCA9IHtzdWI6MjB9XG4vL31cblxudmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG4vLyAgIGNvbnNvbGUubG9nKCdyZXNpemUhIScsJ3c6Jyx3aW5kb3cuaW5uZXJXaWR0aCwnaDonLHdpbmRvdy5pbm5lckhlaWdodCwnYmxvY2s/OicsYXBwLmJsb2NrUmVzaXplKVxuICBpZighYXBwLmJsb2NrUmVzaXplKSB7XG4gICAgLy8gYW5pbWF0aW9uLnByZXZlbnQgPSB0cnVlXG4gICAgYXBwLncudmFsID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBhcHAuaC52YWwgPSB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAvLyBhbmltYXRpb24ucHJldmVudCA9IGZhbHNlXG4gIH0gZWxzZSB7XG4gICAgYXBwLmJsb2NrUmVzaXplID0gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q2FzZShzdHIpIHtcbiAgaWYoc3RyICE9PSAnJGhhc1RvdWNoJyl7XG4gICAgdmFyIGNzc1N0ciA9ICAncycgKyBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gICAgdmFyIGNhc2VTdHIgPSAnJGknICsgY3NzU3RyXG4gICAgaWYoY2FzZXNbY2FzZVN0cl09PT12b2lkIDApIHtcbiAgICAgIGNhc2VzW2Nhc2VTdHJdID0gKHVhLmRldmljZSA9PT0gc3RyIHx8IHVhLnBsYXRmb3JtID09PSBzdHIpID8gdHJ1ZSA6IGZhbHNlXG4gICAgfVxuICAgIGFwcC5jc3MgPSB7YWRkQ2xhc3M6Y2FzZXNbY2FzZVN0cl0gPyAnaScgKyBjc3NTdHIgOiAnbm90SScrIGNzc1N0cn1cbiAgfWVsc2V7XG4gICAgYXBwLmNzcyA9IHthZGRDbGFzczpjYXNlcy4kaGFzVG91Y2ggPyAnaGFzVG91Y2gnIDogJ25vdEhhc1RvdWNoJ31cbiAgfVxufVxuXG4vLyBsaXN0ZW5lciA9IGV2ZW50VXRpbHMudGhyb3R0bGUobGlzdGVuZXIsNjApXG4vLyBsaXN0ZW5lciA9XG4vLyBjYXNlcy4kaXNub0NhbGMgPSAhdXRpbC5oYXNDYWxjKClcbi8vY2FzZSB0b28gc2VlIGlmIGFwcCBpcyBydW5uaW5nIGluIGEgYnJvd3NlciBvbiBpb3MgKGxpbWl0cyB2aWRlbyBjYXBhYmlsaXRpZXMpXG5cbmlmKGNhc2VzLiRpc3RvdWNoKSBldmVudHMuZG9jdW1lbnQuYWRkRXZlbnQoJ21vdmUnLGZ1bmN0aW9uKGUpIHtcbiAgaWYoIWV2ZW50cy5fbWF5YmVzY3JvbGwgJiYgIWV2ZW50cy5fc2V0c2Nyb2xsKSBlLnByZXZlbnREZWZhdWx0KClcbn0sJ2FwcCcpXG5cbmlmKCdvcmllbnRhdGlvbicgaW4gd2luZG93KSB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb3JpZW50YXRpb25jaGFuZ2UnLGxpc3RlbmVyKVxuaWYoIV9pb3MpIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLGxpc3RlbmVyKVxuXG4vL2FkZGluZyAjPGNhc2U+IGluIHVybCBmb3JjZXMgY2FzZSwgbXVsdGlwbGUgaGFzaGVzID09PiBtdWx0aXBsZSBjYXNlc1xuLy90aGlzIGlzIGZvciB0ZXN0aW5nIHB1cnBvc2VzICwgYWRkIGRldmVsb3BtZW50IGluZGVudGlmaWVyIGZvciBjb21waWxlclxuXG4vL3RoaXMgaGFzIHRvIGdvXG5pZih3aW5kb3cubG9jYXRpb24uaGFzaCkge1xuICB2YXIgaGFzaENhc2VzID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3BsaXQoJyMnKVsxXVxuICAgICwgeCA9IGhhc2hDYXNlcy5zcGxpdCgnLCcpXG5cbiAgZm9yKHZhciBqIGluIHgpIHtcbiAgICB2YXIgeSA9IHhbal0uc3BsaXQoJz0nKVxuICAgIHVhW3lbMF1dID0geVsxXVxuICB9XG4gIFxufVxuXG5pZih1YS5kZXZpY2UgPT09ICd0dicpIHtcbiAgY2FzZXMuJGlzU2xvdyA9IHRydWVcbn1cblxuZm9yKDtpID49IDA7KSBkZWZhdWx0Q2FzZShhcnJbaS0tXSlcblxuXG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCcuLi8uLi8uLi9icm93c2VyL2VsZW1lbnQnKVxuXG5yZXF1aXJlKCcuLi8uLi8uLi92YWx1ZS9mbGFncy9wYXJlbnQnKVxucmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUvZmxhZ3Mvc2VsZicpXG5yZXF1aXJlKCcuLi8uLi8uLi92YWx1ZS9mbGFncy9wcm9jZXNzJylcbnJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlL2ZsYWdzL3V0aWwnKVxucmVxdWlyZSgnLi4vLi4vLi4vYnJvd3Nlci9ldmVudHMnKVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4gIEVsZW1lbnRcbiAgLmluamVjdFxuICAoIHJlcXVpcmUoJy4uLy4uLy4uL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2NvbGxlY3Rpb24nKVxuICAsIHJlcXVpcmUoJy4uLy4uLy4uL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzJylcbiAgLCByZXF1aXJlKCcuLi8uLi8uLi9icm93c2VyL2VsZW1lbnQvcHJvcGVydGllcy9zY3JvbGxiYXInKVxuICAsIHJlcXVpcmUoJy4uLy4uLy4uL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL3Byb2Nlc3MnKVxuICAsIHJlcXVpcmUoJy4uLy4uLy4uL3ZhbHVlL29uJylcbiAgKVxuXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi9icm93c2VyL2V2ZW50cy91dGlsJykgXG4gICwgc3ByaXRlID0gbmV3IEVsZW1lbnQoeyBcbiAgICAndyxoJzo1MCxcbiAgICB4Ont0cmFuc2xhdGU6dHJ1ZSx2YWw6MH1cbiAgfSlcblxuc3ByaXRlLmV4dGVuZCh7IG5hbWU6ICdwYXJhbXMnIC8vdGhpcyBoYXMgdG8gY29tZSBmcm9tIHVpIChlbGVtZW50KVxuICAsIHR5cGU6IGZhbHNlXG4gICwgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICB0aGlzLl9wYXJhbXMgPSB2YWxcbiAgICB0aGlzLkNsYXNzLnByb3RvdHlwZS5fcGFyYW1zID0gdmFsIC8vdGVtcD9cbiAgfVxufSlcblxuc3ByaXRlLnNldFNldHRpbmcoe1xuICBuYW1lOidzcGlubmVyJyxcbiAgcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpc1xuICAgICAgLCBwYXJhbXMgPSB0aGlzLl9wYXJhbXMgfHwge31cbiAgICAgICwgc3RhcnQgPSBwYXJhbXMuc3RhcnQgfHwgMFxuICAgICAgLCBzcGVlZCA9IHBhcmFtcy5mcmFtZXMgfHwgM1xuICAgICAgLCByb3dzID0gcGFyYW1zLnJvd3MgfHwgMVxuICAgICAgLCBjb2xzID0gcGFyYW1zLmNvbHMgfHwgMCAvL2lnbm9yZVxuICAgICAgLCBvbmNlID0gcGFyYW1zLm9uY2VcbiAgICAgICwgY250ID0gc3RhcnRcbiAgICAgICwgc3RlcHMgPSAocGFyYW1zLnN0ZXBzIHx8IChyb3dzKmNvbHMtc3RhcnQpIHx8IDE5KVxuICAgICAgLCBjdXJSb3cgPSAwXG4gICAgICAsIGN1ckNvbCA9IDBcblxuICAgIGlmKCF0LmRpc3BsYXkgfHwgIXQuZGlzcGxheS5fYmFzZT09PXQpIHtcbiAgICAgIHQuZGlzcGxheSA9IHQuZGlzcGxheSAmJiB0LmRpc3BsYXkudmFsIHx8ICdibG9jaydcbiAgICB9XG4gICAgdC5kaXNwbGF5LmFkZExpc3RlbmVyKFtkaXNwbGF5TGlzdGVuZXIsdF0sdHJ1ZSlcblxuICAgIHQubm9kZS5zdHlsZS5iYWNrZ3JvdW5kU2l6ZSA9IHRoaXMudy52YWwqY29scysncHggYXV0bydcbiAgICAvL3JlbWViZXIgd2hlcmUgaXQgd2FzIHBlcmhhcHMgaWYgcmUtcmVuZGVyZWRcbiAgICBpZih0LmRpc3BsYXkudmFsPT09J25vbmUnKSByZXR1cm5cblxuICAgIHQuX3NwaW5uZXIgPSB1dGlsLmludGVydmFsKGZ1bmN0aW9uKCkgeyAvL3Rlc3QgaW50ZXJ2YWwgZm9yIGxlYWtzXG4gICAgICB0Lm5vZGUuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID0gXG4gICAgICAgICgtdC53LnZhbCpjdXJDb2wpKydweCAnKyhyb3dzID8gKC10LmgudmFsKmN1clJvdykgOiAwKSsncHgnXG4gICAgICBjbnQrK1xuICAgICAgaWYoY250ID09PSBzdGVwcykge1xuICAgICAgICBjbnQgPSBzdGFydFxuICAgICAgICBpZihvbmNlKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignWFhYWFgnKVxuICAgICAgICAgIHJlbW92ZVJhZi5jYWxsKHQpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN1clJvdyA9IHJvd3MgPyB+fihjbnQvY29scykgOiAwXG4gICAgICBjdXJDb2wgPSBjbnQtKGN1clJvdykqY29sc1xuICAgIH0sc3BlZWQpXG4gIH0sXG4gIHJlbW92ZTpyZW1vdmVSYWZcbn0pXG5cbmZ1bmN0aW9uIHJlbW92ZVJhZigpIHtcbiAgICAgLy8gYWxlcnQoJ2xldHMgcmVtb3ZlIHRoaXMgYmFkYm95JylcblxuICBpZih0aGlzLl9zcGlubmVyKSB7XG4gICAgdGhpcy5fc3Bpbm5lcigpXG4gICAgdGhpcy5fc3Bpbm5lciA9IG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwbGF5TGlzdGVuZXIgKHZhbCkge1xuICBpZih2YWwudmFsPT09J25vbmUnKSB7XG4gICAgcmVtb3ZlUmFmLmNhbGwodGhpcylcbiAgfSBlbHNlIHtcbiAgICBpZighdGhpcy5fc3Bpbm5lcikgdGhpcy5zZXR0aW5nKCdyZW5kZXInKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3ByaXRlLkNsYXNzXG5cblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9iYXNlJylcbiAgLCBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudCcpXG4gICwgVmFsdWUgPSByZXF1aXJlKCd2aWdvdXItanMvdmFsdWUnKVxuICAsIFZPYmplY3QgPSByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0JylcbiAgLCBzd2l0Y2hlciA9IG5ldyBFbGVtZW50KClcbiAgLCBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcblxuZnVuY3Rpb24gZXh0ZW5kRmFjdG9yeSggZmllbGQgKXtcbiAgcmV0dXJuIHsgbmFtZTpmaWVsZFxuICAsIHR5cGU6ZmFsc2VcbiAgLCBzZXQ6ZnVuY3Rpb24oIGZuICl7XG4gICAgICBpZihmbiBpbnN0YW5jZW9mIEZ1bmN0aW9uKVxuICAgICAge1xuICAgICAgICB2YXIgc2V0ID0ge31cbiAgICAgICAgc2V0WydfJytmaWVsZF0gPSBmblxuICAgICAgICB0aGlzLmRlZmluZShzZXQpXG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3Byb3BlcnR5ICcgKyBmaWVsZCArICcgbmVlZHMgdG8gYmUgYSBmdW5jdGlvbicpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cblZhbHVlLmZsYWdzLiRwYXJhbXMgPSB7XG4gIHNldDpmdW5jdGlvbiggdmFsICkge1xuICAgIHRoaXMucGFyYW1zID0gdmFsXG4gIH1cbn1cblxuVmFsdWUuZmxhZ3MuJG9wdGlvbnMgPSB7XG4gIHNldDpmdW5jdGlvbiggdmFsICkge1xuICAgIHRoaXMub3B0aW9ucyA9IHZhbFxuICB9XG59XG5cbnN3aXRjaGVyLmV4dGVuZFxuKCB7IGxvYWRlcjp7fVxuICAsIGFuaW1hdGlvbjp7fVxuICAsIGRlbGF5Ont9XG4gICwgZG9uZTp7fVxuICAsIGZvcmNlOnt9XG4gICwgYmFja0ZhbGxiYWNrOlxuICAgIHsgY2FjaGU6ZmFsc2VcbiAgICAvLyAsIHNldDpmdW5jdGlvbigpe31cbiAgICB9XG4gICwgb25UcmFuc2l0aW9uOlxuICAgIHsgY2FjaGU6ZmFsc2VcbiAgICAvLyAsIHNldDpmdW5jdGlvbigpe31cbiAgICB9XG4gICwgdHJhbnNpdGlvbjpcbiAgICB7IGNhY2hlOmZhbHNlXG4gICAgLCBzZXQ6ZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICB2YXIgZWxlbWVudCA9IHZhbC5lbGVtZW50ICYmIHZhbC5lbGVtZW50Ll92YWxcbiAgICAgICAgICAsIHBhcmFtcyA9IHZhbC5wYXJhbXNcbiAgICAgICAgICAsIG9wdGlvbnMgPSB2YWwub3B0aW9ucyB8fCB7fVxuICAgICAgICAgICwgZm9yY2UgPSBvcHRpb25zICYmIG9wdGlvbnMuZm9yY2VcbiAgICAgICAgICAsIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuICAgICAgICAgICwgbGFzdCA9IHRoaXMuX3N3RWxlbSB8fCBjaGlsZHJlblswXVxuICAgICAgICAgICwgYmFzZSA9IGVsZW1lbnQgJiYgZWxlbWVudC5iYXNlXG4gICAgICAgICAgLCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aFxuICAgICAgICAgICwgY3VycmVudFxuICAgICAgICAgICwgY2hpbGRcbiAgICAgICAgICAsIGRpcmVjdGlvblxuICAgICAgICAgICwgX3RoaXMgPSB0aGlzXG5cbiAgICAgICAgLy9pZiB0aGVyZSBhcmUgb2xkIGxvYWRpbmcgbGlzdGVuZXJzIHJlbW92ZSB0aGVzZVxuICAgICAgICBpZiggdGhpcy5fbG9hZGluZyApXG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLl9sb2FkaW5nWzFdLnJlbW92ZUxpc3RlbmVyKCB0aGlzLl9sb2FkaW5nWzBdIClcbiAgICAgICAgICB0aGlzLl9sb2FkaW5nID0gdm9pZCAwXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiggX3RoaXMuX3RpbWVyICl7XG4gICAgICAgIC8vICAgY2xlYXJUaW1lb3V0KCBfdGhpcy5fdGltZXIgKVxuICAgICAgICAvLyAgIF90aGlzLl90aW1lciA9IG51bGxcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvcHRpb25zPyEnLmdyZWVuLmludmVyc2Usb3B0aW9ucylcbiAgICAgICAgLy9pcyBpdCB0aGUgc2FtZSAsIGlzIGl0IG5vdCB0aGUgc2FtZSB3aGF0dXAhXG4gICAgICAgIGlmKCBiYXNlICYmIGJhc2UgaW5zdGFuY2VvZiBFbGVtZW50IHx8IGVsZW1lbnQgPT09IEVsZW1lbnQgKVxuICAgICAgICB7IFxuICAgICAgICAgIGlmKCAhZm9yY2UgJiYgdGhpcy5fc3dFbGVtICYmIHRoaXMuX3N3RWxlbSBpbnN0YW5jZW9mIGVsZW1lbnQgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX3N3RWxlbS5zZXQoIHBhcmFtcyApXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCBvbGQgcGFnZXMsIHJlbW92ZSB0aGVzZVxuICAgICAgICAgICAgaWYoIGNoaWxkcmVuTGVuZ3RoID4gMSApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvciAoIGkgPSBjaGlsZHJlbkxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICkgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgICAgICAgICAgaWYoIGNoaWxkICE9PSBsYXN0ICkgY2hpbGQucmVtb3ZlKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXJlY3Rpb24gPSB0aGlzLl9kaXJlY3Rpb24gPSB2YWwuZGlyZWN0aW9uICYmIHZhbC5kaXJlY3Rpb24uX3ZhbFxuICAgICAgICAgICAgaWYoIG9wdGlvbnMgJiYgb3B0aW9ucy5sb2FkZXIgJiYgIW9wdGlvbnMubG9hZGVyLiRsb2FkZWQgKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiggIXRoaXMubG9hZGVyIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoICdubyBsb2FkZXIgZGVmaW5lZCEnIClcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHZhciBsb2FkZXIgPSBuZXcgdGhpcy5sb2FkZXIuX3ZhbC5DbGFzcygpXG5cbiAgICAgICAgICAgICAgaWYoIG9wdGlvbnMubG9hZGVyIGluc3RhbmNlb2YgVk9iamVjdCApIC8vVE9ETzogdGhpcyBoYXMgZ290dGVuIFZFUlkgZGlydHkgPiBjbGVhbiB0aGlzIHVwIVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5kb25lID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgIGlmKCAhY3VycmVudCApIGN1cnJlbnQgPSBuZXcgZWxlbWVudCggcGFyYW1zIClcbiAgICAgICAgICAgICAgICAgIGlmKCBsb2FkZXIuX3JlbW92ZSApXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZG9uZSA9IHZvaWQgMFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlbGF5ID0gY2FzZXMudGFibGV0ID8gNDAwIDogMjAwIC8vZGl0IGlzIG5hdHV1cmxpamsgYWJzdXJkXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiggX3RoaXMuX3N3RWxlbSBpbnN0YW5jZW9mIGVsZW1lbnQgKVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N3RWxlbS5zZXQoIHBhcmFtcyApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgX3RoaXMub25UcmFuc2l0aW9uLl92YWwuY2FsbCggX3RoaXMsIGN1cnJlbnQsIF90aGlzLl9zd0VsZW0gLCAwLCBvcHRpb25zIClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlbGF5ID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBvcHRpb25zLmxvYWRlci5fcGF0aFxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRpbmcgPSBbIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgLy8gaWYoIF90aGlzLl90aW1lciApe1xuICAgICAgICAgICAgICAgICAgLy8gICBjbGVhclRpbWVvdXQoIF90aGlzLl90aW1lciApXG4gICAgICAgICAgICAgICAgICAvLyAgIF90aGlzLl90aW1lciA9IG51bGxcbiAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgIGxvYWRlci5fcmVtb3ZlID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgaWYoIGN1cnJlbnQgJiYgb3B0aW9ucy5kb25lICkgb3B0aW9ucy5kb25lKClcblxuICAgICAgICAgICAgICAgIH0sIG9wdGlvbnMubG9hZGVyIF1cblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdhZGQgdGhlIGxpc3RlbmVyIGZvcicscGF0aClcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkaW5nWzFdLmlzKCdsb2FkZWQnLCB0aGlzLl9sb2FkaW5nWzBdIClcbiAgICAgICAgICAgICAgICAvLyBfdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCB0aGlzLl9sb2FkaW5nWzBdLCA1MDAwIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLmRvbmUgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgaWYoICFjdXJyZW50ICkgY3VycmVudCA9IG5ldyBlbGVtZW50KCBwYXJhbXMgKVxuXG4gICAgICAgICAgICAgICAgICBvcHRpb25zLmRvbmUgPSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVsYXkgPSAyMDBcblxuICAgICAgICAgICAgICAgICAgaWYoIF90aGlzLl9zd0VsZW0gaW5zdGFuY2VvZiBlbGVtZW50IClcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N3RWxlbS5zZXQoIHBhcmFtcyApXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9uVHJhbnNpdGlvbi5fdmFsLmNhbGwoIF90aGlzLCBjdXJyZW50LCBfdGhpcy5fc3dFbGVtICwgMCwgb3B0aW9ucyApXG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVsYXkgPSB2b2lkIDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvcHRpb25zLmxvYWRlciA9IHZvaWQgMFxuXG4gICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uLl92YWwuY2FsbCggdGhpcywgbG9hZGVyLCBsYXN0LCBkaXJlY3Rpb24sIG9wdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGN1cnJlbnQgPSBuZXcgZWxlbWVudChwYXJhbXMpXG4gICAgICAgICAgICAgIG9wdGlvbnMuZG9uZSA9IHZvaWQgMFxuICAgICAgICAgICAgICBvcHRpb25zLmRlbGF5ID0gdm9pZCAwXG4gICAgICAgICAgICAgIG9wdGlvbnMubG9hZGVyID0gdm9pZCAwXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB0aGlzLm9uVHJhbnNpdGlvbi5fdmFsLmNhbGwoIHRoaXMsIGN1cnJlbnQsIGxhc3QgLCBkaXJlY3Rpb24sIG9wdGlvbnMgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggb3B0aW9ucy5hbmltYXRpb24gIT09IHZvaWQgMCApIG9wdGlvbnMuYW5pbWF0aW9uID0gdm9pZCAwXG4gICAgICAgICAgICBpZiggb3B0aW9ucy5kZWxheSApIG9wdGlvbnMuZGVsYXkgPSB2b2lkIDBcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKHBhcmFtcylcbiAgICAgICAge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ29ubHkgcGFyYW1zIGRlZmluZWQhJywgcGFyYW1zKVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYocGFyYW1zKVxuICAgICAgICB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignbm8gcGFyYW1zIGFuZCBubyBlbGVtZW50IGRlZmluZWQhJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuKVxuXG5zd2l0Y2hlci5kZWZpbmVcbih7IGJhY2s6ZnVuY3Rpb24oKXsgLy9yZW1vdmUgYmFjayBsb2dpYyBmcm9tIHN3aXRjaGVyICh5b3UgY2FuJ3QgaXNvbGF0ZSBpdCEgaWUgd2hlbiB5b3UgbGFuZCBvbiBwYWdlLCB3aGF0IGlzIGJhY2s/KVxuICAgICAgdGhpcy5iYWNrRmFsbGJhY2suX3ZhbC5jYWxsKCB0aGlzIClcblx0XHR9XG4gICwgYWRkOmZ1bmN0aW9uKCBlbGVtZW50LCBwcmV2aW91cyApe1xuICAgICAgY29uc29sZS5sb2coJ2FkZC0tLT4nLGVsZW1lbnQpXG4gICAgICB0aGlzLl9zd0VsZW0gPSBlbGVtZW50XG5cbiAgICAgIC8vIHRyeVxuICAgICAgLy8ge1xuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5hZGQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAvLyB9XG4gICAgICAvLyBjYXRjaChlcnIpXG4gICAgICAvLyB7XG4gICAgICAvLyAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIGFkZGluZyB0aGUgbmV3IGVsZW1lbnQnLGVycixhcmd1bWVudHMpXG4gICAgICAvLyB9XG4gICAgfVxuXHR9XG4pXG5cbnN3aXRjaGVyLmV4dGVuZFxuKCB7IG5hbWU6J29uJ1xuICAsIHNldDpmdW5jdGlvbiggdmFsICkge1xuICAgICAgLy8gc2V0IGhpc3RvcnkgdmFyaWFibGUgZm9yIGFsbFxuICAgICAgLy8gdmFsLmVhY2goZnVuY3Rpb24oKXtcbiAgICAgIC8vICAgdmFyIGZyb20gPSB0aGlzLiR1c2VyT3JpZ2luLnZhbFxuICAgICAgLy8gICBpZighZnJvbSkgcmV0dXJuXG4gICAgICAvLyAgIGlmKCFmcm9tLl9oaXN0b3J5KSBmcm9tLnNldCgnaGlzdG9yeScsdHJ1ZSlcbiAgICAgIC8vICAgaWYoIXRoaXMuX19jaGVja2VkKVxuICAgICAgLy8gICB7XG4gICAgICAvLyAgICAgdGhpcy5vbihmdW5jdGlvbigpe1xuICAgICAgLy8gICAgICAgdmFyIGNhbGxlciA9IHRoaXMuX3BhcmVudC5fY2FsbGVyXG4gICAgICAgICAgICBcbiAgICAgIC8vICAgICAgIGlmKCFjYWxsZXIuX2JhY2tTdG9yZSlcbiAgICAgIC8vICAgICAgIHsgXG4gICAgICAvLyAgICAgICAgIGNhbGxlci5fYmFja1N0b3JlID0gWyB0aGlzIF1cbiAgICAgIC8vICAgICAgIH1cbiAgICAgIC8vICAgICAgIGVsc2UgaWYoY2FsbGVyLl9kaXJlY3Rpb24gPT09IC0xKVxuICAgICAgLy8gICAgICAge1xuICAgICAgLy8gICAgICAgICBpZihjYWxsZXIuX2JhY2tTdG9yZVsxXSAhPT0gdm9pZCAwKSBjYWxsZXIuX2JhY2tTdG9yZS5zaGlmdCgpXG4gICAgICAvLyAgICAgICAgIGVsc2UgY2FsbGVyLl9iYWNrU3RvcmUgPSBbIHRoaXMgXVxuICAgICAgLy8gICAgICAgfVxuICAgICAgLy8gICAgICAgZWxzZSBpZihjYWxsZXIuX2RpcmVjdGlvbiA9PT0gMSlcbiAgICAgIC8vICAgICAgIHtcbiAgICAgIC8vICAgICAgICAgY2FsbGVyLl9iYWNrU3RvcmUudW5zaGlmdCggdGhpcyApXG4gICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgIC8vICAgICB9KVxuICAgICAgLy8gICAgIHRoaXMuX19jaGVja2VkID0gdHJ1ZVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9KVxuICAgIH1cbiAgLCByZW1vdmU6ZnVuY3Rpb24oKXsgLy8gY3JlYXRlIHJlZnMgdG8gb3JpZ2luYWxcbiAgICAgIGlmKCB0aGlzLl9sb2FkaW5nIClcbiAgICAgIHtcbiAgICAgICAgdGhpcy5fbG9hZGluZ1sxXS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9sb2FkaW5nWzBdKVxuICAgICAgICB0aGlzLl9sb2FkaW5nID0gbnVsbFxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiggdGhpcy5fc3dUaW1lciApIGNsZWFyVGltZW91dCggdGhpcy5fc3dUaW1lciApXG4gICAgICBpZiggdGhpcy5fdGltZXIgKSBjbGVhclRpbWVvdXQoIHRoaXMuX3RpbWVyIClcblxuICAgICAgaWYoIHRoaXMub24uJHJlbW92ZSApIHRoaXMub24uJHJlbW92ZS51cGRhdGUoKVxuICAgIH1cbiAgLCBuZXc6ZnVuY3Rpb24oKXtcbiAgICAgIGlmKCB0aGlzLm9uLiRuZXcgKSB0aGlzLm9uLiRuZXcudXBkYXRlKClcbiAgICB9XG4gIH1cbilcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgc3dpdGNoZXIuQ2xhc3MoKS5DbGFzcyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTUsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJyksXG4gIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbihiYXNlKSB7XG4gIGJhc2Uuc2V0KHtcbiAgICBvblRyYW5zaXRpb246IHtcbiAgICAgIGRlZmVyOiBmdW5jdGlvbih1cGRhdGUpIHsgLy9vYnNjdXJlIHRyYW5zZm9ybVxuICAgICAgICBpZiAoZXhwb3J0c1t0aGlzLl92YWxdKSB0aGlzLl92YWwgPSBleHBvcnRzW3RoaXMuX3ZhbF1cbiAgICAgICAgdXBkYXRlKClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59KVxuXG4vL3NsaWRlIHRyYW5zaXRpb25cbmV4cG9ydHMuc2xpZGUgPSBmdW5jdGlvbihjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgaWYgKGRpcmVjdGlvbiAmJiBsYXN0KSBhbmltYXRlKHRoaXMsIGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbiwgb3B0aW9ucylcbiAgZWxzZSBiYXNpYyh0aGlzLCBjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24sIG9wdGlvbnMpXG59XG5cbi8vZmFkZSB0cmFuc2l0aW9uXG5leHBvcnRzLmZhZGUgPSBmdW5jdGlvbihjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgYmFzaWModGhpcywgY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uLCBvcHRpb25zKVxufVxuXG4vL2Jhc2ljIHRyYW5zaXRpb25cbmZ1bmN0aW9uIGJhc2ljKF90aGlzLCBjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGRvbmUgPSBvcHRpb25zLmRvbmUsXG4gICAgbm9BbmltYXRpb24gPSBvcHRpb25zLmFuaW1hdGlvbiA9PT0gZmFsc2UsXG4gICAgZGVsYXkgPSBvcHRpb25zLmRlbGF5XG5cbiAgaWYgKGxhc3QpIHtcbiAgICBhZGQoX3RoaXMsIGN1cnJlbnQsIGxhc3QpXG5cbiAgICBpZiAobm9BbmltYXRpb24pIHtcbiAgICAgIHJlbW92ZShfdGhpcywgbGFzdClcbiAgICAgIGFkZChfdGhpcywgY3VycmVudClcblxuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgaWYgKGRlbGF5KSB7XG4gICAgICAgICAgdGltZXIoX3RoaXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZG9uZSkgb3B0aW9ucy5kb25lKClcbiAgICAgICAgICB9LCBkZWxheSlcbiAgICAgICAgfSBlbHNlIGRvbmUoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGVsYXkpIHtcbiAgICAgIHRpbWVyKF90aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgZmFkZShfdGhpcywgbGFzdCwgb3B0aW9ucylcbiAgICAgIH0sIGRlbGF5KVxuICAgIH0gZWxzZSBmYWRlKF90aGlzLCBsYXN0LCBvcHRpb25zKVxuICB9IGVsc2UgYWRkKF90aGlzLCBjdXJyZW50LCBmYWxzZSwgZG9uZSlcbn1cblxuLy9hbmltYXRlZCB0cmFuc2l0aW9uXG5mdW5jdGlvbiBhbmltYXRlKF90aGlzLCBjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24sIG9wdGlvbnMpIHtcbiAgdmFyIGFuaW1hdGlvblRpbWUgPSAyMCAvLyBtYWtlIHRoaXMgY29uZmlndXJhYmxlXG4gICAgLFxuICAgIGFwcFdpZHRoID0gYXBwLncudmFsLFxuICAgIGN1cnJlbnRTdGFydCwgZm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gMSxcbiAgICBsYXN0RW5kXG5cbiAgaWYgKGZvcndhcmQpIHtcbiAgICBjdXJyZW50U3RhcnQgPSBhcHBXaWR0aFxuICAgIGxhc3RFbmQgPSBhcHBXaWR0aCAvIC0zXG4gIH0gZWxzZSB7XG4gICAgY3VycmVudFN0YXJ0ID0gYXBwV2lkdGggLyAtM1xuICAgIGxhc3RFbmQgPSBhcHBXaWR0aFxuICB9XG5cbiAgaWYgKGNhc2VzLiRpc1dpbmRvd3MpIHtcbiAgICBjdXJyZW50LnggPSB7XG4gICAgICB0cmFuc2xhdGU6IHRydWUsXG4gICAgICB2YWw6IGN1cnJlbnRTdGFydFxuICAgIH1cblxuICAgIGxhc3QueCA9IHtcbiAgICAgIHRyYW5zbGF0ZTogdHJ1ZSxcbiAgICAgIHZhbDogMFxuICAgIH1cblxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICBjdXJyZW50LnggPSAwXG4gICAgICBsYXN0LnggPSBsYXN0RW5kXG5cbiAgICAgIHRpbWVyKF90aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVtb3ZlKF90aGlzLCBsYXN0LCBvcHRpb25zLmRvbmUpXG4gICAgICB9LCAyMTApXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBjdXJyZW50LnggPSB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgc3RhcnQ6IGN1cnJlbnRTdGFydCxcbiAgICAgICAgdGltZTogYW5pbWF0aW9uVGltZSxcbiAgICAgICAgZGVsYXk6IDEsXG4gICAgICAgIGVhc2luZzogJ291dEN1YmljJyxcbiAgICAgICAgZG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVtb3ZlKF90aGlzLCBsYXN0LCBvcHRpb25zLmRvbmUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2YWw6IDBcbiAgICB9XG5cbiAgICBsYXN0LnggPSB7XG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgdGltZTogYW5pbWF0aW9uVGltZSxcbiAgICAgICAgZGVsYXk6IDIsXG4gICAgICAgIGVhc2luZzogJ291dEN1YmljJ1xuICAgICAgfSxcbiAgICAgIHZhbDogbGFzdEVuZFxuICAgIH1cbiAgfVxuXG4gIGlmICghZm9yd2FyZCkgYWRkKF90aGlzLCBjdXJyZW50LCBsYXN0KVxuICBlbHNlIGFkZChfdGhpcywgY3VycmVudClcblxufVxuXG5mdW5jdGlvbiBhZGQoX3RoaXMsIHRvQWRkLCBiZWZvcmUsIGRvbmUpIHtcbiAgaWYgKHRvQWRkKSBfdGhpcy5hZGQodG9BZGQsIGJlZm9yZSlcbiAgaWYgKGRvbmUpIGRvbmUoKVxufVxuXG5mdW5jdGlvbiBmYWRlKF90aGlzLCBsYXN0LCBvcHRpb25zKSB7XG4gIGxhc3Qub3BhY2l0eSA9IDBcbiAgbGFzdC5ub2RlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSdcbiAgdGltZXIoX3RoaXMsIGZ1bmN0aW9uKCkge1xuICAgIHJlbW92ZShfdGhpcywgbGFzdCwgb3B0aW9ucy5kb25lKVxuICB9LCAyMDApXG59XG5cbmZ1bmN0aW9uIHJlbW92ZShfdGhpcywgdG9SZW1vdmUsIGRvbmUpIHtcbiAgaWYgKHRvUmVtb3ZlKSB0b1JlbW92ZS5yZW1vdmUoKVxuICBpZiAoZG9uZSkgZG9uZSgpXG59XG5cbmZ1bmN0aW9uIHRpbWVyKF90aGlzLCBmbiwgdGltZSkge1xuICBpZiAoX3RoaXMuX3N3VGltZXIpIHtcbiAgICBjbGVhclRpbWVvdXQoX3RoaXMuX3N3VGltZXIpXG4gICAgX3RoaXMuX3N3VGltZXIgPSBudWxsXG4gIH1cbiAgX3RoaXMuX3N3VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGZuLmNhbGwoX3RoaXMpXG4gICAgX3RoaXMuX3N3VGltZXIgPSBudWxsXG4gIH0sIHRpbWUpXG59XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuXG5yZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy9wcm9jZXNzJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZFxuKCBmdW5jdGlvbiggYmFzZSApIHtcbiAgICAvLyBiYXNlXG4gICAgYmFzZS5leHRlbmRcbiAgICAoIFxuICAgICAgeyBpZDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgdmFyIGlkID0gdmFsLnZhbFxuXG4gICAgICAgICAgaWYoIGlkICYmIHRoaXMuY2xvdWQgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSB0aGlzLmNsb3VkLmRhdGEuZ2V0KFsgJ3VzZXJzJywgaWQgXSlcbiAgICAgICAgICB9IFxuICAgICAgICAgIGVsc2UgaWYoICFpZCApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIHRoaXMuZGF0YSA9IHZvaWQgMFxuICAgICAgICAgICAgLy9UT0RPOiB0aGlzIHdvcmtzIGJ1Z2d5IGluIHZhbHVlcyAtLS0gdm9pZCAwIGRvZXMgbm90IHVwZGF0ZSBkYXRhLCBtYXliZSBqdXN0IHVzZSBmYWxzZSBmb3Igbm93XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYmFzZS5tb2NrZGF0YScpXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBiYXNlLm1vY2tkYXRhXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAsIGRhdGE6IHtcbiAgICAgICAgICAvL21vY2tkYXRhIG9uIHN0YXJ0IGNhbiBicmVhayBldmVyeXRoaW5nIGRvd25cbiAgICAgICAgICB2YWw6IGJhc2UubW9ja2RhdGEgLFxuICAgICAgICAgIHNldDpmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgICAgdmFyIHVzZXIgPSB0aGlzXG5cbiAgICAgICAgICAgIC8vIGlmKCF0aGlzLmZpcnN0KSB7XG4gICAgICAgICAgICAgIC8vIHRoaXMuZmlyc3QgPSB0cnVlXG4gICAgICAgICAgICAvLyB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZih1c2VyLmluc3RhbmNlcyAmJiB1c2VyLmluc3RhbmNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvciAoJy0tIHRtcCBmaXggZGF0YSBvbiBiYXNlIHN3aXRjaCB0byBpbnN0YW5jZVswXScgKVxuICAgICAgICAgICAgICAvL1RPRE86IHRoaXMgaXMgYSBoYWNreSBzb2x1dGlvbiEgZml4IGxhdGVyXG4gICAgICAgICAgICAgIHVzZXIgPSB1c2VyLmluc3RhbmNlc1swXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiggdmFsLmZyb20uY2xvdWQgICkgXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmKCB1c2VyLl9fX2MgIT09IHZhbC5mcm9tICkgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB1c2VyLmluaXRpYWxpc2VkID0gbnVsbFxuICAgICAgICAgICAgICAgIHVzZXIuX19fYyA9IHZhbC5mcm9tXG4gICAgICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gdXNlci5vbi51c2VyKSB7XG4gICAgICAgICAgICAgICAgICB1c2VyLm9uLnVzZXJba2V5XS5jYWxsKCB1c2VyLCBrZXkgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1c2VyLmluaXRpYWxpc2VkID0gdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiggdXNlci5fX19jID09PSBmYWxzZSApIHJldHVyblxuICAgICAgICAgICAgICB1c2VyLl9fX2MgPSBmYWxzZVxuICAgICAgICAgICAgICBmb3IodmFyIGtleSBpbiB1c2VyLm9uLnVzZXIpIHtcbiAgICAgICAgICAgICAgICB1c2VyLm9uLm1vY2tba2V5XS5jYWxsKCB1c2VyLCBrZXkgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVzZXIuaW5pdGlhbGlzZWQgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcblxufSlcbiIsInJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzL3NlbGYnKVxucmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG5yZXF1aXJlKCcuLi8uLi92YWx1ZS9mbGFncy91dGlsJylcbiAgLy9UT0RPOiBjbGVhbiB0aGVzZSB0byB3b3JrIC93IGluamVjdFxuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKSxcbiAgVmFsdWUgPSByZXF1aXJlKCcuLi8uLi92YWx1ZScpLFxuICBCYXNlID0gcmVxdWlyZSgnLi4vLi4vYmFzZScpLFxuICBEYXRhID0gcmVxdWlyZSgnLi4vLi4vZGF0YScpLFxuICB2T2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JykuaW5qZWN0KFxuICAgIHJlcXVpcmUoJy4vb3JpZ2luJylcbiAgKSxcbiAgdGltZXN0YW1wID0gcmVxdWlyZSgnbW9ub3RvbmljLXRpbWVzdGFtcCcpLFxuICBfc3Vic2NyaXB0aW9ucyA9IHt9LFxuICBNb2NrRGF0YSA9IHJlcXVpcmUoJy4vbW9ja2RhdGEnKSxcbiAgbW9ja2RhdGEgPSBuZXcgTW9ja0RhdGEoe30pXG4gIC8vIG1ha2UgbW9ja2RhdGEgdmFpbGFibGVcblxudmFyIF9leHRlbmQgPSBCYXNlLnByb3RvdHlwZS5leHRlbmRcblxudmFyIHVzZXIgPSBuZXcgQmFzZSh7XG4gIGRlZmF1bHRUeXBlOiByZXF1aXJlKCcuL3R5cGUnKVxufSlcblxudXNlci5kZWZpbmUoe1xuICBzdWJzY3JpcHRpb25zOiB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gX3N1YnNjcmlwdGlvbnNcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgaWYgKHZhbCkgdXRpbC5tZXJnZShfc3Vic2NyaXB0aW9ucywgdmFsKVxuICAgIH1cbiAgfSxcbiAgbW9ja2RhdGE6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtb2NrZGF0YVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICBpZiAodmFsKSBtb2NrZGF0YS5tZXJnZSh2YWwpXG4gICAgfVxuICB9LFxuICBvbjoge1xuICAgIHZhbHVlOiB7XG4gICAgICBtb2NrOiB7fSxcbiAgICAgIHVzZXI6IHt9XG4gICAgfVxuICB9XG4sIGV4dGVuZDogZnVuY3Rpb24oIHNldHRpbmdzICkge1xuXG4gICAgaWYoc2V0dGluZ3MubW9jaykge1xuICAgICAgdGhpcy5tb2NrZGF0YSA9IHNldHRpbmdzLm1vY2tcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gX2V4dGVuZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG5cbiAgICBpZihzZXR0aW5ncy52YWwgIT09IHZvaWQgMCkge1xuICAgICAgdGhpc1tzZXR0aW5ncy5uYW1lXSA9IHNldHRpbmdzLnZhbFxuICAgIH1cblxuICAgIGlmKCBzZXR0aW5ncy5vbiApIHtcblxuICAgICAgaWYoIHR5cGVvZiBzZXR0aW5ncy5vbiA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgc2V0dGluZ3Mub24uY2FsbCggdGhpcywgc2V0dGluZ3MubmFtZSApIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoIHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEuY2xvdWQgKSB7XG4gICAgICAgICAgc2V0dGluZ3Mub24udXNlciAmJiBzZXR0aW5ncy5vbi51c2VyLmNhbGwoIHRoaXMsIHNldHRpbmdzLm5hbWUgKSBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXR0aW5ncy5vbi5tb2NrICYmIHNldHRpbmdzLm9uLm1vY2suY2FsbCggdGhpcywgc2V0dGluZ3MubmFtZSApIFxuICAgICAgICB9XG4gICAgICB9ICAgIFxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfVxufSlcblxuLy8gdXNlclxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKFxuICByZXF1aXJlKCcuLi9jbG91ZCcpLFxuICBmdW5jdGlvbiAoYmFzZSkge1xuICAgIHZhciBhcHB1c2VyID0gYmFzZS51c2VyID0gbmV3IHVzZXIuQ2xhc3MoKS5pbmplY3QoXG4gICAgICByZXF1aXJlKCcuL3NldCcpLFxuICAgICAgcmVxdWlyZSgnLi9pZCcpXG4gICAgICAvL2luamVjdCBwYXMgb3AgZXh0ZW5kPz8/XG4gICAgKVxuICAgIGFwcHVzZXIucGFyZW50ID0gYmFzZVxuICAgIGFwcHVzZXIuY2FzZXMgPSBiYXNlLmNhc2VzXG4gICAgYXBwdXNlci5jbG91ZCA9IGJhc2UuY2xvdWRcbiAgfVxuKSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgRGF0YSA9IHJlcXVpcmUoJy4uLy4uL2RhdGEnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBEYXRhLm5ldygpICBcblxudXRpbC5kZWZpbmUoIGV4cG9ydHMsXG4nZ2V0JywgZnVuY3Rpb24oIHZhbCwgc2V0LCBub3RzZWxmICkge1xuICByZXR1cm4gdGhpcy5wYXRoXG4gICggKHZhbCBpbnN0YW5jZW9mIEFycmF5KSA/IHZhbCA6IFN0cmluZyh2YWwpLnNwbGl0KCcuJylcbiAgLCBzZXQgIT09IHZvaWQgMCA/IHNldCA6IHt9XG4gICwgZmFsc2VcbiAgLCBmYWxzZVxuICAsIGZhbHNlXG4gICwgZmFsc2VcbiAgLCB0cnVlXG4gICwgIW5vdHNlbGZcbiAgKVxufSlcblxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbCcpLFxuICBWYWx1ZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZScpLFxuICBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJyksXG4gIERhdGEgPSByZXF1aXJlKCd2aWdvdXItanMvZGF0YScpLmluamVjdChcbiAgICByZXF1aXJlKCd2aWdvdXItanMvZGF0YS9zZWxlY3Rpb24nKSAgICBcbiAgKSxcbiAgQ29tcG91bmQgPSByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0L2NvbXBvdW5kJyksXG4gIGV2ZW50cyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cycpLFxuICB1YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL3VhJyksXG4gIHJhZiA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9yYWYnKVxuXG52YXIgVk9iamVjdCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QnKVxuVk9iamVjdC5pbmplY3QoXG4gIHJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZS9sZW5ndGgnKVxuKVxuXG52YXIgSU5BQ1RJVkUgPSB0eXBlb2Ygd2luZG93ICE9PSB2b2lkIDAgJiYgd2luZG93LklOQUNUSVZFXG5cbnZhciBkZXZpY2VJc0NhbmRpZGF0ZSA9IC8oZGVza3RvcCl8KHR2KXwoY2FzdCl8KHRhYmxldCl8KGFpcnBsYXkpL2lcbmNhc2VzLiRpc0NhbmRpZGF0ZSA9IGRldmljZUlzQ2FuZGlkYXRlLnRlc3QodWEuZGV2aWNlKVxuXG52YXIgZGV2aWNlSXNUdkxpa2UgPSAvKHR2KXwoY2FzdCl8KGFpcnBsYXkpL2lcblxucmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGZ1bmN0aW9uICh1c2VyKSB7XG5cbiAgdmFyIGNvbnRlbnQgPSB1c2VyLnBhcmVudC5pbmplY3QocmVxdWlyZSgnLi4vLi4vY29udGVudCcpKS5jb250ZW50XG5cbiAgY29udGVudC5vbignc2VsZicsIGZ1bmN0aW9uKCkge1xuICAgIGlmKCB1c2VyLnRva2VuLnZhbCApIHtcbiAgICAgIGlmKHVzZXIucmVjZWl2ZXIubWVkaWEudmFsICYmIHVzZXIucmVjZWl2ZXIubWVkaWEuZnJvbSAhPT0gdXNlci5yZWNlaXZlci5tZWRpYSApIHtcbiAgICAgICAgaWYodXNlci5yZWNlaXZlci5tZWRpYS5mcm9tIT09IGNvbnRlbnQuZ2V0KCB1c2VyLnJlY2VpdmVyLm1lZGlhLmZyb20uX2NvbnRlbnRQYXRoICkpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdsZXRzIGdvIGNoYW5nZSBpdCEnLCB1c2VyLnJlY2VpdmVyLm1lZGlhKVxuICAgICAgICAgIHVzZXIucmVjZWl2ZXIubWVkaWEuJHVzZXJPcmlnaW4gPSBjb250ZW50LmdldCggdXNlci5yZWNlaXZlci5tZWRpYS5mcm9tLl9jb250ZW50UGF0aCApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IFxuICB9KVxuXG4gIC8vIGV4dGVuZCBiYXNpYyBwcm9wZXJ0aWVzXG4gIHVzZXIuZXh0ZW5kKHtcbiAgICByZWNlaXZlcjoge1xuICAgICAgbW9jazoge1xuICAgICAgICByZWNlaXZlcjoge1xuICAgICAgICAgIHZvbHVtZTogMSxcbiAgICAgICAgICBtZWRpYTogZmFsc2UsXG4gICAgICAgICAgcGxheWluZzogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHZhbDoge1xuICAgICAgICBtZWRpYToge1xuICAgICAgICAgICRidWJibGU6IHtcbiAgICAgICAgICAgIHJlZmVyZW5jZXM6e1xuICAgICAgICAgICAgICAkbHRlOjFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSl7XG4gICAgICAgICAgICB2YXIgcGxheWluZyA9IHRoaXMuX3BhcmVudC5wbGF5aW5nXG4gICAgICAgICAgICBpZihwbGF5aW5nICYmICF0aGlzLmZyb20udmFsKSBwbGF5aW5nLmZyb20udmFsID0gZmFsc2VcbiAgICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3Vic2NyaXB0aW9uOiB7XG4gICAgICAgIHJlY2VpdmVyOiB7XG4gICAgICAgICAgdm9sdW1lOiB0cnVlLFxuICAgICAgICAgIHBsYXlpbmc6dHJ1ZSxcbiAgICAgICAgICBtZWRpYToge1xuICAgICAgICAgICAgJDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIG1vY2s6IHNldE1vY2tfcmVjZWl2ZXIsXG4gICAgICAgIHVzZXI6IHNldFVzZXJfcmVjZWl2ZXJcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsaWVudHM6IHtcbiAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICBjbGllbnRzOiB7XG4gICAgICAgICAgJDoge1xuICAgICAgICAgICAgJDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIG1vY2s6IHNldENsaWVudHMsXG4gICAgICAgIHVzZXI6IHNldENsaWVudHNcbiAgICAgIH1cbiAgICB9LFxuICAgIGNhbmRpZGF0ZXM6IHsgdmFsOiB7fSB9LFxuICAgIHNpYmxpbmdzOiB7IHZhbDoge30gfSxcbiAgICByZWNlaXZlckNsaWVudDoge1xuICAgICAgdmFsOiB7fSxcbiAgICAgIG9uOiB7XG4gICAgICAgIG1vY2s6IHNldE1vY2tfcmVjZWl2ZXJDbGllbnQsXG4gICAgICAgIHVzZXI6IHNldFVzZXJfcmVjZWl2ZXJDbGllbnRcbiAgICAgIH0sXG4gICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgcmVjZWl2ZXJDbGllbnQ6e1xuICAgICAgICAgICQ6IHRydWUgIFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhY3RpdmVDbGllbnQ6IHtcbiAgICAgIHZhbDoge30sXG4gICAgICBtb2NrOiB7XG4gICAgICAgIGFjdGl2ZUNsaWVudDogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICBhY3RpdmVDbGllbnQ6e1xuICAgICAgICAgICQ6IHRydWUgIFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb246IHtcbiAgICAgICAgbW9jazogc2V0TW9ja19hY3RpdmVDbGllbnQsXG4gICAgICAgIHVzZXI6IHNldFVzZXJfYWN0aXZlQ2xpZW50XG4gICAgICB9XG4gICAgfVxuICB9KVxuICBcbiAgLy8gZXh0ZW5kIGRldmljZXMgKG5lZWRzIHNpYmxpbmdzKVxuICB1c2VyLmV4dGVuZCh7XG4gICAgZGV2aWNlczoge1xuICAgICAgdmFsOiBuZXcgQ29tcG91bmQodXNlci5zaWJsaW5ncylcbiAgICB9XG4gIH0pXG4gIFxuICAvLyBleHRlbmQgY2FzZSB2YWx1ZXNcbiAgdXNlci5leHRlbmQoe1xuICAgIGhhc1JlY2VpdmVyOiB7XG4gICAgICB2YWw6IHtcbiAgICAgICAgdmFsOiB1c2VyLnJlY2VpdmVyQ2xpZW50LFxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHZhbCwgY3YpIHtcbiAgICAgICAgICB2YXIgZW5kcG9pbnQgPSB1c2VyLnJlY2VpdmVyQ2xpZW50LmZyb21cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgZW5kcG9pbnQgJiYgIWVuZHBvaW50Ll9yZW1vdmVkICYmXG4gICAgICAgICAgICBlbmRwb2ludC5jbG91ZCAmJiBlbmRwb2ludC5fcGF0aFswXSA9PT0gJ2NsaWVudHMnXG4gICAgICAgICAgKSB8fCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlzUmVjZWl2ZXI6IHsgICAgICBcbiAgICAgIHZhbDoge1xuICAgICAgICBkZWZlcjogZnVuY3Rpb24odXBkYXRlLCBhcmdzKXtcbiAgICAgICAgICB2YXIgb3JpZ2luID0gYXJnc1syXSB8fCB0aGlzLl91cGRhdGVPcmlnaW5cbiAgICAgICAgICBpZighb3JpZ2luIHx8IFxuICAgICAgICAgICAgICEob3JpZ2luLl9wcm9wIHx8IG9yaWdpbi5fbmFtZSA9PT0gJ3JlY2VpdmVyQ2xpZW50JylcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2Jsb2NrIHVwZGF0ZScsIG9yaWdpbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdubyBibG9jaycpXG4gICAgICAgICAgdmFyIHN0YW1wID0gYXJnc1sxXVxuICAgICAgICAgIGlmKHN0YW1wICE9PSAnY2xlYW51cCcpIHtcbiAgICAgICAgICAgIGlmKHVzZXIuX2hhbmRsZU9sZElzUmVjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgaWYoIHVzZXIuX3dhc1JlY2VpdmVyICYmIFxuICAgICAgICAgICAgICAgICAgIXVzZXIuaGFzUmVjZWl2ZXIudmFsICYmXG4gICAgICAgICAgICAgICAgICAhdXNlci5pc0FjdGl2ZS52YWxcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdpIHdhcyByZWNlaXZlciBmb3IgdGhpcyBndXknLCB1c2VyLmRhdGEuX3ZhbC5yYXcpXG4gICAgICAgICAgICAgICAgdXNlci5zZXRSZWNlaXZlcih1c2VyLmNsb3VkLmNsaWVudC5mcm9tKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHVzZXIuX2hhbmRsZU9sZElzUmVjZWl2ZXIgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgICAgdXNlci5fd2FzUmVjZWl2ZXIgPSB0aGlzLnZhbFxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9LFxuICAgICAgICB2YWw6IHVzZXIucmVjZWl2ZXJDbGllbnQsXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odmFsLCBjdikge1xuICAgICAgICAgIHZhciBlbmRwb2ludCA9IHVzZXIucmVjZWl2ZXJDbGllbnQuZnJvbVxuICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlbmRwb2ludCAmJiAhZW5kcG9pbnQuX3JlbW92ZWQgJiZcbiAgICAgICAgICAgIGVuZHBvaW50LmNsb3VkICYmIGVuZHBvaW50ID09PSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG4gICAgICAgICAgKSB8fCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc0NhbmRpZGF0ZXM6IHsgXG4gICAgICB2YWw6IHsgXG4gICAgICAgIHZhbDogdXNlci5jYW5kaWRhdGVzLiRsZW5ndGgsXG4gICAgICAgICRjb252ZXJ0VHlwZTogJ2Jvb2xlYW4nXG4gICAgICB9XG4gICAgfSxcbiAgICBoYXNEZXZpY2VzOiB7XG4gICAgICB2YWw6IHsgXG4gICAgICAgIHZhbDogdXNlci5kZXZpY2VzLiRsZW5ndGgsXG4gICAgICAgICRjb252ZXJ0VHlwZTogJ2Jvb2xlYW4nXG4gICAgICB9XG4gICAgfSxcbiAgICBpc0FjdGl2ZToge1xuICAgICAgdmFsOiB7XG4gICAgICAgIGRlZmVyOiBmdW5jdGlvbih1cGRhdGUsIGFyZ3Mpe1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLSBpc0FjdGl2ZSBjaGVjayBkYXQhJylcbiAgICAgICAgICB2YXIgb3JpZ2luID0gYXJnc1syXSB8fCB0aGlzLl91cGRhdGVPcmlnaW5cbiAgICAgICAgICBpZighb3JpZ2luIHx8IFxuICAgICAgICAgICAgICEob3JpZ2luLl9wcm9wIHx8IG9yaWdpbi5fbmFtZSA9PT0gJ2FjdGl2ZUNsaWVudCcpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdubyBibG9ja2l0JywgXG4gICAgICAgICAgICAvLyAgIG9yaWdpbi5fcGF0aCxcbiAgICAgICAgICAgIC8vICAgb3JpZ2luLFxuICAgICAgICAgICAgLy8gICAnXFxudmFsOicsIGFyZ3NbMF1cbiAgICAgICAgICAgIC8vIClcbiAgICAgICAgICAgIHVwZGF0ZSh0cnVlKVxuICAgICAgICAgICAgLy8gcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHN0YW1wID0gYXJnc1sxXVxuXG4gICAgICAgICAgaWYoc3RhbXApIHtcbiAgICAgICAgICAgIGlmKHN0YW1wICE9PSAnY2xlYW51cCcpIHtcbiAgICAgICAgICAgICAgaWYodXNlci5faGFuZGxlT2xkSXNBY3RpdmUpIHtcbiAgICAgICAgICAgICAgICBpZiggdXNlci5fd2FzQWN0aXZlICYmIFxuICAgICAgICAgICAgICAgICAgICAhKCB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgdXNlci5hY3RpdmVDbGllbnQuJHVzZXJPcmlnaW4uX3ZhbFxuICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdpIHdhcyBhY3RpdmVDbGllbnQgZm9yIHRoaXMgZ3V5IFJFU0VUJylcbiAgICAgICAgICAgICAgICAgIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luID0gdXNlci5jbG91ZC5jbGllbnQuX3ZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1c2VyLl9oYW5kbGVPbGRJc0FjdGl2ZSA9IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgICAgICB1c2VyLl93YXNBY3RpdmUgPSB0aGlzLnZhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdnbyB1cGRhdGUhJylcbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9LFxuICAgICAgICB2YWw6IHVzZXIuYWN0aXZlQ2xpZW50LFxuICAgICAgICAvLyAkYnViYmxlOiB7XG4gICAgICAgIC8vICAgcmVmZXJlbmNlczogMlxuICAgICAgICAvLyB9LFxuICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChjLCBjdikge1xuICAgICAgICAgIHZhciBlbmRwb2ludCA9IHVzZXIuYWN0aXZlQ2xpZW50LmZyb21cbiAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgKGVuZHBvaW50ICYmIGVuZHBvaW50LnZhbCA9PT0gdHJ1ZSkgfHxcbiAgICAgICAgICAgIGVuZHBvaW50ID09PSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tXG4gICAgICAgICAgKSB8fCAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHNldFJlY2VpdmVyOiB7XG4gICAgICB0eXBlOiBmYWxzZSxcbiAgICAgIHZhbDogZnVuY3Rpb24oY2xpZW50KSB7XG4gICAgICAgIHZhciB1c2VyID0gdGhpc1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdzZXRSZWNlaXZlciBjYWxsZWQgbG9sJylcbiAgICAgICAgY2xpZW50ID0gY2xpZW50LmZyb21cbiAgICAgICAgaWYoIWNsaWVudCkgcmV0dXJuXG5cbiAgICAgICAgdmFyIGNhc3R0eXBlID0gY2xpZW50LmNhc3QgJiYgY2xpZW50LmNhc3QudmFsXG5cbiAgICAgICAgaWYoY2FzdHR5cGUpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnc2V0UmVjZWl2ZXIhIHVzZXIuY2FzdFtjYXN0dHlwZV0nLCB1c2VyLmNhc3RbY2FzdHR5cGVdKVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzZXRSZWNlaXZlciEgdXNlci5jYXN0W2Nhc3R0eXBlXS5zZXRSZWNlaXZlcicsIHVzZXIuY2FzdFtjYXN0dHlwZV0uc2V0UmVjZWl2ZXIpXG4gICAgICAgICAgdXNlci5jYXN0W2Nhc3R0eXBlXS5zZXRSZWNlaXZlcihjbGllbnQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpZW50LnNldCgndG9rZW4nLCB1c2VyLnRva2VuLnZhbClcbiAgICAgICAgICB1c2VyLnJlY2VpdmVyQ2xpZW50LiR1c2VyT3JpZ2luID0gY2xpZW50XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIFxuICAvLyBERUJVRzpcbiAgLy8gdXNlci5hY3RpdmVDbGllbnQub24oZnVuY3Rpb24oKXtcbiAgLy8gICBjb25zb2xlLmVycm9yKCdhY3RpdmVDbGllbnQgaGFwcGVuaW4hJywgdGhpcy5mcm9tICYmIHRoaXMuZnJvbS50b1N0cmluZygpKVxuICAvLyB9KVxuICBcbiAgLy8gdXNlci5oYXNSZWNlaXZlci5vbihmdW5jdGlvbigpe1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoJ2xvbCBoYXNSZWNlaXZlciBsaXN0ZW5lciBmaXJlcyEgdmFsOicsIHRoaXMudmFsKVxuICAvLyB9KVxuICAvLyB1c2VyLmlzUmVjZWl2ZXIub24oZnVuY3Rpb24oKXtcbiAgLy8gICBjb25zb2xlLmVycm9yKCdsb2wgaXNSZWNlaXZlciBsaXN0ZW5lciBmaXJlcyEgdmFsOicsIHRoaXMudmFsKVxuICAvLyB9KVxuICAvLyB1c2VyLmFjdGl2ZUNsaWVudC5vbihmdW5jdGlvbigpe1xuICAvLyAgIGNvbnNvbGUuZXJyb3IoJ2xvbCBhY3RpdmVDbGllbnQgbGlzdGVuZXIgZmlyZXMhIHZhbDpcXG4nLCB0aGlzLmZyb20udG9TdHJpbmcoKSlcbiAgLy8gfSlcblxuICAvLyBsaXN0ZW5lcnM6XG5cbiAgLy8gb24gYWN0aXZpdHk6IG1ha2UgbWUgYWN0aXZlQ2xpZW50XG4gIGlmKCFjYXNlcy4kaXNDaHJvbWVjYXN0ICYmICFJTkFDVElWRSkge1xuICAgIHZhciBhY3RpdmVFdmVudCA9IGNhc2VzLiRpc1R2ID8gJ2tleWRvd24nIDogJ2Rvd24nXG4gICAgZXZlbnRzLmRvY3VtZW50LmFkZEV2ZW50KGFjdGl2ZUV2ZW50LCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiggdXNlci5jbG91ZC5jbGllbnQuX3ZhbCAmJlxuICAgICAgICAgICEoY2FzZXMuJGlzRnVsbHNjcmVlbiAmJiBjYXNlcy4kaXNGdWxsc2NyZWVuLnZhbClcbiAgICAgICAgKSB7XG4gICAgICAgIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luID0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuICAgICAgfVxuICAgIH0pICBcbiAgfVxuICBcblxuICAvLyByZS1lc3RhYmxpc2ggb2xkIHNldHVwIGFmdGVyIHJlY29ubmVjdFxuICB1c2VyLmNsb3VkLm9uKCd3ZWxjb21lJywgZnVuY3Rpb24oKXtcbiAgICBpZih1c2VyLmNsb3VkLl9zdGF0dXMgPiAyKXtcbiAgICAgIHVzZXIuX2hhbmRsZU9sZElzQWN0aXZlID0gdHJ1ZVxuICAgICAgdXNlci5faGFuZGxlT2xkSXNSZWNlaXZlciA9IHRydWVcbiAgICAgIHVzZXIuY2xvdWQuZGF0YS5vbmNlKGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvayBnbyByZXNldCBkYXQgb2xkIHNpdHVhdGlvbicpXG4gICAgICAgIHVzZXIuaXNBY3RpdmUudXBkYXRlKClcbiAgICAgICAgdXNlci5pc1JlY2VpdmVyLnVwZGF0ZSgpXG4gICAgICB9KVxuICAgIH1cbiAgfSlcblxuICAvKlxuICAqIHdoZW4gSSBiZWNvbWUgYWN0aXZlLCB1bnNldCBteXNlbGYgYXMgcmVjZWl2ZXJcbiAgKiBhbmQgaWYgbm90IGlwbG9naW4gPiBzZWxlY3QgbmV3IHJlY2VpdmVyXG4gICovXG4gIHVzZXIuaXNBY3RpdmUub24odHJ1ZSwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGlzUmVjZWl2ZXIgPSB1c2VyLmlzUmVjZWl2ZXIudmFsXG4gICAgLy8gY29uc29sZS5sb2coJ2lzUmVjZWl2ZXI/IScsIGlzUmVjZWl2ZXIpXG5cbiAgICBpZih1c2VyLmhhc0NhbmRpZGF0ZXMudmFsKSB7IC8vICAmJiAhdXNlci5pcGxvZ2luLnZhbFxuICAgICAgLy8gY29uc29sZS5sb2coJ3VzZXIuaGFzQ2FuZGlkYXRlcy52YWwnLCB1c2VyLmhhc0NhbmRpZGF0ZXMudmFsKVxuICAgICAgLy8gY29uc29sZS5sb2coJ2lzUmVjZWl2ZXInLCBcbiAgICAgIC8vICAgaXNSZWNlaXZlciwgXG4gICAgICAvLyAgICdcXG51c2VyLmhhc1JlY2VpdmVyLnZhbCcsIHVzZXIuaGFzUmVjZWl2ZXIudmFsXG4gICAgICAvLyAgIClcbiAgICAgIGlmKGlzUmVjZWl2ZXIgfHwgIXVzZXIuaGFzUmVjZWl2ZXIudmFsKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdvayBzZWxlY3QgcmVjZWl2ZXIgYmVjYXVzZSBpIGJlY2FtZSBhY3RpdmUhJylcbiAgICAgICAgdmFyIG5ld3JlY2VpdmVyID0gc2VsZWN0UmVjZWl2ZXIodXNlciwgdXNlci5jYW5kaWRhdGVzKVxuICAgICAgICBpZihuZXdyZWNlaXZlcikge1xuICAgICAgICAgIC8vIHdhaXQgZm9yIG15IG93biBpc2FjdGl2ZSBzZXRcbiAgICAgICAgICByYWYoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHVzZXIuc2V0UmVjZWl2ZXIobmV3cmVjZWl2ZXIpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIGlmKGlzUmVjZWl2ZXIpIHtcbiAgICAgICAgICB1c2VyLnJlY2VpdmVyQ2xpZW50LiR1c2VyT3JpZ2luID0gbnVsbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGlzUmVjZWl2ZXIpe1xuICAgICAgdXNlci5yZWNlaXZlckNsaWVudC4kdXNlck9yaWdpbiA9IG51bGxcbiAgICB9XG4gIH0pICBcbiAgXG5cbiAgLy8gd2hlbiByZWNlaXZlciBsZWF2ZXMsIEkgbWlnaHQgaGF2ZSB0byBiZWNvbWUgdGhlIG5ldyByZWNlaXZlclxuICBpZihjYXNlcy4kaXNDYW5kaWRhdGUpIHtcbiAgICB1c2VyLmhhc1JlY2VpdmVyLm9uKDAsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20pe1xuICAgICAgaWYoc3RhbXAgPT09IHVzZXIuY2xvdWQuc3RhbXApIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3llcyB1cGRhdGUgaXMgb2snKVxuICAgICAgICBpZighdXNlci5pc0FjdGl2ZS52YWwpe1xuICAgICAgICAgIC8vIHdhaXQgZm9yIGFsbCByZW1vdmVzIHRvIGZpbmlzaFxuICAgICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgICAgLy8gc2VsZWN0IHJlY2VpdmVyXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnb2sgc2VsZWN0IHJlY2VpdmVyIGJlY2F1c2UgcmVjZWl2ZXIgbGVmdCEnKVxuICAgICAgICAgICAgdmFyIG5ld3JlY2VpdmVyID0gc2VsZWN0UmVjZWl2ZXIodXNlciwgdXNlci5jbGllbnRzKVxuICAgICAgICAgICAgLy8gaWYgaXRzIG1lID4gdXBkYXRlIHVzZXJcbiAgICAgICAgICAgIGlmKG5ld3JlY2VpdmVyID09PSB1c2VyLmNsb3VkLmNsaWVudC5mcm9tKSB7XG4gICAgICAgICAgICAgIHVzZXIuc2V0UmVjZWl2ZXIobmV3cmVjZWl2ZXIpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaSBhbSBub3QgbmV3IHJlY2VpdmVyISBuZXdyZWNlaXZlciBpcycsIG5ld3JlY2VpdmVyICYmIG5ld3JlY2VpdmVyLnJhdylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygndXBkYXRlIG5vdCBmcm9tIHRoZSBjbG91ZCcpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8vIHdoZW4gYSB0diBqb2lucywgSSBtaWdodCB3YW50IHRvIGdyYWIgaXRcbiAgaWYoIXVzZXIuaXBsb2dpbi52YWwpe1xuICAgIHVzZXIuY2FuZGlkYXRlcy5vbihmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkKXtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJy0tLS0tLS0tIGNoZWNrIGZvciB0diBqb2luZXJcXG4nLFxuICAgICAgLy8gICAndXNlci5oYXNDYW5kaWRhdGVzLnZhbCcsIHVzZXIuaGFzQ2FuZGlkYXRlcy52YWwsICdcXG4nLFxuICAgICAgLy8gICAndXNlci5pc0FjdGl2ZS52YWwnLCB1c2VyLmlzQWN0aXZlLnZhbCwgJ1xcbicsXG4gICAgICAvLyAgICd1c2VyLmluaXRpYWxpc2VkJywgdXNlci5pbml0aWFsaXNlZFxuICAgICAgLy8gKVxuICAgICAgLy8gY29uc29sZS5sb2codXNlci5jYW5kaWRhdGVzLnRvU3RyaW5nKCkpXG4gICAgICBpZih1c2VyLmhhc0NhbmRpZGF0ZXMudmFsICYmIHVzZXIuaXNBY3RpdmUudmFsICYmXG4gICAgICAgICAgdXNlci5pbml0aWFsaXNlZFxuICAgICAgICApIHtcbiAgICAgICAgZ3JhYlRWKHVzZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdubyBjYW5kaWRhdGVzJylcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgXG4gIC8vIG1ha2UgY2FzZXNcbiAgY2FzZXMuJGlzQWN0aXZlID0gdXNlci5pc0FjdGl2ZVxuICAvLyBjYXNlcy4kaGFzQ2FuZGlkYXRlcyA9IHVzZXIuaGFzQ2FuZGlkYXRlc1xuICBjYXNlcy4kaGFzRGV2aWNlcyA9IHVzZXIuaGFzRGV2aWNlc1xuICBjYXNlcy4kaGFzUmVjZWl2ZXIgPSB1c2VyLmhhc1JlY2VpdmVyXG4gIGNhc2VzLiRpc1JlY2VpdmVyID0gdXNlci5pc1JlY2VpdmVyXG5cblxufSlcblxuLy8gY2xpZW50c1xuZnVuY3Rpb24gdXBkYXRlQ2xpZW50cygpIHtcbiAgdGhpcy5jbGllbnRzLnVwZGF0ZSgpXG59XG5cbmZ1bmN0aW9uIHNldENsaWVudHMgKCkge1xuICB2YXIgdXNlciA9IHRoaXNcbiAgdmFyIGxpbmtlZCA9IHVzZXIuZGF0YS5fdmFsXG5cbiAgLy8gY2xpZW50c1xuICB2YXIgbGlua2VkY2xpZW50cyA9IGxpbmtlZC5nZXQoJ2NsaWVudHMnKVxuICAvLyBjYWNoZSBvbGQsIHNldCBuZXcsIGFuZCByZW1vdmUgbGlzdGVuZXIgaWYgY2FjaGVkIG9sZFxuICB2YXIgb2xkY2xpZW50cyA9IHVzZXIuY2xpZW50cy5fdmFsXG4gIHVzZXIuY2xpZW50cyA9IGxpbmtlZGNsaWVudHNcbiAgbGlua2VkY2xpZW50cy5hZGRMaXN0ZW5lcihbdXBkYXRlQ2xpZW50cywgdXNlcl0sIHRydWUpXG4gIGlmKCBvbGRjbGllbnRzICkge1xuICAgIG9sZGNsaWVudHMucmVtb3ZlTGlzdGVuZXIodXBkYXRlQ2xpZW50cywgdXNlcilcbiAgfVxuXG4gIC8vIGNhbmRpZGF0ZXNcbiAgLy8gY2FjaGUgcHJldmlvdXNlIHZhbHVlXG4gIHZhciBvbGRjYW5kaWRhdGVzID0gdXNlci5jYW5kaWRhdGVzICYmIHVzZXIuY2FuZGlkYXRlcy5fdmFsXG4gIC8vIG1ha2UgY2FuZGlkYXRlc1xuICB2YXIgY2FuZGlkYXRlcyA9IHVzZXIuY2FuZGlkYXRlcyA9IG5ldyBEYXRhKCBsaW5rZWRjbGllbnRzLCB7XG4gICAgY29uZGl0aW9uOiB7IFxuICAgICAgZGV2aWNlOiB7XG4gICAgICAgICRjb250YWluczogJyhkZXNrdG9wKXwodHYpfChjYXN0KXwodGFibGV0KXwoYWlycGxheSknXG4gICAgICB9LFxuICAgICAga2V5OiB7XG4gICAgICAgICRleGlzdHM6IHRydWUsXG4gICAgICAgICRuZTogdGhpcy5jbG91ZC5jbGllbnRpZFxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgLy8gYWRkIGxpc3RlbmVyIGJlY2F1c2Ugb2YgcmVhc29uc1xuICBjYW5kaWRhdGVzLm9uKGZ1bmN0aW9uKCl7XG4gICAgdXNlci5jYW5kaWRhdGVzLnVwZGF0ZSgpXG4gIH0pXG4gIC8vIGNsZWFuIHVwIGRhdCBvbGQgc2VsZWN0aW9uXG4gIGlmKG9sZGNhbmRpZGF0ZXMpIHtcbiAgICBvbGRjYW5kaWRhdGVzLnJlbW92ZSgpXG4gIH1cbiAgXG4gIC8vIHNpYmxpbmdzXG4gIC8vIGNhY2hlIHByZXZpb3VzZSB2YWx1ZVxuICB2YXIgb2xkc2libGluZ3MgPSB1c2VyLnNpYmxpbmdzICYmIHVzZXIuc2libGluZ3MuX3ZhbFxuICAvLyBtYWtlIHNpYmxpbmdzXG4gIHZhciBzaWJsaW5ncyA9IHVzZXIuc2libGluZ3MgPSBuZXcgRGF0YSggbGlua2VkY2xpZW50cywge1xuICAgIGNvbmRpdGlvbjoge1xuICAgICAga2V5OiB7XG4gICAgICAgICRleGlzdHM6IHRydWUsXG4gICAgICAgICRuZTogdGhpcy5jbG91ZC5jbGllbnRpZFxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgLy8gYWRkIGxpc3RlbmVyIGJlY2F1c2Ugb2YgcmVhc29uc1xuICBzaWJsaW5ncy5vbihmdW5jdGlvbigpe1xuICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGUgb24gY2FuZGlkYXRlcyA+IHVwZGF0ZSB1c2VyLmNhbmRpZGF0ZXMnKVxuICAgIHVzZXIuc2libGluZ3MudXBkYXRlKClcbiAgfSlcbiAgLy8gY2xlYW4gdXAgZGF0IG9sZCBzZWxlY3Rpb25cbiAgaWYob2xkc2libGluZ3MpIHtcbiAgICBvbGRzaWJsaW5ncy5yZW1vdmUoKVxuICB9XG59XG5cbi8vIGFjdGl2ZUNsaWVudFxuXG52YXIgYWNSZW1vdmVUYXJnZXRcbnZhciBhY0FkZGVkVGFyZ2V0XG5cbmZ1bmN0aW9uIHNldE1vY2tfYWN0aXZlQ2xpZW50ICgpIHtcbiAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tLS0gc2V0TW9ja19hY3RpdmVDbGllbnQhJylcblxuICB2YXIgdXNlciA9IHRoaXNcblxuICBpZihhY1JlbW92ZVRhcmdldCkge1xuICAgIGFjUmVtb3ZlVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGFjUmVtb3ZlQ2hlY2ssIHVzZXIpXG4gICAgYWNSZW1vdmVUYXJnZXQgPSBudWxsXG4gIH1cbiAgaWYoYWNBZGRlZFRhcmdldCkge1xuICAgIGFjQWRkZWRUYXJnZXQucmVtb3ZlTGlzdGVuZXIoYWNBZGRlZENoZWNrLCB1c2VyKVxuICAgIGFjQWRkZWRUYXJnZXQgPSBudWxsXG4gIH1cblxuICB2YXIgbGlua2VkID0gdXNlci5kYXRhLl92YWxcblxuICB1c2VyLmFjdGl2ZUNsaWVudCA9IGxpbmtlZC5nZXQoJ2FjdGl2ZUNsaWVudCcsIHt9KVxuICB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiA9IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cblxufVxuXG5cblxuZnVuY3Rpb24gc2V0VXNlcl9hY3RpdmVDbGllbnQgKCkge1xuICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tLSBzZXRVc2VyX2FjdGl2ZUNsaWVudCEnKVxuXG4gIHZhciB1c2VyID0gdGhpc1xuXG4gIC8vIGNvbnNvbGUubG9nKCdkYXQgYWN0aXZlQ2xpZW50OicsIFxuICAvLyAgIHVzZXIuZGF0YS5fdmFsLmFjdGl2ZUNsaWVudFxuICAvLyAgID8gJ3llcyBhY3RpdmVjbGllbnRcXG4nICsgdXNlci5kYXRhLl92YWwuYWN0aXZlQ2xpZW50LnRvU3RyaW5nKClcbiAgLy8gICA6ICdubyBhY3RpdmVDbGllbnQgaW4gbWEgbmV3IHVzZXIhIVxcbicgKyB1c2VyLmRhdGEuX3ZhbC50b1N0cmluZygpXG4gIC8vIClcblxuICBpZihhY0FkZGVkVGFyZ2V0KSB7XG4gICAgYWNBZGRlZFRhcmdldC5yZW1vdmVMaXN0ZW5lcihhY0FkZGVkQ2hlY2ssIHVzZXIpXG4gICAgYWNBZGRlZFRhcmdldCA9IG51bGxcbiAgfVxuICBcbiAgdmFyIGxpbmtlZCA9IHVzZXIuZGF0YS5fdmFsXG4gIHZhciBsaW5rZWRSZWYgPSBsaW5rZWQuZ2V0KCdhY3RpdmVDbGllbnQnLCB7fSlcblxuICBpZihhY1JlbW92ZVRhcmdldCkge1xuICAgIGFjUmVtb3ZlVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGFjUmVtb3ZlQ2hlY2ssIHVzZXIpXG4gIH1cbiAgYWNSZW1vdmVUYXJnZXQgPSBsaW5rZWRSZWZcbiAgYWNSZW1vdmVUYXJnZXQuYWRkTGlzdGVuZXIoW2FjUmVtb3ZlQ2hlY2ssIHVzZXJdLCB0cnVlKVxuXG4gIHVzZXIuYWN0aXZlQ2xpZW50ID0gbGlua2VkUmVmXG4gIFxuICAvLyBjb25zb2xlLmVycm9yKCdVU0VSU1dJVENIIEFDVElWRUNMSUVOVCcpXG4gIGlmKCFJTkFDVElWRSl7XG4gICAgaWYoY2FzZXMuJGlzVHYpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0lNIFRWIFVTRVJTV0lUQ0ggV0FUIFRPIERPJylcbiAgICAgIC8vIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luID0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuICAgICAgLy8gVE9ETzogZml4IHRoaXM6XG4gICAgICB2YXIgYWN0aXZlQ2xpZW50ID0gbGlua2VkUmVmLmZyb21cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2FjdGl2ZUNsaWVudCBpcycsIGFjdGl2ZUNsaWVudClcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdpIGFtJywgdXNlci5jbG91ZC5jbGllbnQuZnJvbS5yYXcpXG4gICAgICBpZighKGFjdGl2ZUNsaWVudCAmJiBhY3RpdmVDbGllbnQuX25hbWUgIT09ICdhY3RpdmVDbGllbnQnKSkge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdzZXQgbWFzZWxmIGFjdGl2ZScpXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1NFVCBNRSBUTyBEQVQgYWN0aXZlQ2xpZW50IChUViknKVxuICAgICAgICB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiA9IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cbiAgICAgIH1lbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3VkcGF0ZSBhY3RpdmVDbGllbnQgYmVjYXVzZSBkbyBpdCcpXG4gICAgICAgIHVzZXIuYWN0aXZlQ2xpZW50LnVwZGF0ZSgpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKCFjYXNlcy4kaXNDaHJvbWVjYXN0KSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdTRVQgTUUgVE8gREFUIGFjdGl2ZUNsaWVudCcpXG4gICAgICB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiA9IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cbiAgICB9XG4gIH1cbiAgXG5cbiAgaWYodXNlci5oYXNDYW5kaWRhdGVzLnZhbCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjaGVjayBmb3IgdHYgdG8gZ3JhYiBvbiBzZXRVc2VyX2FjdGl2ZUNsaWVudCcpXG4gICAgZ3JhYlRWKHVzZXIpXG4gIH1cblxuICB1c2VyLmFjdGl2ZUNsaWVudC51cGRhdGUoKVxuXG59XG5mdW5jdGlvbiBhY1JlbW92ZUNoZWNrIChmaXJlciwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlKSB7XG4gIHZhciB1c2VyID0gdGhpc1xuICBpZihmaXJlci5fcmVtb3ZlZCkge1xuICAgIGlmKGFjQWRkZWRUYXJnZXQpIHtcbiAgICAgIGFjQWRkZWRUYXJnZXQucmVtb3ZlTGlzdGVuZXIoYWNBZGRlZENoZWNrLCB1c2VyKVxuICAgIH1cbiAgICBhY0FkZGVkVGFyZ2V0ID0gZmlyZXIuX3BhcmVudFxuICAgIGFjQWRkZWRUYXJnZXQuYWRkTGlzdGVuZXIoW2FjQWRkZWRDaGVjaywgdXNlcl0sIHRydWUpXG4gIH1cbn1cbmZ1bmN0aW9uIGFjQWRkZWRDaGVjayAoZmlyZXIsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQpIHtcbiAgdmFyIHVzZXIgPSB0aGlzLFxuICAgIGxpbmtlZHVzZXIgPSBmaXJlclxuXG4gIGlmKGxpbmtlZHVzZXIuYWN0aXZlQ2xpZW50KXtcbiAgICBhY0FkZGVkVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKGFjQWRkZWRDaGVjaywgdXNlcilcbiAgICBhY0FkZGVkVGFyZ2V0ID0gbnVsbFxuICAgIFxuICAgIGFjUmVtb3ZlVGFyZ2V0ID0gbGlua2VkdXNlci5hY3RpdmVDbGllbnRcbiAgICBhY1JlbW92ZVRhcmdldC5hZGRMaXN0ZW5lcihbYWNSZW1vdmVDaGVjaywgdXNlcl0sIHRydWUpXG5cbiAgICB1c2VyLmFjdGl2ZUNsaWVudCA9IGxpbmtlZHVzZXIuYWN0aXZlQ2xpZW50XG4gIH1cbn1cblxuLy8gcmVjZWl2ZXJDbGllbnRcbnZhciByY0FkZGVkVGFyZ2V0XG52YXIgcmNSZW1vdmVUYXJnZXRcblxuZnVuY3Rpb24gc2V0TW9ja19yZWNlaXZlckNsaWVudCAoKSB7XG4gIHZhciB1c2VyID0gdGhpc1xuXG4gIGlmKHJjQWRkZWRUYXJnZXQpIHtcbiAgICByY0FkZGVkVGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHJjQWRkZWRDaGVjaywgdXNlcilcbiAgfVxuICBpZihyY1JlbW92ZVRhcmdldCkge1xuICAgcmNSZW1vdmVUYXJnZXQucmVtb3ZlTGlzdGVuZXIocmNSZW1vdmVDaGVjaywgdXNlcikgXG4gIH1cblxuICB2YXIgbGlua2VkID0gdXNlci5kYXRhLl92YWxcbiAgdXNlci5yZWNlaXZlckNsaWVudCA9IGxpbmtlZC5nZXQoJ3JlY2VpdmVyQ2xpZW50JywgZmFsc2UpXG59XG5mdW5jdGlvbiBzZXRVc2VyX3JlY2VpdmVyQ2xpZW50ICgpIHtcbiAgdmFyIHVzZXIgPSB0aGlzXG5cbiAgaWYocmNBZGRlZFRhcmdldCkge1xuICAgIHJjQWRkZWRUYXJnZXQucmVtb3ZlTGlzdGVuZXIocmNBZGRlZENoZWNrLCB1c2VyKVxuICAgIHJjQWRkZWRUYXJnZXQgPSBudWxsXG4gIH1cblxuICB2YXIgbGlua2VkID0gdXNlci5kYXRhLl92YWxcbiAgdmFyIGxpbmtlZFJlZiA9IGxpbmtlZC5nZXQoJ3JlY2VpdmVyQ2xpZW50Jywge30pXG5cbiAgaWYocmNSZW1vdmVUYXJnZXQpIHtcbiAgICByY1JlbW92ZVRhcmdldC5yZW1vdmVMaXN0ZW5lcihyY1JlbW92ZUNoZWNrLCB1c2VyKVxuICB9XG4gIHJjUmVtb3ZlVGFyZ2V0ID0gbGlua2VkUmVmXG4gIHJjUmVtb3ZlVGFyZ2V0LmFkZExpc3RlbmVyKFtyY1JlbW92ZUNoZWNrLCB1c2VyXSwgdHJ1ZSlcblxuICB1c2VyLnJlY2VpdmVyQ2xpZW50ID0gbGlua2VkUmVmXG5cbiAgaWYoY2FzZXMuJGlzVHYpIHtcbiAgICAvLyBzZXQgdHYgdG8gcmVjZWl2ZXIgaWYgYWN0aXZlY2xpZW50IGFuZCBubyByZWNlaXZlclxuICAgIHZhciBhY3RpdmVDbGllbnQgPSB1c2VyLmFjdGl2ZUNsaWVudC5mcm9tXG4gICAgaWYoIGFjdGl2ZUNsaWVudCAmJiBhY3RpdmVDbGllbnQuX190ID09PSAyICYmXG4gICAgICAgIGFjdGl2ZUNsaWVudCAhPT0gdXNlci5jbG91ZC5jbGllbnQuZnJvbSAmJlxuICAgICAgICAhdXNlci5oYXNSZWNlaXZlci52YWxcbiAgICAgICkge1xuICAgICAgdXNlci5zZXRSZWNlaXZlcih1c2VyLmNsb3VkLmNsaWVudC5mcm9tKVxuICAgIH1cbiAgfSBlbHNlIGlmIChjYXNlcy4kaXNDaHJvbWVjYXN0KSB7XG4gICAgLy8gYWx3YXlzIHNldCBjaHJvbWVjYXN0IHRvIHJlY2VpdmVyXG4gICAgdXNlci5zZXRSZWNlaXZlcih1c2VyLmNsb3VkLmNsaWVudC5mcm9tKVxuICB9XG5cbn1cbmZ1bmN0aW9uIHJjUmVtb3ZlQ2hlY2sgKGZpcmVyLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUpIHtcbiAgdmFyIHVzZXIgPSB0aGlzXG4gIGlmKGZpcmVyLl9yZW1vdmVkKSB7XG4gICAgaWYocmNBZGRlZFRhcmdldCkge1xuICAgICAgcmNBZGRlZFRhcmdldC5yZW1vdmVMaXN0ZW5lcihyY0FkZGVkQ2hlY2ssIHVzZXIpXG4gICAgfVxuICAgIHJjQWRkZWRUYXJnZXQgPSBmaXJlci5fcGFyZW50XG4gICAgcmNBZGRlZFRhcmdldC5hZGRMaXN0ZW5lcihbcmNBZGRlZENoZWNrLCB1c2VyXSwgdHJ1ZSlcbiAgfVxufVxuZnVuY3Rpb24gcmNBZGRlZENoZWNrIChmaXJlciwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCkge1xuICB2YXIgdXNlciA9IHRoaXMsXG4gICAgbGlua2VkdXNlciA9IGZpcmVyXG5cbiAgaWYobGlua2VkdXNlci5yZWNlaXZlckNsaWVudCl7XG4gICAgcmNBZGRlZFRhcmdldC5yZW1vdmVMaXN0ZW5lcihyY0FkZGVkQ2hlY2ssIHVzZXIpXG4gICAgcmNBZGRlZFRhcmdldCA9IG51bGxcblxuICAgIHJjUmVtb3ZlVGFyZ2V0ID0gbGlua2VkdXNlci5yZWNlaXZlckNsaWVudFxuICAgIHJjUmVtb3ZlVGFyZ2V0LmFkZExpc3RlbmVyKFtyY1JlbW92ZUNoZWNrLCB1c2VyXSwgdHJ1ZSlcblxuICAgIHVzZXIucmVjZWl2ZXJDbGllbnQgPSBsaW5rZWR1c2VyLnJlY2VpdmVyQ2xpZW50XG4gIH1cbn1cbi8vIHJlY2VpdmVyXG5mdW5jdGlvbiBzZXRNb2NrX3JlY2VpdmVyICgpIHtcbiAgdmFyIHVzZXIgPSB0aGlzXG4gIGxpbmtSZWNlaXZlcih1c2VyKVxufVxuZnVuY3Rpb24gc2V0VXNlcl9yZWNlaXZlciAoKSB7XG4gIHZhciB1c2VyID0gdGhpc1xuICBsaW5rUmVjZWl2ZXIodXNlcilcbn1cbmZ1bmN0aW9uIGxpbmtSZWNlaXZlciAodXNlcikge1xuICB2YXIgbGlua2VkID0gdXNlci5kYXRhLl92YWxcbiAgICAsIGxpbmtlZHJlY2VpdmVyID0gbGlua2VkLmdldCgncmVjZWl2ZXInLCB7fSlcblxuICB1c2VyLnJlY2VpdmVyID0ge1xuICAgIHZvbHVtZTogbGlua2VkcmVjZWl2ZXIuZ2V0KCd2b2x1bWUnLCAxKSxcbiAgICBtZWRpYTogbGlua2VkcmVjZWl2ZXIuZ2V0KCdtZWRpYScsIGZhbHNlKSxcbiAgICBwbGF5aW5nOiBsaW5rZWRyZWNlaXZlci5nZXQoJ3BsYXlpbmcnLCBmYWxzZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzZWxlY3RSZWNlaXZlcih1c2VyLCBsaXN0KSB7XG4gIC8vIGNvbnNvbGUuZXJyb3IoJ1xcblxcbj09PT09PT09PT09PT09PT09PT09PT09PT1zZWxlY3RSZWNlaXZlciEhIVxcblxcbicpXG4gIHdoaWxlKGxpc3QgJiYgbGlzdC5fX3QgPT09IDQgJiYgIWxpc3QuX2ZpbHRlcil7XG4gICAgbGlzdCA9IGxpc3QuX3ZhbFxuICB9XG4gIGlmKCFsaXN0KSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ2NvdWxkIG5vdCBkZXRlcm1pbmUgbGlzdCB0byBzZWxlY3QgZnJvbScpXG4gIH1cbiAgdmFyIHdpbm5lclxuICBsaXN0LmVhY2goZnVuY3Rpb24oKXtcbiAgICB2YXIgY2xpZW50ID0gdGhpcy5fdmFsXG4gICAgLy8gc2FuaXR5IGNoZWNrXG4gICAgaWYoIWNsaWVudCB8fCBjbGllbnQuX3JlbW92ZWQgfHwgIWNsaWVudC5kZXZpY2UpIHtcbiAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKCdiYWQgY2xpZW50JywgXG4gICAgICAgICdwYXRoOicsIGNsaWVudCAmJiBjbGllbnQuX3BhdGgsXG4gICAgICAgICdjbGllbnQ6JywgY2xpZW50ICYmIGNsaWVudC5yYXcgfHwgY2xpZW50XG4gICAgICApXG4gICAgfVxuICAgIC8vIHNraXAgaWYgY2xpZW50IGlzIHRoZSBhY3RpdmVDbGllbnRcbiAgICBpZihjbGllbnQgPT09IHVzZXIuYWN0aXZlQ2xpZW50LmZyb20pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgZGV2aWNlID0gY2xpZW50LmRldmljZS52YWxcbiAgICAvLyBza2lwIGlmIGNsaWVudCBpcyBub3QgYSBjYW5kaWRhdGVcbiAgICBpZighZGV2aWNlSXNDYW5kaWRhdGUudGVzdChkZXZpY2UpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBza2lwIGlmIGNsaWVudCBpcyBpbiB1c2UgYnkgb3RoZXIgdXNlclxuICAgIGlmKGNsaWVudC50b2tlbiAmJiBjbGllbnQudG9rZW4udmFsICE9PSB1c2VyLnRva2VuLnZhbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIGNsaWVudCBpcyBhIHBvc3NpYmxlIHdpbm5lclxuICAgIHdpbm5lciA9IGNsaWVudFxuICAgIC8vIHN0aWNrIGlmIGNsaWVudCBpcyB0di1saWtlXG4gICAgaWYoZGV2aWNlSXNUdkxpa2UudGVzdChkZXZpY2UpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfSlcbiAgLy8gY29uc29sZS5lcnJvcignXFxuXFxuPT09PT09PT09PT09PT09PT09PT09PT09PSB3aW5uZXI6Jyx3aW5uZXIsdXNlci5jbG91ZC5jbGllbnRpZCwnXFxuXFxuJylcblxuICByZXR1cm4gd2lubmVyXG59XG5cbmZ1bmN0aW9uIGdyYWJUVih1c2VyKXtcbiAgLy8gY29uc29sZS5lcnJvcignPT09PT09PT09PT09PSBncmFiVFYhJylcbiAgdXNlci5jYW5kaWRhdGVzLl92YWwuZWFjaChmdW5jdGlvbigpe1xuICAgIHZhciBjYW5kaWRhdGUgPSB0aGlzLmZyb21cbiAgICAvLyBjb25zb2xlLmVycm9yKCdjYW5kaWRhdGUnLCBcbiAgICAvLyAgICdkZXZpY2VJc1R2TGlrZScsIGRldmljZUlzVHZMaWtlLnRlc3QoY2FuZGlkYXRlLmRldmljZS52YWwpLFxuICAgIC8vICAgJyFjYW5kaWRhdGUudG9rZW4nLCAhKGNhbmRpZGF0ZS50b2tlbiAmJiBjYW5kaWRhdGUudG9rZW4udmFsKSxcbiAgICAvLyAgICdjYW5kaWRhdGUudG9rZW4nLCAoY2FuZGlkYXRlLnRva2VuICYmIGNhbmRpZGF0ZS50b2tlbi52YWwpXG4gICAgLy8gKVxuICAgIGlmKGNhbmRpZGF0ZS5kZXZpY2UudmFsID09PSAndHYnICYmXG4gICAgICAgICEoY2FuZGlkYXRlLnRva2VuICYmIGNhbmRpZGF0ZS50b2tlbi52YWwpXG4gICAgICApIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2dyYWIgZGF0IScpXG4gICAgICBjYW5kaWRhdGUuc2V0KCd0b2tlbicsIHVzZXIudG9rZW4udmFsKVxuICAgICAgaWYoIXVzZXIuaGFzUmVjZWl2ZXIudmFsKSB7XG4gICAgICAgIHVzZXIuc2V0UmVjZWl2ZXIoY2FuZGlkYXRlKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuLy8gZnVuY3Rpb24gbG9nKCl7XG4vLyAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tLS0tLS0tLS0tLVxcblxcblxcblxcbicpXG4vLyAgIGNvbnNvbGUubG9nKHdpbmRvdy5GTEFHLCc6Jylcbi8vICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKVxuLy8gICBjb25zb2xlLmxvZygnXFxuXFxuXFxuXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0nKVxuLy8gfVxuLy8gbG9nLnN0YXJ0ID0gZnVuY3Rpb24oZmxhZyl7XG4vLyAgIGNvbnNvbGUubG9nKCdcXG5cXG5cXG49PT09PT09PT09PT09PT09PT09PT09IFNUQVJUJyxcbi8vICAgICB3aW5kb3cuRkxBRyA/IHdpbmRvdy5GTEFHIDogJycsIGZsYWcsICdcXG5cXG4nXG4vLyAgIClcbi8vIH1cbi8vIGxvZy5lbmQgPSBmdW5jdGlvbihmbGFnKXtcbi8vICAgY29uc29sZS5sb2coJ1xcblxcbj09PT09PT09PT09PT09PT09PT09PT0gRU5EJyxcbi8vICAgICB3aW5kb3cuRkxBRyA/IHdpbmRvdy5GTEFHIDogJycsIGZsYWcsICdcXG5cXG4nXG4vLyAgIClcbi8vIH1cbiIsInZhciB1dGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwnKVxudmFyIHZPYmplY3QgPSByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0JylcbnZhciBNb2NrRGF0YSA9IHJlcXVpcmUoJy4vbW9ja2RhdGEnKVxuXG5yZXF1aXJlKCd2aWdvdXItanMvdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG5cbi8vbmF2IGlzIHRha2luZyBjYXJlIG9mOiBcbi8vIGRvdWJsZSB1cGRhdGVzIG9uIHRoZSBzYW1lIHRoaW5nIHdpdGggdGhlIHNhbWUgdmFsdWUgKHN5bmNpbmcgaW4gaXQgdHJvdWdoIHRoZSBjbG91ZClcbi8vIHVwZGF0aW5nIG5hdmlnYXRpb25cbi8vIG1vY2sgYW5kIHVzZXIgZGF0YSwgc3Vic2NyaXB0aW9uc1xuXG4vL1RPRE86IGFkZCB2aWV3XG5cbi8vIGNvbnRlbnQgZW4gc3dpdGNoIG9wIGNvbnRlbnQgcGFra2VuXG4vLyAgIHBhZ2Vcbi8vICAgY29udGVudFxuLy8gb29rIGJ1YmJsZTogMSBvcCBhbGxlIGRpbmdlblxuLy8gZnVuY3Rpb24gdXBkYXRlTmF2aWdhdGlvblxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kXG4oIGZ1bmN0aW9uKCB1c2VyICkge1xuXG4gIHZhciBjb250ZW50ID0gdXNlci5wYXJlbnQuaW5qZWN0KHJlcXVpcmUoJy4uL2NvbnRlbnQnKSkuY29udGVudFxuXG4gIGNvbnRlbnQub24oJ3NlbGYnLCBmdW5jdGlvbigpIHtcbiAgICB2YXIgbmF2ID0gdXNlci5uYXZpZ2F0aW9uXG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzXG4gICAgdmFyIGNvbnRlbnROYXYgPSBuYXYuY29udGVudC5mcm9tXG4gICAgdmFyIG1pc2MgPSBuYXYubWlzYy5mcm9tXG5cbiAgICBpZihjb250ZW50TmF2Ll9jb250ZW50UGF0aCkge1xuICAgICAgbmF2LmNvbnRlbnQuJHVzZXJPcmlnaW4udmFsID0gY29udGVudC5mcm9tLmdldChjb250ZW50TmF2Ll9jb250ZW50UGF0aCkgLy9ESVQgSU4gTkFWSUdBVElPTlxuICAgIH1cblxuICAgIGlmKG1pc2MuX2NvbnRlbnRQYXRoKSB7XG4gICAgICBuYXYuY29udGVudC4kdXNlck9yaWdpbi52YWwgPSBjb250ZW50LmZyb20uZ2V0KG1pc2MuX2NvbnRlbnRQYXRoKSAvL0RJVCBJTiBOQVZJR0FUSU9OXG4gICAgfVxuICB9KVxuXG4gIHVzZXIuZGVmaW5lKHtcbiAgICB1cGRhdGVOYXZpZ2F0aW9uOiBmdW5jdGlvbigga2V5ICkge1xuICAgICAgaWYodGhpcy5uYXZpZ2F0aW9uLmxhc3QgJiYgdGhpcy5uYXZpZ2F0aW9uLmxhc3QuJHVzZXJPcmlnaW4pIHtcbiAgICAgICAga2V5ID0ga2V5IHx8IHRoaXMubmF2aWdhdGlvbi5sYXN0LiR1c2VyT3JpZ2luLmdldCgna2V5JykudmFsXG4gICAgICAgIGlmKCB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb25ba2V5XS5fdXBkYXRlKCB0aGlzLm5hdmlnYXRpb25ba2V5XS5fdmFsLl92YWwgLCAnbCcrTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpKjk5OTkpIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5uYXZpZ2F0aW9uLnBhZ2UuJHVzZXJPcmlnaW4gPSAnZGlzY292ZXInXG4gICAgfVxuICB9KVxuXG4gIHVzZXIuZXh0ZW5kKHtcbiAgICBuYXZpZ2F0aW9uOiB7XG4gICAgICBtb2NrOiB7XG4gICAgICAgIG5hdmlnYXRpb246IFxuICAgICAgICB7IGNvbnRlbnQ6IGZhbHNlXG4gICAgICAgICwgcGFnZTogZmFsc2UgXG4gICAgICAgICwgbWlzYzogZmFsc2VcbiAgICAgICAgLCBsYXN0OiB7IGtleTogJ3BhZ2UnLCB0aW1lOiAwIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICBuYXZpZ2F0aW9uOiBcbiAgICAgICAgeyBjb250ZW50OnRydWVcbiAgICAgICAgLCBwYWdlOnRydWVcbiAgICAgICAgLCBtaXNjOiB0cnVlXG4gICAgICAgICwgbGFzdDogXG4gICAgICAgICAgeyBrZXk6dHJ1ZVxuICAgICAgICAgICwgdGltZTp0cnVlXG4gICAgICAgICAgfVxuICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB2YWw6IFxuICAgICAgeyBwYWdlOiB7IGRlZmVyOiBkZWZlck5hdmlnYXRpb24gfVxuICAgICAgLCBjb250ZW50OiB7IGRlZmVyOiBkZWZlck5hdmlnYXRpb24gfVxuICAgICAgLCBtaXNjOiB7IGRlZmVyOiBkZWZlck5hdmlnYXRpb24gfVxuICAgICAgfSxcbiAgICAgIG9uOiB7XG4gICAgICAgIHVzZXI6IGZ1bmN0aW9uIG5hdmlnYXRpb25Ub1VzZXJEYXRhKCBrZXkgKSB7XG5cbiAgICAgICAgICByZXNvbHZlTGFzdExpc3RlbmVyKHRoaXMpXG4gICAgICAgICAgXG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0ge1xuICAgICAgICAgICAgbGFzdDogdGhpcy5kYXRhLl92YWwuZ2V0KCBbIGtleSwgJ2xhc3QnIF0gKVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLl9fZmlyc3QgPSB0cnVlXG5cbiAgICAgICAgICB2YXIgbmF2ID0gdGhpcy5uYXZpZ2F0aW9uXG4gICAgICAgICAgICAsIHVzZXJEYXRhID0gdGhpcy5kYXRhLiR1c2VyT3JpZ2luXG5cbiAgICAgICAgICB0aGlzLl9sYXN0dXBkYXRlID0gZnVuY3Rpb24gbGFzdFVwZGF0ZVVzZXIoIHZhbCwgc3RhbXAsIGZyb20gKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdoZXkgdGhpcyBzaG91bGQgZG8gdGhlIHVwZGF0ZScpXG5cbiAgICAgICAgICAgIGlmKCB0aGlzLmtleSAmJiBuYXZbdGhpcy5rZXkudmFsXSApICBcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaGV5IHRoaXMgc2hvdWxkIGRvIHRoZSB1cGRhdGUhMScpXG5cbiAgICAgICAgICAgICAgbmF2W3RoaXMua2V5LnZhbF0uJHVzZXJPcmlnaW4uX3VwZGF0ZSggdm9pZCAwLCAnbCcrc3RhbXAgIClcbiAgICAgICAgICAgICAgbmF2LnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmF2Lmxhc3QuZnJvbS5vbih0aGlzLl9sYXN0dXBkYXRlKVxuXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignS0VZJyxrZXkpXG4gICAgICAgICAgLy8gZGVidWdnZXJcblxuICAgICAgICAgIHRoaXMubmF2aWdhdGlvbiA9IFxuICAgICAgICAgIHsgcGFnZTogdXNlckRhdGEuZ2V0KCBbIGtleSwgJ3BhZ2UnIF0sICdkaXNjb3ZlcicgKSBcbiAgICAgICAgICAsIGNvbnRlbnQ6IHVzZXJEYXRhLmdldCggWyBrZXksICdjb250ZW50JyBdIClcbiAgICAgICAgICAsIG1pc2M6IHVzZXJEYXRhLmdldCggWyBrZXksICdtaXNjJyBdIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZihuYXYubGFzdC5mcm9tLmtleSkge1xuICAgICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgICAgIG5hdi5sYXN0LmZyb20uX3VwZGF0ZSggdm9pZCAwLCB2T2JqZWN0LnN0YW1wKCkgKVxuICAgICAgICAgIH0gZWxzZSBpZighbmF2Lmxhc3QuZnJvbS5rZXkpIHtcbiAgICAgICAgICAgIC8vbm8gcGFnZSBzd2l0Y2ggdG8gZGVmYXVsdCAoIG1ha2UgYSBkZWZhdWx0IHBvc3NpbGJlIClcbiAgICAgICAgICAgIG5hdi5wYWdlLiR1c2VyT3JpZ2luID0gJ2Rpc2NvdmVyJ1xuICAgICAgICAgIH1cblxuICAgICAgICB9LFxuICAgICAgICBtb2NrOiBmdW5jdGlvbiBuYXZpZ2F0aW9uVG9Nb2NrRGF0YSgpIHtcblxuICAgICAgICAgIHJlc29sdmVMYXN0TGlzdGVuZXIodGhpcylcbiAgICBcbiAgICAgICAgICB2YXIgbmF2ID0gdGhpcy5uYXZpZ2F0aW9uXG5cbiAgICAgICAgICAgdmFyIG1vY2sgPSB0aGlzLm1vY2tkYXRhLm5hdmlnYXRpb25cbiAgICAgICAgICAgICwgc2V0ID0gXG4gICAgICAgICAgICAgIHsgcGFnZTogbW9jay5wYWdlXG4gICAgICAgICAgICAgICwgY29udGVudDogbW9jay5jb250ZW50XG4gICAgICAgICAgICAgICwgbWlzYzogbW9jay5taXNjXG4gICAgICAgICAgICAgIC8vICwgbGFzdDogbW9jay5sYXN0IFxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm5hdmlnYXRpb24gPSB7IGxhc3Q6IG1vY2subGFzdCB9XG5cbiAgICAgICAgICAvL1RPRE86IHRoaXMgaXMgYSB0ZW1wIGZpeCBzaG91bGQgZ28gYmFjayB0byBwYWdlIHlvdSBsb2dvdXQgZnJvbSFcbiAgICAgICAgICBpZih0aGlzLl9fZmlyc3QpIHtcbiAgICAgICAgICAgIG1vY2sucGFnZS52YWwgPSAnZGlzY292ZXInXG4gICAgICAgICAgfSBcbiAgICBcbiAgICAgICAgICB0aGlzLl9sYXN0dXBkYXRlID0gZnVuY3Rpb24gbGFzdFVwZGF0ZU1vY2soIHZhbCwgc3RhbXAsIGZyb20gKSB7XG4gICAgICAgICAgICBpZiggbmF2W3RoaXMua2V5LnZhbF0gKSBcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbmF2W3RoaXMua2V5LnZhbF0uJHVzZXJPcmlnaW4uX3VwZGF0ZSggdm9pZCAwLCAnbCcrc3RhbXAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuYXYubGFzdC5mcm9tLm9uKCB0aGlzLl9sYXN0dXBkYXRlIClcbiAgICAgICAgICAvLyB2YXIgbmF2ID0gaG9lIGtvbSBpayBoaWVyIGFhbiBtbiB1c2VyPz8/XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignPz8/Pz8nLHRoaXMudG9rZW4uX2x2YWwsIHRoaXMudG9rZW4udmFsKVxuICAgICAgICAgIC8vIG5lZWQgdG8gdXNlIHNldHRlciAobm90IG5hdiByZWYpXG4gICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gc2V0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgZnVuY3Rpb24gcmVzb2x2ZUxhc3RMaXN0ZW5lciggdXNlciApIHtcbiAgICBpZiggdXNlci5fbGFzdHVwZGF0ZSBcbiAgICAgICAgJiYgdXNlci5uYXZpZ2F0aW9uLmxhc3QgXG4gICAgICAgICYmIHVzZXIubmF2aWdhdGlvbi5sYXN0LmZyb20gIT09IHVzZXIubmF2aWdhdGlvbi5sYXN0XG4gICAgICl7XG4gICAgICB1c2VyLm5hdmlnYXRpb24ubGFzdC5mcm9tLnJlbW92ZUxpc3RlbmVyKHVzZXIuX2xhc3R1cGRhdGUpXG4gICAgICB1c2VyLl9sYXN0dXBkYXRlID0gbnVsbFxuICAgICB9XG4gIH0gICAgICBcblxuICBmdW5jdGlvbiBkZWZlck5hdmlnYXRpb24oIHVwZGF0ZSwgYXJncyApIHtcbiAgICBpZiggYXJnc1sxXSAmJiBhcmdzWzFdWzBdID09PSAnbCcgJiYgXG4gICAgICB0aGlzLl9uYW1lID09PSB0aGlzLl9wYXJlbnQubGFzdC5mcm9tLmtleS52YWxcbiAgICApIHtcblxuICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICAgIC8vVE9ETzogbW9yZSBzcGVjaWZpYyBtYXkgYmUgdG9vIG1hbnkgdXBkYXRlcz8/P1xuICAgICAgLy8gY29uc29sZS5sb2coJ2xlenogdXBkYXRlIGl0JywgdGhpcy5fcGFyZW50Ll9wYXRoLCB0aGlzLl9wYXRoKVxuXG4gICAgICB1cGRhdGUoKVxuXG4gICAgICAvLyB0aGlzLl9wYXJlbnQuX3VwZGF0ZS5hcHBseSggdGhpcy5fcGFyZW50LCBhcmdzIClcblxuXG4gICAgfSBcbiAgICBlbHNlIFxuICAgIHtcbiAgICAgIHVwZGF0ZSggdHJ1ZSApXG4gICAgfVxuICB9IFxuXG59KVxuIiwiLy91c2VyT3JpZ2luXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIE1vY2tEYXRhID0gcmVxdWlyZSgnLi9tb2NrZGF0YScpXG4gICwgdGltZXN0YW1wID0gcmVxdWlyZSgnbW9ub3RvbmljLXRpbWVzdGFtcCcpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoIGZ1bmN0aW9uKCB2T2JqZWN0ICkge1xuXG4gIHZhciBfY29yZVNldCA9IHZPYmplY3Quc2V0XG4gICAgLCBfZnJvbVVzZXIgPSBmdW5jdGlvbiggb2JqICkge1xuICAgICAgICB2YXIgdmFsID0gb2JqXG4gICAgICAgICAgLCBuYXZcbiAgICAgICAgICAsIGxhc3RcblxuICAgICAgICB3aGlsZSAodmFsICYmICF2YWwuX3JlbW92ZWQgJiYgdmFsIGluc3RhbmNlb2Ygdk9iamVjdCkge1xuXG4gICAgICAgICAgaWYoIHZhbC5fcGFyZW50ICYmIHZhbC5fcGFyZW50Ll9wcm9wICYmIHZhbC5fcGFyZW50Ll9wcm9wLm5hbWUgPT09ICduYXZpZ2F0aW9uJyApIHtcbiAgICAgICAgICAgIG5hdiA9IHZhbFxuICAgICAgICAgIH0gXG5cbiAgICAgICAgICBpZiggKCB2YWwuY2xvdWQgJiYgdmFsLl9wYXRoWzBdID09PSAndXNlcnMnICkgXG4gICAgICAgICAgICAgIHx8IHZhbCBpbnN0YW5jZW9mIE1vY2tEYXRhIFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gWyB2YWwsIG5hdiBdXG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3QgPSB2YWw7XG4gICAgICAgICAgdmFsID0gdmFsLl92YWw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdWx0ID0gbGFzdCAmJiAhbGFzdC5fcmVtb3ZlZCAmJiBsYXN0ICE9PSBvYmpcbiAgICAgICAgICA/IGxhc3QgXG4gICAgICAgICAgOiBmYWxzZVxuXG4gICAgICAgIHJldHVybiBbIHJlc3VsdCwgbmF2IF1cblxuICAgICAgfVxuXG4gIHV0aWwuZGVmaW5lKCB2T2JqZWN0LCBcbiAgICAnJHVzZXJPcmlnaW4nLCB7XG4gICAgc2V0OiBmdW5jdGlvbiggdmFsICkge1xuXG4gICAgICB2YXIgc2VhcmNoID0gX2Zyb21Vc2VyKHRoaXMpXG4gICAgICAgICwgZm91bmQgPSBzZWFyY2hbMF0gLy98fCB0aGlzXG4gICAgICAgICwgbmF2ID0gc2VhcmNoWzFdXG4gICAgICAgICwgc2FtZVxuXG4gICAgICBpZighZm91bmQpIHtcbiAgICAgICAgdmFyIHByb3BuYW1lID0gdGhpcy5fcHJvcCAmJiB0aGlzLl9wcm9wLm5hbWVcblxuICAgICAgICBpZihwcm9wbmFtZSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJz4+Pj4+Pj4+IG1ha2luZyBhbmQgbGlua2luZycsIHByb3BuYW1lKVxuXG4gICAgICAgICAgdmFyIHVzZXIgPSB0aGlzLl9jYWxsZXIsXG4gICAgICAgICAgICBsaW5rZWR1c2VyID0gdXNlci5kYXRhLl92YWxcblxuICAgICAgICAgIGlmKCFsaW5rZWR1c2VyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCc/Pz8/JywgdmFsKVxuICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3VuZCA9IGxpbmtlZHVzZXIuZ2V0KHByb3BuYW1lLCB7fSlcbiAgICAgICAgICB0aGlzLnZhbCA9IGZvdW5kXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0ZPVU5EJywgdGhpcy5fcHJvcCAmJiB0aGlzLl9wcm9wLm5hbWUsIGZvdW5kLl9wYXRoLCBmb3VuZC5yYXcsIGZvdW5kKVxuICAgICAgfVxuXG4gICAgICBpZighZm91bmQpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdubyB1c2VyIGJ1dCBkbyBmcm9tJylcbiAgICAgICAgLy8gcmV0dXJuIF9jb3JlU2V0KCB0aGlzLmZyb20sIHZhbCApXG5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZmluZCBjb3JyZWN0ICR1c2VyT3JpZ2luIGZvciAnKyAoIHRoaXMuX25hbWUgfHwgdGhpcy5fcHJvcCAmJiAncHJvcGV0eSAnK3RoaXMuX3Byb3AubmFtZSApIClcbiAgICAgIH1cblxuICAgICAgX2NvcmVTZXQuY2FsbCggZm91bmQgLCB2YWwpXG5cbiAgICAgIGlmKG5hdiAmJiBuYXYuX25hbWUgKSB7XG4gICAgICAgIG5hdi5fcGFyZW50Lmxhc3QuZnJvbS52YWwgPSBcbiAgICAgICAgeyB0aW1lOiB0aW1lc3RhbXAoKVxuICAgICAgICAsIGtleTogbmF2Ll9uYW1lXG4gICAgICAgIH1cbiAgICAgIH0gXG5cbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2Zyb21Vc2VyKCB0aGlzIClbMF0gLy98fCB0aGlzXG4gICAgfVxuICB9KVxufSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgdXNlciA9IHJlcXVpcmUoJy4vJylcbiAgLCB2T2JqID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZCggXG5mdW5jdGlvbiggYmFzZSApIHtcblxuICBmdW5jdGlvbiBzZXRVc2VyKGkpIHtcbiAgICAvL21ha2UgdGhlc2UgMiBtb3JlIGRlZnVhbHRcbiAgICAvLyBjb25zb2xlLmxvZyhpKVxuICAgIC8vIGNvbnNvbGUubG9nKCAnc3d0aWNoIHRvIHVzZXInLCBpLCB0aGlzLmRhdGEuX3ZhbCApXG4gICAgdGhpc1tpXSA9IHRoaXMuZGF0YS4kdXNlck9yaWdpbi5nZXQoIGksIHRoaXNbaV0uX3Byb3AuJGRlZmF1bHQgKVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0TW9jayhpKSB7XG4gICAgLy8gY29uc29sZS5sb2coICdzd3RpY2ggdG8gbW9jaycsIGksIHRoaXMubW9ja2RhdGFbaV0gKVxuICAgIHRoaXNbaV0gPSB0aGlzLm1vY2tkYXRhW2ldXG4gIH1cblxuICBiYXNlLmRlZmluZSh7XG4gICAgX3NldDogZnVuY3Rpb24odmFsLCBpICkgXG4gICAge1xuICAgICAgaWYgKCB0aGlzW2ldIGluc3RhbmNlb2Ygdk9iaiApIFxuICAgICAge1xuICAgICAgICAvL1RPRE86IHRvcm91Z2ggdGVzdGluZ1xuICAgICAgICB0aGlzW2ldLnZhbCA9IHZhbFtpXVxuICAgICAgfSBcbiAgICAgIGlmICh0eXBlb2YgdGhpc1tpXSA9PT0gJ2Z1bmN0aW9uJykgXG4gICAgICB7XG4gICAgICAgIGlmICh2YWxbaV0gaW5zdGFuY2VvZiBBcnJheSkgXG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzW2ldLmFwcGx5KHRoaXMsdmFsW2ldKVxuICAgICAgICB9IGVsc2UgXG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzW2ldKHZhbFtpXSlcbiAgICAgICAgfVxuICAgICAgfSBcbiAgICAgIGVsc2UgXG4gICAgICB7XG4gICAgICAgIGlmICggdGhpcy5pc1Byb3BlcnR5KCBpLCB2YWwgKSApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ3RoaXMgaXMgYSBwcm9wZXJ0eSEnLCBpICwgdmFsIClcbiAgICAgICAgICB0aGlzW2ldID0gdmFsW2ldXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYoIHRoaXNbaV0gKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBtZXJnZT8gY2hlY2sgb29rIHZvb3IgY2xvdWQgYmlqdm9vcmJlZWxkXG4gICAgICAgICAgICB0aGlzW2ldID0gdmFsW2ldXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgXG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcignTk9XIExFVFMgTUFLRSBBIEJBU0lDIFRZUEUnLCBpLCB0aGlzKVxuXG4gICAgICAgICAgICB2YXIgbW9jayA9IHt9XG5cbiAgICAgICAgICAgIG1vY2tbaV0gPSB2YWxbaV1cblxuICAgICAgICAgICAgdmFyIHN1YnNjcmlwdGlvbiA9IHt9XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25baV0gPSB0cnVlXG5cbiAgICAgICAgICAgIC8vIHRoaXMubW9ja2RhdGEgPSBtb2NrXG5cbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgbmFtZTppXG4gICAgICAgICAgICAsIG1vY2s6IG1vY2tcbiAgICAgICAgICAgICwgJGRlZmF1bHQ6IHZhbFtpXVxuICAgICAgICAgICAgLCBzdWJzY3JpcHRpb246IHN1YnNjcmlwdGlvbiAvL21heWJlIGRvIHRoaXMgaWYgbm90IHNwZWNpZmllZFxuICAgICAgICAgICAgLCBvbjoge1xuICAgICAgICAgICAgICAgIG1vY2s6IHNldE1vY2tcbiAgICAgICAgICAgICAgLCB1c2VyOiBzZXRVc2VyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vZGl0IGJldGVyLS0tLSBtb2V0IG5hbWVsaWprIG5pZXQgdmFsW2ldIHdvcmRlbiBtYWFyIG1vY2tkYXRhIChvZiBtZXRlZW4gc3dpdGNoZW4gbmFhciB1c2VyRGF0YSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICBcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdoZXknLCBpLCB0aGlzW2ldIClcbiAgICAgICAgXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG59KSIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgVmFsdWUgPSByZXF1aXJlKCcuLi8uLi92YWx1ZScpXG4gICwgY2FzZXMgPSByZXF1aXJlKCcuLi8uLi9icm93c2VyL2Nhc2VzJylcblxucmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG5cbi8vVE9ETzogdXJsIGVycm9yIG9uIHN0YXJ0IHVwIChzZXQgZnJvbSBjbG91ZClcbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmRcbiggZnVuY3Rpb24oIGJhc2UgKSB7XG5cbiAgYmFzZS5kZWZpbmUoe1xuICAgIHVwZGF0ZUlkOiBmdW5jdGlvbiggcmVzICkge1xuICAgICAgdGhpcy5pZCA9IHJlcyBpbnN0YW5jZW9mIEFycmF5ID8gcmVzWyByZXMubGVuZ3RoIC0xIF0gOiByZXNcbiAgICAgIFxuICAgICAgLy9oaWVyIGZmIHZvb3IgbmF2aWdhdGlvblxuICAgICAgLy9nZXQgbGFzdD9cbiAgICB9XG4gICwgYXV0aGVudGljYXRlOiBmdW5jdGlvbiBhdXRoZW50aWNhdGUoIF90aGlzLCByZXF1ZXN0LCB2YWwsIHVwZGF0ZSApIHtcbiAgICAgIHZhciB1c2VyID0gdGhpc1xuICAgICAgICAsIGNsb3VkID0gdXNlci5jbG91ZFxuXG4gICAgICBpZihjbG91ZC5wYXJhbXMuZmFzdExvZ2luICYmIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICB2YXIgdXNlcklkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3VzZXJJZCcpXG4gICAgICAgIGlmKHVzZXJJZCl7XG4gICAgICAgICAgcmVxdWVzdC5pZCA9IHVzZXJJZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb25zb2xlLmxvZygnZ28gY2xvdWQuYXV0aGVudGljYXRlISEnKVxuICAgICAgY2xvdWQuYXV0aGVudGljYXRlKCByZXF1ZXN0LCBmdW5jdGlvbiggcmVzICkge1xuICAgICAgICBcbiAgICAgICAgaWYocmVzLmVycm9yICYmIHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIpe1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VySWQnKVxuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNsZWFyQ2FjaGUoKVxuXG4gICAgICAgIGlmKHZhbCAhPT0gX3RoaXMudmFsKXtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdcXG5cXG5cXG5kaWQgYSBmYXN0IHJlLWxvZ2luISAtLSBkb3VibGUgY2hlY2snKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoIHJlcy5lcnJvciB8fCAhX3RoaXMudmFsICl7XG4gICAgICAgICAgX3RoaXMudmFsID0gZmFsc2VcbiAgICAgICAgICB1c2VyLmlkID0gZmFsc2VcbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICAgIGlmKCByZXMuZXJyb3IgKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2F1dGhlbnRpY2F0ZSBlcnJvcjonLCByZXMuZXJyb3IpXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBpZighICh1c2VyLmlwbG9naW4gJiYgdXNlci5pcGxvZ2luLnZhbCkgKXtcbiAgICAgICAgICAgICAgdXNlci5jbG91ZC5lbWl0KCdsb2dvdXQnLCByZXMgKVxuXG4gICAgICAgICAgICAgIGlmKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09IFwidW5kZWZpbmVkXCIgKXtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgndXNlcklkJylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3Rva2VuIGlzIHNldCB0byBmYWxzZSB3aGlsZSBhdXRoZW50aWNhdGluZyAobG9nb3V0ISAtLSBuZWVkIHRvIGdldCBhIG1ldGhvZCB0byBicmVhayBpdCB3aGlsZSBpbiBwcm9ncmVzcyknKVxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0FVVEggU1VDNicsIHVzZXIsIHJlcyApXG4gICAgICAgICAgLy9kaXQgaXMgb29rIHdyb25nIGNvbXBsZXRlbHkhIC0tIGRpdCBhbGxlZW4gZG9lbiBtZXQgZWVuIHVzZXJ0b2tlbiEhISFcbiAgICAgICAgICAvLyBhbmRlcnMgd2FjaHRlbiB0b3QgZWVuIG92ZXJ0YWtlIGFjdGllXG4gICAgICAgICAgaWYoIF90aGlzLnZhbCAhPT0gdHJ1ZSApIHtcbiAgICAgICAgICAgIHVzZXIudXBkYXRlSWQoIHJlcyApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYoY2xvdWQucGFyYW1zLmZhc3RMb2dpbiAmJiB0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSBcInVuZGVmaW5lZFwiKXtcbiAgICAgICAgICAgIHZhciB1c2VySWRcbiAgICAgICAgICAgIGlmKHJlcyBpbnN0YW5jZW9mIEFycmF5KVxuICAgICAgICAgICAgICB1c2VySWQgPSByZXNbcmVzLmxlbmd0aC0xXVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB1c2VySWQgPSByZXNcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd1c2VySWQnLCB1c2VySWQpICBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZih1c2VyLmlwbG9naW4gJiYgdXNlci5pcGxvZ2luLnZhbCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1RWIExPR0lOIFNVQ0NFU1MhIG1heWJlIGdvIG1ha2UgbWFzZWxmIGRhdCB1c2VyJylcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc+Pj4gdG9rZW4nLCB1c2VyLnRva2VuLnZhbClcbiAgICAgICAgICAgIFxuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfSlcbiAgXG4gIC8vIGNvbnNvbGUubG9nKCc/Pz8/Pz8/Pz8/Pz8/IHNldCBpcGxvZ2luJywgY2FzZXMuJGlzVHYgfHwgY2FzZXMuJGlzQ2hyb21lY2FzdClcbiAgLy8gYmFzZS5pcGxvZ2luID0gY2FzZXMuJGlzVHYgfHwgY2FzZXMuJGlzQ2hyb21lY2FzdFxuICBcbiAgYmFzZS5leHRlbmQoXG4gIHsgLy9wcmltYXJ5XG4gICAgaXBsb2dpbjogeyB2YWw6IGNhc2VzLiRpc1R2IHx8IGNhc2VzLiRpc0Nocm9tZWNhc3QgfSxcbiAgICB0b2tlbjp7XG4gICAgICAvLyBUT0RPOiB3aGVuIElQIGJhc2VkIGNvbm5lY3Rpdml0eSBpcyBmaXhlZCB0aGlzIGlzIG5vdCBuZWVkZWRcbiAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICB0b2tlbjogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHZhbDp7XG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24oIHZhbCwgY3YgKSB7XG4gICAgICAgICAgcmV0dXJuICggY3YgaW5zdGFuY2VvZiBPYmplY3QgKSA/IGZhbHNlIDogY3ZcbiAgICAgICAgfSxcbiAgICAgICAgZGVmZXI6ZnVuY3Rpb24oIHVwZGF0ZSwgYXJncywgdGVtcGRlZmVyICkge1xuXG4gICAgICAgICAgaWYoYXJnc1swXSAmJiBhcmdzWzBdLmRlZmVyKSByZXR1cm4gdHJ1ZVxuXG4gICAgICAgICAgdmFyIHRva2VuID0gdGhpc1xuICAgICAgICAgIHZhciB1c2VyID0gdG9rZW4uX2NhbGxlclxuXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignVE9LRU4gU0VUIXh4eCcsIHRva2VuKVxuXG4gICAgICAgICAgdXNlci5jbG91ZC5jb25uZWN0ZWQuaXModHJ1ZSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgb2xkdmFsID0gYXJnc1xuICAgICAgICAgICAgICAsIHZhbCA9IHRva2VuLnZhbFxuICAgICAgICAgICAgICAsIHVzZXJJZCA9IHVzZXIuaWQgJiYgdXNlci5pZC52YWxcbiAgICAgICAgICAgICAgLCBpcGxvZ2luID0gdXNlci5pcGxvZ2luICYmIHVzZXIuaXBsb2dpbi52YWxcblxuICAgICAgICAgICAgLy8gaWYoIHVzZXIuaXBsb2dpbiAmJiB1c2VyLmlwbG9naW4udmFsICl7XG4gICAgICAgICAgICAvLyAgIGlwbG9naW4gPSB0cnVlXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAvL0RPVUJMRSBDSEVDSyAtLS0gdGhpcyB3YXMgaW4gdGhlcmUgdG8gYWxsd2F5cyBtYWtlIHN1cmUgdGhpcyBzdHVmZiBkaWQgbm90IGhhcHBlbi4uLlxuICAgICAgICAgICAgLy8gaWYoIHVzZXIuYWN0aXZlQ2xpZW50ICYmIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luICYmIHVzZXIuYWN0aXZlQ2xpZW50LmZyb20gPT09IHVzZXIuY2xpZW50LmZyb20gICkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbWMgZGlydHkgbGV0cyBmaXggdGhpcyBoZXJlISBvbiBsb2dvdXQgc2V0IGZhbHNlIHRvIGJlIGNlcnRhaW4nLCB1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiApXG4gICAgICAgICAgICAgIC8vIHVzZXIuYWN0aXZlQ2xpZW50LiR1c2VyT3JpZ2luID0gZmFsc2VcbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgdG9rZW4uY2xlYXJDYWNoZSgpXG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3Rva2VuIGlzIHNldCEnLCB2YWwpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4gaXMgc2V0IScsIGlwbG9naW4pXG5cbiAgICAgICAgICAgIGlmKCB1c2VySWQgJiYgIWlwbG9naW4gKXtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0xPR09VVCAtLS0+IEVNSVQnLnJlZC5pbnZlcnNlLCB1c2VySWQgKVxuICAgICAgICAgICAgICB2YXIgX2xhc3QgPSB1c2VyLmNsb3VkLmxvZ291dCggdXNlcklkIClcbiAgICAgICAgICAgICAgaWYodHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gXCJ1bmRlZmluZWRcIil7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ3VzZXJJZCcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHZhbCApe1xuXG4gICAgICAgICAgICAgIHZhciB1cmwgPSB1c2VyLmNsb3VkLmFwaS5nZXQoJ2F1dGgnKVxuXG4gICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gXG4gICAgICAgICAgICAgIHsgdXJsOiB1cmxcbiAgICAgICAgICAgICAgLCBzdWJzOiB1c2VyLnN1YnNjcmlwdGlvbnNcbiAgICAgICAgICAgICAgLCB0b2tlbjogdmFsXG4gICAgICAgICAgICAgIC8vVE9ETzogYWxzbyBhZGQgdHZcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAsIGF1dGggPSB1c2VyLl9fYXV0aGVudGljYXRlZF9fXG5cbiAgICAgICAgICAgICAgaWYoIGlwbG9naW4gKXtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFsbCB0diB2aWJlc1xuICAgICAgICAgICAgICAgIGlmKCB2YWwgPT09IHRydWUgKSB7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdC50b2tlblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXF1ZXN0LnR2ID0gdHJ1ZVxuXG4gICAgICAgICAgICAgICAgaWYoICFhdXRoICl7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSVBMT0dJTiBGSVJTVCBUSU1FIFBPUCBEQVQgQVVUSEVOVElDQVRFJylcbiAgICAgICAgICAgICAgICAgIHVzZXIuX2F1dGhyZXF1ZXN0ID0gcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgdXNlci5hdXRoZW50aWNhdGUoIHRva2VuLCByZXF1ZXN0LCB2YWwsIHVwZGF0ZSApXG4gICAgICAgICAgICAgICAgICB1c2VyLl9fYXV0aGVudGljYXRlZF9fID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgdmFyIHVzZXJzID0gdXNlci5jbG91ZC5kYXRhLmdldCgndXNlcnMnKVxuICAgICAgICAgICAgICAgICAgICAsIHNldFxuXG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdJUExPR0lOIFVTRVJTV0lUQ0gnKVxuICAgICAgICAgICAgICAgICAgLy8gZmluZCB0aGUgdXNlciBJIHNob3VsZCBzd2l0Y2ggdG9cbiAgICAgICAgICAgICAgICAgIHVzZXJzLmVhY2goZnVuY3Rpb24oIGtleSApIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnPj4gSEFWRSBVU0VSJywgdGhpcylcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3VkdXNlciA9IHRoaXNcblxuICAgICAgICAgICAgICAgICAgICBpZihjbG91ZHVzZXIudG9rZW4gJiYgY2xvdWR1c2VyLnRva2VuLnZhbCA9PT0gdG9rZW4udmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaW0gc3dpdGNoaW5nIHRvIHRoaXMgdXNlclxuICAgICAgICAgICAgICAgICAgICAgIHNldCA9IGNsb3VkdXNlci5fbmFtZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzd2l0Y2ggdG8gdGhpcyB1c2VydCEnKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGlmKFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvdWR1c2VyLnJlY2VpdmVyQ2xpZW50ICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvdWR1c2VyLnJlY2VpdmVyQ2xpZW50LmZyb20gPT09IHVzZXIuY2xvdWQuY2xpZW50LmZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd0aGlzIG90aGVyIHVzZXIgaGFzIG1lIGFzIHJlY2VpdmVyQ2xpZW50LCBiZXR0ZXIgcmVtb3ZlJylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3VkdXNlci5yZWNlaXZlckNsaWVudC4kdXNlck9yaWdpbiA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYoY2xvdWR1c2VyLmFjdGl2ZUNsaWVudCAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3VkdXNlci5hY3RpdmVDbGllbnQuZnJvbSA9PT0gdXNlci5jbG91ZC5jbGllbnQuZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3RoaXMgb3RoZXIgdXNlciBoYXMgbWUgYXMgcmVjZWl2ZXJDbGllbnQsIGJldHRlciByZW1vdmUnKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2xvdWR1c2VyLmFjdGl2ZUNsaWVudC4kdXNlck9yaWdpbiA9IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICBpZighc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIuaWQgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHVzZXIuaWQgPSBzZXRcblxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdXBkYXRlKCkgXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHVzZXIuX2F1dGhyZXF1ZXN0ID0gcmVxdWVzdFxuICAgICAgICAgICAgICAgIHVzZXIuYXV0aGVudGljYXRlKCB0b2tlbiwgcmVxdWVzdCwgdmFsLCB1cGRhdGUgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgdXNlci5pZCA9IGZhbHNlXG4gICAgICAgICAgICAgIHVwZGF0ZSgpIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGxvY2FsU3RvcmFnZVRva2VuOiB7XG4gICAgICB2YWw6IHtcbiAgICAgICAgZGVmZXI6ZnVuY3Rpb24odXBkYXRlLCBhcmdzKSB7XG4gICAgICAgICAgdmFyIHVzZXIgPSB0aGlzLl9jYWxsZXJcbiAgICAgICAgICBpZighdXNlci5fcmVhZExvY2FsU3RvcmFnZSAmJiB0eXBlb2YgdGhpcy52YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB1c2VyLl9yZWFkTG9jYWxTdG9yYWdlID0gdGhpcy52YWxcbiAgICAgICAgICAgIHZhciB0b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKHVzZXIuX3JlYWRMb2NhbFN0b3JhZ2UpXG4gICAgICAgICAgICBpZih0b2tlbiAmJiB0b2tlbiAhPT0gJ3RydWUnKSB7XG4gICAgICAgICAgICAgIHVzZXIudG9rZW4gPSB0b2tlblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXNlci50b2tlbi5vbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHRva2VudmFsID0gdGhpcy52YWxcbiAgICAgICAgICAgICAgaWYodHlwZW9mIHRva2VudmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHVzZXIuX3JlYWRMb2NhbFN0b3JhZ2UsIHRva2VudmFsKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHVzZXIuX3JlYWRMb2NhbFN0b3JhZ2UpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGUodHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgLy8gYmFzZS50b2tlbiA9IGZhbHNlXG5cbiAgYmFzZS5jYXNlcy4kaXNMb2dnZWRJbiA9IG5ldyBWYWx1ZShcbiAgeyB2YWw6IGJhc2UudG9rZW5cbiAgLCB0cmFuc2Zvcm06ZnVuY3Rpb24odmFsLCBjdikge1xuICAgICAgaWYoY3YgPT09IHRydWUpIHJldHVybiAwXG4gICAgfVxuICB9KVxuXG4gIHZhciBteWNsaWVudCA9IGJhc2UuY2xvdWQuY2xpZW50XG5cbiAgbXljbGllbnQub24oZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSl7XG4gICAgLy8gY29uc29sZS5sb2coJ3NvbWV0aGluZyBoYXBwZW5lZCBvbiBteSBjbG91ZCBjbGllbnQhJylcbiAgICBvcmlnaW4gPSBmcm9tIHx8IHRoaXMuX3VwZGF0ZU9yaWdpblxuICAgIGlmKHN0YW1wID09PSBiYXNlLmNsb3VkLnN0YW1wKSB7XG4gICAgICB2YXIgY2xvdWRjbGllbnQgPSBteWNsaWVudC5mcm9tXG4gICAgICBpZihjbG91ZGNsaWVudC50b2tlbil7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLSB0b2tlbiBvbiB1c2VyIGlzIG5vdycsIGJhc2UudG9rZW4udmFsLCAnc2V0IHdpdGgnLCBjbG91ZGNsaWVudC50b2tlbi52YWwpXG4gICAgICAgIGJhc2UudG9rZW4udmFsID0gYmFzZS5fYXV0aHJlcXVlc3QudG9rZW4gPSBjbG91ZGNsaWVudC50b2tlbi52YWxcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0gZGlkIHNldCB0b2tlbiBvbiB1c2VyJylcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgYmFzZS50b2tlbi5fbmFtZSA9ICd0b2tlbidcblxufSlcblxuXG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBiYXNlID0gcmVxdWlyZSgnLi4vLi4vYmFzZScpXG4gICwgVmFsdWUgPSByZXF1aXJlKCcuLi8uLi92YWx1ZScpLy8ubmV3KClcbiAgLCBvYmplY3RTZXQgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKS5zZXRcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG5cbi8vIFZhbHVlLmluamVjdChyZXF1aXJlKCcuL2xpc3Rlbl9maXgnKSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHR5cGU6IFZhbHVlLFxuICBjcmVhdGU6IGZ1bmN0aW9uKHZhbCwgcHJvcCwgc2V0dGluZ3MsIG5vdXBkYXRlKSB7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnY3JlYXRlIGl0JywgdmFsLCBzZXR0aW5ncyApXG4gICAgdmFyIHYgPSBuZXcgVmFsdWUoKVxuICAgIHYuX2Jhc2UgPSB0aGlzXG4gICAgdi5fY2FsbGVyID0gdi5fYmFzZVxuICAgIHYuX3Byb3AgPSBzZXR0aW5nc1xuICAgIC8vIGNvbnNvbGUubG9nKCdzZXQnKVxuICAgIG9iamVjdFNldC5jYWxsKHYsIHZhbCwgZmFsc2UsIGZhbHNlLCB0cnVlKVxuICAgIC8vIGNvbnNvbGUubG9nKCdkb25lIHNldHRpbmcnKVxuICAgIGlmICh0aGlzLl9jbGFzcykgdGhpcy5fY2xhc3MucHJvdG90eXBlLl9bc2V0dGluZ3MubmFtZV0gPSB2XG4gICAgaWYgKHNldHRpbmdzKSB7XG5cbiAgICAgIGlmICghc2V0dGluZ3MuX3ZzZXQpIHtcblxuICAgICAgICAvL2NhbiBhbHNvIGFkZCBhIHRoaW5nIHRvIHNldCBvbiBnZXQgYnkgZGVmYXVsdD9cblxuICAgICAgICBpZihzZXR0aW5ncy5tb2NrKSB7XG4gICAgICAgICAgLy9pZiBub3Qgc2V0IGFkZCBzb21lIGVmZmljaWVuY3kgcGx6XG4gICAgICAgICAgdGhpcy5tb2NrZGF0YSA9IHNldHRpbmdzLm1vY2tcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHNldHRpbmdzLnN1YnNjcmlwdGlvbikge1xuICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHNldHRpbmdzLnN1YnNjcmlwdGlvblxuICAgICAgICB9XG5cbiAgICAgICAgaWYoc2V0dGluZ3Mub24pIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHNldHRpbmdzLm9uID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgdGhpcy5vbi5tb2NrW3NldHRpbmdzLm5hbWVdID0gc2V0dGluZ3Mub25cbiAgICAgICAgICAgIHRoaXMub24udXNlcltzZXR0aW5ncy5uYW1lXSA9IHNldHRpbmdzLm9uXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKHNldHRpbmdzLm9uLm1vY2sgJiYgIXRoaXMub24ubW9ja1tzZXR0aW5ncy5uYW1lXSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhiYXNlLCBiYXNlLm9uKVxuICAgICAgICAgICAgICB0aGlzLm9uLm1vY2tbc2V0dGluZ3MubmFtZV0gPSBzZXR0aW5ncy5vbi5tb2NrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzZXR0aW5ncy5vbi51c2VyICYmICF0aGlzLm9uLnVzZXJbc2V0dGluZ3MubmFtZV0pIHtcbiAgICAgICAgICAgICAgdGhpcy5vbi51c2VyW3NldHRpbmdzLm5hbWVdID0gc2V0dGluZ3Mub24udXNlclxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRpbmdzLl92c2V0ID0gZnVuY3Rpb24oc3RhbXAsIGZyb20sIHJlbW92ZSwgY3ZhbCkge1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciBiYXNlID0gdGhpcy5fY2FsbGVyXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fYmFzZVxuICAgICAgICAgICAgICAgIHx8IHRoaXNcblxuXG4gICAgICAgICAgLy9pZiAhYmFzZSAtLVxuICAgICAgICAgIC8vIGlmKCFiYXNlLilcblxuICAgICAgICAgIGlmKHNldHRpbmdzLnNldCkge1xuICAgICAgICAgICAgc2V0dGluZ3Muc2V0LmNhbGwoXG4gICAgICAgICAgICAgIGJhc2UsIHRoaXMsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGN2YWxcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFub3VwZGF0ZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVVBEQVRFIGNyZWF0aW9uJylcbiAgICAgICAgdi5fdXBkYXRlKHZhbClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbih2YWwsIHByb3AsIHNldHRpbmdzKSB7XG4gICAgLy8gY29uc29sZS5lcnJvcignc2V0IGl0JywgdmFsIClcbiAgICB0aGlzLl9jYWxsZXIgPSB0aGlzXG4gICAgcmV0dXJuIHZhbFxuICB9LFxuICBnZXQ6IGZ1bmN0aW9uKHByb3AsIHNldHRpbmdzKSB7XG4gICAgaWYgKHByb3ApIHByb3AuX2NhbGxlciA9IHRoaXNcbiAgICBpZiAoc2V0dGluZ3MuZ2V0KSByZXR1cm4gc2V0dGluZ3MuZ2V0LmNhbGwodGhpcywgcHJvcClcbiAgICByZXR1cm4gcHJvcFxuICB9XG59IiwidmFyIHV0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbCcpXG5cbnZhciB2T2JqZWN0ID0gcmVxdWlyZSgndmlnb3VyLWpzL29iamVjdCcpXG5cbnZhciBNb2NrRGF0YSA9IHJlcXVpcmUoJy4vbW9ja2RhdGEnKVxuXG52YXIgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG5cbnZhciBEYXRhID0gcmVxdWlyZSgndmlnb3VyLWpzL2RhdGEnKVxuICAgICAgLmluamVjdCggcmVxdWlyZSgndmlnb3VyLWpzL2RhdGEvc2VsZWN0aW9uJykgKVxuXG5cbnJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZS9mbGFncy9wcm9jZXNzJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZFxuKCBmdW5jdGlvbiggdXNlciApIHtcblxuICB2YXIgY29udGVudCA9IHVzZXIucGFyZW50LmluamVjdChyZXF1aXJlKCcuLi9jb250ZW50JykpLmNvbnRlbnRcblxuICB1c2VyLmV4dGVuZCh7XG4gICAgdXNhZ2U6IHtcbiAgICAgIG1vY2s6IHtcbiAgICAgICAgdXNhZ2U6e31cbiAgICAgIH0sXG4gICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgdXNhZ2U6IHtcbiAgICAgICAgICBzaG93czoge1xuICAgICAgICAgICAgJDoge1xuICAgICAgICAgICAgICBtZWRpYTp7XG4gICAgICAgICAgICAgICAgLy9kaXQgbW9ldCBzb3dpZXNvIG5pZXQgdGl0bGUgd29yZGVuISBsaWV2ZXIgZ2V3b29uIHRydWUgb2YgaWQgb2Z6b1xuICAgICAgICAgICAgICAgICQ6dHJ1ZVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmYXZvdXJpdGU6dHJ1ZSxcbiAgICAgICAgICAgICAgdGltZXN0YW1wOnRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbjoge1xuICAgICAgICBtb2NrOmZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMudXNhZ2UgPSB0aGlzLm1vY2tkYXRhLnVzYWdlXG4gICAgICAgIH0sXG4gICAgICAgIHVzZXI6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy51c2FnZSA9IHRoaXMuZGF0YS5mcm9tLmdldCgndXNhZ2UnLHt9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHdhdGNoZWQ6e1xuICAgICAgb246IHtcbiAgICAgICAgLy9taXNjaGllbiBlaWdlbiAsIG5pZXV3ZSBzZWxlY3Rpb24gbWFrZW4gYWx2YXN0XG4gICAgICAgIG1vY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmKHRoaXMuX193YXRjaGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9fd2F0Y2hlZC5yZW1vdmUoKVxuICAgICAgICAgICAgdGhpcy5fX3dhdGNoZWQgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKHRoaXMud2F0Y2hlZCkgdGhpcy53YXRjaGVkLiRlbXB0eSgpXG4gICAgICAgICAgdGhpcy53YXRjaGVkID0ge31cbiAgICAgICAgfSxcbiAgICAgICAgdXNlcjpmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgdXNlciA9IHRoaXNcbiAgICAgICAgICBpZih0aGlzLl9fd2F0Y2hlZCkge1xuICAgICAgICAgICAgdGhpcy5fX3dhdGNoZWQucmVtb3ZlKClcbiAgICAgICAgICAgIHRoaXMuX193YXRjaGVkID0gbnVsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzLl9fd2F0Y2hlZCA9IG5ldyBEYXRhKCB1c2VyLnVzYWdlLmZyb20uZ2V0KCdzaG93cycpICwge1xuICAgICAgICAgICAgY29uZGl0aW9uOiB7IFxuICAgICAgICAgICAgICBtZWRpYToge1xuICAgICAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgICAgICAkZXhpc3RzOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIHVzZXIud2F0Y2hlZCA9IHt9XG5cbiAgICAgICAgICBzZWxlY3Rpb24ub24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2V0cyA9IHt9XG5cbiAgICAgICAgICAgIHNlbGVjdGlvbi5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgICAgdmFyIGJsYSA9ICBjb250ZW50LmdldCh0aGlzLl9wYXRoLnNsaWNlKC0yKSlcbiAgICAgICAgICAgICAgdmFyIG9iaiA9IHt9XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB1dGlsLnBhdGgob2JqLCBibGEuX3BhdGgsIHtcbiAgICAgICAgICAgICAgICBpbWc6dHJ1ZSxcbiAgICAgICAgICAgICAgICB0aXRsZTp0cnVlXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICB2YXIgX2Nsb3VkID0gIHVzZXIucGFyZW50LmNsb3VkXG4gICAgICAgICAgICAgX2Nsb3VkLnN1YnNjcmliZShvYmopXG5cbiAgICAgICAgICAgICAgdXNlci53YXRjaGVkLnNldCh0aGlzLl9uYW1lLCBcbiAgICAgICAgICAgICAgeyBzaG93OiBibGFcbiAgICAgICAgICAgICAgLCBtZWRpYTogdGhpcy5tZWRpYS5mcm9tXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgdXNlci53YXRjaGVkW3RoaXMuX25hbWVdLm9uY2UoJ3JlbW92ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIF9jbG91ZC51bnN1YnNjcmliZShvYmopXG4gICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgc2V0c1t0aGlzLl9uYW1lXSA9IHRydWVcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHVzZXIud2F0Y2hlZC5lYWNoKGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgICAgICAgaWYoIXNldHNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBpZih1c2VyLndhdGNoZWQpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBzZXRzID0gZmFsc2VcblxuICAgICAgICAgICAgdXNlci53YXRjaGVkLnVwZGF0ZSgpXG4gICAgICAgICAgfSlcbiAgICAgICAgICBzZWxlY3Rpb24uX3VwZGF0ZSgpXG5cbiAgICAgICAgfVxuICAgICAgfSBcbiAgICB9LFxuXG4gICAgZmF2b3VyaXRlczp7XG4gICAgICBvbjoge1xuICAgICAgICAvL21pc2NoaWVuIGVpZ2VuICwgbmlldXdlIHNlbGVjdGlvbiBtYWtlbiBhbHZhc3RcbiAgICAgICAgbW9jazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYodGhpcy5fX2Zhdm91cml0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX19mYXZvdXJpdGVzLnJlbW92ZSgpXG4gICAgICAgICAgICB0aGlzLl9fZmF2b3VyaXRlcyA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYodGhpcy5mYXZvdXJpdGVzKSB0aGlzLmZhdm91cml0ZXMuJGVtcHR5KClcbiAgICAgICAgICB0aGlzLmZhdm91cml0ZXMgPSB7fVxuICAgICAgICB9LFxuICAgICAgICB1c2VyOmZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciB1c2VyID0gdGhpc1xuICAgICAgICAgIGlmKHVzZXIuX19mYXZvdXJpdGVzKSB7XG4gICAgICAgICAgICB1c2VyLl9fZmF2b3VyaXRlcy5yZW1vdmUoKVxuICAgICAgICAgICAgdXNlci5fX2Zhdm91cml0ZXMgPSBudWxsXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZmF2b3VyaXRlcy4kZW1wdHkoKVxuICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB1c2VyLl9fZmF2b3VyaXRlcyA9IG5ldyBEYXRhKCB1c2VyLnVzYWdlLmZyb20uZ2V0KCdzaG93cycpICwge1xuICAgICAgICAgICAgY29uZGl0aW9uOiB7IFxuICAgICAgICAgICAgICBmYXZvdXJpdGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgdXNlci5mYXZvdXJpdGVzID0ge31cblxuICAgICAgICAgIHNlbGVjdGlvbi5vbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZXRzID0ge31cblxuICAgICAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICB2YXIgYmxhID0gIGNvbnRlbnQuZ2V0KHRoaXMuX3BhdGguc2xpY2UoLTIpKVxuXG4gICAgICAgICAgICAgIHVzZXIuZmF2b3VyaXRlcy5zZXQodGhpcy5fbmFtZSxibGEpXG4gICAgICAgICAgICAgIHNldHNbdGhpcy5fbmFtZV0gPSB0cnVlXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB1c2VyLmZhdm91cml0ZXMuZWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIGlmKCFzZXRzW25hbWVdICApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHNldHMgPSBmYWxzZVxuXG4gICAgICAgICAgICB1c2VyLmZhdm91cml0ZXMudXBkYXRlKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIHNlbGVjdGlvbi5fdXBkYXRlKClcblxuICAgICAgICB9XG4gICAgICB9IFxuICAgIH1cbiAgfSlcblxuICB1c2VyLmV4dGVuZCh7XG4gICAgaGFzV2F0Y2hlZDoge1xuICAgICAgdmFsOiB7XG4gICAgICAgIHZhbDogdXNlci53YXRjaGVkLFxuICAgICAgICB0cmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICAgICAgfVxuICAgIH0sXG4gICAgaGFzRmF2b3VyaXRlczoge1xuICAgICAgdmFsOiB7XG4gICAgICAgIHZhbDogdXNlci5mYXZvdXJpdGVzLFxuICAgICAgICB0cmFuc2Zvcm06IGhhc1RyYW5zZm9ybVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICB2YXIgb2xkQ29udGVudCA9IGNvbnRlbnQuX3ZhbFxuXG4gIGNvbnRlbnQub24oJ3NlbGYnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnY29udGVudCBpcyBjaGFuZ2luZyBmcm9tJywgb2xkQ29udGVudCAmJiBvbGRDb250ZW50Ll9wYXRoLCAndG8nLCB0aGlzLl92YWwuX3BhdGgpXG4gICAgaWYoIHVzZXIudG9rZW4udmFsICkge1xuICAgICAgcmVzb2x2ZVdhdGNoZWRNZWRpYSggdXNlciApXG4gICAgICB1c2VyLmZhdm91cml0ZXMuX3Byb3Aub24udXNlci5jYWxsKHVzZXIpXG4gICAgICB1c2VyLndhdGNoZWQuX3Byb3Aub24udXNlci5jYWxsKHVzZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmVXYXRjaGVkTWVkaWEoIHVzZXIgKVxuICAgICAgdXNlci5mYXZvdXJpdGVzLl9wcm9wLm9uLm1vY2suY2FsbCh1c2VyKVxuICAgICAgdXNlci53YXRjaGVkLl9wcm9wLm9uLnVzZXIuY2FsbCh1c2VyKVxuICAgIH1cbiAgfSlcblxuICBjYXNlcy4kaGFzRmF2b3VyaXRlcyA9IHVzZXIuaGFzRmF2b3VyaXRlc1xuICBjYXNlcy4kaGFzV2F0Y2hlZCA9IHVzZXIuaGFzV2F0Y2hlZFxuXG59KVxuXG5mdW5jdGlvbiByZXNvbHZlV2F0Y2hlZE1lZGlhKCB1c2VyICkge1xuICB1c2VyLndhdGNoZWQuZnJvbS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgIHZhciBtZWRpYSA9IHRoaXMubWVkaWEgJiYgdGhpcy5tZWRpYS5mcm9tXG4gICAgaWYobWVkaWEpIHtcblxuICAgICAgdmFyIG5ld1BhdGggPSB1c2VyLnBhcmVudC5jb250ZW50LmZyb20uX3BhdGguY29uY2F0KCBtZWRpYS5fY29udGVudFBhdGggKSAgICAgICBcbiAgICAgIHZhciBvbGRQYXRoID0gbWVkaWEuX3BhdGhcblxuICAgICAgaWYoICF1dGlsLmNvbXBhcmVBcnJheXMoIG9sZFBhdGgsIG5ld1BhdGggKSApIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Jlc29sdmUnLCBvbGRQYXRoLCBuZXdQYXRoKVxuICAgICAgICB0aGlzLm1lZGlhLnZhbCA9IHVzZXIucGFyZW50LmNvbnRlbnQuZ2V0KCBuZXdQYXRoIClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGhhc1RyYW5zZm9ybSggYywgY3YpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IGMuX3BhcmVudC5fdmFsXG4gIGlmKHNlbGVjdGlvbikge1xuICAgIGlmKHNlbGVjdGlvbi4kbGVuZ3RoLnZhbD4wKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gMFxufVxuICAiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIFZhbHVlID0gcmVxdWlyZSgnLi4vdmFsdWUnKVxuICAsIHVybCA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvbmV0d29yay91cmwnKVxuICAsIHVhID0gcmVxdWlyZSgnLi4vYnJvd3Nlci91YScpXG5cbnJlcXVpcmUoJy4uL3ZhbHVlL2ZsYWdzL3Byb2Nlc3MnKVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoIGZ1bmN0aW9uKCBhcHAgKSB7XG5cbiAgLy91c2UgY2FzZXMgcmVmZXJlbmNlIG9uIGFwcFxuICB2YXIgY2FzZXMgPSBhcHAuY2FzZXMgfHwgKCBhcHAuY2FzZXMgPSByZXF1aXJlKCcuLi9icm93c2VyL2Nhc2VzJykgKVxuXG4gIGFwcC5pbml0aWFsaXNlZCA9IG5ldyBWYWx1ZSggZmFsc2UgKVxuXG4gIGFwcC5vdmVybGF5ID0gbmV3IFZhbHVlKCBmYWxzZSApXG5cbiAgYXBwLmZvY3VzU3RhdGUgPSBuZXcgVmFsdWUoJ21lbnUnKVxuXG4gIGFwcC5yZWdpb24gPSBuZXcgVmFsdWUoeyBpbml0OiBhcHAuaW5pdGlhbGlzZWQgfSlcbiAgLy9icm93c2VyXG4gIC8vdWEuYnJvd3NlclxuXG4gIGFwcC51cmwgPSB1YS5kZXZpY2UgPT09ICd0dicgJiYgdWEucGxhdGZvcm0gPT09ICdsZycgXG4gICAgICAgID8gIG5ldyBWYWx1ZSh7ZGVmZXI6ZnVuY3Rpb24oKXt9LCBwYXJhbXM6e30sIHN0cmluZzonJ30pIFxuICAgICAgICA6ICB1cmwgXG4gIC8vb29rIHBhcyBvcCBhcHAgaW5pdGlsaXNlZCFcblxuICBhcHAucmVhZHkgPSBuZXcgVmFsdWUoKVxuXG4gIGFwcC5tZW51ID0gbmV3IFZhbHVlKHsgaW5pdDogYXBwLnJlYWR5IH0pXG5cbiAgLy9UT0RPOm5ldHdvcmtcbiAgLy9tb3ZlIG5ldHdvcmsgYXBpIGZpbGUgdG8gaGVyZSBwZXJoYXBzXG4gIGFwcC5uZXR3b3JrID0gbmV3IFZhbHVlKClcblxuICAvL1RPRE86IGRvdWJsZSBjaGVjayB0aGlzIGlzIGVmZmljaWVudFxuICBhcHAubG9hZGluZyA9IG5ldyBWYWx1ZSh7IFxuICAgIGluaXQ6IGFwcC5yZWFkeVxuICAsIGRlZmVyOiBmdW5jdGlvbiggdXBkYXRlLCBhcmdzICkge1xuICAgICAgLy9UT0RPOiBjYWNoZWQgdXBkYXRlUGF0aCA/XG4gICAgICB2YXIgaWQgPSB0aGlzLnVwZGF0ZVBhdGguam9pbignLicpXG4gICAgICBpZiggYXJnc1swXT09PWZhbHNlICYmICggKGlkICYmIGlkID09PSB0aGlzLmlkKSB8fCAhdGhpcy5pZCApICkge1xuICAgICAgICB0aGlzLnZhbCA9IGFyZ3NbMF1cbiAgICAgICAgdGhpcy5pZCA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYoIGFyZ3NbMF0gPT09IHRydWUgKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZFxuICAgICAgICB0aGlzLnZhbCA9IHRydWVcbiAgICAgIH1cbiAgICAgIHVwZGF0ZSgpXG4gICAgfVxuICAgIC8vYWRkIGRlZmVyZWQgbGF0ZXIgKG1heWJlIGRvbnQgc2hvdyBhIGxvYWRlciBmb3IgbGVzcyB0aGVuIHh4eCBzZWMpIFxuICB9KVxuXG4gIC8vICdfc2V0JywgZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBub3VwZGF0ZSwgYWRkZWQsIG9sZHZhbCkge1xuICAvL2FkZCBsb2NhbHN0b3JhZ2VcblxuICB2YXIgZ3Vlc3NMYW5ndWFnZSA9IGFwcC5ndWVzc0xhbmd1YWdlID0gZnVuY3Rpb24gZ3Vlc3NMYW5ndWFnZSgpe1xuICAgIC8vVE9ETzogY29yZG92YSBsYW5ndWFnZVxuICAgIHZhciBndWVzcyA9IHdpbmRvdy5uYXZpZ2F0b3IudXNlckxhbmd1YWdlXG4gICAgICAgICAgICAgfHwgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZVxuICAgICAgICAgICAgIHx8IGFwcC5yZWdpb24udmFsIFxuICAgIGlmKGd1ZXNzKVxuICAgICAgcmV0dXJuIGd1ZXNzLnNsaWNlKDAsMikudG9Mb3dlckNhc2UoKVxuICB9XG5cbiBhcHAubGFuZ3VhZ2UgPSBuZXcgVmFsdWUoICBcbiAgeyB0cmFuc2Zvcm06IGZ1bmN0aW9uKCB2YWwsIGN2ICkge1xuICAgICAgaWYoIWN2IHx8IHR5cGVvZiBjdiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgY3YgPSBndWVzc0xhbmd1YWdlKClcbiAgICAgIH0gXG4gICAgICByZXR1cm4gY3YgPyBjdi5zbGljZSgwLDIpLnRvTG93ZXJDYXNlKCkgOiBmYWxzZVxuICAgIH1cbiAgLCBpbml0OiBhcHAuaW5pdGlhbGlzZWQgXG4gIH0pXG5cbiAgYXBwLmZ1bGxzY3JlZW4gPSBuZXcgVmFsdWUoeyBmb3JjZTogdHJ1ZSB9KVxuXG4gIGFwcC5sb2FkZXIgPSBuZXcgVmFsdWUoKVxuXG4gIGFwcC52b2x1bWUgPSBuZXcgVmFsdWUoXG4gIHsgdmFsOjFcbiAgLCB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICAvLyBjb25zb2xlLmxvZygndm9sdW1lPycsY3YsaXNOYU4oY3YpID8gMSA6IGN2KVxuICAgICAgLy9UT0RPOiB1c2UgbG9EYXNoIGZvciBpc05hblxuICAgICAgcmV0dXJuIGlzTmFOKGN2KSA/IDEgOiBjdlxuICAgIH1cbiAgfSlcblxuICBhcHAucG9wdXAgPSBuZXcgVmFsdWUoeyBpbml0OiBhcHAucmVhZHkgfSlcblxuICBhcHAucHJldmlldyA9IG5ldyBWYWx1ZSh7IGluaXQ6IGFwcC5yZWFkeSB9KVxuXG4gIGFwcC5oaWdobGlnaHQgPSBuZXcgVmFsdWUoeyBpbml0OiBhcHAucmVhZHkgfSlcblxuICBhcHAuc3RhdGUgPSBuZXcgVmFsdWUoeyBpbml0OiBhcHAucmVhZHkgfSlcbiAgXG4gIGFwcC5ub3RpZmljYXRpb24gPSBuZXcgVmFsdWUoIFxuICB7IGluaXQ6IGFwcC5yZWFkeSAgXG4gICwgZm9yY2U6IHRydWUgLy9UT0RPOiBtYWtlIHRoaXMgYmV0dGVyXG4gIH0pXG5cbiAgYXBwLmlzUGxheWluZyA9IG5ldyBWYWx1ZShcbiAgeyBpbml0OiBhcHAucmVhZHlcbiAgLCB2YWw6ZmFsc2VcbiAgfSlcblxuICBhcHAucmVzdHJpY3RQbGF5YmFjayA9IG5ldyBWYWx1ZSgpXG5cbiAgLy9tYWtlIGluamVjdGFibGVcbiAgYXBwLndpZmlPbmx5ID0gbmV3IFZhbHVlKFxuICAgIGxvY2FsU3RvcmFnZSBcbiAgICA/IHsgdmFsOiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnd2lmaU9ubHknKSB8fCBmYWxzZVxuICAgICAgLCBkZWZlcjpmdW5jdGlvbiggdXBkYXRlICl7XG4gICAgICAgICAgaWYodGhpcy5fdmFsKSBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnd2lmaU9ubHknLHRydWUpXG4gICAgICAgICAgZWxzZSBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgnd2lmaU9ubHknKVxuICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICA6IGZhbHNlXG4gIClcblxuICBhcHAucmVzdHJpY3RQbGF5YmFjay52YWwgPSBcbiAgeyB2YWw6IGFwcC53aWZpT25seVxuICAsIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIHJldHVybiAoIGN2ICYmIGNhc2VzLiRpc05hdGl2ZSAmJiBhcGkubmV0d29yay52YWwgIT09ICd3aWZpJyApXG4gICAgICAgID8gdHJ1ZVxuICAgICAgICA6IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogbW92ZSB0aGlzIChzZXR0aW5nIGNhc2UgdmFsdWUpIG91dCBvZiBhcHAgdmFsdWVzXG4gIGNhc2VzLiRzdG9yZUF2YWlsYWJsZSA9IG5ldyBWYWx1ZSggXG4gICAgY2FzZXMuJGlzTmF0aXZlICYmICggY2FzZXMuJGlzSW9zIHx8IGNhc2VzLiRpc0FuZHJvaWQgfHwgY2FzZXMuJGlzV2luZG93c01vYmlsZSApIC8vJiYgd2luZG93LlN0b3JlXG4gIClcblxufSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgViA9IHJlcXVpcmUoJy4uLycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIGluamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvaW5qZWN0Jylcbi8vICwgcmFmID0gcmVxdWlyZSgnLi4vYnJvd3Nlci9hbmltYXRpb24vcmFmJylcblxuXG4vKlxuICB1dGlsLmRlZmluZSggZXh0ZW5kLCAnZXh0ZW5zaW9ucycse3ZhbDpbXSwgc2V0Q2xhc3M6dHJ1ZX0gKVxuKi9cblxuLyoqXG4gKiBCYXNlIGlzIHVzZWQgYXMgYSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAqIEBjb25zdHJ1Y3RvciBWLkJhc2VcbiAqIEBwYXJhbSAgeyp9IFt2YWxdIFN0YXJ0dmFsdWUgZm9yIG5ldyBWLkJhc2VcbiAqL1xudmFyIGJhc2UgPSBWLkJhc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbih2YWwpIHtcbiAgdGhpcy5fZnJvbSA9IHRoaXMuY29uc3RydWN0b3JcbiAgaWYgKHZhbCkgdGhpcy5zZXQodmFsKVxufVxuXG5leHBvcnRzLnNldHRpbmdzID0gcmVxdWlyZSgnLi9zZXR0aW5ncycpXG5cbi8qKlxuICogU2V0cyBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gYW4gb2JqZWN0LlxuICogRGVmaW5lIGEgX3NldCBtZXRob2Qgb24gYSBiYXNlIGluc3RhbmNlIHRvIGdldCBjdXN0b20gbWV0aG9kIHBlciBzZXQuXG4gKiBAZnVuY3Rpb24gX3NldFxuICogQHBhcmFtICB7Kn0gdmFsICAgICAgICAgQW55IHZhbHVlXG4gKiBAcGFyYW0gIHsqfSBbcGFyYW1zXSAgICBBZGRlZCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG5vc2V0ICBXaGVuIHRydWUgcmV0dXJucyBhIHBhcnNlZCB2YWwgb2JqZWN0IGJ1dCBzZXQgbm90aGluZ1xuICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgcmV0dXJuIHNlbGYgZm9yIGNoYWluaW5nXG4gKi9cbnZhciBfc2V0ID0gZXhwb3J0cy5zZXQgPSBmdW5jdGlvbih2YWwsIHBhcmFtcywgbm9zZXQpIHtcbiAgZm9yICh2YXIgaSBpbiB2YWwpIHtcbiAgICBpZiAofmkuaW5kZXhPZignLCcpKSB7XG4gICAgICBmb3IgKHZhciBhcnIgPSBpLnNwbGl0KCcsJyksIG11bHRpb2JqID0ge30sIG0gPSAwLCBtbCA9IGFyci5sZW5ndGg7IG0gPCBtbDsgbSsrKSB7XG4gICAgICAgIG11bHRpb2JqW2FyclttXV0gPSB1dGlsLmNsb25lKHZhbFtpXSlcbiAgICAgIH1cbiAgICAgIGlmICghbm9zZXQpIHtcbiAgICAgICAgX3NldC5jYWxsKHRoaXMsIG11bHRpb2JqLCBwYXJhbXMsIG5vc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHZhbFtpXVxuICAgICAgICBmb3IgKHZhciBuIGluIG11bHRpb2JqKSB7XG4gICAgICAgICAgdmFsW25dID0gbXVsdGlvYmpbbl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpID0gdXRpbC5kb3RGaWVsZCh2YWwsIGkpXG5cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoICdTRVQnLCB0aGlzLCB0aGlzLl9zZXQpXG5cbiAgICAgIGlmICh0aGlzLl9zZXQgJiYgIW5vc2V0KSB7XG4gICAgICAgIHRoaXMuX3NldC5jYWxsKHRoaXMsIHZhbCwgaSwgcGFyYW1zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9UT0RPOiBjaGVjayBmb3IgcHJvcGVydHkgbW92ZSBmcm9tIGVsZW1lbnQgc2V0IHRvIGhlcmVcbiAgICAgICAgLy8gaWYoIFYuT2JqZWN0ICYmIHRoaXMuaXNQcm9wZXJ0eSggaSwgdmFsICkgJiYgdGhpc1tpXSBpbnN0YW5jZW9mIFYuT2JqZWN0IClcbiAgICAgICAgLy8ge1xuICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCc/PycsIGksIHZhbCwgdGhpcy5pc1Byb3BlcnR5KCBpLCB2YWwgKSApXG4gICAgICAgIC8vICAgdGhpc1tpXS52YWwgPSB2YWxbaV1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vIHtcbiAgICAgICAgICB0aGlzW2ldID0gdmFsW2ldXG4gICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vc2V0ID8gdmFsIDogdGhpc1xufTtcblxudXRpbC5kZWZpbmUoYmFzZSxcbiAgLyoqXG4gICAqIFdoZW4gYSBCYXNlIGlzIGV4dGVuZGVkIHdpdGhvdXQgZGVmaW5pbmcgdGhlIHR5cGUgdGhpcyBpcyB0aGUgZGVmYXVsdCB0eXBlLlxuICAgKiBAcHJvcGVydHkgZGVmYXVsdFR5cGVcbiAgICovXG4gICdpc1Byb3BlcnR5JywgZnVuY3Rpb24oIGksIHZhbCkge1xuICAgIHZhciB0ID0gdGhpc1xuICAgICAgLCByZXN1bHQgPSBcblxuICAgICAgXG4gICAgLy8gdmFsW2ldIGluc3RhbmNlb2YgT2JqZWN0ICAvL1RISVMgTUFZIEdPIEFXQVkgTEFURVJcbiAgICAgICAgICAgLy9UT0RPOiBjaGVjayBpZiB0aGlzIGlzIHJlYWxseSBuZXNzZXJhY3kgKCB2b2lkIDAgKVxuICAgICAgICAgICAvLyAmJiBcblxuICAgICAgLy9TVVBFUiBEQU5HRVJHT1VTIFRISU5HXG5cbiAgICAgICAgICAhKCB0Ll9baV0gPT09IHZvaWQgMCAvLy0tLSBkYW5nZXIgcmVzb2x2ZSB3aGVuIGRlZmluZSBfIGlzIGZpeGVkXG4gICAgICAgICAgICYmICF1dGlsLmxvb2t1cC5jYWxsKHQsIGkpIFxuICAgICAgICAgICAmJiB0eXBlb2YgdFtpXSE9PSdmdW5jdGlvbicgXG4gICAgICAgICAgKVxuXG4gICAgLy8gY29uc29sZS5sb2coIHZhbFtpXSBpbnN0YW5jZW9mIE9iamVjdCwgdC5fW2ldID09PSB2b2lkIDAsICd2YWw6Jyx0Ll9baV0sICF1dGlsLmxvb2t1cC5jYWxsKHQsIGkpLCB0eXBlb2YgdFtpXSE9PSdmdW5jdGlvbicgIClcblxuICAgIC8vIGNvbnNvbGUubG9nKCAnSVMgUFJPUEVSVFknLCBpLCByZXN1bHQgKVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9LFxuICAnZGVmYXVsdFR5cGUnLCBmYWxzZSxcbiAgJ2V4dGVuc2lvbnMnLCBmYWxzZSxcbiAgJ2RlZmluZScsIGZ1bmN0aW9uKHZhbCkge1xuICAgIGZvcih2YXIgaSBpbiB2YWwpIHtcbiAgICAgIHV0aWwuZGVmaW5lKCB0aGlzLCBpLCB2YWxbaV0gKVxuICAgICAgdXRpbC5kZWZpbmUoIHRoaXMuQ2xhc3MsIGksIHZhbFtpXSApXG4gICAgfVxuICB9LFxuICAvKipcbiAgICogRXh0ZW5kIGlzIHVzZWQgdG8gYWRkIHByb3BlcnRpZXMgdG8gYmFzZS5cbiAgICogU2V0dGluZ3MgYXJlIHNpbWlsYXIgdG8gc3RhbmRhcmQgZGVmaW5lUHJvcGVydHkuXG4gICAqIEBtZXRob2QgZXh0ZW5kXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgc2V0dGluZ3MgICAgICAgIERlZmluZSB0aGUgZm9sbG93aW5nIGZpZWxkczogbmFtZSwgdHlwZSwgc2V0LCBuZXcsIHJlbW92ZS5cbiAgICogQHBhcmFtICAge1N0cmluZ30gICBzZXR0aW5ncy5uYW1lICAgRGVmaW5lIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgIFtzZXR0aW5ncy50eXBlXSBEZWZpbmUgdGhlIHR5cGUgb2Ygb2JqZWN0IGUuZy4gVi5WYWx1ZSwgc2V0IHR5cGUgdG8gZmFsc2UgaWYgeW91IHdhbnQgdG8gdXNlIHN0YW5kYXJkIGRlZmluZVByb3BlcnR5XG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gc2V0dGluZ3Muc2V0ICAgIERlZmluZSBhIGZ1bmN0aW9uIG9uIHNldFxuICAgKiBAcGFyYW0gICB7RnVuY3Rpb259IHNldHRpbmdzLm5ldyAgICBEZWZpbmUgYSBmdW5jdGlvbiBvbiBjb25zdHJ1Y3RcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSBzZXR0aW5ncy5yZW1vdmUgRGVmaW5lIGEgZnVuY3Rpb24gb24gcmVtb3ZlXG4gICAqIEByZXR1cm4gIHtbdHlwZV19ICAgICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdleHRlbmQnLCBmdW5jdGlvbihzZXR0aW5ncykge1xuXG4gICAgLy9UT0RPOiBhZGQgdG8gaW5zdGFuY2UgYXMgd2VsbCAsIGhhdmUgYSBkaWN0aW9uYXJ5IG9mIGV4dGVuc3Rpb25zIC0tIGdldCB0byBvcmdpbmFsIGVhc3lseVxuICAgIHZhciBhcmdzID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgICAgLCBsID0gYXJncy5sZW5ndGhcbiAgICAgICwgaVxuXG4gICAgaWYgKGwgPiAxKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgdGhpcy5leHRlbmQoIGFyZ3NbaSsrXSApKTtcbiAgICB9IGVsc2UgaWYgKCFzZXR0aW5ncy5uYW1lKSB7XG4gICAgICBmb3IgKGkgaW4gc2V0dGluZ3MpIHtcblxuICAgICAgICBpZiggdHlwZW9mIHNldHRpbmdzW2ldID09PSAnZnVuY3Rpb24nICkgXG4gICAgICAgIHtcbiAgICAgICAgICB0aGlzLmV4dGVuZCggeyBuYW1lOiBpLCBzZXQ6IHNldHRpbmdzW2ldIH0gKVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAge1xuICAgICAgICAgIHNldHRpbmdzW2ldLm5hbWUgPSBpXG4gICAgICAgICAgdGhpcy5leHRlbmQoIHNldHRpbmdzW2ldIClcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYoIHNldHRpbmdzID09PSB0cnVlICl7XG4gICAgICAgIGFsZXJ0KClcbiAgICAgIH1cblxuXG4gICAgICBpZiAoIXNldHRpbmdzLmRlZiAmJiBzZXR0aW5ncy5kZWYgIT09IDApIHNldHRpbmdzLmRlZiA9IGZhbHNlO1xuICBcbiAgICAgIGlmICh0aGlzLkNsYXNzLnByb3RvdHlwZS5fc2V0dGluZ3MpIHtcbiAgICAgICAgZXhwb3J0cy5zZXR0aW5ncy5wYXJzZS5jYWxsKHRoaXMsIHNldHRpbmdzKVxuICAgICAgICBpZiAoc2V0dGluZ3MuX3NldHRpbmdzKSBleHBvcnRzLnNldHRpbmdzLmNyZWF0ZS5jYWxsKHRoaXMsIHNldHRpbmdzKVxuICAgICAgfVxuICAgICAgLy8xLiBub3JtYWwgZXh0ZW5zaW9uc1xuICAgICAgaWYgKHNldHRpbmdzLnR5cGUgPT09IGZhbHNlIHx8ICggIXNldHRpbmdzLnR5cGUgJiYgIXRoaXMuZGVmYXVsdFR5cGUgKSApIHtcblxuICAgICAgICAvL1RPRE86IHRlc3QgaWYgZG91YmxlIGRlZmluZSBpcyBhY3R1YWxseSBvayFcbiAgICAgICAgLy8gdXRpbC5kZWZpbmUodGhpcywgc2V0dGluZ3MubmFtZSwgc2V0dGluZ3MpXG5cbiAgICAgICAgdXRpbC5kZWZpbmUodGhpcy5DbGFzcywgc2V0dGluZ3MubmFtZSwgc2V0dGluZ3MpXG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vMi4gVi5WYWx1ZXNcbiAgICAgICAgaWYgKCFzZXR0aW5ncy50eXBlKSBzZXR0aW5ncy50eXBlID0gdGhpcy5kZWZhdWx0VHlwZVxuICAgICAgICAgIC8vYSB0eXBlIGhhcyBmaWVsZHMgdHlwZSwgc2V0ICxnZXQsIGNyZWF0ZVxuICAgICAgICB2YXIgZ2V0ID0gIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgIC8vY3VzdG9tIGdldFxuICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnR5cGUuZ2V0IFxuICAgICAgICAgICAgICA/IHNldHRpbmdzLnR5cGUuZ2V0LmNhbGwodGhpcywgcHJvcCwgc2V0dGluZ3MpXG4gICAgICAgICAgICAgIDogcHJvcFxuICAgICAgICAgIH1cbiAgICAgICAgICAsIHNldCA9ICBmdW5jdGlvbih2YWwpIHtcblxuICAgICAgICAgICAgdmFyIHByb3AgPSB0aGlzW3NldHRpbmdzLm5hbWVdXG4gICAgICAgICAgICBpZihwcm9wPT09bnVsbCkgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvcD09PXNldHRpbmdzLmRlZikgeyAvLyhwcm9wIGluc3RhbmNlb2YgVi5PYmplY3QpXG4gICAgICAgICAgICAgIC8vcmV0dXJuIGlzIGhpZXIgbWlzY2hpZW4gbmlldCBub2RpZztcbiAgICAgICAgICAgICAgcmV0dXJuIHNldHRpbmdzLnR5cGUuY3JlYXRlLmNhbGwodGhpcywgdmFsLCBwcm9wLCBzZXR0aW5ncylcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbCA9IHNldHRpbmdzLnR5cGUuc2V0LmNhbGwodGhpcywgdmFsLCBwcm9wLCBzZXR0aW5ncylcbiAgICAgICAgICAgICAgaWYgKHZhbCE9PSBudWxsKSBwcm9wLnZhbCA9IHZhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAvL1RPRE86IHRlc3QgaWYgZG91YmxlIGRlZmluZSBpcyBhY3R1YWxseSBvayFcbiAgICAgICAgdXRpbC5kZWZpbmUoXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBzZXR0aW5ncy5uYW1lLFxuICAgICAgICAgIHNldHRpbmdzLmRlZixcbiAgICAgICAgICBzZXQsXG4gICAgICAgICAgZ2V0LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuICAgICAgICAvL2RpdCBicmVha2VkIHdhdCBzaGl0XG5cbiAgICAgICAgLy9vciBvbiB2YWx1ZSA/IHZhbHVlLnByb3BcblxuICAgICAgICAvL21ha2UgZXh0ZW5kZWQgcHJvdG90eXBlIG9iamVjdCBwZXJoYXBzXG4gICAgICAgIC8vIHRoaXMuQ2xhc3MucHJvdG90eXBlWydfXycrc2V0dGluZ3MubmFtZSsnX18nXSA9IHNldHRpbmdzXG5cbiAgICAgICAgdXRpbC5kZWZpbmUoXG4gICAgICAgICAgdGhpcy5DbGFzcyxcbiAgICAgICAgICBzZXR0aW5ncy5uYW1lLFxuICAgICAgICAgIHNldHRpbmdzLmRlZixcbiAgICAgICAgICBzZXQsXG4gICAgICAgICAgZ2V0XG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoaXMgQmFzZS4gQWxzbyByZW1vdmVzIGFsbCBsaXN0ZW5lcnMgYWRkZWQgdG8gZXh0ZW5zaW9ucy5cbiAgICogSW5zdGFuY2VzIHRydWUgd2lsbCByZW1vdmUgYWxsIGluc3RhbmNlcyBhcyB3ZWxsLlxuICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGluc3RhbmNlcyAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGZyb21yZW1vdmUgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHBhcmFtcyAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ3JlbW92ZScsIGZ1bmN0aW9uKGluc3RhbmNlcywgZnJvbXJlbW92ZSwgcGFyYW1zKSB7XG5cbiAgICAvLyB0aGlzLl9yZW1vdmluZyA9IHRydWVcblxuICAgIGlmKCF0aGlzLl9mcm9tKSByZXR1cm5cblxuICAgIHRoaXMuc2V0dGluZygncmVtb3ZlJywgW3BhcmFtc10pO1xuXG4gICAgaWYgKCFmcm9tcmVtb3ZlKSB7XG4gICAgICB2YXIgaW5zID0gdGhpcy5fZnJvbS5iYXNlLmluc3RhbmNlc1xuICAgICAgaWYoaW5zKSB7XG4gICAgICAgIGZvciAodmFyIG4gPSAwLCBsID0gaW5zLmxlbmd0aDsgaW5zW25dICE9PSB0aGlzIHx8ICFpbnMuc3BsaWNlKG4sIDEpOyBuKyspO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gdGhpcy5fXykge1xuICAgICAgaWYgKHRoaXMuX19baV0gaW5zdGFuY2VvZiBWLk9iamVjdCkge1xuICAgICAgICAvL25lc3RlZCwgYmxhY2tsaXN0LCBub3QgKGZpZWxkcyBpbiBvYmplY3QpLCBmcm9tLCBzdGFtcCwgbm91cGRhdGVcbi8vICAgICAgICAgY29uc29sZS5sb2coJy0tLS0tLS0tLScsIGksIHRoaXMuX19baV0sIHRoaXMuX19baV0uX3BhdGggKVxuICAgICAgICB0aGlzLl9fW2ldLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLl9fW2ldID0gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX1tpXSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fXyA9IG51bGxcblxuICAgIGlmIChpbnN0YW5jZXMgJiYgdGhpcy5pbnN0YW5jZXMpIHtcbiAgICAgIGZvciAoaiA9IHRoaXMuaW5zdGFuY2VzLmxlbmd0aCAtIDE7IGogPj0gMDsgdGhpcy5pbnN0YW5jZXNbai0tXS5yZW1vdmUodHJ1ZSwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGogaW4gdGhpcykge1xuICAgICAgLy8gaWYodGhpc1tqXSBpbnN0YW5jZW9mIFYuQmFzZSkge1xuICAgICAgLy8gICB0aGlzW2pdLnJlbW92ZSgpXG4gICAgICAvLyB9IFxuICAgICAgdGhpc1tqXSA9IG51bGw7XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0dGluZ3MgPSBudWxsXG4gICAgdGhpcy5fID0gbnVsbFxuICAgIGRlbGV0ZSB0aGlzLl9zZXR0aW5nc1xuICAgIGRlbGV0ZSB0aGlzLl9cbiAgICBkZWxldGUgdGhpcy5fX1xuICAgIC8vIGRlbGV0ZSB0aGlzLl9jbGFzczsgbWF5IG5vdCBiZSBuZXNzZWNhcnlcbiAgfSxcbiAgLypzZXQgb24gcHJvdG90eXBlKi9cbiAgJ3NldCcsIF9zZXQsXG4gICdnZXQnLCBmdW5jdGlvbiggcGF0aCwgc2VsZiApIHtcbiAgICByZXR1cm4gdXRpbC5nZXQoIHRoaXMsIHBhdGgsIHNlbGYgKVxuICB9LFxuXG4gICdpbmplY3QnLCBpbmplY3QsXG4gIC8qKlxuICAgKiBQYXNzZXMgZmllbGQgcGFyYW1ldGVyIG9ubHkgZm9yIGluc3RhbmNlcyBtYXRjaGluZyBhIGZpZWxkXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGZuICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7U3RyaW5nfSAgIGZpZWxkIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7Kn0gICAgICAgIHZhbCAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7Kn0gICAgICAgIHAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdlYWNoSW5zdGFuY2UnLCBmdW5jdGlvbihmbiwgZmllbGQsIHZhbCwgcCkge1xuICAgIHZhciBpbnN0YW5jZXMgPSB0aGlzLmluc3RhbmNlcztcbiAgICBpZiAoaW5zdGFuY2VzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGluc3RhbmNlcy5sZW5ndGgsIGluc3RhbmNlOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGluc3RhbmNlID0gaW5zdGFuY2VzW2ldO1xuXG5cbi8vcHJvYmxlbSEgaGFzIHRvIGNvcnJlY3QgZm9yIG1pc3NpbmcgaW5zdGFuY2VzISEhXG4vLyAgIGNvbnNvbGUubG9nKGluc3RhbmNlLCBpbnN0YW5jZXMpXG5cbiAgICAgICAgICBcblxuICAgICAgICBpZiAoaW5zdGFuY2UgJiYgKCFmaWVsZCB8fCAhaW5zdGFuY2UuX18gfHwgIWluc3RhbmNlLl9fW2ZpZWxkXSkpIHtcbiAgICAgICAgICBpZiAoZm4uY2FsbChpbnN0YW5jZSwgdmFsLCBwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnN0YW5jZS5lYWNoSW5zdGFuY2UoZm4sIGZpZWxkLCB2YWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZighaW5zdGFuY2UpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdcXG5cXG5cXG5cXG5pbnN0YW5jZSBpbiBiYXNlIGdvbmU/JywgaSAsIGluc3RhbmNlcylcbiAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsYXNzIGZyb20gdGhlIGN1cnJlbnQgQmFzZSBpbnN0YW5jZVxuICAgKiBAY29uc3RydWN0b3IgQ2xhc3NcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgJ0NsYXNzJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2NsYXNzKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VzID0gW107XG4gICAgICAgIHRoaXMuX2NsYXNzID0gZnVuY3Rpb24odmFsLCBwcm90bywgc2V0dGluZykge1xuICAgICAgICAgIGlmICghcHJvdG8pIHtcbiAgICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5fZnJvbS5iYXNlO1xuICAgICAgICAgICAgZnJvbS5pbnN0YW5jZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmcpIHtcbiAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nKCduZXcnLCBbZnJvbSwgc2V0dGluZ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICB0aGlzLnNldCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fY2xhc3MuYmFzZSA9IHRoaXM7XG4gICAgICAgIHRoaXMuX2NsYXNzLnByb3RvdHlwZSA9IG5ldyB0aGlzLl9mcm9tKGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fY2xhc3MucHJvdG90eXBlLl9fID0gbnVsbDtcbiAgICAgICAgdXRpbC5zZXRzdG9yZS5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgaSwgX3Byb3RvID0gdGhpcy5fY2xhc3MucHJvdG90eXBlLl8gPSB7fTtcbiAgICAgICAgZm9yIChpIGluIHRoaXMuX18pIHtcbiAgICAgICAgICBfcHJvdG9baV0gPSB0aGlzLl9fW2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSBpbiB0aGlzLl8pIHtcbiAgICAgICAgICBpZiAoX3Byb3RvW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIF9wcm90b1tpXSA9IHRoaXMuX1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2xhc3MucHJvdG90eXBlLl9mcm9tID0gdGhpcy5fY2xhc3M7XG4gICAgICAgIHRoaXMuX2NsYXNzLmluamVjdCA9IGluamVjdFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzO1xuICAgIH1cbiAgfSk7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGJhc2UgPSByZXF1aXJlKCcuLycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG4vKipcbiAqIFNldHRpbmdzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGNhc2VzIGUuZy4gb25SZW1vdmUgb3Igb25OZXcgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eVxuICovXG51dGlsLmRlZmluZShiYXNlLCAnX3NldHRpbmdzJyk7XG5cbmJhc2UucHJvdG90eXBlLl8uX3NldHRpbmdzID0ge307XG5cbi8qKlxuICogU2V0IHNldHRpbmdzIG9uIEJhc2VcbiAqIEBmdW5jdGlvbiBfc2V0XG4gKiBAcGFyYW0gIHtPYmplY3R9ICBzZXQgICAgICBPYmplY3QgdG8gc2V0XG4gKiBAcGFyYW0gIHtCb29sZWFufSBbcmVtb3ZlXVxuICogQHBhcmFtICB7Qm9vbGVhbn0gW2ZvcmNlXSAgVHJ1ZS9mYWxzZVxuICovXG52YXIgX3NldCA9IGZ1bmN0aW9uKHNldCwgcmVtb3ZlLCBmb3JjZSkge1xuICB2YXIgX3MgPSBzZXQuX3NldHRpbmdzIC8vZS5nLiBub2RlICwgcmVtb3ZlIGFuZCBwYXJlbnRcbiAgICAsIHQgPSB0aGlzXG4gICAgLCBfX3QgPSB0Ll8uX3NldHRpbmdzXG4gICAgLCBzZXR0aW5nXG4gICAgLCBpXG4gICAgLCBfdFxuXG4gIHV0aWwuc2V0c3RvcmUuY2FsbCh0KVxuXG4gIGlmICghdC5fXy5fc2V0dGluZ3MpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnY3JlYXRlIG15IG93biBzZXR0aW5ncycpXG4gICAgdC5fXy5fc2V0dGluZ3MgPSB7fVxuICAgIGZvciAodmFyIGogaW4gX190KSB7XG4gICAgICB0Ll9zZXR0aW5nc1tqXSA9IF9fdFtqXVxuICAgIH1cbiAgfVxuXG4gIF90ID0gdC5fXy5fc2V0dGluZ3NcblxuICAvLyBjb25zb2xlLmxvZygnU0VUVElOR1M/Jy5pbnZlcnNlLCBzZXQsIF9fdClcblxuICBmb3IgKGkgaW4gX3MpIHtcbiAgICBzZXR0aW5nID0gX3NbaV1cbiAgICAvL2VmZmljaWVudCBtZW1vcnkgbWFuYWdlbWVudCBvbmx5IG1ha2Ugb3duIGlmIGFic29sdXRlbHkgbmVzc2VjYXJ5XG4gICAgaWYgKChyZW1vdmUgJiYgX3Rbc2V0dGluZ11bc2V0Lm5hbWVdKSB8fCAoIXJlbW92ZSAmJiAhX3Rbc2V0dGluZ11bc2V0Lm5hbWVdKSB8fCBmb3JjZSkge1xuICAgICAgXG4gICAgICBpZiAoX3Rbc2V0dGluZ10gPT09IF9fdFtzZXR0aW5nXSkge1xuICAgICAgICBfdFtzZXR0aW5nXSA9IHt9XG4gICAgICAgIGZvciAodmFyIG4gaW4gX190W3NldHRpbmddKSB7XG4gICAgICAgICAgX3Rbc2V0dGluZ11bbl0gPSBfX3Rbc2V0dGluZ11bbl1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgIHRoaXMuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICh0aGlzW3NldC5uYW1lXSAhPT0gdFtzZXQubmFtZV0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zZXR0aW5nICE9PSBfdCAmJiB0aGlzLl9zZXR0aW5nc1tzZXR0aW5nXSA9PT0gX3Rbc2V0dGluZ10pIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZvdW5kIHRoYXQgdGhlIHNldHRpbmdzIGFyZSB0aGUgc2FtZSBhbmQgbm90IHRoZSBzYW1lIHByb3BlcnR5IG1ha2UgbXkgb3duJyk7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0gU0VUVElORycpXG4gICAgICAgICAgICAgIF9zZXQuY2FsbCh0aGlzLCBfdFtzZXR0aW5nXVtzZXQubmFtZV0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NldHRpbmcgIT09IF90ICYmIHRoaXMuX3NldHRpbmdzW3NldHRpbmddICE9PSBfdFtzZXR0aW5nXSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tIFJFTU9WRSBTRVRUSU5HJylcblxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLm5hbWUsc2V0Lm5hbWUsJ2ZvdW5kIHRoYXQgdGhlIHByb3BlcnR5IGlzIHRoZSBzYW1lIGJ1dCBzZXR0aW5ncyBhcmUgbm90IScpO1xuICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNldHRpbmcoc2V0Lm5hbWUsIHNldHRpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIF90W3NldHRpbmddW3NldC5uYW1lXSA9IG51bGw7XG4gICAgICAgIGRlbGV0ZSBfdFtzZXR0aW5nXVtzZXQubmFtZV07IC8vZGVsZXRlIGlzIGt1dCE7XG4gICAgICAgIGlmICh1dGlsLmVtcHR5KF90W3NldHRpbmddKSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsZXRzIHB1dCB0aGlzIHRvIHRydWUhJylcbiAgICAgICAgICBfdFtzZXR0aW5nXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0gRE8gU0VUVElORycsIHNldCwgX3QsIHNldHRpbmcsIHNldC5uYW1lKVxuICAgICAgICBpZihfdFtzZXR0aW5nXT09PXRydWUpIHtcbiAgICAgICAgICBfdFtzZXR0aW5nXT17fVxuICAgICAgICB9XG4gICAgICAgIF90W3NldHRpbmddW3NldC5uYW1lXSA9IHNldDtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFU1VMVD8nLCBzZXR0aW5nLCBfdFtzZXR0aW5nXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZygnU0VUVElOR1M/IC0tIHJlc3VsdCcuaW52ZXJzZSwgX3QsIHRoaXMuX3NldHRpbmdzPT09X3QsIHRoaXMuQkxVWEVOKVxuXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXR0aW5nXG4gKiBAbWV0aG9kIGNyZWF0ZVxuICogQHBhcmFtICB7W3R5cGVdfSBzZXQgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7W3R5cGVdfSAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uKHNldCkge1xuICBzZXQuX3NldCA9IHNldC5zZXQ7XG4gIHNldC5zZXQgPSBmdW5jdGlvbih2YWwsIHByb3ApIHtcbiAgICBfc2V0LmNhbGwodGhpcywgc2V0KVxuICAgIHNldC5fc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3RzIHNldHRpbmdzIGZyb20gc2V0dGluZ3NvYmplY3QgYW5kIHN0b3JlcyB0aGVtIGluIGFuIGFycmF5LlxuICogQG1ldGhvZCBwYXJzZVxuICogQHBhcmFtICB7T2JqZWN0fSBzZXR0aW5ncyBTZXR0aW5nb2JqZWN0XG4gKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdCAgIFNldHRpbmdzb2JqZWN0XG4gKi9cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbihzZXR0aW5ncywgb2JqZWN0KSB7XG4gIGlmICghb2JqZWN0KSB7XG4gICAgb2JqZWN0ID0gdGhpcy5fc2V0dGluZ3NcbiAgfVxuICBmb3IgKHZhciBpIGluIG9iamVjdCkge1xuICAgIGlmIChzZXR0aW5nc1tpXSkge1xuICAgICAgaWYgKCFzZXR0aW5ncy5fc2V0dGluZ3MpIHtcbiAgICAgICAgc2V0dGluZ3MuX3NldHRpbmdzID0gW107XG4gICAgICB9XG4gICAgICBzZXR0aW5ncy5fc2V0dGluZ3MucHVzaChpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkcyBzZXR0aW5nKHMpIHRvIEJhc2UgcHJvdG90eXBlXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtICB7U3RyaW5nW119ICAgIG5hbWUgIEFycmF5IG9mIHNldHRpbmduYW1lc1xuICogQHBhcmFtICB7UHJvdG90eXBlfSAgIHByb3RvIFByb3RvdHlwZSBlZy4gbXlCYXNlIGNsYXNzXG4gKi9cbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24obmFtZSwgcHJvdG8pIHsgLy9zdGFydCB1c2luZyB0aGlzIHNvbWV0aW1lcyE7XG4gIGlmIChuYW1lIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBmb3IgKHZhciBpIGluIG5hbWUpIHtcbiAgICAgIGlmIChwcm90bykge1xuICAgICAgICB0aGlzLmFkZChuYW1lW2ldLCBwcm90byk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZFNldHRpbmcobmFtZVtpXSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIXByb3RvKSB7XG4gICAgICB1dGlsLnNldHN0b3JlLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIXRoaXMuX18uX3NldHRpbmdzKSB7XG4gICAgICAgIHRoaXMuX18uX3NldHRpbmdzID0ge307XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBqIGluIHRoaXMuXy5fc2V0dGluZ3MpIHtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3Nbal0gPSB0aGlzLl8uX3NldHRpbmdzW2pdO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0dGluZ3NbbmFtZV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm90by5wcm90b3R5cGUuX3NldHRpbmdzW25hbWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogQWRkIHNldHRpbmdzIHRvIGluc3RhbmNlcyBvZiBCYXNlXG4gKiBzZXR0aW5ncyBvbmx5IHdvcmsgZm9yIGluc3RhbmNlcyBvZiB0aGUgYWRkZWQgQmFzZXNldHRpbmdzXG4gKiBAbWV0aG9kXG4gKi9cbnV0aWwuZGVmaW5lKGJhc2UsXG4gICdhZGRTZXR0aW5nJywgZnVuY3Rpb24obmFtZSkge1xuICAgIGV4cG9ydHMuYWRkLmNhbGwodGhpcywgbmFtZSk7XG4gICAgaWYgKHRoaXMuX2NsYXNzKSB7XG4gICAgICB0aGlzLl9jbGFzcy5wcm90b3R5cGUuXy5fc2V0dGluZ3MgPSB0aGlzLl9zZXR0aW5ncztcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBTaW1wbGUgaW1wbGVtZW50YXRpb24gb2Ygc2V0dGluZy5jcmVhdGVcbiAgICogQG1ldGhvZCBzZXRTZXR0aW5nXG4gICAqIEBwYXJhbSAge09iamVjdH0gc2V0IFNldHRpbmdvYmplY3RcbiAgICovXG4gICdzZXRTZXR0aW5nJywgZnVuY3Rpb24oc2V0KSB7XG4gICAgLy9lZXJzdCBjaGVja2VuIG9mIGllIGFsIGJlc3RhYXQgYW5kZXJzIGthbiBoZXQgdm9vcmtvbWVuIGRhdCBoZXQgdGV2ZWVsIGlzXG4gICAgZXhwb3J0cy5wYXJzZS5jYWxsKHRoaXMsIHNldCk7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnU0VUIFNFVFRJTkcnLnllbGxvdy5pbnZlcnNlLCBzZXQsIHRoaXMuX3NldHRpbmdzIClcblxuICAgIC8vZ2V0IGdlYnJ1aWtlbiAtLS0gb2JqZWN0IGlzIGVlbiBjaGVjayBvcCBtZWVyZGVyZSBmaWVsZHMgcmV0dXJucyB0cnVlIG9mIGZhbHNlIC8vIGJpaiBnZXQgb29rIG1vZ2VsaWprIG9tIGZpZWxkIG1lZSB0ZSBnZXZlblxuICAgIF9zZXQuY2FsbCh0aGlzLCBzZXQpO1xuXG4gICAgLy8gY29uc29sZS5sb2coJ1NFVCBTRVRUSU5HIC0tIHJlc3VsdCcueWVsbG93LmludmVyc2UsIHRoaXMuX3NldHRpbmdzIClcblxuICB9LFxuICAvKipcbiAgICogW2Rlc2NyaXB0aW9uXVxuICAgKiBAbWV0aG9kIHJlbW92ZVNldHRpbmdcbiAgICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBuYW1lICAgICBOYW1lIG9mIHRoZSBzZXR0aW5nIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0gIHtBcnJheXxPYmplY3R9IHNldHRpbmdzIFNldHRpbmdvYmplY3RcbiAgICovXG4gICdyZW1vdmVTZXR0aW5nJywgZnVuY3Rpb24obmFtZSwgc2V0dGluZ3MpIHtcblxuICAgIC8vIGlmKCFzZXR0aW5ncykge1xuICAgIC8vICAgLy90aGlzIG1heSBhbGwgYmUgbm90IG5lc3NlY2FyeSFcbiAgICAvLyAgIGZvcih2YXIgaSBpbiB0aGlzLl9zZXR0aW5ncykge1xuICAgIC8vICAgICBmb3IodmFyIGogaW4gdGhpcy5fc2V0dGluZ3NbaV0pIHtcbiAgICAvLyAgICAgICBpZih0aGlzLl9zZXR0aW5nc1tpXVtqXS5uYW1lPT09bmFtZSkge1xuICAgIC8vICAgICAgICAgc2V0dGluZ3M9dGhpcy5fc2V0dGluZ3NbaV1bal1cbiAgICAvLyAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICAgIH1cbiAgICAvLyAgICAgfVxuICAgIC8vICAgfVxuICAgIC8vIH1cblxuICAgIGlmICghKHNldHRpbmdzIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAvL3RoaXMgbWF5IGFsbCBiZSBub3QgbmVzc2VjYXJ5IVxuICAgICAgLy8gaWYoc2V0dGluZ3MgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIC8vICAgc2V0dGluZ3MgPSBzZXR0aW5ncy5fc2V0dGluZ3NcbiAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIHNldHRpbmdzID0gW3NldHRpbmdzXTtcbiAgICAgIC8vIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gc2V0dGluZ3MubGVuZ3RoIC0gMSwgZm91bmQsIF9zZXR0aW5ncyA9IHRoaXMuX3NldHRpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKF9zZXR0aW5ncyAmJiBfc2V0dGluZ3Nbc2V0dGluZ3NbaV1dICYmIF9zZXR0aW5nc1tzZXR0aW5nc1tpXV1bbmFtZV0pIHtcbiAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvdW5kKSB7XG4gICAgICBfc2V0LmNhbGwodGhpcywge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBfc2V0dGluZ3M6IHNldHRpbmdzXG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBvYmplY3QgaGFzIHNldHRpbmdzIGFuZCBleGVjdXRlcyB0aGVtLiBBcmd1bWVudHMgYXJlIHBhc3NlZCB0byBzZXR0aW5ncy5cbiAgICogQG1ldGhvZCBzZXR0aW5nXG4gICAqIEBwYXJhbSAge1N0cmluZ30gICAgbmFtZSBOYW1lIG9mIHRoZSBzZXR0aW5nXG4gICAqIEBwYXJhbSAge0FyZ3VtZW50c30gYXJnICBBcmd1bWVudHMgdG8gcGFzcyB0byBzZXR0aW5nc1xuICAgKi9cbiAgJ3NldHRpbmcnLCBmdW5jdGlvbihuYW1lLCBhcmcpIHsgLy9taXNzY2hpZW4gYXJnXG4gICAgdmFyIF9zID0gdGhpcy5fc2V0dGluZ3M7XG4gICAgaWYgKF9zICYmIF9zW25hbWVdICYmIF9zW25hbWVdICE9PSB0cnVlKSB7XG4gICAgICBmb3IgKHZhciBpIGluIF9zW25hbWVdKSB7XG4gICAgICAgIF9zW25hbWVdW2ldW25hbWVdLmFwcGx5KHRoaXMsIGFyZyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuLyoqXG4gKiBCYXNlIGhhcyB0d28gZGVmYXVsdCBzZXR0aW5nc1xuICogbmV3IGlzIGludm9rZWQgb24gY29uc3RydWN0aW9uICwgcmVtb3ZlIG9uIHJlbW92YWw7XG4gKiBAc2V0dGluZ3NcbiAqL1xuZXhwb3J0cy5hZGQoWyduZXcnLCAncmVtb3ZlJ10sIGJhc2UpXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG52YXIgYW5pbWF0aW9uID0gcmVxdWlyZSgnLi8nKTtcbmFuaW1hdGlvbi5lYXNpbmcgPSBleHBvcnRzO1xuLy8gdDogY3VycmVudCB0aW1lLCBiOiBiZWdpbm5pbmcgdmFsdWUsIGM6IGNoYW5nZSBJbiB2YWx1ZSwgZDogZHVyYXRpb25cbi8vIGNvdXJ0ZXN5IG9mIFJvYmVydCBQZW5uZXJcbmV4cG9ydHMuaW5DdWJpYyA9IGZ1bmN0aW9uKHQsIGIsIGMsIGQpIHtcbiAgcmV0dXJuIGMgKiAodCAvPSBkKSAqIHQgKiB0ICsgYjtcbn07XG5cbmV4cG9ydHMub3V0Q3ViaWMgPSBmdW5jdGlvbih0LCBiLCBjLCBkKSB7XG4gIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiB0ICsgMSkgKyBiO1xufTtcblxuZXhwb3J0cy5vdXRCYWNrID0gZnVuY3Rpb24odCwgYiwgYywgZCwgcykge1xuICB2YXIgcyA9IDEuNzAxNTg7XG4gIHJldHVybiBjICogKCh0ID0gdCAvIGQgLSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDEpICsgYjtcbn07IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUnKVxuICAsIGZyYW1lID0gbmV3IFZhbHVlKDEpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIF9vbiA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGNvbnNvbGUuZ3JvdXAoKVxuICAgIC8vIGNvbnNvbGUubG9nKCdcXG5cXG4tLS0tUkFGLS0tLScubWFnZW50YS5ib2xkKVxuICAgIGV4cG9ydHMucmFmSWQgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9vbilcbiAgICBmcmFtZS52YWwrK1xuICAgIC8vIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICB9XG5cbmZyYW1lLmRvbmUgPSBuZXcgVmFsdWUodHJ1ZSlcblxudXRpbC5kZWZpbmUoZnJhbWUsXG4gICdhZGRMaXN0ZW5lcicsIGZ1bmN0aW9uKHZhbCwgbWFyaywgcmVtb3ZlKSB7XG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnMpe1xuICAgICAgdGhpcy5kb25lLnZhbCA9IGZhbHNlXG4gICAgICBfb24oKVxuICAgIH1cbiAgICBWYWx1ZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIuY2FsbCh0aGlzLCB2YWwsIG1hcmssIHJlbW92ZSlcbiAgfVxuLCAncmVtb3ZlTGlzdGVuZXInLCBmdW5jdGlvbih2YWwsIG1hcmssIHJlbW92ZSkge1xuICAgIHZhciB0ID0gdGhpc1xuICAgIFZhbHVlLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHQsIHZhbCwgbWFyaywgcmVtb3ZlKVxuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoZXhwb3J0cy5yYWZJZClcbiAgICAgIHRoaXMudmFsID0gMVxuICAgICAgdGhpcy5kb25lLnZhbCA9IHRydWVcbiAgICB9XG4gIH1cbilcblxubW9kdWxlLmV4cG9ydHMgPSBmcmFtZSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cblxudmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuLi9lbGVtZW50JykuaW5qZWN0KHJlcXVpcmUoJy4uL2VsZW1lbnQvcHJvcGVydGllcycpKSAvL2VsZW1lbnQgYWRkZWQgKGV4dGVuZCkgLy9jYWxsIGV4dGVuZCBvbiBmbGFncyAobWFrZSBidWZmZXIgaWYgYWxyZWFkeSBleHRlbmRlZClcbiAgLCBvYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBmbGFncyA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzL3V0aWwnKVxuICAsIG9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL29wZXJhdG9ycycpXG4gICwgZnJhbWUgPSByZXF1aXJlKCcuL2ZyYW1lJylcbiAgLCBfbGluZWFyID0gZnVuY3Rpb24odCwgYiwgYywgZCkge1xuICAgIHJldHVybiBjICogdCAvIGQgKyBiXG4gIH1cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxub3BlcmF0b3JzLl9hID0gZnVuY3Rpb24gKHZhbCwgb3BlcmF0b3IpIHtcbiAgcmV0dXJuIG9wZXJhdG9yXG59XG5cbmZ1bmN0aW9uIHByZXZlbnRTZXQodmFsKSB7XG4gIHRoaXMuX3AgPSB0cnVlXG4gIHRoaXMudmFsID0gdmFsXG4gIHRoaXMuX3AgPSBmYWxzZVxufVxuXG5vcGVyYXRvcnMuX2Eub3JkZXIgPSAyXG5cbmZsYWdzLmFuaW1hdGlvbiA9IHtcbiAgc2V0OiBmdW5jdGlvbiAodmFsKSB7XG4gICAgXG4gICAgdmFyIHRoaXNPYmplY3QgPSB0aGlzXG4gICAgICAsIF9wID0gdGhpc09iamVjdC5jaGVja1BhcmVudCgnX3Byb3AnKVxuXG4gICAgaWYgKHZhbCkge1xuXG4gICAgICBpZiAoIXRoaXNPYmplY3QuX3ZhbCkgdGhpc09iamVjdC52YWwgPSAwXG5cbiAgICAgIHZhciBuYW1lID0gX3AuX3Byb3AubmFtZVxuICAgICAgICAsIGVsZW1lbnQgPSBfcC5fY2FsbGVyXG4gICAgICAgICwgbm9MaXN0ZW5lciA9IHZhbC5ub0xpc3RlbmVyXG4gICAgICAgICwgcGF0aCA9IHRoaXNPYmplY3QuX3BhdGhcbiAgICAgICAgLCBpZCA9IG5hbWUuY29uY2F0KHBhdGguam9pbignJykpXG4gICAgICAgICwgc2tpcCA9IHZhbC5za2lwXG4gICAgICAgICwgZWFzaW5nID0gdmFsLmVhc2luZyBcbiAgICAgICAgICAmJiBleHBvcnRzLmVhc2luZ1t2YWwuZWFzaW5nXSBcbiAgICAgICAgICB8fCB2YWwuZWFzaW5nIFxuICAgICAgICAgIHx8IF9saW5lYXJcbiAgICAgICAgLCB0aW1lLCBzdGFydCwgcmVhZHlcblxuICAgICAgaWYoIV9wLl9hbmltTGlzdGVuKSBfcC5fYW5pbUxpc3RlbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFyIHRuID0gdGhpc1tuYW1lXVxuICAgICAgICBpZih0bikgdG4udXBkYXRlKHRoaXMsIHRydWUpXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBGT1JURVNUSU5HID0gZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgICAgIGNvbnNvbGUubG9nKCdfYW5pbUxpc3RlbiBzZXR0aW5nJyxmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgICAgIGZyYW1lLnJlbW92ZUxpc3RlbmVyKHZvaWQgMCwgdGhpcylcbiAgICAgICAgICBjb25zb2xlLmxvZygnPj4gX2FuaW1MaXN0ZW4gc2V0dGluZycsZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICBpZihGT1JURVNUSU5HICYmIEZPUlRFU1RJTkcgPT09IChmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKSlcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0aGlzID4+Jyx0aGlzKVxuICAgICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWxlbWVudC5zZXRTZXR0aW5nKHtcbiAgICAgICAgbmFtZTonYW5pbWF0aW9uJyxcbiAgICAgICAgcmVtb3ZlOmZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBGT1JURVNUSU5HID0gZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgc2V0dGluZycsZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICBcblxuICAgICAgICAgIGZyYW1lLnJlbW92ZUxpc3RlbmVyKCB2b2lkIDAsIHRoaXMpXG5cblxuICAgICAgICAgIGlmKGZyYW1lLl9saXN0ZW5lcnMgJiYgRk9SVEVTVElORyAmJiBGT1JURVNUSU5HID09PSAoZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aCkpXG4gICAgICAgICAge1xuICAgICAgICAgICAgZm9yKHZhciBpIGluIGZyYW1lLl9saXN0ZW5lcnMgKSB7XG4gICAgICAgICAgICAgIGlmKCBmcmFtZS5fbGlzdGVuZXJzW2ldIGluc3RhbmNlb2YgQXJyYXkgKSB7XG4vLyAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NPTVBBUkUnLGZyYW1lLl9saXN0ZW5lcnNbaV1bMV09PT10aGlzLCBmcmFtZS5fbGlzdGVuZXJzW2ldWzFdLCAndnMnLCB0aGlzIClcbiAgICAgICAgICAgICAgICBpZiggZnJhbWUuX2xpc3RlbmVyc1tpXVsxXT09PXRoaXMsIGZyYW1lLl9saXN0ZW5lcnNbaV1bMV0gKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZyYW1lLl9saXN0ZW5lcnMuc3BsaWNlKGksMSlcbi8vICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndGhpcyA+PicsdGhpcy5ub2RlKVxuICAgICAgICAgICAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIF9wLnByZXZlbnRTZXQgPSBwcmV2ZW50U2V0XG5cbiAgICAgIF9wLnNldCgndHJhbnNsYXRlJywgdHJ1ZSlcblxuICAgICAgdGhpc09iamVjdC5zZXQoJ19hJywge1xuICAgICAgICB0aW1lOiB2YWwudGltZSB8fCA2MCxcbiAgICAgICAgdmFsOiBmdW5jdGlvbih2LCBjdiwgYikge1xuICAgICAgICAgIFxuICAgICAgICAgIHZhciB0ID0gdGhpc1xuICAgICAgICAgICAgLCBhXG4gICAgICAgICAgICAsIHByb3AgPSBfcCAvL3RbbmFtZV0gfHxcbiAgICAgICAgICAgICwgcHIgPSB0W25hbWVdXG5cbiAgICAgICAgICBpZiAoIXQuX2EpIHQuX2EgPSB7fVxuICAgICAgICBcbiAgICAgICAgICBpZiAoIXQuX2FbaWRdKSB7XG5cbiAgICAgICAgICAgIHN0YXJ0ID0gdmFsLnN0YXJ0ID09PSB2b2lkIDAgXG4gICAgICAgICAgICAgID8gdC5yZW5kZXJlZCAmJiAodGhpc09iamVjdC5fX2x2YWwgIT09IHZvaWQgMClcbiAgICAgICAgICAgICAgICA/IHRoaXNPYmplY3QuX19sdmFsXG4gICAgICAgICAgICAgICAgOiBjdlxuICAgICAgICAgICAgICA6IHZhbC5zdGFydCBpbnN0YW5jZW9mIG9iamVjdCBcbiAgICAgICAgICAgICAgICA/IHZhbC5zdGFydC52YWxcbiAgICAgICAgICAgICAgICA6IHZhbC5zdGFydFxuXG4gICAgICAgICAgICB0Ll9hW2lkXSA9IHtcbiAgICAgICAgICAgICAgX3N0YXJ0OiBzdGFydCxcbiAgICAgICAgICAgICAgX2VuZDogc3RhcnQsXG4gICAgICAgICAgICAgIF9jdXJyZW50OiBzdGFydCxcbiAgICAgICAgICAgICAgX2NvdW50OiAwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdC5yZW5kZXJlZCkgcmV0dXJuIHN0YXJ0XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHQucmVuZGVyZWQpIHtcbiAgICAgICAgICAgIGlmKHNraXApIHtcbiAgICAgICAgICAgICAgdC5fYVtpZF0uX2N1cnJlbnQgPSBjdlxuICAgICAgICAgICAgICBza2lwID0gZmFsc2VcbiAgICAgICAgICAgICAgcmV0dXJuIGN2XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGEgPSB0Ll9hW2lkXVxuICAgICAgICAgICAgaWYgKHByLl9wIHx8IGV4cG9ydHMucHJldmVudCkge1xuICAgICAgICAgICAgICBhLl9mcmFtZSA9IDBcbi8vICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlbW92ZSBwcmV2ZW50JyxmcmFtZS5fbGlzdGVuZXJzICYmIGZyYW1lLl9saXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgICAgICAgICBmcmFtZS5yZW1vdmVMaXN0ZW5lcihwcm9wLl9hbmltTGlzdGVuLCB0aGlzLCB0cnVlKVxuLy8gICAgICAgICAgICAgICBjb25zb2xlLmxvZygnPj4gcmVtb3ZlIHByZXZlbnQnLGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpXG4gICAgICAgICAgICAgIGlmIChwci5fcCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIGEuX2N1cnJlbnQgPSBhLl9lbmQgPSBjdlxuICAgICAgICAgICAgICAgIGlmICh2YWwuY29tcGxldGUpIG5vTGlzdGVuZXIgPSB2YWwuY29tcGxldGUuY2FsbCh0LCBjdilcbiAgICAgICAgICAgICAgICBpZiAodmFsLmRvbmUpIHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkgeyB2YWwuZG9uZS5jYWxsKHQsY3YpIH0sIDApXG4gICAgICAgICAgICAgICAgaWYgKHZhbC5vbmNlKSB7XG4gICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgICAgIGlmKHZhbC5vbmNlKSB2YWwub25jZS5jYWxsKHQsY3YpIFxuICAgICAgICAgICAgICAgICAgICB2YWwub25jZSA9IG51bGxcbiAgICAgICAgICAgICAgICAgIH0sIDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGEuX2ZyYW1lICE9PSBmcmFtZS52YWwpIHtcbiAgICAgICAgICAgICAgaWYgKGEuX2ZyYW1lIHx8IChjdiAhPT0gdm9pZCAwICYmIGEuX2N1cnJlbnQgIT09IGN2KSkgeyAvL2NoZWNraW5nIGEuZnJhbWUgZmFzdGVyIHRoYW4gY29tcGFyaW5nIGEuY3VycmVudCB0byBjdlxuICAgICAgICAgICAgICAgIGlmIChhLl9lbmQgIT09IGN2KSB7XG5cbiAgICAgICAgICAgICAgICAgIGlmICh2YWwuaW5pdCkgdmFsLmluaXQuY2FsbCh0LCBhLl9jdXJyZW50KVxuICAgICAgICAgICAgICAgICAgaWYoIW5vTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUuYWRkTGlzdGVuZXIoW3Byb3AuX2FuaW1MaXN0ZW4sIHRoaXMsIG5hbWVdXG4gICAgICAgICAgICAgICAgICAgICAgLCBmdW5jdGlvbiAobGlzdGVuQXJyYXksIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBpIGluIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZihsaXN0ZW5lcnNbaV0ucG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYobGlzdGVuZXJzW2ldLnBvcCAmJiBsaXN0ZW5lcnNbaV1bMV09PT10ICYmIGxpc3RlbmVyc1tpXVsyXT09PW5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZSBcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGEuX3N0YXJ0ID0gYS5fY3VycmVudFxuICAgICAgICAgICAgICAgICAgYS5fZW5kID0gY3ZcbiAgICAgICAgICAgICAgICAgIGEuX2NvdW50ID0gMFxuICAgICAgICAgICAgICAgICAgdGltZSA9IH5+di50aW1lLnZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhLl9mcmFtZSA9IGZyYW1lLnZhbFxuXG4gICAgICAgICAgICAgICAgaWYodmFsLmRlbGF5KXtcbiAgICAgICAgICAgICAgICAgIHZhbC5kZWxheS0tXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYS5fc3RhcnRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgY250ID0gKythLl9jb3VudFxuICAgICAgICAgICAgICAgIGEuX2N1cnJlbnQgPSBlYXNpbmcuY2FsbCh0LCBjbnQsIGEuX3N0YXJ0LCBhLl9lbmQgLSBhLl9zdGFydCwgdGltZSB8fCAodGltZSA9IH5+di50aW1lLnZhbCkpXG4gICAgICAgICAgICAgICAgaWYodmFsW2NudF0pIHZhbFtjbnRdLmNhbGwodGhpcyxhLl9jdXJyZW50LGN2KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhLl9jb3VudCA9PT0gdGltZSkgeyAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYS5fY3VycmVudCA9IGN2XG4gICAgICAgICAgICAgICAgYS5fZnJhbWUgPSAwXG4gICAgICAgICAgICAgICAgYS5fY291bnQgPSAwXG5cbiAgICAgICAgICAgICAgICBpZiAodmFsLmNvbXBsZXRlKSBub0xpc3RlbmVyID0gdmFsLmNvbXBsZXRlLmNhbGwodCwgY3YpXG4gICAgICAgICAgICAgICAgaWYgKHZhbC5kb25lKSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHsgdmFsLmRvbmUuY2FsbCh0LGN2KSB9LCAwKVxuICAgICAgICAgICAgICAgIGlmICh2YWwub25jZSkge1xuICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgICAgICBpZih2YWwub25jZSkgdmFsLm9uY2UuY2FsbCh0LGN2KSBcbiAgICAgICAgICAgICAgICAgICAgdmFsLm9uY2UgPSBudWxsXG4gICAgICAgICAgICAgICAgICB9LCAwKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCFub0xpc3RlbmVyKVxuICAgICAgICAgICAgICAgIHtcbi8vICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZW1vdmUgbm9saXN0ZW5lcicsZnJhbWUuX2xpc3RlbmVycyAmJiBmcmFtZS5fbGlzdGVuZXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgIGZyYW1lLnJlbW92ZUxpc3RlbmVyKHByb3AuX2FuaW1MaXN0ZW4sIHRoaXMsIHRydWUpXG4vLyAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnPj4gcmVtb3ZlIG5vbGlzdGVuZXInLGZyYW1lLl9saXN0ZW5lcnMgJiYgZnJhbWUuX2xpc3RlbmVycy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYS5fY3VycmVudFxuICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgIF9wLl9za2lwID0gdHJ1ZVxuICAgICAgdGhpc09iamVjdC5fc2tpcCA9IHRydWVcbiAgICAgIFxuICAgICAgaWYgKHZhbC5zdGFydCAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHZhciBjYWxsZXIgPSB0aGlzLl9jYWxsZXJcbiAgICAgICAgaWYoIWNhbGxlcikgY2FsbGVyID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AnKS5fY2FsbGVyXG4gICAgICAgIGNhbGxlci5zZXRSZW5kZXIobmFtZSwgZnVuY3Rpb24ocGFyZW50KSB7XG4gICAgICAgICAgdGhpcy51cGRhdGUobmFtZSlcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9IFxuICAgIGVsc2Uge1xuICAgICAgdGhpc09iamVjdC5yZW1vdmUoJ19hJylcbiAgICAgIHRoaXNPYmplY3QuX3NraXAgPSB2b2lkIDBcbiAgICAgIF9wLl9za2lwID0gdm9pZCAwXG4gICAgICBfcmVtb3ZlKF9wKVxuICAgIH1cblxuICB9XG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogWW91cmkgRGFhbWVuLCB5b3VyaUB2aWdvdXIuaW9cbiAqL1xudmFyIHVhID0gcmVxdWlyZSgnLi4vdWEnKSxcbiAgUkFGID0gJ2VxdWVzdEFuaW1hdGlvbkZyYW1lJyxcbiAgQ0FQID0gJ1InICsgUkFGLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gIGxhc3RGcmFtZSA9IDA7XG5cbnV0aWwuZGVmaW5lKHVhLCAnaGFzVHJhbnNpdGlvbicsIHtcbiAgZ2V0OmZ1bmN0aW9uKCkge1xuICAgIGlmKCF1YS5faGFzVHJhbnNpdGlvbikge1xuICAgICAgIHZhciBiID0gZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnRcbiAgICAgICAgLCBzID0gYi5zdHlsZVxuICAgICAgICAsIHAgPSAncmFuc2l0aW9uJztcbiAgICAgIHVhLl9oYXNUcmFuc2l0aW9uID0gdHlwZW9mIHNbJ3QnK3BdID09PSAnc3RyaW5nJyBcbiAgICAgICAgfHwgdHlwZW9mIHNbdWEucHJlZml4ICsgJ1QnK3BdID09PSAnc3RyaW5nJ1xuICAgIH1cbiAgICByZXR1cm4gdWEuX2hhc1RyYW5zaXRpb25cbiAgfVxufSlcbiAgXG5SQUYgPSAncicgKyBSQUY7XG5pZiAoIXdpbmRvd1tSQUZdKSB7IFxuXG4gIHVhLm5vUmFmID0gdHJ1ZVxuXG4gIC8vd2luZG93W3VhLnByZWZpeCArIENBUF0gfHwgXG5cbiAgd2luZG93W1JBRl0gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGNhbGxiYWNrLCAyMCk7XG4gIH07XG4gIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgY2xlYXJUaW1lb3V0KGlkKTtcbiAgfTtcbn1cblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHdpbmRvd1tSQUZdXG5cbmV4cG9ydHMudGltZXIgPSBmdW5jdGlvbiggZm4sIGZyYW1lcywgcmVwZWF0ICl7XG4gIGlmKCAtLWZyYW1lcyApe1xuICAgIGV4cG9ydHMoZnVuY3Rpb24oKXtcbiAgICAgIGlmKCByZXBlYXQgKSBmbigpXG4gICAgICBleHBvcnRzLnRpbWVyKCBmbiwgZnJhbWVzLCByZXBlYXQgKVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cyggZm4gKVxuICB9XG59XG5cbmV4cG9ydHMucmVwZWF0ID0gZnVuY3Rpb24oIGZuLCBmcmFtZXMgKXtcbiAgZXhwb3J0cy50aW1lciggZm4sIGZyYW1lcywgdHJ1ZSApXG59XG5cbi8vY2hlY2sgaW9zIDYgcGF1bCBpcmlzaCBzYXlzIHN0dWZmIGdvZXMgd3JvbmcgdGhlcmUuLi4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciBjYXNlcyA9IHJlcXVpcmUoJy4vJyksXG4gIGVsZW1lbnQgPSByZXF1aXJlKCcuLi9lbGVtZW50JyksXG4gIHNldEZsYWdzID0gcmVxdWlyZSgnLi4vZWxlbWVudC9zZXQnKSxcbiAgYmFzZSA9IHJlcXVpcmUoJy4uLy4uL2Jhc2UnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS1DQVNFUyBGT1IgU0VULS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIF9jc3MgPSBmdW5jdGlvbih0LCBuYW1lLCBpbnZlcnQsIHJlbW92ZSkge1xuICAgIGlmICghaW52ZXJ0KSB7XG4gICAgICBpZighdC5jc3MpIHsgdC5jc3MgPSAnJyB9XG4gICAgICB0LmNzcy5zZXQoIHJlbW92ZSA/ICdyZW1vdmVDbGFzcycgOiAnYWRkQ2xhc3MnLCBuYW1lICkgXG4gICAgICB0LmNzcy51cGRhdGUodClcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1xcblxcblxcbnNldCBjc3MhISEhIXh4eCcsIG5hbWUsIHQubm9kZSlcblxuICAgICAgdC5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdcXG5cXG5cXG5pbnN0YW5jZSEgc2V0IGNzcyEhISEhJywgbmFtZSwgdC5ub2RlKVxuXG4gICAgICAgIC8vIGlmKHRoaXMuY3NzICE9PSB0LmNzcykge1xuICAgICAgICAgIHRoaXMuY3NzLnNldCggcmVtb3ZlID8gJ3JlbW92ZUNsYXNzJyA6ICdhZGRDbGFzcycsIG5hbWUgKSBcbiAgICAgICAgICB0aGlzLmNzcy51cGRhdGUodGhpcylcbiAgICAgICAgLy8gfVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHMgPSBjYXNlcy5tZXRob2RzO1xuXG5zZXRGbGFncy5yZW1vdmUgPSBmdW5jdGlvbihpLCB2YWwsIGNvcHksIHRvcCkge1xuICAvL3RoaXMgY291bGQgYmVjb21lIGEgc2VwZXJhdGUgbW9kdWxlIHNpbmNlIHJlbW92ZSBtYXkgYmUgdXNlZnVsbCBmb3IgZGlmZmVyZW50IHB1cnBvc2VzXG4gIGlmICh2YWwgJiYgdmFsLl9fcmVtb3ZlX18pIHtcbiAgICBpZiAodGhpc1tpXSBpbnN0YW5jZW9mIGJhc2UpIHtcbiAgICAgIHRvcFtpXSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAodXRpbC5sb29rdXAuY2FsbCh0aGlzLCBpKSkge1xuICAgICAgZGVsZXRlIHZhbC5fX3JlbW92ZV9fO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdmFsW2ldO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5zZXRGbGFncy5jYXNlcyA9IG1ldGhvZHMucmVhZGVyKGZ1bmN0aW9uIGNhc2VSZWFkZXJCYXNlKG5hbWUsIHZhbCwgZHluYW1pYywgaW52ZXJ0KSB7XG4gIHZhciB0ID0gdGhpcyxcbiAgICBmID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICBvYmogPSBiYXNlLnNldChvYmosIGZhbHNlLCB0cnVlKTtcbiAgICAgIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICh1dGlsLmlzT2JqKG9ialtpXSkpIHtcbiAgICAgICAgICBvYmpbaV0gPSBmKG9ialtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICBtZXRob2QsXG4gICAgcGFyc2VkLFxuICAgIHNldCxcbiAgICBzVmFsLFxuICAgIG9yaWdpbmFsO1xuICB2YWwgPSBmKHZhbCk7XG5cbiAgaWYgKGR5bmFtaWMpIHtcbiAgICBpZiAoIXQuX2Nhc2VzKSB7XG4gICAgICB0Ll9jYXNlcyA9IHt9O1xuICAgIH1cbiAgICBpZiAodmFsID09PSBudWxsKSB7XG4gICAgICBpZiAodC5fY2FzZXNbbmFtZV0ubWV0aG9kKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IobmFtZSwgJ2Nhc2UgPT09IG51bGwgLCByZW1vdmUgaXQnKTtcbiAgICAgICAgY2FzZXNbbmFtZV0ucmVtb3ZlTGlzdGVuZXIodC5fY2FzZXNbbmFtZV0ubWV0aG9kKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYXNlc1tuYW1lXS52YWwpIHtcbiAgICAgICAgdC5jc3MgPSB7XG4gICAgICAgICAgcmVtb3ZlQ2xhc3M6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgICAgIHQuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jc3MgPSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiBuYW1lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0Ll9jYXNlc1tuYW1lXTsgLy9yZW1vdmVzIGNhc2Ugb3JnaW5hbFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdTRVQgQ0FTRScsbmFtZSx0Ll9jYXNlc1tuYW1lXSYmdC5fY2FzZXNbbmFtZV0ubWV0aG9kKTtcbiAgICAgIHBhcnNlZCA9IG1ldGhvZHMub3JpZ2luYWwodCwgdHJ1ZSwgdmFsLCB0Ll9jYXNlcywgdHJ1ZSwgbmFtZSk7XG4gICAgICB0Ll9jYXNlc1tuYW1lXSA9IHtcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIG9yaWc6IHBhcnNlZFswXSxcbiAgICAgICAgbmVzdGVkOiBwYXJzZWRbMV1cbiAgICAgIH07XG5cbiAgICAgIGlmICghdC5fY2FzZXNbbmFtZV0ubWV0aG9kKSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3RoaXMgaXMgd2hhdCBpIGhhdmUgc2V0IGZvciBvcmlnaW5hbCcsIHQuX2Nhc2VzKTtcbiAgICAgICAgbWV0aG9kID0gdC5fY2FzZXNbbmFtZV0ubWV0aG9kID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTEVUUyBUUlkgVE8gUlVOIE1FVEhPRCcsbmFtZSx2YWwpO1xuXG4gICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgc2V0ID0gbWV0aG9kcy5tZXJnZSh0cnVlLCBuYW1lLCB2YWwsIHQuX2Nhc2VzKTsgLy9hcmcgbm8gdmFsO1xuICAgICAgICAgICAgc1ZhbCA9IHNldCBbMF07XG4gICAgICAgICAgICBvcmlnaW5hbCA9IHNldFsxXTtcbiAgICAgICAgICAgIGRlbGV0ZSBzVmFsLnZhbDtcbiAgICAgICAgICAgIGRlbGV0ZSBvcmlnaW5hbC52YWw7XG4gICAgICAgICAgICBpZiAoY2FzZXNbbmFtZV0udmFsKSB7XG4gICAgICAgICAgICAgIF9jc3ModCwgbmFtZSwgaW52ZXJ0KTtcbiAgICAgICAgICAgICAgdC5zZXQoc1ZhbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfY3NzKHQsIG5hbWUsIGludmVydCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHQuc2V0KG9yaWdpbmFsLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0FERCBMSVNURU5FUiBUTycsbmFtZSwgIHQuX2Nhc2VzW25hbWVdKTtcbiAgICAgICAgY2FzZXNbbmFtZV0uYWRkTGlzdGVuZXIobWV0aG9kKTtcbiAgICAgICAgLy9yZW1vdmUgc2V0dGluZyBvbiByZW1vdmUgKHNhdmVzIG1lbW9yeSlcbiAgICAgICAgdC5zZXRTZXR0aW5nKHtcbiAgICAgICAgICBuYW1lOiAnX2MnICsgbmFtZSxcbiAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYodGhpcyA9PT0gdCApIHtcbiAgICAgICAgICAgICAgY2FzZXNbbmFtZV0ucmVtb3ZlTGlzdGVuZXIobWV0aG9kKTsgLy9pZighdGhpcy5jc3MgPT09IHRoaXMuX2Zyb20uYmFzZS5jc3MpIFxuICAgICAgICAgICAgICB0aGlzLl9jYXNlc1tuYW1lXS5tZXRob2QgPSBudWxsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2cobmFtZSwgJ2FscmVhZHkgZ290IGxpc3RlbmVycyBmb3IgY2FzZScsbmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FzZXNbbmFtZV0udmFsKSB7XG4gICAgICAgIF9jc3ModCwgbmFtZSwgaW52ZXJ0KTtcbiAgICAgICAgdC5zZXQodmFsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX2Nzcyh0LCBuYW1lLCBpbnZlcnQpO1xuICAgIHQuc2V0KHZhbCk7IC8vbWF5YmUgY29weSBhcmdzP1xuICB9XG4gIHJldHVybiB0cnVlO1xufSk7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksXG4gIGVsZW1lbnQgPSByZXF1aXJlKCcuLi9lbGVtZW50JyksIC8vZWxlbWVudCAvdyBleHRlbmRcbiAgdmFsdWUgPSByZXF1aXJlKCcuLi8uLi92YWx1ZScpLFxuICBmbGFncyA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzJyk7XG5cbi8qKlxuICogY2FzZXNcbiAqIGNhc2VzIGFyZSB1c2VkIHRvIHNldCBvbmUgb3IgbW9yZSB2YWx1ZXMgd2hlbiBhIHNwZWNpZmljIGNhc2UgaXMgdHJ1ZVxuICogdGhlcmUgYXJlIDIgdHlwZXMgb2YgY2FzZXMgLCBzdGF0aWMgYW5kIGR5bmFtaWMgLFxuICogc3RhdGljIGNhc2VzIGFyZSBzZXQgYXQgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGFwcGxpY2F0aW9uICwgdXNlZnVsbCBmb3IgdGhpbmdzIHN1Y2ggYXMgZGV2aWNlIHR5cGUgKHBob25lLCBkZXNrdG9wLCB0dilcbiAqIGR5bmFtaWMgY2FzZXMgY2FuIGJlIGNoYW5nZWQgZHluYW1pY2x5IGFuZCBPYmplY3RzIG9yIEJhc2VzIHRoYXQgdXNlIHRoZSBjYXNlIHdpbGwgYmUgY2hhbmdlZCBkeW5hbWljbHkgYXMgd2VsbFxuICovXG5cbnV0aWwuZGVmaW5lKGV4cG9ydHMsICdtZXRob2RzJywge30pO1xuLy9tdWx0aXBsZSwgcmVjdXJzaXZlIGFuZCBvcmlnaW5hbCBoYXZlIHRvIGJlY29tZSBleHRlbnNpb25zIG9uIFYuT2JqZWN0LmNvbnZlcnQgc28gaXQncyBwb3NzaWJsZSB0byB1c2UgdGhlIHNhbWUgZm9yIGRhdGEgYW5kIGV2ZW50c1xuXG52YXIgX2lzT2JqID0gdXRpbC5pc09iaixcbiAgLypcbiAgICBfcmVjdXJcbiAgICBzcGVjaWFsIG1lcmdlIHRoYXQgYWRkcyBfX3JlbW92ZV9fIGlmIGEgZmllbGQgaGFzIHRvIGJlIHJlbW92ZWRcbiAgKi9cbiAgX3JlY3VyID0gZnVuY3Rpb24ob3JpZ2luYWwsIG1lcmdlLCBmaWVsZEV4aXN0cykge1xuXG4gICAgLy8gY29uc29sZS5sb2cob3JpZ2luYWwsIG1lcmdlLCBmaWVsZEV4aXN0cylcblxuICAgIHZhciBrZXlzLCBpLCBrZXksIG9yaWdpbmFsQ2hpbGQsIG1lcmdlQ2hpbGQ7XG4gICAgaWYgKGZpZWxkRXhpc3RzKSB7XG4gICAgICBrZXlzID0ge307XG4gICAgICBmb3IgKGtleSBpbiBvcmlnaW5hbCkge1xuICAgICAgICBrZXlzW2tleV0gPSB0cnVlOyAvL2tleXMgY2FuIGJlIHVuZGVmaW5lZCAtLSBjb2RlIGNhbiBiZWNvbWUgc2hvcnRlclxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGkgaW4gbWVyZ2UpIHtcbiAgICAgIGlmICghZmllbGRFeGlzdHMgfHwga2V5c1tpXSkge1xuICAgICAgICBvcmlnaW5hbENoaWxkID0gb3JpZ2luYWxbaV07XG4gICAgICAgIG1lcmdlQ2hpbGQgPSBtZXJnZVtpXTtcbiAgICAgICAgaWYgKG9yaWdpbmFsQ2hpbGQgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgICAgICBpZiAob3JpZ2luYWxDaGlsZC5fX3JlbW92ZV9fICYmIChtZXJnZUNoaWxkICYmICFtZXJnZUNoaWxkLl9fcmVtb3ZlX18pKSB7XG4gICAgICAgICAgICBkZWxldGUgb3JpZ2luYWxDaGlsZC5fX3JlbW92ZV9fO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShtZXJnZUNoaWxkIGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICAgICAgbWVyZ2VbaV0gPSB7XG4gICAgICAgICAgICAgIHZhbDogbWVyZ2VDaGlsZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3JlY3VyKG9yaWdpbmFsQ2hpbGQsIG1lcmdlQ2hpbGQsIGZpZWxkRXhpc3RzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcmlnaW5hbFtpXSA9IG1lcmdlQ2hpbGQ7XG4gICAgICAgICAgb3JpZ2luYWxDaGlsZCA9ICdidXJuJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLypcbiAgICAgICAgICBfbXVsdGlwbGVcbiAgICAgICAgICBtZXJnZSBtdWx0aXBsZSBvcmdpbmFscyBpbnRvIGEgbmV3IG9yZ2luYWwgb2JqZWN0IGFsc28gcmVzb2x2ZSBuZXN0ZWQgY2FzZXNcbiAgICAgICovXG4gIF9tdWx0aXBsZSA9IGZ1bmN0aW9uKHQsIG5lc3RlZCwgY2FzZXMsIGN1cnJlbnRPYmosIGN1cnJlbnRWYWwsIGJhc2UsIG5hbWUsIHBhdGgsIG9yaWcpIHtcblxuICAgIGlmICghcGF0aCkge1xuICAgICAgb3JpZyA9IHQ7XG4gICAgICBwYXRoID0gW107XG4gICAgfVxuICAgIHZhciBqLCBfY2FzZSwgY3ZDaGlsZDtcblxuICAgIGlmKChjdXJyZW50VmFsIGluc3RhbmNlb2Ygb2JqZWN0KSAmJiAhYmFzZSkge1xuXG4gICAgICAvLyBjdXJyZW50T2JqLnZhbCA9IHQuX3ZhbFxuICAgICAgLy8gY29uc29sZS5lcnJvcignVk9CSicsIGN1cnJlbnRPYmopXG5cblxuICAgIH0gZWxzZSBpZiAoY3VycmVudFZhbCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgZm9yIChqIGluIGN1cnJlbnRWYWwpIHtcbiAgICAgICAgY3ZDaGlsZCA9IGN1cnJlbnRWYWxbal07XG4gICAgICAgIGlmIChleHBvcnRzW2pdKSB7XG4gICAgICAgICAgX2Nhc2UgPSBleHBvcnRzW2pdO1xuICAgICAgICAgIGlmIChfY2FzZSBpbnN0YW5jZW9mIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCFiYXNlIHx8ICFlbGVtZW50LnNldC5sb29rdXAuY2FsbChvcmlnLCBwYXRoW3BhdGgubGVuZ3RoIC0gMV0pKSB7IC8vZWxlbWVudCBpcyByZXF1aXJlZCBpbiBjYXNlcy5iYXNlLCBtYWtlIHRoaXMgcGFydCBleHRlbmRhYmxlXG4gICAgICAgICAgICAgIG5lc3RlZFtqXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX2lzT2JqKGN2Q2hpbGQpKSB7XG4gICAgICAgICAgICBjdXJyZW50T2JqLnZhbCA9IHQgJiYgKHQuX3ZhbCAhPT0gdm9pZCAwID8gdC5fdmFsIDogdm9pZCAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0aC5wdXNoKGopO1xuICAgICAgICAgICAgLy9zaG91bGQgYmUgcG9zc2libGUgdG8gdXNlIG5lc3RlZCBmb3IgY3VycmVudCBuZXN0ZWQgY2FzZTtcbiAgICAgICAgICAgIF9tdWx0aXBsZSh0LCBuZXN0ZWQsIGNhc2VzLCBjdXJyZW50T2JqLCBjdkNoaWxkLCBiYXNlLCBuYW1lLCBwYXRoLCBvcmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VycmVudE9ialtqXSA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKF9pc09iaihjdkNoaWxkKSkge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50T2JqW2pdKSB7XG4gICAgICAgICAgICAgIGN1cnJlbnRPYmpbal0gPSAodCAmJiB0W2pdICYmIHRbal0uY29udmVydCAmJiB0W2pdLmNvbnZlcnQoY3ZDaGlsZCkpIHx8IChjdkNoaWxkIGluc3RhbmNlb2YgQXJyYXkgPyBbXSA6IHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGgucHVzaChqKTtcbiAgICAgICAgICAgIF9tdWx0aXBsZSh0ICYmIHRbal0sIG5lc3RlZCwgY2FzZXMsIGN1cnJlbnRPYmpbal0sIGN2Q2hpbGQsIGJhc2UsIG5hbWUsIHBhdGgsIG9yaWcpO1xuICAgICAgICAgICAgaWYgKGJhc2UgJiYgKCF0IHx8ICF0W2pdKSkge1xuICAgICAgICAgICAgICBjdXJyZW50T2JqW2pdLl9fcmVtb3ZlX18gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodCAmJiBjdXJyZW50T2JqICYmICFjdXJyZW50T2JqW2pdKSB7XG4gICAgICAgICAgICAgIGlmIChmbGFnc1tqXSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBjdXJyZW50T2JqW2pdO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRPYmoudmFsID0gdC5fdmFsICE9PSB2b2lkIDAgPyB0Ll92YWwgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE9ialtqXSA9IGogPT09ICd2YWwnIFxuICAgICAgICAgICAgICAgICAgPyAodC5fdmFsICE9PSB2b2lkIDAgPyB0Ll92YWwgOiB2b2lkIDApIFxuICAgICAgICAgICAgICAgICAgOiAodFtqXSE9PXZvaWQgMCAmJiB0W2pdLmNvbnZlcnQgJiYgdFtqXS5jb252ZXJ0KCkpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qXG4gICAgICBvcmlnaW5hbFxuICAgICAgY3JlYXRlIGEgb3JnaW5hbCBzdG9yZSBmb3IgYSBuZXcgY2FzZVxuICAgICovXG5leHBvcnRzLm1ldGhvZHMub3JpZ2luYWwgPSBmdW5jdGlvbih0LCBpc09iaiwgdmFsLCBjYXNlcywgYmFzZSwgbmFtZSkge1xuXG5cblxuICB2YXIgb2JqID0gaXNPYmogPyB0LmNvbnZlcnQodmFsKSA6IHQuX3ZhbCxcbiAgICBpLCBjZmxhZywgbmVzdGVkID0ge307XG5cbiAgX211bHRpcGxlKHQsIG5lc3RlZCwgY2FzZXMsIG9iaiwgdmFsLCBiYXNlLCBuYW1lKTtcblxuICAvLyBmb3IodmFyIGkgaW4gbmVzdGVkKSB7XG4gIC8vICAgY29uc29sZS5lcnJvcignTkVTVEVEOjo6JyxpKTtcbiAgLy8gfVxuICAvLyBjb25zb2xlLmxvZyhiYXNlID8gJ0JBU0U6JzogJ1BST1BFUlRZOicgLCBuYW1lLCdPUklHSU5BTCBHRU5FUkFUSU9OJywnXFxudmFsOicsdmFsLCdcXG5vYmo6JyxvYmosJ1xcbm5lc3RlZDonLG5lc3RlZCwnXFxuY2FzZXM6JyxjYXNlcyk7XG5cbiAgZm9yIChpIGluIGNhc2VzKSB7XG4gICAgaWYgKCFuZXN0ZWRbaV0pIHtcbiAgICAgIGNmbGFnID0gY2FzZXNbaV0ub3JpZztcbiAgICAgIGlmICghaXNPYmopIHtcbiAgICAgICAgaWYgKF9pc09iaihjZmxhZykpIHtcbiAgICAgICAgICBpZiAoY2ZsYWcudmFsKSB7XG4gICAgICAgICAgICBvYmogPSBjZmxhZy52YWw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9iaiA9IGNmbGFnO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX2lzT2JqKGNmbGFnKSkge1xuICAgICAgICAgIGlmICghY2FzZXNbaV0ubmVzdGVkW25hbWVdKSB7XG4gICAgICAgICAgICBfcmVjdXIob2JqLCBjZmxhZywgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG9iai52YWwpIHtcbiAgICAgICAgICBvYmoudmFsID0gY2ZsYWc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG5cbiAgcmV0dXJuIFtvYmosIG5lc3RlZF07XG59O1xuLypcbiAgbWVyZ2VcbiAgbWVyZ2UgZHluYW1pYyBjYXNlcyAob3ZlcndyaXRlIC93IGNhc2VzIHRoYXQgYXJlIHRydWUgYW5kIGZ1cnRoZXIgaW4gdGhlIG9yZGVyIG9mIGNhc2VzKVxuKi9cbmV4cG9ydHMubWV0aG9kcy5tZXJnZSA9IGZ1bmN0aW9uKGlzT2JqLCBuYW1lLCB2YWwsIGNhc2VzKSB7XG4gIHZhciBvcmlnaW5hbCA9IHV0aWwuY2xvbmUoY2FzZXNbbmFtZV0ub3JpZyksXG4gICAgc1ZhbCA9IHZhbCxcbiAgICBvdmVyd3JpdGUsXG4gICAgaSxcbiAgICBtZXJnZSxcbiAgICBvcmlnaW5hbENoaWxkO1xuICBmb3IgKGkgaW4gY2FzZXMpIHtcbiAgICBpZiAoaSAhPT0gbmFtZSAmJiAhY2FzZXNbbmFtZV0ubmVzdGVkW2ldKSB7XG4gICAgICBpZiAoZXhwb3J0c1tpXS52YWwpIHtcbiAgICAgICAgbWVyZ2UgPSBjYXNlc1tpXS52YWw7XG4gICAgICAgIGlmIChfaXNPYmoob3JpZ2luYWwpIHx8IF9pc09iaihtZXJnZSkpIHtcbiAgICAgICAgICBpZiAoIV9pc09iaihvcmlnaW5hbCkpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsID0ge1xuICAgICAgICAgICAgICB2YWw6IG9yaWdpbmFsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIV9pc09iaihtZXJnZSkpIHtcbiAgICAgICAgICAgIG1lcmdlID0ge1xuICAgICAgICAgICAgICB2YWw6IG1lcmdlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfcmVjdXIob3JpZ2luYWwsIG1lcmdlLCB0cnVlKTtcbiAgICAgICAgICBmb3IgKGkgaW4gZXhwb3J0cykge1xuICAgICAgICAgICAgb3JpZ2luYWxDaGlsZCA9IG9yaWdpbmFsW2ldO1xuICAgICAgICAgICAgaWYgKG9yaWdpbmFsQ2hpbGQgIT09IG51bGwgJiYgb3JpZ2luYWxDaGlsZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBvcmlnaW5hbFtpXTsgLy9kZWxldGUgaXMgcHJldHR5IHNsb3dcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgICAgICAgaWYgKGlzT2JqKSB7XG4gICAgICAgICAgICAgIGlmIChzVmFsID09PSB2YWwpIHtcbiAgICAgICAgICAgICAgICBzVmFsID0gdXRpbC5jbG9uZShzVmFsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtZXJnZSA9IHV0aWwuY2xvbmUobWVyZ2UpO1xuICAgICAgICAgICAgICBmb3IgKGkgaW4gZXhwb3J0cykge1xuICAgICAgICAgICAgICAgIGlmIChtZXJnZVtpXSAhPT0gbnVsbCAmJiBtZXJnZVtpXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdSRU1PVkUgRklYJywgaSk7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgbWVyZ2VbaV07IC8vZGVsZXRlIGlzIHByZXR0eSBzbG93XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9yZWN1cihzVmFsLCBtZXJnZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobWVyZ2UudmFsKSB7XG4gICAgICAgICAgICAgICAgc1ZhbCA9IG1lcmdlLnZhbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcmlnaW5hbCA9IG1lcmdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG92ZXJ3cml0ZSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBbc1ZhbCwgb3JpZ2luYWxdO1xufTtcbi8qXG4gIHJlYWRlclxuICBhYnN0cmFjdGlvbiBmb3IgdXNlIGluIGNhc2VzLm9iamVjdCBhbmQgY2FzZXMuYmFzZVxuKi9cbmV4cG9ydHMubWV0aG9kcy5yZWFkZXIgPSBmdW5jdGlvbihmbiwgZHluYW1pYywgX3N0YXRpYykge1xuICByZXR1cm4gZnVuY3Rpb24gcmVhZGVyKG5hbWUsIHZhbCkge1xuICAgIHZhciBpbnZlcnQgPSAobmFtZVswXSA9PT0gJyEnKSxcbiAgICAgIHZDYXNlID0gaW52ZXJ0ID8gZXhwb3J0c1sobmFtZS5zbGljZSgxKSldIDogZXhwb3J0c1tuYW1lXSxcbiAgICAgIHJldDtcbiAgICBpZiAodkNhc2UpIHtcbiAgICAgIGlmICh2Q2FzZSBpbnN0YW5jZW9mIG9iamVjdCkge1xuICAgICAgICBpZiAoaW52ZXJ0ICYmICFleHBvcnRzW25hbWVdKSB7XG4gICAgICAgICAgZXhwb3J0c1tuYW1lXSA9IG5ldyB2YWx1ZSh7XG4gICAgICAgICAgICB2YWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gIXZDYXNlLnZhbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsaXN0ZW46IHZDYXNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0ID0gZm4gPyBmbi5jYWxsKHRoaXMsIG5hbWUsIHZhbCwgdHJ1ZSwgaW52ZXJ0KSA6IGR5bmFtaWM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSBpbnZlcnQgPyAhIWZuIDogZm4gPyBmbi5jYWxsKHRoaXMsIG5hbWUsIHZhbCkgOiBfc3RhdGljXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnZlcnQpIHtcbiAgICAgIHJldCA9IGZuID8gZm4uY2FsbCh0aGlzLCBuYW1lLCB2YWwsIGZhbHNlLCBpbnZlcnQpIDogX3N0YXRpYztcbiAgICB9XG4gICAgaWYgKHZDYXNlID09PSBmYWxzZSAmJiBmbikge1xuICAgICAgcmV0ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG5cbnJlcXVpcmUoJy4vb2JqZWN0Jyk7XG5yZXF1aXJlKCcuL2Jhc2UnKTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciBmbGFncyA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL2ZsYWdzJyksXG4gIENhc2VzID0gcmVxdWlyZSgnLi8nKSxcbiAgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyksXG4gIG1ldGhvZHMgPSBDYXNlcy5tZXRob2RzLFxuICBkeW5hbWljID0ge1xuICAgIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQsIG5hbWUpIHtcblxuICAgICAgaWYoIXRoaXMuX2ZsYWcpIHRoaXMuX2ZsYWcgPSB7fVxuXG4gICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgLy9zZWxlY3Rpb24gZm9yIHQuX2ZsYWcgZWFzeSBtYWtlblxuICAgICAgICAgIFxuICAgICAgICAgIFxuICAgICAgICBmbGFncyA9IHQuX2ZsYWcuY2FzZSB8fCAodC5fZmxhZy5jYXNlID0gW1xuICAgICAgICAgICdjYXNlJyxcbiAgICAgICAgICB0Ll92YWwsXG4gICAgICAgICAgZmFsc2UsIHt9LFxuICAgICAgICAgIGR5bmFtaWNcbiAgICAgICAgXSksXG4gICAgICAgIGNhc2VzID0gZmxhZ3NbM10sXG4gICAgICAgIGlzT2JqID0gdXRpbC5pc09iaih2YWwpLFxuICAgICAgICBzZXRWYWwgPSAoaXNPYmogJiYgIXZhbC52YWwpID8gZmFsc2UgOiB0cnVlO1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoY2FzZXNbbmFtZV0pIHtcbiAgICAgICAgICBDYXNlc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcihjYXNlc1tuYW1lXS5tZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBjYXNlc1tuYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYWdzWzVdID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFjYXNlc1tuYW1lXSkge1xuICAgICAgICAgIHZhciB4ID0gbWV0aG9kcy5vcmlnaW5hbCh0LCBpc09iaiwgdmFsLCBjYXNlcywgZmFsc2UsIG5hbWUpO1xuICAgICAgICAgIGNhc2VzW25hbWVdID0ge1xuICAgICAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgICAgICBvcmlnOiB4WzBdLFxuICAgICAgICAgICAgbmVzdGVkOiB4WzFdLFxuICAgICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHNldCA9IG1ldGhvZHMubWVyZ2UoaXNPYmosIG5hbWUsIHZhbCwgY2FzZXMpLFxuICAgICAgICAgICAgICBzVmFsID0gc2V0WzBdLFxuICAgICAgICAgICAgICBvcmlnaW5hbCA9IHNldFsxXTtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2cobmFtZSlcbiAgICAgICAgICAgICAgLy8gaWYobmFtZSA9PT0gJyRpc0FjdGl2ZScgKWNvbnNvbGUuZXJyb3IoJ2JvZWxvZSBib2Vsb2UgYm9lbG9lISEhJyxzVmFsLG9yaWdpbmFsKVxuXG4gICAgICAgICAgICAgIGZsYWdzWzVdID0gdHJ1ZTsgLy90aGUgY2xvc3VyZXMgaGVyZSBhcmUgbm90IHJlYWxseSBuZXNzZWNhcnkgYmV0dGVyIHRvIGF2b2lkXG4gICAgICAgICAgICAgIGlmIChDYXNlc1tuYW1lXS52YWwpIHtcblxuICAgICAgICAgICAgICAgIGlmKCFzVmFsKSBjb25zb2xlLndhcm4obmFtZSwnd3JvbmcgaW4gY2FzZXMhJywgc1ZhbCwgQ2FzZXMsIGZsYWdzKVxuICAgICAgICAgICAgICAgIGlmIChzZXRWYWwgJiYgc1ZhbCkge1xuICAgICAgICAgICAgICAgICAgLy8gaWYobmFtZSA9PT0gJyRpc0FjdGl2ZScgKWNvbnNvbGUubG9nKCd5ZWUgaXRzIHRydWUnKVxuICAgICAgICAgICAgICAgICAgZmxhZ3NbMV0gPSBzVmFsLnZhbCB8fCBzVmFsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0LnZhbCA9IHNWYWw7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYobmFtZSA9PT0gJyRpc0FjdGl2ZScgKWNvbnNvbGUubG9nKCdubyB3YXkgZ296ZWUnKVxuXG4gICAgICAgICAgICAgICAgaWYgKHNldFZhbCkgZmxhZ3NbMV0gPSBvcmlnaW5hbCAmJiBvcmlnaW5hbC52YWwgfHwgb3JpZ2luYWxcblxuICAgICAgICAgICAgICAgIGlmKG5hbWUgPT09ICckaXNBY3RpdmUnICljb25zb2xlLmxvZygnbm8gd2F5IGdvemVlIDInLG9yaWdpbmFsLCB0KVxuXG4gICAgICAgICAgICAgICAgdC52YWwgPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmbGFnc1s1XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBDYXNlc1tuYW1lXS5hZGRMaXN0ZW5lcihmbGFnc1szXVtuYW1lXS5tZXRob2QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChDYXNlc1tuYW1lXS52YWwpIHtcbiAgICAgICAgICBpZiAoc2V0VmFsKSB7XG4gICAgICAgICAgICBmbGFnc1sxXSA9IHZhbC52YWwgfHwgdmFsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3Quc2V0LmNhbGwodCwgdmFsLCBzdGFtcCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgIC8vbm90IGFsd2F5c1xuICAgICAgICAgIHQuX2lnbm9yZWZvcm5vdyA9IHRydWVcblxuICAgICAgICB9XG4gICAgICAgIGZsYWdzWzVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIHJlc2V0OmZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29uc29sZS5lcnJvcigncmVzZXQnKVxuICAgIC8vIH0sXG4gICAgLy9hZGQgcmVzZXQgbGF0ZXJcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGZsYWdzLCBuYW1lKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhmbGFncywgbmFtZSlcbiAgICAgIHZhciBjbnQgPSAwXG4gICAgICBmb3IgKHZhciBpIGluIGZsYWdzWzNdKSB7XG4gICAgICAgIC8vIGlmKGZsYWdzWzNdKVxuICAgICAgICBjbnQrK1xuICAgICAgICBpZighdGhpcy5faWdub3JlZm9ybm93ICYmICFuYW1lIHx8IGk9PT1uYW1lKSB7XG4gICAgICAgICAgY250IC0tXG4gICAgICAgICAgQ2FzZXNbaV0ucmVtb3ZlTGlzdGVuZXIoZmxhZ3NbM11baV0ubWV0aG9kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdGhpcy5faWdub3JlZm9ybm93XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGNudCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ0FTRSBPQkpFQ1QgUkVNT1ZBTCAtLS0gSVQgSVMgTk9UIEVNUFknKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RhY2s6ICdjYXNlJ1xuICB9LFxuICBfc3RhdGljID0ge1xuICAgIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQsIG5hbWUpIHtcbiAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgb2JqZWN0LnNldC5jYWxsKHRoaXMsIHZhbCwgc3RhbXAsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbmZsYWdzLmR5bmFtaWMuY2FzZXMgPSBtZXRob2RzLnJlYWRlcihmYWxzZSwgZHluYW1pYywgX3N0YXRpYyk7IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG4vKlxuICBnZXRzIGFuZCBjYWNoZXMgdmFsdWVzIGZvciBjc3MgY2xhc3NlcywgYWxzbyBwb3NzaWJsZSB0byBjaGFuZ2Ugc3R5bGVzIG9mIGNsYXNzZXNcbiAgcmV0dXJuIGFuIGFycmF5IG9mIG11bHRpcGxlIGNzcyBvYmplY3RzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGNsYXNzIG5hbWVcbiAgd2hlbiB5b3UgcGFzcyBmaWVsZCBpdCBzZWFyY2hlcyB0aGUgZmllbGQgdHJvdWdoIGFsbCB0aGUgY2xhc3NlcyBzZWxlY3RlZCwgYWx3YXlzIHRha2VzIGZpcnN0IGFyZ3VtZW50XG4gIG1heWJlIGhhdmUgdG8gbWFrZSB0aGlzIGZvciB0aGluZ3Mgc3VjaCBhcyBkaXYgc2VsZWN0b3JzIC8gbmVzdGVkIHN0dWZmIC0tLSB3aWxsIGJlIGNwdSBpbnRlbnNpdmUhO1xuKi9cbnZhciBzZWxlY3RvciA9ICdjc3NSdWxlcycsXG4gIHBhcnNlY2xhc3MgPSBmdW5jdGlvbihzbGN0cikge1xuICAgIHNsY3RyID0gJy4nICsgc2xjdHIucmVwbGFjZSgvXFwuL2csICcgLicpLnRvTG93ZXJDYXNlKCk7XG4gICAgZm9yICh2YXIgcm9iaiwgc2VsZWN0ID0gZG9jdW1lbnQuc3R5bGVTaGVldHMsIGxlbmd0aCA9IHNlbGVjdC5sZW5ndGgsIGkgPSAwLCBzZWxlY3RJdGVtOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdEl0ZW0gPSBzZWxlY3RbaV1bc2VsZWN0b3JdIHx8IHNlbGVjdFtpXVsoc2VsZWN0b3IgPSAncnVsZXMnKV07IC8vbG9jYXRpb24gb2YgdGhpcyBwb2x5ZmlsbCBjYW4gYmUgaW1wcm92ZWRcbiAgICAgIGlmKHNlbGVjdEl0ZW0pIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBzZWxlY3RJdGVtLmxlbmd0aCwgaXRlbTsgc2VsZWN0SXRlbSwgaiA8IGw7IGl0ZW0gPSBzZWxlY3RJdGVtW2orK10sIGl0ZW0uc2VsZWN0b3JUZXh0ID09PSBzbGN0ciAmJiAocm9iaiA9IGl0ZW0uc3R5bGUpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJvYmo7XG4gIH0sXG4gIGMgPSBmdW5jdGlvbihjc3NDbGFzcywgY2FjaGUpIHtcbiAgICB2YXIgdCA9IGV4cG9ydHM7XG4gICAgY2FjaGUucHVzaCh0W2Nzc0NsYXNzXSB8fCAodFtjc3NDbGFzc10gPSBwYXJzZWNsYXNzKGNzc0NsYXNzKSkgfHwge30pO1xuICAgIHJldHVybiBjc3NDbGFzcztcbiAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzbGN0ciwgZmllbGQpIHtcbiAgaWYgKHNsY3RyKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpc1tzbGN0cl07XG4gICAgaWYgKCFjYWNoZSkge1xuICAgICAgY2FjaGUgPSBbXTtcbiAgICAgIGZvciAodmFyIHNlbGVjdGFycmF5ID0gc2xjdHIuc3BsaXQoJyAnKSwgaSA9IDAsIGwgPSBzZWxlY3RhcnJheS5sZW5ndGgsIGNzc0NsYXNzOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmICgoY3NzQ2xhc3MgPSBjKHNlbGVjdGFycmF5W2ldLCBjYWNoZSkuc3BsaXQoJy4nKSkgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIGMoY3NzQ2xhc3NbY3NzQ2xhc3MubGVuZ3RoIC0gMV0sIGNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpc1tzbGN0cl0gPSBjYWNoZTtcbiAgICB9XG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICBpZighKGNhY2hlIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICByZXR1cm5cbiAgICAgIGZvciAodmFyIHJldCwgaSA9IGNhY2hlLmxlbmd0aCAtIDE7ICFyZXQgJiYgaSA+PSAwOyByZXQgPSBjYWNoZVtpLS1dW2ZpZWxkXSk7XG4gICAgICBjYWNoZSA9IHJldDsgIFxuICAgIH1cbiAgICByZXR1cm4gY2FjaGU7XG4gIH1cbn07IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGJhc2UgPSByZXF1aXJlKCcuLi8uLi9iYXNlJylcbiAgLCB2YWx1ZUJhc2UgPSByZXF1aXJlKCcuLi8uLi92YWx1ZS9iYXNlJylcbiAgLCB2aWdvdXIgPSByZXF1aXJlKCcuLi8uLi8nKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBlbGVtZW50QmFzZSA9IG5ldyBiYXNlKClcblxuZWxlbWVudEJhc2UuZGVmYXVsdFR5cGUgPSB2YWx1ZUJhc2UudHlwZVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSB2aWdvdXIuRWxlbWVudCA9IGVsZW1lbnRCYXNlLkNsYXNzXG5leHBvcnRzLmJhc2UgPSBlbGVtZW50QmFzZVxuXG52YXIgX2RvYyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6ICdubyBkb2N1bWVudCcsIC8vcmVmZXJlbmNlIHRvIGRvY3VtZW50IGlzIGZhc3RlciB0aGFuIHVzaW5nIHdpbmRvdy5kb2N1bWVudDtcbiAgLyoqXG4gICAqIFJlbW92ZXMgY2hpbGRyZW4gZnJvbSBwYXJlbnQgbm9kZVxuICAgKiBAbWV0aG9kIF9yZW1vdmVDaGlsZHJlblxuICAgKi9cbiAgX3JlbW92ZUNoaWxkcmVuID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgYyA9IHRoaXMuX25vZGUuY2hpbGROb2RlcywgaSA9IDAsIGwgPSBjLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGNbaV0uYmFzZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZ1xuICAgICAgICBjW2ldLmJhc2UucmVtb3ZlKGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIG5vZGVcbiAqIGFkZHMgYW5kIGNsb25lcyBodG1sIG5vZGVzO1xuICogQGF0dHJpYnV0ZVxuICovXG5leHBvcnRzLmJhc2UuZXh0ZW5kKHtcbiAgICBuYW1lOiAnbm9kZScsXG4gICAgdHlwZTogZmFsc2UgLFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4gbm9kZSBpcyBzZXRcbiAgICAgKiBAbWV0aG9kIHNldFxuICAgICAqIEBwYXJhbSAgeyp9IHZhbCBEZWZpbmVzIHRoZSB2YWx1ZSBvZiB0aGlzLl9ub2RlXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIC8vY2hhbmdpbmcgbm9kZSBidWdzIC93IGNvbnZlcnNpb25zXG4gICAgICAvL2lmcmFtZSBzZWxlY3RvcnMgZG9udCBldmFsdWF0ZSB0byBhIHN0cmluZ1xuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCB8fCAhdmFsLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9ub2RlID0gdmFsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbm9kZSA9IF9kb2MuY3JlYXRlRWxlbWVudCh2YWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbm9kZS5iYXNlID0gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4geW91IGdldCBub2RlXG4gICAgICogQG1ldGhvZCBnZXRcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9ub2RlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IF9kb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4geW91IGNyZWF0ZSBhIG5ldyBub2RlXG4gICAgICogQG1ldGhvZCBuZXdcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGZyb20gICAgVGFyZ2V0XG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBuZXdub2RlIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICBcIm5ld1wiOiBmdW5jdGlvbihmcm9tLCBuZXdub2RlKSB7XG4gICAgICBpZiAoIW5ld25vZGUpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBmcm9tLl9ub2RlO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIHRoaXMuX25vZGUgPSBub2RlLmNsb25lTm9kZSh0cnVlKTsgLy9lc3BlY2lhbHkgZ29vZCB0byBkbyBmb3IgbWVtb3J5IChhbHNvIHNhdmVzIDIwJSBvbiBjcHUpXG4gICAgICAgICAgdGhpcy5fbm9kZS5iYXNlID0gdGhpcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbm9kZSA9IG5ld25vZGU7XG4gICAgICB9XG4gICAgICBpZiAoZnJvbS5fbm9kZSAmJiBmcm9tLl9ub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICB2YXIgaSwgYyA9IHRoaXMuX25vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgICBjZiA9IGZyb20uX25vZGUuY2hpbGROb2RlcyxcbiAgICAgICAgICBsID0gYy5sZW5ndGgsXG4gICAgICAgICAgY2ksIGNmYjtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIGNmYiA9IGNmW2ldLmJhc2U7XG4gICAgICAgICAgaWYgKGNmYikge1xuICAgICAgICAgICAgY1tpXS5iYXNlID0gbmV3IGNmYi5DbGFzcyhmYWxzZSwgZmFsc2UsIGNbaV0pO1xuICAgICAgICAgICAgLy9tYXliZSBjYWxsIGNoaWxkcmVuIG5ldyBzdHVmZiB3aXRoIGEgY3VzdG9tIHNldHRpbmcgYXMgd2VsbD9cbiAgICAgICAgICAgIGlmIChjZmIuX25hbWUpIHtcbiAgICAgICAgICAgICAgY1tpXS5iYXNlLl9uYW1lID0gY2ZiLl9uYW1lO1xuICAgICAgICAgICAgICB0aGlzW2NmYi5fbmFtZV0gPSBjW2ldLmJhc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjW2ldLmJhc2Uuc2V0dGluZygncGFyZW50JywgW3RoaXNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIERlZmluZXMgd2hhdCBoYXBwZW5zIHdoZW4geW91IHJlbW92ZSBhIG5vZGVcbiAgICAgKiBAbWV0aG9kIHJlbW92ZVxuICAgICAqIEBwYXJhbSAgeyp9ICBbcGFyYW1dIElmIHBhcmFtIGRvZXNuJ3QgcmVtb3ZlIG5vZGUgZnJvbSBwYXJlbnRcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKHBhcmFtKSB7XG4gICAgICBfcmVtb3ZlQ2hpbGRyZW4uY2FsbCh0aGlzKTtcbiAgICAgIGlmKHRoaXMuX25vZGUpIHRoaXMuX25vZGUuYmFzZSA9IG51bGwgLy9saXR0bGUgc2xvdyBvcHRpbWl6ZSBsYXRlclxuICAgICAgaWYgKCFwYXJhbSkge1xuICAgICAgICB2YXIgX3AgPSB0aGlzLl9ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChfcCkge1xuICAgICAgICAgIF9wLnJlbW92ZUNoaWxkKHRoaXMuX25vZGUpO1xuICAgICAgICAgIGlmICh0aGlzLl9uYW1lICYmIF9wLmJhc2UpIHtcbiAgICAgICAgICAgIF9wLmJhc2VbdGhpcy5fbmFtZV0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFNldCBjc3MgY2xhc3Mgb2YgYSBkaXZcbiAgICogVXNlIGFkZENsYXNzIG9yIHJlbW92ZUNsYXNzIHRvIGFkZC9yZW1vdmUgYSBjbGFzc1xuICAgKiBAYXR0cmlidXRlIGNzc1xuICAgKiBAcGFyYW0gIHtPYmplY3R9IHZhbCBbZGVzY3JpcHRpb25dXG4gICAqIHdhcm5pbmc6IHRoZSBhZGQgb3BlcmF0b3IgaW4gY3NzIGlzIGN1cnJlbnRseSB1c2VkIGJ5IC5uYW1lLFxuICAgKiBhbmQgd2lsbCBiZSByZXBsYWNlZCB3aGVuIHlvdSB0cnkgdG8gYnVpbGQgYSBzdHJpbmdcbiAgICogdXNpbmcge3ZhbDogLi4uLiBhZGQ6IC4uLi59XG4gICAqL1xuICB7XG4gICAgLy8gX18kY3NzOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIC8vIHRoaXMuY3NzXG4gICAgLy8gfVxuICAgIGNzczogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgX3ZhbCA9IHZhbC52YWwgfHwgJyc7XG4gICAgICB2YWwuX3NraXAgPSB0cnVlOyAvL19za2lwIGlzIGFuIHVnbHkgbmFtZVxuICAgICAgaWYodmFsLmFkZENsYXNzKXtcbiAgICAgICAgaWYgKCF+X3ZhbC5pbmRleE9mKHZhbC5hZGRDbGFzcy52YWwpKSB7XG4gICAgICAgICAgdmFsLl92YWwgPSAoKF92YWwubGVuZ3RoID4gMCA/IF92YWwgKyAnICcgOiAnJykgKyB2YWwuYWRkQ2xhc3MudmFsKTtcbiAgICAgICAgICBpZih2YWwuYWRkKSB2YWwuX3ZhbCA9IHZhbC5fdmFsLnJlcGxhY2UodmFsLmFkZC52YWwsJycpXG4gICAgICAgICAgdmFsLl9sdmFsID0gZmFsc2U7XG4gICAgICAgICAgdmFsLl9fbHZhbCA9IGZhbHNlO1xuICAgICAgICAgIHZhbC5fX19sdmFsID0gZmFsc2U7XG4gICAgICAgICAgX3ZhbCA9IHZhbC52YWw7XG4gICAgICAgIH1cbiAgICAgICAgdmFsLmFkZENsYXNzLnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZih2YWwucmVtb3ZlQ2xhc3Mpe1xuICAgICAgICBpZiAoX3ZhbCAmJiB2YWwuX3ZhbCkge1xuICAgICAgICAgIHZhbC5fdmFsID0gdmFsLl92YWwucmVwbGFjZShuZXcgUmVnRXhwKCcgPycgKyB2YWwucmVtb3ZlQ2xhc3MudmFsKSwgJycpO1xuICAgICAgICAgIHZhbC5fbHZhbCA9IGZhbHNlO1xuICAgICAgICAgIHZhbC5fX2x2YWwgPSBmYWxzZTtcbiAgICAgICAgICB2YWwuX19fbHZhbCA9IGZhbHNlO1xuICAgICAgICAgIF92YWwgPSB2YWwudmFsO1xuICAgICAgICB9XG4gICAgICAgIHZhbC5yZW1vdmVDbGFzcy5yZW1vdmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYoIF92YWwgKSB7XG4gICAgICAgIHRoaXMubm9kZS5jbGFzc05hbWUgPSBfdmFsLnJlcGxhY2UoJyQnLCcnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ub2RlLmNsYXNzTmFtZSA9ICcnXG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogTWFrZXMgaXQgcG9zc2libGUgdG8gcmVmZXJlbmNlIGEgY2hpbGQgYnkgbmFtZVxuICAgKiBTZXR0aW5nIG9uIGEgY2xhc3MgZG9lcyBub3QgdXBkYXRlIG5hbWVzIG9mIGluc3RhbmNlc1xuICAgKiBFbGVtZW50W05BTUVdXG4gICAqIEBhdHRyaWJ1dGUgbmFtZVxuICAgKi9cbiAge1xuICAgIG5hbWU6ICduYW1lJyxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIF9wID0gdGhpcy5wYXJlbnQ7XG4gICAgICBpZiAodGhpcy5fbmFtZSkge1xuICAgICAgICBpZiAoX3ApIHtcbiAgICAgICAgICBfcFt0aGlzLl9uYW1lXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX25hbWUgPSB2YWw7XG4gICAgICBpZiAoIXRoaXMuX25vZGUgfHwgdmFsICE9PSB0aGlzLm5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAvL25hbWUgZG9lcyBub3QgaW5oZXJpdCwgYmV3YXJlIVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnV0hBVFMgVEhJUz8nLHZhbCk7XG4gICAgICAgIC8vIHRoaXMuY3NzID0ge2FkZENsYXNzOnZhbH07XG4gICAgICAgIC8vIHRoaXMuY2xhc3NOYW1lID0gdGhpcy5fbmFtZTtcbiAgICAgICAgaWYoIXRoaXMuY3NzIHx8IHRoaXMuY3NzLl92YWwhPT12YWwpdGhpcy5jc3MgPSB7IGFkZDogJyAnICsgdmFsIH1cbiAgICAgICAgLy9zcGVjaWFsIG5hbWUgZmllbGQ/XG4gICAgICB9XG4gICAgICBpZiAoX3ApIHtcbiAgICAgICAgX3BbdmFsXSA9IHRoaXM7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBwYXJlbnQgYmFzZSBlbGVtZW50XG4gICAqIEBhdHRyaWJ1dGUgcGFyZW50XG4gICAqL1xuICB7XG4gICAgbmFtZTogJ3BhcmVudCcsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLl9ub2RlKSB7XG4gICAgICAgIHZhciBfcCA9IHRoaXMuX25vZGUucGFyZW50Tm9kZSB8fCB0aGlzLl9wO1xuICAgICAgICByZXR1cm4gX3AgPyBfcC5iYXNlIHx8IF9wLl9wIDogZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyBjaGlsZE5vZGVzIC93IGJhc2UgY2xhc3NlcyBhcnJheSBzbG93LCBjYWNoZSBpZiBwb3NzaWJsZVxuICAgKiBAYXR0cmlidXRlIGNoaWxkcmVuXG4gICAqL1xuICB7XG4gICAgbmFtZTogJ2NoaWxkcmVuJyxcbiAgICB0eXBlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYoIXRoaXMuX25vZGUpIHJldHVybiBbXVxuICAgICAgdmFyIGMgPSB0aGlzLl9ub2RlLmNoaWxkTm9kZXMsXG4gICAgICAgIGwgPSBjLmxlbmd0aCxcbiAgICAgICAgX2MgPSBuZXcgQXJyYXkobCksXG4gICAgICAgIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIF9jW2ldID0gY1tpXS5iYXNlIHx8IGNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gX2M7XG4gICAgfVxuICB9KTtcblxudmFyIHJlY3VyUmVuZGVyID0gZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgaWYgKCF0aGlzLmxhc3RpbmRleCkgdGhpcy5zZXR0aW5nKCdyZW5kZXInLCBbcGFyZW50XSkgLy9leGVjdXRlIHJlbmRlciBzZXR0aW5nc1xuXG4gIGlmICh0aGlzLnJlbmRlcnMpIHtcblxuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1JFTkRFUiAtLS0nLCB0aGlzLm5hbWUsIHRoaXMucmVuZGVycylcblxuICAgIGZvciAodmFyIHBcbiAgICAgICwgYyA9IHRoaXMubm9kZS5jaGlsZE5vZGVzXG4gICAgICAsIGNsXG4gICAgICAsIGFyciA9IHRoaXMucmVuZGVyc1xuICAgICAgLCBvYmpcbiAgICAgICwgaSA9IHRoaXMubGFzdGluZGV4IHx8IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBvYmogPSBhcnJbaV1cblxuICAgICBpZihvYmopIHtcbiAgICAgICAgcCA9IHV0aWwuY2hlY2tBcnJheShjLCBvYmosICdiYXNlJylcbiAgICAgICAgaWYgKHAgIT09IGZhbHNlKSB7XG4gICAgICAgICAgcmVjdXJSZW5kZXIuY2FsbChvYmosIHRoaXMpXG4gICAgICAgIH0gZWxzZSBpZihvYmouX2Zyb20pIHtcblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDTEFTUyEnLG9iaiwgb2JqLm5hbWUgJiYgdGhpc1tvYmoubmFtZV0gJiYgdGhpc1tvYmoubmFtZV0gPT09IGNsKVxuXG4gICAgICAgICAgY2wgPSBvYmouQ2xhc3NcblxuICAgICAgICAgIGlmKG9iai5uYW1lICYmIHRoaXNbb2JqLm5hbWVdICYmIHRoaXNbb2JqLm5hbWVdID09PSBjbCkge1xuICAgICAgICAgICAgcmVjdXJSZW5kZXIuY2FsbCh0aGlzW29iai5uYW1lXSwgdGhpcylcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICBmb3IgKHZhciBqIGluIGMpIHtcbiAgICAgICAgICAgICBpZiAoY1tqXS5iYXNlICYmIGNbal0uYmFzZSBpbnN0YW5jZW9mIGNsKSB7XG4gICAgICAgICAgICAgICByZWN1clJlbmRlci5jYWxsKGNbal0uYmFzZSwgdGhpcylcbiAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGFyci5zcGxpY2UoaSwxKVxuICAgIH1cbiAgfVxuXG4gIHRoaXMubGFzdGluZGV4ID0gbFxufSxcblxuc2V0UmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwLCBwcDtcbiAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgcCA9IHRoaXMucGFyZW50O1xuICAgIGlmIChwLnJlbmRlcnMpIHtcbiAgICAgIHAucmVuZGVycy5wdXNoKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnJlbmRlcnMgPSBbdGhpc107XG4gICAgICBwcCA9IHAucGFyZW50O1xuICAgICAgaWYgKHBwICYmICEocHAuX3NldHRpbmdzICYmIHBwLl9zZXR0aW5ncy5yZW5kZXIgIT09IHRydWUpKSB7XG4gICAgICAgIHNldFJlbmRlci5jYWxsKHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSxcblxudmFsUmVuZGVyID0gZnVuY3Rpb24odmFsKSB7XG4gIHZhciBfc2V0dGluZ3MgPSAodmFsLl9fICYmIHZhbC5fXy5fc2V0dGluZ3MgfHwgdmFsLl8uX3NldHRpbmdzKVxuICBpZiAodmFsLl8ucmVuZGVycyB8fCB2YWwuX18gJiYgdmFsLl9fLnJlbmRlcnMgfHwgX3NldHRpbmdzLnJlbmRlciAhPT0gdHJ1ZSkge1xuICAgIGlmICghdGhpcy5yZW5kZXJzKSB0aGlzLnJlbmRlcnMgPSBbXVxuICAgIGlmICghKHRoaXMuX18gJiYgdGhpcy5fXy5yZW5kZXJzKSkgdGhpcy5yZW5kZXJzID0gdXRpbC5jbG9uZSh0aGlzLnJlbmRlcnMpXG4gICAgLy8gY29uc29sZS5sb2codGhpcy5yZW5kZXJzPT09dGhpcy5fXy5yZW5kZXJzLCB0aGlzLl9fLnJlbmRlcnMsIHRoaXMuXy5yZW5kZXJzKVxuXG4gICAgLy8gY29uc29sZS5sb2codXRpbC5jaGVja0FycmF5KHRoaXMucmVuZGVycyx2YWwuX2Zyb20pKVxuICAgIC8vIGNvbnNvbGUubG9nKCdYWFhYWFgnLHZhbClcbiAgICAvLyBpZih1dGlsLmNoZWNrQXJyYXkodGhpcy5yZW5kZXJzLHZhbC5fZnJvbS5fZnJvbSwnX2Zyb20uX2Zyb20nKT09PWZhbHNlJiZ1dGlsLmNoZWNrQXJyYXkodGhpcy5yZW5kZXJzLHZhbC5fZnJvbSwnX2Zyb20nKT09PWZhbHNlKSB7XG4gICAgICB0aGlzLnJlbmRlcnMucHVzaCh2YWwpXG4gICAgLy8gfVxuICAgIC8vIGNvbnNvbGUubG9nKCdyZW5kZXJzIHB1c2ggLS0tIGNyZWF0ZXMgbGVha3MhJylcbiAgfVxufVxuXG4vL2RlZmluZSB2YW51aXQgYmFzZSAoa29ydGVyISlcbnV0aWwuZGVmaW5lKGV4cG9ydHMsXG4gICAnYXBwZW5kJywgZnVuY3Rpb24oYXJyKSB7XG5cbiAgICAvLyBhbGVydCgnQVBQRU5EJylcbiAgICAvLyBjb25zb2xlLmxvZygnQVBQRU5EJy5pbnZlcnNlLGFycilcblxuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHNcblxuICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aD4xKSB7XG4gICAgICAgIGFyciA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICAgIH0gLy9lbHNlIGlmKGFyciApXG5cbiAgICAgIHZhciBpbnNlcnRiZWZvcmVcbiAgICAgIGlmKCFhcnIubGVuZ3RoICYmICEoYXJyIGluc3RhbmNlb2YgZXhwb3J0cykgJiYgYXJyLnZhbCkge1xuICAgICAgICBpbnNlcnRiZWZvcmUgPSBhcnIuYmVmb3JlXG4gICAgICAgIGFyciA9IGFyci52YWxcbiAgICAgIH1cbiAgICAgIHZhciBDbGFzcyA9IGFyclswXVxuICAgICAgLCBpID0gMFxuICAgICAgLCBsID0gYXJyLmxlbmd0aFxuICAgICAgaWYoIWFyci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQoYXJyLCBpbnNlcnRiZWZvcmUpXG4gICAgICB9IGVsc2UgaWYodHlwZW9mIENsYXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvcih2YXIgaT0xLCBsID0gYXJyLmxlbmd0aDtpPGw7aSsrKSB7XG4gICAgICAgICAgdGhpcy5hZGQobmV3IENsYXNzKGFycltpXSksIGluc2VydGJlZm9yZSlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKDtpPGw7aSsrKSB7XG4gICAgICAgICAgdGhpcy5hZGQoYXJyW2ldLCBpbnNlcnRiZWZvcmUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgfSxcbiAgJ2NoZWNrUmVuZGVyJywgZnVuY3Rpb24odmFsLCBub3RSZW5kZXJlZCkge1xuICAgIGlmICh2YWwpIHZhbFJlbmRlci5jYWxsKHRoaXMsIHZhbClcbiAgICBpZiAoIW5vdFJlbmRlcmVkKSB7XG4gICAgICB2YXIgX3JlbmRlcnMgPSAodGhpcy5fXyAmJiB0aGlzLl9fLnJlbmRlcnMgfHwgdGhpcy5fLnJlbmRlcnMpXG4gICAgICBpZiAoICggKF9yZW5kZXJzICB8fCAoKHRoaXMuX18gJiYgdGhpcy5fXy5fc2V0dGluZ3MpICB8fCB0aGlzLl8uX3NldHRpbmdzKS5yZW5kZXIgIT09IHRydWUpXG4gICAgICAgICAgJiYgKCF0aGlzLmxhc3RpbmRleCB8fCAoX3JlbmRlcnMgJiYgdGhpcy5sYXN0aW5kZXggPCBfcmVuZGVycy5sZW5ndGgpKVxuICAgICAgICApICYmIHRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgcmVjdXJSZW5kZXIuY2FsbCh0aGlzLCB0aGlzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYodGhpcy5wYXJlbnQpIHZhbFJlbmRlci5jYWxsKHRoaXMucGFyZW50LCB0aGlzKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ2NoZWNrUGFyZW50JywgdXRpbC5jaGVja1BhcmVudEZhY3RvcnkoJ3BhcmVudCcpLFxuICAnZ2V0JyxmdW5jdGlvbihwYXRoLCBzZWxmKSB7IC8vZ2V0IGRvZXMgbm90IG5lZWQgYW4gYXJyYXkgYXMgcGF0aFxuICAgIHJldHVybiB1dGlsLmdldCh0aGlzLCBwYXRoLCBzZWxmKTtcbiAgfSxcbiAgJ2ZpbmQnLCBmdW5jdGlvbihnZXQsIG1hdGNoLCBsZXZlbCkge1xuICAgIGlmKGxldmVsID09PSB2b2lkIDApIGxldmVsID0gdHJ1ZVxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMubm9kZS5jaGlsZE5vZGVzXG4gICAgICAsIGkgPSAwXG4gICAgICAsIGZvdW5kXG4gICAgICAsIGNoaWxkXG4gICAgICAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aFxuICAgICAgLCBwYXNzT24gPSBsZXZlbD09PXRydWUgPyB0cnVlIDogbGV2ZWwtMVxuICAgIGZvcig7aTxsZW47aSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldLmJhc2VcbiAgICAgIGlmKGNoaWxkKSB7XG4gICAgICAgIGlmKGNoaWxkLmdldChnZXQsIHRydWUpPT1tYXRjaCkge1xuICAgICAgICAgIHJldHVybiBjaGlsZFxuICAgICAgICB9IGVsc2UgaWYobGV2ZWwpIHtcbiAgICAgICAgICBmb3VuZCA9IGNoaWxkLmZpbmQoZ2V0LCBtYXRjaCwgcGFzc09uKVxuICAgICAgICAgIGlmKGZvdW5kKSByZXR1cm4gZm91bmRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJ3NldFJlbmRlcicsIGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAgIHRoaXMuc2V0U2V0dGluZyh7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgcmVuZGVyOiB2YWxcbiAgICB9KTtcbiAgICBzZXRSZW5kZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHsgLy9sb29rIGZvciBjdXJyZW50IGNhbGxlciBpbnN0YW5jZSBwZXJoYXBzP1xuICAgICAgc2V0UmVuZGVyLmNhbGwodGhpcylcbiAgICB9LCBuYW1lKTtcbiAgfSxcbiAgJ3JlbmRlcnMnLCBmYWxzZSxcbiAgLyoqXG4gICAqIEFkZCBlbGVtZW50IGFzIGNoaWxkXG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgdmFsICBPYmplY3QgdG8gYmUgYWRkZWRcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICBSZXR1cm5zIHRoZSBWLmVsZW1lbnRcbiAgICovXG4gICdhZGQnLCBmdW5jdGlvbih2YWwsIGluc2VydGJlZm9yZSkge1xuICAgIFxuICAgIGlmKGluc2VydGJlZm9yZSkge1xuICAgICAgaWYodHlwZW9mIGluc2VydGJlZm9yZSA9PT0gJ3N0cmluZycpIGluc2VydGJlZm9yZSA9IHRoaXNbaW5zZXJ0YmVmb3JlXVxuICAgICAgaWYoaW5zZXJ0YmVmb3JlKSB7XG4gICAgICAgIHRoaXMubm9kZS5pbnNlcnRCZWZvcmUodmFsLm5vZGUsIGluc2VydGJlZm9yZS5ub2RlIHx8IGluc2VydGJlZm9yZSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Nhbm5vdCBmaW5kIGluc2VydGJlZm9yZScpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcih2YWwpXG5cbiAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh2YWwubm9kZSlcbiAgICB9XG5cbiAgICB2YWwuc2V0dGluZygncGFyZW50JywgW3RoaXNdKSAvL2V4ZWN1dGUgcGFyZW50IHNldHRpbmdzXG4gICAgaWYgKHZhbC5uYW1lKSB0aGlzW3ZhbC5uYW1lXSA9IHZhbFxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL25lZWRzIGNsZWFuaW5nIGNvc3RzIDMlIG5vdy4uLlxuICAgIHRoaXMuY2hlY2tSZW5kZXIodmFsKVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZXR1cm4gdGhpc1xuICB9LFxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW5cbiAgICogQG1ldGhvZCBlbXB0eVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBpbnN0YW5jZXMgVHJ1ZSB3aWxsIHJlbW92ZSBhbGwgaW5zdGFuY2VzIG9mIGNoaWxkcmVuIHJlbW92ZWRcbiAgICovXG4gICdlbXB0eScsXG4gIGZ1bmN0aW9uKGluc3RhbmNlcykge1xuICAgIHZhciBjID0gdGhpcy5ub2RlLmNoaWxkTm9kZXNcbiAgICAgICwgaVxuICAgIHRoaXMubm9kZS5pbm5lckh0bWwgPSAnJ1xuICAgIGZvciAoaSA9IGMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGlmIChjW2ldLmJhc2UpIGNbaV0uYmFzZS5yZW1vdmUoaW5zdGFuY2VzKVxuICAgIH1cbiAgfSk7XG5cbmV4cG9ydHMuYmFzZS5hZGRTZXR0aW5nKCdwYXJlbnQnKVxuZXhwb3J0cy5iYXNlLmFkZFNldHRpbmcoJ3JlbmRlcicpXG5yZXF1aXJlKCcuL3NldCcpIiwidmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuL3V0aWwnKVxuXG5leHBvcnRzLnByZXBhcmUgPSBmdW5jdGlvbihlbCkge1xuICBpZighZWwuZGlzcGxheSkgZWwuZGlzcGxheSA9ICdibG9jaydcbn1cblxuZXhwb3J0cy5uZXdFbGVtZW50ID0gZnVuY3Rpb24oZGF0YSwgZWxlbWVudCwgdCkge1xuICB2YXIgYyA9IGNvbGxlY3Rpb24uY2hpbGRyZW4odClcbiAgZm9yKHZhciBpIGluIGMpIHtcbiAgICBpZihjW2ldLl9kICYmIGNbaV0uX2Q9PT1kYXRhKSB7XG4gICAgICBjW2ldLmRpc3BsYXkgPSBlbGVtZW50LmRpc3BsYXkudmFsXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuIFxuZXhwb3J0cy5yZW0gPSBmdW5jdGlvbiAoZWwsIHQsIGhhc0ZpbHRlciwgbm9SZXNvbHZlKSB7XG4gZWwuZGlzcGxheSA9ICdub25lJ1xuIHJldHVybiB0cnVlXG59XG5cbmV4cG9ydHMuZnJhZ21lbnQgPSBmdW5jdGlvbihhLGIsZXhjbHVkZSxpKSB7XG4gIC8vc2luY2UgaXQgbmV2ZXIgcmVtb3ZlcyBleGNsdWRlcyBzaG91bGQgbmV2ZXIgYmUgYXBwbGllZFxuICAvL2V4Y2x1ZGUgaXMgbm9ybWFsbHkgdXNlZCB0byBub3QgYWRkIHRoaW5ncyBhZ2FpbiBpZiB0aGV5IGFscmVhZHkgZXhpc3RcbiAgaWYoZXhjbHVkZSkgZXhjbHVkZVtpXT1udWxsXG59XG4iLCJcbnZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi91dGlsJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vLi4vdXRpbCcpXG5cbi8qKlxuICogY29sbGVjdGlvblxuICogbGlua3MgYXJyYXlzIG9yIG9iamVjdCB0byBlbGVtZW50c1xuICogdXNlIGZpbHRlciBpZiB5b3Ugd2FudCB0byBjb252ZXJ0XG4gKiBAYXR0cmlidXRlXG4gKi9cblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChcbiAgcmVxdWlyZSgnLi4vZGF0YScpLFxuICBmdW5jdGlvbihiYXNlKXtcblxuICAgIGJhc2UuZXh0ZW5kKHtcbiAgICAgIG5hbWU6J2NvbGxlY3Rpb24nLFxuICAgICAgLy8gcmVuZGVyOmZ1bmN0aW9uKCkge1xuICAgICAgLy8gICB0aGlzLnVwZGF0ZSgnY29sbGVjdGlvbicpIFxuICAgICAgLy8gfSxcbiAgICAgIHJlbW92ZTpmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5fY29sRWxlbSkgdGhpcy5fY29sRWxlbS5yZW1vdmUoKVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBjaGFuZ2UsIGFkZGVkKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5lcnJvcigneHh4eCFAIyEhQCMhIycsIHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEudG9TdHJpbmcoKSlcblxuICAgICAgICB2YWwuX3NraXAgPSB0cnVlXG5cbiAgICAgICAgdmFyIGhhc0ZpbHRlciA9IGNvbGxlY3Rpb24uZmlsdGVyKHZhbCwgdGhpcylcbiAgICAgICAgICAsIGRhdGEgPSB0aGlzLmZpbHRlciB8fCB2YWwudmFsXG4gICAgICAgICAgLCBvcHRpb25zID0gdGhpcy5fY29sT3B0aW9ucyB8fCB2YWwub3B0aW9ucyBcbiAgICAgICAgICAgICAgJiYgKHRoaXMuX2NvbE9wdGlvbnMgPSB2YWwub3B0aW9ucy5jb252ZXJ0KCkpXG4gICAgICAgICAgLCBvcmlnID0gIHZhbC5lbGVtZW50XG4gICAgICAgICAgLCBlbCA9IHRoaXMuX2NvbEVsZW0gXG4gICAgICAgICAgICAgIHx8IChvcmlnICYmIG9yaWcuX3ZhbCkgJiYgKHRoaXMuX2NvbEVsZW0gPSBuZXcgKG9yaWcuX3ZhbC5DbGFzcyB8fCBvcmlnLl92YWwpKCkpXG4gICAgICAgICAgLCBmaXJzdFJ1biA9ICF0aGlzLl9jb2xJbml0XG4gICAgICAgICAgLCBzbFN0YW1wXG4gICAgICAgICAgLCBlbFZhbFxuICAgICAgICAgICwgY29sRWxlbSA9IHRoaXMuX2NvbEVsZW1cblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCchISFPUFRJT05TIScsIG9wdGlvbnMpXG5cbiAgICAgICAgLy9kaXJ0eSBibG9jayEgY2xlYW4gaXQgRkFTVFxuXG4gICAgICAgIC8vIHx8ICF0aGlzLnJlbmRlcmVkIFxuXG4gICAgICAgIGlmKCEoZGF0YSAmJiBlbCkpIHJldHVybiAvL3x8IXRoaXMucmVuZGVyZWRcbiAgICAgICAgXG4gICAgICAgIHNsU3RhbXAgPSBvcmlnLl9zbFN0YW1wXG4gICAgICAgIGVsVmFsID0gb3JpZy5fdmFsXG5cbiAgICAgICAgaWYoc2xTdGFtcCkge1xuICAgICAgICAgIG9yaWcuX3NsU3RhbXAgPSBzdGFtcFxuICAgICAgICB9IGVsc2UgaWYoY29sRWxlbSAmJiBvcmlnLl9zbFN0YW1wICE9PSBzdGFtcCkge1xuICAgICAgICAgIGlmKCEoZWxWYWwuQ2xhc3MgJiYgKGNvbEVsZW0gaW5zdGFuY2VvZiBlbFZhbC5DbGFzcykpIFxuICAgICAgICAgICAgJiYgISghZWxWYWwuQ2xhc3MgJiYgKGNvbEVsZW0gaW5zdGFuY2VvZiBlbFZhbCkpKSB7XG4gICAgICAgICAgICBlbCA9IHRoaXMuX2NvbEVsZW0gPSBuZXcgKGVsVmFsLkNsYXNzIHx8IGVsVmFsKSgpXG4gICAgICAgICAgICBvcmlnLl9zbFN0YW1wID0gc3RhbXBcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ29vayBsZXVrIGZmIHVwZGF0ZScsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgY2hhbmdlLCBhZGRlZClcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygncGFzcyEnKVxuICAgICAgICAgIFxuICAgICAgICBpZihmaXJzdFJ1bikge1xuXG4gICAgICAgICAgb3B0aW9ucyAmJiBvcHRpb25zLnByZXBhcmUgJiYgb3B0aW9ucy5wcmVwYXJlKGVsKVxuXG4gICAgICAgICAgdGhpcy5fY29sSW5pdCA9IHRydWVcbiAgICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQoY29sbGVjdGlvbi5mcmFnbWVudCggZGF0YSwgZWwsIHRoaXMsIGZhbHNlLCBvcHRpb25zXG4gICAgICAgICAgICAsIGhhc0ZpbHRlciApKVxuXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZihmcm9tICYmIGZyb20uX3BhcmVudCA9PT0gZGF0YS5mcm9tKSB7XG4gICAgICAgICAgICBpZihyZW1vdmUpIHtcbiAgICAgICAgICAgICAgdmFyIHIgPSB1dGlsLmNoZWNrQXJyYXkoY29sbGVjdGlvbi5jaGlsZHJlbih0aGlzKSxmcm9tLCdfZCcsdHJ1ZSlcbiAgICAgICAgICAgICAgaWYocikge1xuICAgICAgICAgICAgICAgIGlmKCEob3B0aW9ucyAmJiBvcHRpb25zLnJlbSAmJiBvcHRpb25zLnJlbShyLCB0aGlzLCBoYXNGaWx0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgci5yZW1vdmUoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmKHV0aWwuY2hlY2tBcnJheShjb2xsZWN0aW9uLmNoaWxkcmVuKHRoaXMpLGZyb20sJ19kJyk9PT1mYWxzZSkge1xuXG4gICAgICAgICAgICAgIGNvbGxlY3Rpb24uZWxlbWVudCggZnJvbSwgZWwsIHRoaXMsIHRydWUsIHRoaXMubm9kZSwgb3B0aW9ucywgaGFzRmlsdGVyLCB0cnVlIClcbiAgICAgICAgICAgIH0gZWxzZSBpZihoYXNGaWx0ZXIgJiYgb3B0aW9ucyAmJiBvcHRpb25zLmluZGV4Q2hhbmdlKSB7XG5cbiAgICAgICAgICAgICAgICBvcHRpb25zLmluZGV4Q2hhbmdlKFxuICAgICAgICAgICAgICAgICAgdXRpbC5jaGVja0FycmF5KGNvbGxlY3Rpb24uY2hpbGRyZW4odGhpcyksZnJvbSwnX2QnLHRydWUpXG4gICAgICAgICAgICAgICAgICAsIHRoaXMsIGhhc0ZpbHRlciApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnMTIyWFhYWFgnLCBmcm9tLCBoYXNGaWx0ZXIsIGNvbGxlY3Rpb24uZmlsdGVyKHZhbCwgdGhpcykpIC8vdHJ5IHRvIGZpeCBvcmRlciBieSBuYW1lIGJldHRlclxuXG4gICAgICAgICAgICBpZighZnJvbSkge1xuXG4gICAgICAgICAgICAgIGlmKHJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uY2xlYXIodGhpcywgb3B0aW9ucylcbiAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHZhciBjID0gY29sbGVjdGlvbi5jaGlsZHJlbih0aGlzKVxuICAgICAgICAgICAgICAgICAgLCBleGNsdWRlID0ge31cbiAgICAgICAgICAgICAgICAgICwgbmFtZVxuICAgICAgICAgICAgICAgICAgLCBmRmllbGRcbiAgICAgICAgICAgICAgICAgICwga2V5c1xuICAgICAgICAgICAgICAgICAgLCBjaGlsZFxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1hYWFhYJyxoYXNGaWx0ZXIpIC8vdHJ5IHRvIGZpeCBvcmRlciBieSBuYW1lIGJldHRlclxuICAgICAgICAgICAgICAgIGlmKGhhc0ZpbHRlcj09PXRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGtleXMgPSBkYXRhLmtleXNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmb3IodmFyIGogaW4gYykge1xuICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjW2pdXG4gICAgICAgICAgICAgICAgICBuYW1lID0gY1tqXS5fZC5fbmFtZVxuXG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhjW2pdLCBoYXNGaWx0ZXIsIGtleXMsIHV0aWwuY2hlY2tBcnJheShkYXRhLGNoaWxkLl9kKSA9PT0gZmFsc2UpXG5cbiAgICAgICAgICAgICAgICAgIGlmKGhhc0ZpbHRlciAmJiAha2V5cyA/IHV0aWwuY2hlY2tBcnJheShkYXRhLGNoaWxkLl9kKSA9PT0gZmFsc2UgOiAhZGF0YVtuYW1lXSB8fCBkYXRhW25hbWVdIT09Y2hpbGQuX2QgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NIRUNLIS0tLScsailcblxuICAgICAgICAgICAgICAgICAgICBpZighKG9wdGlvbnMgJiYgb3B0aW9ucy5yZW0gJiYgb3B0aW9ucy5yZW0oY2hpbGQsIHRoaXMsIGhhc0ZpbHRlciwgaGFzRmlsdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5yZW1vdmUoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL3RoaXMgaXMgbW9yZSBlZmZpY2llbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYoZGF0YVtuYW1lXSE9PWNbal0uX2QpIGNbal0uZGF0YSA9IGRhdGFbbmFtZV0gXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVbbmFtZV09dHJ1ZVxuICAgICAgICAgICAgICAgICAgICBpZihoYXNGaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZihvcHRpb25zICYmIG9wdGlvbnMuaW5kZXhDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNoaWxkLl9kLl9pbmRleENhY2hlW2hhc0ZpbHRlcl1bMF0hPT1jaGlsZC5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5kZXhDaGFuZ2UoY2hpbGQsIHRoaXMsIGhhc0ZpbHRlciwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYoaGFzRmlsdGVyPT09dHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaiE9dXRpbC5jaGVja0FycmF5KGtleXMsbmFtZSx0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZXhjbHVkZVtuYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZighKG9wdGlvbnMgJiYgb3B0aW9ucy5yZW0gJiYgb3B0aW9ucy5yZW0oY1tqXSwgdGhpcywgaGFzRmlsdGVyLCBoYXNGaWx0ZXIpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKFxuICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5mcmFnbWVudChkYXRhLCBlbCwgdGhpcywgZXhjbHVkZSwgb3B0aW9ucywgaGFzRmlsdGVyKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcbn0pIiwidmFyIGVsZW1lbnQgPSByZXF1aXJlKCcuLi8nKVxuICAsIERhdGEgPSByZXF1aXJlKCcuLi8uLi8uLi8uLi9kYXRhJykuaW5qZWN0KHJlcXVpcmUoJy4uLy4uLy4uLy4uL2RhdGEvc2VsZWN0aW9uJykpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uLy4uL3V0aWwnKVxuXG52YXIgciA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gU3RyaW5nKH5+KE1hdGgucmFuZG9tKCkqOSkpKycnXG59XG5cbmV4cG9ydHMuZWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBlbGVtZW50LCB0LCB1cGRhdGUsIG5vZGUsIG9wdGlvbnMsIGhhc0ZpbHRlciwgcmVzb2x2ZSkge1xuICB2YXIgZWxlbVxuICBpZihvcHRpb25zICYmIG9wdGlvbnMubmV3RWxlbWVudCkge1xuICAgIGVsZW0gPSBvcHRpb25zLm5ld0VsZW1lbnQuYXBwbHkodGhpcyxhcmd1bWVudHMpXG4gICAgaWYoZWxlbT09PXRydWUpIHJldHVyblxuICB9XG4gIGVsZW0gPSBlbGVtIHx8IG5ldyBlbGVtZW50LkNsYXNzKClcbiAgXG4gIGVsZW0uX2NvbCA9IHRydWVcblxuLy8gICBjb25zb2xlLmxvZyggJy0tLS0+JywgZGF0YSApXG5cbiAgaWYgKGRhdGEgIT09IHZvaWQgMCkgZWxlbS5fZFNldChkYXRhKVxuICBpZiAobm9kZSkgbm9kZS5hcHBlbmRDaGlsZChlbGVtLm5vZGUpXG4gIGVsZW0uc2V0dGluZygncGFyZW50JywgW3RdKVxuICA7b3B0aW9ucyYmb3B0aW9ucy5lbGVtZW50JiZvcHRpb25zLmVsZW1lbnQoZWxlbSwgdCwgaGFzRmlsdGVyLCByZXNvbHZlKVxuICBpZiAodXBkYXRlICYmIGRhdGEgIT09IHZvaWQgMCkgZWxlbS51cGRhdGVEYXRhKClcbiAgdC5jaGVja1JlbmRlcihlbGVtLCB0cnVlKVxuICByZXR1cm4gZWxlbVxufVxuXG5leHBvcnRzLmZyYWdtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGVsZW1lbnQsIHQsIGV4Y2x1ZGUsIG9wdGlvbnMsIGhhc0ZpbHRlcikge1xuICB2YXIgZnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICAgICwgaXRlbSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgLy9pZiB5b3UgdXNlIHRoZSBwYXNzZWQgaSBpdCBpcyBhIGRpZmZlcmVudCB2YWx1ZSBmb3Igc2VsZWN0aW9uc1xuICAgICAgICBpZih0aGlzLl9uYW1lKSBpID0gdGhpcy5fbmFtZVxuICAgICAgICBpZighKG9wdGlvbnMmJm9wdGlvbnMuZnJhZ21lbnQmJm9wdGlvbnMuZnJhZ21lbnQodCx0aGlzLGV4Y2x1ZGUsaSkpXG4gICAgICAgICAgJiYgKCFleGNsdWRlIHx8ICFleGNsdWRlW2ldKSApIHtcbiAgICAgICAgICB2YXIgZWxlbSA9IGV4cG9ydHMuZWxlbWVudCggdGhpcyB8fCBudWxsLCBlbGVtZW50LCB0LCBmYWxzZSwgZnJhZywgb3B0aW9uc1xuICAgICAgICAgICAgICAsIGhhc0ZpbHRlcilcbiAgICAgICAgICBpZihlbGVtKSBmcmFnLmFwcGVuZENoaWxkKCBlbGVtLm5vZGUgKVxuICAgICAgICAgIGVsZW0udXBkYXRlRGF0YSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgZnJhZy5fcCA9IHRcblxuICBpZihkYXRhLmVhY2gpIHtcbiAgICBkYXRhLmVhY2goaXRlbSlcbiAgfSBlbHNlIHtcbiAgICAvL25vcm1hbCBkYXRhXG4gICAgZm9yKHZhciBpIGluIGRhdGEpIHtcbiAgICAgIGl0ZW0uY2FsbCggZGF0YVtpXSAsaSApXG4gICAgfVxuICB9XG5cbiAgLy8gZWxlbWVudC51cGRhdGVEYXRhKHRydWUpXG4gIHJldHVybiBmcmFnXG59XG5cbmV4cG9ydHMuY2hpbGRyZW4gPSBmdW5jdGlvbiAodCwgb3B0aW9ucykge1xuICBpZighdCkgcmV0dXJuXG4gIHZhciBjaCA9IFtdXG4gIGZvcih2YXIgaSBpbiB0Lm5vZGUuY2hpbGROb2Rlcykge1xuICAgIHZhciBjaGlsZCA9IHQubm9kZS5jaGlsZE5vZGVzW2ldLmJhc2VcbiAgICBpZihjaGlsZCAmJiBjaGlsZC5fY29sKSB7XG4gICAgICBjaC5wdXNoKGNoaWxkKVxuICAgIH1cbiAgfVxuICA7b3B0aW9ucyYmb3B0aW9ucy5jaGlsZHJlbiYmb3B0aW9ucy5jaGlsZHJlbihjaClcbiAgcmV0dXJuIGNoXG59XG5cbmV4cG9ydHMuY2xlYXIgPSBmdW5jdGlvbiAodCwgb3B0aW9ucykge1xuICB0LmNvbEluaXQgPSBudWxsXG4gIHZhciBjID0gZXhwb3J0cy5jaGlsZHJlbih0KVxuICBmb3IodmFyIGkgaW4gYykgeyBjW2ldLnJlbW92ZSgpIH1cbiAgO29wdGlvbnMmJm9wdGlvbnMuY2xlYXImJm9wdGlvbnMuY2xlYXIodClcbn1cblxuZXhwb3J0cy5maWx0ZXIgPSBmdW5jdGlvbiAodmFsLHQpIHtcblxuXG4gIHZhciBkYXRhID0gdmFsLnZhbFxuXG5cbiAgLy8gY29uc29sZS5sb2coJ0RPIEkgSEFWRSBGVUxURVIhPj8nLGRhdGEsICB2YWwsIHQpXG5cblxuICBpZih2YWwuZmlsdGVyICYmIHZhbC5maWx0ZXIudmFsPT09dHJ1ZSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdzb3J0IGJ5IG5hbWUnKSBtb2V0IGJldGVyXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdnb3QgaXQhREFUQXghJylcblxuICAgIHJldHVybiB0cnVlXG4gICAgLy9kaWZmZXJlbnQgdmliZXNcbiAgfVxuXG4gIGlmIChkYXRhICYmIHZhbC5maWx0ZXIgJiYgIXQuZmlsdGVyKSB7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnTUFLRSBORVcgU1RZVUZGRicpXG5cbiAgICB2YXIgYSA9IHZhbC5maWx0ZXIucmF3XG4gICAgLy9kaXQgaXMga2Fwb3RcbiAgICBkYXRhID0gdC5maWx0ZXIgPSBuZXcgRGF0YShkYXRhLCBhKVxuXG4gICAgLy8gY29uc29sZS5sb2coJ0ZJTFRFUlNTU1MhJywgYSwgdClcbiAgICAvLyBkZWJ1Z2dlclxuXG4gICAgYS5fY29sID0gdHJ1ZVxuICAgIFxuICAgIGRhdGEuYWRkTGlzdGVuZXIoZnVuY3Rpb24gKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSkge1xuICAgICAgdC5jb2xsZWN0aW9uLl91cGRhdGUodmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlKVxuICAgIH0pXG4gICAgXG4gICAgdC5zZXRTZXR0aW5nKHtcbiAgICAgIC8vIG5hbWU6ICdjb2xsZWNpdG9uZmlsdGVyJyxcbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0LmZpbHRlci5yZW1vdmUoKVxuICAgICAgICB0LmZpbHRlciA9IG51bGxcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gY29uc29sZS5sb2coJ0RBVEF4IScpXG4gICAgcmV0dXJuIGRhdGEuX3VpZFxuICAgIC8vIHJldHVybiB0LmZpbHRlci5fdWlkLy9kYXRhIGlzIGZpbHRlclxuICB9IGVsc2UgaWYoZGF0YSAmJiBkYXRhLl9maWx0ZXIpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0R4eHhBVEF4IScpXG5cbiAgICByZXR1cm4gZGF0YS5fdWlkXG4gIH0gXG4gIGVsc2UgaWYodC5maWx0ZXIpIHtcblxuICAgIHJldHVybiB0LmZpbHRlci5fdWlkXG4gIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdOTyBEQVRBWCEgRklMVEVSJywgdClcblxufVxuXG4vLyBleHBvcnRzLmluZGV4Q2hhbmdlID0gZnVuY3Rpb24oZWwsIHQsIGhhc0ZpbHRlciwgbm9SZXNvbHZlKSB7XG4vLyB2YXIgb2xkSW5kZXggPSBlbC5fZC5faW5kZXhDYWNoZVtoYXNGaWx0ZXJdWzFdXG4vLyAgICAgLCBuZXdJbmRleCA9IGVsLl9kLl9pbmRleENhY2hlW2hhc0ZpbHRlcl1bMF1cbi8vICAgICAsIGNoID0gIW5vUmVzb2x2ZSAmJiBjb2xsZWN0aW9uLmNoaWxkcmVuKHQsZXhwb3J0cylcbi8vICAgICAsIGxcblxuXG4vLyAgIGV4cG9ydHMueHkoZWwpXG5cbi8vICAgaWYobm9SZXNvbHZlKSByZXR1cm5cblxuLy8gICBsID0gY2gubGVuZ3RoXG4gIFxuICBcbi8vICAgdmFyIGNsb25lID0gZWwubm9kZS5jbG9uZU5vZGUodHJ1ZSlcbi8vICAgdC5ub2RlLnJlbW92ZUNoaWxkKGVsKVxuLy8gICBlbC5fbm9kZSA9IGNsb25lXG5cblxuICAgXG4vLyAgIC8vIHQuaCA9IHQubm9kZS5zY3JvbGxIZWlnaHRcbi8vIH0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZGF0YSA9IHJlcXVpcmUoJy4uLy4uLy4uL2RhdGEvYmFzZScpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKVxuICAsIGZsYWdzID0gcmVxdWlyZSgnLi4vLi4vLi4vdmFsdWUvZmxhZ3MnKVxuXG4vKipcbiAgKiBleHRlbmRzIHVwZGF0ZURhdGEgdG8gdGFrZSBjaGlsZE5vZGVzIGludG8gYWNjb3VudFxuICAqIG1heSBuZWVkIHRvIGFkZCBleHRyYSBhcmd1bWVudCBmb3IgZ28gZGVlcFxuICAqIEBtZXRob2RcbiovXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKFsgZGF0YSwge1xuICB1cGRhdGVEYXRhOiBmdW5jdGlvbiAoIGluc3RhbmNlcywgZGF0YSwgZm1vZGVsICkge1xuXG4gICAgLy8gaWYoIGluc3RhbmNlcyApIGNvbnNvbGUuZXJyb3IoJz8/Pz8tLS0tLS0tLS0tLT4+Pj4+JylcblxuICAgIGlmICh0aGlzLl9kKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmVkID0gZmFsc2VcbiAgICAgIGRhdGEgPSB0aGlzLl9kXG4gICAgfVxuXG4gICAgdmFyIGZmbW9kZWwgPSBmYWxzZVxuICAgIHZhciBwYXJzZWQgPSBmYWxzZVxuICAgIGlmICghZm1vZGVsICYmICF0aGlzLm1vZGVsICYmICF0aGlzLl9mbW9kZWwpIGZmbW9kZWwgPSB0cnVlXG4gICAgLy9mbW9kZWwgaXMgZmlyc3QgbW9kZWxcbiAgICBmb3IgKHZhciBjaGlsZHJlbiA9IHRoaXMubm9kZS5jaGlsZE5vZGVzXG4gICAgICAsIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxXG4gICAgICAsIGJhc2U7IGkgPj0gMDsgaS0tKSB7XG5cbiAgICAgIGJhc2UgPSBjaGlsZHJlbltpXS5iYXNlXG4gICAgICBcbiAgICAgIC8vIGlmKGJhc2UgJiYgYmFzZS5tb2RlbCAmJiBiYXNlLm1vZGVsLmZpZWxkICYmIGJhc2UubW9kZWxQYXJzZWQgIT09IGJhc2UubW9kZWwuZmllbGQudmFsICYmIGJhc2UuaW5zdGFuY2VzICYmIGluc3RhbmNlcykge1xuICAgICAgLy8gICAvLyBjb25zb2xlLmVycm9yKCcxJywgYmFzZSAmJiBiYXNlLm5hbWUsIGJhc2UuaW5zdGFuY2VzKVxuICAgICAgLy8gICAgICAgaWYoIWRhdGEgJiYgaW5zdGFuY2VzKSB7XG4gICAgICAvLyAgICAgICAgIGlmKCFkYXRhKSB7XG4gICAgICAvLyAgICAgICAgICAgZGF0YSA9IGJhc2UuY2hlY2tQYXJlbnQoJ19kJyx0cnVlKSB8fCB0aGlzLmNoZWNrUGFyZW50KCdfZCcsdHJ1ZSlcbiAgICAgIC8vICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnaGV5IGhleSBoZXknLCBkYXRhLCB0aGlzLl9kLCBiYXNlLl9kLCBiYXNlKVxuICAgICAgLy8gICAgICAgICB9XG4gICAgICAvLyAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2xlenpnbyBpbnN0YW5jZXMnLCBkYXRhKVxuICAgICAgLy8gICAgICAgICAvLyBiYXNlLl9kID0gZGF0YSA9IGRhdGEuZ2V0KHRoaXMubW9kZWwuZmllbGQudmFsKSAvL3V0aWwucGF0aChkYXRhLHRoaXMubW9kZWwuZmllbGQudmFsLnNwbGl0KCcuJykpXG4gICAgICAvLyAgICAgICAgIGZvcih2YXIgaSBpbiBiYXNlLmluc3RhbmNlcykge1xuICAgICAgLy8gICAgICAgICAgIGlmKCFiYXNlLmluc3RhbmNlc1tpXS5tb2RlbC5wYXJzZWQpIHtcbiAgICAgIC8vICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJz8nLGJhc2UuaW5zdGFuY2VzW2ldLm1vZGVsLnBhcnNlZClcbiAgICAgIC8vICAgICAgICAgICAgIGJhc2UuaW5zdGFuY2VzW2ldLnVwZGF0ZURhdGEoZmFsc2UsIGRhdGEpXG4gICAgICAvLyAgICAgICAgICAgfVxuICAgICAgLy8gICAgICAgICB9XG4gICAgICAvLyAgICAgICAgIC8vIGJhc2UubW9kZWxQYXJzZWQgPSBcbiAgICAgIC8vICAgICAgICAgLy8gYmFzZS5tb2RlbCA9IHt9XG4gICAgICAvLyAgICAgICAgIC8vIGJhc2UubW9kZWwucGFyc2VkID0gYmFzZS5tb2RlbC5maWVsZC52YWwgXG4gICAgICAvLyAgICAgICAgIC8vIHJldHVyblxuICAgICAgLy8gICAgICAgfVxuICAgICAgLy8gfVxuXG4gICAgICAvLyBpZihiYXNlICYmIGJhc2UubW9kZWwgJiYgYmFzZS5tb2RlbC5maWVsZCAmJiAhYmFzZS5fZCkge1xuICAgICAgICAvLyBiYXNlLl9kU2V0KGRhdGEsIHRydWUpXG4gICAgICAvLyB9XG5cbiAgICAgIGlmIChiYXNlXG4gICAgICAmJiAoIShiYXNlLm1vZGVsICYmIGJhc2UubW9kZWwuaW5oZXJpdCAmJiBiYXNlLm1vZGVsLmluaGVyaXQudmFsPT09ZmFsc2UpKVxuICAgICAgJiYgKGJhc2UuX2QgPT09IHZvaWQgMCB8fCBiYXNlLl9kZnJvbSB8fCAoYmFzZS5tb2RlbCAmJiBiYXNlLm1vZGVsLmZpZWxkKSApKSB7XG4gICAgICAgIHZhciB0ZGF0YSA9IGRhdGFcblxuICAgICAgICBpZiAoYmFzZS5tb2RlbCAmJiAoZGF0YSB8fCBiYXNlLm1vZGVsICYmIGJhc2UubW9kZWwuZmllbGQpKSB7XG4gICAgICAgICAgaWYgKGZmbW9kZWwpIGJhc2UuX2Ztb2RlbCA9IHRydWVcblxuICAgICAgICAgIC8vaGllciBvb2sgZmYgbW9kZWwgcGFyc2VuIVxuICAgICAgICAgIGlmKGJhc2UubW9kZWwgJiYgYmFzZS5tb2RlbC5maWVsZCkge1xuICAgICAgICAgICAgdGRhdGEgPSBkYXRhLmdldChiYXNlLm1vZGVsLmZpZWxkLnZhbClcbiAgICAgICAgICAgIGJhc2UubW9kZWxQYXJzZWQgPSBiYXNlLm1vZGVsLmZpZWxkLnZhbFxuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcih0ZGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKHRkYXRhLl9jYWNoZWRQYXRoKVxuXG4gICAgICAgICAgYmFzZS5fZFNldCh0ZGF0YSwgdHJ1ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2UudXBkYXRlRGF0YShmYWxzZSwgdGRhdGEsIGJhc2UuX2Ztb2RlbCB8fCBmbW9kZWwpXG4gICAgICB9XG4gICAgfVxuICB9XG59XSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbiAgLypcbiAgICBoZXJlIHNvbWUgYmFzaWMgaHRtbCBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBWLkVsZW1lbnQuTmVzc2VjYXJ5XG4gICAgZm9yIHZhbHVlcyB0aGF0IHlvdSB3YW50IHRvIGJlIGFibGUgdG8gYmluZCB0byBWLk9iamVjdHNcbiAgICBVc2VzIGJhc2UuZXh0ZW5kIC0tIHNlZSBjb3JlLmJhc2UgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiAgKi9cblxudmFyIHVhID0gcmVxdWlyZSgnLi4vLi4vdWEnKVxudmFyIGNzcyA9IHJlcXVpcmUoJy4uLy4uL2NzcycpXG52YXIgVmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi92YWx1ZScpXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKVxudmFyIGhhc2ggPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL2hhc2gnKVxudmFyIHJhZiA9IHJlcXVpcmUoJy4uLy4uL2FuaW1hdGlvbi9yYWYnKVxudmFyIF9sb2FkID0gcmVxdWlyZSgnLi4vJykuaW1hZ2VzID0ge31cbnZhciBfdHJhbnNmb3JtID0gdWEucHJlZml4ICsgJ1RyYW5zZm9ybSdcbnZhciBfY3NzVHJhbnNmb3JtID0gdWEucHJlZml4ICsgJy10cmFuc2Zvcm0nXG52YXIgcG9zdHBvbmUgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG52YXIgYm9keSA9IGRvY3VtZW50LmJvZHkuc3R5bGVcbiAgICAvL3RoaW5rIGFib3V0IGRvYyByZWFkeSBldmVudCBvciBmYWxsYmFjayBpZiBubyBib2R5XG52YXIgX3RyYW5zbGF0ZSA9IGJvZHkucGVyc3BlY3RpdmVQcm9wZXJ0eSAhPSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgfHwgYm9keS5XZWJraXRQZXJzcGVjdGl2ZSAhPSB2b2lkIDBcbiAgICAgICAgICAgICAgICAgICAgPyBbJ3RyYW5zbGF0ZTNkKCcsICcsMHB4KSddXG4gICAgICAgICAgICAgICAgICAgIDogWyd0cmFuc2xhdGUoJywgJyknXVxudmFyIF9jb29yZGluYXRlID0gZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHZhciBtYXJnaW4gPSAnbWFyZ2luJyArIChzdHlsZVswXS50b1VwcGVyQ2FzZSgpICsgc3R5bGUuc2xpY2UoMSkpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZih2YWwuY2xlYW4pIHtcbiAgICAgICAgICBfY2xlYW5Db29yZGluYXRlLmNhbGwodGhpcyxzdHlsZSxtYXJnaW4pXG4gICAgICAgICAgdmFsLmNsZWFuID0gbnVsbFxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwudHJhbnNsYXRlKSB7XG4gICAgICAgICAgdGhpcy50cmFuc2xhdGUodmFsKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubm9kZS5zdHlsZVt0aGlzLnJlbGF0aXZlID8gbWFyZ2luIDogc3R5bGVdID0gdmFsLnZhbCArICdweCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbnZhciBfY2xlYXJUcmFuc2Zvcm0gPSBuZXcgUmVnRXhwKF9jc3NUcmFuc2Zvcm0rJyguKj8pOycpXG52YXIgX2NsZWFyID1cbiAgICB7IHg6IC8obWFyZ2luLWxlZnQoLio/KTspfChsZWZ0KC4qPyk7KS9nXG4gICAgLCB5OiAvKG1hcmdpbi10b3AoLio/KTspfCh0b3AoLio/KTspL2dcbiAgICB9XG52YXIgX2NsZWFuQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uKCBjaGVjayApIHtcbiAgICAgIHZhciB0ID0gdGhpcy5fdFxuICAgICAgLCBrZWVwID0gZmFsc2VcbiAgICAgICwgdmFsID0gdGhpc1tjaGVja11cbiAgICAgICwgY3NzVGV4dCA9IHRoaXMubm9kZS5zdHlsZS5jc3NUZXh0LnJlcGxhY2UoIF9jbGVhcltjaGVja10sICcnIClcblxuICAgIGlmKCB2YWwgJiYgdmFsLnRyYW5zbGF0ZSAmJiB2YWwudHJhbnNsYXRlLnZhbD09PWZhbHNlKSB2YWwudHJhbnNsYXRlID0gbnVsbFxuXG4gICAgaWYodGhpcy5ub2RlLnN0eWxlW190cmFuc2Zvcm1dICYmICF2YWwudHJhbnNsYXRlKSB7XG4gICAgICBpZih0KSB7XG4gICAgICAgIGlmKCF0aGlzW2NoZWNrXS50cmFuc2xhdGUpIHtcbiAgICAgICAgICBmb3IodmFyIGkgPSAyIDsgaSA8IDYgOyBpKyspIHtcbiAgICAgICAgICAgIGlmKHRbaV0pa2VlcD10cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGtlZXA9dHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZigha2VlcCkgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShfY2xlYXJUcmFuc2Zvcm0sJycpXG4gICAgfVxuICAgIHRoaXMubm9kZS5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dFxuICB9XG5cbnZhciBzZXRUaW1lcnMsIHJlbW92ZVRpbWVycywgX3NldFRpbWVvdXRcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbihiYXNlKSB7XG4gIHV0aWwuZGVmaW5lKGJhc2UuQ2xhc3MsXG4gICAgJ2NsZWFuQ29vcmRpbmF0ZXMnLCBmdW5jdGlvbihjb29yZCkge1xuICAgICAgIGlmKHRoaXMuX25vZGUpIHtcbiAgICAgICAgaWYoIWNvb3JkKSB7XG4gICAgICAgICAgX2NsZWFuQ29vcmRpbmF0ZS5jYWxsKHRoaXMsJ3gnKVxuICAgICAgICAgIF9jbGVhbkNvb3JkaW5hdGUuY2FsbCh0aGlzLCd5JylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfY2xlYW5Db29yZGluYXRlLmNhbGwodGhpcyxjb29yZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgJ3RyYW5zbGF0ZScsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBfeFxuICAgICAgLCBfeVxuICAgICAgLCBfdmFsID0gIHZhbC52YWxcbiAgICAgICwgX3NjYWxlXG4gICAgICAsIF9yb3RhdGVcbiAgICAgICwgX3JvdGF0ZVlcbiAgICAgICwgX3JvdGF0ZVhcbiAgICAgICwgX3N0ciA9ICcnXG4gICAgICAsIF9uYW1lID0gdmFsICYmIHZhbC5fcHJvcC5uYW1lXG4gICAgICAsIF90ID0gdGhpcy5fdCA9IHRoaXMuX3QgfHwgW11cbiAgICAgICwgbm9wZSA9IGZhbHNlXG5cbiAgICAvL2NpcnRpY2FsIHBlcmZvcm1hbmNlIHBvaW50IGhlbmNlIHVzZSBvZiB8IDBcbiAgICBpZiAoX25hbWUgPT09ICd4Jykge1xuICAgICAgX3ggPSBfdmFsIHwgMFxuICAgICAgaWYgKF94ID09PSBfdFswXSkgbm9wZSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKF9uYW1lID09PSAneScpIHtcbiAgICAgIF95ID0gX3ZhbCB8IDBcbiAgICAgIGlmIChfeSA9PT0gX3RbMV0pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3JvdGF0ZScpIHtcbiAgICAgIF9yb3RhdGUgPSBfdmFsXG4gICAgICBpZiAoX3JvdGF0ZSA9PT0gX3RbMl0pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3NjYWxlJykge1xuICAgICAgX3NjYWxlID0gX3ZhbFxuICAgICAgaWYgKF9zY2FsZSA9PT0gX3RbM10pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3JvdGF0ZVknKSB7XG4gICAgICBfcm90YXRlWSA9IF92YWxcbiAgICAgIGlmIChfcm90YXRlWSA9PT0gX3RbNF0pIG5vcGUgPSB0cnVlXG4gICAgfSBlbHNlIGlmIChfbmFtZSA9PT0gJ3JvdGF0ZVgnKSB7XG4gICAgICBfcm90YXRlWCA9IF92YWxcbiAgICAgIGlmIChfcm90YXRlWCA9PT0gX3RbNF0pIG5vcGUgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCFub3BlKSB7XG4gICAgICBfdFswXSA9ICBfeCB8fCAodGhpcy54LnRyYW5zbGF0ZSAmJiB0aGlzLngudmFsIHwgMCkgfHwgMFxuICAgICAgX3RbMV0gPSAgX3kgfHwgKHRoaXMueS50cmFuc2xhdGUgJiYgdGhpcy55LnZhbCB8IDApIHx8IDBcbiAgICAgIF90WzJdID0gX3JvdGF0ZSB8fCB0aGlzLnJvdGF0ZS52YWxcbiAgICAgIF90WzNdID0gX3NjYWxlIHx8IHRoaXMuc2NhbGUudmFsXG4gICAgICBfdFs0XSA9IF9yb3RhdGVZIHx8IHRoaXMucm90YXRlWS52YWxcbiAgICAgIF90WzVdID0gX3JvdGF0ZVggfHwgdGhpcy5yb3RhdGVYLnZhbFxuICAgICAgaWYgKF90WzBdIHx8IF90WzFdKSB7XG4gICAgICAgIF9zdHIgPSBfc3RyXG4gICAgICAgICAgLmNvbmNhdChcbiAgICAgICAgICAgIF90cmFuc2xhdGVbMF1cbiAgICAgICAgICArIF90WzBdICsgJ3B4LCdcbiAgICAgICAgICArIF90WzFdICsgJ3B4J1xuICAgICAgICAgICsgX3RyYW5zbGF0ZVsxXVxuICAgICAgICAgIClcbiAgICAgIH1cbiAgICAgIGlmIChfdFsyXSkgeyBfc3RyID0gX3N0ci5jb25jYXQoJyByb3RhdGUoJyArIF90WzJdICsgJ2RlZyknKSB9XG4gICAgICBpZiAoX3RbM10pIHsgX3N0ciA9IF9zdHIuY29uY2F0KCcgc2NhbGUoJyArIF90WzNdICsgJyknKSB9XG4gICAgICBpZiAoX3RbNF0pIHsgX3N0ciA9IF9zdHIuY29uY2F0KCcgcm90YXRlWSgnICsgX3RbNF0gKyAnZGVnKScpIH1cbiAgICAgIGlmIChfdFs1XSkgeyBfc3RyID0gX3N0ci5jb25jYXQoJyByb3RhdGVYKCcgKyBfdFs1XSArICdkZWcpJykgfVxuICAgICAgdGhpcy5ub2RlLnN0eWxlW190cmFuc2Zvcm1dID0gX3N0clxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9LCAndXBkYXRlJywgZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIF9hcmdzID0gdXRpbC5hcmcoYXJndW1lbnRzKSwgbCA9IF9hcmdzLmxlbmd0aCwgcDsgaSA8IGw7IGkrKyApIHtcbiAgICAgIGlmIChfYXJnc1tpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHRoaXMudXBkYXRlLmFwcGx5KHRoaXMsIF9hcmdzW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHAgPSB1dGlsLmdldCh0aGlzLCBfYXJnc1tpXSk7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgcC51cGRhdGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIHZhciBkb25lID0gcG9zdHBvbmUoZnVuY3Rpb24odmFsLHNlbGYsc2Rpcil7XG4gICAgaWYoc2VsZil7XG4gICAgICBpZih2YWwuX2xpc3RlbmVycyAhPT0gdm9pZCAwKSB2YWwudmFsID0gc2VsZi5ub2RlW3NkaXJdXG4gICAgICBlbHNlIHNlbGZbc2Rpcl0uX19sdmFsID0gdm9pZCAwXG4gICAgfVxuICB9LDIwKVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNjcm9sbChkaXIpe1xuICAgIHZhciBzID0gJ3Njcm9sbCdcbiAgICAgICwgc2RpciA9IHMgKyBkaXIgLy9zY3JvbGxMZWZ0IG9yIHNjcm9sbFRvcFxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6c2RpcixcbiAgICAgIHNldDpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHYgPSB2YWwudmFsXG4gICAgICAgICAgLCBzZWxmID0gdGhpc1xuICAgICAgICBpZih2ICE9PSB2b2lkIDApIHNlbGYubm9kZVtzZGlyXSA9IHZcbiAgICAgICAgaWYoIXNlbGYuX19zVCl7XG4gICAgICAgICAgc2VsZi5fX3NUID0gdHJ1ZVxuICAgICAgICAgIHNlbGYuYWRkRXZlbnQocyxmdW5jdGlvbigpe1xuICAgICAgICAgICAgZG9uZSh2YWwsc2VsZixzZGlyKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgfSxcbiAgICAgIGdldDpmdW5jdGlvbih2YWwpe1xuICAgICAgICBpZih2YWwuX19sdmFsID09PSB2b2lkIDApIHZhbC52YWwgPSB0aGlzLm5vZGVbc2Rpcl1cbiAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgfSxcbiAgICAgIHJlbmRlcjpmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzXG4gICAgICAgICAgLCB2YWwgPSBzZWxmW3NkaXJdLl9fbHZhbFxuICAgICAgICBpZih2YWwpe1xuICAgICAgICAgIHJhZihmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5ub2RlW3NkaXJdID0gdmFsXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgYmFzZS5leHRlbmQoe1xuICAgIG5hbWU6ICdyZWxhdGl2ZScsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gdGhpcy5wb3NpdGlvbiAhPT0gZmFsc2UgPyB0aGlzLnBvc2l0aW9uLnZhbCA6ICh0aGlzLnBvc2l0aW9uID0ge1xuICAgICAgICBjc3M6IHRydWUsXG4gICAgICAgIHZhbDogY3NzKHRoaXMuY3NzLnZhbCwgJ3Bvc2l0aW9uJylcbiAgICAgIH0pXG4gICAgICByZXR1cm4gcyAhPT0gJ2Fic29sdXRlJ1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6IGZhbHNlLFxuICAgIG5hbWU6ICdyZW5kZXJlZCcsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXQgPSB0aGlzLl9yZW5kZXJlZCB8fCAodGhpcy5ub2RlID09PSBkb2N1bWVudC5ib2R5KSxcbiAgICAgICAgcGFyZW50O1xuICAgICAgaWYgKCFyZXQpIHtcbiAgICAgICAgcGFyZW50ID0gdGhpcy5ub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIHdoaWxlICghcmV0ICYmIHBhcmVudCkge1xuICAgICAgICAgIGlmIChwYXJlbnQuYmFzZSAmJiBwYXJlbnQuX3JlbmRlcmVkKSB7XG4gICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyZW50ID09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICB0aGlzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LFxuICBjcmVhdGVTY3JvbGwoJ0xlZnQnKSxcbiAgY3JlYXRlU2Nyb2xsKCdUb3AnKSxcbiAge1xuICAgIHBvc2l0aW9uOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/PycsdmFsLmNzcy52YWwpXG4gICAgICAvLyBpZiAoIXZhbC5jc3MpIHsgLy9jaGVjayB3aGVuIGlnbm9yaW5nIHRoaXMgYmVjb21lcyBhIHByb2JsZW1cbiAgICAgICAgdGhpcy5ub2RlLnN0eWxlLnBvc2l0aW9uID0gdmFsLnZhbDtcbiAgICAgIC8vIH1cbiAgICB9LFxuICAgIC8vIHNjcm9sbFRvcDpmdW5jdGlvbih2YWwpIHtcbiAgICAvLyAgIGNvbnNvbGUuZXJyb3IodmFsLnZhbClcbiAgICAvLyAgIHRoaXMubm9kZS5zY3JvbGxUb3AgPSB2YWwudmFsXG4gICAgLy8gfSxcbiAgICByb3RhdGU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUodmFsKTtcbiAgICB9LFxuICAgIHJvdGF0ZVk6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUodmFsKTtcbiAgICB9LFxuICAgIHJvdGF0ZVg6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdGhpcy50cmFuc2xhdGUodmFsKTtcbiAgICB9LFxuICAgIHNjYWxlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMudHJhbnNsYXRlKHZhbCk7XG4gICAgfSxcbiAgICBzcmM6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHYgPSB2YWwudmFsO1xuICAgICAgaWYgKHYgJiYgdlt2Lmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgdGhpcy5ub2RlLnNyYyA9IHY7XG4gICAgICB9XG4gICAgfSxcbiAgICBhdHRyOmZ1bmN0aW9uKHZhbCkge1xuICAgICAgdmFyIHQgPSB0aGlzXG4gICAgICB2YWwuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIHQubm9kZS5zZXRBdHRyaWJ1dGUoaSx0aGlzLnZhbClcbiAgICAgIH0pXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kUG9zOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5iYWNrZ3JvdW5kUG9zaXRpb24gPSB2YWwudmFsXG4gICAgfSxcbiAgICBiYWNrZ3JvdW5kQmF0Y2g6IGZ1bmN0aW9uKHZhbCkge1xuXG5cbiAgICB9LFxuICAgIGJhY2tncm91bmQ6IGZ1bmN0aW9uKHZhbCkgeyAvL29wdGlvbmFsIG1heWJlIGluIGEgc2VwZXJhdGUgbW9kdWxlXG4gICAgICB2YXIgdiA9IHZhbC52YWxcbiAgICAgICAgLCB0ID0gdGhpc1xuICAgICAgICAsIHN0eWxlID0gdGhpcy5ub2RlLnN0eWxlXG4gICAgICAgICwgdXJsXG4gICAgICAgICwgaGFzaGVkXG4gICAgICAgICwgcGFyZW50QmF0Y2hcbiAgICAgICAgLCBiYXRjaFxuXG4gICAgICBpZih2YWwuZ29uZSAmJiB2YWwuZ29uZS52YWwpIHtcbiAgICAgICAgdmFsLl9za2lwID0gdHJ1ZVxuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSAnJ1xuICAgICAgfSBlbHNlIGlmICh2ICYmIHZbdi5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgICAgIHVybCA9ICd1cmwoJyArIHYgKyAnKSdcbiAgICAgICAgaWYoc3R5bGUuYmFja2dyb3VuZEltYWdlPT09dXJsKSByZXR1cm5cblxuICAgICAgICAvL1ZhbHVlXG4gICAgICAgIGlmICh2YWwuc2l6ZSkgc3R5bGUuYmFja2dyb3VuZFNpemUgPSB2YWwuc2l6ZS52YWxcblxuICAgICAgICBpZiAodmFsLmxvYWQpIHtcblxuICAgICAgICAgIGhhc2hlZCA9IGhhc2godilcbiAgICAgICAgICBwYXJlbnRCYXRjaCA9IHRoaXMuY2hlY2tQYXJlbnQoJ2JhY2tncm91bmRCYXRjaCcpXG4gICAgICAgICAgaWYocGFyZW50QmF0Y2gpIGJhdGNoID0gcGFyZW50QmF0Y2guYmFja2dyb3VuZEJhdGNoXG5cbiAgICAgICAgICBpZighX2xvYWRbaGFzaGVkXSkge1xuICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gbnVsbFxuICAgICAgICAgICAgLy9hbHNvIHJlbW92ZSBzZXR0aW5nXG5cbiAgICAgICAgICAgIGlmKGJhdGNoKSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShiYXRjaC5fcmFmKVxuICAgICAgICAgICAgICBpZighYmF0Y2guYmF0Y2gpIGJhdGNoLmJhdGNoID0gW11cbiAgICAgICAgICAgICAgYmF0Y2guYmF0Y2gucHVzaChoYXNoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfbG9hZFtoYXNoZWRdPW5ldyBWYWx1ZShmYWxzZSlcbiAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKVxuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgaWYoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgIGJhdGNoLmJhdGNoLnNwbGljZSh1dGlsLmNoZWNrQXJyYXkoYmF0Y2guYmF0Y2gsaGFzaGVkKSwxKVxuICAgICAgICAgICAgICAgaWYoYmF0Y2guYmF0Y2gubGVuZ3RoPT09MCkge1xuICAgICAgICAgICAgICAgIGJhdGNoLmJhdGNoID0gbnVsbFxuICAgICAgICAgICAgICAgIGJhdGNoLl9yYWYgPSByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZihwYXJlbnRCYXRjaC5fbm9kZSkgYmF0Y2guX3ZhbC5jYWxsKHBhcmVudEJhdGNoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9sb2FkW2hhc2hlZF0udmFsID0gdHJ1ZVxuICAgICAgICAgICAgICBpbWcub25sb2FkID0gbnVsbFxuICAgICAgICAgICAgICBpbWcgPSBudWxsXG4gICAgICAgICAgICAgIF9sb2FkW2hhc2hlZF0ucmVtb3ZlKGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLGZhbHNlLHRydWUpXG4gICAgICAgICAgICAgIF9sb2FkW2hhc2hlZF0gPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWcuc3JjID0gdlxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKF9sb2FkW2hhc2hlZF0hPT10cnVlKSB7XG4gICAgICAgICAgICAgdGhpcy5fbG9hZGVkID0gbnVsbFxuXG4gICAgICAgICAgICBfbG9hZFtoYXNoZWRdLmFkZExpc3RlbmVyKFtmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYodmFsLmxvYWQgJiYgdmFsLmxvYWQudmFsIT09dHJ1ZSkgdmFsLmxvYWQuX3ZhbC5jYWxsKHRoaXMsIHQpO1xuICAgICAgICAgICAgfSx2YWwuX2Jhc2VdLCB0cnVlKVxuICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWVcblxuICAgICAgICAgICAgaWYoYmF0Y2gpIHtcbiAgICAgICAgICAgICAgaWYoKCFiYXRjaC5iYXRjaCkgfHwgYmF0Y2guYmF0Y2gubGVuZ3RoPT09MCkge1xuICAgICAgICAgICAgICAgIGJhdGNoLmJhdGNoID0gbnVsbFxuICAgICAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShiYXRjaC5fcmFmKVxuICAgICAgICAgICAgICAgIGJhdGNoLl9yYWYgPSByYWYoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgaWYocGFyZW50QmF0Y2guX25vZGUpIGJhdGNoLl92YWwuY2FsbChwYXJlbnRCYXRjaClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmKHZhbC5sb2FkLnZhbCE9PXRydWUpIHZhbC5sb2FkLl92YWwuY2FsbCh0aGlzLCB0KTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlLmJhY2tncm91bmRJbWFnZSA9IHVybFxuXG4gICAgICB9XG4gICAgfSxcbiAgICBwYWRkaW5nOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5wYWRkaW5nID0gdmFsLnZhbCArICdweCc7XG4gICAgfSxcbiAgICB5OiBfY29vcmRpbmF0ZSgndG9wJyksXG4gICAgeDogX2Nvb3JkaW5hdGUoJ2xlZnQnKSxcbiAgICBkaXNwbGF5OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5kaXNwbGF5ID0gdmFsLnZhbDtcbiAgICB9LFxuICAgIHc6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ3cnKTtcbiAgICAgIHZhciB2ID0gdmFsLnZhbFxuICAgICAgdGhpcy5ub2RlLnN0eWxlLndpZHRoID0gKHYgPiAtMSA/ICh2IHwgMCkgICsgJ3B4JyA6IHYgKSB8fCAnMTAwJScgXG4gICAgfSxcbiAgICBoOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIC8vIHZhciB2ID0gdmFsLnZhbCB8IDAgdHlwbyBvciBidWc/XG4gICAgICB2YXIgdiA9IHZhbC52YWxcbiAgICAgIHRoaXMubm9kZS5zdHlsZS5oZWlnaHQgPSAodiA+IC0xID8gKHYgfCAwKSAgKyAncHgnIDogdiApIHx8ICcxMDAlJ1xuICAgIH0sXG4gICAgb3BhY2l0eTogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgdiA9IHZhbC52YWw7XG4gICAgICBpZih2PT09ZmFsc2UpIHRoaXMubm9kZS5zdHlsZS5vcGFjaXR5ID0gbnVsbFxuICAgICAgZWxzZSB0aGlzLm5vZGUuc3R5bGUub3BhY2l0eSA9IHYgPiAtMSA/IHYgOiAxO1xuICAgIH0sXG4gICAgaHRtbDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgdiA9IHZhbC52YWwgfHwgJydcbiAgICAgIGlmKCB2LnJlcGxhY2UgKVxuICAgICAge1xuICAgICAgICAvL2FkZCBzb21lIGluamVjdGlvbiBwcmV2ZW50aW9uIGFzIG9wdGlvbj8gKG5vIHNjcmlwdCBldGMpXG4gICAgICAgIHYgPSB2LnJlcGxhY2UoL1xcdC9nLCAnICAgICcpXG4gICAgICAgICAgICAgLnJlcGxhY2UoL1xcclxcbnxcXG58XFxyL2csICc8YnIvPicpXG4gICAgICAgICAgICAgLnJlcGxhY2UoLyAgL2csICcmbmJzcDsgJylcbiAgICAgICAgICAgICAucmVwbGFjZSgvICAvZywgJyAmbmJzcDsnKSAvLyBzZWNvbmQgcGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZXMgb2RkIG51bWJlciBvZiBzcGFjZXMsIHdoZXJlIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZW5kIHVwIHdpdGggXCImbmJzcDtcIiArIFwiIFwiICsgXCIgXCJcbiAgICAgICAgdGhpcy5ub2RlLmlubmVySFRNTCA9IHZcbiAgICAgIH1cblxuICAgIH0sXG4gICAgaHJlZjogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLm5vZGUuaHJlZiA9IHZhbC52YWw7XG4gICAgfSxcbiAgICB0ZXh0OiBmdW5jdGlvbih2YWwpIHtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ1NFVFRJTkcgVEVYVCcuZ3JlZW4uaW52ZXJzZS4gdmFsLnZhbCwgdmFsKVxuXG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVxuICAgICAgICAsIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzXG4gICAgICAgICwgdiA9IHZhbC52YWwgfHwgdmFsLnZhbCA9PT0gMCA/IHZhbC52YWwgOiAnJ1xuXG4gICAgICBpZih2IGluc3RhbmNlb2YgT2JqZWN0KSB2ID0gJydcblxuICAgICAgaWYgKC90ZXh0Ly50ZXN0KG5vZGUudHlwZSkpIHtcbiAgICAgICAgbm9kZS52YWx1ZSA9IHY7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKG5vZGVzW2ldLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnQkxBQkxBJy5pbnZlcnNlLHYpXG4gICAgICAgICAgICBub2Rlc1tpXS5ub2RlVmFsdWUgPSB2O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2KSk7XG4gICAgfSxcbiAgICAkdGltZW91dDogZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgIGlmKHNldFRpbWVycyA9PT0gdm9pZCAwKXtcbiAgICAgICAgc2V0VGltZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgICAgIHZhciB0aW1lb3V0ID0gdGhpcy4kdGltZW91dFxuICAgICAgICAgIGlmKCB0aW1lb3V0ICkge1xuICAgICAgICAgICAgaWYoX3NldFRpbWVvdXQgPT09IHZvaWQgMCl7XG4gICAgICAgICAgICAgIF9zZXRUaW1lb3V0ID0gZnVuY3Rpb24oIF90aGlzLCB0aW1lb3V0LCBrZXlzLCBpICkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lID0ga2V5c1sgaSBdIC0gKCBrZXlzWyBpIC0gMSBdIHx8IDAgKVxuICAgICAgICAgICAgICAgIHZhciBmbiA9IHRpbWVvdXRbIGtleXNbIGkgXSBdLl92YWxcbiAgICAgICAgICAgICAgICBmbi5pZCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgZm4uaWQgPSBudWxsXG4gICAgICAgICAgICAgICAgICBpZiggIWZuLmRvbmUgfHwgIV90aGlzLmRvbmUgKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwoIF90aGlzIClcbiAgICAgICAgICAgICAgICAgICAgZm4uZG9uZSA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG9uZSA9IG51bGxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmKCBrZXlzWyArK2kgXSApIF9zZXRUaW1lb3V0KCBfdGhpcywgdGltZW91dCwga2V5cywgaSApXG4gICAgICAgICAgICAgICAgfSwgdGltZSApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfc2V0VGltZW91dCggX3RoaXMsIHRpbWVvdXQsIHRpbWVvdXQua2V5cywgMCApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiggdGhpcy5yZW5kZXJlZCApIHtcbiAgICAgICAgc2V0VGltZXJzLmNhbGwoIHRoaXMgKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTZXR0aW5nKCB7XG4gICAgICAgICAgbmFtZTogJ3NldFRpbWVycycsXG4gICAgICAgICAgcmVuZGVyOiBzZXRUaW1lcnNcbiAgICAgICAgfSApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U2V0dGluZygge1xuICAgICAgICBuYW1lOiAncmVtb3ZlVGltZXJzJyxcbiAgICAgICAgcmVtb3ZlOiByZW1vdmVUaW1lcnMgfHwgKHJlbW92ZVRpbWVycyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJy0tLS0tLS0tUkVNT1ZFJyx0aGlzLl9ub2RlKVxuICAgICAgICAgIHZhciB0aW1lcnMgPSB0aGlzLiR0aW1lb3V0XG4gICAgICAgICAgaWYoIHRpbWVycyApIHtcbiAgICAgICAgICAgIHRpbWVycy5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGZuID0gdGhpcy5fdmFsXG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJy0tLS0tLS0tLXJlbW92aW5nJyxmbixmbi5kb25lKVxuICAgICAgICAgICAgICBpZiggdGhpcy5kb25lICkgdGhpcy5kb25lID0gbnVsbFxuICAgICAgICAgICAgICBpZiggZm4uaWQgKSBjbGVhclRpbWVvdXQoIGZuLmlkIClcbiAgICAgICAgICAgICAgaWYoIGZuLmRvbmUgKSBmbi5kb25lID0gbnVsbFxuICAgICAgICAgICAgfSApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSApXG4gICAgfVxuICB9KTtcbn0pOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZnVuY3Rpb24oYmFzZSkge1xuICB2YXIgcHJvdG8gPSBiYXNlLkNsYXNzLnByb3RvdHlwZVxuICAgICwgYWRkID0gcHJvdG8uYWRkXG5cbiAgdXRpbC5kZWZpbmVcbiAgKCBwcm90b1xuICAsICdhZGQnXG4gICwgIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgIGlmKCAhdmFsLnByb2Nlc3MgKVxuICAgICAgIHtcbiAgICAgICAgICBhZGQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgfSBlbHNlXG4gICAgICAge1xuICAgICAgICAgIHZhbC5fX3RlbXBBZGQgPSB1dGlsLmFyZyggYXJndW1lbnRzIClcbiAgICAgICAgICB2YWwuX190ZW1wQWRkLnVuc2hpZnQodGhpcylcbiAgICAgICB9XG4gICAgIH1cbiAgKVxuXG4gIGJhc2UuZXh0ZW5kKHtcbiAgICBwcm9jZXNzOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCd4eHh4X19feHh4eCcpXG4gICAgICBpZih0aGlzLl9fdGVtcEFkZCAmJiAhdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgYWRkLmFwcGx5KHRoaXMuX190ZW1wQWRkWzBdLCB0aGlzLl9fdGVtcEFkZC5zbGljZSgxKSlcbiAgICAgICAgdGhpcy5fX3RlbXBBZGQgPSBudWxsXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG59KVxuXG4vL3Byb2Nlc3Mgd29yZHQgbWlzY2hpZW4gbWVlciBlZW4gb3BlcmF0b3I/XG4vL3Nvb3J0IGZpZWxkIGVpZ2VubGlqayIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBldmVudHMgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMnKVxuICAsIGNhc2VzID0gcmVxdWlyZSgnLi4vLi4vY2FzZXMnKVxuICAsIHVhID0gcmVxdWlyZSgnLi4vLi4vdWEnKVxuICAsIGdsb2JhbCA9IGZhbHNlXG4gICwgTk9ORSA9ICdub25lJ1xuICAsIF9pb3MgPSB1YS5wbGF0Zm9ybT09PSdpb3MnXG4gICwgX2FuZHJvaWQgPSB1YS5wbGF0Zm9ybT09PSdhbmRyb2lkJ1xuICAsIFZJU0lCTEUgPSAndmlzaWJsZSdcbiAgLCBleHRlbmQgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJykuZXh0ZW5kXG4gICwgZG9jID0gZXZlbnRzLmRvY3VtZW50XG4gICwgdGltZXJcbiAgLCBmblxuXG5pZihjYXNlcy4kaGFzVG91Y2gpe1xuXG4gIGZ1bmN0aW9uIGJsdXIgKGUpe1xuICAgIGlmKCFkb2N1bWVudC5hY3RpdmVFbGVtZW50KXtcbiAgICAgIGRvYy5yZW1vdmVFdmVudChmYWxzZSwnYmx1cicpXG4gICAgfWVsc2UgaWYoZS50YXJnZXQudGFnTmFtZSE9PSdJTlBVVCcgJiYgZS50YXJnZXQudGFnTmFtZSE9PSdGT1JNJyl7XG4gICAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50LmJsdXIoKVxuICAgICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLCdibHVyJylcbiAgICB9XG4gIH1cblxuICBldmVudHMucHJldmVudERvd24gPSBcbiAgeyB2YWw6XG4gICAgeyBkb3duOmZ1bmN0aW9uKGUsbWV0aG9kKSB7XG4gICAgICAgIGlmKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIGRvYy5hZGRFdmVudCgndXAnLGJsdXIsJ2JsdXInKVxuICAgICAgICBlbHNlIGlmKGUudGFyZ2V0LnRhZ05hbWUhPT0nSU5QVVQnICYmIGUudGFyZ2V0LnRhZ05hbWUhPT0nRk9STScgJiYgIWV2ZW50cy5fbWF5YmVzY3JvbGwpIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV2ZW50cy5zY3JvbGxiYXIgPSBcbiAgeyB2YWw6IFxuICAgIHsgZG93bjpmdW5jdGlvbihlLG1ldGhvZCx2YWwpIHtcblxuICAgICAgICB2YXIgc2Nyb2xsU3RhcnRcbiAgICAgICAgICAsIHQgPSB0aGlzXG4gICAgICAgICAgLCBzY3JvbGxTdHJcbiAgICAgICAgICAsIHhBeGlzID0gKHZhbC5fdmFsID09PSAneCcpXG4gICAgICAgICAgLCBheGlzXG4gICAgICAgICAgLCBvdGhlcmF4aXNcbiAgICAgICAgICAsIG1vdmVcbiAgICAgICAgICAsIGRcbiAgICAgICAgICAsIGJvdHRvbVByZXZlbnRcbiAgICAgICAgICBcbiAgICAgICAgaWYoeEF4aXMpIHtcbiAgICAgICAgICBheGlzID0gJ3gnXG4gICAgICAgICAgb3RoZXJheGlzID0gJ3knXG4gICAgICAgICAgc2Nyb2xsU3RyID0gJ3Njcm9sbExlZnQnXG4gICAgICAgICAgZCA9IHQubm9kZS5zY3JvbGxXaWR0aCAtIHQubm9kZS5vZmZzZXRXaWR0aFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBheGlzID0gJ3knXG4gICAgICAgICAgb3RoZXJheGlzID0gJ3gnXG4gICAgICAgICAgc2Nyb2xsU3RyID0gJ3Njcm9sbFRvcCdcbiAgICAgICAgICBkID0gdC5ub2RlLnNjcm9sbEhlaWdodCAtIHQubm9kZS5vZmZzZXRIZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIHNjcm9sbFN0YXJ0ID0gdC5ub2RlW3Njcm9sbFN0cl0gLy88PT09PT09PT0gbGVzcyBlZmZpY2llbnQgYnV0IG1vcmUgcHJlZGljdGFibGUgZm9yIGNvbXBlbnNhdGlvblxuXG4gICAgICAgIGlmKGQgPiAwKXtcbiAgICAgICAgICBldmVudHNbYXhpc10gPSB0cnVlXG4gICAgICAgICAgZXZlbnRzLl9tYXliZXNjcm9sbCA9IHRydWVcbiAgICAgICAgICBpZigheEF4aXMpe1xuICAgICAgICAgICAgaWYgKCFzY3JvbGxTdGFydCl7XG4gICAgICAgICAgICAgIHNjcm9sbFN0YXJ0ID0gdC5ub2RlW3Njcm9sbFN0cl0gPSAgMVxuICAgICAgICAgICAgfWVsc2UgaWYoc2Nyb2xsU3RhcnQ9PT1kKSB7XG4gICAgICAgICAgICAgIHNjcm9sbFN0YXJ0ID0gdC5ub2RlW3Njcm9sbFN0cl0gPSBkIC0gMVxuICAgICAgICAgICAgfWVsc2UgaWYoc2Nyb2xsU3RhcnQgPiBkKXtcbiAgICAgICAgICAgICAgYm90dG9tUHJldmVudCA9IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgeSA9IGUueVxuICAgICAgICAgICAgLCB4ID0gZS54XG4gICAgICAgICAgICAsIG1vdmVpZCA9IHNjcm9sbFN0ciArIGF4aXNcbiAgICAgICAgICBcbiAgICAgICAgICBkb2MuYWRkRXZlbnQoJ21vdmUnLGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgdmFyIGR4ID0gTWF0aC5hYnMoeC1lLngpXG4gICAgICAgICAgICAgICwgZFkgPSB5LWUueVxuICAgICAgICAgICAgICAsIGR5ID0gTWF0aC5hYnMoZFkpXG5cbiAgICAgICAgICAgIGlmKHhBeGlzKXtcbiAgICAgICAgICAgICAgaWYoZHkgPiBkeCl7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2F4aXNdID0gZmFsc2VcbiAgICAgICAgICAgICAgICBpZighZXZlbnRzW290aGVyYXhpc10pIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgaWYoZHggPiBkeSl7XG4gICAgICAgICAgICAgICAgZXZlbnRzW2F4aXNdID0gZmFsc2VcbiAgICAgICAgICAgICAgICBpZighZXZlbnRzW290aGVyYXhpc10pIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGJvdHRvbVByZXZlbnQgJiYgZFkgPiAwKXtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3ZlID0gdHJ1ZVxuICAgICAgICAgICAgYmx1cihlKVxuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLG1vdmVpZClcbiAgICAgICAgICB9LG1vdmVpZClcblxuICAgICAgICAgIGRvYy5hZGRFdmVudCgndXAnLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBtcyA9IGV2ZW50cy5fbWF5YmVzY3JvbGwsIG1zbCwgYXJyXG5cbiAgICAgICAgICAgIGlmKCFtb3ZlKXtcbiAgICAgICAgICAgICAgdmFyIHNjcmxsID0gdC5ub2RlW3Njcm9sbFN0cl1cbiAgICAgICAgICAgICAgbW92ZSA9ICEoc2NybGwgPT09IHNjcm9sbFN0YXJ0KSB8fCBzY3JsbCA8IDAgfHwgKCBzY3JsbCA+IGQgJiYgIWJvdHRvbVByZXZlbnQgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighbW92ZSAmJiAhZXZlbnRzW290aGVyYXhpc10gJiYgIWV2ZW50cy5jbGljay5ibG9jayAmJiBtcyAmJiBtcy5sZW5ndGgpe1xuICAgICAgICAgICAgICBtc2wgPSBtcy5sZW5ndGhcbiAgICAgICAgICAgICAgd2hpbGUobXNsLS0pIGlmKCFlLnByZXZlbnQpe1xuICAgICAgICAgICAgICAgIGFyciA9IG1zW21zbF1cbiAgICAgICAgICAgICAgICBhcnJbMF0uY2FsbChhcnJbMV0sZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZighZXZlbnRzW290aGVyYXhpc10gfHwgbW92ZSkgZXZlbnRzLl9tYXliZXNjcm9sbCA9IGZhbHNlXG5cbiAgICAgICAgICAgIGV2ZW50c1theGlzXSA9IGZhbHNlXG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnQoZmFsc2Usc2Nyb2xsU3RyKVxuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wID0gMFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LHNjcm9sbFN0cilcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZuID0gZnVuY3Rpb24gKHZhbCkge1xuICAgICAgXG4gICAgdmFyIHN0eWxlID0gdGhpcy5ub2RlLnN0eWxlXG5cbiAgICBzdHlsZS5vdmVyZmxvdyA9ICdzY3JvbGwnXG4gICAgc3R5bGUud2Via2l0T3ZlcmZsb3dTY3JvbGxpbmcgPSAndG91Y2gnXG4gICAgc3R5bGUubXNUb3VjaEFjdGlvbiA9ICdhdXRvJ1xuICAgIHN0eWxlLnRvdWNoQWN0aW9uID0gJ2F1dG8nXG5cbiAgICBpZiAodmFsLnZhbCA9PT0gJ3gnKSB7XG4gICAgICBzdHlsZS5tc1RvdWNoQWN0aW9uID0gJ3Bhbi14J1xuICAgICAgc3R5bGUudG91Y2hBY3Rpb24gPSAncGFuLXgnXG4gICAgICBzdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJ1xuICAgICAgc3R5bGUub3ZlcmZsb3dYID0gJ3Njcm9sbCdcbiAgICB9ZWxzZSBpZiAodmFsLnZhbCA9PT0gJ3knKSB7XG4gICAgICBzdHlsZS5tc1RvdWNoQWN0aW9uID0gJ3Bhbi15J1xuICAgICAgc3R5bGUudG91Y2hBY3Rpb24gPSAncGFuLXknXG4gICAgICBzdHlsZS5vdmVyZmxvd1ggPSAnaGlkZGVuJ1xuICAgICAgc3R5bGUub3ZlcmZsb3dZID0gJ3Njcm9sbCdcbiAgICB9XG5cbiAgICB0aGlzLmV2ZW50cyA9IHsgc2Nyb2xsYmFyOnZhbC52YWwgfVxuICAgIGlmKCFnbG9iYWwpIHtcbiAgICAgIGdsb2JhbCA9IHRydWVcbiAgICAgIGRvYy5ldmVudHMgPSB7IHByZXZlbnREb3duOnRydWUgfVxuICAgIH1cbiAgfVxuXG59ZWxzZXtcblxuICBmbiA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBjb25zb2xlLmVycm9yKCdudW51IGhleSEnKVxuXG4gICAgdmFyIHN0eWxlID0gdGhpcy5ub2RlLnN0eWxlO1xuICAgIHN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgIHN0eWxlLm92ZXJmbG93WSA9IHZhbC52YWwgIT09ICd4JyA/ICdzY3JvbGwnIDogJ2hpZGRlbic7XG4gICAgc3R5bGUub3ZlcmZsb3dYID0gdmFsLnZhbCAhPT0gJ3knID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcbiAgfVxuXG59XG5cbmV4cG9ydHMuZXh0ZW5kID0gZXh0ZW5kKGZ1bmN0aW9uKGJhc2UpIHtcbiAgYmFzZS5leHRlbmQoeyBzY3JvbGxiYXI6Zm4gfSlcbn0pICAiLCJ2YXIgdWEgPSByZXF1aXJlKCcuLi8uLi91YScpXG4gICwgX3ByZWZpeCA9ICctJyt1YS5wcmVmaXgudG9Mb3dlckNhc2UoKVxuICAsIF90cmFuc2Zvcm0gPSBfcHJlZml4ICsgJy10cmFuc2Zvcm0nXG5cbmV4cG9ydHMuZ2V0TWF0cml4ID0gZnVuY3Rpb24obm9kZSkge1xuICBpZihub2RlLnN0eWxlW190cmFuc2Zvcm1dKSB7XG4gICAgdmFyIGFyciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpXG4gICAgICAuZ2V0UHJvcGVydHlWYWx1ZShfdHJhbnNmb3JtKS5yZXBsYWNlKCdtYXRyaXgoJywgJycpLnNwbGl0KCcsJylcbiAgICByZXR1cm4gYXJyXG4gIH1cbn1cblxuLy8gZXhwb3J0cy5oYXNDYWxjID0gZnVuY3Rpb24oKSB7XG4vLyAgIHZhciBkdW1teSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4vLyAgICAgLCBwcm9wcyA9IFsgX3ByZWZpeCsnLWNhbGMnLCAnY2FsYycgXVxuLy8gICAgICwgaSA9IHByb3BzLmxlbmd0aFxuLy8gICB3aGlsZShpLTEpIHtcbi8vICAgICBkdW1teS5zdHlsZS5jc3NUZXh0ID0gJ3dpZHRoOicgKyBwcm9wc1tpLTFdICsgJygxcHgpOydcbi8vICAgICBpZiAoZHVtbXkuc3R5bGUubGVuZ3RoKSByZXR1cm4gcHJvcHNbaS0xXVxuLy8gICAgIGktLVxuLy8gICB9XG4vLyB9IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIGVsZW1lbnQgPSByZXF1aXJlKCcuLycpXG4gICwgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JylcblxuLyoqXG4gKiBmbGFnc1xuICogYWRkIGtleXdvcmRzIHRvIHNldCBvYmplY3RzIHdoaWNoIGFyZSBjaGVja2VkIHVzaW5nIGEgZnVuY3Rpb24gaW4gZmxhZ3NcbiAqIHNpbXBseSBhZGQgZmllbGRzIHRvIHRoZSBzZXQgbW9kdWxlXG4gKi9cbnZhciBmbGFncyA9IGV4cG9ydHNcbiAgLyoqXG4gICAqIF9mbGFnXG4gICAqIGZ1bmN0aW9uIHRoYXQgY2FsbHMgZmxhZyBmdW5jdGlvbnMgb24gZWxlbWVudC5zZXQuZmxhZ3NcbiAgICovXG4gICwgX2ZsYWcgPSBmdW5jdGlvbihuYW1lLCB2YWwsIGNvcHksIHRvcCkge1xuICAgICAgdmFyIGY7XG4gICAgICBmb3IgKHZhciBpIGluIGZsYWdzKSB7XG4gICAgICAgIGYgPSBmbGFnc1tpXS5jYWxsKHRoaXMsIG5hbWUsIHZhbCwgY29weSwgdG9wKTtcbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICByZXR1cm4gZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxudXRpbC5kZWZpbmUoZWxlbWVudCxcbiAgLyoqXG4gICAqIHNldFxuICAgKiBhZGRzIGNoaWxkcmVuIGZvciBub24gZXhpc3RpbmcgYXR0cmlidXRlc1xuICAgKiBfb3JpZ2luYWwgYXJlIG9yaWdpbmFsIHZhbHVlcyBjaGFuZ2VkIGJ5IGNhc2VzIGFuZCBldmVudHNcbiAgICogaW5zdGFuY2VzIC0gYWRkIG9yIHJlbW92ZSBjaGlsZHJlbiBmcm9tIGluc3RhbmNlcztcbiAgICovXG4gICdfc2V0JywgZnVuY3Rpb24odmFsLCBpLCBpbnN0YW5jZXMpIHtcbiAgICAvL3RoaXNcbiAgICBpZiAoIV9mbGFnLmNhbGwodGhpcywgaSwgdmFsW2ldLCBpbnN0YW5jZXMsIHZhbCkpIHtcblxuICAgICAgaWYgKCAhdGhpcy5pc1Byb3BlcnR5KCBpLCB2YWwgKSApIHtcblxuICAgICAgICBpZiAodmFsW2ldIGluc3RhbmNlb2YgZWxlbWVudCkge1xuICAgICAgICAgIHZhciBiZWZvcmVcbiAgICAgICAgICBpZiAodGhpc1tpXSkge1xuICAgICAgICAgICAgZm9yKHZhciBjPXRoaXMubm9kZS5jaGlsZE5vZGVzLG5vZGUkPTAsbGVuPWMubGVuZ3RoO25vZGUkPGxlbjtub2RlJCsrKSB7XG4gICAgICAgICAgICAgIGlmKGNbbm9kZSRdPT09dGhpc1tpXS5ub2RlKSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlID0gY1sobm9kZSQrMSldXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXNbaV0ucmVtb3ZlICYmIHRoaXNbaV0ucmVtb3ZlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vcmVwbGFjZSBlbGVtZW50IGlmIGl0cyBhbHJlYWR5IHRoZXJlXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcihhZGQsIGluc3RhbmNlcywgdmFsW2ldKVxuICAgICAgICAgIHZhciBhZGQgPSBpbnN0YW5jZXMgPyBuZXcgdmFsW2ldLkNsYXNzIDogdmFsW2ldO1xuICAgICAgICAgIGFkZC5uYW1lID0gaTtcbiAgICAgICAgICB0aGlzLmFkZChhZGQsIGJlZm9yZSk7XG4gICAgICAgICAgaWYgKGluc3RhbmNlcykge1xuICAgICAgICAgICAgdGhpcy5lYWNoSW5zdGFuY2UoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHZhciBhID0gbmV3IGFkZC5DbGFzcygpO1xuICAgICAgICAgICAgICBhLl9uYW1lID0gaTtcbiAgICAgICAgICAgICAgdGhpcy5hZGQoYSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgXG4gICAgICAgICAgaWYoIHRoaXNbaV0gaW5zdGFuY2VvZiBvYmplY3QgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvL1RPRE86IHRvcm91Z2ggdGVzdGluZ1xuICAgICAgICAgICAgdGhpc1tpXS52YWwgPSB2YWxbaV1cbiAgICAgICAgICB9IFxuICAgICAgICAgIGVsc2UgaWYoIHZhbFtpXSBpbnN0YW5jZW9mIG9iamVjdCApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignYXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHNldCB1c2luZyBhIHZPYmplY3Q/IG1heWJlIHJlcXVpcmUgc29tZSBzdHVmZiAoZS5nLiBkYXRhKScpXG4gICAgICAgICAgICB0aGlzW2ldID0gdmFsW2ldXG4gICAgICAgICAgfSBcbiAgICAgICAgICBlbHNlIGlmKCB0aGlzW2ldIGluc3RhbmNlb2YgZWxlbWVudCApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmKCB2YWxbaV0gKSB7XG4gICAgICAgICAgICAgIHRoaXNbaV0uc2V0KHZhbFtpXSwgaW5zdGFuY2VzKVxuICAgICAgICAgICAgfSBlbHNlIGlmKCB2YWxbaV0gPT09IGZhbHNlICl7XG4gICAgICAgICAgICAgIGlmICggaW5zdGFuY2VzICkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWFjaEluc3RhbmNlKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0pIHRoaXNbaV0ucmVtb3ZlKClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXNbaV0ucmVtb3ZlKClcbiAgICAgICAgICAgICAgdGhpc1tpXSA9IG51bGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IFxuICAgICAgICAgIGVsc2UgXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYodmFsW2ldIGluc3RhbmNlb2YgT2JqZWN0ICkge1xuICAgICAgICAgICAgICB2YXIgYWRkID0gbmV3IGVsZW1lbnQoKS5zZXQodmFsW2ldLCBpbnN0YW5jZXMpXG4gICAgICAgICAgICAgIGFkZC5uYW1lID0gaTtcbiAgICAgICAgICAgICAgdGhpcy5hZGQoYWRkKVxuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VzKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5lYWNoSW5zdGFuY2UoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgdmFyIGEgPSBuZXcgYWRkLkNsYXNzKClcbiAgICAgICAgICAgICAgICAgIGEuX25hbWUgPSBpXG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZChhKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignXCInICsgaSArICdcIiBpcyBub3QgYW4gZXhpc3RpbmcgcHJvcGVydHkuIFwiJyArIHZhbFtpXSArICdcIiBpcyBhIHByaW1pdGl2ZS4gQWRkaW5nIGFzIHByaW1pdGl2ZS4nIClcbiAgICAgICAgICAgICAgdGhpc1tpXSA9IHZhbFtpXVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZih0eXBlb2YgdGhpc1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGlmKHZhbFtpXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICB0aGlzW2ldLmFwcGx5KHRoaXMsdmFsW2ldKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW2ldKHZhbFtpXSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1tpXSA9IHZhbFtpXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvL2R5bmFtaWMgY2hhbmdlcyB0byB0aGUgX29yaWdpbmFsIHNldCBvYmplY3QgcG9vbFxuICAgICAgLy9pZiAoIWNvcHkgJiYgdGhpcy5fb3JpZ2luYWwpIHtcbiAgICAgIC8vdGhpcy5fb3JpZ2luYWxbaV0gPSB2YWxbaV07IC8vY2hlY2sgaWYgc3R1ZmYgL3cgY2xhc3NlcyBpcyBuZXNzZWNhcnk7XG4gICAgICAvL31cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBjb252ZXJ0XG4gICAqIGZvciBlYWNoIGZpZWxkcyBpbiB2YWwgY29udmVydCBiYWNrIHRvIGEgc2V0T2JqZWN0O1xuICAgKi9cbiAgJ2NvbnZlcnQnLCBmdW5jdGlvbih2YWwpIHtcbiAgICB2YXIgc2V0T2JqID0ge30sXG4gICAgICBpc09iajtcbiAgICBmb3IgKHZhciBpIGluIHZhbCkge1xuICAgICAgaXNPYmogPSB1dGlsLmlzT2JqKHZhbFtpXSlcbiAgICAgIGlmICh0aGlzW2ldIGluc3RhbmNlb2YgZWxlbWVudCkge1xuICAgICAgICBzZXRPYmpbaV0gPSBpc09iaiA/IHRoaXNbaV0uY29udmVydCh2YWxbaV0pIDogdGhpc1tpXVxuICAgICAgfSBlbHNlIGlmICh0aGlzW2ldIGluc3RhbmNlb2Ygb2JqZWN0KSB7XG4gICAgICAgIHNldE9ialtpXSA9IHRoaXNbaV0uY29udmVydChpc09iaiAmJiB2YWxbaV0pXG4gICAgICB9IGVsc2UgaWYgKHRoaXNbaV0gPT09IHZvaWQgMCB8fCAodXRpbC5sb29rdXAuY2FsbCh0aGlzLCBpKSAmJiB0aGlzW2ldID09PSBmYWxzZSkpIHtcbiAgICAgICAgc2V0T2JqW2ldID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldE9ialtpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNldE9ialxuICB9KSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbi8vZHVyYXRpb24gaW4gYSBWLlZhbHVlIC0tPiB1cGRhdGUgaWYgbmVzc2VjYXJ5P1xudmFyIHVhID0gcmVxdWlyZSgnLi4vLi4vdWEnKVxuICAsIHZpZGVvID0gcmVxdWlyZSgnLi8nKVxuICAsIHBvc3Rwb25lID0gcmVxdWlyZSgnLi4vLi4vLi4vYnJvd3Nlci9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG4gICwgX3dpblBob25lID0gdWEucGxhdGZvcm0gPT09ICd3aW5kb3dzJyAmJiB1YS5kZXZpY2UgPT09ICdwaG9uZSdcbiAgLCBfaW9zID0gdWEucGxhdGZvcm0gPT09ICdpb3MnXG4gICwgX2FuZHJvaWQgPSB1YS5wbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnXG4gICwgX2lvczcgPSBfaW9zICYmIG5hdmlnYXRvci51c2VyQWdlbnQuc3BsaXQoJ09TJylbMV1bMV0gPT09ICc3JyAvLyBURU1QIEZJWCBVTlRJTCBXRSBETyBVQVxuICAsIF9jYW5wbGF5ID0gJ2NhbnBsYXknLy9faW9zNyA/ICdjYW5wbGF5dGhyb3VnaCcgOiAnY2FucGxheScgXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpc3RlbmVyICgpIHtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHNcbiAgICAsIGwgPSBhcmdzLmxlbmd0aFxuXG4gIHJldHVybiBmdW5jdGlvbih0eXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIF90aGlzID0gdGhpczsgaSA8IGw7IHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKGFyZ3NbaSsrXVxuICAgICAgLCBmdW5jdGlvbihlKSB7IHR5cGUuX3ZhbC5jYWxsKF90aGlzLGUpIH0pKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIF9jYW5wbGF5TGlzdGVuZXIgKCkge1xuICBpZiAoICF0aGlzLl9jYW5wbGF5ICYmICFfd2luUGhvbmUgKSB7IC8vbGF0ZXIgdmVyc2lvbnMgKGlmIGZpeGVkaW4gOSlcbiAgICBcbiAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAsIG5vZGUgPSB0aGlzLm5vZGVcbiAgICBcbiAgICB0aGlzLl9jYW5wbGF5ID0gdHJ1ZVxuICAgIFxuICAgIC8vIGlmKF9pb3MpIG5vZGUuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG5cbiAgICBmdW5jdGlvbiBjYW5QbGF5KCkge1xuICAgICAgaWYgKCBfdGhpcy50aW1lICkge1xuICAgICAgICBcbiAgICAgICAgaWYgKCFfdGhpcy50aW1lLnZhbCkgdGhpcy5fZmlyc3RUID0gdHJ1ZVxuICAgICAgICAgIC8vZml4ZXMgZm9yIHBob25lZ2FwISB3aW5kb3dzbW9iaWxlXG4gICAgICAgIGlmIChfYW5kcm9pZCAmJiB1YS5icm93c2VyICE9PSAnY2hyb21lJykgeyBcbiAgICAgICAgICAvL2FuZCBzcGVjaWFsIGJyb3dzZXIhOyBjaGVjayBmaXJlZm94OyAvL2lkZW50aWZ5IG1vcmUgYnJvd3NlcnMgdGhhdCBkbyBub3QgbmVlZCB0aGlzIGNyYXBcbiAgICAgICAgICB2YXIgdHJpZXMgPSAwXG4gICAgICAgICAgY2xlYXJJbnRlcnZhbCggX3RoaXMuX3RpbWVGaXhJbnRlcnZhbCApXG4gICAgICAgICAgX3RoaXMuX3RpbWVGaXhJbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlVGltZSgpXG4gICAgICAgICAgICBpZiAodHJpZXMgPT09IDMpIHtcbiAgICAgICAgICAgICAgX3RoaXMuX2NhbnBsYXkgPSBudWxsXG4gICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX3RoaXMuX3RpbWVGaXhJbnRlcnZhbClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ub2RlLmR1cmF0aW9uICE9PSAxKSB7IC8vYW5kcm9pZCBzZXRzIGR1cmF0aW9uIHRvIDEgYXMgZGVmYXVsdCBpbnN0ZWFkIG9mIDBcbiAgICAgICAgICAgICAgdHJpZXMrK1xuICAgICAgICAgICAgICBpZiAoX3RoaXMucGxheWluZykgX3RoaXMubm9kZS5wbGF5KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCAyMDApXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoX3RoaXMudGltZS52YWwpIHtcbiAgICAgICAgICAgIGlmIChfaW9zNykge1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBfdGhpcy51cGRhdGVUaW1lKCkgfSwgMClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVRpbWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5fZm9yY2VUaW1lID0gdHJ1ZSBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggX2lvcyAmJiB0aGlzLnBsYXlpbmcgKXtcbiAgICAgICAgICAgIHZhciB0aW1lID0gX3RoaXMudGltZS52YWwgKiBfdGhpcy5kdXJhdGlvbi52YWxcbiAgICAgICAgICAgIGZ1bmN0aW9uIHRpbWV1cGRhdGUoKXtcbiAgICAgICAgICAgICAgaWYofn5ub2RlLmN1cnJlbnRUaW1lID49IH5+dGltZSl7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgdGltZXVwZGF0ZSlcbiAgICAgICAgICAgICAgICBpZihfaW9zNyl7XG4gICAgICAgICAgICAgICAgICBmdW5jdGlvbiBjYW5wbGF5dGhyb3VnaCgpe1xuICAgICAgICAgICAgICAgICAgICBub2RlLnBsYXkoKVxuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSdcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsY2FucGxheXRocm91Z2gpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXl0aHJvdWdoJyxjYW5wbGF5dGhyb3VnaClcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIG5vZGUucGxheSgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIHRpbWV1cGRhdGUpXG4gICAgICAgICAgICBub2RlLnBhdXNlKClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5fY2FucGxheSA9IG51bGxcblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihfY2FucGxheSwgY2FuUGxheSlcbiAgICB9XG5cbiAgICB0aGlzLl9jYW5QbGF5ID0gY2FuUGxheVxuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihfY2FucGxheSwgY2FuUGxheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRUaW1lICh2YWwpIHtcbiAgaWYgKHRoaXMubm9kZS5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5ub2RlLmN1cnJlbnRUaW1lID0gdmFsXG4gICAgaWYgKF9pb3MpIHRoaXMuX2NvcnJlY3RUaW1lID0gdmFsXG4gIH0gZWxzZSB7XG4gICAgX2NhbnBsYXlMaXN0ZW5lci5jYWxsKHRoaXMpXG4gIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9ICBcbnsgcHJvZ3Jlc3M6IHtcbiAgICBzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZCcsIChfdGhpcy5fcHJFbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgX3RoaXMuY2xlYXJQcm9ncmVzcygpXG4gICAgICB9KSlcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsdGhpcy5fY2FuUGxheSlcbiAgICAgIHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmQnLCB0aGlzLl9wckVuZCkgLy9tYXliZSBubyBwbGF5IGFuZCBwYXVzZSE7XG4gICAgfVxuICB9XG4sIGJ1ZmZlcjogZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIGJ1ZmZlcmVkID0gdGhpcy5ub2RlICYmIHRoaXMubm9kZS5idWZmZXJlZFxuICAgIGlmIChidWZmZXJlZCkge1xuICAgICAgdmFyIGwgPSBidWZmZXJlZC5sZW5ndGhcbiAgICAgICAgLCBwaXYgPSAtMVxuICAgICAgICAsIHQgPSB0aGlzLm5vZGUuY3VycmVudFRpbWUgfHwgMFxuICAgICAgICAsIGxzXG4gICAgICAgICwgdHRcbiAgICAgICAgLCBpID0gMFxuICAgICAgXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBscyA9IGJ1ZmZlcmVkLnN0YXJ0KGkpXG4gICAgICAgIGlmIChscyA+IHBpdiAmJiBscyA8IHQpIHtcbiAgICAgICAgICBwaXYgPSBpXG4gICAgICAgICAgdHQgPSBsc1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwaXYgPiAtMSkge1xuICAgICAgICBwaXYgPSBidWZmZXJlZC5lbmQocGl2KVxuICAgICAgICByZXR1cm4gcGl2IDwgdCA/IDAgOiBwaXYgLyB0aGlzLmR1cmF0aW9uLnZhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfVxuLCBwbGF5OiBmdW5jdGlvbih2YWwpIHtcbiAgICBpZih0aGlzLm5vZGUgJiYgdGhpcy5ub2RlLnBhdXNlKSB7XG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIHRoaXMubm9kZS5wbGF5KClcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLm5vZGUucGF1c2UoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuLCB0aW1lOiBcbiAgLy90ZXN0cyBmb3IgYW5kcm9pZCAsIHdpbnBob25lLCBmaXJlZm94cGhvbmUgKHNlZWtpbmcgb24gd2lucGhvbmUgaXMgbm90IHBvc3NpYmxlIGFueXdheXMpXG4gIHsgc2V0ICAgLy9faW9zICB8fCBfYW5kcm9pZCAvL3VhLmRldmljZSA9PT0gJ3Bob25lJyB8fCB1YS5kZXZpY2UgPT09ICd0YWJsZXQnXG4gICAgICAvLyBwb3N0cG9uZShzZXRUaW1lKVxuICAgIDogc2V0VGltZVxuICAsIGdldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgdGltZSA9IHRoaXMubm9kZSAmJiB0aGlzLm5vZGUuY3VycmVudFRpbWVcbiAgICAgIGlmICh0aGlzLl9jb3JyZWN0VGltZSkge1xuICAgICAgICBpZiAodGhpcy5fY29ycmVjdFRpbWUgPiB0aW1lIC0gMiAmJiB0aGlzLl9jb3JyZWN0VGltZSA8IHRpbWUgKyAyKSB7IC8vfHwgdGhpcy5jbnRcbiAgICAgICAgICB0aW1lID0gdGhpcy5fY29ycmVjdFRpbWVcbiAgICAgICAgICBpZiAoIXRoaXMuY250KSB7XG4gICAgICAgICAgICB0aGlzLmNudCA9IDNcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2NudCA8IDIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcnJlY3RUaW1lID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMuX2NudCA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NvcnJlY3RUaW1lKz0wLjUgLy9zaG91bGQgYmUgaW50ZXJ2YWwgb2YgcHJvZ3Jlc3MgdXBkYXRlc1xuICAgICAgICAgICAgdGhpcy5fY250LS1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGltZSA9IHRoaXMuX2NvcnJlY3RUaW1lXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aW1lIC8gdGhpcy5kdXJhdGlvbi52YWwgfHwgdmFsLnZhbFxuICAgIH1cbiAgfVxuLCBkdXJhdGlvbjogZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVcbiAgICByZXR1cm4gbm9kZSAmJiBub2RlLnJlYWR5U3RhdGUgPyBub2RlLmR1cmF0aW9uIDogdmFsICYmIHZhbC52YWxcbiAgfVxuLCBhdXRvcGxheTogZnVuY3Rpb24odmFsKSB7XG4gICAgaWYodGhpcy5ub2RlKSB0aGlzLm5vZGUuYXV0b3BsYXkgPSB2YWwudmFsXG4gIH1cbiwgbG9vcDogZnVuY3Rpb24odmFsKSB7XG4gICAgaWYodGhpcy5ub2RlKSB0aGlzLm5vZGUubG9vcCA9IHZhbC52YWxcbiAgfVxuLCB2b2x1bWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciB2b2x1bWUgPSB2YWwudmFsXG4gICAgaWYodGhpcy5ub2RlICYmICFpc05hTih2b2x1bWUpKSB0aGlzLm5vZGUudm9sdW1lID0gdm9sdW1lXG4gIH1cblxuLCBcIm5ld1wiOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFkZEV2ZW50KCdkb3duJyxmdW5jdGlvbihlKXsgZS5wcmV2ZW50RGVmYXVsdCgpIH0pXG4gICAgX2NhbnBsYXlMaXN0ZW5lci5jYWxsKHRoaXMpXG4gICAgaWYgKHRoaXMudm9sdW1lKSB0aGlzLnZvbHVtZS51cGRhdGUodGhpcylcbiAgfVxuLCBldmVudHM6IHtcbiAgICBwYXVzZTpmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgIGlmKF9pb3MgJiYgX3RoaXMubm9kZSkgeyBcbiAgICAgICBfdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgaWYoIV90aGlzLmlnbm9yZWV2ZW50cykgX3RoaXMucGF1c2UoKSAgICAgXG4gICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gICwgcHJvZ3Jlc3M6IHZpZGVvLnByb2dyZXNzXG4gICwgcmVhZHk6IGNyZWF0ZUxpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScpXG4gICwgY2FucGxheTogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICBpZihfdGhpcy5ub2RlKSBfdGhpcy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoX2NhbnBsYXksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoX3RoaXMubm9kZSAmJiBfdGhpcy5ub2RlLnJlYWR5U3RhdGU9PT00KSB7XG4gICAgICAgICAgX3RoaXMuX3N0YWxsZWQgPSBmYWxzZVxuICAgICAgICAgIHZhbC5fdmFsLmNhbGwoX3RoaXMsZSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gICwgc3RhbGxlZDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICAgICwgbm9kZSA9IHRoaXMubm9kZVxuICAgICAgICAsIGxpc3RlbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgdGltZSA9IF90aGlzLmdldFRpbWUoKVxuICAgICAgICAgIGlmKCEoX3RoaXMuZ2V0QnVmZmVyKHRpbWUpLXRpbWUgPiAwLjA1KSkge1xuICAgICAgICAgICAgX3RoaXMuX3N0YWxsZWQgPSB0cnVlXG4gICAgICAgICAgICB2YWwuX3ZhbC5jYWxsKF90aGlzLGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBpZihub2RlKXtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdzdGFsbGVkJywgbGlzdGVuIClcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCd3YWl0aW5nJywgbGlzdGVuIClcbiAgICAgIH1cbiAgICB9XG4gICwgcGxheTogXG4gICAgeyBwbGF5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRzLnBsYXkpIHRoaXMuZXZlbnRzLnBsYXkuX3ZhbC5jYWxsKHRoaXMpXG4gICAgICB9XG4gICAgLCBzZXQ6IGZhbHNlXG4gICAgfVxuICAsIGVuZDogY3JlYXRlTGlzdGVuZXIoJ2VuZGVkJylcbiAgfVxuLCBzcmM6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBzcmMgPSB0aGlzLm5vZGUuc3JjXG4gICAgaWYgKHNyYyAhPT0gdmFsIHx8IHZhbCB8fCAhdmFsICYmIHNyYykgdGhpcy5ub2RlLnNyYyA9IHZhbC52YWxcbiAgfVxufVxuXG5pZiAoIXZpZGVvLnBsYXllcikgdmlkZW8ucGxheWVyID0gbW9kdWxlLmV4cG9ydHMiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbnZhciBlbGVtZW50ID0gcmVxdWlyZSgnLi4vJylcbiAgLmluamVjdFxuICAoIHJlcXVpcmUoJy4uL3Byb3BlcnRpZXMnKVxuICApXG5cbiAgLCBldmVudHMgPSByZXF1aXJlKCcuLi8uLi9ldmVudHMnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsJylcbiAgLCBwb3N0cG9uZSA9IHJlcXVpcmUoJy4uLy4uL2V2ZW50cy91dGlsJykucG9zdHBvbmVcbiAgLCBiYXNlID0gbmV3IGVsZW1lbnQoe1xuICAgICAgbm9kZTogJ3ZpZGVvJ1xuICB9KVxuICBcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGJhc2UuQ2xhc3NcbnZhciB2aWRlbyA9IGV4cG9ydHNcbmV4cG9ydHMuYmFzZSA9IGJhc2VcblxuYmFzZS5zZXRTZXR0aW5nKFxueyBuYW1lOiAnX3ZpZGVvU2V0dGluZ3MnXG4sIG5ldzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucGxheWVyLm5ldykgdGhpcy5wbGF5ZXIubmV3LmNhbGwodGhpcylcbiAgfVxuLCByZW1vdmU6ZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucGxheWVyLnJlbW92ZSkgdGhpcy5wbGF5ZXIucmVtb3ZlLmNhbGwodGhpcylcbiAgfVxuLCByZW5kZXI6ZnVuY3Rpb24oKSB7XG4gICAgIGlmICh0aGlzLnBsYXllci5yZW5kZXIpIHRoaXMucGxheWVyLnJlbmRlci5jYWxsKHRoaXMpXG4gIH1cbn0pXG4vL3Byb3h5IGFkZGVuIC0tPiBzaG91bGQgYmUgYW4gZXh0ZW5zaW9uIG9uIHNyY1xuYmFzZS5ub2RlLnNldEF0dHJpYnV0ZSgnd2Via2l0LXBsYXlzaW5saW5lJywgJycpXG5cbi8vY2xvdWQgc2hvcnRlbiB0aGVzZSAzIGZ1bmN0aW9uc1xuZnVuY3Rpb24gX3ZpZEV2ZW50cyAodmFsKSB7XG5cbiAgdGhpcy5fcmVhZHlGb3JFdmVudHMgPSB0cnVlXG5cbi8vICAgY29uc29sZS5sb2coJ1xcblxcblxcblxcblxcbm5cXG5cXG5cXG5TRVQgVklERVZFTlRTJylcblxuICB2YXIgdCA9IHRoaXNcbiAgICAsIGUgPSAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5ldmVudHNcbiAgdmFsLmVhY2goZnVuY3Rpb24oaSkge1xuICAgIGlmIChlW2ldICYmIGVbaV0uc2V0ICE9PSBmYWxzZSkgKGVbaV0uc2V0IHx8IGVbaV0pLmNhbGwodCwgdGhpcywgaSlcbiAgfSlcbiAgcmV0dXJuIGVcbn1cblxuZnVuY3Rpb24gX3JlbW92ZVZpZEV2ZW50cyAodmFsKSB7XG4gIHZhciB0ID0gdGhpc1xuICAgICwgZSA9ICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLmV2ZW50c1xuXG4gIHZhbC5lYWNoKGZ1bmN0aW9uKGkpIHtcbiAgICBpZiAoZVtpXSAmJiBlW2ldLnJlbW92ZSkgZVtpXS5yZW1vdmUuY2FsbCh0LCB0aGlzLCBpKVxuICB9KVxufVxuXG5mdW5jdGlvbiBfcGxheUhvb2sgKHBhcmFtKSB7XG4gIHZhciB2YWwgPSB0aGlzLmV2ZW50c1xuICBpZiAodmFsKSB7XG4gICAgdmFyIHQgPSB0aGlzXG4gICAgICAsIGUgPSAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5ldmVudHNcbiAgICB2YWwuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBpZiAoZVtpXSAmJiBlW2ldLnBsYXkpIGVbaV0ucGxheS5jYWxsKHQsIHRoaXMsIGksIHBhcmFtKVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gX3Byb2dyZXNzKHZhbCkge1xuXG4gIC8vIGNvbnNvbGUuZXJyb3IoJ1NFVCBwcm9ncmVzcycsdGhpcy5fcHJvZ3Jlc3MpXG5cbiAgaWYgKCF0aGlzLl9wcm9ncmVzcykge1xuXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdTRVQgcHJvZ3Jlc3MgZm9yIFJFQUwnLHRoaXMuX3Byb2dyZXNzKVxuXG4gICAgLy9tYXliZSBkbyB0aGlzIHdpdGggcmVxdWVzdEFuaW1hdGlvbkZyYW1lIC0tIGRhbmdlciBsaWVzIGluIGluY29zaXN0ZW5jeSB3aXRoIHRpbWluZ1xuICAgIHZhciBwYXJhbXMgPSB2YWxcbiAgICAgICwgaW50ZXJ2YWwgPSBwYXJhbXMuaW50ZXJ2YWwgJiYgcGFyYW1zLmludGVydmFsLnZhbCB8fCA1MDAgXG4gICAgICAsIGZuID0gcGFyYW1zLl92YWxcbiAgICAgICwgdCA9IHRoaXNcbiAgICAgICwgcHIgPSAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5wcm9ncmVzc1xuXG4gICAgaWYgKHByICYmIHByLnNldCkgcHIuc2V0LmNhbGwodClcblxuICAgIHQuX3Byb2dyZXNzID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdiZWZvcmUgcHJvZ3Jlc3MgY2FsbCEnLHQuc3JjLnZhbClcbiAgICAgIC8vIGlmKHQucGxheWluZyYmIXQuX19wYXVzZWQpIHtcbiAgICAgIC8vICAgLy8gdC5wbGF5KClcbiAgICAgIC8vICAgLy8gbm8gc3JjIVxuICAgICAgLy8gfVxuXG4gICAgICB2YXIgcCA9IE51bWJlcih0LmdldFRpbWUoKSlcbiAgICAgICAgLCBiID0gdC5nZXRCdWZmZXIocClcbiAgICAgICAgLCBkID0gTnVtYmVyKHQuZHVyYXRpb24udmFsKVxuXG4gICAgICBpZihkPT09MSkgZD0wIC8vYW5kcm9pZCBmaXggLS0gbWF5YmUgcmVtb3ZlXG5cbiAgICAgIGlmIChwID49IDEgJiYgZCkge1xuICAgICAgICB0LnBhdXNlKClcbiAgICAgICAgdC5wbGF5aW5nID0gZmFsc2UgLy9zaG91bGQgdGhpcyBiZSByZW1vdmVkIGFuIGdvIHRvIGVuZD8gXG4gICAgICAgIC8vY2FsbCBwYXVzZSBhbmQgc2V0IHRpbWUgaW4gaGVyZT9cbiAgICAgICAgdC5jbGVhclByb2dyZXNzKClcbiAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgaWYodC5fc3RhbGxlZCAmJiBkKSB7IC8vanVzdCB0byBtYWtlIHN1cmUgYnVmZmVyaW5nIGFsd2F5cyBkaXNzYXBhZXJzICAgIFxuICAgICAgICAgIGlmKGI+MC44NSB8fCAodC5fX2xwICYmIHQuZXZlbnRzLmNhbnBsYXkgJiYgKHAgPiB0Ll9fbHArKDEvZCkpKSkgeyAvL2luIHNlY29uZHNcbiAgICAgICAgICAgIHQuX3N0YWxsZWQgPSBmYWxzZVxuICAgICAgICAgICAgdC5ldmVudHMuY2FucGxheS5fdmFsLmNhbGwodClcbiAgICAgICAgICAgIHQuX19scCA9IG51bGxcbiAgICAgICAgICB9IGVsc2UgaWYoICghdC5fX2xwKSAmJiBwPi0xKSB7XG4gICAgICAgICAgICB0Ll9fbHAgPSBwXG4gICAgICAgICAgfSBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCF0Lmlnbm9yZWV2ZW50cykgZm4uY2FsbCh0LCBwLCBiKVxuICAgICAgfVxuICAgIH0sIGludGVydmFsKVxuICB9XG59XG5cbnRoaXMuX3Byb2dyZXNzID0gX3Byb2dyZXNzXG5cbmV4cG9ydHMucHJvZ3Jlc3MgPSBcbnsgcGxheTogZnVuY3Rpb24oaSwgcCwgcGEpIHtcbiAgICBpZiAocGEpIHtcbiAgICAgIF9wcm9ncmVzcy5jYWxsKHRoaXMsIHRoaXMuZXZlbnRzLnByb2dyZXNzKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNsZWFyUHJvZ3Jlc3MoKVxuICAgIH1cbiAgfVxuLCBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICh0aGlzLnBsYXlpbmcpIF9wcm9ncmVzcy5jYWxsKHRoaXMsIHZhbClcbiAgfVxuLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xlYXJQcm9ncmVzcygpXG4gIH1cbn1cblxudXRpbC5kZWZpbmUoZXhwb3J0c1xuLCAncmVzdW1lUGxheScsIHBvc3Rwb25lKGZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMubm9kZSkge1xuICAgICAgaWYodGhpcy4kcGxheWluZy52YWw9PT10cnVlKSB7XG4gICAgICAgIHRoaXMucGxheSgpXG4gICAgICB9XG4gICAgICB0aGlzLmlzU2Vla2luZyA9IG51bGxcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1JFU1VNRSEnKVxuICAgIH1cbiAgfSwxMDAxKVxuLCAnc2V0RXZlbnRzJywgZnVuY3Rpb24oKSB7XG4gICAgX3ZpZEV2ZW50cy5jYWxsKHRoaXMsIHRoaXMuZXZlbnRzKVxuICB9XG4sICdwbGF5JywgZnVuY3Rpb24oY2xlYXIsIGlnbm9yZSkge1xuXG4gICAgaWYgKGNsZWFyKSBkZWxldGUgdGhpcy5pZ25vcmVldmVudHNcbiAgICBpZiAoIWlnbm9yZSAmJiAhdGhpcy5pZ25vcmVldmVudHMgJiYgdGhpcy5wbGF5aW5nICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMucGxheWluZyA9IHRydWVcbiAgICAgICAgX3BsYXlIb29rLmNhbGwodGhpcywgdHJ1ZSlcbiAgICB9IGVsc2UgaWYodGhpcy5fX3BhdXNlZCAmJiB0aGlzLmV2ZW50cy5wcm9ncmVzcykge1xuICAgICAgdGhpcy5wbGF5aW5nID0gdHJ1ZVxuICAgICAgX3Byb2dyZXNzLmNhbGwodGhpcyx0aGlzLmV2ZW50cy5wcm9ncmVzcylcbiAgICB9XG4gICAgdGhpcy5fX3BhdXNlZCA9IG51bGxcbiAgICA7KHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikucGxheS5jYWxsKHRoaXMsIHRydWUpXG4gIH1cbiwgJ3BhdXNlJywgZnVuY3Rpb24oaWdub3JlKSB7XG5cbiAgICBpZihpZ25vcmUpIHRoaXMuaWdub3JlZXZlbnRzID0gdHJ1ZVxuXG4gICAgaWYgKCF0aGlzLmlnbm9yZWV2ZW50cyAmJiB0aGlzLnBsYXlpbmcgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnBsYXlpbmcgPSBmYWxzZVxuICAgICAgX3BsYXlIb29rLmNhbGwodGhpcywgZmFsc2UpXG4gICAgICBpZih0aGlzLmV2ZW50cy5wYXVzZSkge1xuICAgICAgICB0aGlzLmV2ZW50cy5wYXVzZS5fdmFsLmNhbGwodGhpcylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jbGVhclByb2dyZXNzKClcbiAgICB9XG5cbiAgICB0aGlzLl9fcGF1c2VkID0gdHJ1ZVxuICAgIDsodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5wbGF5LmNhbGwodGhpcywgZmFsc2UpXG4gIH1cbiwgJ3RvZ2dsZScsIGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICh0aGlzLnBsYXlpbmcpIHtcbiAgICAgIHRoaXMucGF1c2UoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBsYXkoKVxuICAgIH1cbiAgfVxuLCAndXBkYXRlVGltZScsIGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZpcnN0VCA9IGZhbHNlXG4gICAgZXhwb3J0cy5zZXRUaW1lLmNhbGwodGhpcywgdGhpcy50aW1lKVxuICB9XG4sICdnZXRUaW1lJywgZnVuY3Rpb24oKSB7XG5cbiAgICAvLyBjb25zb2xlLmVycm9yKHRoaXMuaXNTZWVraW5nKVxuXG4gICAgcmV0dXJuIHRoaXMuaXNTZWVraW5nIFxuICAgICAgfHwgKHRoaXMucmVuZGVyZWQgJiYgdGhpcy5wbGF5ZXIgXG4gICAgICB8fCB2aWRlby5wbGF5ZXIpLnRpbWUuZ2V0LmNhbGwodGhpcywgdGhpcy50aW1lKSBcbiAgICAgIHx8IDBcbiAgfVxuLCAnZ2V0QnVmZmVyJywgZnVuY3Rpb24odmFsKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlbmRlcmVkICYmIHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikuYnVmZmVyLmNhbGwodGhpcywgdmFsIHx8IDApXG4gIH1cbiwgJ2NsZWFyUHJvZ3Jlc3MnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcHJvZ3Jlc3MpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgdGhhdCBwcm9ncmVzcycpXG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3Byb2dyZXNzKVxuICAgICAgdGhpcy5fcHJvZ3Jlc3MgPSBudWxsXG4gICAgICB2YXIgcHIgPSAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5wcm9ncmVzc1xuICAgICAgaWYgKHByICYmIHByLnJlbW92ZSkgcHIucmVtb3ZlLmNhbGwodGhpcylcbiAgICB9XG4gIH1cbilcblxuYmFzZS5leHRlbmQoXG57IG5hbWU6ICdwbGF5ZXInXG4sIHR5cGU6IGZhbHNlXG4sIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgdXRpbC5zZXRzdG9yZS5jYWxsKHRoaXMpXG4gICAgdGhpcy5fXy5wbGF5ZXIgPSB2YWxcbiAgICBpZiAodmFsLmVsZW1lbnQpIHRoaXMubm9kZSA9IHZhbC5lbGVtZW50XG4gICAgaWYgKHRoaXMuX2NsYXNzKSB0aGlzLl9jbGFzcy5wcm90b3R5cGUuXy5wbGF5ZXIgPSB2YWxcbiAgfVxuLCBnZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHJldHVybiB1dGlsLmdldFN0b3JlLmNhbGwodGhpcywgJ3BsYXllcicpIHx8IHZpZGVvLnBsYXllciB8fCB7fVxuICB9XG59XG4sIFxueyBuYW1lOiAnZHVyYXRpb24nXG4sIHNldDogZnVuY3Rpb24odmFsKSB7fVxuLCBnZXQ6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhbC5fb3ZlcndyaXRlID0gKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikuZHVyYXRpb24uY2FsbCh0aGlzLCB2YWwpXG4gICAgcmV0dXJuIHZhbFxuICB9XG59XG4sXG57XG4gIG5hbWU6JyRwbGF5aW5nJ1xuLCBzZXQ6ZnVuY3Rpb24oIHZhbCApIHtcbiAgICAvL3N0YW1wIGluZm9cbiAgICAvLyBpZiggdGhpcy5yZW5kZXJlZCApIC8vVE9ETyBhdm9pZCBoZWF2eSBjaGVja1xuICAgIC8vIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJyEhISEhISEhISEhc2V0ICRwbGF5aW5nJywgdmFsLnZhbClcbiAgICAgIGlmKCB2YWwudmFsIClcbiAgICAgIHtcbiAgICAgICAgdGhpcy5wbGF5KClcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICB9XG4gICAgLy8gfVxuICB9XG59XG4sIFxueyBuYW1lOiAndGltZSdcbiwgc2V0OiBcbiAgKGV4cG9ydHMuc2V0VGltZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmICghdGhpcy5faWdub3JlKSB7XG5cblxuICAgICAgdmFsLl9vdmVyd3JpdGUgPSBudWxsXG4gICAgXG4gICAgICB2YXIgdiA9IHZhbC52YWxcbiAgICAgICAgLCBpID0gZmFsc2VcblxuICAgICAgaWYgKHYgIT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIXRoaXMuX2ZpcnN0VCB8fCB0aGlzLl9mb3JjZVRpbWUgPT09IHRydWUpIHsgXG4gICAgICAgICAgdiA9IE1hdGguYWJzKHYpXG4gICAgICAgICAgaSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fZmlyc3RUID0gdHJ1ZVxuICAgICAgICAgIHRoaXMuX2ZvcmNlVGltZSA9IG51bGxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2ID49IDApIHtcblxuXG5cbiAgICAgICAgICBpZih0aGlzLmR1cmF0aW9uKXtcbiAgICAgICAgICAgIHRoaXMuaXNTZWVraW5nID0gdlxuXG4gICAgICAgICAgICAvLyBpZihwbGF5aW5nKSB0aGlzLnBhdXNlKClcblxuICAgICAgICAgICAgaWYodGhpcy5fX2xwKSB0aGlzLl9fbHAgPSBudWxsXG4gICAgICAgICAgICA7KHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikudGltZS5zZXQuY2FsbCh0aGlzLCB2ICogdGhpcy5kdXJhdGlvbi52YWwpXG4gICAgICAgICAgICBpZih0aGlzLmV2ZW50cy5zZWVraW5nICYmICFpKSAgdGhpcy5ldmVudHMuc2Vla2luZy5fdmFsLmNhbGwodGhpcyx2KVxuXG4gICAgICAgICAgICB0aGlzLnJlc3VtZVBsYXkoKVxuXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjYW5cXCd0IHNldCB0aW1lLCBubyBkdXJhdGlvbiBkZWZpbmVkIScpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgXG5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICB9KVxufVxuLCBcbnsgYXV0b3BsYXk6IGZ1bmN0aW9uKHZhbCkge1xuICAgICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLmF1dG9wbGF5LmNhbGwodGhpcywgdmFsKVxuICB9XG4sIGxvb3A6IGZ1bmN0aW9uKHZhbCkge1xuICAgICh0aGlzLnBsYXllciB8fCB2aWRlby5wbGF5ZXIpLmxvb3AuY2FsbCh0aGlzLCB2YWwpXG4gIH1cbiwgdm9sdW1lOiBmdW5jdGlvbih2YWwpIHtcbiAgICAodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS52b2x1bWUuY2FsbCh0aGlzLCB2YWwpXG4gIH1cbiwgc3JjOiBmdW5jdGlvbih2YWwpIHtcbiAgICBpZih2YWwudmFsIT09dGhpcy5fX19TcmMpIHtcbiAgICAgIHRoaXMuX19fU3JjID0gdmFsLnZhbFxuICAgICAgaWYodGhpcy5ldmVudHMuc3JjKSAgdGhpcy5ldmVudHMuc3JjLl92YWwuY2FsbCh0aGlzLHZhbClcbiAgICAgIDsodGhpcy5wbGF5ZXIgfHwgdmlkZW8ucGxheWVyKS5zcmMuY2FsbCh0aGlzLCB2YWwpXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCchISEhISEhISEhIXNldCBzcmMnKVxuXG4gICAgICBpZih0aGlzLiRwbGF5aW5nLnZhbCA9PT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnBsYXkoKVxuICAgICAgfVxuXG4gICAgfVxuICB9XG59XG4sIFxueyBuYW1lOiAnZXZlbnRzJ1xuLCBcIm5ld1wiOiBmdW5jdGlvbigpIHtcbiAgICAvL2RlemUgZnVuY3RpZSBrdW5uZW4gaW5zdGVsbGVuXG4gICAgaWYoICAodGhpcy5wbGF5ZXIgJiYgdGhpcy5wbGF5ZXIuc2V0RXZlbnRzICE9PSBmYWxzZSkpIHtcbiAgICAgIF92aWRFdmVudHMuY2FsbCh0aGlzLCB0aGlzLmV2ZW50cylcbiAgICB9XG4gIH1cbiwgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICBpZih0aGlzLnJhZklkKVxuICAgIHsgXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yYWZJZClcbiAgICAgIHRoaXMucmFmSWQgPSBudWxsXG4gICAgfVxuICAgIF9yZW1vdmVWaWRFdmVudHMuY2FsbCh0aGlzLCB0aGlzLmV2ZW50cylcbiAgfVxuLCBzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuLy8gICBjb25zb2xlLmxvZygnRVZFTlRTIScpXG4gICAgXG4gICAgdmFyIGEgPSB1dGlsLmFyZyhhcmd1bWVudHMpXG4gICAgXG4gICAgICBhWzVdID0gdGhpcy5fcmVhZHlGb3JFdmVudHMgXG4gICAgICAgICAgID8gX3ZpZEV2ZW50cy5jYWxsKHRoaXMsIHZhbCkgXG4gICAgICAgICAgIDogKHRoaXMucGxheWVyIHx8IHZpZGVvLnBsYXllcikuZXZlbnRzIFxuXG4gICAgICBpZighYVs1XS5zZWVraW5nKSBhWzVdLnNlZWtpbmcgPSB7c2V0OmZhbHNlfVxuICAgICAgaWYoIWFbNV0uc3JjKSBhWzVdLnNyYyA9IHtzZXQ6ZmFsc2V9XG4gICAgXG4gICAgZXZlbnRzLl9zZXQuYXBwbHkodGhpcywgYSlcbiAgfVxufSlcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cbmV4cG9ydHMudGltZSA9IGZ1bmN0aW9uKHRpbWUsIGRlY2ltYWxzKSB7XG4gIHZhciBocnMgPSB+fiAodGltZSAvIDM2MDApLFxuICAgIG1pbnMgPSB+fiAoKHRpbWUgJSAzNjAwKSAvIDYwKSxcbiAgICBzZWNzID0gZGVjaW1hbHMgPyAodGltZSAlIDYwKS50b0ZpeGVkKGRlY2ltYWxzKSA6IH5+KHRpbWUgJSA2MCk7XG4gIHJldCA9IFwiXCI7XG4gIGlmIChocnMgPiAwKSByZXQgKz0gXCJcIiArIGhycyArIFwiOlwiICsgKG1pbnMgPCAxMCA/IFwiMFwiIDogXCJcIik7XG4gIHJldCArPSBcIlwiICsgbWlucyArIFwiOlwiICsgKHNlY3MgPCAxMCA/IFwiMFwiIDogXCJcIik7XG4gIHJldCArPSBcIlwiICsgc2VjcztcbiAgcmV0dXJuIHJldCB8fCAwO1xufTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG52YXIgZXZlbnRzID0gcmVxdWlyZSgnLi8nKVxuICAsIG9wZXJhdG9ycyA9IHJlcXVpcmUoJy4uLy4uL3ZhbHVlL29wZXJhdG9ycycpXG4gICwgZG9jID0gZXZlbnRzLmRvY3VtZW50XG5cbm1vZHVsZS5leHBvcnRzID0gZXZlbnRzXG5cbm9wZXJhdG9ycy5fZSA9IGZ1bmN0aW9uKHZhbCwgb3BlcmF0b3IpIHtcbiAgcmV0dXJuIHZhbCArIG9wZXJhdG9yXG59XG5cbm9wZXJhdG9ycy5fZXN1YiA9IGZ1bmN0aW9uKHZhbCwgb3BlcmF0b3IpIHtcbiAgcmV0dXJuIHZhbCAtIG9wZXJhdG9yXG59XG5cbm9wZXJhdG9ycy5fZS5vcmRlciA9IDNcbiAgXG5mdW5jdGlvbiBjaG9vc2VNb3ZlICh2YWwsIG1ldGhvZCkge1xuICByZXR1cm4gdmFsLm1vdmUgJiYgdmFsLm1vdmUuX3ZhbCBcbiAgICB8fCAhbWV0aG9kLl9fdCAmJiBtZXRob2QgIT09IHRydWUgJiYgbWV0aG9kIFxuICAgIHx8IG1ldGhvZC5fdmFsO1xufVxuXG5mdW5jdGlvbiBkcmFnIChlLCBtZXRob2QsIHZhbCkge1xuICB2YXIgdCA9IHZhbC5iaW5kID8gdmFsLmJpbmQuX3ZhbCA6IHRoaXNcbiAgICAsIG1vdmUgPSBjaG9vc2VNb3ZlKHZhbCwgbWV0aG9kKVxuICAgICwgaWQgPSAnZHJhZydcbiAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gIGlmIChtb3ZlKSBkb2MuYWRkRXZlbnQoJ21vdmUnLCBmdW5jdGlvbihlKSB7XG4gICAgbW92ZS5jYWxsKHQsIGUsIHZhbClcbiAgfSwgaWQpXG5cbiAgaWYgKHZhbC5kb3duKSB2YWwuZG93bi5fdmFsLmNhbGwodCwgZSwgdmFsKVxuICBcbiAgZG9jLmFkZEV2ZW50KCd1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodmFsLnVwKSB2YWwudXAuX3ZhbC5jYWxsKHQsIGUsIHZhbClcbiAgICBkb2MucmVtb3ZlRXZlbnQoZmFsc2UsIGlkKVxuICB9LCBpZClcbn1cblxuZnVuY3Rpb24gYWN0aXZlIChlLCBtZXRob2QsIHZhbCkge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGlkID0gJ2FjdGl2ZSdcbiAgICAsIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLmNzcyA9IHthZGRDbGFzczp2YWwuX3ZhbH1cbiAgICAgICAgdGltZXIgPSBudWxsXG4gICAgICB9LDUwKVxuXG4gIGlmKGV4cG9ydHMuX2RlYWN0aXZhdGUpIGV4cG9ydHMuX2RlYWN0aXZhdGUoKVxuXG4gIGV4cG9ydHMuX2RlYWN0aXZhdGUgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRpbWVyKSBjbGVhclRpbWVvdXQodGltZXIpXG4gICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLGlkKVxuICAgIGV4cG9ydHMuX2RlYWN0aXZhdGUgPSBudWxsXG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgICAgaWYoIXNlbGYpIHJldHVyblxuICAgICAgaWYoIXNlbGYuX3N0YXlBY3RpdmUpIHNlbGYuY3NzID0ge3JlbW92ZUNsYXNzOnZhbC5fdmFsfVxuICAgICAgZWxzZSBzZWxmLmNzcyA9IHthZGRDbGFzczp2YWwuX3ZhbH1cbiAgICB9KVxuICB9XG5cbiAgZG9jLmFkZEV2ZW50KCdtb3ZlJyxleHBvcnRzLl9kZWFjdGl2YXRlLGlkKVxuICBkb2MuYWRkRXZlbnQoJ3VwJyxleHBvcnRzLl9kZWFjdGl2YXRlLGlkKVxufVxuXG5mdW5jdGlvbiBzaGFsbG93UmF3ICh2b2JqKSB7XG4gIHZhciBvYmogPSB7fVxuICAgICwga2V5cyA9IHZvYmoua2V5c1xuICAgICwga2V5XG4gICAgLCBpID0ga2V5cy5sZW5ndGggLSAxXG4gIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGtleXNbaV1cbiAgICBvYmpba2V5XSA9IHZvYmpba2V5XVxuICB9XG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gaW5pdEdyYWIgKHQsIGUsIHZhbCwgbmFtZSkge1xuICBpZiAoIXRbbmFtZV0gfHwgIXRbbmFtZV0uX2UpIHRbbmFtZV0gPSB7IF9lOiAwIH1cbiAgaWYgKHZhbFtuYW1lXS5fdmFsICE9PSB0cnVlKSB0W25hbWVdLnNldCgnX2UnLCBzaGFsbG93UmF3KHZhbFtuYW1lXSkpXG4gIHJldHVybiBlW25hbWVdIC0gKHRbbmFtZV0uX2UudmFsKVxufVxuXG5mdW5jdGlvbiBncmFiIChlLCBtZXRob2QsIHZhbCwgbmVzdGVkKSB7XG4gIHZhciB0ID0gdmFsLmJpbmQgJiYgIW5lc3RlZCA/IHZhbC5iaW5kLnZhbCA6IHRoaXNcbiAgICAsIGlkID0gKCB2YWwueSBcbiAgICAgID8gJ3knIFxuICAgICAgOiB2YWwueCBcbiAgICAgICAgPyAneCcgXG4gICAgICAgIDogJ3h5JykgXG4gICAgICAgICsgJ0dyYWInIFxuICAgICAgICArIChuZXN0ZWQgfHwgJycpXG4gIGlmICh0KSB7XG4gICAgaWYgKHQuX25vZGUpIHtcbiAgICAgIHZhciBtb3ZlID0gY2hvb3NlTW92ZSh2YWwsIG1ldGhvZClcbiAgICAgICAgLCBzdGFydFggPSBlLnhcbiAgICAgICAgLCBzdGFydFkgPSBlLnlcbiAgICAgICAgLCByZWFkeVxuICAgICAgICAsIGNYXG4gICAgICAgICwgY1lcbiAgICAgICAgLCBvbGRYXG4gICAgICAgICwgb2xkWVxuICAgICAgICAsIG5ld1ggPSBzdGFydFhcbiAgICAgICAgLCBuZXdZID0gc3RhcnRZXG4gICAgICAgICwgcGFzc1xuICAgICAgICAsIHVwRm4gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB0LnguX3AgPSBmYWxzZVxuICAgICAgICAgICAgdC55Ll9wID0gZmFsc2VcbiAgICAgICAgICAgIGlmICh2YWwudXAgJiYgcGFzcykge1xuICAgICAgICAgICAgICB2YWwudXAuX3ZhbC5jYWxsKHQsIGUsIHtcbiAgICAgICAgICAgICAgICB4OiBuZXdYIC0gc3RhcnRYLFxuICAgICAgICAgICAgICAgIHk6IG5ld1kgLSBzdGFydFlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgeyB4OiBuZXdYIC0gb2xkWFxuICAgICAgICAgICAgICAsIHk6IG5ld1kgLSBvbGRZXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudHMuY2xpY2suYmxvY2sgPSBmYWxzZVxuICAgICAgICAgICAgZG9jLnJlbW92ZUV2ZW50KGZhbHNlLCBpZClcbiAgICAgICAgICB9XG4gICAgICBpZiAoIXZhbC54ICYmICF2YWwueSl7IC8vdGhpcyBuZWVkcyByZXZpc2lvblxuICAgICAgICB2YWwueCA9IHtfdmFsOiB0cnVlfVxuICAgICAgICB2YWwueSA9IHtfdmFsOiB0cnVlfVxuICAgICAgfVxuICAgICAgaWYgKHZhbC5kb3duKSB2YWwuZG93bi5fdmFsLmNhbGwodCwgZSwgdmFsKTtcbiAgICAgIGRvYy5hZGRFdmVudCgnbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgb2xkWCA9IG5ld1hcbiAgICAgICAgb2xkWSA9IG5ld1lcbiAgICAgICAgbmV3WCA9IGUueFxuICAgICAgICBuZXdZID0gZS55XG5cbiAgICAgICAgZXZlbnRzLmNsaWNrLmJsb2NrID0gdHJ1ZVxuXG4gICAgICAgIGlmICghcmVhZHkpIHtcbiAgICAgICAgICBwYXNzID0gdmFsLnBhc3MgPyB2YWwucGFzcy5fdmFsLmNhbGwodCwgZSwge1xuICAgICAgICAgICAgeDogbmV3WCAtIHN0YXJ0WCxcbiAgICAgICAgICAgIHk6IG5ld1kgLSBzdGFydFlcbiAgICAgICAgICB9KSA6IHRydWVcbiAgICAgICAgICBpZighcGFzcykge1xuICAgICAgICAgICAgdXBGbihlKVxuICAgICAgICAgICAgbW92ZSA9IGZhbHNlXG4gICAgICAgICAgICBkb2MucmVtb3ZlRXZlbnQoZmFsc2UsIGlkKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIGlmICh2YWwueCkge1xuICAgICAgICAgICAgICBjWCA9IGluaXRHcmFiKHQsIGUsIHZhbCwgJ3gnKVxuICAgICAgICAgICAgICB0LnguX3AgPSAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsLnkpIHtcbiAgICAgICAgICAgICAgY1kgPSBpbml0R3JhYih0LCBlLCB2YWwsICd5JylcbiAgICAgICAgICAgICAgdC55Ll9wID0gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbC5zdGFydCkgdmFsLnN0YXJ0Ll92YWwuY2FsbCh0LCBlLCB2YWwpXG4gICAgICAgICAgICByZWFkeSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKSAvL2ZvciBhbmRyb2lkXG4gICAgICAgICAgaWYgKGNYKSB0LnggPSB7IF9lOiBuZXdYIC0gY1ggfVxuICAgICAgICAgIGlmIChjWSkgdC55ID0geyBfZTogbmV3WSAtIGNZIH1cbiAgICAgICAgICBpZiAobW92ZSkgbW92ZS5jYWxsKHQsIGUsIHtcbiAgICAgICAgICAgICAgeDogbmV3WCAtIHN0YXJ0WCxcbiAgICAgICAgICAgICAgeTogbmV3WSAtIHN0YXJ0WVxuICAgICAgICAgICAgfSx2YWwpIC8vY2hlY2sgZm9yIHNwZWVkXG4gICAgICAgIH1cbiAgICAgIH0sIGlkKVxuICAgICAgZG9jLmFkZEV2ZW50KCd1cCcsIHVwRm4sIGlkKVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBncmFiLmNhbGwodFtpXSwgZSwgbWV0aG9kLCB2YWwsIGkgKyAxKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLy9hZGQgdGhlIGV2ZW50c1xuZXZlbnRzLmRyYWcgPSB7IHZhbDogeyBkb3duOiBkcmFnIH0gfVxuZXZlbnRzLmdyYWIgPSB7IHZhbDogeyBkb3duOiBncmFiIH0gfVxuZXZlbnRzLmFjdGl2ZSA9IHsgdmFsOiB7IGRvd246IGFjdGl2ZSB9IH0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZXZlbnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpXG4gICwgY2FzZXMgPSByZXF1aXJlKCcuLi9jYXNlcycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIHVhID0gcmVxdWlyZSgnLi4vdWEnKVxuXG5jYXNlcy4kaGFzVG91Y2ggPVxuKCAoICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyApXG4gIHx8IHdpbmRvdy5Eb2N1bWVudFRvdWNoXG4gICYmIGRvY3VtZW50IGluc3RhbmNlb2YgRG9jdW1lbnRUb3VjaFxuKVxufHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHNcbnx8IGZhbHNlXG5cbmZ1bmN0aW9uIF9iYXNpYyhlLCBtZXRob2QsIHZhbCkge1xuICBlLnggPSBlLnBhZ2VYXG4gIGUueSA9IGUucGFnZVlcbiAgbWV0aG9kLmNhbGwodGhpcywgZSwgdmFsKVxufVxuXG51dGlsLmRlZmluZVxuKCBldmVudHNcbiwgJ19vdXQnXG4sIHsgdmFsdWU6IFtdIH1cbilcbi8vY2xpY2tvdXQgY2Fubm90IGJlIHVzZWQgdG8gY3JlYXRlIGNvbXBsZXggZXZlbnRzISBpdCdzIHRvbyBjdXN0b20gXG4vL3RyaWVkIHRvIGZpeFxuXG5mdW5jdGlvbiBrZXlCb2FyZEV2ZW50KCBuYW1lLCBkb21FdmVudCwgd3JhcHBlciApIHtcblxuICB2YXIgX25hbWUgPSAnXycrbmFtZVxuXG4gIHV0aWwuZGVmaW5lKCBldmVudHMsIF9uYW1lLCB7IHZhbHVlOltdIH0gKVxuXG4gIHZhciBldmVudCA9IFxuICB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiggZmllbGQsIGZyb20gKSB7XG4gICAgICB2YXIgZXhlYyA9IGZ1bmN0aW9uKCBlICkge1xuXG4gICAgICAgIC8vZGl0IGdhYXQgaGVlbCBzbmVsIGZvdXQgaGllcm9cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ251IGZmIG9vayBkZSB3cmFwcGVyIGNhbGxlbiEnLCBmaWVsZCwgZnJvbSwgZXZlbnRzW2Zyb21dKVxuICAgICAgICAgaWYoIHRoaXMucmVuZGVyZWQgKSB7XG5cbiAgICAgICAgICBpZiggd3JhcHBlciApIHtcbiAgICAgICAgICAgIHdyYXBwZXIuY2FsbCh0aGlzLCBlLCB0aGlzLmV2ZW50c1tmcm9tXS5fdmFsIClcbiAgICAgICAgICAgIC8vdGhpcy5ldmVudHNbZnJvbV0uX3ZhbC5jYWxsKHRoaXMsIGUpXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIGV2ZW50c1tmcm9tXSAmJiBldmVudHNbZnJvbV0udmFsKSB7XG4gICAgICAgICAgICB2YXIgbWV0aG9kID0gZXZlbnRzW2Zyb21dLnZhbFxuICAgICAgICAgICAgZm9yKHZhciBpIGluIGV2ZW50c1tmcm9tXSkge1xuICAgICAgICAgICAgICBpZiggY2FzZXNbaV0pIHtcbiAgICAgICAgICAgICAgICBtZXRob2QgPSBldmVudHNbZnJvbV1baV1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0aG9kID0gbWV0aG9kW2ZpZWxkXVxuICAgICAgICAgICAgaWYoIG1ldGhvZCApIHtcbiAgICAgICAgICAgICAgbWV0aG9kLmNhbGwodGhpcywgZSwgdGhpcy5ldmVudHNbZnJvbV0uX3ZhbCApXG4gICAgICAgICAgICB9IFxuICAgICAgICAgIH0gZWxzZSBpZiggdGhpcy5ldmVudHNbZnJvbV0gKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tmcm9tXS5fdmFsLmNhbGwodGhpcywgZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnRzLmRvY3VtZW50LmFkZEV2ZW50KCBkb21FdmVudCwgZnVuY3Rpb24oZSkge1xuXG4gICAgICAgIGZvciAoIHZhciBhcnIgPSBldmVudHNbIF9uYW1lIF0sIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKSB7XG4gICAgICAgICAgZXhlYy5jYWxsKCBhcnJbaV0sIGUgKVxuICAgICAgICAgIFxuICAgICAgICAgIGlmKCBhcnJbaV0gKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJ2RvIGl0IG5vdyEnLCBfbmFtZSwgYXJyLCBhcnJbaV0sIGUpXG4gICAgICAgICAgICBhcnJbaV0uZWFjaEluc3RhbmNlKCBleGVjLCAnZXZlbnRzJywgZSApXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgIH0sIG5hbWUgKVxuICAgIH0sXG4gICAgYWRkOiBmdW5jdGlvbiggaWQsIGZpZWxkICkge1xuXG4gICAgICBmaWVsZCA9IF9uYW1lXG5cbiAgICAgIHRoaXMuc2V0U2V0dGluZyhcbiAgICAgIHsgbmFtZTogZmllbGRcbiAgICAgICwgcmVtb3ZlOiBldmVudHNbIG5hbWUgXS5yZW1vdmVcbiAgICAgIH0pXG5cbiAgICAgIGlmICggIXV0aWwuY2hlY2tBcnJheSggZXZlbnRzWyBfbmFtZSBdLCB0aGlzICkgKSBcbiAgICAgIHtcbiAgICAgICAgZXZlbnRzWyBfbmFtZSBdLnB1c2godGhpcylcbiAgICAgIH1cblxuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdXUk9OR1dST05HV1JPTkchISEhIScsIF9uYW1lLCBldmVudHNbX25hbWVdLCBldmVudHMpXG4gICAgICAvL3NlbGVjdGVkIG1vZXQgbWlzY2hlaW4gYWxsZWVuIHZhbnVpdCBWYWx1ZSAkZm9jdXNlZCAtLSBuaWV0IG9wIGVsayBpdGVtIG9wIGtleSB1cC4uLi5cbiAgICAgIC8vZG9lIGRpdCBzbWFydCAtLSBmb3Igbm93IHpvdSBhdXRvIHJlbW92ZSBrdW5uZW4gZG9lbiBhbHMgaWV0cyBlciBuaWV0IG1lZXIgaXM/XG4gICAgICB2YXIgaW5kZXggPSB1dGlsLmNoZWNrQXJyYXkoIGV2ZW50c1sgX25hbWUgXSwgdGhpcywgdHJ1ZSApIFxuICAgICAgaWYoIH5pbmRleCApIHtcblxuICAgICAgICB2YXIgbm9SZW1vdmVcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygndGhpczonLCB0aGlzIClcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2Zyb20gYmFzZTonLCB0aGlzLl9mcm9tLmJhc2UpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdldmVudCBuYW1lOicsIG5hbWUpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdldmVudHM6JywgdGhpcy5ldmVudHMgKVxuICAgICAgICBpZih0aGlzLmV2ZW50cyAmJiB0aGlzLl9mcm9tLmJhc2UuZXZlbnRzKSB7IFxuICAgICAgICAgIG5vUmVtb3ZlID0gdGhpcy5ldmVudHNbbmFtZV0gPT09IHRoaXMuX2Zyb20uYmFzZS5ldmVudHNbbmFtZV1cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZXZlbnRzIGVxdWFscyBjbGFzczonLCBub1JlbW92ZSApXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignbm8gbmljZSBldmVudHMnKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZighbm9SZW1vdmUpIHtcbiAgICAgICAgICBldmVudHNbIF9uYW1lIF0uc3BsaWNlKCBpbmRleCwgMSApXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2cobm9SZW1vdmUsICdub1JlbW92ZSBldm50LCBhcmUgd2Ugc3VyZSAtIGZpeCB0aGlzIGFzYXAnKVxuICAgICAgICB9XG4gICAgICAgIC8vIGRlYnVnZ2VyXG4gICAgICAgIC8vIHRoaXMucmVtb3ZlU2V0dGluZyggbmFtZSApIC0tLSByZWRvIHRoaXMgbGF0ZXJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBldmVudHNbIG5hbWUgXSA9IGV2ZW50XG5cbn1cblxuZXZlbnRzLiRtYWtlS2V5Qm9hcmRFdmVudCA9IGtleUJvYXJkRXZlbnRcblxua2V5Qm9hcmRFdmVudCggJ2tleWJvYXJkJywgJ2tleXVwJyApXG5rZXlCb2FyZEV2ZW50KCAna2V5Ym9hcmREb3duJywgJ2tleWRvd24nIClcbmtleUJvYXJkRXZlbnQoICdrZXlib2FyZERvd24kZG93bicsICdrZXlkb3duJyApXG5rZXlCb2FyZEV2ZW50KCAna2V5Ym9hcmREb3duJGNsaWNrJywgJ2tleWRvd24nIClcblxuLy8tLS0tLWRpdCBmZiBlY2h0IGdvZWQgZml4ZW4hXG5cbmZ1bmN0aW9uIGJhc2ljRG93bihlLCBtZXRob2QsIHZhbCkge1xuICBpZiggZS53aGljaCE9PTEgfHwgZXZlbnRzLmRvd24uYmxvY2sgKSByZXR1cm5cbiAgIF9iYXNpYy5jYWxsKHRoaXMsZSwgbWV0aG9kLCB2YWwpXG59XG5cbmV2ZW50cy5kb3duID1cbnsgJGhhc1RvdWNoOlxuICB7IHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUsIG1ldGhvZCwgdmFsKSB7XG4gICAgICBpZihldmVudHMuZG93bi5ibG9jaykgcmV0dXJuXG4gICAgICB2YXIgdGFyZ2V0VG91Y2hlcyA9IGUudGFyZ2V0VG91Y2hlc1swXSB8fCB7fVxuICAgICAgZS54ID0gdGFyZ2V0VG91Y2hlcy5wYWdlWFxuICAgICAgZS55ID0gdGFyZ2V0VG91Y2hlcy5wYWdlWVxuICAgICAgbWV0aG9kLmNhbGwodGhpcywgZSwgdmFsKVxuICAgIH1cbiAgfVxuLCB2YWw6IHsgbW91c2Vkb3duOiBiYXNpY0Rvd24gfVxuLy8gLCB0djogXG4vLyAgIHsgIC8vIG1vdXNlZG93bjogYmFzaWNEb3duIC8vY29tYmluZXJlbiBiaW5uZW4ga29ydCBtb2V0IHZvb3IgTEdcbi8vICAgICAga2V5Ym9hcmREb3duJGRvd246IGZ1bmN0aW9uKCBlLCBtZXRob2QsIHZhbCApIHtcbi8vICAgICAgIC8vdGhpcy5fJGZvY3VzZWQgJiYgXG4vLyAgICAgICBpZiggdGhpcy5fJGZvY3VzZWQgJiYgdXRpbC5jaGVja0FycmF5KCBbIDEzLCAyOTQ0MyBdICwgZS5rZXlDb2RlICkgIT09IGZhbHNlICkgXG4vLyAgICAgICB7XG4vLyAgICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbi8vICAgICAgIH1cblxuLy8gICAgIH1cbi8vICAgfVxufVxuXG4vL3JpZ2h0LWRvd25cbmV2ZW50cy5yZG93biA9XG57ICRoYXNUb3VjaDpcbiAgeyB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLzIgZmluZ2Vycz9cbiAgICB9XG4gIH1cbiwgdmFsOlxuICB7IG1vdXNlZG93bjogZnVuY3Rpb24gKGUsIG1ldGhvZCwgdmFsKSB7XG4gICAgICBpZihlLndoaWNoPT09Mykge1xuICAgICAgICBkb2N1bWVudC5vbmNvbnRleHRtZW51ID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAvLyBlLnJkb3duID0gdHJ1ZVxuICAgICAgICBfYmFzaWMuY2FsbCh0aGlzLGUsbWV0aG9kLHZhbClcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZG9jdW1lbnQub25jb250ZXh0bWVudSA9IGZhbHNlIH0sIDApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vbW92ZVxuZXZlbnRzLm1vdmUgPSB7XG4gICRoYXNUb3VjaDpcbiAgeyB0b3VjaG1vdmU6IGZ1bmN0aW9uIChlLCBtZXRob2QsIHZhbCkge1xuICAgICAgdmFyIHRhcmdldFRvdWNoZXMgPSBlLnRhcmdldFRvdWNoZXNbMF1cbiAgICAgIGUueCA9IHRhcmdldFRvdWNoZXMucGFnZVhcbiAgICAgIGUueSA9IHRhcmdldFRvdWNoZXMucGFnZVlcbiAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbiAgICAgIC8vIGRvY3VtZW50LndyaXRlKGUudGFyZ2V0VG91Y2hlc1swXS5wYWdlWCk7XG4gICAgfVxuICB9XG4gICwgdmFsOiB7XG4gICAgbW91c2Vtb3ZlOiBfYmFzaWNcbiAgfVxufVxuXG4vL3VwXG5ldmVudHMudXAgPSB7XG4gIC8va2V5VXBcbiAgJGhhc1RvdWNoOiB7XG4gICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUsIG1ldGhvZCwgdmFsKSB7XG4gICAgICB2YXIgY3QgPSBlLmNoYW5nZWRUb3VjaGVzXG4gICAgICBlLnggPSBjdFswXS5wYWdlWFxuICAgICAgZS55ID0gY3RbMF0ucGFnZVlcbiAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbiAgICB9XG4gIH1cbiwgdmFsOiB7XG4gICAgbW91c2V1cDogX2Jhc2ljXG4gIH1cbn1cblxuLy9jbGlja1xuZXZlbnRzLmNsaWNrID0ge1xuICAvLyB0djoge1xuICAvLyAgIGtleWJvYXJkRG93biRjbGljazogZnVuY3Rpb24oZSwgbWV0aG9kLCB2YWwgKSB7XG5cbiAgLy8gICAgIGlmKCB0aGlzLl8kZm9jdXNlZCAmJiB1dGlsLmNoZWNrQXJyYXkoIFsgMTMsIDI5NDQzIF0gLCBlLmtleUNvZGUgKSAhPT0gZmFsc2UgKSB7XG4gIC8vICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGUsIHZhbClcbiAgLy8gICAgIH1cblxuICAvLyAgIH1cbiAgLy8gfSxcbiAgdmFsOiB7XG4gICAgZG93bjogZnVuY3Rpb24oZSwgbWV0aG9kLCB2YWwpIHtcblxuICAgICAgLy8gY29uc29sZS5sb2coJ0NMSUNLIElUIScpXG5cbiAgICAgIHZhciB0ID0gdGhpc1xuICAgICAgICAsIG5hbWUgPSAnY2xpY2snXG4gICAgICBpZighZXZlbnRzLmNsaWNrLmJsb2NrKXtcbiAgICAgICAgdC5hZGRFdmVudCgndXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgdC5yZW1vdmVFdmVudCgndXAnLCBuYW1lKVxuICAgICAgICAgIHZhciBtcyA9IGV2ZW50cy5fbWF5YmVzY3JvbGxcbiAgICAgICAgICBpZihtcyl7XG4gICAgICAgICAgICBpZihtcy5sZW5ndGgpIGV2ZW50cy5fbWF5YmVzY3JvbGwudW5zaGlmdChbbWV0aG9kLHRdKVxuICAgICAgICAgICAgZWxzZSBldmVudHMuX21heWJlc2Nyb2xsID0gW1ttZXRob2QsdF1dXG4gICAgICAgICAgfWVsc2UgaWYoIWV2ZW50cy5jbGljay5ibG9jaykgbWV0aG9kLmNhbGwodCwgZSwgdmFsKVxuICAgICAgICB9LCBuYW1lKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0LnJlbW92ZUV2ZW50KCd1cCcsIG5hbWUpXG4gICAgICAgIH0sIDMwMClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXZlbnRzLnJjbGljayA9IHtcbiAgdmFsOiB7XG4gICAgcmRvd246ZXZlbnRzLmNsaWNrLnZhbC5kb3duXG4gIH1cbn1cblxudmFyIF9vdXRSZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5kZXggPSB1dGlsLmNoZWNrQXJyYXkoZXZlbnRzLl9vdXQsIHRoaXMsIHRydWUpXG4gICAgaWYgKH5pbmRleCkge1xuICAgICAgZXZlbnRzLl9vdXQuc3BsaWNlKGluZGV4LCAxKVxuICAgICAgdGhpcy5yZW1vdmVTZXR0aW5nKCdfb3V0JywgX291dFNldHRpbmcpXG5cbiAgICAgIC8vIGRlYnVnZ2VyXG5cbiAgICB9XG4gIH1cbiwgX291dFNldHRpbmcgPSB7XG4gIG5hbWU6ICdfb3V0JyxcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXV0aWwuY2hlY2tBcnJheShldmVudHMuX291dCwgdGhpcykpIHtcbiAgICAgIGV2ZW50cy5fb3V0LnB1c2godGhpcylcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogX291dFJlbW92ZVxufVxuXG5ldmVudHMub3V0ID0ge1xuICBjcmVhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubSA9IHRydWU7XG4gICAgZXZlbnRzLmRvY3VtZW50LmFkZEV2ZW50KCd1cCcsIGZ1bmN0aW9uKGUpIHtcblxuICAgICAgdmFyIGJhc2UgPSBlLnRhcmdldCxcbiAgICAgICAgZXhlYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBwID0gYmFzZVxuICAgICAgICAgICAgLCB0XG4gICAgICAgICAgd2hpbGUgKHAgJiYgIXQpIHtcbiAgICAgICAgICAgIGlmIChwLmJhc2UgJiYgdGhpcyA9PT0gcC5iYXNlKSB7XG4gICAgICAgICAgICAgIHQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcCA9IHAucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0ICYmIHRoaXMucmVuZGVyZWQpIHRoaXMuZXZlbnRzLm91dC5fdmFsLmNhbGwodGhpcywgZSlcbiAgICAgICAgfVxuICAgICAgZm9yICh2YXIgYXJyID0gZXZlbnRzLl9vdXQsIGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgZXhlYy5jYWxsKGFycltpXSlcbiAgICAgICAgaWYgKGFycltpXSkgYXJyW2ldLmVhY2hJbnN0YW5jZShleGVjLCAnZXZlbnRzJylcbiAgICAgIH1cbiAgICB9LCdvdXQnKVxuICB9LFxuICBhZGQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0ID0gdGhpc1xuICAgICAvLyBldmVudHMuX291dC5wdXNoKHRoaXMpXG4gICAgdGhpcy5zZXRTZXR0aW5nKF9vdXRTZXR0aW5nKVxuICB9LFxuICByZW1vdmU6X291dFJlbW92ZVxufTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZWxlbWVudCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQnKVxuICAsIGNhc2VzID0gcmVxdWlyZSgnLi4vY2FzZXMnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJylcbiAgLCBGaWVsZFN0b3JlID0gZnVuY3Rpb24gKCkge31cblxudXRpbC5kZWZpbmUoRmllbGRTdG9yZSwgJ191aWQnLCB7IHZhbHVlOiAwIH0pXG5cbmV4cG9ydHMuX3IgPSB7fSAvL2xpc3Qgb2YgYmFzaWMgKHJhdykgZXZlbnRzIGUuZy4gJ21vdXNlZG93bidcblxuLy9yZW1vdmUgZXZlbnRzIGlmIHRoZXJlIGFyZSBubyBjaGlsZHJlbiB0aGF0IHVzZSB0aGVtIGFueW1vcmVcblxuZXhwb3J0cy5kb2N1bWVudCA9IG5ldyBlbGVtZW50KHsgbm9kZTogZG9jdW1lbnQgfSlcblxuZXhwb3J0cy5kb2N1bWVudC5leGVjID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuICBpZiggdGhpcy5fX2VbZXZlbnRdIClcbiAge1xuICAgIHZhciBhcmdzID0gdXRpbC5hcmcoIGFyZ3VtZW50cywgMSApXG4gICAgZm9yKCB2YXIgaSBpbiB0aGlzLl9fZVtldmVudF0gKVxuICAgIHtcbiAgICAgIHRoaXMuX19lW2V2ZW50XVtpXS5hcHBseSggdGhpcywgYXJncyApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGUoIGksIGZyb20gKSB7XG4gIGlmKCBleHBvcnRzW2ldIClcbiAge1xuICAgIC8vIGNvbnNvbGUubG9nKCdjb21wbGV4JywgaSwgZnJvbSlcbiAgICBfY3JlYXRlQ29tcGxleCggaSwgZnJvbSApXG4gIH1cbiAgZWxzZVxuICB7XG4gICAgLy8gY29uc29sZS5sb2coJ19iYXNpYycsIGkpXG5cbiAgICBleHBvcnRzW2ldID0geyBfYmFzaWM6IHRydWUgfVxuICAgIF9jcmVhdGVCYXNpYyggaSApXG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVdoaWxlIChpLCBtKSB7XG4gIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgdmFyIHBhcmVudCA9IGUudGFyZ2V0XG4gICAgICAsIGJhc2UsIGV2ZW50c1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGJhc2UgPSBwYXJlbnQuYmFzZVxuICAgICAgaWYgKGJhc2UpIHtcbiAgICAgICAgZXZlbnRzID0gYmFzZS5ldmVudHNcbiAgICAgICAgaWYgKGV2ZW50c1tpXSkge1xuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICBleHBvcnRzW2ldLl9tLmNhbGwoYmFzZSwgZSwgZXZlbnRzW2ldKVxuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW2ldLl92YWwpIHtcbiAgICAgICAgICAgIGV2ZW50c1tpXS5fdmFsLmNhbGwoYmFzZSwgZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGUucHJldmVudCkgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgZXZlbnRzID0gYmFzZS5fX2VcbiAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHNbaV0pIHtcblxuICAgICAgICAgIGZvciAodmFyIGogaW4gZXZlbnRzW2ldKSB7XG4gICAgICAgICAgICBpZihqIT09J191aWQnKSB7XG4gICAgICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAgICAgZXhwb3J0c1tpXS5fbS5jYWxsKGJhc2UsIGUsIGV2ZW50c1tpXVtqXSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnP3doYXQnLCBpLCBqLCBiYXNlLCBiYXNlLl9ub2RlKVxuICAgICAgICAgICAgICAgIGV2ZW50c1tpXVtqXS5jYWxsKGJhc2UsIGUpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGUucHJldmVudCkgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQmFzaWMgKGksIHIpIHtcbiAgdmFyIHR5cGUgPSBpIHx8IHJcblxuICAvLyBjb25zb2xlLmxvZygnY3JlYXRlQmFzaWMnLCB0eXBlLGkpXG5cbiAgZXhwb3J0cy5fcltpXSA9IHRydWVcbiAgaWYodHlwZSA9PT0gJ3Njcm9sbCcpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGZ1bmN0aW9uKGUpe1xuICAgICAgdmFyIGJhc2UgPSBlLnRhcmdldC5iYXNlXG4gICAgICAgICwgZXZlbnRzXG5cbiAgICAgIGlmKGJhc2UpIHtcbiAgICAgICAgZXZlbnRzID0gYmFzZS5ldmVudHNcbiAgICAgICAgaWYoZXZlbnRzICYmIGV2ZW50c1tpXSkgZXZlbnRzW2ldLl92YWwuY2FsbChiYXNlLCBlKVxuICAgICAgICBldmVudHMgPSBiYXNlLl9fZVxuICAgICAgICBpZiAoZXZlbnRzICYmIGV2ZW50c1tpXSkge1xuICAgICAgICAgIGZvciAodmFyIGogaW4gZXZlbnRzW2ldKSB7XG4gICAgICAgICAgICBpZihqIT09J191aWQnKSBldmVudHNbaV1bal0uY2FsbChiYXNlLCBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sdHJ1ZSlcbiAgfWVsc2UgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCAoZXhwb3J0c1tpXS5tID0gX2NyZWF0ZVdoaWxlKGkpKSlcbn1cblxuZnVuY3Rpb24gX3NldENvbXBsZXggKCBpLCBtLCByLCBmcm9tICkge1xuICB2YXIgbWV0ID0gZXhwb3J0c1tpXS5fbSA9IGZ1bmN0aW9uIChlLCB2YWwpIHtcbiAgICBpZiAoZS5wcmV2ZW50KSByZXR1cm5cbiAgICBtLmNhbGwodGhpcywgZSwgKHZhbC5fdmFsIHx8IHZhbC52YWwgfHwgdmFsKSwgdmFsKVxuICB9XG4gIGV4cG9ydHNbaV0ubSA9IF9jcmVhdGVXaGlsZShpLCB0cnVlKVxuICBleHBvcnRzLl9yW2ldID0gdHJ1ZVxuICBpZiAoZXhwb3J0c1tyXSkge1xuICAgIGlmICghZXhwb3J0c1tyXS5tKSB7XG4gICAgICBfY3JlYXRlKHIsIGZyb20gKVxuICAgIH1cbiAgICBpZiAoIWV4cG9ydHNbcl0uX2Jhc2ljKSB7XG4gICAgICBleHBvcnRzW2ldLl9fZSA9IGV4cG9ydHNbcl0uX19lXG4gICAgICBleHBvcnRzW2ldLl9tID0gZnVuY3Rpb24gKGUsIG0pIHtcbiAgICAgICAgZXhwb3J0c1tyXS5fbS5jYWxsKHRoaXMsIGUsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBtZXQuY2FsbCh0aGlzLCBlLCBtKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzW2ldLl9fZSA9IHJcbiAgICB9XG4gIH1cbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigoZXhwb3J0c1tyXSAmJiBleHBvcnRzW3JdLl9fZSkgfHwgciwgZXhwb3J0c1tpXS5tKVxufVxuXG52YXIgYWRkV3JhcHBlciA9IGZ1bmN0aW9uKCBhZGQsIGZpZWxkLCBvcmlnICkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgLy8gY29uc29sZS5sb2coICdBREQgV1JBUCEnLCBmaWVsZCwgb3JpZyAsIGFyZ3VtZW50cyApXG4gICAgcmV0dXJuIGFkZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNvbXBsZXgoIGZpZWxkLCBmcm9tICkge1xuXG4gIC8vIGNvbnNvbGUubG9nKCdfY3JlYXRlQ29tcGxleCcgLGZpZWxkLCBmcm9tIClcblxuICBpZiggZXhwb3J0c1tmaWVsZF0uY3JlYXRlICkgZXhwb3J0c1tmaWVsZF0uY3JlYXRlKCBmaWVsZCwgZnJvbSlcbiAgdmFyIG1cbiAgICAsIGlcbiAgICAsIGpcbiAgZm9yICggaSBpbiBleHBvcnRzW2ZpZWxkXSApIHtcbiAgICBpZiAoY2FzZXNbaV0gPT09IHRydWUpIG0gPSBleHBvcnRzW2ZpZWxkXVtpXVxuICB9XG4gIGlmICggbSB8fCAoIG0gPSBleHBvcnRzW2ZpZWxkXS52YWwgKSApIHtcbiAgICBmb3IgKGogaW4gbSkgLy9vbmx5IG9uZVxuICAgIDtleHBvcnRzW2ZpZWxkXS5fX2UgPSBqXG5cbiAgICBpZiAobVtqXSA9PT0gdHJ1ZSkgXG4gICAge1xuICAgICAgZXhwb3J0c1tmaWVsZF0uX2Jhc2ljID0gdHJ1ZVxuICAgICAgX2NyZWF0ZUJhc2ljKGZpZWxkLCBqKVxuICAgIH0gXG4gICAgZWxzZSBcbiAgICB7XG4gICAgICAvL2Jhc2ljIGVuIG5vbiBiYXNpYyBpam4gbmlldCB0ZSBjb21iaW5lcmVuIC0tIGNvbWJpbmVyZW4gbm9nIGthcG90XG4gICAgICAvLyBjb25zb2xlLmxvZygnc2V0IGNvbXBsZXggZmllbGQnLCBmaWVsZCwgbSwgaiwgIGV4cG9ydHNbal0pIFxuICAgICAgLy8hISF0cmlwcGxlIGNoZWNrIGRpdCEhIVxuICAgICAgIGZvciggaiBpbiBtICkgXG4gICAgICAgeyBcbiAgICAgICAgaWYoIGV4cG9ydHNbal0gJiYgZXhwb3J0c1tqXS5hZGQgXG4gICAgICAgICAmJiBleHBvcnRzW2ZpZWxkXSAmJiAhZXhwb3J0c1tmaWVsZF0uYWRkXG4gICAgICAgICkgXG4gICAgICAgIHtcbiAgICAgICAgICBleHBvcnRzW2ZpZWxkXS5hZGQgPSBhZGRXcmFwcGVyKCBleHBvcnRzW2pdLmFkZCwgZmllbGQsIGogKVxuICAgICAgICB9XG4gICAgICAgIF9zZXRDb21wbGV4KGZpZWxkLCBtW2pdLCBqLCBmcm9tIClcbiAgICAgIH1cbiAgICAgIC8vISEhZGFuZ2VyIGxvb3AhISFcbiAgICB9XG5cbiAgfVxufVxuXG5leHBvcnRzLl9zZXQgPSBmdW5jdGlvbiAodmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBjdmFsLCBibGFja2xpc3QpIHtcbiAgdmFyIHQgPSB0aGlzXG4gIHZhbC5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgaWYgKCFibGFja2xpc3QgfHwgIWJsYWNrbGlzdFtpXSkge1xuICAgICAgaWYgKHRoaXMuX3ZhbCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGV4cG9ydHNbaV0pIHtcbiAgICAgICAgICBpZiAoZXhwb3J0c1tpXS5yZW1vdmUpIGV4cG9ydHNbaV0ucmVtb3ZlLmNhbGwodClcbiAgICAgICAgICB0LmVhY2hJbnN0YW5jZShleHBvcnRzW2ldLnJlbW92ZSwgdmFsLl9wcm9wLm5hbWUpXG4gICAgICAgICAgdGhpcy5yZW1vdmUoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ19jcmUnLCBpLCBleHBvcnRzW2ldKVxuXG4gICAgICAgIGlmICghKGV4cG9ydHNbaV0gJiYgZXhwb3J0c1tpXS5tKSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS1wYXNzJywgaSlcbiAgICAgICAgICBfY3JlYXRlKGksIGkpXG4gICAgICAgIH1cbiAgICAgICAgLy9hZGQgd3JhcHBlcj9cblxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdfc2V0JyxpLCBleHBvcnRzW2ldLmFkZCwgZXhwb3J0c1tpXSlcblxuICAgICAgICBpZiAoZXhwb3J0c1tpXS5hZGQpIGV4cG9ydHNbaV0uYWRkLmNhbGwoIHQsIGZhbHNlLCBpIClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmVsZW1lbnQuYmFzZS5leHRlbmQoXG57IG5hbWU6ICdldmVudHMnXG4sIHNldDogZXhwb3J0cy5fc2V0XG59KVxuXG51dGlsLmRlZmluZShlbGVtZW50XG4sICdhZGRFdmVudCcsIGZ1bmN0aW9uKGZpZWxkLCBmbiwgaWQpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnWFhYWCcsZmllbGQpXG5cbiAgICBpZiAoIShleHBvcnRzW2ZpZWxkXSAmJiBleHBvcnRzW2ZpZWxkXS5tKSkgX2NyZWF0ZShmaWVsZClcbiAgICB2YXIgZXZlbnRzID0gdGhpcy5fX2UgfHwgKHRoaXMuX19lID0ge30pXG4gICAgICAsIGYgPSBldmVudHNbZmllbGRdIHx8IChldmVudHNbZmllbGRdID0gbmV3IEZpZWxkU3RvcmUoKSlcblxuICAgIGlmICghaWQpIHtcbiAgICAgIGYuX3VpZCsrXG4gICAgICBpZCA9IGYuX3VpZFxuICAgIH1cbiAgICBmW2lkXSA9IGZuXG5cbiAgICAvLyBjb25zb2xlLmxvZygnYWRkRXZlbnQhISEnLCBmaWVsZClcblxuICAgIGlmIChleHBvcnRzW2ZpZWxkXS5hZGQpIGV4cG9ydHNbZmllbGRdLmFkZC5jYWxsKHRoaXMsIGlkLCBmaWVsZClcbiAgICByZXR1cm4gdGhpc1xuICB9XG4sICdyZW1vdmVFdmVudCcsIGZ1bmN0aW9uIChmaWVsZCwgaWQsIGZuKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX19lXG4gICAgICAsIHJlbW92ZVxuICAgIGlmIChldmVudHMpIHtcbiAgICAgIGlmIChmaWVsZCAmJiBldmVudHNbZmllbGRdKSB7XG4gICAgICAgIHJlbW92ZSA9IChleHBvcnRzW2ZpZWxkXSAmJiBleHBvcnRzW2ZpZWxkXS5yZW1vdmUpXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGlmIChldmVudHNbZmllbGRdW2lkXSAmJiAoIWZuIHx8IGV2ZW50c1tmaWVsZF1baWRdID09PSBmbikpIHtcbiAgICAgICAgICAgIGlmIChyZW1vdmUpIGV4cG9ydHNbZmllbGRdLnJlbW92ZS5jYWxsKHRoaXMsIGlkKVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tmaWVsZF1baWRdXG4gICAgICAgICAgfVxuICAgICAgICB9IFxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBmb3IgKGlkIGluIGV2ZW50c1tmaWVsZF0pIHtcbiAgICAgICAgICAgIGlmICghZm4gfHwgZXZlbnRzW2ZpZWxkXVtpZF0gPT09IGZuKSB7XG4gICAgICAgICAgICAgIGlmIChyZW1vdmUpIGV4cG9ydHNbZmllbGRdLnJlbW92ZS5jYWxsKHRoaXMsIGlkKVxuICAgICAgICAgICAgICBkZWxldGUgZXZlbnRzW2ZpZWxkXVtpZF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0aWwuZW1wdHkoZXZlbnRzW2ZpZWxkXSkpIGRlbGV0ZSBldmVudHNbZmllbGRdXG4gICAgICB9IFxuICAgICAgZWxzZSBpZiAoIWZpZWxkKSB7XG4gICAgICAgIGZvciAoZmllbGQgaW4gZXZlbnRzKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudChmaWVsZCwgaWQsIGZuKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1dGlsLmVtcHR5KGV2ZW50cykpIGRlbGV0ZSB0aGlzLl9fZVxuICAgIHJldHVybiB0aGlzXG4gIH0pXG5cbnJlcXVpcmUoJy4vYmFzaWMnKVxuIiwidmFyIG1hdHJpeCA9IHJlcXVpcmUoJy4uL2VsZW1lbnQvcHJvcGVydGllcy91dGlsJykuZ2V0TWF0cml4XG4gICwgdmlnb3VyID0gcmVxdWlyZSgnLi4vLi4vJylcbiAgLCBjc3MgPSByZXF1aXJlKCcuLi9jc3MnKVxuXG5leHBvcnRzLmxlZnQgPSBleHBvcnRzLnggPSBmdW5jdGlvbiAoIG9iamVjdCwgYXJyICkge1xuICByZXR1cm4gb2Zmc2V0KG9iamVjdCxhcnIsJ2xlZnQnLCdvZmZzZXRMZWZ0JywgNClcbn1cblxuZXhwb3J0cy50b3AgPSBleHBvcnRzLnkgPSBmdW5jdGlvbiAoIG9iamVjdCwgYXJyICkge1xuICByZXR1cm4gb2Zmc2V0KG9iamVjdCxhcnIsJ3RvcCcsJ29mZnNldFRvcCcsIDUpXG59IFxuXG5mdW5jdGlvbiBvZmZzZXQgKCBvYmplY3QsIGFyciwgcHJvcCwgcHJvcEwsIG1hdHJpeEluZGV4ICkge1xuICBpZighb2JqZWN0KSByZXR1cm4gMFxuICB2YXIgc3RhcnQgPSBmYWxzZVxuICBpZighYXJyKSB7XG4gICAgYXJyID0gW11cbiAgICBzdGFydCA9IHRydWVcbiAgfVxuICBcbiAgaWYodmlnb3VyLkVsZW1lbnQgJiYgb2JqZWN0IGluc3RhbmNlb2Ygdmlnb3VyLkVsZW1lbnQpIG9iamVjdCA9IG9iamVjdC5ub2RlXG5cbiAgdmFyIGFtb3VudCA9IG9iamVjdFtwcm9wTF1cbiAgICAsIHRlbXAgPSAwXG4gIGlmKHR5cGVvZihhbW91bnQpICE9PSAnbnVtYmVyJykgYW1vdW50ID0gMFxuICBpZihvYmplY3QucGFyZW50Tm9kZSkgZXhwb3J0c1twcm9wXShvYmplY3QucGFyZW50Tm9kZSwgYXJyKVxuICAgIGlmKCAoIChvYmplY3Quc3R5bGUgJiYgb2JqZWN0LnN0eWxlLnBvc2l0aW9uKVxuICAgICAgfHxvYmplY3QuX19wcmVDc3NcbiAgICAgIHx8b2JqZWN0LmNsYXNzTmFtZSBcbiAgICAgICAgJiYgKG9iamVjdC5fX3ByZUNzcyA9IGNzcyhvYmplY3QuY2xhc3NOYW1lLCAncG9zaXRpb24nKXx8dHJ1ZSkpIFxuICAgICAgIT09ICdhYnNvbHV0ZScgKSB7XG4gICAgICAgIGFyci5wdXNoKFsncmVsJywgYW1vdW50XSlcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hdHJpeEFycmF5ID0gbWF0cml4KG9iamVjdClcbiAgICAgIGFyci5wdXNoKFsnYWJzJywgbWF0cml4QXJyYXkgXG4gICAgICAgID8gcGFyc2VJbnQobWF0cml4QXJyYXlbbWF0cml4SW5kZXhdLDEwKSthbW91bnQgLy9ub3JtYWwgYW1vdW50IGFzIHdlbGxcbiAgICAgICAgOiBhbW91bnQgXSlcbiAgICB9XG4gIFxuICBpZihzdGFydCkge1xuICAgIHZhciBsYXN0cmVsXG4gICAgICAsIGFicyA9IDBcbiAgICAgICwgaVxuICAgIGZvcihpIGluIGFycikge1xuICAgICAgaWYoYXJyW2ldWzBdID09ICdhYnMnKSB7XG4gICAgICAgIGFicyArPSBhcnJbaV1bMV1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RyZWwgPSBhcnJbaV1bMV1cbiAgICAgIH1cbiAgICB9XG4gICAgYW1vdW50ID0gYXJyW2Fyci5sZW5ndGggLSAxXVswXSA9PT0gJ3JlbCcgPyBhYnMrbGFzdHJlbCA6IGFic1xuICB9XG4gIHJldHVybiBhbW91bnQgfHwgMFxufVxuXG4gIFxuXG5cbiIsInZhciByYWYgPSByZXF1aXJlKCcuLi9hbmltYXRpb24vcmFmJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG5cbmV4cG9ydHMudGhyb3R0bGUgPSBmdW5jdGlvbihmbiwgZnJhbWVzLCBiaW5kKSB7XG4gIGZyYW1lcyB8fCAoZnJhbWVzID0gMjApIC8vfjAuNHNlY1xuICB2YXIgdGltZXJcbiAgICAsIGFyZ1xuICAgICwgbm9iaW5kID0gIWJpbmRcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGFyZyA9IGFyZ3VtZW50c1xuICAgIGlmKG5vYmluZCkgYmluZCA9IHRoaXNcbiAgICBpZighdGltZXIpIHtcbiAgICAgIHRpbWVyID0gZnJhbWVzXG4gICAgICByYWYoZnVuY3Rpb24gcmVwZWF0KCkge1xuICAgICAgICB0aW1lci0tXG4gICAgICAgIGlmKCF0aW1lcikge1xuICAgICAgICAgIGZuLmFwcGx5KGJpbmQsYXJnKSBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByYWYocmVwZWF0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG4vL1RPRE86IHBvc3Rwb25lIGJhc2VkIG9uIGZyYW1lc1xuZXhwb3J0cy5wb3N0cG9uZSA9IGZ1bmN0aW9uKGZuLCB0aW1lLCBiaW5kKSB7XG4gIHRpbWUgfHwgKHRpbWUgPSAyMDApIC8vbm8gcmFmIVxuICB2YXIgdGltZXJcbiAgICAsIGFyZ1xuICAgICwgbm9iaW5kID0gIWJpbmRcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGFyZyA9IGFyZ3VtZW50c1xuICAgIGlmKG5vYmluZCkgYmluZCA9IHRoaXNcbiAgICBpZih0aW1lcikgY2xlYXJUaW1lb3V0KHRpbWVyKVxuICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGZuLmFwcGx5KGJpbmQsYXJnKVxuICAgIH0sdGltZSlcbiAgICByZXR1cm4gdGltZXJcbiAgfVxufVxuXG4vL1RPRE86IHRlc3QgZm9yIGxlYWtzLi4uXG5leHBvcnRzLmludGVydmFsID0gZnVuY3Rpb24oZm4sIGZyYW1lcywgYmluZCkge1xuICBmcmFtZXMgfHwgKGZyYW1lcyA9IDMwKSAvL34wLjVzZWNcbiAgdmFyIHRpbWVyXG4gICAgLCBjbGVhclxuICAgICwgYXJnID0gdXRpbC5hcmcoYXJndW1lbnRzLDMpXG4gIGlmKCF0aW1lcikge1xuICAgIHRpbWVyID0gZnJhbWVzXG4gICAgcmFmKGZ1bmN0aW9uIHJlcGVhdCgpIHtcbiAgICAgIHRpbWVyLS1cbiAgICAgIGlmKCF0aW1lcikge1xuICAgICAgICB0aW1lciA9IGZyYW1lc1xuICAgICAgICBmbi5hcHBseShiaW5kLGFyZylcbiAgICAgIH0gXG4gICAgICBpZighY2xlYXIpIHJhZihyZXBlYXQpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgY2xlYXI9dHJ1ZVxuICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgX2EgPSAnYWRkRXZlbnRMaXN0ZW5lcidcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgdWEgPSByZXF1aXJlKCcuLi91YScpXG4gICwgY250ID0gMFxuXG4vKipcbiAqIHhociB3cmFwcGVyLCBhZGRzIHNvbWUgbmljZSBleHRyYXMgc3VjaCBhcyBtdWx0aXBsZSByZXF1ZXN0cyB0byBhIHNpbmdsZSBhcGkgY2FsbFxuICogeGhyIHdyYXBwZXIgd2lsbCBpbmNsdWRlIGpzb25wIGluIGEgbGF0ZXIgc3RhZ2VcbiAqIEBtZXRob2QgZXh0ZW5kXG4gKiBAcGFyYW0gICB7U3RyaW5nfEFycmF5fSBwYXJhbXMudXJsICAgICAgICAgU3BlY2lmaXkgdGhlIHVybCwgYXJyYXkgZmV0Y2hlcyBtdWx0aXBsZSB1cmwnc1xuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLmFwaV0gICAgICAgICAgIFJlcGVhdCB0aGlzIHN0cmluZyBmb3IgdGhlIHVybCB0aGF0IG5lZWRzIHRvIGJlIGNhbGxlZFxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBbcGFyYW1zLmNvbXBsZXRlXSAgICAgIFNwZWNpZnkgYSBjYWxsYmFjayB3aGVuIGFuIGFycmF5IGlzIHBhc3NlZCB0byB1cmwgY29tcGxldGUgaXMgY2FsbGVkIHdoZW4gYWxsIGl0ZW1zIGFyZSBjb21wbGV0ZVxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBbcGFyYW1zLmVycm9yXSAgICAgICAgIE9uIGVycm9yIGNhbGxiYWNrXG4gKiBAcGFyYW0gICB7RnVuY3Rpb259IFtwYXJhbXMuY2hhbmdlXSAgICAgICAgRnVuY3Rpb24gY2FsbGVkIG9uIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2VcbiAqIEBwYXJhbSAgIHtCb29sZWFufSAgW3BhcmFtcy5hc3luY10gICAgICAgICBJZiBzZXQgdG8gZmFsc2Ugd2lsbCBjYWxsIGFuIHN5bmNyb25vdXMgcmVxdWVzdCAobm90IHJlY29tbWVuZGVkISlcbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy51c2VyXSAgICAgICAgICBVc2VyIHBhcmFtZXRlclxuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLnBhc3NdICAgICAgICAgIFBhc3N3b3JkIHBhcmFtZXRlclxuICogQHBhcmFtICAge0Jvb2xlYW59ICBbcGFyYW1zLnBhcnNlXSAgICAgICAgIElmIHNldCB0byBmYWxzZSB3aWxsIG5vdCB0cnkgdG8gcGFyc2UgcmVzcG9uc2UgdG8gSlNPTlxuICogQHBhcmFtICAge1N0cmluZ30gICBbcGFyYW1zLnR5cGV8Lm1ldGhvZF0gIFBPU1Qgb3IgR0VULCBkZWZhdWx0IGlzIGdldDtcbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy5jb250ZW50VHlwZV0gICByZXF1ZXN0IGNvbnRlbnQgdHlwZSBkZWZhdWx0IGlkIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCJcbiAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgW3BhcmFtcy5taW1lXSAgICAgICAgICBkZWZpbmVzIG1pbWUgdHlwZVxuICogQHBhcmFtICAge0Z1bmN0aW9ufSBbcGFyYW1zLnByb2dyZXNzXSAgICAgIFByb2dyZXNzIGNhbGxiYWNrXG4gKiBAcGFyYW0gICB7Qm9vbGVhbnxTdHJpbmd9IFtwYXJhbXMuanNvbnBdICAgVXNlIGpzb25wICwgaWYgcGFzc2VkIGFzIGEgc3RyaW5nIGRldGVybWluZXMgc2NyaXB0Kz9jYWxsYmFjaz1cbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgW3BhcmFtcy5oZWFkZXJdICAgICAgICBTZXRzIHJlcXVlc3QgaGVhZGVyc1xuICogQHBhcmFtICAgeyp9ICAgICAgICBbcGFyYW1zLmRhdGFdICAgICAgICAgIFBhc3MgZGF0YSB0byB0aGUgcmVxdWVzdCwgZGVmYXVsdHMgdG8gPyBvbiBnZXQ7XG4gKi9cblxudmFyIGlmcmFtZXNcbiAgLCBhamF4ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihwYXJhbXMsIHVybHNldCkge1xuICAgIHZhciBfdXJsID0gcGFyYW1zLnVybDtcbiAgICBpZiAoIXVybHNldCAmJiBfdXJsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHBhcmFtcy5tID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICgoKytwYXJhbXMucikgPT09IHBhcmFtcy5uKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFyciA9IFtdLCBsID0gX3VybC5sZW5ndGg7IGkgPCBsOyBhcnIucHVzaChwYXJhbXMuZFtfdXJsW2krK11dKSk7XG4gICAgICAgICAgcGFyYW1zLmNvbXBsZXRlKGFycik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwYXJhbXMuciA9IDA7XG4gICAgICBwYXJhbXMuZCA9IHt9O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXJhbXMubiA9IF91cmwubGVuZ3RoOyBpIDwgbDsgbW9kdWxlLmV4cG9ydHMocGFyYW1zLCBfdXJsW2krK10pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBwYXJhbXMuZGF0YVxuICAgICAgICAsIGVuY29kZSA9IHBhcmFtcy5lbmNvZGVcbiAgICAgICAgLCB1cmwgPSAocGFyYW1zLmFwaSB8fCAnJykgKyAodXJsc2V0IHx8IF91cmwpXG4gICAgICAgICwgaGVhZGVycyA9IHBhcmFtcy5oZWFkZXJzXG4gICAgICAgICwgc3VjY2VzcyA9IHBhcmFtcy5jb21wbGV0ZVxuICAgICAgICAsIHByb2dyZXNzID0gcGFyYW1zLnByb2dyZXNzXG4gICAgICAgICwgZXJyb3IgPSBwYXJhbXMuZXJyb3JcbiAgICAgICAgLCBjaGFuZ2UgPSBwYXJhbXMuY2hhbmdlXG4gICAgICAgICwgbWltZSA9IHBhcmFtcy5taW1lXG4gICAgICAgICwgdXNlciA9IHBhcmFtcy51c2VyXG4gICAgICAgICwgcGFzcyA9IHBhcmFtcy5wYXNzXG4gICAgICAgICwganNvbnAgPSBwYXJhbXMuanNvbnBcbiAgICAgICAgLCBwYXJzZSA9IHBhcmFtcy5wYXJzZVxuICAgICAgICAsIGlmcmFtZSA9IHBhcmFtcy5pZnJhbWVcbiAgICAgICAgLCByZXFkYXRhID0gbnVsbFxuICAgICAgICAsIGZhbGxiYWNrID0gcGFyYW1zLmZhbGxiYWNrXG4gICAgICAgICwgZmFsbGJhY2tJbmRleCA9IHBhcmFtcy5fZmFsbGJhY2tJbmRleFxuICAgICAgICAsIG1ldGhvZCA9IHBhcmFtcy50eXBlIHx8IHBhcmFtcy5tZXRob2QgfHwgJ0dFVCdcbiAgICAgICAgLCBjb250ZW50VHlwZSA9IHBhcmFtcy5jb250ZW50VHlwZSB8fCBlbmNvZGUgPT09ICdqc29uJ1xuICAgICAgICAgID8gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgICAgOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xuICAgICAgICAsIGFzeW5jID0gKHBhcmFtcy5hc3luYyA9PT0gZmFsc2UpID8gZmFsc2UgOiB0cnVlXG4gICAgICAgIFxuICAgICAgaWYoIGpzb25wICkgXG4gICAgICB7XG4gICAgICAgIGFqYXguanNvbnAoIHVybCwgc3VjY2VzcywgZXJyb3IgKSAgXG4gICAgICAgIC8vZnVuY3Rpb24oIHVybCwgc3VjY2VzcywgZXJyb3IsIGNvbnRleHQsIGNiTmFtZSApIHtcbiAgICAgIH0gXG4gICAgICBlbHNlIFxuICAgICAge1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gREFUQVxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgICAgICAgaWYoaWZyYW1lKSB7XG4gICAgICAgICAgY250KytcbiAgICAgICAgICB2YXIgZWxlbVxuICAgICAgICAgICAgLCBtc2cgPSB7fVxuICAgICAgICAgICAgLCByZXFpZCA9IGNudFxuXG4gICAgICAgICAgZm9yKHZhciBmaWVsZCBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIGlmKGZpZWxkIT09J2Vycm9yJyYmZmllbGQhPT0naWZyYW1lJyYmZmllbGQhPT0nY29tcGxldGUnKSB7XG5cbiAgICAgICAgICAgICAgbXNnW2ZpZWxkXT1wYXJhbXNbZmllbGRdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBzZXRtc2cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBlbGVtXG4gICAgICAgICAgICBpZnJhbWVzW2lmcmFtZV0ub25sb2FkID0gbnVsbFxuICAgICAgICAgICAgdmFyIG1zZ2NvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdJRlJBTUUgUkVRIE1TRyBDT01QTEVURScsZS5kYXRhKVxuICAgICAgICAgICAgICBpZihlLmRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgZFxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBkID0gSlNPTi5wYXJzZShlLmRhdGEpXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICBpZihlcnJvcikgZXJyb3IoZSlcbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihkLmlkIT09cmVxaWQpIHJldHVyblxuICAgICAgICAgICAgICAgIGlmKGQuZXJyKSB7XG4gICAgICAgICAgICAgICAgICBpZihlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcihkLmVycilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzcCA9IGQubXNnXG4gICAgICAgICAgICAgICAgaWYoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3AgPSBKU09OLnBhcnNlKHJlc3ApXG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBzdWNjZXNzKHJlc3AsZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIG1zZ2NvbXBsZXRlKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBtc2djb21wbGV0ZSwgZmFsc2UpXG4gICAgICAgICAgICAgIGVsZW0gPSBpZnJhbWVzW2lmcmFtZV0uY29udGVudFdpbmRvd1xuICAgICAgICAgICAgICBtc2cgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgbXNnOm1zZyxcbiAgICAgICAgICAgICAgICBpZDpyZXFpZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBlbGVtLnBvc3RNZXNzYWdlKG1zZywgJyonKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmKCFpZnJhbWVzKSBpZnJhbWVzID0ge31cbiAgICAgICAgICBpZighaWZyYW1lc1tpZnJhbWVdKSB7XG4gICAgICAgICAgICBlbGVtID0gaWZyYW1lc1tpZnJhbWVdID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJylcbiAgICAgICAgICAgIGVsZW0uc3JjID0gaWZyYW1lXG4gICAgICAgICAgICBlbGVtLmNMaXN0ZW5lcnMgPSBbXG4gICAgICAgICAgICAgIHNldG1zZ1xuICAgICAgICAgICAgXVxuICAgICAgICAgICAgZWxlbS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgZm9yKHZhciBoIGluIGVsZW0uY0xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGVsZW0uY0xpc3RlbmVyc1toXSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxlbS5jTGlzdGVuZXJzID0gbnVsbFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbS5zdHlsZS52aXNpYmlsaXR5PSdoaWRkZW4nXG4gICAgICAgICAgICBlbGVtLnN0eWxlLndpZHRoID0gJzBweCdcbiAgICAgICAgICAgIGVsZW0uc3R5bGUuaGVpZ2h0ID0gJzBweCdcbiAgICAgICAgICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0pXG4gICAgICAgICAgfSBlbHNlIGlmKGlmcmFtZXNbaWZyYW1lXS5jTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBpZnJhbWVzW2lmcmFtZV0uY0xpc3RlbmVycy5wdXNoKHNldG1zZylcbiAgICAgICAgICAgIC8vZWxlbS5jTGlzdGVuZXJzW2ldXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldG1zZygpXG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhKSB7XG5cbiAgICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgdXJsICs9ICc/JyArIGVuQ29kZShkYXRhLCAnR0VUJywgZW5jb2RlKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXFkYXRhID0gZW5Db2RlKGRhdGEsICdQT1NUJywgZW5jb2RlKVxuICAvLyAgICAgICAgICAgY29uc29sZS5sb2coIHJlcWRhdGEgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBNRVRIT0QsIFVSTCwgQVNZTkMsIFVTRVIgJiBQQVNTXG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdXJsLCBhc3luYywgdXNlciwgcGFzcylcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEhFQURFUlNcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsIGNvbnRlbnRUeXBlKVxuICAgICAgICBpZiAoaGVhZGVycykge1xuICAgICAgICAgIGZvciAodmFyIGYgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoZiwgaGVhZGVyc1tmXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVWRU5UU1xuICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgIHhocltfYV0oXCJsb2FkXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciByZXNwID0gKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCkucmVzcG9uc2U7XG4gICAgICAgICAgICBpZiAocGFyc2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzcCA9IEpTT04ucGFyc2UocmVzcClcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubSkge1xuICAgICAgICAgICAgICBwYXJhbXMuZFt1cmxzZXRdID0gcmVzcFxuICAgICAgICAgICAgICBwYXJhbXMubSgpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdWNjZXNzKHJlc3AsIGUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgaWYoIWZhbGxiYWNrSW5kZXgpIHBhcmFtcy5fZmFsbGJhY2tJbmRleCA9IDBcbiAgICAgICAgICBpZihmYWxsYmFjayAmJiBmYWxsYmFja0luZGV4IT09ZmFsbGJhY2subGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJhbXMuX2ZhbGxiYWNrSW5kZXgrK1xuICAgICAgICAgICAgcGFyYW1zID0gdXRpbC5tZXJnZShwYXJhbXMsZmFsbGJhY2tJbmRleClcbiAgICAgICAgICAgIGFqYXgocGFyYW1zLCB1cmxzZXQpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHhocltfYV0oXCJlcnJvclwiLCBlcnJvciwgZmFsc2UpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmVzcykge1xuICAgICAgICAgIHhocltfYV0oXCJwcm9ncmVzc1wiLCBwcm9ncmVzcywgZmFsc2UpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZSkge1xuICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjaGFuZ2VcbiAgICAgICAgfVxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTUlNRVxuICAgICAgICBpZiAobWltZSkge1xuICAgICAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFNFTkRcblxuICAgICAgICB4aHIuc2VuZChyZXFkYXRhKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG52YXIganNvbnBTdGFtcCA9IDBcblxuYWpheC5qc29ucCA9IGZ1bmN0aW9uKCB1cmwsIHN1Y2Nlc3MsIGVycm9yLCBjb250ZXh0LCBjYk5hbWUgKSB7XG5cbiAgaWYoICFjYk5hbWUgfHwgY2JOYW1lID09PSB0cnVlICkgY2JOYW1lID0gJ2NhbGxiYWNrJ1xuXG4gIHZhciBuYW1lID0gJ19qc29ucF8nICsganNvbnBTdGFtcCsrXG4gICAgLCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKVxuICBcbiAgaWYgKHVybC5tYXRjaCgvXFw/LykpIFxuICB7IFxuICAgIHVybCArPSAnJicrY2JOYW1lKyc9JytuYW1lXG4gIH1cbiAgZWxzZSBcbiAge1xuICAgIHVybCArPSAnPycrY2JOYW1lKyc9JytuYW1lXG4gIH1cbiAgXG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCdcbiAgc2NyaXB0LnNyYyA9IHVybFxuICBcbiAgaWYoZXJyb3IpIHtcbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKCBlICkge1xuICAgICAgZXJyb3IoIGUgKVxuICAgIH1cbiAgfVxuXG4gIHdpbmRvd1tuYW1lXSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHN1Y2Nlc3MuY2FsbCgoIGNvbnRleHQgfHwgd2luZG93ICksIGRhdGEpXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5yZW1vdmVDaGlsZChzY3JpcHQpXG4gICAgc2NyaXB0ID0gbnVsbFxuICAgIGRlbGV0ZSB3aW5kb3dbbmFtZV1cbiAgfVxuICBcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzY3JpcHQpXG5cbn1cblxudmFyIGVuQ29kZSA9IGFqYXguZW5jb2RlID0gZnVuY3Rpb24oZGF0YSwgbWV0aG9kLCBlbmNvZGUpIHtcbiAgdmFyIHJlc3VsdCA9ICcnXG5cbiAgaWYoZW5jb2RlID09PSAnanNvbicpe1xuICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KGRhdGEpXG4gIH0gZWxzZSBpZihkYXRhIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgaWYgKCF1dGlsLmlzTm9kZSAmJiAod2luZG93LkZvcm1EYXRhICYmIGRhdGEgaW5zdGFuY2VvZiBGb3JtRGF0YSkgJiYgbWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgcmVzdWx0ID0gZGF0YVxuICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShkYXRhW2ZdKVxuICAgICAgaWYoZW5jb2RlID09PSAndXJpJykgcmVzdWx0ID0gZW5jb2RlVVJJQ29tcG9uZW50KHJlc3VsdClcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgZiBpbiBkYXRhKSB7XG4gICAgICAgIHZhciB2YWwgPSBkYXRhW2ZdXG4gICAgICAgIGlmKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkgdmFsID0gSlNPTi5zdHJpbmdpZnkodmFsKVxuICAgICAgICBpZihlbmNvZGUgPT09ICd1cmknKXtcbiAgICAgICAgICBmID0gZW5jb2RlVVJJQ29tcG9uZW50KGYpXG4gICAgICAgICAgdmFsID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbClcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gZiArICc9JyArIHZhbCArICcmJ1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKDAsIC0xKVxuXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IChlbmNvZGUgPT09ICd1cmknKSA/IGVuY29kZVVSSUNvbXBvbmVudChkYXRhKSA6IGRhdGFcbiAgfVxuICAvLyBjb25zb2xlLmxvZygnZW5jb2RlZDonLCByZXN1bHQpXG4gIHJldHVybiByZXN1bHRcbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBNYXJjdXMgQmVzamVzLCBtYXJjdXNAdmlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZXh0ZW5kKVxuXG5mdW5jdGlvbiBleHRlbmQoQ2xvdWQpIHtcbiAgdXRpbC5kZWZpbmUoIENsb3VkXG4gICwgJ2F1dGhlbnRpY2F0ZScsIGZ1bmN0aW9uIGF1dGhlbnRpY2F0ZShyZXEsIGNiLCByZSl7XG4gICAgICB3aW5kb3cuYXV0aHJlcXVlc3QgPSByZXFcbiAgICAgIHZhciBjbG91ZCA9IHRoaXNcblxuICAgICAgaWYodHlwZW9mIHJlcSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmVxID0gcmVxKClcblxuICAgICAgaWYoIXJlcSlcbiAgICAgICAgcmV0dXJuIGNsb3VkLnNvY2tldC5yZW1vdmVMaXN0ZW5lcignY29ubmVjdCcsIHJlQXV0aClcblxuICAgICAgY2xvdWQuZW1pdCgnYXV0aGVudGljYXRlJywgcmVxLCBmdW5jdGlvbihyZXMpe1xuICAgICAgICBpZihyZXMuaG9wKVxuICAgICAgICAgIGNsb3VkLmhvcChyZXMuaG9wKVxuICAgICAgICBlbHNlIGlmKGNiKVxuICAgICAgICAgIGNiKHJlcylcbiAgICAgIH0pXG4gICAgIFxuICAgICAgaWYoIXJlKXtcbiAgICAgICAgY2xvdWQub24oJ2Nvbm5lY3QnLCByZUF1dGgpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlQXV0aCgpe1xuICAgICAgICBjb25zb2xlLmVycm9yKCdjb25uZWN0IC0+Pj4gcmVBdXRoPycpXG4gICAgICAgIGlmKGNsb3VkLl9zdGF0dXMgPiAyKXtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZWNvbm5lY3QgLT4+PiByZUF1dGghJywgcmVxKVxuICAgICAgICAgIGNsb3VkLmF1dGhlbnRpY2F0ZShyZXEsIGNiLCB0cnVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjbG91ZC5fcmVBdXRoID0gcmVBdXRoXG4gICAgfVxuICAsICdsb2dvdXQnLCBmdW5jdGlvbiBsb2dvdXQodXNlcmlkKXtcbiAgICAgIHZhciBjbG91ZCA9IHRoaXNcblxuICAgICAgY2xvdWQuZW1pdCgnbG9nb3V0JywgdXNlcmlkKVxuXG4gICAgICBpZihcbiAgICAgICAgY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdICYmIFxuICAgICAgICAgY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdLmFjdGl2ZUNsaWVudCBcbiAgICAgICAgICYmIGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXS5hY3RpdmVDbGllbnQuZnJvbS5fbmFtZSA9PT0gY2xvdWQuY2xpZW50aWRcbiAgICAgICApIFxuICAgICAgIHtcbiAgICAgICAgIGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXS5hY3RpdmVDbGllbnQucmVtb3ZlKClcbiAgICAgICB9XG5cbiAgICAgIFxuICAgICAgdmFyIHN0YW1wID0gY2xvdWQuc3RhbXBcblxuICAgICAgaWYodXNlcmlkKXtcbiAgICAgICAgaWYoY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdKVxuXG4gICAgICAgIGlmKCBcbiAgICAgICAgICBjbG91ZC5kYXRhLnVzZXJzW3VzZXJpZF0uYWN0aXZlQ2xpZW50IFxuICAgICAgICAgICYmIGNsb3VkLmRhdGEudXNlcnNbdXNlcmlkXS5hY3RpdmVDbGllbnQuZnJvbS5fbmFtZSA9PT0gY2xvdWQuY2xpZW50aWQpIFxuICAgICAgICB7XG4gICAgICAgICAgY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdLmFjdGl2ZUNsaWVudC5mcm9tID0gY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdLmFjdGl2ZUNsaWVudFxuICAgICAgICB9XG5cbiAgICAgICAgY2xvdWQuZGF0YS51c2Vyc1t1c2VyaWRdLnJlbW92ZSh2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHN0YW1wKVxuICAgICAgICAvLyBlbHNlXG4gICAgICAgIC8vICAgY29uc29sZS5lcnJvcigndGhhdCB1c2VyIGRvZXMgbm90IGV4aXN0JylcbiAgICAgIH0gZWxzZXtcbiAgICAgICAgY2xvdWQuZGF0YS51c2Vycy5lYWNoKGZ1bmN0aW9uKHVzZXJpZCl7XG4gICAgICAgICAgdGhpcy5yZW1vdmUodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBzdGFtcClcbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgY2xvdWQuc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdjb25uZWN0JywgY2xvdWQuX3JlQXV0aClcbiAgICAgIGNsb3VkLl9yZUF1dGggPSBudWxsXG5cbiAgICB9XG4gIClcbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBNYXJjdXMgQmVzamVzLCBtYXJjdXNAdmlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSggJy4uLy4uLy4uL3V0aWwnIClcbiAgLCBOZXR3b3JrRGF0YSA9IHJlcXVpcmUoICcuLi9kYXRhJyApXG4gICAgLmluamVjdCggcmVxdWlyZSggJy4uLy4uLy4uL29iamVjdC9oYXNocGF0aCcgKSApXG4gICAgLy9UT0RPOiBhZGQgbG9jYWxzdG9yYWdlIC0tPiAsICF1dGlsLmlzTm9kZSAmJiByZXF1aXJlKCcuLi8uLi8uLi9vYmplY3QvbG9jYWxzdG9yYWdlJylcbiAgLCBuZXR3b3JrRGF0YUVsZW1lbnQgPSByZXF1aXJlKCAnLi4vZGF0YS9lbGVtZW50JyApXG4gICwgRGF0YSA9IHJlcXVpcmUoICcuLi8uLi8uLi9kYXRhJyApXG4gICwgcHJldmVudFVwZGF0ZVxuICAsIHZPYmplY3QgPSByZXF1aXJlKCAnLi4vLi4vLi4vb2JqZWN0JyApXG4gICwgbW9ub1N0YW1wID0gcmVxdWlyZSggJ21vbm90b25pYy10aW1lc3RhbXAnIClcbiAgLCBDbG91ZERhdGEgPSBOZXR3b3JrRGF0YS5uZXdcbiAgICAoIGZhbHNlIC8vcHV0IHNvbWUgc2V0dGluZ3MhXG4gICAgLCBmdW5jdGlvbiBDbG91ZERhdGEoIHZhbCwgaG9vaywgcGFyZW50LCBjbG91ZCApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuXG4gICAgICAgIGlmKCBjbG91ZCApXG4gICAgICAgIHtcbiAgICAgICAgICBfdGhpcy5jbG91ZCA9IGNsb3VkXG4gICAgICAgICAgX3RoaXMuYWRkTGlzdGVuZXIoY2RMaXN0ZW5lcilcblxuICAgICAgICAgIGlmKCF1dGlsLmlzTm9kZSAmJiAhIXdpbmRvdy5jb3Jkb3ZhKSBcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BhdXNlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIC8vVE9ETzogdGhpcyBkb2VzIG5vdCB3b3JrIHlldCAtLSBtYWtlIHByZXZlbnQgdXBkYXRlIGEgdXNhYmxlIHRoaW5nIGluIGFwcCBsb2dpYyAoIGUuZy4gaW4gZGV2aWNlIGxpc3RzIG9yIGNsaWVudHMgKVxuICAgICAgICAgICAgICBfdGhpcy5wcmV2ZW50VXBkYXRlID0gdHJ1ZVxuICAgICAgICAgICAgfSwgZmFsc2UpXG5cbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc3VtZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgY2xvdWQua2lja1BpbmcoKVxuXG4gICAgICAgICAgICAgIGlmKCBfdGhpcy50aW1lb3V0IClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCggX3RoaXMudGltZW91dCApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoIF90aGlzLmRlZmVyZWQgKSBcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5tZXJnZSggX3RoaXMuZGVmZXJlZC5kYXRhLCBmYWxzZSwgX3RoaXMuZGVmZXJlZC5zdGFtcCApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnByZXZlbnRVcGRhdGUgPSBudWxsXG4gICAgICAgICAgICAgICAgX3RoaXMuZGVmZXJlZCA9IG51bGxcbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gbnVsbFxuICAgICAgICAgICAgICB9LCAxMDAgKVxuICAgICAgICAgICAgICAvLyBfdGhpcy5wcmV2ZW50VXBkYXRlID0gdHJ1ZSAvL3dhaXQgZm9yIGFub3RoZXIgdXBkYXRlIGFuZCB0aW1lb3V0XG4gICAgICAgICAgICB9LCBmYWxzZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbG91ZC5vblxuICAgICAgICAgICggJ3NldCdcbiAgICAgICAgICAsIGZ1bmN0aW9uKCBkYXRhICkge1xuIFxuICAgICAgICAgICAgLy8gY29uc29sZS5jbGVhcigpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZ3JvdXAoKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1xcbi0tLS0tLS0tLS0tSU5DT01JTkcgQ0xPVUQtLS0tLS0tXFxuJywgZGF0YSApXG5cbiAgICAgICAgICAgIC8vIGlmKClcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoZGF0YSwgZmFsc2UsIDIpLnNsaWNlKDAsMjAwKSlcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoZGF0YSwgZmFsc2UsIDIpKVxuICAgICAgICAgICAgLy8gY29uc29sZS5ncm91cEVuZCgpXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdJTkNPTUlORyFcXG4nLCBKU09OLnN0cmluZ2lmeShkYXRhKSlcbiAgICAgICAgICAgICAgdmFyIHNldCA9IGRhdGEuc1xuICAgICAgICAgICAgICAgICwgdmNsb2NrID0gZGF0YS52XG4gICAgICAgICAgICAgICAgLy8gLCBzdGFtcHMgPSB2Y2xvY2tbMV1cbiAgICAgICAgICAgICAgICAsIHN1YnMgPSBjbG91ZC5zdGF0ZS5zdWJzLm1hcFxuICAgICAgICAgICAgICAgICwgc3Vic3RhbXAgPSB2Y2xvY2tbMV1cblxuICAgICAgICAgICAgICBpZiggdmNsb2NrWzBdIGluc3RhbmNlb2YgQXJyYXkgKVxuICAgICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgICAvL3ZjbG9jayB3aGVyZSBpcyBpdD8/Pz8/P1xuXG4gICAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IHZjbG9ja1swXS5sZW5ndGg7IGhhc2ggPSB2Y2xvY2tbMF1bLS1pXTsgKVxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZVN1Yiggc3Vic1toYXNoXSwgc3Vic3RhbXAgKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVN1Yiggc3Vic1tkYXRhLnZbMF1dLCBzdWJzdGFtcCApXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAvLyBzdWJzdGFtcCA9IDBcblxuICAgICAgICAgICAgICAvLyBmb3IoIHZhciBzIGluIHN0YW1wcyApXG4gICAgICAgICAgICAgIC8vIHtcbiAgICAgICAgICAgICAgLy8gICBjb25zb2xlLmxvZygnYnVycnInLCBzdGFtcHNbc10pXG4gICAgICAgICAgICAgIC8vICAgaWYoIHN0YW1wc1tzXSA+IHN0YW1wICkgc3RhbXAgPSBzdGFtcHNbc11cbiAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgIHZhciBzdGFtcCA9IG1vbm9TdGFtcCgpXG4gICAgICAgICAgICAgIGNsb3VkLnN0YW1wID0gc3RhbXBcblxuICAgICAgICAgICAgICAvLyBfdGhpcy5fdGltZVxuXG4gICAgICAgICAgICAgIGlmKCAhX3RoaXMucHJldmVudFVwZGF0ZSApIFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX3RoaXMubWVyZ2UoIGRhdGEucywgZmFsc2UsIHN0YW1wIClcbiAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYoIV90aGlzLmRlZmVyZWQpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgLy9wYXVzZSBnZWVuIHRpbWVvdXQgYWxsZWVuIG1hYXIgdWl0c3RlbGxlblxuICAgICAgICAgICAgICAgICAgX3RoaXMuZGVmZXJlZCA9IFxuICAgICAgICAgICAgICAgICAgeyBkYXRhOiBkYXRhLnNcbiAgICAgICAgICAgICAgICAgICwgc3RhbXA6IHN0YW1wXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuZGVmZXJlZC5zdGFtcCA9IHN0YW1wXG4gICAgICAgICAgICAgICAgICBfdGhpcy5kZWZlcmVkLmRhdGEgPSB1dGlsLm1lcmdlKCBfdGhpcy5kZWZlcmVkLmRhdGEsIGRhdGEucylcbiAgICAgICAgICAgICAgICAgIC8vIF90aGlzLmRlZmVyZWQuZGF0YS5fdXBkYXRlKCBkYXRhLnMgKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICApXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKCBwYXJlbnQgKVxuICAgICAgICB7XG4gICAgICAgICAgX3RoaXMuY2xvdWQgPSBwYXJlbnQuY2xvdWRcbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgKVxuICAsIF9fdXBkYXRlXG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvdWREYXRhXG5cbmZ1bmN0aW9uIHVwZGF0ZVN1YiggY2FjaGVkLCB2Y2xvY2sgKSB7XG4gIGlmKCAhY2FjaGVkICkgcmV0dXJuXG5cbiAgcmV0dXJuIC8vIG5vdCBpbXBsZW1lbnRlZFxuXG4gIC8vIHZhciBzdWIgPSBjYWNoZWQuc3Vic29ialxuICAvLyBpZiggIXN1Yi5fdiApIHN1Yi5zZXQoICdfdicsIHt9IClcblxuICAvLyBmb3IoIHZhciBmIGluIHZjbG9jayApXG4gIC8vIHtcbiAgLy8gICBzdWIuX3Yuc2V0KCBmLCB2Y2xvY2tbZl0gKVxuICAvLyB9XG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3ViKCBwYXRoLCBzdWIsIHBhcnRpYWxTdWIgKSB7XG5cbiAgaWYoIHBhdGgubGVuZ3RoIClcbiAge1xuICAgIHV0aWwucGF0aCggc3ViLCBwYXRoLCBwYXJ0aWFsU3ViLCB0cnVlIClcbiAgICByZXR1cm4gc3ViXG4gIH1cbiAgZWxzZVxuICB7XG4gICAgcmV0dXJuIHBhcnRpYWxTdWJcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHQ0d2Fsa2VyKCB2YWwgKSB7XG4vL1RPRE86IHJlbW92ZSAkdDo0XG4gIGZvciggdmFyIGkgaW4gdmFsIClcbiAge1xuXG4gICAgaWYodmFsW2ldIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgIHtcblxuICAgICAgaWYodmFsW2ldIGluc3RhbmNlb2Ygdk9iamVjdClcbiAgICAgIHtcbiAgICAgICAgdmFsW2ldID0geyAkcGF0aDogdmFsW2ldLl9wYXRoIH0gLy8gJHQ6IDQgXG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgIHQ0d2Fsa2VyKCB2YWxbaV0gKVxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxufVxuXG5mdW5jdGlvbiBjZExpc3RlbmVyKCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGQgKXtcbiAgdmFyIGNsb3VkID0gdGhpcy5jbG91ZFxuICAvLyBjb25zb2xlLmxvZygnT09PTyBjbG91ZGF0YSBsaXN0ZW5lcmJ1cicsIHRoaXMuX3BhdGgsIHZhbClcbiAgaWYoIHN0YW1wID09PSAnbG9jYWxTdG9yYWdlJyB8fCBzdGFtcD09PWZhbHNlICApXG4gIHtcbiAgICAvLyBjb25zb2xlLmxvZygnSSBXSUxMIE5PVCBVUERBVEUnLnJlZC5pbnZlcnNlKVxuICAgIC8vIGNvbnNvbGUubG9nKCdDbG91ZCBmcm9tIGxvY2Fsc3RvcmFnZScuaW52ZXJzZS5yZWQpXG4gICAgcmV0dXJuXG4gIH1cblxuXG4gIGlmKCBzdGFtcCAhPT0gY2xvdWQuc3RhbXAgJiYgdmFsICE9PSB2b2lkIDAgKVxuICB7XG5cbiAgICAvLyBjb25zb2xlLmxvZygnPj4+Pj4+IHNoaW5lcicpXG5cbiAgICAvLyBjb25zb2xlLmxvZygnXFxuXFxuXFxuXFxuXFxudXBkYXRlIGNsb3VkJywgdmFsKVxuXG5cblxuICAgIGlmKCByZW1vdmUgJiYgZnJvbSApXG4gICAge1xuICAgICAgaWYoIGZyb20uX3JlbW92ZWQgKVxuICAgICAge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCchISEhISFVUERBVEUgQ0xPVUQhISEnLCBmcm9tICYmIGZyb20uX3BhdGgsIHZhbCwgc3RhbXApXG5cbiAgICAgICAgY2xvdWQuc2V0KGZyb20uX2hhc2hwYXRoLCBbZnJvbS5fcGF0aCwgbnVsbCwgY2xvdWQudGltZVN0YW1wKCldKVxuICAgICAgfVxuXG4gICAgfVxuICAgIGVsc2UgaWYgKCBmcm9tICYmICF0aGlzLl9jbG91ZGlnbm9yZSApXG4gICAge1xuXG5cbiAgICAgIC8vIGlmKCBzdGFtcCA9PT0gdm9pZCAwICkge1xuICAgICAgLy8gICBhbGVydCgnWCcpXG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnY2NjY2NjY2NjY2NjIHVwZGF0ZSEnLCB0aGlzLl9wYXRoICwgZnJvbS5fdXBkYXRlT3JpZ2luLCBmcm9tLl9jYWNoZWRQYXRoKVxuXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdfdXBkYXRlIE9yaWdpbiBjYWxsIGZyb20gY2xvdWQuZGF0YScpIFxuICAgICAgaWYoIGZyb20uX3VwZGF0ZU9yaWdpbiA9PT0gZnJvbSApIC8vaGllciBnYWF0IGlldHMgbWlzXG4gICAgICB7XG4gICAgICAgIGlmKCBmcm9tLl9fdCA9PT0gMiAmJiB2YWwgaW5zdGFuY2VvZiBPYmplY3QgKSB7XG4vLyAgICAgICAgICAgY29uc29sZS5sb2coZnJvbSwgdmFsKVxuICAgICAgICAgIHQ0d2Fsa2VyKHZhbClcbiAgICAgICAgfVxuXG5cbiAgICAgICAgLy9bXCJ1c2Vyc1wiLCBcIlVfZmU3Y2M4MDAxMzZiNzYwOFwiLCBcImNsaWVudHNcIiwgXCJWX2t1Y28yenMycWZcIl1cbiAgICAgICAgdmFyIHAgPSBmcm9tJiZmcm9tLl9wYXRoXG4gICAgICAgIGlmKHAgJiYgcFswXSA9PT0gJ3VzZXJzJyAmJiBwW3AubGVuZ3RoLTJdICYmIHBbcC5sZW5ndGgtMl0gPT09ICdjbGllbnRzJyApIHtcbiAgICAgICAgICAvL1RPRE86IHZlcnkgZGlydHkgZml4IVxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2JyZWFrIGl0IGRvd24hJywgcCwgcCwgdmFsIClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHAgJiYgcFswXSA9PT0gJ3VzZXJzJyAmJiBwWzFdID09PSAnbWVkaWEnKSB7XG4gICAgICAgICAgdGhyb3cobmV3IEVycm9yKCdUSElTIElTIFdST05HIEFCT1JUIS0tLT4gc2V0dGluZyB1c2Vycy5tZWRpYSAnK3Auam9pbignLicpKSlcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdUSElTIElTIFdST05HIEFCT1JUIS0tLT4gc2V0dGluZyB1c2Vycy5tZWRpYScsIHApXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cblxuXG4gICAgICAgIGNsb3VkLnNldFxuICAgICAgICAoIGZyb20uX2hhc2hwYXRoXG4gICAgICAgICwgWyBmcm9tLl9wYXRoXG4gICAgICAgICAgLCBmcm9tLl9fdCA9PT0gNCA/IHsgICRwYXRoOiB2YWwuX3BhdGggfSA6IHZhbCAvLyR0OiA0LFxuICAgICAgICAgICwgY2xvdWQudGltZVN0YW1wKClcbiAgICAgICAgICBdXG4gICAgICAgIClcblxuICAgICAgfVxuXG4gICAgfVxuXG4gIH1cblxufVxuXG5DbG91ZERhdGEucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnY2xvdWQnLCAnZGF0YWNsb3VkJywgJ19iYXRjaFVuc3ViJywnX2Nsb3VkaWdub3JlJywgJ19sc3RhbXAnLCAnJHQnLCAnJGxvYWRlZCcsICdfZnJvbWxmcm9tJylcblxuX191cGRhdGUgPSBDbG91ZERhdGEucHJvdG90eXBlLl9fdXBkYXRlXG5cbkNsb3VkRGF0YS5pbmplY3QoIHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QvZmxhZ3MnKSApXG5cbkNsb3VkRGF0YS5mbGFncy4kcGF0aCA9IHtcbiAgcmVzZXQ6dHJ1ZSxcbiAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCkge1xuICAgIFxuICAgIGlmKCByZXNldCApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xvdWQgZGF0YSAkcGF0aCBmbGFnIHJlc2V0Pz8/JylcbiAgICB9XG4gIFxuICAgIHZhciB0ID0gdGhpc1xuICAgIGlmKHN0YW1wICE9PSB0aGlzLmNsb3VkLnN0YW1wKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldCB3aXRoICRwYXRoIG9ubHkgYWxsb3dlZCBmcm9tIHRoZSBodWInKVxuICAgIH1cblxuICAgIHZhciBwYXRoID0gdXRpbC5jaGFuZ2VUeXBlKCB2YWwgKVxuICAgIGlmKHBhdGgubGVuZ3RoKXtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdfX19fX19fX19fXyAkcGF0aCBzZXQnKVxuICAgICAgIC8vIHZhbCwgc2V0LCBub3RzZWxmLCBzdGFtcCBcbiAgICAgICAvLyBub3VwZGF0ZVxuICAgICAgdGhpcy5fJHNldFZhbCggdGhpcy5jbG91ZC5kYXRhLmdldCggcGF0aCwge30sIHZvaWQgMCwgc3RhbXAgKSAsc3RhbXAsZmFsc2UsdHJ1ZSlcbiAgICB9XG5cbiAgICBpZih0aGlzLl9fdCE9PTQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2xvdWQgZGF0YSAkcGF0aCBmbGFnIF9fdCAhPT0gNCcpXG4gICAgfVxuXG4gIH1cbn1cblxuXG52YXIgX3NldCA9IENsb3VkRGF0YS5wcm90b3R5cGUuc2V0XG5cbnZhciBfJHNldFZhbCA9IENsb3VkRGF0YS5wcm90b3R5cGUuXyRzZXRWYWxcblxuLy9DbG91ZERhdGEgYWRkIGZsYWdzXG5cbi8vKCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbSApXG51dGlsLmRlZmluZVxuKCBDbG91ZERhdGFcbiwgJ18kc2V0VmFsJywgZnVuY3Rpb24oIHZhbCwgc3RhbXAgKSB7XG4gICAvL3NldFZhbFxuXG4gICAvLyBjb25zb2xlLmxvZygnLi4uLi4uLi4uLi4uLicsIHRoaXMuX3BhdGgsIHN0YW1wLCBzdGFtcCAmJiB0aGlzLmNsb3VkLnN0YW1wID09PSBzdGFtcClcbiAgIGlmKHRoaXMuY2xvdWQuc3RhbXAgPT09IHN0YW1wICYmICF0aGlzLiRsb2FkZWQpIHtcbiAgICAvL1RPRE86IGZhc3RlciB0byBkbyAhIGxvYWRlZFxuICAgIHZhciBwYXJlbnQgPSB0aGlzXG4gICAgd2hpbGUocGFyZW50ICYmICFwYXJlbnQuJGxvYWRlZCkge1xuICAgICAgcGFyZW50LiRsb2FkZWQgPSB0cnVlXG4gICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudFxuICAgIH1cbiAgIH1cblxuICAgXyRzZXRWYWwuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gIH1cbiwgJ3NldCcsIGZ1bmN0aW9uKG5hbWUsIHZhbCwgdm9iaiwgc3RhbXApe1xuICBpZiAoc3RhbXAgIT09IHRoaXMuY2xvdWQuc3RhbXAgJiZcbiAgICAgIHRoaXMuX25hbWUgPT09ICdjbGllbnRzJyAmJlxuICAgICAgIXRoaXNbbmFtZV0gJiYgXG4gICAgICBuYW1lICE9PSB0aGlzLmNsb3VkLmNsaWVudGlkXG4gICAgICkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1xcblxcbkkgV0FOVCBUTyBCTE9DSyBUSElTIFlBIERVUksnLFxuICAgICAgJ1xcbnN0YW1wICE9PSB0aGlzLmNsb3VkLnN0YW1wJywgc3RhbXAgIT09IHRoaXMuY2xvdWQuc3RhbXAsXG4gICAgICBcIlxcbnRoaXMuX25hbWUgPT09ICdjbGllbnRzJ1wiLCB0aGlzLl9uYW1lID09PSAnY2xpZW50cycsXG4gICAgICBcIlxcbiF0aGlzW25hbWVdXCIsICF0aGlzW25hbWVdLFxuICAgICAgXCJcXG5uYW1lICE9PSB0aGlzLmNsb3VkLmNsaWVudGlkXCIsIG5hbWUgIT09IHRoaXMuY2xvdWQuY2xpZW50aWRcbiAgICApXG4gICAgZGVidWdnZXJcbiAgICAvLyByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gX3NldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG4sICd1cGRhdGVRdWV1ZSdcbiwgZnVuY3Rpb24oKSB7XG4gICAgLy8gd2h5IHRoaXM/Pz9cbiAgfVxuLCAnc3RhbXAnXG4sIGZ1bmN0aW9uKCl7XG4gICAgaWYoICF0aGlzLmNsb3VkICkge1xuICAgICAgY29uc29sZS5lcnJvciggJ1dBVCBOTyBDTE9VRD8hIGluIHRoaXM6XFxuJywgdGhpcyApXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvdWQudGltZVN0YW1wKClcbiAgfVxuLCAnX191cGRhdGUnXG4sIGZ1bmN0aW9uKCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKSB7XG5cbiAgICAvLyBpZihzdGFtcCAmJiB0aGlzLl9sc3RhbXAgPT09IHN0YW1wKSByZXR1cm5cblxuXG4gICAgLy8gY29uc29sZS5sb2coZnJvbSwgJ1xcbicsIHRoaXMuX2xmcm9tLCBmcm9tLCBmcm9tJiZmcm9tLl9sZnJvbS5fY2FjaGVkUGF0aCwgdGhpcy5fY2FjaGVkUGF0aCwgdGhpcy5fbGZyb20pXG4gICAgaWYoZnJvbSAmJiBmcm9tLl9sZnJvbSkge1xuXG4gICAgICB0aGlzLl9mcm9tbGZyb20gPSBmcm9tLl9sZnJvbVxuICAgICAgLy8gY29uc29sZS5lcnJvcih0aGlzLl9mcm9tbGZyb20pXG4gICAgICAvLyByZXR1cm5cbiAgICB9XG5cbiAgICBpZih0aGlzLl9mcm9tbGZyb20gJiYgdGhpcy5fZnJvbWxmcm9tID09PSAoZnJvbSAmJiBmcm9tLl9sZnJvbSkgJiYgdGhpcy5fbHN0YW1wPT09c3RhbXApIHtcbiAgICAgIC8vVE9ETzogdGhpcyBpcyBhIG1lbW9yeSBsZWFrIGdldCByaWQgb2YgaXQgY2lyYyByZWZzIHNob3VsZCBiZSByZXNvbHZlZCBmcm9tIHZvYmogaXRzZWxmXG4gICAgICBkZWxldGUgdGhpcy5fZnJvbWxmcm9tXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9sc3RhbXAgPSBzdGFtcFxuXG4gICAgLy8gaWYodGhpcy5fcGF0aFswXT09PSdjbGllbnRzJykge1xuICAgIC8vICAgY29uc29sZS5sb2coJzInLCB0aGlzLl9wYXRoLCBzdGFtcD09PXRoaXMuY2xvdWQuc3RhbXApXG4gICAgLy8gfVxuICAgIC8vIGNvbnNvbGUubG9nKCcxIGxldHMgX191cGRhdGUnLCB0aGlzLl9wYXRoLCBhcmd1bWVudHMpXG4gICAgLy8gaWYoIHRoaXMuX2lnbm9yZSAgKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnMjEgbGV0cyBfX3VwZGF0ZScsIHRoaXMuX3BhdGgsIGFyZ3VtZW50cylcbiAgICAgIC8vIGRlbGV0ZSB0aGlzLl9pZ25vcmVcbiAgICAgIC8vIHJldHVybiBmYWxzZVxuICAgIC8vIH1cbiAgICAvL21vc3QgbmVzdGVkIHVwZGF0ZSBoaWVyIGFkZGl0aW9uIG1ha2VuIHZvb3IgcHJvY2Vzc1xuICAgIC8vIGNvbnNvbGUubG9nKHZhbCwgc3RhbXAsIGZyb20pXG4gICAgLy9pcyBkaXQgbWF5YmUgd2VpcmQ/Pz9cbiAgICByZXR1cm4gX191cGRhdGUuY2FsbCggdGhpcywgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsIClcbiAgfVxuLCAnX3NldCdcbiwgZnVuY3Rpb24gKHZhbCwgc3RhbXApIHtcbiAgICBpZiggIXN0YW1wICkgcmV0dXJuXG4gICAgaWYoIHRoaXMuX2xzdGFtcCA+IHN0YW1wIClcbiAgICB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJ2xldHMgc2V0IGl0ISEhJywgdGhpcy5fcGF0aCwgYXJndW1lbnRzKVxuXG4gICAgcmV0dXJuIE5ldHdvcmtEYXRhLnByb3RvdHlwZS5fc2V0LmFwcGx5KCB0aGlzLGFyZ3VtZW50cyApXG4gIH1cbiwgJ3N1YnNjcmliZSdcbiwgZnVuY3Rpb24oIHZhbCwgZnJvbSwgcGFyZW50Rml4ZXIgKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzdGFydCcpXG5cbiAgICBpZiggZnJvbSAmJiBmcm9tLmNsb3VkICAmJiBmcm9tLl92YWwgPT09IHRoaXMgKSB7XG5cbiAgICAgICAgLy9CVUc6IGRpdCBrYW4gaGVlbCB2ZWVsIGJyb2tlbiBtYWtlbiEhISEhISFcbi8vICAgICAgICAgY29uc29sZS5sb2coJ1xcblxcbkhVUkshISEhISEgRElUIElTIFRFTVAgTU9FVCBOSUVUIEVFTiBFWFRSQSBTVUIgR0VNQUFLVCBXT1JERU4hJyApXG5cbiAgICAgICAgLy8gZnJvbSA9IHZvaWQgMFxuXG4gICAgICAgIC8vVE9ETzogZGl0IGlzIGhlbGVtYWFsIHdyb25nIEdFVCBSSUQgT0YgSVQhISEhXG4gICAgICAgIC8vIHJldHVyblxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKCAnbGV0cyBkbyBpdCBzdWIgc3ViJy5jeWFuLmludmVyc2UsIHRoaXMsIHZhbCwgZnJvbSwgcGFyZW50Rml4ZXIgKVxuICAgIC8vIGlmKGZyb20pIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdHT1QgRlJPTScsIGZyb20gLCAnU1VCU0NSSUJFJylcbiAgICAvLyB9XG4gICAgIGlmICghdmFsIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHsgcmV0dXJuOyB9XG4gICAgIC8vIGlmKHZhbCBpbnN0YW5jZW9mIHZPYmplY3QpIHtcbiAgICAgLy8gICAgdmFsID0gdmFsLmZyb21cbiAgICAgLy8gfVxuXG5cbiAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoXG4gICAgICAgLCBlbGVtID0gdmFsWzFdXG4gICAgICAgLCBzdWJcbiAgICAgICAsIHBhcnRpYWxTdWJcbiAgICAgICAsIHN0cmluZ2lmaWVkXG4gICAgICAgLCBzdWJzQXJyYXlcbiAgICAgICAsIGV4aXN0c1xuICAgICAgICwgbGlzdGVuZXJzXG4gICAgICAgLCBmcm9tTmFtZVxuXG4gICAgICB2YXIgZm91bmQgPSBwYXRoICYmIHV0aWwuY2hlY2tBcnJheSggcGF0aCAsICd1c2FnZScgKVxuICAgIFxuXG5cbiAgICAvLyBpZiggZm91bmQgfHwgZm91bmQ9PT0wKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbGV0cyB0cnkgdG8gc3ViJywgdmFsICYmIHZhbC5fcGF0aCwgJzonLCB0aGlzLl9wYXRoIClcbiAgICAgIC8vIH1cbiAgIFxuXG4gICAgLy8gaWYoZWxlbSkge1xuICAgIC8vICAgY29uc29sZS5lcnJvcihlbGVtLCBlbGVtLl9jb2wsIGVsZW0uX2Rmcm9tLCBlbGVtLl9mbW9kZWwpXG4gICAgLy8gfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ1NVQlNDUklCRScsIGVsZW0uX2Rmcm9tLCBlbGVtLl9mbW9kZWwsICdERlJPTSwgRk1PREVMIScpXG5cbiAgICAvLyBpZiAoZWxlbSAmJiAhZWxlbS5fY29sICYmICghZWxlbS5fZGZyb20gfHwgZWxlbS5fZm1vZGVsKSkge1xuICAgIHZhciBpc0VsZW0gPSAoZWxlbSAmJiAhZWxlbS5fY29sICYmICghZWxlbS5fZGZyb20gfHwgZWxlbS5fZm1vZGVsKSlcblxuICAgIGlmKCBpc0VsZW0gJiYgIWVsZW0uZ2V0TW9kZWwpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2JlIGNhcmVmdWxsISBjbG91ZCBkYXRhIGVsZW0gZG9lcyBub3QgaGF2ZSBnZXRNb2RlbCcpXG4gICAgfSBlbHNlIGlmKCBpc0VsZW0gKSB7XG5cbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1hYWCEnKVxuICAgICAgLy9oaWVyIGRpbmdlbiB2aW5kZW4gdm9vclxuICAgICAgLy8gY29uc29sZS5sb2coJyFERlJPTSEnKVxuXG4gICAgLy9pc0VsZW1cblxuICAgIC8vdmFsLCBmcm9tLCBwYXJlbnRGaXhlclxuXG4gICAgLy8gaWYodmFsWzNdICYmIHZhbFszXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgLy8gICAgICAgY29uc29sZS5sb2coICdZRVMhISEnIClcblxuICAgIC8vIH1cblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnISEhISEhMTExMTExJywgYXJndW1lbnRzLCB2YWxbM10sIGZyb20sIHBhcmVudEZpeGVyLCB0aGlzLCBwYXRoIClcblxuICAgIHZhciBmaWVsZGlnbm9yZVxuICAgIGlmKCB2YWxbMV0uX2lnbm9yZUZpZWxkSW5TdWJzY3JpcHRpb24gKSB7XG4gICAgICAvLyBhbGVydCgnIScrdmFsWzNdKVxuICAgICAgaWYoIXZhbFszXSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnRklFTERJR05PUkUnLmJsdWUuaW52ZXJzZSwgdmFsLCB0aGlzLCBwYXRoIClcbiAgICAgICAgLy8gZGVidWdnZXJcblxuICAgICAgICAvLyBpZihmaSlcblxuICAgICAgICBmaWVsZGlnbm9yZSA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1RPRE86IGhhcyB0byBiZWNvbWUgdmFsWzJdISEhXG4gICAgLy90eXBlb2YgZnJvbSA9PT0gJ3N0cmluZycgPyBmcm9tIDpcbiAgICAgIC8vZGl0IGlzIG5pZXQgZ29lZCEhISFcbiAgICAgIGZyb21OYW1lID0gdmFsWzNdXG5cbiAgICAvLyBjb25zb2xlLmxvZyggJy0tLS0tLS0tMjIhISEhISExMTExMTEnLCBwYXJ0aWFsU3ViLCB2YWxbM10sICdcXG5cXG4/JywgdmFsWzNdLl9uYW1lICApXG5cbiAgICAgIC8vdmFsWzNdIGluc3RhbmNlb2YgRGF0YVxuICAgICAgcGFydGlhbFN1YiA9IGVsZW0uZ2V0TW9kZWwoIHRoaXMsICB2YWxbM10gLCBmaWVsZGlnbm9yZSApXG4gICAgICAvLyBjb25zb2xlLmNsZWFyKClcbiAgICAvLyBjb25zb2xlLmxvZyggJy0tLS0hISEhISExMTExMTEnLCBwYXJ0aWFsU3ViIClcbiAgICAgIC8vIGlmKHBhcnRpYWxTdWIgJiYgcGFydGlhbFN1Yi5zcGVjaWFsRml4KSB7XG4gICAgICAvLyAgIGNvbnNvbGUubG9nKCdMRVRTIERPIElUIElUSSBJVCcsIHBhcnRpYWxTdWIsIHBhcnRpYWxTdWIuc3BlY2lhbEZpeCwgcGF0aClcbiAgICAgICAgXG4gICAgICAvLyAgIC8vIGlmKHBhcnRpYWxTdWIuc3BlY2lhbEZpeCBpbnN0YW5jZW9mIEFycmF5ICkge1xuXG4gICAgICAvLyAgIC8vICAgY29uc29sZS5sb2coIHBhdGgsIHBhcnRpYWxTdWIuc3BlY2lhbEZpeCwgcGFydGlhbFN1YiApXG4gICAgICAvLyAgIC8vICAgaWYocGF0aFtwYXRoLmxlbmd0aC0xXSA9PT0gcGFydGlhbFN1Yi5zcGVjaWFsRml4WzBdKSB7XG5cbiAgICAgIC8vICAgLy8gICAgIGlmKHBhcnRpYWxTdWIuJCAmJiBwYXJ0aWFsU3ViLiRbcGFydGlhbFN1Yi5zcGVjaWFsRml4WzFdXSkge1xuICAgICAgLy8gICAvLyAgICAgICAgIGNvbnNvbGUubG9nKCdkbyBpdCEnKVxuICAgICAgLy8gICAvLyAgICAgICAgIHBhcnRpYWxTdWIgPSBwYXJ0aWFsU3ViLiRbcGFydGlhbFN1Yi5zcGVjaWFsRml4WzFdXVxuICAgICAgLy8gICAvLyAgICAgfVxuXG4gICAgICAvLyAgIC8vICAgfVxuXG4gICAgICAvLyAgIC8vIH0gZWxzZSBcblxuICAgICAgLy8gICBpZihwYXRoW3BhdGgubGVuZ3RoLTFdPT09cGFydGlhbFN1Yi5zcGVjaWFsRml4KSB7XG4gICAgICAvLyAgICAgcGF0aC5wb3AoKVxuICAgICAgLy8gICB9XG4gICAgICAgIFxuICAgICAgLy8gICBkZWxldGUgcGFydGlhbFN1Yi5zcGVjaWFsRml4XG4gICAgICAvLyB9XG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCdMRVRTIERPIElUIElUSSBJVCcuZ3JlZW4uaW52ZXJzZSwgcGFydGlhbFN1YilcblxuICAgICAgLy8gcGFydGlhbFN1Yi5ERUJVRyRsb2coJ3BhcnRpYWwnKVxuXG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRhICYmIHZhbC5fX3N1Yikge1xuICAgIC8vaXNEYXRhK1N1YnNjcmlwdGlvblxuICAgICAgLy9kaXQgbW9ldCBvb2sgZ2VmaXhlZCEhISEhISEhIVxuICAgICAgcGFydGlhbFN1YiA9IG5ldHdvcmtEYXRhRWxlbWVudC5wYXJzZURhdGEodmFsKVxuXG4gICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiB2T2JqZWN0ICkge1xuICAgIC8vdk9iamVjdFxuICAgICAgbGlzdGVuZXJzID0gdmFsLl9saXN0ZW5lcnNcblxuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5fcGF0aCwgJ0xJU1RFTkVSJywgZnJvbSApXG5cbiAgICAgIGlmKGxpc3RlbmVycykge1xuICAgICAgICBmb3IoIHZhciBsaXN0ZW5lciQ9MCwgbGVuJD1saXN0ZW5lcnMubGVuZ3RoOyBsaXN0ZW5lciQ8bGVuJDsgbGlzdGVuZXIkKysgKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyEhISEhISEhISEhIGxpc3RuZXIkMzMzMzMzJy5yZWQuaW52ZXJzZSwgbGlzdGVuZXJzW2xpc3RlbmVyJF0pXG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tPicsdGhpcy5fcGF0aCwgJ0xJU1RFTkVSLCAnICwgbGlzdGVuZXJzW2xpc3RlbmVyJF0uX3BhdGgsIHZhbClcbiAgICAgICAgICB0aGlzLnN1YnNjcmliZSggbGlzdGVuZXJzW2xpc3RlbmVyJF0sIHZhbCApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYodmFsLl9wYXJlbnQgJiYgIXZhbC5fcGFyZW50LmNsb3VkKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwYXJlbnQnLHZhbC5fcGFyZW50LCB2YWwuX3BhcmVudC5fbGlzdGVuZXJzKVxuICAgICAgLy8gICBsaXN0ZW5lcnMgPSB2YWwuX3BhcmVudC5fbGlzdGVuZXJzXG5cbiAgICAgIC8vICAgLy8gdmFsLl9wYVxuICAgICAgLy8gICBpZihsaXN0ZW5lcnMpIHtcbiAgICAgIC8vICAgICBmb3IgKHZhciBsaXN0ZW5lciQ9MCwgbGVuJD1saXN0ZW5lcnMubGVuZ3RoOyBsaXN0ZW5lciQ8bGVuJDsgbGlzdGVuZXIkKyspIHtcbiAgICAgIC8vICAgICAgIHRoaXMuc3Vic2NyaWJlKGxpc3RlbmVyc1tsaXN0ZW5lciRdLCBmYWxzZSwgdHJ1ZSlcbiAgICAgIC8vICAgICB9XG4gICAgICAvLyAgIH1cbiAgICAgIC8vIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAodmFsICYmIHV0aWwuaXNPYmoodmFsKSAmJiAhKHZhbCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgLy9pc05vcm1hbFN1YnNjcmlwdGlvblxuICAgICAgLy8gY29uc29sZS5sb2coJ0lTIE9CSicuY3lhbilcbiAgICAgIHBhcnRpYWxTdWIgPSB2YWxcbiAgICAgIHZhbCA9IEpTT04uc3RyaW5naWZ5KHZhbClcbiAgICB9XG5cbiAgICBpZiAocGFydGlhbFN1Yikge1xuXG4gICAgIC8vaWYhIGVtcHR5XG4gICAgIC8vIGNvbnNvbGUubG9nKCcyIExFVFMgRE8gSVQgSVRJIElUIDInLHRoaXMgLCBwYXRoLCAnZnJvbTonLCBmcm9tLCAnc3ViOicsIG5ldHdvcmtEYXRhRWxlbWVudC5wYXJzZURhdGEoZnJvbSwgcGFydGlhbFN1YiwgdGhpcy5fc3VicyApIClcblxuICAgICB2YXIgZnJvbUNoZWNrXG4gICAgIGlmKGZyb20pIHBhcnRpYWxTdWIgPSBuZXR3b3JrRGF0YUVsZW1lbnQucGFyc2VEYXRhKGZyb20sIHBhcnRpYWxTdWIsIHRoaXMuX3N1YnMpXG4gICAgICAvL2RlIGNoZWNrIG1vZXQgbnUgaW4gZnJvbSBnZWJldXJlblxuICAgICAgLy8gY29uc29sZS5sb2coJy5zdWJzY3JpYmUgY2xvdWQuZGF0YSBwYXJ0aWFsU3ViIGFyZSB3ZSBzdXJlIHRoaXMgaXMgZnJvbSBhIHJlZiBpbiB0aGUgY2xvdWQnLmJsdWUuaW52ZXJzZSwgcGFydGlhbFN1YiwgcGF0aCkgLy9yZXBsYWNlIC93IGZyb21cblxuICAgICAgaWYoZnJvbSAmJiBmcm9tLmNsb3VkICYmIGZyb20uX3ZhbCA9PT0gdGhpcykge1xuICAgICAgICBwYXRoID0gZnJvbS5fcGF0aCAvL2lmIGZyb20gaXMgY2xvdWRcbiAgICAgICAgLy8gYWxlcnQoJyEnKVxuICAgICAgICBmcm9tQ2hlY2sgPSB0cnVlXG4gICAgICAgIC8vIGNvbnNvbGUud2FybignZG8gbm90aGluZyBwcm9wIGZyb20gY2xvdWQnLCBmcm9tKVxuICAgICAgfVxuXG4gICAgIHN1YiA9IGNyZWF0ZVN1YihwYXRoLCB7fSwgcGFydGlhbFN1YilcbiAgICAgc3RyaW5naWZpZWQgPSBKU09OLnN0cmluZ2lmeShzdWIpXG5cbiAgICAgdmFyIHN1YnN0YXJnZXQgPSAgZnJvbUNoZWNrID8gZnJvbSA6IHRoaXNcblxuICAgICBpZighc3Vic3RhcmdldC5fc3Vicykgc3Vic3RhcmdldC5fc3VicyA9IFtdXG4gICAgIGlmKGVsZW0pIGVsZW0uX3N1YnNjcmliZWQgPSB0cnVlXG4gICAgIC8vIGNvbnNvbGUubG9nKCczTEVUUyBETyBJVCBJVEkgSVQgMycucmVkLmludmVyc2UsIG5ldHdvcmtEYXRhRWxlbWVudC5wYXJzZURhdGEoZnJvbSwgcGFydGlhbFN1YikgKVxuXG4gICAgICBzdWJzQXJyYXkgPSBbIHBhcnRpYWxTdWIsIGVsZW0gfHwgdmFsICwgc3RyaW5naWZpZWQgXVxuXG4gICAgICBpZihmcm9tTmFtZSkge1xuICAgICAgICBzdWJzQXJyYXkucHVzaChmcm9tTmFtZSlcbiAgICAgIH1cblxuICAgICAgZXhpc3RzID0gdXRpbC5jaGVja0FycmF5KCBzdWJzdGFyZ2V0Ll9zdWJzLCBzdHJpbmdpZmllZCwgMilcbiAgICAgIC8vbWF5YmUgY2hlY2sgaWYgdmFsIGFscmVhZHkgZXhpc3RzXG4gICAgICAvLyBjb25zb2xlLmxvZygnIFRFU1QgVFJVRSAtLS0tLSBTVUJTQ1JJQkUnLCBmcm9tLCBleGlzdHMsIHRoaXMuX3N1YnMsIHN0cmluZ2lmaWVkLCBwYXJ0aWFsU3ViLCBzdWIgKVxuICAgICAgLy9UT0RPOiBjaGVjayBpZiBub3QgZXhpc3RzIHN1YnNBcnJheSBlYWNoIGZpZWxkXG4gICAgICAvLyBjb25zb2xlLmxvZygnUFVTSCEgU1VCUycuZ3JlZW4uaW52ZXJzZSwgc3Vic0FycmF5ICxzdHJpbmdpZmllZCwgZXhpc3RzIClcbiAgICAgIHZhciBzYW1lXG4gICAgICBmb3IodmFyIGkgaW4gc3Vic3RhcmdldC5fc3VicyApIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyhzdWJzdGFyZ2V0Ll9zdWJzW2ldLCBpLCBzdWJzdGFyZ2V0Ll9wYXRoKVxuICAgICAgICAvL2NvbXBhcmUgb2JqZWN0c1xuXG4gICAgICAgIGlmKCBzdWJzdGFyZ2V0Ll9zdWJzW2ldWzFdID09PSAoZWxlbSB8fCB2YWwpICYmIHN1YnN0YXJnZXQuX3N1YnNbaV1bMl0gPT09IHN0cmluZ2lmaWVkICkge1xuICAgICAgICAgIC8vZGlzdGluY2F0aW9uISEhIVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdUSEUgU0FNRScuY3lhbi5pbnZlcnNlKVxuICAgICAgICAgIHNhbWUgPSB0cnVlXG4gICAgICAgIH1cblxuICAgICAgfVxuXG4gICAgICBpZighc2FtZSkge1xuICAgICAgc3Vic3RhcmdldC5fc3Vicy5wdXNoKCBzdWJzQXJyYXkgKVxuICAgICAgICAvL2p1c3QgZG9udCBzdWJzY3JpYmUgLS0tXG4gICAgICAgIGlmICggZXhpc3RzPT09ZmFsc2UgKSB7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnIFRSVUUgLS0tLS0gU1VCU0NSSUJFJywgSlNPTi5zdHJpbmdpZnkoc3ViLGZhbHNlLDIpIClcbiAgICAgICAgICB0aGlzLmNsb3VkLnN1YnNjcmliZShzdWIsIHN0cmluZ2lmaWVkKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUud2FybignQUxMUkVBRFkgRVhJU1RTIScsIHN1Yiwgc3RyaW5naWZpZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuLCAndW5zdWJzY3JpYmUnXG4sIGZ1bmN0aW9uKCB2YWwsIGZyb20gKSB7XG5cbiAgICAvL3RvZG86IGRvdWJsZSBjaGVjayBpZiB0aGlzIGdvZXMgd2VsbFxuICAgIC8vIGNvbnNvbGUuZXJyb3IoJzF1bnN1YnNjcmliZSEnKVxuXG4gICAgLy9kb3VuZGxlIHJlbW92ZVxuXG4gICAgaWYgXG4gICAgKCAhdmFsXG4gICAgICB8fCB2YWwuX2NvbFxuICAgICAgfHwgKHZhbC5fZmlsdGVyICYmIHZhbC5fZmlsdGVyLl9jb2wpXG4gICAgICB8fCAhKCF2YWwuX2Rmcm9tIHx8IHZhbC5fZm1vZGVsKVxuICAgICkgXG4gICAgeyBcbiAgICAgIHJldHVybiBcbiAgICB9XG5cbiAgICAgdmFyIHBhdGggPSB0aGlzLl9wYXRoXG4gICAgICAgLCBzdHJpbmdpZmllZFxuICAgICAgICwgc3Vic0FycmF5XG4gICAgICAgLCBzdWJcbiAgICAgICAsIGV4aXN0c1xuICAgICAgICwgcGFydGlhbFN1YlxuICAgICAgICwgaW5kZXhcbiAgICAgICAsIGZpZWxkXG4gICAgICAgLCBsaXN0ZW5lcnMgPSB2YWwuX2xpc3RlbmVyc1xuXG4gICAgLy8gY29uc29sZS5sb2coJ3Vuc3Vic2NyaWJsZXgnLCdwYXRoOicuYmx1ZSwgcGF0aCwgJ3N0cmluZ2lmaWVkOicuYmx1ZSwgIHN1YiwgJ3RoaXM6Jy5ibHVlLHRoaXMsICd2YWw6Jy5ibHVlLCB2YWwsICdmcm9tOicsZnJvbSApXG5cbiAgICBpZiAoIHV0aWwuaXNPYmooIHZhbCApICYmICEoIHZhbCBpbnN0YW5jZW9mIEFycmF5ICkgKSB2YWwgPSBKU09OLnN0cmluZ2lmeSggdmFsIClcblxuICAgIGluZGV4ID0gdGhpcy5fc3VicyAmJiB1dGlsLmNoZWNrQXJyYXkoIHRoaXMuX3N1YnMsIHZhbCwgMSApXG4gICAgLy9uaWV0IGFsbGUgMSdzIHdlZ2hhbGVuXG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Vuc3Vicz8/Pz8/PycucmVkLmludmVyc2UsIHV0aWwuY2xvbmUodGhpcy5fc3VicyksIHZhbCwgaW5kZXgsIHRoaXMgKVxuICAgICAgICAvL21pc3NpbmcgaW5kZXghXG5cblxuICAgIGlmICggaW5kZXghPT1mYWxzZSAmJiBpbmRleCAhPT0gdm9pZCAwICkge1xuXG5cblxuXG4gICAgICBpZih2YWwubW9kZWwgJiYgdmFsLm1vZGVsLnBhcnNpbmcpIHtcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnTU9ERUwgdW5zdWJzPz8/Pz8/Jy5yZWQuaW52ZXJzZSlcbiAgICAgICAgLy8gdmFyIHJlbW92ZUlcblxuICAgICAgICAvL2Jsb2NrIHVuc3VicyBvbiBtb2RlbCBwYXJzaW5nXG4gICAgICAgIGlmKHZhbC5tb2RlbCAmJiB2YWwubW9kZWwuZmllbGQgKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5jbGVhcigpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1dBUk4hIHVuc3VicyBmaWVsZCBXQVJOIScucmVkLmludmVyc2UsIGZyb20sIHRoaXMuX3N1YnNbaW5kZXhdIClcblxuICAgICAgICAgIC8vcmVhcHBseSBpZiBmaWVsZFxuICAgICAgICAgIGZpZWxkID0gdGhpcy5nZXQodmFsLm1vZGVsLmZpZWxkLnZhbClcbiAgICAgICAgICBpZighZmllbGQuX3N1YnMpIGZpZWxkLl9zdWJzID0gW11cblxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdXQVJOISB1bnN1YnMgZmllbGQgV0FSTiEnLnJlZC5pbnZlcnNlLGZpZWxkPT09dGhpcywgZmllbGQsIGZyb20sIHRoaXMuX3N1YnNbaW5kZXhdIClcblxuXG4gICAgICAgICAgdmFyIF9fc3VicyA9IHV0aWxcbiAgICAgICAgICAgIC5nZXQoIHRoaXMuX3N1YnNbaW5kZXhdWzBdLCB2YWwubW9kZWwuZmllbGQudmFsIClcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICdzdWJzWzBdJy5ibHVlLCAgdGhpcy5fc3Vic1tpbmRleF1bMF0gKVxuXG4gICAgICAgICAgaWYoIF9fc3VicyApIHtcbiAgICAgICAgICB0aGlzLl9zdWJzW2luZGV4XVswXSA9IF9fc3Vic1xuICAgICAgICAgIC8vIGZpZWxkLl9zdWJzLnB1c2godGhpcy5fc3Vic1tpbmRleF0pXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBTVUJTIGFuZCBwdXNoJy5yZWQuaW52ZXJzZSwgaW5kZXgsZmllbGQuX3N1YnMsIF9fc3VicywgdGhpcy5fc3Vic1tpbmRleF0sIHRoaXMuX3BhdGgpXG4gICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgICAvLyB0aGlzLl9zdWJzLnNwbGljZShpbmRleCwgMSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnd2FybicucmVkKVxuXG4gICAgICAgIH1cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggX19zdWJzIClcblxuXG4gICAgICAgICBcbiAgICAgICAgICAvL2RpdCBmZiBiZXRlciBkb2VuIChtZWVyZGVyZSBfc3VicylcbiAgICAgICAgICAvL3RlbCBjb3VudHNcbiAgICAgICAgICBcbiAgICAgICAgICAvL3Zvb3IgZGV6ZSBzcGxpY2UgY2hlY2sgb3AgaW5kZXggZW4gc3RyaW5naWZpZWQhXG5cbiAgICAgICAgIFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHN1YnNBcnJheSA9IHRoaXMuX3N1YnNbaW5kZXhdXG4gICAgICBzdHJpbmdpZmllZCA9IHN1YnNBcnJheVsyXVxuICAgICAgcGFydGlhbFN1YiA9IHN1YnNBcnJheVswXVxuICAgICAgLy8gaWYoZnJvbSkgcGFydGlhbFN1YiA9IG5ldHdvcmtEYXRhRWxlbWVudC5wYXJzZURhdGEoZnJvbSwgcGFydGlhbFN1YilcblxuICAgICAgLy8gY29uc29sZS5sb2coICdwYXJ0aWFsU3ViJy5pbnZlcnNlLCBwYXJ0aWFsU3ViIClcblxuICAgICAgc3ViID0gY3JlYXRlU3ViKHBhdGgsIHt9LCBwYXJ0aWFsU3ViKVxuXG4gICAgICAvL3Zvb3IgZGV6ZSBzcGxpY2UgY2hlY2sgb3AgaW5kZXggZW4gc3RyaW5naWZpZWQhXG4gICAgICAvL2thbiBkdXMgb29rIGVmZmljaWVudGVyXG4gICAgICAvLyBpZiggcmVtb3ZlSSAhPT0gdm9pZCAwICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVNT1ZFJywgaW5kZXgpXG4gICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVNT1ZFIFNVQlMnLnJlZC5pbnZlcnNlLCBpbmRleCwgdGhpcy5fc3VicywgdGhpcy5fcGF0aCApXG4gICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgdGhpcy5fc3Vicy5zcGxpY2UoaW5kZXgsIDEpXG5cbiAgICAgIC8vIH1cblxuXG5cbiAgICAgIGV4aXN0cyA9IHV0aWwuY2hlY2tBcnJheSh0aGlzLl9zdWJzLCBzdHJpbmdpZmllZCwgMilcblxuICAgICAgaWYoZXhpc3RzIT09ZmFsc2UpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0VYSVNUUz8/Pz8nLmN5YW4uaW52ZXJzZSwgZXhpc3RzLCBzdHJpbmdpZmllZCwgdGhpcy5fc3VicywgdGhpcy5fcGF0aCwgdGhpcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCchRVhJU1RTJyAsIGV4aXN0cywgc3RyaW5naWZpZWQpXG4gICAgICB9XG5cbiAgICAgIGlmICggZXhpc3RzID09PSBmYWxzZSApIHRoaXMuY2xvdWQudW5zdWJzY3JpYmUoc3ViLCBzdHJpbmdpZmllZClcbiAgICAgICAgLy8gdGhpcy5fc3Vic1JBRi5wdXNoKFtzdWIsIHN0cmluZ2lmaWVkXSlcbiAgICAgICAgLy8gdGhpcy5fc3Vic1JBRiA9IFtdIHNlYXJjaCAmIHJlbW92ZSB1c2UgZGlmZmVyZW50IGlkZW50aWZpZXJzIGUuZy4gc3VicyBhcnJheVxuXG4gICAgfSBlbHNlIGlmKCB2YWwuX3JlbW92ZWQgKSB7XG5cbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd1bnN1YnM/PzIyMjIyPz8/PyAyMjIyMjIyJy5yZWQuaW52ZXJzZSlcblxuICAgICAgLy8gY29uc29sZS5lcnJvcignaXMgdGhpcyByZWFsbHkgbmVzc2VjYXJ5PyBfcmVtb3ZlZCAsIGZyb2NlIGFsbCBsaXN0ZW5lcnMgcmVtb3ZlIHRhZ2V0cyBldGMnKVxuICAgIH0gZWxzZSBpZihsaXN0ZW5lcnMpIHtcblxuICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Vuc3Vicz8/MzMzMzMzMzMzPz8/PyAyMjIyMjIyJy5yZWQuaW52ZXJzZSlcblxuICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0+IHRoaXMgaXMgYWxzbyBwcmV0dHkgZGlmZmVyZW50ISBfbGlzdGVuZXJzJylcbiAgICAgIGZvciAodmFyIGxpc3RlbmVyJD0wLCBsZW4kPWxpc3RlbmVycy5sZW5ndGg7IGxpc3RlbmVyJDxsZW4kOyBsaXN0ZW5lciQrKykge1xuICAgICAgICBpZiAobGlzdGVuZXJzW2xpc3RlbmVyJF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUobGlzdGVuZXJzW2xpc3RlbmVyJF1bMV0sIHZhbClcbiAgICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnNbbGlzdGVuZXIkXS5fX3QpIHtcbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKGxpc3RlbmVyc1tsaXN0ZW5lciRdLCB2YWwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICB9XG4pXG4iLCJtb2R1bGUuZXhwb3J0cyA9IERhdGFDbG91ZFxuXG52YXIgdGltZXN0YW1wID0gcmVxdWlyZSgnbW9ub3RvbmljLXRpbWVzdGFtcCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9vYmplY3QnKSxcbiAgQ2xvdWREYXRhID0gcmVxdWlyZSgnLi9kYXRhJyksXG4gIFZPYmplY3QgPSByZXF1aXJlKCcuLi8uLi8uLi9vYmplY3QnKSxcbiAgQmF0Y2ggPSBWT2JqZWN0Lm5ldyh7XG4gICAgbWVyZ2U6IHRydWVcbiAgfSksXG4gIENsb3VkU3RhdGUgPSBWT2JqZWN0Lm5ldyh7XG4gICAgbWVyZ2U6IHRydWVcbiAgfSksXG4gIG1ha2VIYXNoID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9oYXNoJyksXG4gIGJhdGNodGltZSA9IDIwLFxuICBTVUJTID0gJ3N1YnMnLFxuICBTRVRTID0gJ3NldHMnLFxuICBVTlNVQlMgPSAndW5zdWJzJ1xuXG5mdW5jdGlvbiBEYXRhQ2xvdWQgKCkge1xuICAvLyB3aW5kb3cuZGF0YWNsb3VkID0gdGhpc1xuICB2YXIgY2xvdWQgPSB0aGlzXG4gIGNsb3VkLl9qb2lucyA9IHt9XG4gIGNsb3VkLl9zdGF0dXMgPSAxXG5cbiAgY2xvdWQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbiAoKSB7XG4gICAgLy8gY29uc29sZS5lcnJvcignLS0tLSBjbG91ZCBjb25uZWN0ID4+IGNsb3VkLl9zdGF0dXMrKyBjYWxsIF9yZWNvbm5lY3QnKVxuICAgIGNsb3VkLl9zdGF0dXMrK1xuICAgIGNsb3VkLl9yZWNvbm5lY3QoKVxuICB9KVxuXG4gIC8vIGNvbnNvbGUubG9nKCdzdGFydCBtYWtpbmcgc3RhdGUnKVxuICBjbG91ZC5zdGF0ZSA9IG5ldyBDbG91ZFN0YXRlKHtcbiAgICAgICAgc3Viczoge1xuICAgICAgICAgIG1hcDoge30sXG4gICAgICAgICAgdHJlZToge31cbiAgICAgICAgfSxcbiAgICAgICAgc2V0czoge1xuICAgICAgICAgIG1hcDoge30gLyosIGxpc3Q6W10qL1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyAsIHsgbG9jYWxzdG9yYWdlOiAnVkMkJyB9XG4gICAgKVxuICAgIC8vIGNvbnNvbGUubG9nKCdkb25lIG1ha2luZyBzdGF0ZScsIEpTT04uc3RyaW5naWZ5KGNsb3VkLnN0YXRlLnJhdyxmYWxzZSwyKSlcblxuICBpZiAoIWNsb3VkLnN0YXRlLnNldHMubGlzdCkgY2xvdWQuc3RhdGUuc2V0cy5zZXQoJ2xpc3QnLCBbXSlcbiAgICAvLyBeXiBzZXQgbWV0IGxlZ2UgYXJyYXkgbWVyZ2VkIG5pZXRcblxuICBjbG91ZC5iYXRjaCA9IHtcbiAgICBtYXBzOiB7XG4gICAgICBzZXRzOiB7fSxcbiAgICAgIHN1YnM6IHt9LFxuICAgICAgdW5zdWJzOiB7fVxuICAgIH1cbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCctLS0tLS1TRVQgQyBEQVRBJylcblxuICBjbG91ZC5kYXRhID0gbmV3IENsb3VkRGF0YSh7fSwgZmFsc2UgLy97bG9jYWxzdG9yYWdlOidjbG91ZERhdGEnfVxuICAgICwgZmFsc2UsIHRoaXMpXG5cbiAgLy8gY29uc29sZS5sb2coJy0tLS0tLUxPRycpXG5cblxuICAvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeSggY2xvdWQuZGF0YS5yYXcsZmFsc2UsMikpXG4gIC8vIF5eIGRpdCBrYW4gZG9vciB3ZWlyZGUgc2hpdCBpbiBsb2NhbFN0b3JhZ2UgZGUgY29uc3RydWN0b3IgbGF0ZW4ga2FwcGVuIVxuXG4gIC8vIGNsb3VkLm9uKCdpbmNvbWluZzo6cG9uZycsIHRoaXMuX2NsZWFyQ2FjaGUpXG4gIC8vIGNsb3VkLm9uKCdkYXRhJywgdGhpcy5fY2xlYXJDYWNoZSlcblxuICBjbG91ZC5fcVRpbWVyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gX3FUaW1lciAoKSB7XG4gICAgY2xvdWQuX2RvQmF0Y2goKVxuICB9LCBiYXRjaHRpbWUpXG5cblxuICAvLyBjbG91ZC5vbignd2VsY29tZScsIGZ1bmN0aW9uIG9uV2VsY29tZSgpe1xuXG4gIC8vIH0pXG5cbiAgY2xvdWQub24oJ3N1YnNjcmliZWQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgLy8gY29uc29sZS5lcnJvcignPj4+IEhleSBDbG91ZCBzYXlzIGltIHN1YnNjcmliZWQgdG8nLCBtc2cpXG4gIH0pXG5cbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS50aW1lU3luYyA9IGZ1bmN0aW9uIHRpbWVTeW5jICgpIHtcbiAgLy8gY29uc29sZS5sb2coJ3RpbWVTeW5jIScpXG4gIHZhciBjbG91ZCA9IHRoaXMsXG4gICAgb3V0c3RhbXAgPSBEYXRlLm5vdygpXG4gIGNsb3VkLmVtaXQoJ3RpbWUnLCBmdW5jdGlvbiAoY2xvdWRzdGFtcCkge1xuXG4gICAgdmFyIHRyYXZlbHRpbWUgPSBEYXRlLm5vdygpIC0gb3V0c3RhbXAsXG4gICAgICBhcnJpdmFsID0gb3V0c3RhbXAgKyB0cmF2ZWx0aW1lIC8gMixcbiAgICAgIG9mZnNldCA9IGNsb3Vkc3RhbXAgLSBhcnJpdmFsXG4gICAgICAvLyBjb25zb2xlLmxvZygndGltZXN0YW1wIGluJywgdHJhdmVsdGltZSwgJ29mZnNldCcsIG9mZnNldClcbiAgICBpZiAodHJhdmVsdGltZSA8IGNsb3VkLl90aW1lVHJhdmVsKSB7XG4gICAgICBjbG91ZC5fdGltZVRyYXZlbCA9IHRyYXZlbHRpbWVcbiAgICAgIGNsb3VkLl90aW1lT2Zmc2V0ID0gb2Zmc2V0XG4gICAgfVxuICAgIHZhciB0cmllcyA9IGNsb3VkLl90aW1lVHJpZXMrK1xuICAgICAgaWYgKHRyYXZlbHRpbWUgPiA3NSAmJiB0cmllcyA8IDEwIHx8IHRyYXZlbHRpbWUgPiA1MCAmJiB0cmllcyA8IDUgfHwgdHJhdmVsdGltZSA+IDIwICYmIHRyaWVzIDwgMikge1xuICAgICAgICBjbG91ZC50aW1lU3luYygpXG4gICAgICB9XG4gIH0pXG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUub3V0TGlzdCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICB2YXIgYmF0Y2ggPSB0aGlzLmJhdGNoXG4gIGlmICghYmF0Y2gubGlzdHMpIHtcbiAgICBiYXRjaC5saXN0cyA9IHt9XG4gICAgcmV0dXJuIGJhdGNoLmxpc3RzW2xhYmVsXSA9IFtdXG4gIH0gZWxzZSBpZiAoIWJhdGNoLmxpc3RzW2xhYmVsXSkge1xuICAgIHJldHVybiBiYXRjaC5saXN0c1tsYWJlbF0gPSBbXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXRjaC5saXN0c1tsYWJlbF1cbiAgfVxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLl9kb0JhdGNoID0gZnVuY3Rpb24gX2RvQmF0Y2ggKCkge1xuICB2YXIgY2xvdWQgPSB0aGlzLFxuICAgIG91dCA9IGNsb3VkLmJhdGNoLmxpc3RzXG5cbiAgaWYgKG91dCkge1xuICAgIC8vIGNvbnNvbGUubG9nKCdlbWl0IGRhdCBiYXRjaCBvdXQhJylcbiAgICAvLyBjb25zb2xlLmxvZygnRU1JVFRJTkchJyxvdXQpXG4gICAgLy8gaWYodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgIC8vICAgY29uc29sZS5sb2coJ3dyaXRpbmcgb3V0JywgSlNPTi5zdHJpbmdpZnkob3V0KS5zbGljZSgwLDUwKSlcbiAgICAvLyAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoKVxuICAgIC8vICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkob3V0LGZhbHNlLDIpKVxuICAgIC8vICAgY29uc29sZS5ncm91cEVuZCgpXG4gICAgLy8gfVxuICAgIGNsb3VkLmVtaXQoJ2JhdGNoJywgb3V0KVxuICAgICAgLy8gY2xvdWQud3JpdGUob3V0KVxuICAgICAgLy8gY2FjaGUgc2V0cyB1bnRpbGwgbmV4dCBoZWFydGJlYXRcbiAgICAgIC8vIHZhciBzZXRzbGlzdCA9IG91dC5zZXRzXG4gICAgICAvLyBpZihzZXRzbGlzdCkge1xuICAgICAgLy8gICB2YXIgY2FjaGUgPSBjbG91ZC5zdGF0ZS5zZXRzXG4gICAgICAvLyAgICAgLCBzZXRzbWFwID0gY2xvdWQuYmF0Y2gubWFwcy5zZXRzXG5cbiAgICAvLyAgIGZvcih2YXIgaGFzaCBpbiBzZXRzbWFwKSB7XG4gICAgLy8gICAgIHZhciB1cGRhdGUgPSBzZXRzbWFwW2hhc2hdLnVwZGF0ZVxuICAgIC8vICAgICBpZih1cGRhdGVbMV0gPT09IG51bGwpXG4gICAgLy8gICAgICAgdXBkYXRlWzFdID0gJyQkbnVsbCdcbiAgICAvLyAgICAgc3RvcmVTZXQoaGFzaCwgdXBkYXRlLCBjYWNoZS5saXN0LCBjYWNoZS5tYXApXG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIGNsb3VkLmJhdGNoLmxpc3RzID0gbnVsbFxuICAgIGNsb3VkLmJhdGNoLm1hcHMgPSB7XG4gICAgICBzdWJzOiB7fSxcbiAgICAgIHNldHM6IHt9LFxuICAgICAgdW5zdWJzOiB7fVxuICAgIH1cbiAgfVxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLl9jbGVhckNhY2hlID0gZnVuY3Rpb24gX2NsZWFyQ2FjaGUgKCkge1xuICAvLyBpZih0aGlzLnN0YXRlLnNldHMubGlzdC5sZW5ndGgpe1xuICAvLyAgIHRoaXMuc3RhdGUuc2V0cy5yZW1vdmUoKVxuICAvLyAgIHRoaXMuc3RhdGUuc2V0KCdzZXRzJywge21hcDp7fSxsaXN0OltdfSlcbiAgLy8gfVxuICAvLyBjb3VsZCBiZSBuaWNlciBpZiB3ZSBoYXZlIGEgZ29vZCB3YXkgb2YgY2xlYXJpbmcgYXJyYXlzXG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gc3Vic2NyaWJlIChzdWJzb2JqLCBzdHIpIHtcbiAgLy8gY29uc29sZS5sb2coJ3N1YnNjcmliZSEnLCBzdHIpXG4gIHZhciBjbG91ZCA9IHRoaXMsXG4gICAgc3RhdGUgPSBjbG91ZC5zdGF0ZSxcbiAgICBoYXNoLCBjYWNoZWRcblxuICBpZiAoc3Vic29iai5oYXNoICYmIHN1YnNvYmouc3Vic29iaikge1xuICAgIC8vIGNvbnNvbGUubG9nKCdkYXMgY2FjaGVkIScpXG4gICAgaGFzaCA9IHN1YnNvYmouaGFzaFxuICAgIGNhY2hlZCA9IHN1YnNvYmpcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXN0cilcbiAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KHN1YnNvYmopXG4gICAgaGFzaCA9IG1ha2VIYXNoKHN0cilcbiAgICBjYWNoZWQgPSBzdGF0ZS5zdWJzLm1hcFtoYXNoXVxuICB9XG4gIC8vIGNvbnNvbGUubG9nKCdoYXNoJywgaGFzaClcblxuXG4gIGlmICghY2FjaGVkKSB7IC8vIHBsYWNlIGluIHRyZWVcblxuICAgIC8vIGNvbnNvbGUubG9nKCdzZXQgYWN0aXZlIScpXG5cbiAgICBzdGF0ZS5zdWJzLm1hcC5zZXQoaGFzaCwge1xuICAgICAgaGFzaDogaGFzaCxcbiAgICAgIHN1YnNvYmo6IHN1YnNvYmosXG4gICAgICBhY3RpdmU6IGNsb3VkLl9zdGF0dXMsXG4gICAgICBjbGVhcmVkOiBmYWxzZVxuICAgIH0pXG4gICAgY2FjaGVkID0gc3RhdGUuc3Vicy5tYXBbaGFzaF1cbiAgICB2YXIgdHJlZSA9IHN0YXRlLnN1YnMudHJlZVxuICAgIGluc2VydExlYWYodHJlZSwgY2FjaGVkLnN1YnNvYmosIGNhY2hlZClcbiAgfSBlbHNlIGlmICghY2FjaGVkLmFjdGl2ZSB8fCBjYWNoZWQuYWN0aXZlLl92YWwpIHtcbiAgICAvLyBjb25zb2xlLndhcm4oJ3N1YnNjcmlwdGlvbiBhbHJlYWR5IGFjdGl2ZSEnLCBjYWNoZWQsIGNhY2hlZC5hY3RpdmUpXG4gICAgcmV0dXJuXG4gIH0gZWxzZSB7XG4gICAgY2FjaGVkLmFjdGl2ZS52YWwgPSBjbG91ZC5fc3RhdHVzXG4gIH1cblxuICB2YXIgdW5zdWJzbWFwID0gY2xvdWQuYmF0Y2gubWFwcy51bnN1YnMsXG4gICAgdW5zdWJpbmRleCA9IHVuc3Vic21hcFtoYXNoXVxuXG4gIGlmICh1bnN1YmluZGV4ICE9PSB2b2lkIDApIHtcbiAgICBjbG91ZC5jYW5jZWwoaGFzaCwgdW5zdWJpbmRleCwgVU5TVUJTKVxuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIHN1YnNsaXN0ID0gY2xvdWQub3V0TGlzdChTVUJTKSxcbiAgICBzdWJzbWFwID0gY2xvdWQuYmF0Y2gubWFwcy5zdWJzLFxuICAgIG91dFxuXG4gIGlmICghY2FjaGVkLmNsZWFyZWQuX3ZhbCkge1xuICAgIGNhY2hlZC5jbGVhcmVkLnZhbCA9IGNsb3VkLl9zdGF0dXNcbiAgICB2YXIgZGVwZW5kcyA9IGNsb3VkLmdldERlcHMoc3RhdGUuc3Vicy50cmVlLCBjYWNoZWQuc3Vic29iaiwgY2FjaGVkLCB7fSlcbiAgICBpZiAoIXV0aWwuZW1wdHkoZGVwZW5kcykpIHtcbiAgICAgIG91dCA9IHtcbiAgICAgICAgJHN1YnNvYmo6IGNhY2hlZC5zdWJzb2JqLnJhdyxcbiAgICAgICAgJGRlcGVuZHM6IGRlcGVuZHNcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0ID0gY2FjaGVkLnN1YnNvYmoucmF3XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG91dCA9IGNhY2hlZC5zdWJzb2JqLnJhd1xuICAgIGNhY2hlZC5jbGVhcmVkLnZhbCA9IGNsb3VkLl9zdGF0dXNcbiAgfVxuXG4gIHN1YnNtYXBbaGFzaF0gPSBzdWJzbGlzdC5sZW5ndGhcbiAgc3Vic2xpc3QucHVzaChvdXQpXG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUuZ2V0RGVwcyA9IGZ1bmN0aW9uIGdldERlcHMgKHRyZWUsIHdhbGtlciwgY2FjaGVkLCBsaXN0KSB7XG4gIHdhbGtlci5lYWNoKGZ1bmN0aW9uIChmKSB7XG4gICAgdmFyIGJyYW5jaCA9IHRyZWVbZl1cbiAgICBpZiAoYnJhbmNoKSB7XG4gICAgICBpZiAoYnJhbmNoLl9zdWJzKSB7XG4gICAgICAgIGJyYW5jaC5fc3Vicy5lYWNoKGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgdmFyIGZvdW5kID0gdGhpcy5fdmFsXG4gICAgICAgICAgaWYgKGZvdW5kLnN1YnNvYmouX3YgJiYgZm91bmQuaGFzaC5fdmFsICE9PSBjYWNoZWQuaGFzaC5fdmFsICYmICFmb3VuZC5jbGVhcmVkLl92YWwgJiYgIWxpc3RbZm91bmQuaGFzaC5fdmFsXSkge1xuICAgICAgICAgICAgZm91bmQuY2xlYXJlZC52YWwgPSBjYWNoZWQuY2xlYXJlZC5fdmFsXG4gICAgICAgICAgICBsaXN0W2ZvdW5kLmhhc2guX3ZhbF0gPSBmb3VuZC5zdWJzb2JqLnJhd1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGdldERlcHMoYnJhbmNoLCB3YWxrZXJbZl0sIGNhY2hlZCwgbGlzdClcbiAgICB9XG4gIH0pXG4gIHJldHVybiBsaXN0XG59XG5cbkRhdGFDbG91ZC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZSAoc3Vic29iaiwgc3RyKSB7XG4gIC8vIHN0aWxsIGRvXG4gIHZhciBjbG91ZCA9IHRoaXNcbiAgLy8gY29uc29sZS5lcnJvcigndW5zdWJzY3JpYmUhJywgc3Vic29iailcbiAgaWYgKHN1YnNvYmogaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIC8vIGNvbnNvbGUubG9nKCd1bnN1YiB3aXRoIGFycmF5Jywgc3Vic29iailcbiAgICB2YXIgdHJlZSA9IGNsb3VkLnN0YXRlLnN1YnMudHJlZSxcbiAgICAgIHNwb3QgPSB0cmVlLmdldChzdWJzb2JqKVxuXG4gICAgaWYgKHNwb3QpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdPSyBVTlNVQlNDUklCRSBUTyBUSElTIENSQVAnLCBzcG90KVxuICAgICAgcmVjdXJVbnN1YihjbG91ZCwgc3BvdCwgc3RyKVxuICAgIH1cbiAgfSBlbHNlIHtcblxuICAgIHZhciBiYXRjaG1hcCA9IGNsb3VkLmJhdGNoLm1hcHMuc3VicyxcbiAgICAgIGhhc2gsXG4gICAgICBjYWNoZWRcblxuICAgIGlmIChzdWJzb2JqLmhhc2gpIHtcbiAgICAgIGhhc2ggPSBzdWJzb2JqLmhhc2gudmFsXG4gICAgICBjYWNoZWQgPSBzdWJzb2JqXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghc3RyKSB7XG4gICAgICAgIHN0ciA9IEpTT04uc3RyaW5naWZ5KHN1YnNvYmopXG4gICAgICB9XG4gICAgICBoYXNoID0gbWFrZUhhc2goc3RyKVxuXG4gICAgICB2YXIgc3RhdGVtYXAgPSBjbG91ZC5zdGF0ZS5zdWJzLm1hcFxuXG4gICAgICBjYWNoZWQgPSBzdGF0ZW1hcFtoYXNoXVxuICAgIH1cblxuICAgIHZhciBpbmRleCA9IGJhdGNobWFwW2hhc2hdXG5cbiAgICBpZiAoaW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgY2xvdWQuY2FuY2VsKGhhc2gsIGluZGV4LCBTVUJTKVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBsaXN0ID0gY2xvdWQub3V0TGlzdCgndW5zdWJzJylcbiAgICAgIGNsb3VkLmJhdGNoLm1hcHMudW5zdWJzW2hhc2hdID0gbGlzdC5sZW5ndGhcbiAgICAgIGxpc3QucHVzaChoYXNoKVxuICAgIH1cblxuICAgIGNhY2hlZC5hY3RpdmUudmFsID0gZmFsc2VcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHJlY3VyVW5zdWIgKGNsb3VkLCBzcG90LCBjbGVhcikge1xuICAvLyBjb25zb2xlLmxvZygncmVjdXJVbnN1YiEnLCBzcG90Ll9wYXRoKVxuICBzcG90LmVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICBpZiAodGhpcy5fc3Vicykge1xuICAgICAgdGhpcy5fc3Vicy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3Vuc3ViIG9uIHRoaXMhJywgdGhpcy5yYXcsICdjbGVhcj8nLCBjbGVhcilcbiAgICAgICAgaWYgKGNsZWFyICYmIHRoaXMuZnJvbS5zdWJzb2JqLl92KSB7XG4gICAgICAgICAgdGhpcy5mcm9tLnN1YnNvYmouX3YucmVtb3ZlKClcbiAgICAgICAgfVxuICAgICAgICBjbG91ZC51bnN1YnNjcmliZSh0aGlzLmZyb20pXG4gICAgICB9KVxuICAgIH1cbiAgICBpZiAoZiAhPT0gJ19zdWJzJykge1xuICAgICAgcmVjdXJVbnN1YihjbG91ZCwgdGhpcywgY2xlYXIpXG4gICAgfVxuICB9KVxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIGNhbmNlbCAoaGFzaCwgaW5kZXgsIGxhYmVsKSB7XG4gIHZhciBiYXRjaCA9IHRoaXMuYmF0Y2gsXG4gICAgbGlzdCA9IGJhdGNoLmxpc3RzW2xhYmVsXVxuICByZW1vdmVJbmRleChsaXN0LCBpbmRleClcbiAgaWYgKCFsaXN0Lmxlbmd0aCkge1xuICAgIGRlbGV0ZSBiYXRjaC5saXN0c1tsYWJlbF1cbiAgICBpZiAodXRpbC5lbXB0eShiYXRjaC5saXN0cykpIHtcbiAgICAgIGRlbGV0ZSBiYXRjaC5saXN0c1xuICAgIH1cbiAgfVxuICB2YXIgbWFwID0gYmF0Y2gubWFwc1tsYWJlbF1cbiAgZGVsZXRlIG1hcFtoYXNoXVxuICBmb3IgKGhhc2ggaW4gbWFwKVxuICAgIGlmIChtYXBbaGFzaF0gPiBpbmRleCkge1xuICAgICAgbWFwW2hhc2hdIC0tXG4gICAgfVxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaGFzaCwgdXBkYXRlKSB7XG5cbiAgLy8gY29uc29sZS5sb2coJ1NFVCBDTE9VRCEnKVxuXG4gIGlmICghdXBkYXRlWzBdLmxlbmd0aCkge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0VNUFRZIFBBVEgnLCB1cGRhdGUpXG4gIH1cblxuICB2YXIgY2xvdWQgPSB0aGlzLFxuICAgIGxpc3QgPSBjbG91ZC5vdXRMaXN0KFNFVFMpLFxuICAgIG1hcCA9IGNsb3VkLmJhdGNoLm1hcHMuc2V0c1xuXG4gIHN0b3JlU2V0KGhhc2gsIHVwZGF0ZSwgbGlzdCwgbWFwKVxufVxuXG5mdW5jdGlvbiBzdG9yZVNldCAoaGFzaCwgdXBkYXRlLCBsaXN0LCBtYXApIHtcbiAgLy8gY29uc29sZS5sb2coJ3N0b3Jlc2V0PyEnKVxuICB2YXIgViA9IGxpc3QuX190LFxuICAgIHN0b3JlZCA9IG1hcFtoYXNoXVxuXG4gIGlmIChzdG9yZWQpIHtcbiAgICB2YXIgdmFsID0gdXBkYXRlWzFdLFxuICAgICAgdHMgPSB1cGRhdGVbMl0sXG4gICAgICBvbGR2YWwgPSBzdG9yZWQudXBkYXRlWzFdXG5cbiAgICBpZiAoVikgb2xkdmFsID0gb2xkdmFsLnJhd1xuXG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCAmJiBvbGR2YWwgaW5zdGFuY2VvZiBPYmplY3QgJiYgISh2YWwuJHBhdGgpICYmICEob2xkdmFsLiRwYXRoKSkge1xuICAgICAgaWYgKCFWKSBvbGR2YWwgPSB1dGlsLmNsb25lKG9sZHZhbClcbiAgICAgIHZhbCA9IHV0aWwubWVyZ2Uob2xkdmFsLCB2YWwpXG4gICAgfVxuXG4gICAgaWYgKFYpIHtcbiAgICAgIHN0b3JlZC51cGRhdGUuc2V0KDEsIHZhbClcbiAgICAgIHN0b3JlZC51cGRhdGUuc2V0KDIsIHRzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZWQudXBkYXRlWzFdID0gdmFsXG4gICAgICBzdG9yZWQudXBkYXRlWzJdID0gdHNcbiAgICB9XG5cbiAgICBpZiAoIVYpIHtcbiAgICAgIHZhciBpID0gc3RvcmVkLmksXG4gICAgICAgIGVuZCA9IGxpc3QubGVuZ3RoIC0gMVxuICAgICAgaWYgKGkgIT09IGVuZCkge1xuICAgICAgICBtb3ZlVG9FbmQobGlzdCwgaSlcbiAgICAgICAgZm9yICh2YXIgbWFwaGFzaCBpbiBtYXApIHtcbiAgICAgICAgICBpZiAobWFwW21hcGhhc2hdLmkgPj0gaSkgbWFwW21hcGhhc2hdLmktLVxuICAgICAgICB9XG4gICAgICAgIHN0b3JlZC5pID0gZW5kXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzZXRvYmogPSB7XG4gICAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICAgIGk6IGxpc3QubGVuZ3RoXG4gICAgfVxuICAgIGlmIChWKSB7XG4gICAgICBtYXAuc2V0KGhhc2gsIHNldG9iailcbiAgICB9IGVsc2Uge1xuICAgICAgbWFwW2hhc2hdID0gc2V0b2JqXG4gICAgfVxuXG4gICAgc3RvcmVkID0gbWFwW2hhc2hdXG4gICAgbGlzdC5wdXNoKHN0b3JlZC51cGRhdGUpXG4gIH1cbn1cblxuRGF0YUNsb3VkLnByb3RvdHlwZS5fcmVjb25uZWN0ID0gZnVuY3Rpb24gX3JlY29ubmVjdCAoKSB7XG5cbiAgLy8gYWxlcnQoJyhSRSlDT05ORUNUIScpXG4gIC8vIGNvbnNvbGUuZXJyb3IoJy0tLS0tLS0tLS0tLS0gKFJFKUNPTk5FQ1QhJylcblxuICB2YXIgY2xvdWQgPSB0aGlzLFxuICAgIHN0YXRlID0gY2xvdWQuc3RhdGUsXG4gICAgc3VicyA9IHN0YXRlLnN1YnMubWFwXG5cbiAgY2xvdWQuX3RpbWVUcmllcyA9IDBcbiAgY2xvdWQuX3RpbWVUcmF2ZWwgPSBJbmZpbml0eVxuICBjbG91ZC50aW1lU3luYygpXG5cbiAgLy8gY2xlYW4gZGF0YVxuICBjbG91ZC5zdGFtcCA9ICdjbGVhbnVwJ1xuICBpZiAoY2xvdWQuZGF0YS5jbGllbnRzKSB7XG4gICAgdmFyIG15Y2xpZW50ID0gY2xvdWQuZGF0YS5jbGllbnRzW2Nsb3VkLmNsaWVudGlkXVxuXG4gICAgaWYobXljbGllbnQpIHtcbiAgICAgIG15Y2xpZW50ID0gbXljbGllbnQucmF3XG4gICAgICBkZWxldGUgbXljbGllbnQua2V5XG4gICAgICBkZWxldGUgbXljbGllbnQudHlwZVxuICAgICAgZGVsZXRlIG15Y2xpZW50LmlwXG4gICAgICBkZWxldGUgbXljbGllbnQudG9rZW5cbiAgICB9XG5cbiAgICBjbG91ZC5kYXRhLnNldCgnY2xpZW50cycsIHtcbiAgICAgIGNsZWFyOiB0cnVlXG4gICAgfSwgdm9pZCAwLCBjbG91ZC5zdGFtcClcblxuICAgIC8vIFRPRE86IHB1dCBhbGwgY2xvdWQuY2xpZW50IGxvZ2ljIGluIG9uZSBwbGFjZVxuICAgIGlmKGNsb3VkLmNsaWVudGlkICYmIGNsb3VkLmNsaWVudCkge1xuICAgICAgY2xvdWQuY2xpZW50LnZhbCA9IGNsb3VkLmRhdGEuY2xpZW50cy5nZXQoY2xvdWQuY2xpZW50aWQsIHt9KVxuICAgICAgaWYobXljbGllbnQpIHtcbiAgICAgICAgY2xvdWQuY2xpZW50LmZyb20udmFsID0gbXljbGllbnRcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoY2xvdWQuZGF0YS51c2Vycykge1xuICAgIGNsb3VkLmRhdGEudXNlcnMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnQ0xFQU4gQ0xPVUQ6IGNsZWFuIHVzcnQhIScsIHRoaXMuX25hbWUpXG5cbiAgICAgIHRoaXMuc2V0KCdjbGllbnRzJywge1xuICAgICAgICBjbGVhcjogdHJ1ZVxuICAgICAgfSwgdm9pZCAwLCBjbG91ZC5zdGFtcClcblxuICAgICAgLy8gQ0xFQU4gTUFJTlNDUkVFTiBBTkQgQUNUSVZFIENMSUVOVD8hXG5cbiAgICAgIC8vIHRoaXMubWFpbnNjcmVlbi5zZXQoJ2NsaWVudFJlZicsIGZhbHNlLCB2b2lkIDAsIGNsb3VkLnN0YW1wKVxuICAgICAgLy8gdGhpcy5tYWluc2NyZWVuLmNsaWVudFJlZi5yZW1vdmUodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBjbG91ZC5zdGFtcClcblxuICAgICAgLy8gdGhpcy5hY3RpdmVDbGllbnQucmVtb3ZlKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgY2xvdWQuc3RhbXApXG5cbiAgICB9KVxuICB9XG5cbiAgLy8gaWYoc2V0cy5sZW5ndGgpe1xuICAvLyAgIHNldHMuc29ydChieVRzKVxuICAvLyAgIGZvcih2YXIgaSA9IDAsIHNldCA7IHNldCA9IHNldHNbaSsrXTspe1xuICAvLyAgICAgaWYoc2V0WzFdID09PSAnJCRudWxsJylcbiAgLy8gICAgICAgc2V0WzFdID0gbnVsbFxuICAvLyAgIH1cbiAgLy8gICBjbG91ZC53cml0ZSh7c2V0czpzZXRzfSlcbiAgLy8gICAvLyB3b3VsZCBiZSBuaWNlciB0byBpbnNlcnQgdGhlbSBpbnRvIGN1cnJlbnQgYmF0Y2hcbiAgLy8gfVxuXG4gIHZhciByZXN1YnMgPSBbXVxuICBzdWJzLmVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAvLyBjb25zb2xlLmxvZygncmVzdWI/JywgZilcbiAgICB2YXIgY2FjaGVkID0gdGhpcyxcbiAgICAgIGFjdGl2ZSA9IGNhY2hlZC5hY3RpdmUsXG4gICAgICBjbGVhcmVkID0gY2FjaGVkLmNsZWFyZWRcblxuICAgIGlmIChhY3RpdmUuX3ZhbCA9PT0gMSkge1xuICAgICAgYWN0aXZlLnZhbCA9IHRydWVcbiAgICAgIGNsZWFyZWQudmFsID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoYWN0aXZlLl92YWwpIHtcbiAgICAgIC8vIGFjdGl2ZS5fdmFsID0gZmFsc2VcblxuICAgICAgYWN0aXZlLnZhbCA9IGZhbHNlXG4gICAgICAvLyBkaXQgd29yZHQgbmlldCBpbiBscyBvcGdlbHNhZ2VuXG5cbiAgICAgIGlmIChjbGVhcmVkLl92YWwgPT09IDEpIHtcbiAgICAgICAgY2xlYXJlZC52YWwgPSB0cnVlXG4gICAgICB9IGVsc2UgaWYgKGNsZWFyZWQuX3ZhbCkge1xuICAgICAgICBjbGVhcmVkLnZhbCA9IGZhbHNlXG4gICAgICB9XG4gICAgICByZXN1YnMucHVzaChjYWNoZWQpXG4gICAgfSBlbHNlIGlmIChjbGVhcmVkLl92YWwpIHtcbiAgICAgIGlmIChjbGVhcmVkLl92YWwgPT09IDEpIHtcbiAgICAgICAgY2xlYXJlZC52YWwgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhcmVkLnZhbCA9IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gIH0pXG4gIGZvciAodmFyIGkgPSAwLCByZXN1YjsgcmVzdWIgPSByZXN1YnNbaV07IGkrKykge1xuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3Jlc3Vic2NyaWJlISEnLCByZXN1Yi5zdWJzb2JqLnJhdylcbiAgICBjbG91ZC5zdWJzY3JpYmUocmVzdWIpXG4gIH1cbiAgLy8gY29uc29sZS5lcnJvcignZG9uZSByZXN1YnNjcmliaW4nKVxuXG4gIGZvciAodmFyIGogaW4gY2xvdWQuX2pvaW5zKSB7XG4gICAgY2xvdWQuam9pbihjbG91ZC5fam9pbnNbal0sIHRydWUpXG4gIH1cblxufVxuXG5EYXRhQ2xvdWQucHJvdG90eXBlLnRpbWVTdGFtcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRzID0gdGltZXN0YW1wKClcbiAgaWYgKHRoaXMuX3RpbWVPZmZzZXQpIHtcbiAgICB0cyArPSB0aGlzLl90aW1lT2Zmc2V0XG4gIH1cbiAgcmV0dXJuIHRzXG59XG5cbmZ1bmN0aW9uIGluc2VydExlYWYgKHRyZWUsIHN1YnNvYmosIGNhY2hlZCkge1xuICBzdWJzb2JqLmVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICBpZiAoZiA9PT0gJyonKSB7XG4gICAgICBpZiAoIXRyZWUuJCkge1xuICAgICAgICB0cmVlLnNldCgnJCcsIHt9KVxuICAgICAgfVxuICAgICAgc3Vic29ialsnKiddLmVhY2goZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgc3Vic29ialsnKiddW3NdWzFdLmVhY2goZnVuY3Rpb24gKHNzKSB7XG4gICAgICAgICAgaW5zZXJ0TGVhZih0cmVlLiQsIHN1YnNvYmpbJyonXVtzXVsxXVtzc10sIGNhY2hlZClcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKCF0cmVlW2ZdKSB7XG4gICAgICB0cmVlLnNldChmLCB7fSlcbiAgICB9XG4gICAgaWYgKHN1YnNvYmpbZl0udmFsID09PSB0cnVlKSB7XG4gICAgICBpZiAoIXRyZWVbZl0uX3N1YnMpIHtcbiAgICAgICAgdHJlZVtmXS5zZXQoJ19zdWJzJywgW2NhY2hlZF0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmVlW2ZdLl9zdWJzLnB1c2goY2FjaGVkKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpbnNlcnRMZWFmKHRyZWVbZl0sIHN1YnNvYmpbZl0sIGNhY2hlZClcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIG1vdmVUb0VuZCAoYXJyLCBpKSB7XG4gIHZhciB0bXAgPSBhcnJbaV1cbiAgd2hpbGUgKGFycltpICsgMV0pIHtcbiAgICBhcnJbaV0gPSBhcnJbKytpXVxuICB9XG4gIGFycltpXSA9IHRtcFxufVxuXG5mdW5jdGlvbiByZW1vdmVJbmRleCAoYXJyLCBpKSB7XG4gIHdoaWxlIChhcnJbaSArIDFdKSB7XG4gICAgYXJyW2ldID0gYXJyWysraV1cbiAgfVxuICBhcnIucG9wKClcbn1cblxuLy8gZnVuY3Rpb24gYnlUcyAoYSwgYikge1xuLy8gICByZXR1cm4gYVsyXSAtIGJbMl1cbi8vIH1cbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xufTtcblxuLyoqXG4gKiBNaXhpbiB0aGUgZW1pdHRlciBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICBvYmpba2V5XSA9IEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBMaXN0ZW4gb24gdGhlIGdpdmVuIGBldmVudGAgd2l0aCBgZm5gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cbkVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIG9uLmZuID0gZm47XG4gIHRoaXMub24oZXZlbnQsIG9uKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXG4gKiByZWdpc3RlcmVkIGNhbGxiYWNrcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgY2I7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2IgPSBjYWxsYmFja3NbaV07XG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IE1hcmN1cyBCZXNqZXMsIG1hcmN1c0B2aWdvdXIuaW9cbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKSxcbiAgaW8gPSB1dGlsLmlzTm9kZSBcbiAgICA/IHJlcXVpcmUoJ3NvY2tldC5pby1jbGllbnQnKSBcbiAgICA6IHJlcXVpcmUoJy4vc29ja2V0LmlvLm1pbi5qcycpLFxuICBHID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9nbG9iYWwnKSxcbiAgaWQgPSByZXF1aXJlKCcuLi8uLi8uLi91dGlsL2lkJyksXG4gIHVybEVuY29kZSA9IHJlcXVpcmUoJy4uL2FqYXgnKS5lbmNvZGUsXG4gIFZPYmplY3QgPSByZXF1aXJlKCcuLi8uLi8uLi9vYmplY3QnKSxcbiAgVmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi92YWx1ZScpLFxuICBFbWl0dGVyID0gcmVxdWlyZSgnLi9lbWl0dGVyJylcblxudmFyIENsb3VkID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBDbG91ZCAodXJsLCBwYXJhbXMpIHtcbiAgXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcGFyYW1zID0ge31cbiAgfVxuXG4gIHZhciBjbG91ZCA9IHRoaXNcbiAgY2xvdWQucGFyYW1zID0gcGFyYW1zXG4gIGNsb3VkLnVybCA9IHVybFxuICBjbG91ZC5WSUQgPSBwYXJhbXMuVklEID0gZml4VklEKHBhcmFtcy5WSUQpXG4gICAgLy8gdmFyIEhJRCA9IHBhcmFtcy5ISUQgfHwgRy5lbnYoJ0hJRCcpXG4gICAgLy8gaWYoSElEKVxuICAgIC8vICAgY2xvdWQuSElEID0gcGFyYW1zLkhJRCA9IEhJRFxuICBjbG91ZC5jb25uZWN0ZWQgPSBuZXcgVmFsdWUoZmFsc2UpXG5cbiAgLy8gY2xvdWQuY29ubmVjdGVkLmFkZExpc3RlbmVyKGZ1bmN0aW9uKCl7XG4gIC8vICAgY29uc29sZS5sb2coJ2Nvbm5lY3RlZDogc3RhdGUgY2hhbmdlID4nLCB0aGlzLnZhbClcbiAgLy8gfSlcblxuICBjbG91ZC5hcGkgPSBuZXcgVmFsdWUoe1xuICAgIGRlZmVyOiBmdW5jdGlvbiAodXBkYXRlLCBhcmdzKSB7XG4gICAgICB2YXIgdHlwZSA9IHRoaXMuZnJvbS5fX3RcbiAgICAgIGlmICh0eXBlICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2xvdWQuYXBpIG5lZWRzIHRvIGJlIGFuIE9iamVjdCcpXG4gICAgICB9XG4gICAgICB1cGRhdGUoKVxuICAgIH1cbiAgfSlcblxuICAvLyBjbG91ZC5hcGkub24oZnVuY3Rpb24oKXtcbiAgLy8gIGNvbnNvbGUuZXJyb3IoJ2xvbGsgY2xvdWQuYXBpIGlzIHNldCEhIG9uJywgdGhpcy52YWwpXG4gIC8vIH0pXG5cbiAgaWYgKHBhcmFtcy5hcGkpIHtcbiAgICBjbG91ZC5hcGkudmFsID0gcGFyYW1zLmFwaVxuICB9XG5cbiAgY2xvdWQuYWRkRG9jdW1lbnRMaXN0ZW5lcnMoKVxuXG4gIGlmICh1cmwgaW5zdGFuY2VvZiBWT2JqZWN0KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB1cmwudmFsXG4gICAgICAvLyBjb25zb2xlLmxvZygnY3VycmVudCcsIGN1cnJlbnQpXG5cbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgY2xvdWQuaW5pdCh1cmwsIHBhcmFtcylcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBsYWNlaG9sZGVyID0gbmV3IEVtaXR0ZXIoKVxuICAgICAgcGxhY2Vob2xkZXIuZW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGNsb3VkLmVtaXRidWZmZXIgfHwgKGNsb3VkLmVtaXRidWZmZXIgPSBbXSlcbiAgICAgICAgYnVmZmVyLnB1c2goYXJndW1lbnRzKVxuICAgICAgfVxuICAgICAgcGxhY2Vob2xkZXIucGxhY2Vob2xkZXIgPSB0cnVlXG4gICAgICBjbG91ZC5zb2NrZXQgPSBwbGFjZWhvbGRlclxuICAgICAgdXJsLmFkZExpc3RlbmVyKGZ1bmN0aW9uICh2YWwsIHAxLCBwMiwgcDMpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1VSTCBWQUwgQ0hBTkdFJywgdGhpcy52YWwpXG4gICAgICAgIGlmICh0aGlzLnZhbCkge1xuICAgICAgICAgIGNsb3VkLmluaXQodXJsLCBwYXJhbXMpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGNvbnNvbGUubG9nKCdub3JtYWwgYnVyayBqdXN0IGluaXQnLCB1cmwpXG4gICAgY2xvdWQuaW5pdCh1cmwsIHBhcmFtcylcbiAgfVxuXG59XG5cbkNsb3VkLmluamVjdCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwvaW5qZWN0JylcblxuQ2xvdWQucHJvdG90eXBlLmFkZERvY3VtZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgY2xvdWQgPSB0aGlzXG4gIGlmICghdXRpbC5pc05vZGUgJiYgd2luZG93LmNvcmRvdmEpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZXN1bWUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnY29ubmVjdGVkOiBSRVNVTUUnKVxuICAgICAgY2xvdWQuY29ubmVjdGVkLnZhbCA9IGZhbHNlXG4gICAgfSwgZmFsc2UpXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncGF1c2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnY29ubmVjdGVkOiBQQVVTRScpXG4gICAgICBjbG91ZC5jb25uZWN0ZWQudmFsID0gZmFsc2VcbiAgICB9LCBmYWxzZSlcbiAgfVxufVxuXG5DbG91ZC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcykge1xuICAvLyBjb25zb2xlLmxvZygnQ0xPVUQgSU5JVCEnKVxuICB2YXIgY2xvdWQgPSB0aGlzLFxuICAgIHNvY2tldCA9IGNsb3VkLmNvbm5lY3QodXJsLCBwYXJhbXMsXG4gICAgICB7IGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBsb2coJ2Rpc2Nvbm5lY3QnKVxuICAgICAgICAgIGNsb3VkLmNvbm5lY3RlZC52YWwgPSBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgbG9nKCdjb25uZWN0JylcbiAgICAgICAgICBjbG91ZC5jb25uZWN0ZWQudmFsID0gdHJ1ZVxuICAgICAgICAgIHNvY2tldC5pby5lbmdpbmUub24oJ2hlYXJ0YmVhdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNsb3VkLmNvbm5lY3RlZC52YWwgPSB0cnVlXG4gICAgICAgICAgfSkgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIHdlbGNvbWU6IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgICAgICAgbG9nKCd3ZWxjb21lJylcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zcGxpdCgnQCcpXG5cbiAgICAgICAgICB2YXIgY2xpZW50aWQgPSBjbG91ZC5jbGllbnRpZCA9IGFkZHJlc3NbMF0sXG4gICAgICAgICAgICBodWJpZCA9IGFkZHJlc3NbMV0sXG4gICAgICAgICAgICBzdGF0ZSA9IGNsb3VkLnN0YXRlXG5cbiAgICAgICAgICBjbG91ZC5odWIgPSBwYXJhbXMuaCA9IGh1YmlkXG5cbiAgICAgICAgICBjbG91ZC5zb2NrZXQuaW8udXJpID0gZml4VXJsKGNsb3VkLnNvY2tldC5pby51cmksIHBhcmFtcylcbiAgICAgICAgfSxcbiAgICAgICAgaG9wOiBmdW5jdGlvbiAobmV3aHViKSB7XG4gICAgICAgICAgbG9nKCdob3AnKVxuICAgICAgICAgIGNsb3VkLmhvcChuZXdodWIpXG4gICAgICAgIH0sXG4gICAgICAgIGVycjogZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGxvZy5lcnJvcihlcnIpXG4gICAgICAgICAgaWYgKGVyci50eXBlID09PSAndG9rZW5DaGVjaycpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbG9jYWxTdG9yYWdlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgncHJvZHVjdGlvbnVzZXJUb2tlbicpXG4gICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCd1c2VySWQnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVjb25uZWN0aW5nOiBsb2dnZXIoJ3JlY29ubmVjdGluZycpLFxuICAgICAgICByZWNvbm5lY3RfYXR0ZW1wdDogbG9nZ2VyKCdyZWNvbm5lY3RfYXR0ZW1wdCcpLFxuICAgICAgICByZWNvbm5lY3Q6IGxvZ2dlcigncmVjb25uZWN0JyksXG4gICAgICAgIHJlY29ubmVjdF9mYWlsZWQ6IGxvZ2dlcigncmVjb25uZWN0X2ZhaWxlZCcpXG4gICAgICB9XG4gICAgKVxuXG4gIHZhciBlbWl0YnVmZmVyID0gY2xvdWQuZW1pdGJ1ZmZlclxuICBpZiAoZW1pdGJ1ZmZlcikge1xuICAgIGZvciAodmFyIGUgaW4gZW1pdGJ1ZmZlcikge1xuICAgICAgc29ja2V0LmVtaXQuYXBwbHkoc29ja2V0LCBlbWl0YnVmZmVyW2VdKVxuICAgIH1cbiAgICBjbG91ZC5lbWl0YnVmZmVyID0gbnVsbFxuICB9XG5cbn1cblxuQ2xvdWQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGxpc3RlbmVycykge1xuXG4gIHZhciBjbG91ZCA9IHRoaXNcblxuICBpZiAoIXVybClcbiAgICB1cmwgPSBjbG91ZC51cmxcbiAgaWYgKCFwYXJhbXMpXG4gICAgcGFyYW1zID0gY2xvdWQucGFyYW1zXG5cbiAgaWYgKHVybCBpbnN0YW5jZW9mIFZPYmplY3QpIHtcbiAgICB1cmwgPSB1cmwudmFsXG4gIH1cblxuICB1cmwgPSBmaXhVcmwodXJsLCBwYXJhbXMpXG5cbiAgdmFyIG9sZHNvY2tldCA9IGNsb3VkLnNvY2tldFxuXG4gIGlmIChvbGRzb2NrZXQgJiYgIW9sZHNvY2tldC5wbGFjZWhvbGRlcikge1xuICAgIG9sZHNvY2tldC5kaXNjb25uZWN0KClcbiAgICBvbGRzb2NrZXQuaW8uZGlzY29ubmVjdCgpXG4gIH1cblxuICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tLSBjbG91ZC5jb25uZWN0IScsIHVybCwgcGFyYW1zKVxuXG4gIHZhciBzb2NrZXQgPSBjbG91ZC5zb2NrZXQgPSBuZXcgaW8odXJsLCB7XG4gICAgZm9yY2VOZXc6IHRydWUsXG4gICAgdGltZW91dDogNWUzXG4gIH0pXG5cbiAgaWYgKGxpc3RlbmVycykge1xuICAgIGZvciAodmFyIGwgaW4gbGlzdGVuZXJzKSB7XG4gICAgICBzb2NrZXQub24obCwgbGlzdGVuZXJzW2xdKVxuICAgIH1cbiAgfVxuXG4gIGlmIChvbGRzb2NrZXQpIHtcbiAgICAvLyBjb25zb2xlLmVycm9yKCctLS0tLS0tLS0tLS0tIHRyYW5zZmVycmluZyBvbGQgbGlzdGVuZXJzJywgc29ja2V0Ll9jYWxsYmFja3MpXG4gICAgcGFzc09uKG9sZHNvY2tldCwgc29ja2V0KVxuICB9XG5cbiAgLy8gLS0tLS0tLSB0aGVzZSBleHRlbnRpb25zIGFyZSBvbmx5IGZvciBsb2dnaW5nXG4gIC8vIHdpbmRvdy5jbG91ZG1lc3NhZ2VzID0gW11cbiAgLy8gdmFyIF9vbmV2ZW50ID0gY2xvdWQuc29ja2V0Lm9uZXZlbnRcbiAgLy8gY2xvdWQuc29ja2V0Lm9uZXZlbnQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIC8vICAgd2luZG93LmNsb3VkbWVzc2FnZXMucHVzaChKU09OLnN0cmluZ2lmeShwYWNrZXQuZGF0YSwgZmFsc2UsIDIpKVxuICAvLyAgIGNvbnNvbGUubG9nKCdpbmNvbWluZyBjbG91ZCBtZXNzYWdlIScsIEpTT04uc3RyaW5naWZ5KHBhY2tldC5kYXRhLCBmYWxzZSwgMikpXG4gIC8vICAgX29uZXZlbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAvLyB9XG4gIC8vIHZhciBfZW1pdCA9IGNsb3VkLnNvY2tldC5lbWl0XG4gIC8vIGNsb3VkLnNvY2tldC5lbWl0ID0gZnVuY3Rpb24gKGV2ZW50LCBkYXRhKSB7XG4gIC8vICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjb25zb2xlLmxvZygnXFxuY2xvdWQuc29ja2V0LmVtaXQ6JywgZXZlbnQsIGRhdGEpXG4gIC8vICAgICBpZiAoZXZlbnQgPT09ICdiYXRjaCcpIHtcbiAgLy8gICAgICAgaWYgKGRhdGEuc3Vicykge1xuICAvLyAgICAgICAgIGZvciAodmFyIHMgaW4gZGF0YS5zdWJzKSB7XG4gIC8vICAgICAgICAgICBpZiAoZGF0YS5zdWJzW3NdLm10dkRhdGEpIHtcbiAgLy8gICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1xcbnN1YnNjcmliaW4gdG8gbXR2RGF0YSEnLCBkYXRhLnN1YnNbc10ubXR2RGF0YSlcbiAgLy8gICAgICAgICAgIH1cbiAgLy8gICAgICAgICB9XG4gIC8vICAgICAgIH1cbiAgLy8gICAgICAgaWYgKGRhdGEuc2V0cykge1xuICAvLyAgICAgICAgIGZvciAodmFyIHMgaW4gZGF0YS5zZXRzKSB7XG4gIC8vICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdzZXQ6JywgSlNPTi5zdHJpbmdpZnkoZGF0YS5zZXRzW3NdKSlcbiAgLy8gICAgICAgICB9XG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vICAgX2VtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAvLyB9XG4gIC8vIC0tLS0tLS0gdGhlc2UgZXh0ZW50aW9ucyBhcmUgb25seSBmb3IgbG9nZ2luZ1xuICBcbiAgcmV0dXJuIHNvY2tldFxuXG59XG5cbkNsb3VkLnByb3RvdHlwZS5ob3AgPSBmdW5jdGlvbiBob3AgKG5ld2h1Yikge1xuXG4gIC8vIGNvbnNvbGUubG9nKCdHT1QgT1JERVIgVE8gSE9QIFRPJywgbmV3aHViKVxuXG4gIHZhciBjbG91ZCA9IHRoaXMsXG4gICAgcGFyYW1zID0gY2xvdWQucGFyYW1zXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tIGRldlxuICBpZiAobmV3aHViLmluZGV4T2YoJ0AnKSAhPT0gLTEpXG4gICAgY2xvdWQudXJsID0gJ3dzOi8vJyArIG5ld2h1Yi5zcGxpdCgnQCcpWzFdXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tIC9kZXZcbiAgY2xvdWQuaHViID0gcGFyYW1zLmggPSBuZXdodWJcbiAgY2xvdWQuY29ubmVjdCgpXG59XG5cbkNsb3VkLnByb3RvdHlwZS53aGVuUmVhZHkgPSBmdW5jdGlvbiB3aGVuUmVhZHkgKGZuKSB7XG4gIGlmICh0aGlzLmNsaWVudGlkKVxuICAgIGZuKClcbiAgZWxzZVxuICAgIHRoaXMub25jZSgnd2VsY29tZScsIGZuKVxufVxuXG5DbG91ZC5wcm90b3R5cGUua2lja1BpbmcgPSBmdW5jdGlvbiBraWNrUGluZyAodGltZSkge1xuICB2YXIgZSA9IHRoaXMuc29ja2V0LmlvLmVuZ2luZVxuICBlLnBpbmcoKVxuICBlLm9uSGVhcnRiZWF0KHRpbWUgfHwgZS5waW5nVGltZW91dClcbiAgZS5zZXRQaW5nKClcbn1cblxuQ2xvdWQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiBkaXNjb25uZWN0ICgpIHtcbiAgdmFyIHNvY2tldCA9IHRoaXMuc29ja2V0XG4gIGlmIChzb2NrZXQpIHtcbiAgICBzb2NrZXQuZGlzY29ubmVjdCgpXG4gICAgc29ja2V0LmlvLmRpc2Nvbm5lY3QoKVxuICB9XG59XG5cbmRlbGVnYXRlTGlzdChDbG91ZC5wcm90b3R5cGUsICdzb2NrZXQnLCBbJ29uJywgJ29uY2UnLCAnZW1pdCddKVxuXG5mdW5jdGlvbiBkZWxlZ2F0ZUxpc3QgKG9iaiwgdGFyZ2V0LCBsaXN0KSB7XG4gIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgZGVsZWdhdGUob2JqLCB0YXJnZXQsIGxpc3RbaV0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVsZWdhdGUgKG9iaiwgdGFyZ2V0LCBmaWVsZCkge1xuICBvYmpbZmllbGRdID0gZnVuY3Rpb24gZGVsZWdhdGVkICgpIHtcbiAgICB2YXIgdGhpbmcgPSB0aGlzW3RhcmdldF1cbiAgICB0aGluZ1tmaWVsZF0uYXBwbHkodGhpbmcsIGFyZ3VtZW50cylcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2dpdCAoZmxhZykge1xuICByZXR1cm4gZnVuY3Rpb24gbG9nZ2VyICgpIHtcbiAgICBpZih3aW5kb3cuZ2FzdG9uKXtcbiAgICAgIGNvbnNvbGUubG9nKCc6OiB2aWdvdXItY2xvdWQgOjonLCBmbGFnLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciB2ZmxhZyA9ICc6OiB2aWdvdXItY2xvdWQgOjonXG5mdW5jdGlvbiBsb2cgKCkge1xuICBpZih3aW5kb3cuZ2FzdG9uKXtcbiAgICB2YXIgYXJncyA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICBhcmdzLnVuc2hpZnQodmZsYWcpXG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncylcbiAgfVxufVxubG9nLmVycm9yID0gZnVuY3Rpb24gKGZsYWcsIGVycil7XG4gIGNvbnNvbGUuZXJyb3IodmZsYWcsIGZsYWcsICdcXG4nLCBlcnIpXG59XG5mdW5jdGlvbiBsb2dnZXIgKGZsYWcpe1xuICByZXR1cm4gZnVuY3Rpb24gbG9nZ2VyICgpIHtcbiAgICB2YXIgYXJncyA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICBhcmdzLnVuc2hpZnQodmZsYWcsIGZsYWcpXG4gICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncylcbiAgfVxufVxuXG5mdW5jdGlvbiBmaXhWSUQgKFZJRCkge1xuICBWSUQgPSBWSUQgfHwgRy5zZXNzaW9uKCdWSUQnKSB8fCBpZCgnVl8nKVxuICByZXR1cm4gRy5zZXNzaW9uKCdWSUQnLCBWSUQpXG59XG5cbmZ1bmN0aW9uIHBhc3NPbiAoZnJvbSwgdG8pIHtcbiAgZm9yICh2YXIgZSBpbiBmcm9tLl9jYWxsYmFja3MpIHtcbiAgICB2YXIgZnJvbWxpc3QgPSBmcm9tLl9jYWxsYmFja3NbZV1cbiAgICBmb3IgKHZhciBpID0gMCwgZm47IGZuID0gZnJvbWxpc3RbaV07IGkrKykge1xuICAgICAgLy8gY29uc29sZS5sb2coJ2hhbmQgb3ZlciBkYXQgbGlzdG5lcicsIGZuLm5hbWUgPT09ICdvbicgJiYgZm4uZm4gPyAnb25jZScgOiAnb24nLGUsIGZuLmZuIHx8IGZuKVxuICAgICAgaWYgKGZuLm5hbWUgPT09ICdvbicgJiYgZm4uZm4pIHtcbiAgICAgICAgdG8ub25jZShlLCBmbi5mbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvLm9uKGUsIGZuKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmcm9tLm9mZigpXG59XG5cbmZ1bmN0aW9uIGZpeFVybCAodXJsLCBwYXJhbXMpIHtcbiAgdmFyIGN1dG9mZiA9IHVybC5pbmRleE9mKCc/JylcbiAgaWYgKGN1dG9mZiA+IC0xKSB7XG4gICAgdXJsID0gdXJsLnNsaWNlKDAsIGN1dG9mZilcbiAgfVxuICByZXR1cm4gdXJsICsgJz8nICsgdXJsRW5jb2RlKHBhcmFtcywgJ0dFVCcsICd1cmknKVxufSIsIiFmdW5jdGlvbihlKXtpZihcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZSltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQpZGVmaW5lKFtdLGUpO2Vsc2V7dmFyIGY7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz9mPXdpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsP2Y9Z2xvYmFsOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiYoZj1zZWxmKSxmLmlvPWUoKX19KGZ1bmN0aW9uKCl7dmFyIGRlZmluZSxtb2R1bGUsZXhwb3J0cztyZXR1cm4gZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KHsxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1fZGVyZXFfKFwiLi9saWIvXCIpfSx7XCIuL2xpYi9cIjoyfV0sMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIHVybD1fZGVyZXFfKFwiLi91cmxcIik7dmFyIHBhcnNlcj1fZGVyZXFfKFwic29ja2V0LmlvLXBhcnNlclwiKTt2YXIgTWFuYWdlcj1fZGVyZXFfKFwiLi9tYW5hZ2VyXCIpO3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJzb2NrZXQuaW8tY2xpZW50XCIpO21vZHVsZS5leHBvcnRzPWV4cG9ydHM9bG9va3VwO3ZhciBjYWNoZT1leHBvcnRzLm1hbmFnZXJzPXt9O2Z1bmN0aW9uIGxvb2t1cCh1cmksb3B0cyl7aWYodHlwZW9mIHVyaT09XCJvYmplY3RcIil7b3B0cz11cmk7dXJpPXVuZGVmaW5lZH1vcHRzPW9wdHN8fHt9O3ZhciBwYXJzZWQ9dXJsKHVyaSk7dmFyIHNvdXJjZT1wYXJzZWQuc291cmNlO3ZhciBpZD1wYXJzZWQuaWQ7dmFyIGlvO2lmKG9wdHMuZm9yY2VOZXd8fG9wdHNbXCJmb3JjZSBuZXcgY29ubmVjdGlvblwiXXx8ZmFsc2U9PT1vcHRzLm11bHRpcGxleCl7ZGVidWcoXCJpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzXCIsc291cmNlKTtpbz1NYW5hZ2VyKHNvdXJjZSxvcHRzKX1lbHNle2lmKCFjYWNoZVtpZF0pe2RlYnVnKFwibmV3IGlvIGluc3RhbmNlIGZvciAlc1wiLHNvdXJjZSk7Y2FjaGVbaWRdPU1hbmFnZXIoc291cmNlLG9wdHMpfWlvPWNhY2hlW2lkXX1yZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKX1leHBvcnRzLnByb3RvY29sPXBhcnNlci5wcm90b2NvbDtleHBvcnRzLmNvbm5lY3Q9bG9va3VwO2V4cG9ydHMuTWFuYWdlcj1fZGVyZXFfKFwiLi9tYW5hZ2VyXCIpO2V4cG9ydHMuU29ja2V0PV9kZXJlcV8oXCIuL3NvY2tldFwiKX0se1wiLi9tYW5hZ2VyXCI6MyxcIi4vc29ja2V0XCI6NSxcIi4vdXJsXCI6NixkZWJ1ZzoxMCxcInNvY2tldC5pby1wYXJzZXJcIjo0Nn1dLDM6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciB1cmw9X2RlcmVxXyhcIi4vdXJsXCIpO3ZhciBlaW89X2RlcmVxXyhcImVuZ2luZS5pby1jbGllbnRcIik7dmFyIFNvY2tldD1fZGVyZXFfKFwiLi9zb2NrZXRcIik7dmFyIEVtaXR0ZXI9X2RlcmVxXyhcImNvbXBvbmVudC1lbWl0dGVyXCIpO3ZhciBwYXJzZXI9X2RlcmVxXyhcInNvY2tldC5pby1wYXJzZXJcIik7dmFyIG9uPV9kZXJlcV8oXCIuL29uXCIpO3ZhciBiaW5kPV9kZXJlcV8oXCJjb21wb25lbnQtYmluZFwiKTt2YXIgb2JqZWN0PV9kZXJlcV8oXCJvYmplY3QtY29tcG9uZW50XCIpO3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXJcIik7dmFyIGluZGV4T2Y9X2RlcmVxXyhcImluZGV4b2ZcIik7dmFyIEJhY2tvZmY9X2RlcmVxXyhcImJhY2tvMlwiKTttb2R1bGUuZXhwb3J0cz1NYW5hZ2VyO2Z1bmN0aW9uIE1hbmFnZXIodXJpLG9wdHMpe2lmKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKXJldHVybiBuZXcgTWFuYWdlcih1cmksb3B0cyk7aWYodXJpJiZcIm9iamVjdFwiPT10eXBlb2YgdXJpKXtvcHRzPXVyaTt1cmk9dW5kZWZpbmVkfW9wdHM9b3B0c3x8e307b3B0cy5wYXRoPW9wdHMucGF0aHx8XCIvc29ja2V0LmlvXCI7dGhpcy5uc3BzPXt9O3RoaXMuc3Vicz1bXTt0aGlzLm9wdHM9b3B0czt0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiE9PWZhbHNlKTt0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHN8fEluZmluaXR5KTt0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXl8fDFlMyk7dGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4fHw1ZTMpO3RoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3J8fC41KTt0aGlzLmJhY2tvZmY9bmV3IEJhY2tvZmYoe21pbjp0aGlzLnJlY29ubmVjdGlvbkRlbGF5KCksbWF4OnRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSxqaXR0ZXI6dGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKCl9KTt0aGlzLnRpbWVvdXQobnVsbD09b3B0cy50aW1lb3V0PzJlNDpvcHRzLnRpbWVvdXQpO3RoaXMucmVhZHlTdGF0ZT1cImNsb3NlZFwiO3RoaXMudXJpPXVyaTt0aGlzLmNvbm5lY3RlZD1bXTt0aGlzLmVuY29kaW5nPWZhbHNlO3RoaXMucGFja2V0QnVmZmVyPVtdO3RoaXMuZW5jb2Rlcj1uZXcgcGFyc2VyLkVuY29kZXI7dGhpcy5kZWNvZGVyPW5ldyBwYXJzZXIuRGVjb2Rlcjt0aGlzLmF1dG9Db25uZWN0PW9wdHMuYXV0b0Nvbm5lY3QhPT1mYWxzZTtpZih0aGlzLmF1dG9Db25uZWN0KXRoaXMub3BlbigpfU1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGw9ZnVuY3Rpb24oKXt0aGlzLmVtaXQuYXBwbHkodGhpcyxhcmd1bWVudHMpO2Zvcih2YXIgbnNwIGluIHRoaXMubnNwcyl7dGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSxhcmd1bWVudHMpfX07TWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzPWZ1bmN0aW9uKCl7Zm9yKHZhciBuc3AgaW4gdGhpcy5uc3BzKXt0aGlzLm5zcHNbbnNwXS5pZD10aGlzLmVuZ2luZS5pZH19O0VtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO01hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbj1mdW5jdGlvbih2KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO3RoaXMuX3JlY29ubmVjdGlvbj0hIXY7cmV0dXJuIHRoaXN9O01hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzPWZ1bmN0aW9uKHYpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0czt0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cz12O3JldHVybiB0aGlzfTtNYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheT1mdW5jdGlvbih2KXtpZighYXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7dGhpcy5fcmVjb25uZWN0aW9uRGVsYXk9djt0aGlzLmJhY2tvZmYmJnRoaXMuYmFja29mZi5zZXRNaW4odik7cmV0dXJuIHRoaXN9O01hbmFnZXIucHJvdG90eXBlLnJhbmRvbWl6YXRpb25GYWN0b3I9ZnVuY3Rpb24odil7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3JhbmRvbWl6YXRpb25GYWN0b3I7dGhpcy5fcmFuZG9taXphdGlvbkZhY3Rvcj12O3RoaXMuYmFja29mZiYmdGhpcy5iYWNrb2ZmLnNldEppdHRlcih2KTtyZXR1cm4gdGhpc307TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXg9ZnVuY3Rpb24odil7aWYoIWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O3RoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4PXY7dGhpcy5iYWNrb2ZmJiZ0aGlzLmJhY2tvZmYuc2V0TWF4KHYpO3JldHVybiB0aGlzfTtNYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0PWZ1bmN0aW9uKHYpe2lmKCFhcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLl90aW1lb3V0O3RoaXMuX3RpbWVvdXQ9djtyZXR1cm4gdGhpc307TWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW49ZnVuY3Rpb24oKXtpZighdGhpcy5yZWNvbm5lY3RpbmcmJnRoaXMuX3JlY29ubmVjdGlvbiYmdGhpcy5iYWNrb2ZmLmF0dGVtcHRzPT09MCl7dGhpcy5yZWNvbm5lY3QoKX19O01hbmFnZXIucHJvdG90eXBlLm9wZW49TWFuYWdlci5wcm90b3R5cGUuY29ubmVjdD1mdW5jdGlvbihmbil7ZGVidWcoXCJyZWFkeVN0YXRlICVzXCIsdGhpcy5yZWFkeVN0YXRlKTtpZih+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoXCJvcGVuXCIpKXJldHVybiB0aGlzO2RlYnVnKFwib3BlbmluZyAlc1wiLHRoaXMudXJpKTt0aGlzLmVuZ2luZT1laW8odGhpcy51cmksdGhpcy5vcHRzKTt2YXIgc29ja2V0PXRoaXMuZW5naW5lO3ZhciBzZWxmPXRoaXM7dGhpcy5yZWFkeVN0YXRlPVwib3BlbmluZ1wiO3RoaXMuc2tpcFJlY29ubmVjdD1mYWxzZTt2YXIgb3BlblN1Yj1vbihzb2NrZXQsXCJvcGVuXCIsZnVuY3Rpb24oKXtzZWxmLm9ub3BlbigpO2ZuJiZmbigpfSk7dmFyIGVycm9yU3ViPW9uKHNvY2tldCxcImVycm9yXCIsZnVuY3Rpb24oZGF0YSl7ZGVidWcoXCJjb25uZWN0X2Vycm9yXCIpO3NlbGYuY2xlYW51cCgpO3NlbGYucmVhZHlTdGF0ZT1cImNsb3NlZFwiO3NlbGYuZW1pdEFsbChcImNvbm5lY3RfZXJyb3JcIixkYXRhKTtpZihmbil7dmFyIGVycj1uZXcgRXJyb3IoXCJDb25uZWN0aW9uIGVycm9yXCIpO2Vyci5kYXRhPWRhdGE7Zm4oZXJyKX1lbHNle3NlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKX19KTtpZihmYWxzZSE9PXRoaXMuX3RpbWVvdXQpe3ZhciB0aW1lb3V0PXRoaXMuX3RpbWVvdXQ7ZGVidWcoXCJjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkXCIsdGltZW91dCk7dmFyIHRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtkZWJ1ZyhcImNvbm5lY3QgYXR0ZW1wdCB0aW1lZCBvdXQgYWZ0ZXIgJWRcIix0aW1lb3V0KTtvcGVuU3ViLmRlc3Ryb3koKTtzb2NrZXQuY2xvc2UoKTtzb2NrZXQuZW1pdChcImVycm9yXCIsXCJ0aW1lb3V0XCIpO3NlbGYuZW1pdEFsbChcImNvbm5lY3RfdGltZW91dFwiLHRpbWVvdXQpfSx0aW1lb3V0KTt0aGlzLnN1YnMucHVzaCh7ZGVzdHJveTpmdW5jdGlvbigpe2NsZWFyVGltZW91dCh0aW1lcil9fSl9dGhpcy5zdWJzLnB1c2gob3BlblN1Yik7dGhpcy5zdWJzLnB1c2goZXJyb3JTdWIpO3JldHVybiB0aGlzfTtNYW5hZ2VyLnByb3RvdHlwZS5vbm9wZW49ZnVuY3Rpb24oKXtkZWJ1ZyhcIm9wZW5cIik7dGhpcy5jbGVhbnVwKCk7dGhpcy5yZWFkeVN0YXRlPVwib3BlblwiO3RoaXMuZW1pdChcIm9wZW5cIik7dmFyIHNvY2tldD10aGlzLmVuZ2luZTt0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsXCJkYXRhXCIsYmluZCh0aGlzLFwib25kYXRhXCIpKSk7dGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLFwiZGVjb2RlZFwiLGJpbmQodGhpcyxcIm9uZGVjb2RlZFwiKSkpO3RoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCxcImVycm9yXCIsYmluZCh0aGlzLFwib25lcnJvclwiKSkpO3RoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCxcImNsb3NlXCIsYmluZCh0aGlzLFwib25jbG9zZVwiKSkpfTtNYW5hZ2VyLnByb3RvdHlwZS5vbmRhdGE9ZnVuY3Rpb24oZGF0YSl7dGhpcy5kZWNvZGVyLmFkZChkYXRhKX07TWFuYWdlci5wcm90b3R5cGUub25kZWNvZGVkPWZ1bmN0aW9uKHBhY2tldCl7dGhpcy5lbWl0KFwicGFja2V0XCIscGFja2V0KX07TWFuYWdlci5wcm90b3R5cGUub25lcnJvcj1mdW5jdGlvbihlcnIpe2RlYnVnKFwiZXJyb3JcIixlcnIpO3RoaXMuZW1pdEFsbChcImVycm9yXCIsZXJyKX07TWFuYWdlci5wcm90b3R5cGUuc29ja2V0PWZ1bmN0aW9uKG5zcCl7dmFyIHNvY2tldD10aGlzLm5zcHNbbnNwXTtpZighc29ja2V0KXtzb2NrZXQ9bmV3IFNvY2tldCh0aGlzLG5zcCk7dGhpcy5uc3BzW25zcF09c29ja2V0O3ZhciBzZWxmPXRoaXM7c29ja2V0Lm9uKFwiY29ubmVjdFwiLGZ1bmN0aW9uKCl7c29ja2V0LmlkPXNlbGYuZW5naW5lLmlkO2lmKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RlZCxzb2NrZXQpKXtzZWxmLmNvbm5lY3RlZC5wdXNoKHNvY2tldCl9fSl9cmV0dXJuIHNvY2tldH07TWFuYWdlci5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbihzb2NrZXQpe3ZhciBpbmRleD1pbmRleE9mKHRoaXMuY29ubmVjdGVkLHNvY2tldCk7aWYofmluZGV4KXRoaXMuY29ubmVjdGVkLnNwbGljZShpbmRleCwxKTtpZih0aGlzLmNvbm5lY3RlZC5sZW5ndGgpcmV0dXJuO3RoaXMuY2xvc2UoKX07TWFuYWdlci5wcm90b3R5cGUucGFja2V0PWZ1bmN0aW9uKHBhY2tldCl7ZGVidWcoXCJ3cml0aW5nIHBhY2tldCAlalwiLHBhY2tldCk7dmFyIHNlbGY9dGhpcztpZighc2VsZi5lbmNvZGluZyl7c2VsZi5lbmNvZGluZz10cnVlO3RoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0LGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKXtmb3IodmFyIGk9MDtpPGVuY29kZWRQYWNrZXRzLmxlbmd0aDtpKyspe3NlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldKX1zZWxmLmVuY29kaW5nPWZhbHNlO3NlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCl9KX1lbHNle3NlbGYucGFja2V0QnVmZmVyLnB1c2gocGFja2V0KX19O01hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZT1mdW5jdGlvbigpe2lmKHRoaXMucGFja2V0QnVmZmVyLmxlbmd0aD4wJiYhdGhpcy5lbmNvZGluZyl7dmFyIHBhY2s9dGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTt0aGlzLnBhY2tldChwYWNrKX19O01hbmFnZXIucHJvdG90eXBlLmNsZWFudXA9ZnVuY3Rpb24oKXt2YXIgc3ViO3doaWxlKHN1Yj10aGlzLnN1YnMuc2hpZnQoKSlzdWIuZGVzdHJveSgpO3RoaXMucGFja2V0QnVmZmVyPVtdO3RoaXMuZW5jb2Rpbmc9ZmFsc2U7dGhpcy5kZWNvZGVyLmRlc3Ryb3koKX07TWFuYWdlci5wcm90b3R5cGUuY2xvc2U9TWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdD1mdW5jdGlvbigpe3RoaXMuc2tpcFJlY29ubmVjdD10cnVlO3RoaXMuYmFja29mZi5yZXNldCgpO3RoaXMucmVhZHlTdGF0ZT1cImNsb3NlZFwiO3RoaXMuZW5naW5lJiZ0aGlzLmVuZ2luZS5jbG9zZSgpfTtNYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlPWZ1bmN0aW9uKHJlYXNvbil7ZGVidWcoXCJjbG9zZVwiKTt0aGlzLmNsZWFudXAoKTt0aGlzLmJhY2tvZmYucmVzZXQoKTt0aGlzLnJlYWR5U3RhdGU9XCJjbG9zZWRcIjt0aGlzLmVtaXQoXCJjbG9zZVwiLHJlYXNvbik7aWYodGhpcy5fcmVjb25uZWN0aW9uJiYhdGhpcy5za2lwUmVjb25uZWN0KXt0aGlzLnJlY29ubmVjdCgpfX07TWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0PWZ1bmN0aW9uKCl7aWYodGhpcy5yZWNvbm5lY3Rpbmd8fHRoaXMuc2tpcFJlY29ubmVjdClyZXR1cm4gdGhpczt2YXIgc2VsZj10aGlzO2lmKHRoaXMuYmFja29mZi5hdHRlbXB0cz49dGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpe2RlYnVnKFwicmVjb25uZWN0IGZhaWxlZFwiKTt0aGlzLmJhY2tvZmYucmVzZXQoKTt0aGlzLmVtaXRBbGwoXCJyZWNvbm5lY3RfZmFpbGVkXCIpO3RoaXMucmVjb25uZWN0aW5nPWZhbHNlfWVsc2V7dmFyIGRlbGF5PXRoaXMuYmFja29mZi5kdXJhdGlvbigpO2RlYnVnKFwid2lsbCB3YWl0ICVkbXMgYmVmb3JlIHJlY29ubmVjdCBhdHRlbXB0XCIsZGVsYXkpO3RoaXMucmVjb25uZWN0aW5nPXRydWU7dmFyIHRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZihzZWxmLnNraXBSZWNvbm5lY3QpcmV0dXJuO2RlYnVnKFwiYXR0ZW1wdGluZyByZWNvbm5lY3RcIik7c2VsZi5lbWl0QWxsKFwicmVjb25uZWN0X2F0dGVtcHRcIixzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO3NlbGYuZW1pdEFsbChcInJlY29ubmVjdGluZ1wiLHNlbGYuYmFja29mZi5hdHRlbXB0cyk7aWYoc2VsZi5za2lwUmVjb25uZWN0KXJldHVybjtzZWxmLm9wZW4oZnVuY3Rpb24oZXJyKXtpZihlcnIpe2RlYnVnKFwicmVjb25uZWN0IGF0dGVtcHQgZXJyb3JcIik7c2VsZi5yZWNvbm5lY3Rpbmc9ZmFsc2U7c2VsZi5yZWNvbm5lY3QoKTtzZWxmLmVtaXRBbGwoXCJyZWNvbm5lY3RfZXJyb3JcIixlcnIuZGF0YSl9ZWxzZXtkZWJ1ZyhcInJlY29ubmVjdCBzdWNjZXNzXCIpO3NlbGYub25yZWNvbm5lY3QoKX19KX0sZGVsYXkpO3RoaXMuc3Vicy5wdXNoKHtkZXN0cm95OmZ1bmN0aW9uKCl7Y2xlYXJUaW1lb3V0KHRpbWVyKX19KX19O01hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0PWZ1bmN0aW9uKCl7dmFyIGF0dGVtcHQ9dGhpcy5iYWNrb2ZmLmF0dGVtcHRzO3RoaXMucmVjb25uZWN0aW5nPWZhbHNlO3RoaXMuYmFja29mZi5yZXNldCgpO3RoaXMudXBkYXRlU29ja2V0SWRzKCk7dGhpcy5lbWl0QWxsKFwicmVjb25uZWN0XCIsYXR0ZW1wdCl9fSx7XCIuL29uXCI6NCxcIi4vc29ja2V0XCI6NSxcIi4vdXJsXCI6NixiYWNrbzI6NyxcImNvbXBvbmVudC1iaW5kXCI6OCxcImNvbXBvbmVudC1lbWl0dGVyXCI6OSxkZWJ1ZzoxMCxcImVuZ2luZS5pby1jbGllbnRcIjoxMSxpbmRleG9mOjQyLFwib2JqZWN0LWNvbXBvbmVudFwiOjQzLFwic29ja2V0LmlvLXBhcnNlclwiOjQ2fV0sNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9b247ZnVuY3Rpb24gb24ob2JqLGV2LGZuKXtvYmoub24oZXYsZm4pO3JldHVybntkZXN0cm95OmZ1bmN0aW9uKCl7b2JqLnJlbW92ZUxpc3RlbmVyKGV2LGZuKX19fX0se31dLDU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBwYXJzZXI9X2RlcmVxXyhcInNvY2tldC5pby1wYXJzZXJcIik7dmFyIEVtaXR0ZXI9X2RlcmVxXyhcImNvbXBvbmVudC1lbWl0dGVyXCIpO3ZhciB0b0FycmF5PV9kZXJlcV8oXCJ0by1hcnJheVwiKTt2YXIgb249X2RlcmVxXyhcIi4vb25cIik7dmFyIGJpbmQ9X2RlcmVxXyhcImNvbXBvbmVudC1iaW5kXCIpO3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJzb2NrZXQuaW8tY2xpZW50OnNvY2tldFwiKTt2YXIgaGFzQmluPV9kZXJlcV8oXCJoYXMtYmluYXJ5XCIpO21vZHVsZS5leHBvcnRzPWV4cG9ydHM9U29ja2V0O3ZhciBldmVudHM9e2Nvbm5lY3Q6MSxjb25uZWN0X2Vycm9yOjEsY29ubmVjdF90aW1lb3V0OjEsZGlzY29ubmVjdDoxLGVycm9yOjEscmVjb25uZWN0OjEscmVjb25uZWN0X2F0dGVtcHQ6MSxyZWNvbm5lY3RfZmFpbGVkOjEscmVjb25uZWN0X2Vycm9yOjEscmVjb25uZWN0aW5nOjF9O3ZhciBlbWl0PUVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7ZnVuY3Rpb24gU29ja2V0KGlvLG5zcCl7dGhpcy5pbz1pbzt0aGlzLm5zcD1uc3A7dGhpcy5qc29uPXRoaXM7dGhpcy5pZHM9MDt0aGlzLmFja3M9e307aWYodGhpcy5pby5hdXRvQ29ubmVjdCl0aGlzLm9wZW4oKTt0aGlzLnJlY2VpdmVCdWZmZXI9W107dGhpcy5zZW5kQnVmZmVyPVtdO3RoaXMuY29ubmVjdGVkPWZhbHNlO3RoaXMuZGlzY29ubmVjdGVkPXRydWV9RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtTb2NrZXQucHJvdG90eXBlLnN1YkV2ZW50cz1mdW5jdGlvbigpe2lmKHRoaXMuc3VicylyZXR1cm47dmFyIGlvPXRoaXMuaW87dGhpcy5zdWJzPVtvbihpbyxcIm9wZW5cIixiaW5kKHRoaXMsXCJvbm9wZW5cIikpLG9uKGlvLFwicGFja2V0XCIsYmluZCh0aGlzLFwib25wYWNrZXRcIikpLG9uKGlvLFwiY2xvc2VcIixiaW5kKHRoaXMsXCJvbmNsb3NlXCIpKV19O1NvY2tldC5wcm90b3R5cGUub3Blbj1Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3Q9ZnVuY3Rpb24oKXtpZih0aGlzLmNvbm5lY3RlZClyZXR1cm4gdGhpczt0aGlzLnN1YkV2ZW50cygpO3RoaXMuaW8ub3BlbigpO2lmKFwib3BlblwiPT10aGlzLmlvLnJlYWR5U3RhdGUpdGhpcy5vbm9wZW4oKTtyZXR1cm4gdGhpc307U29ja2V0LnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKCl7dmFyIGFyZ3M9dG9BcnJheShhcmd1bWVudHMpO2FyZ3MudW5zaGlmdChcIm1lc3NhZ2VcIik7dGhpcy5lbWl0LmFwcGx5KHRoaXMsYXJncyk7cmV0dXJuIHRoaXN9O1NvY2tldC5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihldil7aWYoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSl7ZW1pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7cmV0dXJuIHRoaXN9dmFyIGFyZ3M9dG9BcnJheShhcmd1bWVudHMpO3ZhciBwYXJzZXJUeXBlPXBhcnNlci5FVkVOVDtpZihoYXNCaW4oYXJncykpe3BhcnNlclR5cGU9cGFyc2VyLkJJTkFSWV9FVkVOVH12YXIgcGFja2V0PXt0eXBlOnBhcnNlclR5cGUsZGF0YTphcmdzfTtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoLTFdKXtkZWJ1ZyhcImVtaXR0aW5nIHBhY2tldCB3aXRoIGFjayBpZCAlZFwiLHRoaXMuaWRzKTt0aGlzLmFja3NbdGhpcy5pZHNdPWFyZ3MucG9wKCk7cGFja2V0LmlkPXRoaXMuaWRzKyt9aWYodGhpcy5jb25uZWN0ZWQpe3RoaXMucGFja2V0KHBhY2tldCl9ZWxzZXt0aGlzLnNlbmRCdWZmZXIucHVzaChwYWNrZXQpfXJldHVybiB0aGlzfTtTb2NrZXQucHJvdG90eXBlLnBhY2tldD1mdW5jdGlvbihwYWNrZXQpe3BhY2tldC5uc3A9dGhpcy5uc3A7dGhpcy5pby5wYWNrZXQocGFja2V0KX07U29ja2V0LnByb3RvdHlwZS5vbm9wZW49ZnVuY3Rpb24oKXtkZWJ1ZyhcInRyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZ1wiKTtpZihcIi9cIiE9dGhpcy5uc3Ape3RoaXMucGFja2V0KHt0eXBlOnBhcnNlci5DT05ORUNUfSl9fTtTb2NrZXQucHJvdG90eXBlLm9uY2xvc2U9ZnVuY3Rpb24ocmVhc29uKXtkZWJ1ZyhcImNsb3NlICglcylcIixyZWFzb24pO3RoaXMuY29ubmVjdGVkPWZhbHNlO3RoaXMuZGlzY29ubmVjdGVkPXRydWU7ZGVsZXRlIHRoaXMuaWQ7dGhpcy5lbWl0KFwiZGlzY29ubmVjdFwiLHJlYXNvbil9O1NvY2tldC5wcm90b3R5cGUub25wYWNrZXQ9ZnVuY3Rpb24ocGFja2V0KXtpZihwYWNrZXQubnNwIT10aGlzLm5zcClyZXR1cm47c3dpdGNoKHBhY2tldC50eXBlKXtjYXNlIHBhcnNlci5DT05ORUNUOnRoaXMub25jb25uZWN0KCk7YnJlYWs7Y2FzZSBwYXJzZXIuRVZFTlQ6dGhpcy5vbmV2ZW50KHBhY2tldCk7YnJlYWs7Y2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOnRoaXMub25ldmVudChwYWNrZXQpO2JyZWFrO2Nhc2UgcGFyc2VyLkFDSzp0aGlzLm9uYWNrKHBhY2tldCk7YnJlYWs7Y2FzZSBwYXJzZXIuQklOQVJZX0FDSzp0aGlzLm9uYWNrKHBhY2tldCk7YnJlYWs7Y2FzZSBwYXJzZXIuRElTQ09OTkVDVDp0aGlzLm9uZGlzY29ubmVjdCgpO2JyZWFrO2Nhc2UgcGFyc2VyLkVSUk9SOnRoaXMuZW1pdChcImVycm9yXCIscGFja2V0LmRhdGEpO2JyZWFrfX07U29ja2V0LnByb3RvdHlwZS5vbmV2ZW50PWZ1bmN0aW9uKHBhY2tldCl7dmFyIGFyZ3M9cGFja2V0LmRhdGF8fFtdO2RlYnVnKFwiZW1pdHRpbmcgZXZlbnQgJWpcIixhcmdzKTtpZihudWxsIT1wYWNrZXQuaWQpe2RlYnVnKFwiYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudFwiKTthcmdzLnB1c2godGhpcy5hY2socGFja2V0LmlkKSl9aWYodGhpcy5jb25uZWN0ZWQpe2VtaXQuYXBwbHkodGhpcyxhcmdzKX1lbHNle3RoaXMucmVjZWl2ZUJ1ZmZlci5wdXNoKGFyZ3MpfX07U29ja2V0LnByb3RvdHlwZS5hY2s9ZnVuY3Rpb24oaWQpe3ZhciBzZWxmPXRoaXM7dmFyIHNlbnQ9ZmFsc2U7cmV0dXJuIGZ1bmN0aW9uKCl7aWYoc2VudClyZXR1cm47c2VudD10cnVlO3ZhciBhcmdzPXRvQXJyYXkoYXJndW1lbnRzKTtkZWJ1ZyhcInNlbmRpbmcgYWNrICVqXCIsYXJncyk7dmFyIHR5cGU9aGFzQmluKGFyZ3MpP3BhcnNlci5CSU5BUllfQUNLOnBhcnNlci5BQ0s7c2VsZi5wYWNrZXQoe3R5cGU6dHlwZSxpZDppZCxkYXRhOmFyZ3N9KX19O1NvY2tldC5wcm90b3R5cGUub25hY2s9ZnVuY3Rpb24ocGFja2V0KXtkZWJ1ZyhcImNhbGxpbmcgYWNrICVzIHdpdGggJWpcIixwYWNrZXQuaWQscGFja2V0LmRhdGEpO3ZhciBmbj10aGlzLmFja3NbcGFja2V0LmlkXTtmbi5hcHBseSh0aGlzLHBhY2tldC5kYXRhKTtkZWxldGUgdGhpcy5hY2tzW3BhY2tldC5pZF19O1NvY2tldC5wcm90b3R5cGUub25jb25uZWN0PWZ1bmN0aW9uKCl7dGhpcy5jb25uZWN0ZWQ9dHJ1ZTt0aGlzLmRpc2Nvbm5lY3RlZD1mYWxzZTt0aGlzLmVtaXQoXCJjb25uZWN0XCIpO3RoaXMuZW1pdEJ1ZmZlcmVkKCl9O1NvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkPWZ1bmN0aW9uKCl7dmFyIGk7Zm9yKGk9MDtpPHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7aSsrKXtlbWl0LmFwcGx5KHRoaXMsdGhpcy5yZWNlaXZlQnVmZmVyW2ldKX10aGlzLnJlY2VpdmVCdWZmZXI9W107Zm9yKGk9MDtpPHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7aSsrKXt0aGlzLnBhY2tldCh0aGlzLnNlbmRCdWZmZXJbaV0pfXRoaXMuc2VuZEJ1ZmZlcj1bXX07U29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3Q9ZnVuY3Rpb24oKXtkZWJ1ZyhcInNlcnZlciBkaXNjb25uZWN0ICglcylcIix0aGlzLm5zcCk7dGhpcy5kZXN0cm95KCk7dGhpcy5vbmNsb3NlKFwiaW8gc2VydmVyIGRpc2Nvbm5lY3RcIil9O1NvY2tldC5wcm90b3R5cGUuZGVzdHJveT1mdW5jdGlvbigpe2lmKHRoaXMuc3Vicyl7Zm9yKHZhciBpPTA7aTx0aGlzLnN1YnMubGVuZ3RoO2krKyl7dGhpcy5zdWJzW2ldLmRlc3Ryb3koKX10aGlzLnN1YnM9bnVsbH10aGlzLmlvLmRlc3Ryb3kodGhpcyl9O1NvY2tldC5wcm90b3R5cGUuY2xvc2U9U29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0PWZ1bmN0aW9uKCl7aWYodGhpcy5jb25uZWN0ZWQpe2RlYnVnKFwicGVyZm9ybWluZyBkaXNjb25uZWN0ICglcylcIix0aGlzLm5zcCk7dGhpcy5wYWNrZXQoe3R5cGU6cGFyc2VyLkRJU0NPTk5FQ1R9KX10aGlzLmRlc3Ryb3koKTtpZih0aGlzLmNvbm5lY3RlZCl7dGhpcy5vbmNsb3NlKFwiaW8gY2xpZW50IGRpc2Nvbm5lY3RcIil9cmV0dXJuIHRoaXN9fSx7XCIuL29uXCI6NCxcImNvbXBvbmVudC1iaW5kXCI6OCxcImNvbXBvbmVudC1lbWl0dGVyXCI6OSxkZWJ1ZzoxMCxcImhhcy1iaW5hcnlcIjozOCxcInNvY2tldC5pby1wYXJzZXJcIjo0NixcInRvLWFycmF5XCI6NTB9XSw2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgcGFyc2V1cmk9X2RlcmVxXyhcInBhcnNldXJpXCIpO3ZhciBkZWJ1Zz1fZGVyZXFfKFwiZGVidWdcIikoXCJzb2NrZXQuaW8tY2xpZW50OnVybFwiKTttb2R1bGUuZXhwb3J0cz11cmw7ZnVuY3Rpb24gdXJsKHVyaSxsb2Mpe3ZhciBvYmo9dXJpO3ZhciBsb2M9bG9jfHxnbG9iYWwubG9jYXRpb247aWYobnVsbD09dXJpKXVyaT1sb2MucHJvdG9jb2wrXCIvL1wiK2xvYy5ob3N0O2lmKFwic3RyaW5nXCI9PXR5cGVvZiB1cmkpe2lmKFwiL1wiPT11cmkuY2hhckF0KDApKXtpZihcIi9cIj09dXJpLmNoYXJBdCgxKSl7dXJpPWxvYy5wcm90b2NvbCt1cml9ZWxzZXt1cmk9bG9jLmhvc3RuYW1lK3VyaX19aWYoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSl7ZGVidWcoXCJwcm90b2NvbC1sZXNzIHVybCAlc1wiLHVyaSk7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIGxvYyl7dXJpPWxvYy5wcm90b2NvbCtcIi8vXCIrdXJpfWVsc2V7dXJpPVwiaHR0cHM6Ly9cIit1cml9fWRlYnVnKFwicGFyc2UgJXNcIix1cmkpO29iaj1wYXJzZXVyaSh1cmkpfWlmKCFvYmoucG9ydCl7aWYoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpe29iai5wb3J0PVwiODBcIn1lbHNlIGlmKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSl7b2JqLnBvcnQ9XCI0NDNcIn19b2JqLnBhdGg9b2JqLnBhdGh8fFwiL1wiO29iai5pZD1vYmoucHJvdG9jb2wrXCI6Ly9cIitvYmouaG9zdCtcIjpcIitvYmoucG9ydDtvYmouaHJlZj1vYmoucHJvdG9jb2wrXCI6Ly9cIitvYmouaG9zdCsobG9jJiZsb2MucG9ydD09b2JqLnBvcnQ/XCJcIjpcIjpcIitvYmoucG9ydCk7cmV0dXJuIG9ian19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se2RlYnVnOjEwLHBhcnNldXJpOjQ0fV0sNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9QmFja29mZjtmdW5jdGlvbiBCYWNrb2ZmKG9wdHMpe29wdHM9b3B0c3x8e307dGhpcy5tcz1vcHRzLm1pbnx8MTAwO3RoaXMubWF4PW9wdHMubWF4fHwxZTQ7dGhpcy5mYWN0b3I9b3B0cy5mYWN0b3J8fDI7dGhpcy5qaXR0ZXI9b3B0cy5qaXR0ZXI+MCYmb3B0cy5qaXR0ZXI8PTE/b3B0cy5qaXR0ZXI6MDt0aGlzLmF0dGVtcHRzPTB9QmFja29mZi5wcm90b3R5cGUuZHVyYXRpb249ZnVuY3Rpb24oKXt2YXIgbXM9dGhpcy5tcypNYXRoLnBvdyh0aGlzLmZhY3Rvcix0aGlzLmF0dGVtcHRzKyspO2lmKHRoaXMuaml0dGVyKXt2YXIgcmFuZD1NYXRoLnJhbmRvbSgpO3ZhciBkZXZpYXRpb249TWF0aC5mbG9vcihyYW5kKnRoaXMuaml0dGVyKm1zKTttcz0oTWF0aC5mbG9vcihyYW5kKjEwKSYxKT09MD9tcy1kZXZpYXRpb246bXMrZGV2aWF0aW9ufXJldHVybiBNYXRoLm1pbihtcyx0aGlzLm1heCl8MH07QmFja29mZi5wcm90b3R5cGUucmVzZXQ9ZnVuY3Rpb24oKXt0aGlzLmF0dGVtcHRzPTB9O0JhY2tvZmYucHJvdG90eXBlLnNldE1pbj1mdW5jdGlvbihtaW4pe3RoaXMubXM9bWlufTtCYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXg9ZnVuY3Rpb24obWF4KXt0aGlzLm1heD1tYXh9O0JhY2tvZmYucHJvdG90eXBlLnNldEppdHRlcj1mdW5jdGlvbihqaXR0ZXIpe3RoaXMuaml0dGVyPWppdHRlcn19LHt9XSw4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgc2xpY2U9W10uc2xpY2U7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24ob2JqLGZuKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZm4pZm49b2JqW2ZuXTtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBmbil0aHJvdyBuZXcgRXJyb3IoXCJiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvblwiKTt2YXIgYXJncz1zbGljZS5jYWxsKGFyZ3VtZW50cywyKTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZm4uYXBwbHkob2JqLGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpfX19LHt9XSw5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1FbWl0dGVyO2Z1bmN0aW9uIEVtaXR0ZXIob2JqKXtpZihvYmopcmV0dXJuIG1peGluKG9iail9ZnVuY3Rpb24gbWl4aW4ob2JqKXtmb3IodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSl7b2JqW2tleV09RW1pdHRlci5wcm90b3R5cGVba2V5XX1yZXR1cm4gb2JqfUVtaXR0ZXIucHJvdG90eXBlLm9uPUVtaXR0ZXIucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oZXZlbnQsZm4pe3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9Oyh0aGlzLl9jYWxsYmFja3NbZXZlbnRdPXRoaXMuX2NhbGxiYWNrc1tldmVudF18fFtdKS5wdXNoKGZuKTtyZXR1cm4gdGhpc307RW1pdHRlci5wcm90b3R5cGUub25jZT1mdW5jdGlvbihldmVudCxmbil7dmFyIHNlbGY9dGhpczt0aGlzLl9jYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzfHx7fTtmdW5jdGlvbiBvbigpe3NlbGYub2ZmKGV2ZW50LG9uKTtmbi5hcHBseSh0aGlzLGFyZ3VtZW50cyl9b24uZm49Zm47dGhpcy5vbihldmVudCxvbik7cmV0dXJuIHRoaXN9O0VtaXR0ZXIucHJvdG90eXBlLm9mZj1FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihldmVudCxmbil7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e307aWYoMD09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5fY2FsbGJhY2tzPXt9O3JldHVybiB0aGlzfXZhciBjYWxsYmFja3M9dGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtpZighY2FsbGJhY2tzKXJldHVybiB0aGlzO2lmKDE9PWFyZ3VtZW50cy5sZW5ndGgpe2RlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO3JldHVybiB0aGlzfXZhciBjYjtmb3IodmFyIGk9MDtpPGNhbGxiYWNrcy5sZW5ndGg7aSsrKXtjYj1jYWxsYmFja3NbaV07aWYoY2I9PT1mbnx8Y2IuZm49PT1mbil7Y2FsbGJhY2tzLnNwbGljZShpLDEpO2JyZWFrfX1yZXR1cm4gdGhpc307RW1pdHRlci5wcm90b3R5cGUuZW1pdD1mdW5jdGlvbihldmVudCl7dGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e307dmFyIGFyZ3M9W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSksY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc1tldmVudF07aWYoY2FsbGJhY2tzKXtjYWxsYmFja3M9Y2FsbGJhY2tzLnNsaWNlKDApO2Zvcih2YXIgaT0wLGxlbj1jYWxsYmFja3MubGVuZ3RoO2k8bGVuOysraSl7Y2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsYXJncyl9fXJldHVybiB0aGlzfTtFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24oZXZlbnQpe3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9O3JldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdfHxbXX07RW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzPWZ1bmN0aW9uKGV2ZW50KXtyZXR1cm4hIXRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGh9fSx7fV0sMTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPWRlYnVnO2Z1bmN0aW9uIGRlYnVnKG5hbWUpe2lmKCFkZWJ1Zy5lbmFibGVkKG5hbWUpKXJldHVybiBmdW5jdGlvbigpe307cmV0dXJuIGZ1bmN0aW9uKGZtdCl7Zm10PWNvZXJjZShmbXQpO3ZhciBjdXJyPW5ldyBEYXRlO3ZhciBtcz1jdXJyLShkZWJ1Z1tuYW1lXXx8Y3Vycik7ZGVidWdbbmFtZV09Y3VycjtmbXQ9bmFtZStcIiBcIitmbXQrXCIgK1wiK2RlYnVnLmh1bWFuaXplKG1zKTt3aW5kb3cuY29uc29sZSYmY29uc29sZS5sb2cmJkZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLGNvbnNvbGUsYXJndW1lbnRzKX19ZGVidWcubmFtZXM9W107ZGVidWcuc2tpcHM9W107ZGVidWcuZW5hYmxlPWZ1bmN0aW9uKG5hbWUpe3RyeXtsb2NhbFN0b3JhZ2UuZGVidWc9bmFtZX1jYXRjaChlKXt9dmFyIHNwbGl0PShuYW1lfHxcIlwiKS5zcGxpdCgvW1xccyxdKy8pLGxlbj1zcGxpdC5sZW5ndGg7Zm9yKHZhciBpPTA7aTxsZW47aSsrKXtuYW1lPXNwbGl0W2ldLnJlcGxhY2UoXCIqXCIsXCIuKj9cIik7aWYobmFtZVswXT09PVwiLVwiKXtkZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrbmFtZS5zdWJzdHIoMSkrXCIkXCIpKX1lbHNle2RlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIituYW1lK1wiJFwiKSl9fX07ZGVidWcuZGlzYWJsZT1mdW5jdGlvbigpe2RlYnVnLmVuYWJsZShcIlwiKX07ZGVidWcuaHVtYW5pemU9ZnVuY3Rpb24obXMpe3ZhciBzZWM9MWUzLG1pbj02MCoxZTMsaG91cj02MCptaW47aWYobXM+PWhvdXIpcmV0dXJuKG1zL2hvdXIpLnRvRml4ZWQoMSkrXCJoXCI7aWYobXM+PW1pbilyZXR1cm4obXMvbWluKS50b0ZpeGVkKDEpK1wibVwiO2lmKG1zPj1zZWMpcmV0dXJuKG1zL3NlY3wwKStcInNcIjtyZXR1cm4gbXMrXCJtc1wifTtkZWJ1Zy5lbmFibGVkPWZ1bmN0aW9uKG5hbWUpe2Zvcih2YXIgaT0wLGxlbj1kZWJ1Zy5za2lwcy5sZW5ndGg7aTxsZW47aSsrKXtpZihkZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKXtyZXR1cm4gZmFsc2V9fWZvcih2YXIgaT0wLGxlbj1kZWJ1Zy5uYW1lcy5sZW5ndGg7aTxsZW47aSsrKXtpZihkZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfTtmdW5jdGlvbiBjb2VyY2UodmFsKXtpZih2YWwgaW5zdGFuY2VvZiBFcnJvcilyZXR1cm4gdmFsLnN0YWNrfHx2YWwubWVzc2FnZTtyZXR1cm4gdmFsfXRyeXtpZih3aW5kb3cubG9jYWxTdG9yYWdlKWRlYnVnLmVuYWJsZShsb2NhbFN0b3JhZ2UuZGVidWcpfWNhdGNoKGUpe319LHt9XSwxMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9X2RlcmVxXyhcIi4vbGliL1wiKX0se1wiLi9saWIvXCI6MTJ9XSwxMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9X2RlcmVxXyhcIi4vc29ja2V0XCIpO21vZHVsZS5leHBvcnRzLnBhcnNlcj1fZGVyZXFfKFwiZW5naW5lLmlvLXBhcnNlclwiKX0se1wiLi9zb2NrZXRcIjoxMyxcImVuZ2luZS5pby1wYXJzZXJcIjoyNX1dLDEzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgdHJhbnNwb3J0cz1fZGVyZXFfKFwiLi90cmFuc3BvcnRzXCIpO3ZhciBFbWl0dGVyPV9kZXJlcV8oXCJjb21wb25lbnQtZW1pdHRlclwiKTt2YXIgZGVidWc9X2RlcmVxXyhcImRlYnVnXCIpKFwiZW5naW5lLmlvLWNsaWVudDpzb2NrZXRcIik7dmFyIGluZGV4PV9kZXJlcV8oXCJpbmRleG9mXCIpO3ZhciBwYXJzZXI9X2RlcmVxXyhcImVuZ2luZS5pby1wYXJzZXJcIik7dmFyIHBhcnNldXJpPV9kZXJlcV8oXCJwYXJzZXVyaVwiKTt2YXIgcGFyc2Vqc29uPV9kZXJlcV8oXCJwYXJzZWpzb25cIik7dmFyIHBhcnNlcXM9X2RlcmVxXyhcInBhcnNlcXNcIik7bW9kdWxlLmV4cG9ydHM9U29ja2V0O2Z1bmN0aW9uIG5vb3AoKXt9ZnVuY3Rpb24gU29ja2V0KHVyaSxvcHRzKXtpZighKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKXJldHVybiBuZXcgU29ja2V0KHVyaSxvcHRzKTtvcHRzPW9wdHN8fHt9O2lmKHVyaSYmXCJvYmplY3RcIj09dHlwZW9mIHVyaSl7b3B0cz11cmk7dXJpPW51bGx9aWYodXJpKXt1cmk9cGFyc2V1cmkodXJpKTtvcHRzLmhvc3Q9dXJpLmhvc3Q7b3B0cy5zZWN1cmU9dXJpLnByb3RvY29sPT1cImh0dHBzXCJ8fHVyaS5wcm90b2NvbD09XCJ3c3NcIjtvcHRzLnBvcnQ9dXJpLnBvcnQ7aWYodXJpLnF1ZXJ5KW9wdHMucXVlcnk9dXJpLnF1ZXJ5fXRoaXMuc2VjdXJlPW51bGwhPW9wdHMuc2VjdXJlP29wdHMuc2VjdXJlOmdsb2JhbC5sb2NhdGlvbiYmXCJodHRwczpcIj09bG9jYXRpb24ucHJvdG9jb2w7aWYob3B0cy5ob3N0KXt2YXIgcGllY2VzPW9wdHMuaG9zdC5zcGxpdChcIjpcIik7b3B0cy5ob3N0bmFtZT1waWVjZXMuc2hpZnQoKTtpZihwaWVjZXMubGVuZ3RoKXtvcHRzLnBvcnQ9cGllY2VzLnBvcCgpfWVsc2UgaWYoIW9wdHMucG9ydCl7b3B0cy5wb3J0PXRoaXMuc2VjdXJlP1wiNDQzXCI6XCI4MFwifX10aGlzLmFnZW50PW9wdHMuYWdlbnR8fGZhbHNlO3RoaXMuaG9zdG5hbWU9b3B0cy5ob3N0bmFtZXx8KGdsb2JhbC5sb2NhdGlvbj9sb2NhdGlvbi5ob3N0bmFtZTpcImxvY2FsaG9zdFwiKTt0aGlzLnBvcnQ9b3B0cy5wb3J0fHwoZ2xvYmFsLmxvY2F0aW9uJiZsb2NhdGlvbi5wb3J0P2xvY2F0aW9uLnBvcnQ6dGhpcy5zZWN1cmU/NDQzOjgwKTt0aGlzLnF1ZXJ5PW9wdHMucXVlcnl8fHt9O2lmKFwic3RyaW5nXCI9PXR5cGVvZiB0aGlzLnF1ZXJ5KXRoaXMucXVlcnk9cGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7dGhpcy51cGdyYWRlPWZhbHNlIT09b3B0cy51cGdyYWRlO3RoaXMucGF0aD0ob3B0cy5wYXRofHxcIi9lbmdpbmUuaW9cIikucmVwbGFjZSgvXFwvJC8sXCJcIikrXCIvXCI7dGhpcy5mb3JjZUpTT05QPSEhb3B0cy5mb3JjZUpTT05QO3RoaXMuanNvbnA9ZmFsc2UhPT1vcHRzLmpzb25wO3RoaXMuZm9yY2VCYXNlNjQ9ISFvcHRzLmZvcmNlQmFzZTY0O3RoaXMuZW5hYmxlc1hEUj0hIW9wdHMuZW5hYmxlc1hEUjt0aGlzLnRpbWVzdGFtcFBhcmFtPW9wdHMudGltZXN0YW1wUGFyYW18fFwidFwiO3RoaXMudGltZXN0YW1wUmVxdWVzdHM9b3B0cy50aW1lc3RhbXBSZXF1ZXN0czt0aGlzLnRyYW5zcG9ydHM9b3B0cy50cmFuc3BvcnRzfHxbXCJwb2xsaW5nXCIsXCJ3ZWJzb2NrZXRcIl07dGhpcy5yZWFkeVN0YXRlPVwiXCI7dGhpcy53cml0ZUJ1ZmZlcj1bXTt0aGlzLmNhbGxiYWNrQnVmZmVyPVtdO3RoaXMucG9saWN5UG9ydD1vcHRzLnBvbGljeVBvcnR8fDg0Mzt0aGlzLnJlbWVtYmVyVXBncmFkZT1vcHRzLnJlbWVtYmVyVXBncmFkZXx8ZmFsc2U7dGhpcy5iaW5hcnlUeXBlPW51bGw7dGhpcy5vbmx5QmluYXJ5VXBncmFkZXM9b3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7dGhpcy5wZng9b3B0cy5wZnh8fG51bGw7dGhpcy5rZXk9b3B0cy5rZXl8fG51bGw7dGhpcy5wYXNzcGhyYXNlPW9wdHMucGFzc3BocmFzZXx8bnVsbDt0aGlzLmNlcnQ9b3B0cy5jZXJ0fHxudWxsO3RoaXMuY2E9b3B0cy5jYXx8bnVsbDt0aGlzLmNpcGhlcnM9b3B0cy5jaXBoZXJzfHxudWxsO3RoaXMucmVqZWN0VW5hdXRob3JpemVkPW9wdHMucmVqZWN0VW5hdXRob3JpemVkfHxudWxsO3RoaXMub3BlbigpfVNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3M9ZmFsc2U7RW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtTb2NrZXQucHJvdG9jb2w9cGFyc2VyLnByb3RvY29sO1NvY2tldC5Tb2NrZXQ9U29ja2V0O1NvY2tldC5UcmFuc3BvcnQ9X2RlcmVxXyhcIi4vdHJhbnNwb3J0XCIpO1NvY2tldC50cmFuc3BvcnRzPV9kZXJlcV8oXCIuL3RyYW5zcG9ydHNcIik7U29ja2V0LnBhcnNlcj1fZGVyZXFfKFwiZW5naW5lLmlvLXBhcnNlclwiKTtTb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydD1mdW5jdGlvbihuYW1lKXtkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsbmFtZSk7dmFyIHF1ZXJ5PWNsb25lKHRoaXMucXVlcnkpO3F1ZXJ5LkVJTz1wYXJzZXIucHJvdG9jb2w7cXVlcnkudHJhbnNwb3J0PW5hbWU7aWYodGhpcy5pZClxdWVyeS5zaWQ9dGhpcy5pZDt2YXIgdHJhbnNwb3J0PW5ldyB0cmFuc3BvcnRzW25hbWVdKHthZ2VudDp0aGlzLmFnZW50LGhvc3RuYW1lOnRoaXMuaG9zdG5hbWUscG9ydDp0aGlzLnBvcnQsc2VjdXJlOnRoaXMuc2VjdXJlLHBhdGg6dGhpcy5wYXRoLHF1ZXJ5OnF1ZXJ5LGZvcmNlSlNPTlA6dGhpcy5mb3JjZUpTT05QLGpzb25wOnRoaXMuanNvbnAsZm9yY2VCYXNlNjQ6dGhpcy5mb3JjZUJhc2U2NCxlbmFibGVzWERSOnRoaXMuZW5hYmxlc1hEUix0aW1lc3RhbXBSZXF1ZXN0czp0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLHRpbWVzdGFtcFBhcmFtOnRoaXMudGltZXN0YW1wUGFyYW0scG9saWN5UG9ydDp0aGlzLnBvbGljeVBvcnQsc29ja2V0OnRoaXMscGZ4OnRoaXMucGZ4LGtleTp0aGlzLmtleSxwYXNzcGhyYXNlOnRoaXMucGFzc3BocmFzZSxjZXJ0OnRoaXMuY2VydCxjYTp0aGlzLmNhLGNpcGhlcnM6dGhpcy5jaXBoZXJzLHJlamVjdFVuYXV0aG9yaXplZDp0aGlzLnJlamVjdFVuYXV0aG9yaXplZH0pO3JldHVybiB0cmFuc3BvcnR9O2Z1bmN0aW9uIGNsb25lKG9iail7dmFyIG89e307Zm9yKHZhciBpIGluIG9iail7aWYob2JqLmhhc093blByb3BlcnR5KGkpKXtvW2ldPW9ialtpXX19cmV0dXJuIG99U29ja2V0LnByb3RvdHlwZS5vcGVuPWZ1bmN0aW9uKCl7dmFyIHRyYW5zcG9ydDtpZih0aGlzLnJlbWVtYmVyVXBncmFkZSYmU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyYmdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoXCJ3ZWJzb2NrZXRcIikhPS0xKXt0cmFuc3BvcnQ9XCJ3ZWJzb2NrZXRcIn1lbHNlIGlmKDA9PXRoaXMudHJhbnNwb3J0cy5sZW5ndGgpe3ZhciBzZWxmPXRoaXM7c2V0VGltZW91dChmdW5jdGlvbigpe3NlbGYuZW1pdChcImVycm9yXCIsXCJObyB0cmFuc3BvcnRzIGF2YWlsYWJsZVwiKX0sMCk7cmV0dXJufWVsc2V7dHJhbnNwb3J0PXRoaXMudHJhbnNwb3J0c1swXX10aGlzLnJlYWR5U3RhdGU9XCJvcGVuaW5nXCI7dmFyIHRyYW5zcG9ydDt0cnl7dHJhbnNwb3J0PXRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCl9Y2F0Y2goZSl7dGhpcy50cmFuc3BvcnRzLnNoaWZ0KCk7dGhpcy5vcGVuKCk7cmV0dXJufXRyYW5zcG9ydC5vcGVuKCk7dGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KX07U29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQ9ZnVuY3Rpb24odHJhbnNwb3J0KXtkZWJ1ZyhcInNldHRpbmcgdHJhbnNwb3J0ICVzXCIsdHJhbnNwb3J0Lm5hbWUpO3ZhciBzZWxmPXRoaXM7aWYodGhpcy50cmFuc3BvcnQpe2RlYnVnKFwiY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzXCIsdGhpcy50cmFuc3BvcnQubmFtZSk7dGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCl9dGhpcy50cmFuc3BvcnQ9dHJhbnNwb3J0O3RyYW5zcG9ydC5vbihcImRyYWluXCIsZnVuY3Rpb24oKXtzZWxmLm9uRHJhaW4oKX0pLm9uKFwicGFja2V0XCIsZnVuY3Rpb24ocGFja2V0KXtzZWxmLm9uUGFja2V0KHBhY2tldCl9KS5vbihcImVycm9yXCIsZnVuY3Rpb24oZSl7c2VsZi5vbkVycm9yKGUpfSkub24oXCJjbG9zZVwiLGZ1bmN0aW9uKCl7c2VsZi5vbkNsb3NlKFwidHJhbnNwb3J0IGNsb3NlXCIpfSl9O1NvY2tldC5wcm90b3R5cGUucHJvYmU9ZnVuY3Rpb24obmFtZSl7ZGVidWcoJ3Byb2JpbmcgdHJhbnNwb3J0IFwiJXNcIicsbmFtZSk7dmFyIHRyYW5zcG9ydD10aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLHtwcm9iZToxfSksZmFpbGVkPWZhbHNlLHNlbGY9dGhpcztTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzPWZhbHNlO2Z1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe2lmKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKXt2YXIgdXBncmFkZUxvc2VzQmluYXJ5PSF0aGlzLnN1cHBvcnRzQmluYXJ5JiZzZWxmLnRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeTtmYWlsZWQ9ZmFpbGVkfHx1cGdyYWRlTG9zZXNCaW5hcnl9aWYoZmFpbGVkKXJldHVybjtkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLG5hbWUpO3RyYW5zcG9ydC5zZW5kKFt7dHlwZTpcInBpbmdcIixkYXRhOlwicHJvYmVcIn1dKTt0cmFuc3BvcnQub25jZShcInBhY2tldFwiLGZ1bmN0aW9uKG1zZyl7aWYoZmFpbGVkKXJldHVybjtpZihcInBvbmdcIj09bXNnLnR5cGUmJlwicHJvYmVcIj09bXNnLmRhdGEpe2RlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLG5hbWUpO3NlbGYudXBncmFkaW5nPXRydWU7c2VsZi5lbWl0KFwidXBncmFkaW5nXCIsdHJhbnNwb3J0KTtpZighdHJhbnNwb3J0KXJldHVybjtTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzPVwid2Vic29ja2V0XCI9PXRyYW5zcG9ydC5uYW1lO2RlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsc2VsZi50cmFuc3BvcnQubmFtZSk7c2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24oKXtpZihmYWlsZWQpcmV0dXJuO2lmKFwiY2xvc2VkXCI9PXNlbGYucmVhZHlTdGF0ZSlyZXR1cm47ZGVidWcoXCJjaGFuZ2luZyB0cmFuc3BvcnQgYW5kIHNlbmRpbmcgdXBncmFkZSBwYWNrZXRcIik7Y2xlYW51cCgpO3NlbGYuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7dHJhbnNwb3J0LnNlbmQoW3t0eXBlOlwidXBncmFkZVwifV0pO3NlbGYuZW1pdChcInVwZ3JhZGVcIix0cmFuc3BvcnQpO3RyYW5zcG9ydD1udWxsO3NlbGYudXBncmFkaW5nPWZhbHNlO3NlbGYuZmx1c2goKX0pfWVsc2V7ZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkJyxuYW1lKTt2YXIgZXJyPW5ldyBFcnJvcihcInByb2JlIGVycm9yXCIpO2Vyci50cmFuc3BvcnQ9dHJhbnNwb3J0Lm5hbWU7c2VsZi5lbWl0KFwidXBncmFkZUVycm9yXCIsZXJyKX19KX1mdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKXtpZihmYWlsZWQpcmV0dXJuO2ZhaWxlZD10cnVlO2NsZWFudXAoKTt0cmFuc3BvcnQuY2xvc2UoKTt0cmFuc3BvcnQ9bnVsbH1mdW5jdGlvbiBvbmVycm9yKGVycil7dmFyIGVycm9yPW5ldyBFcnJvcihcInByb2JlIGVycm9yOiBcIitlcnIpO2Vycm9yLnRyYW5zcG9ydD10cmFuc3BvcnQubmFtZTtmcmVlemVUcmFuc3BvcnQoKTtkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLG5hbWUsZXJyKTtzZWxmLmVtaXQoXCJ1cGdyYWRlRXJyb3JcIixlcnJvcil9ZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe29uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpfWZ1bmN0aW9uIG9uY2xvc2UoKXtvbmVycm9yKFwic29ja2V0IGNsb3NlZFwiKX1mdW5jdGlvbiBvbnVwZ3JhZGUodG8pe2lmKHRyYW5zcG9ydCYmdG8ubmFtZSE9dHJhbnNwb3J0Lm5hbWUpe2RlYnVnKCdcIiVzXCIgd29ya3MgLSBhYm9ydGluZyBcIiVzXCInLHRvLm5hbWUsdHJhbnNwb3J0Lm5hbWUpO2ZyZWV6ZVRyYW5zcG9ydCgpfX1mdW5jdGlvbiBjbGVhbnVwKCl7dHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwib3BlblwiLG9uVHJhbnNwb3J0T3Blbik7dHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixvbmVycm9yKTt0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLG9uVHJhbnNwb3J0Q2xvc2UpO3NlbGYucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLG9uY2xvc2UpO3NlbGYucmVtb3ZlTGlzdGVuZXIoXCJ1cGdyYWRpbmdcIixvbnVwZ3JhZGUpfXRyYW5zcG9ydC5vbmNlKFwib3BlblwiLG9uVHJhbnNwb3J0T3Blbik7dHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLG9uZXJyb3IpO3RyYW5zcG9ydC5vbmNlKFwiY2xvc2VcIixvblRyYW5zcG9ydENsb3NlKTt0aGlzLm9uY2UoXCJjbG9zZVwiLG9uY2xvc2UpO3RoaXMub25jZShcInVwZ3JhZGluZ1wiLG9udXBncmFkZSk7dHJhbnNwb3J0Lm9wZW4oKX07U29ja2V0LnByb3RvdHlwZS5vbk9wZW49ZnVuY3Rpb24oKXtkZWJ1ZyhcInNvY2tldCBvcGVuXCIpO3RoaXMucmVhZHlTdGF0ZT1cIm9wZW5cIjtTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzPVwid2Vic29ja2V0XCI9PXRoaXMudHJhbnNwb3J0Lm5hbWU7dGhpcy5lbWl0KFwib3BlblwiKTt0aGlzLmZsdXNoKCk7aWYoXCJvcGVuXCI9PXRoaXMucmVhZHlTdGF0ZSYmdGhpcy51cGdyYWRlJiZ0aGlzLnRyYW5zcG9ydC5wYXVzZSl7ZGVidWcoXCJzdGFydGluZyB1cGdyYWRlIHByb2Jlc1wiKTtmb3IodmFyIGk9MCxsPXRoaXMudXBncmFkZXMubGVuZ3RoO2k8bDtpKyspe3RoaXMucHJvYmUodGhpcy51cGdyYWRlc1tpXSl9fX07U29ja2V0LnByb3RvdHlwZS5vblBhY2tldD1mdW5jdGlvbihwYWNrZXQpe2lmKFwib3BlbmluZ1wiPT10aGlzLnJlYWR5U3RhdGV8fFwib3BlblwiPT10aGlzLnJlYWR5U3RhdGUpe2RlYnVnKCdzb2NrZXQgcmVjZWl2ZTogdHlwZSBcIiVzXCIsIGRhdGEgXCIlc1wiJyxwYWNrZXQudHlwZSxwYWNrZXQuZGF0YSk7dGhpcy5lbWl0KFwicGFja2V0XCIscGFja2V0KTt0aGlzLmVtaXQoXCJoZWFydGJlYXRcIik7c3dpdGNoKHBhY2tldC50eXBlKXtjYXNlXCJvcGVuXCI6dGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTticmVhaztjYXNlXCJwb25nXCI6dGhpcy5zZXRQaW5nKCk7YnJlYWs7Y2FzZVwiZXJyb3JcIjp2YXIgZXJyPW5ldyBFcnJvcihcInNlcnZlciBlcnJvclwiKTtlcnIuY29kZT1wYWNrZXQuZGF0YTt0aGlzLmVtaXQoXCJlcnJvclwiLGVycik7YnJlYWs7Y2FzZVwibWVzc2FnZVwiOnRoaXMuZW1pdChcImRhdGFcIixwYWNrZXQuZGF0YSk7dGhpcy5lbWl0KFwibWVzc2FnZVwiLHBhY2tldC5kYXRhKTticmVha319ZWxzZXtkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJyx0aGlzLnJlYWR5U3RhdGUpfX07U29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZT1mdW5jdGlvbihkYXRhKXt0aGlzLmVtaXQoXCJoYW5kc2hha2VcIixkYXRhKTt0aGlzLmlkPWRhdGEuc2lkO3RoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZD1kYXRhLnNpZDt0aGlzLnVwZ3JhZGVzPXRoaXMuZmlsdGVyVXBncmFkZXMoZGF0YS51cGdyYWRlcyk7dGhpcy5waW5nSW50ZXJ2YWw9ZGF0YS5waW5nSW50ZXJ2YWw7dGhpcy5waW5nVGltZW91dD1kYXRhLnBpbmdUaW1lb3V0O3RoaXMub25PcGVuKCk7aWYoXCJjbG9zZWRcIj09dGhpcy5yZWFkeVN0YXRlKXJldHVybjt0aGlzLnNldFBpbmcoKTt0aGlzLnJlbW92ZUxpc3RlbmVyKFwiaGVhcnRiZWF0XCIsdGhpcy5vbkhlYXJ0YmVhdCk7dGhpcy5vbihcImhlYXJ0YmVhdFwiLHRoaXMub25IZWFydGJlYXQpfTtTb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0PWZ1bmN0aW9uKHRpbWVvdXQpe2NsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO3ZhciBzZWxmPXRoaXM7c2VsZi5waW5nVGltZW91dFRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtpZihcImNsb3NlZFwiPT1zZWxmLnJlYWR5U3RhdGUpcmV0dXJuO3NlbGYub25DbG9zZShcInBpbmcgdGltZW91dFwiKX0sdGltZW91dHx8c2VsZi5waW5nSW50ZXJ2YWwrc2VsZi5waW5nVGltZW91dCl9O1NvY2tldC5wcm90b3R5cGUuc2V0UGluZz1mdW5jdGlvbigpe3ZhciBzZWxmPXRoaXM7Y2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO3NlbGYucGluZ0ludGVydmFsVGltZXI9c2V0VGltZW91dChmdW5jdGlvbigpe2RlYnVnKFwid3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zXCIsc2VsZi5waW5nVGltZW91dCk7c2VsZi5waW5nKCk7c2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KX0sc2VsZi5waW5nSW50ZXJ2YWwpfTtTb2NrZXQucHJvdG90eXBlLnBpbmc9ZnVuY3Rpb24oKXt0aGlzLnNlbmRQYWNrZXQoXCJwaW5nXCIpfTtTb2NrZXQucHJvdG90eXBlLm9uRHJhaW49ZnVuY3Rpb24oKXtmb3IodmFyIGk9MDtpPHRoaXMucHJldkJ1ZmZlckxlbjtpKyspe2lmKHRoaXMuY2FsbGJhY2tCdWZmZXJbaV0pe3RoaXMuY2FsbGJhY2tCdWZmZXJbaV0oKX19dGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCx0aGlzLnByZXZCdWZmZXJMZW4pO3RoaXMuY2FsbGJhY2tCdWZmZXIuc3BsaWNlKDAsdGhpcy5wcmV2QnVmZmVyTGVuKTt0aGlzLnByZXZCdWZmZXJMZW49MDtpZih0aGlzLndyaXRlQnVmZmVyLmxlbmd0aD09MCl7dGhpcy5lbWl0KFwiZHJhaW5cIil9ZWxzZXt0aGlzLmZsdXNoKCl9fTtTb2NrZXQucHJvdG90eXBlLmZsdXNoPWZ1bmN0aW9uKCl7aWYoXCJjbG9zZWRcIiE9dGhpcy5yZWFkeVN0YXRlJiZ0aGlzLnRyYW5zcG9ydC53cml0YWJsZSYmIXRoaXMudXBncmFkaW5nJiZ0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCl7ZGVidWcoXCJmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldFwiLHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTt0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO3RoaXMucHJldkJ1ZmZlckxlbj10aGlzLndyaXRlQnVmZmVyLmxlbmd0aDt0aGlzLmVtaXQoXCJmbHVzaFwiKX19O1NvY2tldC5wcm90b3R5cGUud3JpdGU9U29ja2V0LnByb3RvdHlwZS5zZW5kPWZ1bmN0aW9uKG1zZyxmbil7dGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLG1zZyxmbik7cmV0dXJuIHRoaXN9O1NvY2tldC5wcm90b3R5cGUuc2VuZFBhY2tldD1mdW5jdGlvbih0eXBlLGRhdGEsZm4pe2lmKFwiY2xvc2luZ1wiPT10aGlzLnJlYWR5U3RhdGV8fFwiY2xvc2VkXCI9PXRoaXMucmVhZHlTdGF0ZSl7cmV0dXJufXZhciBwYWNrZXQ9e3R5cGU6dHlwZSxkYXRhOmRhdGF9O3RoaXMuZW1pdChcInBhY2tldENyZWF0ZVwiLHBhY2tldCk7dGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7dGhpcy5jYWxsYmFja0J1ZmZlci5wdXNoKGZuKTt0aGlzLmZsdXNoKCl9O1NvY2tldC5wcm90b3R5cGUuY2xvc2U9ZnVuY3Rpb24oKXtpZihcIm9wZW5pbmdcIj09dGhpcy5yZWFkeVN0YXRlfHxcIm9wZW5cIj09dGhpcy5yZWFkeVN0YXRlKXt0aGlzLnJlYWR5U3RhdGU9XCJjbG9zaW5nXCI7dmFyIHNlbGY9dGhpcztmdW5jdGlvbiBjbG9zZSgpe3NlbGYub25DbG9zZShcImZvcmNlZCBjbG9zZVwiKTtkZWJ1ZyhcInNvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2VcIik7c2VsZi50cmFuc3BvcnQuY2xvc2UoKX1mdW5jdGlvbiBjbGVhbnVwQW5kQ2xvc2UoKXtzZWxmLnJlbW92ZUxpc3RlbmVyKFwidXBncmFkZVwiLGNsZWFudXBBbmRDbG9zZSk7c2VsZi5yZW1vdmVMaXN0ZW5lcihcInVwZ3JhZGVFcnJvclwiLGNsZWFudXBBbmRDbG9zZSk7Y2xvc2UoKX1mdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSgpe3NlbGYub25jZShcInVwZ3JhZGVcIixjbGVhbnVwQW5kQ2xvc2UpO3NlbGYub25jZShcInVwZ3JhZGVFcnJvclwiLGNsZWFudXBBbmRDbG9zZSl9aWYodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpe3RoaXMub25jZShcImRyYWluXCIsZnVuY3Rpb24oKXtpZih0aGlzLnVwZ3JhZGluZyl7d2FpdEZvclVwZ3JhZGUoKX1lbHNle2Nsb3NlKCl9fSl9ZWxzZSBpZih0aGlzLnVwZ3JhZGluZyl7d2FpdEZvclVwZ3JhZGUoKX1lbHNle2Nsb3NlKCl9fXJldHVybiB0aGlzfTtTb2NrZXQucHJvdG90eXBlLm9uRXJyb3I9ZnVuY3Rpb24oZXJyKXtkZWJ1ZyhcInNvY2tldCBlcnJvciAlalwiLGVycik7U29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2Vzcz1mYWxzZTt0aGlzLmVtaXQoXCJlcnJvclwiLGVycik7dGhpcy5vbkNsb3NlKFwidHJhbnNwb3J0IGVycm9yXCIsZXJyKX07U29ja2V0LnByb3RvdHlwZS5vbkNsb3NlPWZ1bmN0aW9uKHJlYXNvbixkZXNjKXtpZihcIm9wZW5pbmdcIj09dGhpcy5yZWFkeVN0YXRlfHxcIm9wZW5cIj09dGhpcy5yZWFkeVN0YXRlfHxcImNsb3NpbmdcIj09dGhpcy5yZWFkeVN0YXRlKXtkZWJ1Zygnc29ja2V0IGNsb3NlIHdpdGggcmVhc29uOiBcIiVzXCInLHJlYXNvbik7dmFyIHNlbGY9dGhpcztjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7Y2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7c2V0VGltZW91dChmdW5jdGlvbigpe3NlbGYud3JpdGVCdWZmZXI9W107c2VsZi5jYWxsYmFja0J1ZmZlcj1bXTtzZWxmLnByZXZCdWZmZXJMZW49MH0sMCk7dGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKFwiY2xvc2VcIik7dGhpcy50cmFuc3BvcnQuY2xvc2UoKTt0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTt0aGlzLnJlYWR5U3RhdGU9XCJjbG9zZWRcIjt0aGlzLmlkPW51bGw7dGhpcy5lbWl0KFwiY2xvc2VcIixyZWFzb24sZGVzYyl9fTtTb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzPWZ1bmN0aW9uKHVwZ3JhZGVzKXt2YXIgZmlsdGVyZWRVcGdyYWRlcz1bXTtmb3IodmFyIGk9MCxqPXVwZ3JhZGVzLmxlbmd0aDtpPGo7aSsrKXtpZih+aW5kZXgodGhpcy50cmFuc3BvcnRzLHVwZ3JhZGVzW2ldKSlmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pfXJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzfX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7XCIuL3RyYW5zcG9ydFwiOjE0LFwiLi90cmFuc3BvcnRzXCI6MTUsXCJjb21wb25lbnQtZW1pdHRlclwiOjksZGVidWc6MjIsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MjUsaW5kZXhvZjo0MixwYXJzZWpzb246MzQscGFyc2VxczozNSxwYXJzZXVyaTozNn1dLDE0OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgcGFyc2VyPV9kZXJlcV8oXCJlbmdpbmUuaW8tcGFyc2VyXCIpO3ZhciBFbWl0dGVyPV9kZXJlcV8oXCJjb21wb25lbnQtZW1pdHRlclwiKTttb2R1bGUuZXhwb3J0cz1UcmFuc3BvcnQ7ZnVuY3Rpb24gVHJhbnNwb3J0KG9wdHMpe3RoaXMucGF0aD1vcHRzLnBhdGg7dGhpcy5ob3N0bmFtZT1vcHRzLmhvc3RuYW1lO3RoaXMucG9ydD1vcHRzLnBvcnQ7dGhpcy5zZWN1cmU9b3B0cy5zZWN1cmU7dGhpcy5xdWVyeT1vcHRzLnF1ZXJ5O3RoaXMudGltZXN0YW1wUGFyYW09b3B0cy50aW1lc3RhbXBQYXJhbTt0aGlzLnRpbWVzdGFtcFJlcXVlc3RzPW9wdHMudGltZXN0YW1wUmVxdWVzdHM7dGhpcy5yZWFkeVN0YXRlPVwiXCI7dGhpcy5hZ2VudD1vcHRzLmFnZW50fHxmYWxzZTt0aGlzLnNvY2tldD1vcHRzLnNvY2tldDt0aGlzLmVuYWJsZXNYRFI9b3B0cy5lbmFibGVzWERSO3RoaXMucGZ4PW9wdHMucGZ4O3RoaXMua2V5PW9wdHMua2V5O3RoaXMucGFzc3BocmFzZT1vcHRzLnBhc3NwaHJhc2U7dGhpcy5jZXJ0PW9wdHMuY2VydDt0aGlzLmNhPW9wdHMuY2E7dGhpcy5jaXBoZXJzPW9wdHMuY2lwaGVyczt0aGlzLnJlamVjdFVuYXV0aG9yaXplZD1vcHRzLnJlamVjdFVuYXV0aG9yaXplZH1FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1RyYW5zcG9ydC50aW1lc3RhbXBzPTA7VHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yPWZ1bmN0aW9uKG1zZyxkZXNjKXt2YXIgZXJyPW5ldyBFcnJvcihtc2cpO2Vyci50eXBlPVwiVHJhbnNwb3J0RXJyb3JcIjtlcnIuZGVzY3JpcHRpb249ZGVzYzt0aGlzLmVtaXQoXCJlcnJvclwiLGVycik7cmV0dXJuIHRoaXN9O1RyYW5zcG9ydC5wcm90b3R5cGUub3Blbj1mdW5jdGlvbigpe2lmKFwiY2xvc2VkXCI9PXRoaXMucmVhZHlTdGF0ZXx8XCJcIj09dGhpcy5yZWFkeVN0YXRlKXt0aGlzLnJlYWR5U3RhdGU9XCJvcGVuaW5nXCI7dGhpcy5kb09wZW4oKX1yZXR1cm4gdGhpc307VHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZT1mdW5jdGlvbigpe2lmKFwib3BlbmluZ1wiPT10aGlzLnJlYWR5U3RhdGV8fFwib3BlblwiPT10aGlzLnJlYWR5U3RhdGUpe3RoaXMuZG9DbG9zZSgpO3RoaXMub25DbG9zZSgpfXJldHVybiB0aGlzfTtUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24ocGFja2V0cyl7aWYoXCJvcGVuXCI9PXRoaXMucmVhZHlTdGF0ZSl7dGhpcy53cml0ZShwYWNrZXRzKX1lbHNle3Rocm93IG5ldyBFcnJvcihcIlRyYW5zcG9ydCBub3Qgb3BlblwiKX19O1RyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuPWZ1bmN0aW9uKCl7dGhpcy5yZWFkeVN0YXRlPVwib3BlblwiO3RoaXMud3JpdGFibGU9dHJ1ZTt0aGlzLmVtaXQoXCJvcGVuXCIpfTtUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbihkYXRhKXt2YXIgcGFja2V0PXBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSx0aGlzLnNvY2tldC5iaW5hcnlUeXBlKTt0aGlzLm9uUGFja2V0KHBhY2tldCl9O1RyYW5zcG9ydC5wcm90b3R5cGUub25QYWNrZXQ9ZnVuY3Rpb24ocGFja2V0KXt0aGlzLmVtaXQoXCJwYWNrZXRcIixwYWNrZXQpfTtUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2U9ZnVuY3Rpb24oKXt0aGlzLnJlYWR5U3RhdGU9XCJjbG9zZWRcIjt0aGlzLmVtaXQoXCJjbG9zZVwiKX19LHtcImNvbXBvbmVudC1lbWl0dGVyXCI6OSxcImVuZ2luZS5pby1wYXJzZXJcIjoyNX1dLDE1OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXsoZnVuY3Rpb24oZ2xvYmFsKXt2YXIgWE1MSHR0cFJlcXVlc3Q9X2RlcmVxXyhcInhtbGh0dHByZXF1ZXN0XCIpO3ZhciBYSFI9X2RlcmVxXyhcIi4vcG9sbGluZy14aHJcIik7dmFyIEpTT05QPV9kZXJlcV8oXCIuL3BvbGxpbmctanNvbnBcIik7dmFyIHdlYnNvY2tldD1fZGVyZXFfKFwiLi93ZWJzb2NrZXRcIik7ZXhwb3J0cy5wb2xsaW5nPXBvbGxpbmc7ZXhwb3J0cy53ZWJzb2NrZXQ9d2Vic29ja2V0O2Z1bmN0aW9uIHBvbGxpbmcob3B0cyl7dmFyIHhocjt2YXIgeGQ9ZmFsc2U7dmFyIHhzPWZhbHNlO3ZhciBqc29ucD1mYWxzZSE9PW9wdHMuanNvbnA7aWYoZ2xvYmFsLmxvY2F0aW9uKXt2YXIgaXNTU0w9XCJodHRwczpcIj09bG9jYXRpb24ucHJvdG9jb2w7dmFyIHBvcnQ9bG9jYXRpb24ucG9ydDtpZighcG9ydCl7cG9ydD1pc1NTTD80NDM6ODB9eGQ9b3B0cy5ob3N0bmFtZSE9bG9jYXRpb24uaG9zdG5hbWV8fHBvcnQhPW9wdHMucG9ydDt4cz1vcHRzLnNlY3VyZSE9aXNTU0x9b3B0cy54ZG9tYWluPXhkO29wdHMueHNjaGVtZT14czt4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO2lmKFwib3BlblwiaW4geGhyJiYhb3B0cy5mb3JjZUpTT05QKXtyZXR1cm4gbmV3IFhIUihvcHRzKX1lbHNle2lmKCFqc29ucCl0aHJvdyBuZXcgRXJyb3IoXCJKU09OUCBkaXNhYmxlZFwiKTtyZXR1cm4gbmV3IEpTT05QKG9wdHMpfX19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se1wiLi9wb2xsaW5nLWpzb25wXCI6MTYsXCIuL3BvbGxpbmcteGhyXCI6MTcsXCIuL3dlYnNvY2tldFwiOjE5LHhtbGh0dHByZXF1ZXN0OjIwfV0sMTY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBQb2xsaW5nPV9kZXJlcV8oXCIuL3BvbGxpbmdcIik7dmFyIGluaGVyaXQ9X2RlcmVxXyhcImNvbXBvbmVudC1pbmhlcml0XCIpO21vZHVsZS5leHBvcnRzPUpTT05QUG9sbGluZzt2YXIgck5ld2xpbmU9L1xcbi9nO3ZhciByRXNjYXBlZE5ld2xpbmU9L1xcXFxuL2c7dmFyIGNhbGxiYWNrczt2YXIgaW5kZXg9MDtmdW5jdGlvbiBlbXB0eSgpe31mdW5jdGlvbiBKU09OUFBvbGxpbmcob3B0cyl7UG9sbGluZy5jYWxsKHRoaXMsb3B0cyk7XG50aGlzLnF1ZXJ5PXRoaXMucXVlcnl8fHt9O2lmKCFjYWxsYmFja3Mpe2lmKCFnbG9iYWwuX19fZWlvKWdsb2JhbC5fX19laW89W107Y2FsbGJhY2tzPWdsb2JhbC5fX19laW99dGhpcy5pbmRleD1jYWxsYmFja3MubGVuZ3RoO3ZhciBzZWxmPXRoaXM7Y2FsbGJhY2tzLnB1c2goZnVuY3Rpb24obXNnKXtzZWxmLm9uRGF0YShtc2cpfSk7dGhpcy5xdWVyeS5qPXRoaXMuaW5kZXg7aWYoZ2xvYmFsLmRvY3VtZW50JiZnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcil7Z2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmV1bmxvYWRcIixmdW5jdGlvbigpe2lmKHNlbGYuc2NyaXB0KXNlbGYuc2NyaXB0Lm9uZXJyb3I9ZW1wdHl9LGZhbHNlKX19aW5oZXJpdChKU09OUFBvbGxpbmcsUG9sbGluZyk7SlNPTlBQb2xsaW5nLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeT1mYWxzZTtKU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2U9ZnVuY3Rpb24oKXtpZih0aGlzLnNjcmlwdCl7dGhpcy5zY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdCk7dGhpcy5zY3JpcHQ9bnVsbH1pZih0aGlzLmZvcm0pe3RoaXMuZm9ybS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9ybSk7dGhpcy5mb3JtPW51bGw7dGhpcy5pZnJhbWU9bnVsbH1Qb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyl9O0pTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsPWZ1bmN0aW9uKCl7dmFyIHNlbGY9dGhpczt2YXIgc2NyaXB0PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7aWYodGhpcy5zY3JpcHQpe3RoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO3RoaXMuc2NyaXB0PW51bGx9c2NyaXB0LmFzeW5jPXRydWU7c2NyaXB0LnNyYz10aGlzLnVyaSgpO3NjcmlwdC5vbmVycm9yPWZ1bmN0aW9uKGUpe3NlbGYub25FcnJvcihcImpzb25wIHBvbGwgZXJyb3JcIixlKX07dmFyIGluc2VydEF0PWRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpWzBdO2luc2VydEF0LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHNjcmlwdCxpbnNlcnRBdCk7dGhpcy5zY3JpcHQ9c2NyaXB0O3ZhciBpc1VBZ2Vja289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtpZihpc1VBZ2Vja28pe3NldFRpbWVvdXQoZnVuY3Rpb24oKXt2YXIgaWZyYW1lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO2RvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKX0sMTAwKX19O0pTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZT1mdW5jdGlvbihkYXRhLGZuKXt2YXIgc2VsZj10aGlzO2lmKCF0aGlzLmZvcm0pe3ZhciBmb3JtPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpO3ZhciBhcmVhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTt2YXIgaWQ9dGhpcy5pZnJhbWVJZD1cImVpb19pZnJhbWVfXCIrdGhpcy5pbmRleDt2YXIgaWZyYW1lO2Zvcm0uY2xhc3NOYW1lPVwic29ja2V0aW9cIjtmb3JtLnN0eWxlLnBvc2l0aW9uPVwiYWJzb2x1dGVcIjtmb3JtLnN0eWxlLnRvcD1cIi0xMDAwcHhcIjtmb3JtLnN0eWxlLmxlZnQ9XCItMTAwMHB4XCI7Zm9ybS50YXJnZXQ9aWQ7Zm9ybS5tZXRob2Q9XCJQT1NUXCI7Zm9ybS5zZXRBdHRyaWJ1dGUoXCJhY2NlcHQtY2hhcnNldFwiLFwidXRmLThcIik7YXJlYS5uYW1lPVwiZFwiO2Zvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTt0aGlzLmZvcm09Zm9ybTt0aGlzLmFyZWE9YXJlYX10aGlzLmZvcm0uYWN0aW9uPXRoaXMudXJpKCk7ZnVuY3Rpb24gY29tcGxldGUoKXtpbml0SWZyYW1lKCk7Zm4oKX1mdW5jdGlvbiBpbml0SWZyYW1lKCl7aWYoc2VsZi5pZnJhbWUpe3RyeXtzZWxmLmZvcm0ucmVtb3ZlQ2hpbGQoc2VsZi5pZnJhbWUpfWNhdGNoKGUpe3NlbGYub25FcnJvcihcImpzb25wIHBvbGxpbmcgaWZyYW1lIHJlbW92YWwgZXJyb3JcIixlKX19dHJ5e3ZhciBodG1sPSc8aWZyYW1lIHNyYz1cImphdmFzY3JpcHQ6MFwiIG5hbWU9XCInK3NlbGYuaWZyYW1lSWQrJ1wiPic7aWZyYW1lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaHRtbCl9Y2F0Y2goZSl7aWZyYW1lPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpZnJhbWVcIik7aWZyYW1lLm5hbWU9c2VsZi5pZnJhbWVJZDtpZnJhbWUuc3JjPVwiamF2YXNjcmlwdDowXCJ9aWZyYW1lLmlkPXNlbGYuaWZyYW1lSWQ7c2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7c2VsZi5pZnJhbWU9aWZyYW1lfWluaXRJZnJhbWUoKTtkYXRhPWRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsXCJcXFxcXFxuXCIpO3RoaXMuYXJlYS52YWx1ZT1kYXRhLnJlcGxhY2Uock5ld2xpbmUsXCJcXFxcblwiKTt0cnl7dGhpcy5mb3JtLnN1Ym1pdCgpfWNhdGNoKGUpe31pZih0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCl7dGhpcy5pZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7aWYoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZT09XCJjb21wbGV0ZVwiKXtjb21wbGV0ZSgpfX19ZWxzZXt0aGlzLmlmcmFtZS5vbmxvYWQ9Y29tcGxldGV9fX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7XCIuL3BvbGxpbmdcIjoxOCxcImNvbXBvbmVudC1pbmhlcml0XCI6MjF9XSwxNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIFhNTEh0dHBSZXF1ZXN0PV9kZXJlcV8oXCJ4bWxodHRwcmVxdWVzdFwiKTt2YXIgUG9sbGluZz1fZGVyZXFfKFwiLi9wb2xsaW5nXCIpO3ZhciBFbWl0dGVyPV9kZXJlcV8oXCJjb21wb25lbnQtZW1pdHRlclwiKTt2YXIgaW5oZXJpdD1fZGVyZXFfKFwiY29tcG9uZW50LWluaGVyaXRcIik7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcImVuZ2luZS5pby1jbGllbnQ6cG9sbGluZy14aHJcIik7bW9kdWxlLmV4cG9ydHM9WEhSO21vZHVsZS5leHBvcnRzLlJlcXVlc3Q9UmVxdWVzdDtmdW5jdGlvbiBlbXB0eSgpe31mdW5jdGlvbiBYSFIob3B0cyl7UG9sbGluZy5jYWxsKHRoaXMsb3B0cyk7aWYoZ2xvYmFsLmxvY2F0aW9uKXt2YXIgaXNTU0w9XCJodHRwczpcIj09bG9jYXRpb24ucHJvdG9jb2w7dmFyIHBvcnQ9bG9jYXRpb24ucG9ydDtpZighcG9ydCl7cG9ydD1pc1NTTD80NDM6ODB9dGhpcy54ZD1vcHRzLmhvc3RuYW1lIT1nbG9iYWwubG9jYXRpb24uaG9zdG5hbWV8fHBvcnQhPW9wdHMucG9ydDt0aGlzLnhzPW9wdHMuc2VjdXJlIT1pc1NTTH19aW5oZXJpdChYSFIsUG9sbGluZyk7WEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeT10cnVlO1hIUi5wcm90b3R5cGUucmVxdWVzdD1mdW5jdGlvbihvcHRzKXtvcHRzPW9wdHN8fHt9O29wdHMudXJpPXRoaXMudXJpKCk7b3B0cy54ZD10aGlzLnhkO29wdHMueHM9dGhpcy54cztvcHRzLmFnZW50PXRoaXMuYWdlbnR8fGZhbHNlO29wdHMuc3VwcG9ydHNCaW5hcnk9dGhpcy5zdXBwb3J0c0JpbmFyeTtvcHRzLmVuYWJsZXNYRFI9dGhpcy5lbmFibGVzWERSO29wdHMucGZ4PXRoaXMucGZ4O29wdHMua2V5PXRoaXMua2V5O29wdHMucGFzc3BocmFzZT10aGlzLnBhc3NwaHJhc2U7b3B0cy5jZXJ0PXRoaXMuY2VydDtvcHRzLmNhPXRoaXMuY2E7b3B0cy5jaXBoZXJzPXRoaXMuY2lwaGVycztvcHRzLnJlamVjdFVuYXV0aG9yaXplZD10aGlzLnJlamVjdFVuYXV0aG9yaXplZDtyZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyl9O1hIUi5wcm90b3R5cGUuZG9Xcml0ZT1mdW5jdGlvbihkYXRhLGZuKXt2YXIgaXNCaW5hcnk9dHlwZW9mIGRhdGEhPT1cInN0cmluZ1wiJiZkYXRhIT09dW5kZWZpbmVkO3ZhciByZXE9dGhpcy5yZXF1ZXN0KHttZXRob2Q6XCJQT1NUXCIsZGF0YTpkYXRhLGlzQmluYXJ5OmlzQmluYXJ5fSk7dmFyIHNlbGY9dGhpcztyZXEub24oXCJzdWNjZXNzXCIsZm4pO3JlcS5vbihcImVycm9yXCIsZnVuY3Rpb24oZXJyKXtzZWxmLm9uRXJyb3IoXCJ4aHIgcG9zdCBlcnJvclwiLGVycil9KTt0aGlzLnNlbmRYaHI9cmVxfTtYSFIucHJvdG90eXBlLmRvUG9sbD1mdW5jdGlvbigpe2RlYnVnKFwieGhyIHBvbGxcIik7dmFyIHJlcT10aGlzLnJlcXVlc3QoKTt2YXIgc2VsZj10aGlzO3JlcS5vbihcImRhdGFcIixmdW5jdGlvbihkYXRhKXtzZWxmLm9uRGF0YShkYXRhKX0pO3JlcS5vbihcImVycm9yXCIsZnVuY3Rpb24oZXJyKXtzZWxmLm9uRXJyb3IoXCJ4aHIgcG9sbCBlcnJvclwiLGVycil9KTt0aGlzLnBvbGxYaHI9cmVxfTtmdW5jdGlvbiBSZXF1ZXN0KG9wdHMpe3RoaXMubWV0aG9kPW9wdHMubWV0aG9kfHxcIkdFVFwiO3RoaXMudXJpPW9wdHMudXJpO3RoaXMueGQ9ISFvcHRzLnhkO3RoaXMueHM9ISFvcHRzLnhzO3RoaXMuYXN5bmM9ZmFsc2UhPT1vcHRzLmFzeW5jO3RoaXMuZGF0YT11bmRlZmluZWQhPW9wdHMuZGF0YT9vcHRzLmRhdGE6bnVsbDt0aGlzLmFnZW50PW9wdHMuYWdlbnQ7dGhpcy5pc0JpbmFyeT1vcHRzLmlzQmluYXJ5O3RoaXMuc3VwcG9ydHNCaW5hcnk9b3B0cy5zdXBwb3J0c0JpbmFyeTt0aGlzLmVuYWJsZXNYRFI9b3B0cy5lbmFibGVzWERSO3RoaXMucGZ4PW9wdHMucGZ4O3RoaXMua2V5PW9wdHMua2V5O3RoaXMucGFzc3BocmFzZT1vcHRzLnBhc3NwaHJhc2U7dGhpcy5jZXJ0PW9wdHMuY2VydDt0aGlzLmNhPW9wdHMuY2E7dGhpcy5jaXBoZXJzPW9wdHMuY2lwaGVyczt0aGlzLnJlamVjdFVuYXV0aG9yaXplZD1vcHRzLnJlamVjdFVuYXV0aG9yaXplZDt0aGlzLmNyZWF0ZSgpfUVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1JlcXVlc3QucHJvdG90eXBlLmNyZWF0ZT1mdW5jdGlvbigpe3ZhciBvcHRzPXthZ2VudDp0aGlzLmFnZW50LHhkb21haW46dGhpcy54ZCx4c2NoZW1lOnRoaXMueHMsZW5hYmxlc1hEUjp0aGlzLmVuYWJsZXNYRFJ9O29wdHMucGZ4PXRoaXMucGZ4O29wdHMua2V5PXRoaXMua2V5O29wdHMucGFzc3BocmFzZT10aGlzLnBhc3NwaHJhc2U7b3B0cy5jZXJ0PXRoaXMuY2VydDtvcHRzLmNhPXRoaXMuY2E7b3B0cy5jaXBoZXJzPXRoaXMuY2lwaGVycztvcHRzLnJlamVjdFVuYXV0aG9yaXplZD10aGlzLnJlamVjdFVuYXV0aG9yaXplZDt2YXIgeGhyPXRoaXMueGhyPW5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTt2YXIgc2VsZj10aGlzO3RyeXtkZWJ1ZyhcInhociBvcGVuICVzOiAlc1wiLHRoaXMubWV0aG9kLHRoaXMudXJpKTt4aHIub3Blbih0aGlzLm1ldGhvZCx0aGlzLnVyaSx0aGlzLmFzeW5jKTtpZih0aGlzLnN1cHBvcnRzQmluYXJ5KXt4aHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIn1pZihcIlBPU1RcIj09dGhpcy5tZXRob2Qpe3RyeXtpZih0aGlzLmlzQmluYXJ5KXt4aHIuc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtdHlwZVwiLFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpfWVsc2V7eGhyLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LXR5cGVcIixcInRleHQvcGxhaW47Y2hhcnNldD1VVEYtOFwiKX19Y2F0Y2goZSl7fX1pZihcIndpdGhDcmVkZW50aWFsc1wiaW4geGhyKXt4aHIud2l0aENyZWRlbnRpYWxzPXRydWV9aWYodGhpcy5oYXNYRFIoKSl7eGhyLm9ubG9hZD1mdW5jdGlvbigpe3NlbGYub25Mb2FkKCl9O3hoci5vbmVycm9yPWZ1bmN0aW9uKCl7c2VsZi5vbkVycm9yKHhoci5yZXNwb25zZVRleHQpfX1lbHNle3hoci5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtpZig0IT14aHIucmVhZHlTdGF0ZSlyZXR1cm47aWYoMjAwPT14aHIuc3RhdHVzfHwxMjIzPT14aHIuc3RhdHVzKXtzZWxmLm9uTG9hZCgpfWVsc2V7c2V0VGltZW91dChmdW5jdGlvbigpe3NlbGYub25FcnJvcih4aHIuc3RhdHVzKX0sMCl9fX1kZWJ1ZyhcInhociBkYXRhICVzXCIsdGhpcy5kYXRhKTt4aHIuc2VuZCh0aGlzLmRhdGEpfWNhdGNoKGUpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtzZWxmLm9uRXJyb3IoZSl9LDApO3JldHVybn1pZihnbG9iYWwuZG9jdW1lbnQpe3RoaXMuaW5kZXg9UmVxdWVzdC5yZXF1ZXN0c0NvdW50Kys7UmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XT10aGlzfX07UmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzPWZ1bmN0aW9uKCl7dGhpcy5lbWl0KFwic3VjY2Vzc1wiKTt0aGlzLmNsZWFudXAoKX07UmVxdWVzdC5wcm90b3R5cGUub25EYXRhPWZ1bmN0aW9uKGRhdGEpe3RoaXMuZW1pdChcImRhdGFcIixkYXRhKTt0aGlzLm9uU3VjY2VzcygpfTtSZXF1ZXN0LnByb3RvdHlwZS5vbkVycm9yPWZ1bmN0aW9uKGVycil7dGhpcy5lbWl0KFwiZXJyb3JcIixlcnIpO3RoaXMuY2xlYW51cCh0cnVlKX07UmVxdWVzdC5wcm90b3R5cGUuY2xlYW51cD1mdW5jdGlvbihmcm9tRXJyb3Ipe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiB0aGlzLnhocnx8bnVsbD09PXRoaXMueGhyKXtyZXR1cm59aWYodGhpcy5oYXNYRFIoKSl7dGhpcy54aHIub25sb2FkPXRoaXMueGhyLm9uZXJyb3I9ZW1wdHl9ZWxzZXt0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2U9ZW1wdHl9aWYoZnJvbUVycm9yKXt0cnl7dGhpcy54aHIuYWJvcnQoKX1jYXRjaChlKXt9fWlmKGdsb2JhbC5kb2N1bWVudCl7ZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF19dGhpcy54aHI9bnVsbH07UmVxdWVzdC5wcm90b3R5cGUub25Mb2FkPWZ1bmN0aW9uKCl7dmFyIGRhdGE7dHJ5e3ZhciBjb250ZW50VHlwZTt0cnl7Y29udGVudFR5cGU9dGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVR5cGVcIikuc3BsaXQoXCI7XCIpWzBdfWNhdGNoKGUpe31pZihjb250ZW50VHlwZT09PVwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIpe2RhdGE9dGhpcy54aHIucmVzcG9uc2V9ZWxzZXtpZighdGhpcy5zdXBwb3J0c0JpbmFyeSl7ZGF0YT10aGlzLnhoci5yZXNwb25zZVRleHR9ZWxzZXtkYXRhPVwib2tcIn19fWNhdGNoKGUpe3RoaXMub25FcnJvcihlKX1pZihudWxsIT1kYXRhKXt0aGlzLm9uRGF0YShkYXRhKX19O1JlcXVlc3QucHJvdG90eXBlLmhhc1hEUj1mdW5jdGlvbigpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgZ2xvYmFsLlhEb21haW5SZXF1ZXN0JiYhdGhpcy54cyYmdGhpcy5lbmFibGVzWERSfTtSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydD1mdW5jdGlvbigpe3RoaXMuY2xlYW51cCgpfTtpZihnbG9iYWwuZG9jdW1lbnQpe1JlcXVlc3QucmVxdWVzdHNDb3VudD0wO1JlcXVlc3QucmVxdWVzdHM9e307aWYoZ2xvYmFsLmF0dGFjaEV2ZW50KXtnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbnVubG9hZFwiLHVubG9hZEhhbmRsZXIpfWVsc2UgaWYoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpe2dsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsdW5sb2FkSGFuZGxlcixmYWxzZSl9fWZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKXtmb3IodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cyl7aWYoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSl7UmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpfX19fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHtcIi4vcG9sbGluZ1wiOjE4LFwiY29tcG9uZW50LWVtaXR0ZXJcIjo5LFwiY29tcG9uZW50LWluaGVyaXRcIjoyMSxkZWJ1ZzoyMix4bWxodHRwcmVxdWVzdDoyMH1dLDE4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgVHJhbnNwb3J0PV9kZXJlcV8oXCIuLi90cmFuc3BvcnRcIik7dmFyIHBhcnNlcXM9X2RlcmVxXyhcInBhcnNlcXNcIik7dmFyIHBhcnNlcj1fZGVyZXFfKFwiZW5naW5lLmlvLXBhcnNlclwiKTt2YXIgaW5oZXJpdD1fZGVyZXFfKFwiY29tcG9uZW50LWluaGVyaXRcIik7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcImVuZ2luZS5pby1jbGllbnQ6cG9sbGluZ1wiKTttb2R1bGUuZXhwb3J0cz1Qb2xsaW5nO3ZhciBoYXNYSFIyPWZ1bmN0aW9uKCl7dmFyIFhNTEh0dHBSZXF1ZXN0PV9kZXJlcV8oXCJ4bWxodHRwcmVxdWVzdFwiKTt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdCh7eGRvbWFpbjpmYWxzZX0pO3JldHVybiBudWxsIT14aHIucmVzcG9uc2VUeXBlfSgpO2Z1bmN0aW9uIFBvbGxpbmcob3B0cyl7dmFyIGZvcmNlQmFzZTY0PW9wdHMmJm9wdHMuZm9yY2VCYXNlNjQ7aWYoIWhhc1hIUjJ8fGZvcmNlQmFzZTY0KXt0aGlzLnN1cHBvcnRzQmluYXJ5PWZhbHNlfVRyYW5zcG9ydC5jYWxsKHRoaXMsb3B0cyl9aW5oZXJpdChQb2xsaW5nLFRyYW5zcG9ydCk7UG9sbGluZy5wcm90b3R5cGUubmFtZT1cInBvbGxpbmdcIjtQb2xsaW5nLnByb3RvdHlwZS5kb09wZW49ZnVuY3Rpb24oKXt0aGlzLnBvbGwoKX07UG9sbGluZy5wcm90b3R5cGUucGF1c2U9ZnVuY3Rpb24ob25QYXVzZSl7dmFyIHBlbmRpbmc9MDt2YXIgc2VsZj10aGlzO3RoaXMucmVhZHlTdGF0ZT1cInBhdXNpbmdcIjtmdW5jdGlvbiBwYXVzZSgpe2RlYnVnKFwicGF1c2VkXCIpO3NlbGYucmVhZHlTdGF0ZT1cInBhdXNlZFwiO29uUGF1c2UoKX1pZih0aGlzLnBvbGxpbmd8fCF0aGlzLndyaXRhYmxlKXt2YXIgdG90YWw9MDtpZih0aGlzLnBvbGxpbmcpe2RlYnVnKFwid2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZVwiKTt0b3RhbCsrO3RoaXMub25jZShcInBvbGxDb21wbGV0ZVwiLGZ1bmN0aW9uKCl7ZGVidWcoXCJwcmUtcGF1c2UgcG9sbGluZyBjb21wbGV0ZVwiKTstLXRvdGFsfHxwYXVzZSgpfSl9aWYoIXRoaXMud3JpdGFibGUpe2RlYnVnKFwid2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZVwiKTt0b3RhbCsrO3RoaXMub25jZShcImRyYWluXCIsZnVuY3Rpb24oKXtkZWJ1ZyhcInByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlXCIpOy0tdG90YWx8fHBhdXNlKCl9KX19ZWxzZXtwYXVzZSgpfX07UG9sbGluZy5wcm90b3R5cGUucG9sbD1mdW5jdGlvbigpe2RlYnVnKFwicG9sbGluZ1wiKTt0aGlzLnBvbGxpbmc9dHJ1ZTt0aGlzLmRvUG9sbCgpO3RoaXMuZW1pdChcInBvbGxcIil9O1BvbGxpbmcucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbihkYXRhKXt2YXIgc2VsZj10aGlzO2RlYnVnKFwicG9sbGluZyBnb3QgZGF0YSAlc1wiLGRhdGEpO3ZhciBjYWxsYmFjaz1mdW5jdGlvbihwYWNrZXQsaW5kZXgsdG90YWwpe2lmKFwib3BlbmluZ1wiPT1zZWxmLnJlYWR5U3RhdGUpe3NlbGYub25PcGVuKCl9aWYoXCJjbG9zZVwiPT1wYWNrZXQudHlwZSl7c2VsZi5vbkNsb3NlKCk7cmV0dXJuIGZhbHNlfXNlbGYub25QYWNrZXQocGFja2V0KX07cGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSx0aGlzLnNvY2tldC5iaW5hcnlUeXBlLGNhbGxiYWNrKTtpZihcImNsb3NlZFwiIT10aGlzLnJlYWR5U3RhdGUpe3RoaXMucG9sbGluZz1mYWxzZTt0aGlzLmVtaXQoXCJwb2xsQ29tcGxldGVcIik7aWYoXCJvcGVuXCI9PXRoaXMucmVhZHlTdGF0ZSl7dGhpcy5wb2xsKCl9ZWxzZXtkZWJ1ZygnaWdub3JpbmcgcG9sbCAtIHRyYW5zcG9ydCBzdGF0ZSBcIiVzXCInLHRoaXMucmVhZHlTdGF0ZSl9fX07UG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZT1mdW5jdGlvbigpe3ZhciBzZWxmPXRoaXM7ZnVuY3Rpb24gY2xvc2UoKXtkZWJ1ZyhcIndyaXRpbmcgY2xvc2UgcGFja2V0XCIpO3NlbGYud3JpdGUoW3t0eXBlOlwiY2xvc2VcIn1dKX1pZihcIm9wZW5cIj09dGhpcy5yZWFkeVN0YXRlKXtkZWJ1ZyhcInRyYW5zcG9ydCBvcGVuIC0gY2xvc2luZ1wiKTtjbG9zZSgpfWVsc2V7ZGVidWcoXCJ0cmFuc3BvcnQgbm90IG9wZW4gLSBkZWZlcnJpbmcgY2xvc2VcIik7dGhpcy5vbmNlKFwib3BlblwiLGNsb3NlKX19O1BvbGxpbmcucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKHBhY2tldHMpe3ZhciBzZWxmPXRoaXM7dGhpcy53cml0YWJsZT1mYWxzZTt2YXIgY2FsbGJhY2tmbj1mdW5jdGlvbigpe3NlbGYud3JpdGFibGU9dHJ1ZTtzZWxmLmVtaXQoXCJkcmFpblwiKX07dmFyIHNlbGY9dGhpcztwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLHRoaXMuc3VwcG9ydHNCaW5hcnksZnVuY3Rpb24oZGF0YSl7c2VsZi5kb1dyaXRlKGRhdGEsY2FsbGJhY2tmbil9KX07UG9sbGluZy5wcm90b3R5cGUudXJpPWZ1bmN0aW9uKCl7dmFyIHF1ZXJ5PXRoaXMucXVlcnl8fHt9O3ZhciBzY2hlbWE9dGhpcy5zZWN1cmU/XCJodHRwc1wiOlwiaHR0cFwiO3ZhciBwb3J0PVwiXCI7aWYoZmFsc2UhPT10aGlzLnRpbWVzdGFtcFJlcXVlc3RzKXtxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXT0rbmV3IERhdGUrXCItXCIrVHJhbnNwb3J0LnRpbWVzdGFtcHMrK31pZighdGhpcy5zdXBwb3J0c0JpbmFyeSYmIXF1ZXJ5LnNpZCl7cXVlcnkuYjY0PTF9cXVlcnk9cGFyc2Vxcy5lbmNvZGUocXVlcnkpO2lmKHRoaXMucG9ydCYmKFwiaHR0cHNcIj09c2NoZW1hJiZ0aGlzLnBvcnQhPTQ0M3x8XCJodHRwXCI9PXNjaGVtYSYmdGhpcy5wb3J0IT04MCkpe3BvcnQ9XCI6XCIrdGhpcy5wb3J0fWlmKHF1ZXJ5Lmxlbmd0aCl7cXVlcnk9XCI/XCIrcXVlcnl9cmV0dXJuIHNjaGVtYStcIjovL1wiK3RoaXMuaG9zdG5hbWUrcG9ydCt0aGlzLnBhdGgrcXVlcnl9fSx7XCIuLi90cmFuc3BvcnRcIjoxNCxcImNvbXBvbmVudC1pbmhlcml0XCI6MjEsZGVidWc6MjIsXCJlbmdpbmUuaW8tcGFyc2VyXCI6MjUscGFyc2VxczozNSx4bWxodHRwcmVxdWVzdDoyMH1dLDE5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgVHJhbnNwb3J0PV9kZXJlcV8oXCIuLi90cmFuc3BvcnRcIik7dmFyIHBhcnNlcj1fZGVyZXFfKFwiZW5naW5lLmlvLXBhcnNlclwiKTt2YXIgcGFyc2Vxcz1fZGVyZXFfKFwicGFyc2Vxc1wiKTt2YXIgaW5oZXJpdD1fZGVyZXFfKFwiY29tcG9uZW50LWluaGVyaXRcIik7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcImVuZ2luZS5pby1jbGllbnQ6d2Vic29ja2V0XCIpO3ZhciBXZWJTb2NrZXQ9X2RlcmVxXyhcIndzXCIpO21vZHVsZS5leHBvcnRzPVdTO2Z1bmN0aW9uIFdTKG9wdHMpe3ZhciBmb3JjZUJhc2U2ND1vcHRzJiZvcHRzLmZvcmNlQmFzZTY0O2lmKGZvcmNlQmFzZTY0KXt0aGlzLnN1cHBvcnRzQmluYXJ5PWZhbHNlfVRyYW5zcG9ydC5jYWxsKHRoaXMsb3B0cyl9aW5oZXJpdChXUyxUcmFuc3BvcnQpO1dTLnByb3RvdHlwZS5uYW1lPVwid2Vic29ja2V0XCI7V1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5PXRydWU7V1MucHJvdG90eXBlLmRvT3Blbj1mdW5jdGlvbigpe2lmKCF0aGlzLmNoZWNrKCkpe3JldHVybn12YXIgc2VsZj10aGlzO3ZhciB1cmk9dGhpcy51cmkoKTt2YXIgcHJvdG9jb2xzPXZvaWQgMDt2YXIgb3B0cz17YWdlbnQ6dGhpcy5hZ2VudH07b3B0cy5wZng9dGhpcy5wZng7b3B0cy5rZXk9dGhpcy5rZXk7b3B0cy5wYXNzcGhyYXNlPXRoaXMucGFzc3BocmFzZTtvcHRzLmNlcnQ9dGhpcy5jZXJ0O29wdHMuY2E9dGhpcy5jYTtvcHRzLmNpcGhlcnM9dGhpcy5jaXBoZXJzO29wdHMucmVqZWN0VW5hdXRob3JpemVkPXRoaXMucmVqZWN0VW5hdXRob3JpemVkO3RoaXMud3M9bmV3IFdlYlNvY2tldCh1cmkscHJvdG9jb2xzLG9wdHMpO2lmKHRoaXMud3MuYmluYXJ5VHlwZT09PXVuZGVmaW5lZCl7dGhpcy5zdXBwb3J0c0JpbmFyeT1mYWxzZX10aGlzLndzLmJpbmFyeVR5cGU9XCJhcnJheWJ1ZmZlclwiO3RoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKX07V1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzPWZ1bmN0aW9uKCl7dmFyIHNlbGY9dGhpczt0aGlzLndzLm9ub3Blbj1mdW5jdGlvbigpe3NlbGYub25PcGVuKCl9O3RoaXMud3Mub25jbG9zZT1mdW5jdGlvbigpe3NlbGYub25DbG9zZSgpfTt0aGlzLndzLm9ubWVzc2FnZT1mdW5jdGlvbihldil7c2VsZi5vbkRhdGEoZXYuZGF0YSl9O3RoaXMud3Mub25lcnJvcj1mdW5jdGlvbihlKXtzZWxmLm9uRXJyb3IoXCJ3ZWJzb2NrZXQgZXJyb3JcIixlKX19O2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJi9pUGFkfGlQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSl7V1MucHJvdG90eXBlLm9uRGF0YT1mdW5jdGlvbihkYXRhKXt2YXIgc2VsZj10aGlzO3NldFRpbWVvdXQoZnVuY3Rpb24oKXtUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsZGF0YSl9LDApfX1XUy5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24ocGFja2V0cyl7dmFyIHNlbGY9dGhpczt0aGlzLndyaXRhYmxlPWZhbHNlO2Zvcih2YXIgaT0wLGw9cGFja2V0cy5sZW5ndGg7aTxsO2krKyl7cGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXRzW2ldLHRoaXMuc3VwcG9ydHNCaW5hcnksZnVuY3Rpb24oZGF0YSl7dHJ5e3NlbGYud3Muc2VuZChkYXRhKX1jYXRjaChlKXtkZWJ1ZyhcIndlYnNvY2tldCBjbG9zZWQgYmVmb3JlIG9uY2xvc2UgZXZlbnRcIil9fSl9ZnVuY3Rpb24gb25kcmFpbigpe3NlbGYud3JpdGFibGU9dHJ1ZTtzZWxmLmVtaXQoXCJkcmFpblwiKX1zZXRUaW1lb3V0KG9uZHJhaW4sMCl9O1dTLnByb3RvdHlwZS5vbkNsb3NlPWZ1bmN0aW9uKCl7VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlLmNhbGwodGhpcyl9O1dTLnByb3RvdHlwZS5kb0Nsb3NlPWZ1bmN0aW9uKCl7aWYodHlwZW9mIHRoaXMud3MhPT1cInVuZGVmaW5lZFwiKXt0aGlzLndzLmNsb3NlKCl9fTtXUy5wcm90b3R5cGUudXJpPWZ1bmN0aW9uKCl7dmFyIHF1ZXJ5PXRoaXMucXVlcnl8fHt9O3ZhciBzY2hlbWE9dGhpcy5zZWN1cmU/XCJ3c3NcIjpcIndzXCI7dmFyIHBvcnQ9XCJcIjtpZih0aGlzLnBvcnQmJihcIndzc1wiPT1zY2hlbWEmJnRoaXMucG9ydCE9NDQzfHxcIndzXCI9PXNjaGVtYSYmdGhpcy5wb3J0IT04MCkpe3BvcnQ9XCI6XCIrdGhpcy5wb3J0fWlmKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpe3F1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dPStuZXcgRGF0ZX1pZighdGhpcy5zdXBwb3J0c0JpbmFyeSl7cXVlcnkuYjY0PTF9cXVlcnk9cGFyc2Vxcy5lbmNvZGUocXVlcnkpO2lmKHF1ZXJ5Lmxlbmd0aCl7cXVlcnk9XCI/XCIrcXVlcnl9cmV0dXJuIHNjaGVtYStcIjovL1wiK3RoaXMuaG9zdG5hbWUrcG9ydCt0aGlzLnBhdGgrcXVlcnl9O1dTLnByb3RvdHlwZS5jaGVjaz1mdW5jdGlvbigpe3JldHVybiEhV2ViU29ja2V0JiYhKFwiX19pbml0aWFsaXplXCJpbiBXZWJTb2NrZXQmJnRoaXMubmFtZT09PVdTLnByb3RvdHlwZS5uYW1lKX19LHtcIi4uL3RyYW5zcG9ydFwiOjE0LFwiY29tcG9uZW50LWluaGVyaXRcIjoyMSxkZWJ1ZzoyMixcImVuZ2luZS5pby1wYXJzZXJcIjoyNSxwYXJzZXFzOjM1LHdzOjM3fV0sMjA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBoYXNDT1JTPV9kZXJlcV8oXCJoYXMtY29yc1wiKTttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihvcHRzKXt2YXIgeGRvbWFpbj1vcHRzLnhkb21haW47dmFyIHhzY2hlbWU9b3B0cy54c2NoZW1lO3ZhciBlbmFibGVzWERSPW9wdHMuZW5hYmxlc1hEUjt0cnl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFhNTEh0dHBSZXF1ZXN0JiYoIXhkb21haW58fGhhc0NPUlMpKXtyZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0fX1jYXRjaChlKXt9dHJ5e2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBYRG9tYWluUmVxdWVzdCYmIXhzY2hlbWUmJmVuYWJsZXNYRFIpe3JldHVybiBuZXcgWERvbWFpblJlcXVlc3R9fWNhdGNoKGUpe31pZigheGRvbWFpbil7dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpfWNhdGNoKGUpe319fX0se1wiaGFzLWNvcnNcIjo0MH1dLDIxOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihhLGIpe3ZhciBmbj1mdW5jdGlvbigpe307Zm4ucHJvdG90eXBlPWIucHJvdG90eXBlO2EucHJvdG90eXBlPW5ldyBmbjthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hfX0se31dLDIyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtleHBvcnRzPW1vZHVsZS5leHBvcnRzPV9kZXJlcV8oXCIuL2RlYnVnXCIpO2V4cG9ydHMubG9nPWxvZztleHBvcnRzLmZvcm1hdEFyZ3M9Zm9ybWF0QXJncztleHBvcnRzLnNhdmU9c2F2ZTtleHBvcnRzLmxvYWQ9bG9hZDtleHBvcnRzLnVzZUNvbG9ycz11c2VDb2xvcnM7ZXhwb3J0cy5jb2xvcnM9W1wibGlnaHRzZWFncmVlblwiLFwiZm9yZXN0Z3JlZW5cIixcImdvbGRlbnJvZFwiLFwiZG9kZ2VyYmx1ZVwiLFwiZGFya29yY2hpZFwiLFwiY3JpbXNvblwiXTtmdW5jdGlvbiB1c2VDb2xvcnMoKXtyZXR1cm5cIldlYmtpdEFwcGVhcmFuY2VcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZXx8d2luZG93LmNvbnNvbGUmJihjb25zb2xlLmZpcmVidWd8fGNvbnNvbGUuZXhjZXB0aW9uJiZjb25zb2xlLnRhYmxlKXx8bmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykmJnBhcnNlSW50KFJlZ0V4cC4kMSwxMCk+PTMxfWV4cG9ydHMuZm9ybWF0dGVycy5qPWZ1bmN0aW9uKHYpe3JldHVybiBKU09OLnN0cmluZ2lmeSh2KX07ZnVuY3Rpb24gZm9ybWF0QXJncygpe3ZhciBhcmdzPWFyZ3VtZW50czt2YXIgdXNlQ29sb3JzPXRoaXMudXNlQ29sb3JzO2FyZ3NbMF09KHVzZUNvbG9ycz9cIiVjXCI6XCJcIikrdGhpcy5uYW1lc3BhY2UrKHVzZUNvbG9ycz9cIiAlY1wiOlwiIFwiKSthcmdzWzBdKyh1c2VDb2xvcnM/XCIlYyBcIjpcIiBcIikrXCIrXCIrZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO2lmKCF1c2VDb2xvcnMpcmV0dXJuIGFyZ3M7dmFyIGM9XCJjb2xvcjogXCIrdGhpcy5jb2xvcjthcmdzPVthcmdzWzBdLGMsXCJjb2xvcjogaW5oZXJpdFwiXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncywxKSk7dmFyIGluZGV4PTA7dmFyIGxhc3RDPTA7YXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csZnVuY3Rpb24obWF0Y2gpe2lmKFwiJVwiPT09bWF0Y2gpcmV0dXJuO2luZGV4Kys7aWYoXCIlY1wiPT09bWF0Y2gpe2xhc3RDPWluZGV4fX0pO2FyZ3Muc3BsaWNlKGxhc3RDLDAsYyk7cmV0dXJuIGFyZ3N9ZnVuY3Rpb24gbG9nKCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGNvbnNvbGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGNvbnNvbGUubG9nJiZGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZyxjb25zb2xlLGFyZ3VtZW50cyl9ZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKXt0cnl7aWYobnVsbD09bmFtZXNwYWNlcyl7bG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oXCJkZWJ1Z1wiKX1lbHNle2xvY2FsU3RvcmFnZS5kZWJ1Zz1uYW1lc3BhY2VzfX1jYXRjaChlKXt9fWZ1bmN0aW9uIGxvYWQoKXt2YXIgcjt0cnl7cj1sb2NhbFN0b3JhZ2UuZGVidWd9Y2F0Y2goZSl7fXJldHVybiByfWV4cG9ydHMuZW5hYmxlKGxvYWQoKSl9LHtcIi4vZGVidWdcIjoyM31dLDIzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXtleHBvcnRzPW1vZHVsZS5leHBvcnRzPWRlYnVnO2V4cG9ydHMuY29lcmNlPWNvZXJjZTtleHBvcnRzLmRpc2FibGU9ZGlzYWJsZTtleHBvcnRzLmVuYWJsZT1lbmFibGU7ZXhwb3J0cy5lbmFibGVkPWVuYWJsZWQ7ZXhwb3J0cy5odW1hbml6ZT1fZGVyZXFfKFwibXNcIik7ZXhwb3J0cy5uYW1lcz1bXTtleHBvcnRzLnNraXBzPVtdO2V4cG9ydHMuZm9ybWF0dGVycz17fTt2YXIgcHJldkNvbG9yPTA7dmFyIHByZXZUaW1lO2Z1bmN0aW9uIHNlbGVjdENvbG9yKCl7cmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrJWV4cG9ydHMuY29sb3JzLmxlbmd0aF19ZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKXtmdW5jdGlvbiBkaXNhYmxlZCgpe31kaXNhYmxlZC5lbmFibGVkPWZhbHNlO2Z1bmN0aW9uIGVuYWJsZWQoKXt2YXIgc2VsZj1lbmFibGVkO3ZhciBjdXJyPStuZXcgRGF0ZTt2YXIgbXM9Y3Vyci0ocHJldlRpbWV8fGN1cnIpO3NlbGYuZGlmZj1tcztzZWxmLnByZXY9cHJldlRpbWU7c2VsZi5jdXJyPWN1cnI7cHJldlRpbWU9Y3VycjtpZihudWxsPT1zZWxmLnVzZUNvbG9ycylzZWxmLnVzZUNvbG9ycz1leHBvcnRzLnVzZUNvbG9ycygpO2lmKG51bGw9PXNlbGYuY29sb3ImJnNlbGYudXNlQ29sb3JzKXNlbGYuY29sb3I9c2VsZWN0Q29sb3IoKTt2YXIgYXJncz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO2FyZ3NbMF09ZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBhcmdzWzBdKXthcmdzPVtcIiVvXCJdLmNvbmNhdChhcmdzKX12YXIgaW5kZXg9MDthcmdzWzBdPWFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csZnVuY3Rpb24obWF0Y2gsZm9ybWF0KXtpZihtYXRjaD09PVwiJVwiKXJldHVybiBtYXRjaDtpbmRleCsrO3ZhciBmb3JtYXR0ZXI9ZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGZvcm1hdHRlcil7dmFyIHZhbD1hcmdzW2luZGV4XTttYXRjaD1mb3JtYXR0ZXIuY2FsbChzZWxmLHZhbCk7YXJncy5zcGxpY2UoaW5kZXgsMSk7aW5kZXgtLX1yZXR1cm4gbWF0Y2h9KTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKXthcmdzPWV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLGFyZ3MpfXZhciBsb2dGbj1lbmFibGVkLmxvZ3x8ZXhwb3J0cy5sb2d8fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7bG9nRm4uYXBwbHkoc2VsZixhcmdzKX1lbmFibGVkLmVuYWJsZWQ9dHJ1ZTt2YXIgZm49ZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSk/ZW5hYmxlZDpkaXNhYmxlZDtmbi5uYW1lc3BhY2U9bmFtZXNwYWNlO3JldHVybiBmbn1mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcyl7ZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO3ZhciBzcGxpdD0obmFtZXNwYWNlc3x8XCJcIikuc3BsaXQoL1tcXHMsXSsvKTt2YXIgbGVuPXNwbGl0Lmxlbmd0aDtmb3IodmFyIGk9MDtpPGxlbjtpKyspe2lmKCFzcGxpdFtpXSljb250aW51ZTtuYW1lc3BhY2VzPXNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLFwiLio/XCIpO2lmKG5hbWVzcGFjZXNbMF09PT1cIi1cIil7ZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrbmFtZXNwYWNlcy5zdWJzdHIoMSkrXCIkXCIpKX1lbHNle2V4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKFwiXlwiK25hbWVzcGFjZXMrXCIkXCIpKX19fWZ1bmN0aW9uIGRpc2FibGUoKXtleHBvcnRzLmVuYWJsZShcIlwiKX1mdW5jdGlvbiBlbmFibGVkKG5hbWUpe3ZhciBpLGxlbjtmb3IoaT0wLGxlbj1leHBvcnRzLnNraXBzLmxlbmd0aDtpPGxlbjtpKyspe2lmKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSl7cmV0dXJuIGZhbHNlfX1mb3IoaT0wLGxlbj1leHBvcnRzLm5hbWVzLmxlbmd0aDtpPGxlbjtpKyspe2lmKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSl7cmV0dXJuIHRydWV9fXJldHVybiBmYWxzZX1mdW5jdGlvbiBjb2VyY2UodmFsKXtpZih2YWwgaW5zdGFuY2VvZiBFcnJvcilyZXR1cm4gdmFsLnN0YWNrfHx2YWwubWVzc2FnZTtyZXR1cm4gdmFsfX0se21zOjI0fV0sMjQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciBzPTFlMzt2YXIgbT1zKjYwO3ZhciBoPW0qNjA7dmFyIGQ9aCoyNDt2YXIgeT1kKjM2NS4yNTttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbih2YWwsb3B0aW9ucyl7b3B0aW9ucz1vcHRpb25zfHx7fTtpZihcInN0cmluZ1wiPT10eXBlb2YgdmFsKXJldHVybiBwYXJzZSh2YWwpO3JldHVybiBvcHRpb25zLmxvbmc/bG9uZyh2YWwpOnNob3J0KHZhbCl9O2Z1bmN0aW9uIHBhcnNlKHN0cil7dmFyIG1hdGNoPS9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1zfHNlY29uZHM/fHN8bWludXRlcz98bXxob3Vycz98aHxkYXlzP3xkfHllYXJzP3x5KT8kL2kuZXhlYyhzdHIpO2lmKCFtYXRjaClyZXR1cm47dmFyIG49cGFyc2VGbG9hdChtYXRjaFsxXSk7dmFyIHR5cGU9KG1hdGNoWzJdfHxcIm1zXCIpLnRvTG93ZXJDYXNlKCk7c3dpdGNoKHR5cGUpe2Nhc2VcInllYXJzXCI6Y2FzZVwieWVhclwiOmNhc2VcInlcIjpyZXR1cm4gbip5O2Nhc2VcImRheXNcIjpjYXNlXCJkYXlcIjpjYXNlXCJkXCI6cmV0dXJuIG4qZDtjYXNlXCJob3Vyc1wiOmNhc2VcImhvdXJcIjpjYXNlXCJoXCI6cmV0dXJuIG4qaDtjYXNlXCJtaW51dGVzXCI6Y2FzZVwibWludXRlXCI6Y2FzZVwibVwiOnJldHVybiBuKm07Y2FzZVwic2Vjb25kc1wiOmNhc2VcInNlY29uZFwiOmNhc2VcInNcIjpyZXR1cm4gbipzO2Nhc2VcIm1zXCI6cmV0dXJuIG59fWZ1bmN0aW9uIHNob3J0KG1zKXtpZihtcz49ZClyZXR1cm4gTWF0aC5yb3VuZChtcy9kKStcImRcIjtpZihtcz49aClyZXR1cm4gTWF0aC5yb3VuZChtcy9oKStcImhcIjtpZihtcz49bSlyZXR1cm4gTWF0aC5yb3VuZChtcy9tKStcIm1cIjtpZihtcz49cylyZXR1cm4gTWF0aC5yb3VuZChtcy9zKStcInNcIjtyZXR1cm4gbXMrXCJtc1wifWZ1bmN0aW9uIGxvbmcobXMpe3JldHVybiBwbHVyYWwobXMsZCxcImRheVwiKXx8cGx1cmFsKG1zLGgsXCJob3VyXCIpfHxwbHVyYWwobXMsbSxcIm1pbnV0ZVwiKXx8cGx1cmFsKG1zLHMsXCJzZWNvbmRcIil8fG1zK1wiIG1zXCJ9ZnVuY3Rpb24gcGx1cmFsKG1zLG4sbmFtZSl7aWYobXM8bilyZXR1cm47aWYobXM8bioxLjUpcmV0dXJuIE1hdGguZmxvb3IobXMvbikrXCIgXCIrbmFtZTtyZXR1cm4gTWF0aC5jZWlsKG1zL24pK1wiIFwiK25hbWUrXCJzXCJ9fSx7fV0sMjU6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBrZXlzPV9kZXJlcV8oXCIuL2tleXNcIik7dmFyIGhhc0JpbmFyeT1fZGVyZXFfKFwiaGFzLWJpbmFyeVwiKTt2YXIgc2xpY2VCdWZmZXI9X2RlcmVxXyhcImFycmF5YnVmZmVyLnNsaWNlXCIpO3ZhciBiYXNlNjRlbmNvZGVyPV9kZXJlcV8oXCJiYXNlNjQtYXJyYXlidWZmZXJcIik7dmFyIGFmdGVyPV9kZXJlcV8oXCJhZnRlclwiKTt2YXIgdXRmOD1fZGVyZXFfKFwidXRmOFwiKTt2YXIgaXNBbmRyb2lkPW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7dmFyIGlzUGhhbnRvbUpTPS9QaGFudG9tSlMvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO3ZhciBkb250U2VuZEJsb2JzPWlzQW5kcm9pZHx8aXNQaGFudG9tSlM7ZXhwb3J0cy5wcm90b2NvbD0zO3ZhciBwYWNrZXRzPWV4cG9ydHMucGFja2V0cz17b3BlbjowLGNsb3NlOjEscGluZzoyLHBvbmc6MyxtZXNzYWdlOjQsdXBncmFkZTo1LG5vb3A6Nn07dmFyIHBhY2tldHNsaXN0PWtleXMocGFja2V0cyk7dmFyIGVycj17dHlwZTpcImVycm9yXCIsZGF0YTpcInBhcnNlciBlcnJvclwifTt2YXIgQmxvYj1fZGVyZXFfKFwiYmxvYlwiKTtleHBvcnRzLmVuY29kZVBhY2tldD1mdW5jdGlvbihwYWNrZXQsc3VwcG9ydHNCaW5hcnksdXRmOGVuY29kZSxjYWxsYmFjayl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygc3VwcG9ydHNCaW5hcnkpe2NhbGxiYWNrPXN1cHBvcnRzQmluYXJ5O3N1cHBvcnRzQmluYXJ5PWZhbHNlfWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHV0ZjhlbmNvZGUpe2NhbGxiYWNrPXV0ZjhlbmNvZGU7dXRmOGVuY29kZT1udWxsfXZhciBkYXRhPXBhY2tldC5kYXRhPT09dW5kZWZpbmVkP3VuZGVmaW5lZDpwYWNrZXQuZGF0YS5idWZmZXJ8fHBhY2tldC5kYXRhO2lmKGdsb2JhbC5BcnJheUJ1ZmZlciYmZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXtyZXR1cm4gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LHN1cHBvcnRzQmluYXJ5LGNhbGxiYWNrKX1lbHNlIGlmKEJsb2ImJmRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYil7cmV0dXJuIGVuY29kZUJsb2IocGFja2V0LHN1cHBvcnRzQmluYXJ5LGNhbGxiYWNrKX1pZihkYXRhJiZkYXRhLmJhc2U2NCl7cmV0dXJuIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsY2FsbGJhY2spfXZhciBlbmNvZGVkPXBhY2tldHNbcGFja2V0LnR5cGVdO2lmKHVuZGVmaW5lZCE9PXBhY2tldC5kYXRhKXtlbmNvZGVkKz11dGY4ZW5jb2RlP3V0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpOlN0cmluZyhwYWNrZXQuZGF0YSl9cmV0dXJuIGNhbGxiYWNrKFwiXCIrZW5jb2RlZCl9O2Z1bmN0aW9uIGVuY29kZUJhc2U2NE9iamVjdChwYWNrZXQsY2FsbGJhY2spe3ZhciBtZXNzYWdlPVwiYlwiK2V4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV0rcGFja2V0LmRhdGEuZGF0YTtyZXR1cm4gY2FsbGJhY2sobWVzc2FnZSl9ZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LHN1cHBvcnRzQmluYXJ5LGNhbGxiYWNrKXtpZighc3VwcG9ydHNCaW5hcnkpe3JldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsY2FsbGJhY2spfXZhciBkYXRhPXBhY2tldC5kYXRhO3ZhciBjb250ZW50QXJyYXk9bmV3IFVpbnQ4QXJyYXkoZGF0YSk7dmFyIHJlc3VsdEJ1ZmZlcj1uZXcgVWludDhBcnJheSgxK2RhdGEuYnl0ZUxlbmd0aCk7cmVzdWx0QnVmZmVyWzBdPXBhY2tldHNbcGFja2V0LnR5cGVdO2Zvcih2YXIgaT0wO2k8Y29udGVudEFycmF5Lmxlbmd0aDtpKyspe3Jlc3VsdEJ1ZmZlcltpKzFdPWNvbnRlbnRBcnJheVtpXX1yZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcil9ZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LHN1cHBvcnRzQmluYXJ5LGNhbGxiYWNrKXtpZighc3VwcG9ydHNCaW5hcnkpe3JldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsY2FsbGJhY2spfXZhciBmcj1uZXcgRmlsZVJlYWRlcjtmci5vbmxvYWQ9ZnVuY3Rpb24oKXtwYWNrZXQuZGF0YT1mci5yZXN1bHQ7ZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LHN1cHBvcnRzQmluYXJ5LHRydWUsY2FsbGJhY2spfTtyZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpfWZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LHN1cHBvcnRzQmluYXJ5LGNhbGxiYWNrKXtpZighc3VwcG9ydHNCaW5hcnkpe3JldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsY2FsbGJhY2spfWlmKGRvbnRTZW5kQmxvYnMpe3JldHVybiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsc3VwcG9ydHNCaW5hcnksY2FsbGJhY2spfXZhciBsZW5ndGg9bmV3IFVpbnQ4QXJyYXkoMSk7bGVuZ3RoWzBdPXBhY2tldHNbcGFja2V0LnR5cGVdO3ZhciBibG9iPW5ldyBCbG9iKFtsZW5ndGguYnVmZmVyLHBhY2tldC5kYXRhXSk7cmV0dXJuIGNhbGxiYWNrKGJsb2IpfWV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0PWZ1bmN0aW9uKHBhY2tldCxjYWxsYmFjayl7dmFyIG1lc3NhZ2U9XCJiXCIrZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtpZihCbG9iJiZwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEJsb2Ipe3ZhciBmcj1uZXcgRmlsZVJlYWRlcjtmci5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgYjY0PWZyLnJlc3VsdC5zcGxpdChcIixcIilbMV07Y2FsbGJhY2sobWVzc2FnZStiNjQpfTtyZXR1cm4gZnIucmVhZEFzRGF0YVVSTChwYWNrZXQuZGF0YSl9dmFyIGI2NGRhdGE7dHJ5e2I2NGRhdGE9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSl9Y2F0Y2goZSl7dmFyIHR5cGVkPW5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTt2YXIgYmFzaWM9bmV3IEFycmF5KHR5cGVkLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTx0eXBlZC5sZW5ndGg7aSsrKXtiYXNpY1tpXT10eXBlZFtpXX1iNjRkYXRhPVN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCxiYXNpYyl9bWVzc2FnZSs9Z2xvYmFsLmJ0b2EoYjY0ZGF0YSk7cmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpfTtleHBvcnRzLmRlY29kZVBhY2tldD1mdW5jdGlvbihkYXRhLGJpbmFyeVR5cGUsdXRmOGRlY29kZSl7aWYodHlwZW9mIGRhdGE9PVwic3RyaW5nXCJ8fGRhdGE9PT11bmRlZmluZWQpe2lmKGRhdGEuY2hhckF0KDApPT1cImJcIil7cmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLGJpbmFyeVR5cGUpfWlmKHV0ZjhkZWNvZGUpe3RyeXtkYXRhPXV0ZjguZGVjb2RlKGRhdGEpfWNhdGNoKGUpe3JldHVybiBlcnJ9fXZhciB0eXBlPWRhdGEuY2hhckF0KDApO2lmKE51bWJlcih0eXBlKSE9dHlwZXx8IXBhY2tldHNsaXN0W3R5cGVdKXtyZXR1cm4gZXJyfWlmKGRhdGEubGVuZ3RoPjEpe3JldHVybnt0eXBlOnBhY2tldHNsaXN0W3R5cGVdLGRhdGE6ZGF0YS5zdWJzdHJpbmcoMSl9fWVsc2V7cmV0dXJue3R5cGU6cGFja2V0c2xpc3RbdHlwZV19fX12YXIgYXNBcnJheT1uZXcgVWludDhBcnJheShkYXRhKTt2YXIgdHlwZT1hc0FycmF5WzBdO3ZhciByZXN0PXNsaWNlQnVmZmVyKGRhdGEsMSk7aWYoQmxvYiYmYmluYXJ5VHlwZT09PVwiYmxvYlwiKXtyZXN0PW5ldyBCbG9iKFtyZXN0XSl9cmV0dXJue3R5cGU6cGFja2V0c2xpc3RbdHlwZV0sZGF0YTpyZXN0fX07ZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQ9ZnVuY3Rpb24obXNnLGJpbmFyeVR5cGUpe3ZhciB0eXBlPXBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO2lmKCFnbG9iYWwuQXJyYXlCdWZmZXIpe3JldHVybnt0eXBlOnR5cGUsZGF0YTp7YmFzZTY0OnRydWUsZGF0YTptc2cuc3Vic3RyKDEpfX19dmFyIGRhdGE9YmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7aWYoYmluYXJ5VHlwZT09PVwiYmxvYlwiJiZCbG9iKXtkYXRhPW5ldyBCbG9iKFtkYXRhXSl9cmV0dXJue3R5cGU6dHlwZSxkYXRhOmRhdGF9fTtleHBvcnRzLmVuY29kZVBheWxvYWQ9ZnVuY3Rpb24ocGFja2V0cyxzdXBwb3J0c0JpbmFyeSxjYWxsYmFjayl7aWYodHlwZW9mIHN1cHBvcnRzQmluYXJ5PT1cImZ1bmN0aW9uXCIpe2NhbGxiYWNrPXN1cHBvcnRzQmluYXJ5O3N1cHBvcnRzQmluYXJ5PW51bGx9dmFyIGlzQmluYXJ5PWhhc0JpbmFyeShwYWNrZXRzKTtpZihzdXBwb3J0c0JpbmFyeSYmaXNCaW5hcnkpe2lmKEJsb2ImJiFkb250U2VuZEJsb2JzKXtyZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsY2FsbGJhY2spfXJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsY2FsbGJhY2spfWlmKCFwYWNrZXRzLmxlbmd0aCl7cmV0dXJuIGNhbGxiYWNrKFwiMDpcIil9ZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2Upe3JldHVybiBtZXNzYWdlLmxlbmd0aCtcIjpcIittZXNzYWdlfWZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsZG9uZUNhbGxiYWNrKXtleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIWlzQmluYXJ5P2ZhbHNlOnN1cHBvcnRzQmluYXJ5LHRydWUsZnVuY3Rpb24obWVzc2FnZSl7ZG9uZUNhbGxiYWNrKG51bGwsc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKX0pfW1hcChwYWNrZXRzLGVuY29kZU9uZSxmdW5jdGlvbihlcnIscmVzdWx0cyl7cmV0dXJuIGNhbGxiYWNrKHJlc3VsdHMuam9pbihcIlwiKSl9KX07ZnVuY3Rpb24gbWFwKGFyeSxlYWNoLGRvbmUpe3ZhciByZXN1bHQ9bmV3IEFycmF5KGFyeS5sZW5ndGgpO3ZhciBuZXh0PWFmdGVyKGFyeS5sZW5ndGgsZG9uZSk7dmFyIGVhY2hXaXRoSW5kZXg9ZnVuY3Rpb24oaSxlbCxjYil7ZWFjaChlbCxmdW5jdGlvbihlcnJvcixtc2cpe3Jlc3VsdFtpXT1tc2c7Y2IoZXJyb3IscmVzdWx0KX0pfTtmb3IodmFyIGk9MDtpPGFyeS5sZW5ndGg7aSsrKXtlYWNoV2l0aEluZGV4KGksYXJ5W2ldLG5leHQpfX1leHBvcnRzLmRlY29kZVBheWxvYWQ9ZnVuY3Rpb24oZGF0YSxiaW5hcnlUeXBlLGNhbGxiYWNrKXtpZih0eXBlb2YgZGF0YSE9XCJzdHJpbmdcIil7cmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsYmluYXJ5VHlwZSxjYWxsYmFjayl9aWYodHlwZW9mIGJpbmFyeVR5cGU9PT1cImZ1bmN0aW9uXCIpe2NhbGxiYWNrPWJpbmFyeVR5cGU7YmluYXJ5VHlwZT1udWxsfXZhciBwYWNrZXQ7aWYoZGF0YT09XCJcIil7cmV0dXJuIGNhbGxiYWNrKGVyciwwLDEpfXZhciBsZW5ndGg9XCJcIixuLG1zZztmb3IodmFyIGk9MCxsPWRhdGEubGVuZ3RoO2k8bDtpKyspe3ZhciBjaHI9ZGF0YS5jaGFyQXQoaSk7aWYoXCI6XCIhPWNocil7bGVuZ3RoKz1jaHJ9ZWxzZXtpZihcIlwiPT1sZW5ndGh8fGxlbmd0aCE9KG49TnVtYmVyKGxlbmd0aCkpKXtyZXR1cm4gY2FsbGJhY2soZXJyLDAsMSl9bXNnPWRhdGEuc3Vic3RyKGkrMSxuKTtpZihsZW5ndGghPW1zZy5sZW5ndGgpe3JldHVybiBjYWxsYmFjayhlcnIsMCwxKX1pZihtc2cubGVuZ3RoKXtwYWNrZXQ9ZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLGJpbmFyeVR5cGUsdHJ1ZSk7aWYoZXJyLnR5cGU9PXBhY2tldC50eXBlJiZlcnIuZGF0YT09cGFja2V0LmRhdGEpe3JldHVybiBjYWxsYmFjayhlcnIsMCwxKX12YXIgcmV0PWNhbGxiYWNrKHBhY2tldCxpK24sbCk7aWYoZmFsc2U9PT1yZXQpcmV0dXJufWkrPW47bGVuZ3RoPVwiXCJ9fWlmKGxlbmd0aCE9XCJcIil7cmV0dXJuIGNhbGxiYWNrKGVyciwwLDEpfX07ZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcj1mdW5jdGlvbihwYWNrZXRzLGNhbGxiYWNrKXtpZighcGFja2V0cy5sZW5ndGgpe3JldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpfWZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsZG9uZUNhbGxiYWNrKXtleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsdHJ1ZSx0cnVlLGZ1bmN0aW9uKGRhdGEpe3JldHVybiBkb25lQ2FsbGJhY2sobnVsbCxkYXRhKX0pfW1hcChwYWNrZXRzLGVuY29kZU9uZSxmdW5jdGlvbihlcnIsZW5jb2RlZFBhY2tldHMpe3ZhciB0b3RhbExlbmd0aD1lbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLHApe3ZhciBsZW47aWYodHlwZW9mIHA9PT1cInN0cmluZ1wiKXtsZW49cC5sZW5ndGh9ZWxzZXtsZW49cC5ieXRlTGVuZ3RofXJldHVybiBhY2MrbGVuLnRvU3RyaW5nKCkubGVuZ3RoK2xlbisyfSwwKTt2YXIgcmVzdWx0QXJyYXk9bmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO3ZhciBidWZmZXJJbmRleD0wO2VuY29kZWRQYWNrZXRzLmZvckVhY2goZnVuY3Rpb24ocCl7dmFyIGlzU3RyaW5nPXR5cGVvZiBwPT09XCJzdHJpbmdcIjt2YXIgYWI9cDtpZihpc1N0cmluZyl7dmFyIHZpZXc9bmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO2Zvcih2YXIgaT0wO2k8cC5sZW5ndGg7aSsrKXt2aWV3W2ldPXAuY2hhckNvZGVBdChpKX1hYj12aWV3LmJ1ZmZlcn1pZihpc1N0cmluZyl7cmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK109MH1lbHNle3Jlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdPTF9dmFyIGxlblN0cj1hYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7Zm9yKHZhciBpPTA7aTxsZW5TdHIubGVuZ3RoO2krKyl7cmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK109cGFyc2VJbnQobGVuU3RyW2ldKX1yZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXT0yNTU7dmFyIHZpZXc9bmV3IFVpbnQ4QXJyYXkoYWIpO2Zvcih2YXIgaT0wO2k8dmlldy5sZW5ndGg7aSsrKXtyZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXT12aWV3W2ldfX0pO3JldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpfSl9O2V4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYj1mdW5jdGlvbihwYWNrZXRzLGNhbGxiYWNrKXtmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LGRvbmVDYWxsYmFjayl7ZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LHRydWUsdHJ1ZSxmdW5jdGlvbihlbmNvZGVkKXt2YXIgYmluYXJ5SWRlbnRpZmllcj1uZXcgVWludDhBcnJheSgxKTtiaW5hcnlJZGVudGlmaWVyWzBdPTE7aWYodHlwZW9mIGVuY29kZWQ9PT1cInN0cmluZ1wiKXt2YXIgdmlldz1uZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxlbmNvZGVkLmxlbmd0aDtpKyspe3ZpZXdbaV09ZW5jb2RlZC5jaGFyQ29kZUF0KGkpfWVuY29kZWQ9dmlldy5idWZmZXI7YmluYXJ5SWRlbnRpZmllclswXT0wfXZhciBsZW49ZW5jb2RlZCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP2VuY29kZWQuYnl0ZUxlbmd0aDplbmNvZGVkLnNpemU7dmFyIGxlblN0cj1sZW4udG9TdHJpbmcoKTt2YXIgbGVuZ3RoQXJ5PW5ldyBVaW50OEFycmF5KGxlblN0ci5sZW5ndGgrMSk7Zm9yKHZhciBpPTA7aTxsZW5TdHIubGVuZ3RoO2krKyl7bGVuZ3RoQXJ5W2ldPXBhcnNlSW50KGxlblN0cltpXSl9bGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdPTI1NTtpZihCbG9iKXt2YXIgYmxvYj1uZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsbGVuZ3RoQXJ5LmJ1ZmZlcixlbmNvZGVkXSk7ZG9uZUNhbGxiYWNrKG51bGwsYmxvYil9fSl9bWFwKHBhY2tldHMsZW5jb2RlT25lLGZ1bmN0aW9uKGVycixyZXN1bHRzKXtyZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpfSl9O2V4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5PWZ1bmN0aW9uKGRhdGEsYmluYXJ5VHlwZSxjYWxsYmFjayl7aWYodHlwZW9mIGJpbmFyeVR5cGU9PT1cImZ1bmN0aW9uXCIpe2NhbGxiYWNrPWJpbmFyeVR5cGU7YmluYXJ5VHlwZT1udWxsfXZhciBidWZmZXJUYWlsPWRhdGE7dmFyIGJ1ZmZlcnM9W107dmFyIG51bWJlclRvb0xvbmc9ZmFsc2U7d2hpbGUoYnVmZmVyVGFpbC5ieXRlTGVuZ3RoPjApe3ZhciB0YWlsQXJyYXk9bmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7dmFyIGlzU3RyaW5nPXRhaWxBcnJheVswXT09PTA7dmFyIG1zZ0xlbmd0aD1cIlwiO2Zvcih2YXIgaT0xOztpKyspe2lmKHRhaWxBcnJheVtpXT09MjU1KWJyZWFrO2lmKG1zZ0xlbmd0aC5sZW5ndGg+MzEwKXtudW1iZXJUb29Mb25nPXRydWU7YnJlYWt9bXNnTGVuZ3RoKz10YWlsQXJyYXlbaV19aWYobnVtYmVyVG9vTG9uZylyZXR1cm4gY2FsbGJhY2soZXJyLDAsMSk7YnVmZmVyVGFpbD1zbGljZUJ1ZmZlcihidWZmZXJUYWlsLDIrbXNnTGVuZ3RoLmxlbmd0aCk7bXNnTGVuZ3RoPXBhcnNlSW50KG1zZ0xlbmd0aCk7dmFyIG1zZz1zbGljZUJ1ZmZlcihidWZmZXJUYWlsLDAsbXNnTGVuZ3RoKTtpZihpc1N0cmluZyl7dHJ5e21zZz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsbmV3IFVpbnQ4QXJyYXkobXNnKSl9Y2F0Y2goZSl7dmFyIHR5cGVkPW5ldyBVaW50OEFycmF5KG1zZyk7bXNnPVwiXCI7Zm9yKHZhciBpPTA7aTx0eXBlZC5sZW5ndGg7aSsrKXttc2crPVN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pfX19YnVmZmVycy5wdXNoKG1zZyk7YnVmZmVyVGFpbD1zbGljZUJ1ZmZlcihidWZmZXJUYWlsLG1zZ0xlbmd0aCl9dmFyIHRvdGFsPWJ1ZmZlcnMubGVuZ3RoO2J1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsaSl7Y2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLGJpbmFyeVR5cGUsdHJ1ZSksaSx0b3RhbCl9KX19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se1wiLi9rZXlzXCI6MjYsYWZ0ZXI6MjcsXCJhcnJheWJ1ZmZlci5zbGljZVwiOjI4LFwiYmFzZTY0LWFycmF5YnVmZmVyXCI6MjksYmxvYjozMCxcImhhcy1iaW5hcnlcIjozMSx1dGY4OjMzfV0sMjY6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPU9iamVjdC5rZXlzfHxmdW5jdGlvbiBrZXlzKG9iail7dmFyIGFycj1bXTt2YXIgaGFzPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7Zm9yKHZhciBpIGluIG9iail7aWYoaGFzLmNhbGwob2JqLGkpKXthcnIucHVzaChpKX19cmV0dXJuIGFycn19LHt9XSwyNzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9YWZ0ZXI7ZnVuY3Rpb24gYWZ0ZXIoY291bnQsY2FsbGJhY2ssZXJyX2NiKXt2YXIgYmFpbD1mYWxzZTtlcnJfY2I9ZXJyX2NifHxub29wO3Byb3h5LmNvdW50PWNvdW50O3JldHVybiBjb3VudD09PTA/Y2FsbGJhY2soKTpwcm94eTtmdW5jdGlvbiBwcm94eShlcnIscmVzdWx0KXtpZihwcm94eS5jb3VudDw9MCl7dGhyb3cgbmV3IEVycm9yKFwiYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzXCIpfS0tcHJveHkuY291bnQ7aWYoZXJyKXtiYWlsPXRydWU7Y2FsbGJhY2soZXJyKTtjYWxsYmFjaz1lcnJfY2J9ZWxzZSBpZihwcm94eS5jb3VudD09PTAmJiFiYWlsKXtjYWxsYmFjayhudWxsLHJlc3VsdCl9fX1mdW5jdGlvbiBub29wKCl7fX0se31dLDI4OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbihhcnJheWJ1ZmZlcixzdGFydCxlbmQpe3ZhciBieXRlcz1hcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO3N0YXJ0PXN0YXJ0fHwwO2VuZD1lbmR8fGJ5dGVzO2lmKGFycmF5YnVmZmVyLnNsaWNlKXtyZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsZW5kKX1pZihzdGFydDwwKXtzdGFydCs9Ynl0ZXN9aWYoZW5kPDApe2VuZCs9Ynl0ZXN9aWYoZW5kPmJ5dGVzKXtlbmQ9Ynl0ZXN9aWYoc3RhcnQ+PWJ5dGVzfHxzdGFydD49ZW5kfHxieXRlcz09PTApe3JldHVybiBuZXcgQXJyYXlCdWZmZXIoMCl9dmFyIGFidj1uZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7dmFyIHJlc3VsdD1uZXcgVWludDhBcnJheShlbmQtc3RhcnQpO2Zvcih2YXIgaT1zdGFydCxpaT0wO2k8ZW5kO2krKyxpaSsrKXtyZXN1bHRbaWldPWFidltpXX1yZXR1cm4gcmVzdWx0LmJ1ZmZlcn19LHt9XSwyOTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGNoYXJzKXtcInVzZSBzdHJpY3RcIjtleHBvcnRzLmVuY29kZT1mdW5jdGlvbihhcnJheWJ1ZmZlcil7dmFyIGJ5dGVzPW5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxpLGxlbj1ieXRlcy5sZW5ndGgsYmFzZTY0PVwiXCI7Zm9yKGk9MDtpPGxlbjtpKz0zKXtiYXNlNjQrPWNoYXJzW2J5dGVzW2ldPj4yXTtiYXNlNjQrPWNoYXJzWyhieXRlc1tpXSYzKTw8NHxieXRlc1tpKzFdPj40XTtiYXNlNjQrPWNoYXJzWyhieXRlc1tpKzFdJjE1KTw8MnxieXRlc1tpKzJdPj42XTtiYXNlNjQrPWNoYXJzW2J5dGVzW2krMl0mNjNdfWlmKGxlbiUzPT09Mil7YmFzZTY0PWJhc2U2NC5zdWJzdHJpbmcoMCxiYXNlNjQubGVuZ3RoLTEpK1wiPVwifWVsc2UgaWYobGVuJTM9PT0xKXtiYXNlNjQ9YmFzZTY0LnN1YnN0cmluZygwLGJhc2U2NC5sZW5ndGgtMikrXCI9PVwifXJldHVybiBiYXNlNjR9O2V4cG9ydHMuZGVjb2RlPWZ1bmN0aW9uKGJhc2U2NCl7dmFyIGJ1ZmZlckxlbmd0aD1iYXNlNjQubGVuZ3RoKi43NSxsZW49YmFzZTY0Lmxlbmd0aCxpLHA9MCxlbmNvZGVkMSxlbmNvZGVkMixlbmNvZGVkMyxlbmNvZGVkNDtpZihiYXNlNjRbYmFzZTY0Lmxlbmd0aC0xXT09PVwiPVwiKXtidWZmZXJMZW5ndGgtLTtpZihiYXNlNjRbYmFzZTY0Lmxlbmd0aC0yXT09PVwiPVwiKXtidWZmZXJMZW5ndGgtLX19dmFyIGFycmF5YnVmZmVyPW5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLGJ5dGVzPW5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtmb3IoaT0wO2k8bGVuO2krPTQpe2VuY29kZWQxPWNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtlbmNvZGVkMj1jaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtlbmNvZGVkMz1jaGFycy5pbmRleE9mKGJhc2U2NFtpKzJdKTtlbmNvZGVkND1jaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtieXRlc1twKytdPWVuY29kZWQxPDwyfGVuY29kZWQyPj40O2J5dGVzW3ArK109KGVuY29kZWQyJjE1KTw8NHxlbmNvZGVkMz4+MjtieXRlc1twKytdPShlbmNvZGVkMyYzKTw8NnxlbmNvZGVkNCY2M31yZXR1cm4gYXJyYXlidWZmZXJ9fSkoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIpfSx7fV0sMzA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBCbG9iQnVpbGRlcj1nbG9iYWwuQmxvYkJ1aWxkZXJ8fGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlcnx8Z2xvYmFsLk1TQmxvYkJ1aWxkZXJ8fGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjt2YXIgYmxvYlN1cHBvcnRlZD1mdW5jdGlvbigpe3RyeXt2YXIgYj1uZXcgQmxvYihbXCJoaVwiXSk7cmV0dXJuIGIuc2l6ZT09Mn1jYXRjaChlKXtyZXR1cm4gZmFsc2V9fSgpO3ZhciBibG9iQnVpbGRlclN1cHBvcnRlZD1CbG9iQnVpbGRlciYmQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZCYmQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7ZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3Rvcihhcnksb3B0aW9ucyl7b3B0aW9ucz1vcHRpb25zfHx7fTt2YXIgYmI9bmV3IEJsb2JCdWlsZGVyO2Zvcih2YXIgaT0wO2k8YXJ5Lmxlbmd0aDtpKyspe2JiLmFwcGVuZChhcnlbaV0pfXJldHVybiBvcHRpb25zLnR5cGU/YmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpOmJiLmdldEJsb2IoKX1tb2R1bGUuZXhwb3J0cz1mdW5jdGlvbigpe2lmKGJsb2JTdXBwb3J0ZWQpe3JldHVybiBnbG9iYWwuQmxvYn1lbHNlIGlmKGJsb2JCdWlsZGVyU3VwcG9ydGVkKXtyZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3Rvcn1lbHNle3JldHVybiB1bmRlZmluZWR9fSgpfSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHt9XSwzMTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIGlzQXJyYXk9X2RlcmVxXyhcImlzYXJyYXlcIik7bW9kdWxlLmV4cG9ydHM9aGFzQmluYXJ5O2Z1bmN0aW9uIGhhc0JpbmFyeShkYXRhKXtmdW5jdGlvbiBfaGFzQmluYXJ5KG9iail7aWYoIW9iailyZXR1cm4gZmFsc2U7aWYoZ2xvYmFsLkJ1ZmZlciYmZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopfHxnbG9iYWwuQXJyYXlCdWZmZXImJm9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxnbG9iYWwuQmxvYiYmb2JqIGluc3RhbmNlb2YgQmxvYnx8Z2xvYmFsLkZpbGUmJm9iaiBpbnN0YW5jZW9mIEZpbGUpe3JldHVybiB0cnVlfWlmKGlzQXJyYXkob2JqKSl7Zm9yKHZhciBpPTA7aTxvYmoubGVuZ3RoO2krKyl7aWYoX2hhc0JpbmFyeShvYmpbaV0pKXtyZXR1cm4gdHJ1ZX19fWVsc2UgaWYob2JqJiZcIm9iamVjdFwiPT10eXBlb2Ygb2JqKXtpZihvYmoudG9KU09OKXtvYmo9b2JqLnRvSlNPTigpfWZvcih2YXIga2V5IGluIG9iail7aWYob2JqLmhhc093blByb3BlcnR5KGtleSkmJl9oYXNCaW5hcnkob2JqW2tleV0pKXtyZXR1cm4gdHJ1ZX19fXJldHVybiBmYWxzZX1yZXR1cm4gX2hhc0JpbmFyeShkYXRhKX19KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYhPT1cInVuZGVmaW5lZFwiP3NlbGY6dHlwZW9mIHdpbmRvdyE9PVwidW5kZWZpbmVkXCI/d2luZG93Ont9KX0se2lzYXJyYXk6MzJ9XSwzMjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24oYXJyKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycik9PVwiW29iamVjdCBBcnJheV1cIn19LHt9XSwzMzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7KGZ1bmN0aW9uKHJvb3Qpe3ZhciBmcmVlRXhwb3J0cz10eXBlb2YgZXhwb3J0cz09XCJvYmplY3RcIiYmZXhwb3J0czt2YXIgZnJlZU1vZHVsZT10eXBlb2YgbW9kdWxlPT1cIm9iamVjdFwiJiZtb2R1bGUmJm1vZHVsZS5leHBvcnRzPT1mcmVlRXhwb3J0cyYmbW9kdWxlO3ZhciBmcmVlR2xvYmFsPXR5cGVvZiBnbG9iYWw9PVwib2JqZWN0XCImJmdsb2JhbDtpZihmcmVlR2xvYmFsLmdsb2JhbD09PWZyZWVHbG9iYWx8fGZyZWVHbG9iYWwud2luZG93PT09ZnJlZUdsb2JhbCl7cm9vdD1mcmVlR2xvYmFsfXZhciBzdHJpbmdGcm9tQ2hhckNvZGU9U3RyaW5nLmZyb21DaGFyQ29kZTtmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZyl7dmFyIG91dHB1dD1bXTt2YXIgY291bnRlcj0wO3ZhciBsZW5ndGg9c3RyaW5nLmxlbmd0aDt2YXIgdmFsdWU7dmFyIGV4dHJhO3doaWxlKGNvdW50ZXI8bGVuZ3RoKXt2YWx1ZT1zdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO2lmKHZhbHVlPj01NTI5NiYmdmFsdWU8PTU2MzE5JiZjb3VudGVyPGxlbmd0aCl7ZXh0cmE9c3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtpZigoZXh0cmEmNjQ1MTIpPT01NjMyMCl7b3V0cHV0LnB1c2goKCh2YWx1ZSYxMDIzKTw8MTApKyhleHRyYSYxMDIzKSs2NTUzNil9ZWxzZXtvdXRwdXQucHVzaCh2YWx1ZSk7Y291bnRlci0tfX1lbHNle291dHB1dC5wdXNoKHZhbHVlKX19cmV0dXJuIG91dHB1dH1mdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KXt2YXIgbGVuZ3RoPWFycmF5Lmxlbmd0aDt2YXIgaW5kZXg9LTE7dmFyIHZhbHVlO3ZhciBvdXRwdXQ9XCJcIjt3aGlsZSgrK2luZGV4PGxlbmd0aCl7dmFsdWU9YXJyYXlbaW5kZXhdO2lmKHZhbHVlPjY1NTM1KXt2YWx1ZS09NjU1MzY7XG5vdXRwdXQrPXN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZT4+PjEwJjEwMjN8NTUyOTYpO3ZhbHVlPTU2MzIwfHZhbHVlJjEwMjN9b3V0cHV0Kz1zdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpfXJldHVybiBvdXRwdXR9ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsc2hpZnQpe3JldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50Pj5zaGlmdCY2M3wxMjgpfWZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpe2lmKChjb2RlUG9pbnQmNDI5NDk2NzE2OCk9PTApe3JldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KX12YXIgc3ltYm9sPVwiXCI7aWYoKGNvZGVQb2ludCY0Mjk0OTY1MjQ4KT09MCl7c3ltYm9sPXN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQ+PjYmMzF8MTkyKX1lbHNlIGlmKChjb2RlUG9pbnQmNDI5NDkwMTc2MCk9PTApe3N5bWJvbD1zdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50Pj4xMiYxNXwyMjQpO3N5bWJvbCs9Y3JlYXRlQnl0ZShjb2RlUG9pbnQsNil9ZWxzZSBpZigoY29kZVBvaW50JjQyOTI4NzAxNDQpPT0wKXtzeW1ib2w9c3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludD4+MTgmN3wyNDApO3N5bWJvbCs9Y3JlYXRlQnl0ZShjb2RlUG9pbnQsMTIpO3N5bWJvbCs9Y3JlYXRlQnl0ZShjb2RlUG9pbnQsNil9c3ltYm9sKz1zdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50JjYzfDEyOCk7cmV0dXJuIHN5bWJvbH1mdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZyl7dmFyIGNvZGVQb2ludHM9dWNzMmRlY29kZShzdHJpbmcpO3ZhciBsZW5ndGg9Y29kZVBvaW50cy5sZW5ndGg7dmFyIGluZGV4PS0xO3ZhciBjb2RlUG9pbnQ7dmFyIGJ5dGVTdHJpbmc9XCJcIjt3aGlsZSgrK2luZGV4PGxlbmd0aCl7Y29kZVBvaW50PWNvZGVQb2ludHNbaW5kZXhdO2J5dGVTdHJpbmcrPWVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpfXJldHVybiBieXRlU3RyaW5nfWZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCl7aWYoYnl0ZUluZGV4Pj1ieXRlQ291bnQpe3Rocm93IEVycm9yKFwiSW52YWxpZCBieXRlIGluZGV4XCIpfXZhciBjb250aW51YXRpb25CeXRlPWJ5dGVBcnJheVtieXRlSW5kZXhdJjI1NTtieXRlSW5kZXgrKztpZigoY29udGludWF0aW9uQnl0ZSYxOTIpPT0xMjgpe3JldHVybiBjb250aW51YXRpb25CeXRlJjYzfXRocm93IEVycm9yKFwiSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVwiKX1mdW5jdGlvbiBkZWNvZGVTeW1ib2woKXt2YXIgYnl0ZTE7dmFyIGJ5dGUyO3ZhciBieXRlMzt2YXIgYnl0ZTQ7dmFyIGNvZGVQb2ludDtpZihieXRlSW5kZXg+Ynl0ZUNvdW50KXt0aHJvdyBFcnJvcihcIkludmFsaWQgYnl0ZSBpbmRleFwiKX1pZihieXRlSW5kZXg9PWJ5dGVDb3VudCl7cmV0dXJuIGZhbHNlfWJ5dGUxPWJ5dGVBcnJheVtieXRlSW5kZXhdJjI1NTtieXRlSW5kZXgrKztpZigoYnl0ZTEmMTI4KT09MCl7cmV0dXJuIGJ5dGUxfWlmKChieXRlMSYyMjQpPT0xOTIpe3ZhciBieXRlMj1yZWFkQ29udGludWF0aW9uQnl0ZSgpO2NvZGVQb2ludD0oYnl0ZTEmMzEpPDw2fGJ5dGUyO2lmKGNvZGVQb2ludD49MTI4KXtyZXR1cm4gY29kZVBvaW50fWVsc2V7dGhyb3cgRXJyb3IoXCJJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXCIpfX1pZigoYnl0ZTEmMjQwKT09MjI0KXtieXRlMj1yZWFkQ29udGludWF0aW9uQnl0ZSgpO2J5dGUzPXJlYWRDb250aW51YXRpb25CeXRlKCk7Y29kZVBvaW50PShieXRlMSYxNSk8PDEyfGJ5dGUyPDw2fGJ5dGUzO2lmKGNvZGVQb2ludD49MjA0OCl7cmV0dXJuIGNvZGVQb2ludH1lbHNle3Rocm93IEVycm9yKFwiSW52YWxpZCBjb250aW51YXRpb24gYnl0ZVwiKX19aWYoKGJ5dGUxJjI0OCk9PTI0MCl7Ynl0ZTI9cmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtieXRlMz1yZWFkQ29udGludWF0aW9uQnl0ZSgpO2J5dGU0PXJlYWRDb250aW51YXRpb25CeXRlKCk7Y29kZVBvaW50PShieXRlMSYxNSk8PDE4fGJ5dGUyPDwxMnxieXRlMzw8NnxieXRlNDtpZihjb2RlUG9pbnQ+PTY1NTM2JiZjb2RlUG9pbnQ8PTExMTQxMTEpe3JldHVybiBjb2RlUG9pbnR9fXRocm93IEVycm9yKFwiSW52YWxpZCBVVEYtOCBkZXRlY3RlZFwiKX12YXIgYnl0ZUFycmF5O3ZhciBieXRlQ291bnQ7dmFyIGJ5dGVJbmRleDtmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpe2J5dGVBcnJheT11Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO2J5dGVDb3VudD1ieXRlQXJyYXkubGVuZ3RoO2J5dGVJbmRleD0wO3ZhciBjb2RlUG9pbnRzPVtdO3ZhciB0bXA7d2hpbGUoKHRtcD1kZWNvZGVTeW1ib2woKSkhPT1mYWxzZSl7Y29kZVBvaW50cy5wdXNoKHRtcCl9cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyl9dmFyIHV0Zjg9e3ZlcnNpb246XCIyLjAuMFwiLGVuY29kZTp1dGY4ZW5jb2RlLGRlY29kZTp1dGY4ZGVjb2RlfTtpZih0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJnR5cGVvZiBkZWZpbmUuYW1kPT1cIm9iamVjdFwiJiZkZWZpbmUuYW1kKXtkZWZpbmUoZnVuY3Rpb24oKXtyZXR1cm4gdXRmOH0pfWVsc2UgaWYoZnJlZUV4cG9ydHMmJiFmcmVlRXhwb3J0cy5ub2RlVHlwZSl7aWYoZnJlZU1vZHVsZSl7ZnJlZU1vZHVsZS5leHBvcnRzPXV0Zjh9ZWxzZXt2YXIgb2JqZWN0PXt9O3ZhciBoYXNPd25Qcm9wZXJ0eT1vYmplY3QuaGFzT3duUHJvcGVydHk7Zm9yKHZhciBrZXkgaW4gdXRmOCl7aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LGtleSkmJihmcmVlRXhwb3J0c1trZXldPXV0Zjhba2V5XSl9fX1lbHNle3Jvb3QudXRmOD11dGY4fX0pKHRoaXMpfSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHt9XSwzNDpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIHJ2YWxpZGNoYXJzPS9eW1xcXSw6e31cXHNdKiQvO3ZhciBydmFsaWRlc2NhcGU9L1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZzt2YXIgcnZhbGlkdG9rZW5zPS9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZzt2YXIgcnZhbGlkYnJhY2VzPS8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZzt2YXIgcnRyaW1MZWZ0PS9eXFxzKy87dmFyIHJ0cmltUmlnaHQ9L1xccyskLzttb2R1bGUuZXhwb3J0cz1mdW5jdGlvbiBwYXJzZWpzb24oZGF0YSl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIGRhdGF8fCFkYXRhKXtyZXR1cm4gbnVsbH1kYXRhPWRhdGEucmVwbGFjZShydHJpbUxlZnQsXCJcIikucmVwbGFjZShydHJpbVJpZ2h0LFwiXCIpO2lmKGdsb2JhbC5KU09OJiZKU09OLnBhcnNlKXtyZXR1cm4gSlNPTi5wYXJzZShkYXRhKX1pZihydmFsaWRjaGFycy50ZXN0KGRhdGEucmVwbGFjZShydmFsaWRlc2NhcGUsXCJAXCIpLnJlcGxhY2UocnZhbGlkdG9rZW5zLFwiXVwiKS5yZXBsYWNlKHJ2YWxpZGJyYWNlcyxcIlwiKSkpe3JldHVybiBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gXCIrZGF0YSkoKX19fSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmIT09XCJ1bmRlZmluZWRcIj9zZWxmOnR5cGVvZiB3aW5kb3chPT1cInVuZGVmaW5lZFwiP3dpbmRvdzp7fSl9LHt9XSwzNTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7ZXhwb3J0cy5lbmNvZGU9ZnVuY3Rpb24ob2JqKXt2YXIgc3RyPVwiXCI7Zm9yKHZhciBpIGluIG9iail7aWYob2JqLmhhc093blByb3BlcnR5KGkpKXtpZihzdHIubGVuZ3RoKXN0cis9XCImXCI7c3RyKz1lbmNvZGVVUklDb21wb25lbnQoaSkrXCI9XCIrZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSl9fXJldHVybiBzdHJ9O2V4cG9ydHMuZGVjb2RlPWZ1bmN0aW9uKHFzKXt2YXIgcXJ5PXt9O3ZhciBwYWlycz1xcy5zcGxpdChcIiZcIik7Zm9yKHZhciBpPTAsbD1wYWlycy5sZW5ndGg7aTxsO2krKyl7dmFyIHBhaXI9cGFpcnNbaV0uc3BsaXQoXCI9XCIpO3FyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldPWRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKX1yZXR1cm4gcXJ5fX0se31dLDM2OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgcmU9L14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87dmFyIHBhcnRzPVtcInNvdXJjZVwiLFwicHJvdG9jb2xcIixcImF1dGhvcml0eVwiLFwidXNlckluZm9cIixcInVzZXJcIixcInBhc3N3b3JkXCIsXCJob3N0XCIsXCJwb3J0XCIsXCJyZWxhdGl2ZVwiLFwicGF0aFwiLFwiZGlyZWN0b3J5XCIsXCJmaWxlXCIsXCJxdWVyeVwiLFwiYW5jaG9yXCJdO21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uIHBhcnNldXJpKHN0cil7dmFyIHNyYz1zdHIsYj1zdHIuaW5kZXhPZihcIltcIiksZT1zdHIuaW5kZXhPZihcIl1cIik7aWYoYiE9LTEmJmUhPS0xKXtzdHI9c3RyLnN1YnN0cmluZygwLGIpK3N0ci5zdWJzdHJpbmcoYixlKS5yZXBsYWNlKC86L2csXCI7XCIpK3N0ci5zdWJzdHJpbmcoZSxzdHIubGVuZ3RoKX12YXIgbT1yZS5leGVjKHN0cnx8XCJcIiksdXJpPXt9LGk9MTQ7d2hpbGUoaS0tKXt1cmlbcGFydHNbaV1dPW1baV18fFwiXCJ9aWYoYiE9LTEmJmUhPS0xKXt1cmkuc291cmNlPXNyYzt1cmkuaG9zdD11cmkuaG9zdC5zdWJzdHJpbmcoMSx1cmkuaG9zdC5sZW5ndGgtMSkucmVwbGFjZSgvOy9nLFwiOlwiKTt1cmkuYXV0aG9yaXR5PXVyaS5hdXRob3JpdHkucmVwbGFjZShcIltcIixcIlwiKS5yZXBsYWNlKFwiXVwiLFwiXCIpLnJlcGxhY2UoLzsvZyxcIjpcIik7dXJpLmlwdjZ1cmk9dHJ1ZX1yZXR1cm4gdXJpfX0se31dLDM3OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgZ2xvYmFsPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dmFyIFdlYlNvY2tldD1nbG9iYWwuV2ViU29ja2V0fHxnbG9iYWwuTW96V2ViU29ja2V0O21vZHVsZS5leHBvcnRzPVdlYlNvY2tldD93czpudWxsO2Z1bmN0aW9uIHdzKHVyaSxwcm90b2NvbHMsb3B0cyl7dmFyIGluc3RhbmNlO2lmKHByb3RvY29scyl7aW5zdGFuY2U9bmV3IFdlYlNvY2tldCh1cmkscHJvdG9jb2xzKX1lbHNle2luc3RhbmNlPW5ldyBXZWJTb2NrZXQodXJpKX1yZXR1cm4gaW5zdGFuY2V9aWYoV2ViU29ja2V0KXdzLnByb3RvdHlwZT1XZWJTb2NrZXQucHJvdG90eXBlfSx7fV0sMzg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbihnbG9iYWwpe3ZhciBpc0FycmF5PV9kZXJlcV8oXCJpc2FycmF5XCIpO21vZHVsZS5leHBvcnRzPWhhc0JpbmFyeTtmdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSl7ZnVuY3Rpb24gX2hhc0JpbmFyeShvYmope2lmKCFvYmopcmV0dXJuIGZhbHNlO2lmKGdsb2JhbC5CdWZmZXImJmdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKXx8Z2xvYmFsLkFycmF5QnVmZmVyJiZvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcnx8Z2xvYmFsLkJsb2ImJm9iaiBpbnN0YW5jZW9mIEJsb2J8fGdsb2JhbC5GaWxlJiZvYmogaW5zdGFuY2VvZiBGaWxlKXtyZXR1cm4gdHJ1ZX1pZihpc0FycmF5KG9iaikpe2Zvcih2YXIgaT0wO2k8b2JqLmxlbmd0aDtpKyspe2lmKF9oYXNCaW5hcnkob2JqW2ldKSl7cmV0dXJuIHRydWV9fX1lbHNlIGlmKG9iaiYmXCJvYmplY3RcIj09dHlwZW9mIG9iail7aWYob2JqLnRvSlNPTil7b2JqPW9iai50b0pTT04oKX1mb3IodmFyIGtleSBpbiBvYmope2lmKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosa2V5KSYmX2hhc0JpbmFyeShvYmpba2V5XSkpe3JldHVybiB0cnVlfX19cmV0dXJuIGZhbHNlfXJldHVybiBfaGFzQmluYXJ5KGRhdGEpfX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7aXNhcnJheTozOX1dLDM5OltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXttb2R1bGUuZXhwb3J0cz1fZGVyZXFfKDMyKX0se31dLDQwOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgZ2xvYmFsPV9kZXJlcV8oXCJnbG9iYWxcIik7dHJ5e21vZHVsZS5leHBvcnRzPVwiWE1MSHR0cFJlcXVlc3RcImluIGdsb2JhbCYmXCJ3aXRoQ3JlZGVudGlhbHNcImluIG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3R9Y2F0Y2goZXJyKXttb2R1bGUuZXhwb3J0cz1mYWxzZX19LHtnbG9iYWw6NDF9XSw0MTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKX0se31dLDQyOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgaW5kZXhPZj1bXS5pbmRleE9mO21vZHVsZS5leHBvcnRzPWZ1bmN0aW9uKGFycixvYmope2lmKGluZGV4T2YpcmV0dXJuIGFyci5pbmRleE9mKG9iaik7Zm9yKHZhciBpPTA7aTxhcnIubGVuZ3RoOysraSl7aWYoYXJyW2ldPT09b2JqKXJldHVybiBpfXJldHVybi0xfX0se31dLDQzOltmdW5jdGlvbihfZGVyZXFfLG1vZHVsZSxleHBvcnRzKXt2YXIgaGFzPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7ZXhwb3J0cy5rZXlzPU9iamVjdC5rZXlzfHxmdW5jdGlvbihvYmope3ZhciBrZXlzPVtdO2Zvcih2YXIga2V5IGluIG9iail7aWYoaGFzLmNhbGwob2JqLGtleSkpe2tleXMucHVzaChrZXkpfX1yZXR1cm4ga2V5c307ZXhwb3J0cy52YWx1ZXM9ZnVuY3Rpb24ob2JqKXt2YXIgdmFscz1bXTtmb3IodmFyIGtleSBpbiBvYmope2lmKGhhcy5jYWxsKG9iaixrZXkpKXt2YWxzLnB1c2gob2JqW2tleV0pfX1yZXR1cm4gdmFsc307ZXhwb3J0cy5tZXJnZT1mdW5jdGlvbihhLGIpe2Zvcih2YXIga2V5IGluIGIpe2lmKGhhcy5jYWxsKGIsa2V5KSl7YVtrZXldPWJba2V5XX19cmV0dXJuIGF9O2V4cG9ydHMubGVuZ3RoPWZ1bmN0aW9uKG9iail7cmV0dXJuIGV4cG9ydHMua2V5cyhvYmopLmxlbmd0aH07ZXhwb3J0cy5pc0VtcHR5PWZ1bmN0aW9uKG9iail7cmV0dXJuIDA9PWV4cG9ydHMubGVuZ3RoKG9iail9fSx7fV0sNDQ6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe3ZhciByZT0vXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLzt2YXIgcGFydHM9W1wic291cmNlXCIsXCJwcm90b2NvbFwiLFwiYXV0aG9yaXR5XCIsXCJ1c2VySW5mb1wiLFwidXNlclwiLFwicGFzc3dvcmRcIixcImhvc3RcIixcInBvcnRcIixcInJlbGF0aXZlXCIsXCJwYXRoXCIsXCJkaXJlY3RvcnlcIixcImZpbGVcIixcInF1ZXJ5XCIsXCJhbmNob3JcIl07bW9kdWxlLmV4cG9ydHM9ZnVuY3Rpb24gcGFyc2V1cmkoc3RyKXt2YXIgbT1yZS5leGVjKHN0cnx8XCJcIiksdXJpPXt9LGk9MTQ7d2hpbGUoaS0tKXt1cmlbcGFydHNbaV1dPW1baV18fFwiXCJ9cmV0dXJuIHVyaX19LHt9XSw0NTpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7dmFyIGlzQXJyYXk9X2RlcmVxXyhcImlzYXJyYXlcIik7dmFyIGlzQnVmPV9kZXJlcV8oXCIuL2lzLWJ1ZmZlclwiKTtleHBvcnRzLmRlY29uc3RydWN0UGFja2V0PWZ1bmN0aW9uKHBhY2tldCl7dmFyIGJ1ZmZlcnM9W107dmFyIHBhY2tldERhdGE9cGFja2V0LmRhdGE7ZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpe2lmKCFkYXRhKXJldHVybiBkYXRhO2lmKGlzQnVmKGRhdGEpKXt2YXIgcGxhY2Vob2xkZXI9e19wbGFjZWhvbGRlcjp0cnVlLG51bTpidWZmZXJzLmxlbmd0aH07YnVmZmVycy5wdXNoKGRhdGEpO3JldHVybiBwbGFjZWhvbGRlcn1lbHNlIGlmKGlzQXJyYXkoZGF0YSkpe3ZhciBuZXdEYXRhPW5ldyBBcnJheShkYXRhLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxkYXRhLmxlbmd0aDtpKyspe25ld0RhdGFbaV09X2RlY29uc3RydWN0UGFja2V0KGRhdGFbaV0pfXJldHVybiBuZXdEYXRhfWVsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGRhdGEmJiEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKXt2YXIgbmV3RGF0YT17fTtmb3IodmFyIGtleSBpbiBkYXRhKXtuZXdEYXRhW2tleV09X2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSl9cmV0dXJuIG5ld0RhdGF9cmV0dXJuIGRhdGF9dmFyIHBhY2s9cGFja2V0O3BhY2suZGF0YT1fZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0RGF0YSk7cGFjay5hdHRhY2htZW50cz1idWZmZXJzLmxlbmd0aDtyZXR1cm57cGFja2V0OnBhY2ssYnVmZmVyczpidWZmZXJzfX07ZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldD1mdW5jdGlvbihwYWNrZXQsYnVmZmVycyl7dmFyIGN1clBsYWNlSG9sZGVyPTA7ZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEpe2lmKGRhdGEmJmRhdGEuX3BsYWNlaG9sZGVyKXt2YXIgYnVmPWJ1ZmZlcnNbZGF0YS5udW1dO3JldHVybiBidWZ9ZWxzZSBpZihpc0FycmF5KGRhdGEpKXtmb3IodmFyIGk9MDtpPGRhdGEubGVuZ3RoO2krKyl7ZGF0YVtpXT1fcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSl9cmV0dXJuIGRhdGF9ZWxzZSBpZihkYXRhJiZcIm9iamVjdFwiPT10eXBlb2YgZGF0YSl7Zm9yKHZhciBrZXkgaW4gZGF0YSl7ZGF0YVtrZXldPV9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pfXJldHVybiBkYXRhfXJldHVybiBkYXRhfXBhY2tldC5kYXRhPV9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSk7cGFja2V0LmF0dGFjaG1lbnRzPXVuZGVmaW5lZDtyZXR1cm4gcGFja2V0fTtleHBvcnRzLnJlbW92ZUJsb2JzPWZ1bmN0aW9uKGRhdGEsY2FsbGJhY2spe2Z1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosY3VyS2V5LGNvbnRhaW5pbmdPYmplY3Qpe2lmKCFvYmopcmV0dXJuIG9iajtpZihnbG9iYWwuQmxvYiYmb2JqIGluc3RhbmNlb2YgQmxvYnx8Z2xvYmFsLkZpbGUmJm9iaiBpbnN0YW5jZW9mIEZpbGUpe3BlbmRpbmdCbG9icysrO3ZhciBmaWxlUmVhZGVyPW5ldyBGaWxlUmVhZGVyO2ZpbGVSZWFkZXIub25sb2FkPWZ1bmN0aW9uKCl7aWYoY29udGFpbmluZ09iamVjdCl7Y29udGFpbmluZ09iamVjdFtjdXJLZXldPXRoaXMucmVzdWx0fWVsc2V7YmxvYmxlc3NEYXRhPXRoaXMucmVzdWx0fWlmKCEtLXBlbmRpbmdCbG9icyl7Y2FsbGJhY2soYmxvYmxlc3NEYXRhKX19O2ZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKX1lbHNlIGlmKGlzQXJyYXkob2JqKSl7Zm9yKHZhciBpPTA7aTxvYmoubGVuZ3RoO2krKyl7X3JlbW92ZUJsb2JzKG9ialtpXSxpLG9iail9fWVsc2UgaWYob2JqJiZcIm9iamVjdFwiPT10eXBlb2Ygb2JqJiYhaXNCdWYob2JqKSl7Zm9yKHZhciBrZXkgaW4gb2JqKXtfcmVtb3ZlQmxvYnMob2JqW2tleV0sa2V5LG9iail9fX12YXIgcGVuZGluZ0Jsb2JzPTA7dmFyIGJsb2JsZXNzRGF0YT1kYXRhO19yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO2lmKCFwZW5kaW5nQmxvYnMpe2NhbGxiYWNrKGJsb2JsZXNzRGF0YSl9fX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7XCIuL2lzLWJ1ZmZlclwiOjQ3LGlzYXJyYXk6NDh9XSw0NjpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7dmFyIGRlYnVnPV9kZXJlcV8oXCJkZWJ1Z1wiKShcInNvY2tldC5pby1wYXJzZXJcIik7dmFyIGpzb249X2RlcmVxXyhcImpzb24zXCIpO3ZhciBpc0FycmF5PV9kZXJlcV8oXCJpc2FycmF5XCIpO3ZhciBFbWl0dGVyPV9kZXJlcV8oXCJjb21wb25lbnQtZW1pdHRlclwiKTt2YXIgYmluYXJ5PV9kZXJlcV8oXCIuL2JpbmFyeVwiKTt2YXIgaXNCdWY9X2RlcmVxXyhcIi4vaXMtYnVmZmVyXCIpO2V4cG9ydHMucHJvdG9jb2w9NDtleHBvcnRzLnR5cGVzPVtcIkNPTk5FQ1RcIixcIkRJU0NPTk5FQ1RcIixcIkVWRU5UXCIsXCJCSU5BUllfRVZFTlRcIixcIkFDS1wiLFwiQklOQVJZX0FDS1wiLFwiRVJST1JcIl07ZXhwb3J0cy5DT05ORUNUPTA7ZXhwb3J0cy5ESVNDT05ORUNUPTE7ZXhwb3J0cy5FVkVOVD0yO2V4cG9ydHMuQUNLPTM7ZXhwb3J0cy5FUlJPUj00O2V4cG9ydHMuQklOQVJZX0VWRU5UPTU7ZXhwb3J0cy5CSU5BUllfQUNLPTY7ZXhwb3J0cy5FbmNvZGVyPUVuY29kZXI7ZXhwb3J0cy5EZWNvZGVyPURlY29kZXI7ZnVuY3Rpb24gRW5jb2Rlcigpe31FbmNvZGVyLnByb3RvdHlwZS5lbmNvZGU9ZnVuY3Rpb24ob2JqLGNhbGxiYWNrKXtkZWJ1ZyhcImVuY29kaW5nIHBhY2tldCAlalwiLG9iaik7aWYoZXhwb3J0cy5CSU5BUllfRVZFTlQ9PW9iai50eXBlfHxleHBvcnRzLkJJTkFSWV9BQ0s9PW9iai50eXBlKXtlbmNvZGVBc0JpbmFyeShvYmosY2FsbGJhY2spfWVsc2V7dmFyIGVuY29kaW5nPWVuY29kZUFzU3RyaW5nKG9iaik7Y2FsbGJhY2soW2VuY29kaW5nXSl9fTtmdW5jdGlvbiBlbmNvZGVBc1N0cmluZyhvYmope3ZhciBzdHI9XCJcIjt2YXIgbnNwPWZhbHNlO3N0cis9b2JqLnR5cGU7aWYoZXhwb3J0cy5CSU5BUllfRVZFTlQ9PW9iai50eXBlfHxleHBvcnRzLkJJTkFSWV9BQ0s9PW9iai50eXBlKXtzdHIrPW9iai5hdHRhY2htZW50cztzdHIrPVwiLVwifWlmKG9iai5uc3AmJlwiL1wiIT1vYmoubnNwKXtuc3A9dHJ1ZTtzdHIrPW9iai5uc3B9aWYobnVsbCE9b2JqLmlkKXtpZihuc3Ape3N0cis9XCIsXCI7bnNwPWZhbHNlfXN0cis9b2JqLmlkfWlmKG51bGwhPW9iai5kYXRhKXtpZihuc3Apc3RyKz1cIixcIjtzdHIrPWpzb24uc3RyaW5naWZ5KG9iai5kYXRhKX1kZWJ1ZyhcImVuY29kZWQgJWogYXMgJXNcIixvYmosc3RyKTtyZXR1cm4gc3RyfWZ1bmN0aW9uIGVuY29kZUFzQmluYXJ5KG9iaixjYWxsYmFjayl7ZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpe3ZhciBkZWNvbnN0cnVjdGlvbj1iaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTt2YXIgcGFjaz1lbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO3ZhciBidWZmZXJzPWRlY29uc3RydWN0aW9uLmJ1ZmZlcnM7YnVmZmVycy51bnNoaWZ0KHBhY2spO2NhbGxiYWNrKGJ1ZmZlcnMpfWJpbmFyeS5yZW1vdmVCbG9icyhvYmosd3JpdGVFbmNvZGluZyl9ZnVuY3Rpb24gRGVjb2Rlcigpe3RoaXMucmVjb25zdHJ1Y3Rvcj1udWxsfUVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO0RlY29kZXIucHJvdG90eXBlLmFkZD1mdW5jdGlvbihvYmope3ZhciBwYWNrZXQ7aWYoXCJzdHJpbmdcIj09dHlwZW9mIG9iail7cGFja2V0PWRlY29kZVN0cmluZyhvYmopO2lmKGV4cG9ydHMuQklOQVJZX0VWRU5UPT1wYWNrZXQudHlwZXx8ZXhwb3J0cy5CSU5BUllfQUNLPT1wYWNrZXQudHlwZSl7dGhpcy5yZWNvbnN0cnVjdG9yPW5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7aWYodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cz09PTApe3RoaXMuZW1pdChcImRlY29kZWRcIixwYWNrZXQpfX1lbHNle3RoaXMuZW1pdChcImRlY29kZWRcIixwYWNrZXQpfX1lbHNlIGlmKGlzQnVmKG9iail8fG9iai5iYXNlNjQpe2lmKCF0aGlzLnJlY29uc3RydWN0b3Ipe3Rocm93IG5ldyBFcnJvcihcImdvdCBiaW5hcnkgZGF0YSB3aGVuIG5vdCByZWNvbnN0cnVjdGluZyBhIHBhY2tldFwiKX1lbHNle3BhY2tldD10aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtpZihwYWNrZXQpe3RoaXMucmVjb25zdHJ1Y3Rvcj1udWxsO3RoaXMuZW1pdChcImRlY29kZWRcIixwYWNrZXQpfX19ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiK29iail9fTtmdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKXt2YXIgcD17fTt2YXIgaT0wO3AudHlwZT1OdW1iZXIoc3RyLmNoYXJBdCgwKSk7aWYobnVsbD09ZXhwb3J0cy50eXBlc1twLnR5cGVdKXJldHVybiBlcnJvcigpO2lmKGV4cG9ydHMuQklOQVJZX0VWRU5UPT1wLnR5cGV8fGV4cG9ydHMuQklOQVJZX0FDSz09cC50eXBlKXt2YXIgYnVmPVwiXCI7d2hpbGUoc3RyLmNoYXJBdCgrK2kpIT1cIi1cIil7YnVmKz1zdHIuY2hhckF0KGkpO2lmKGkrMT09c3RyLmxlbmd0aClicmVha31pZihidWYhPU51bWJlcihidWYpfHxzdHIuY2hhckF0KGkpIT1cIi1cIil7dGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBhdHRhY2htZW50c1wiKX1wLmF0dGFjaG1lbnRzPU51bWJlcihidWYpfWlmKFwiL1wiPT1zdHIuY2hhckF0KGkrMSkpe3AubnNwPVwiXCI7d2hpbGUoKytpKXt2YXIgYz1zdHIuY2hhckF0KGkpO2lmKFwiLFwiPT1jKWJyZWFrO3AubnNwKz1jO2lmKGkrMT09c3RyLmxlbmd0aClicmVha319ZWxzZXtwLm5zcD1cIi9cIn12YXIgbmV4dD1zdHIuY2hhckF0KGkrMSk7aWYoXCJcIiE9PW5leHQmJk51bWJlcihuZXh0KT09bmV4dCl7cC5pZD1cIlwiO3doaWxlKCsraSl7dmFyIGM9c3RyLmNoYXJBdChpKTtpZihudWxsPT1jfHxOdW1iZXIoYykhPWMpey0taTticmVha31wLmlkKz1zdHIuY2hhckF0KGkpO2lmKGkrMT09c3RyLmxlbmd0aClicmVha31wLmlkPU51bWJlcihwLmlkKX1pZihzdHIuY2hhckF0KCsraSkpe3RyeXtwLmRhdGE9anNvbi5wYXJzZShzdHIuc3Vic3RyKGkpKX1jYXRjaChlKXtyZXR1cm4gZXJyb3IoKX19ZGVidWcoXCJkZWNvZGVkICVzIGFzICVqXCIsc3RyLHApO3JldHVybiBwfURlY29kZXIucHJvdG90eXBlLmRlc3Ryb3k9ZnVuY3Rpb24oKXtpZih0aGlzLnJlY29uc3RydWN0b3Ipe3RoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCl9fTtmdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCl7dGhpcy5yZWNvblBhY2s9cGFja2V0O3RoaXMuYnVmZmVycz1bXX1CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YT1mdW5jdGlvbihiaW5EYXRhKXt0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtpZih0aGlzLmJ1ZmZlcnMubGVuZ3RoPT10aGlzLnJlY29uUGFjay5hdHRhY2htZW50cyl7dmFyIHBhY2tldD1iaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssdGhpcy5idWZmZXJzKTt0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtyZXR1cm4gcGFja2V0fXJldHVybiBudWxsfTtCaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uPWZ1bmN0aW9uKCl7dGhpcy5yZWNvblBhY2s9bnVsbDt0aGlzLmJ1ZmZlcnM9W119O2Z1bmN0aW9uIGVycm9yKGRhdGEpe3JldHVybnt0eXBlOmV4cG9ydHMuRVJST1IsZGF0YTpcInBhcnNlciBlcnJvclwifX19LHtcIi4vYmluYXJ5XCI6NDUsXCIuL2lzLWJ1ZmZlclwiOjQ3LFwiY29tcG9uZW50LWVtaXR0ZXJcIjo5LGRlYnVnOjEwLGlzYXJyYXk6NDgsanNvbjM6NDl9XSw0NzpbZnVuY3Rpb24oX2RlcmVxXyxtb2R1bGUsZXhwb3J0cyl7KGZ1bmN0aW9uKGdsb2JhbCl7bW9kdWxlLmV4cG9ydHM9aXNCdWY7ZnVuY3Rpb24gaXNCdWYob2JqKXtyZXR1cm4gZ2xvYmFsLkJ1ZmZlciYmZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihvYmopfHxnbG9iYWwuQXJyYXlCdWZmZXImJm9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfX0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiE9PVwidW5kZWZpbmVkXCI/c2VsZjp0eXBlb2Ygd2luZG93IT09XCJ1bmRlZmluZWRcIj93aW5kb3c6e30pfSx7fV0sNDg6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPV9kZXJlcV8oMzIpfSx7fV0sNDk6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpeyhmdW5jdGlvbih3aW5kb3cpe3ZhciBnZXRDbGFzcz17fS50b1N0cmluZyxpc1Byb3BlcnR5LGZvckVhY2gsdW5kZWY7dmFyIGlzTG9hZGVyPXR5cGVvZiBkZWZpbmU9PT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQ7dmFyIG5hdGl2ZUpTT049dHlwZW9mIEpTT049PVwib2JqZWN0XCImJkpTT047dmFyIEpTT04zPXR5cGVvZiBleHBvcnRzPT1cIm9iamVjdFwiJiZleHBvcnRzJiYhZXhwb3J0cy5ub2RlVHlwZSYmZXhwb3J0cztpZihKU09OMyYmbmF0aXZlSlNPTil7SlNPTjMuc3RyaW5naWZ5PW5hdGl2ZUpTT04uc3RyaW5naWZ5O0pTT04zLnBhcnNlPW5hdGl2ZUpTT04ucGFyc2V9ZWxzZXtKU09OMz13aW5kb3cuSlNPTj1uYXRpdmVKU09OfHx7fX12YXIgaXNFeHRlbmRlZD1uZXcgRGF0ZSgtMHhjNzgyYjViODAwY2VjKTt0cnl7aXNFeHRlbmRlZD1pc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCk9PS0xMDkyNTImJmlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKT09PTAmJmlzRXh0ZW5kZWQuZ2V0VVRDRGF0ZSgpPT09MSYmaXNFeHRlbmRlZC5nZXRVVENIb3VycygpPT0xMCYmaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCk9PTM3JiZpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKT09NiYmaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKT09NzA4fWNhdGNoKGV4Y2VwdGlvbil7fWZ1bmN0aW9uIGhhcyhuYW1lKXtpZihoYXNbbmFtZV0hPT11bmRlZil7cmV0dXJuIGhhc1tuYW1lXX12YXIgaXNTdXBwb3J0ZWQ7aWYobmFtZT09XCJidWctc3RyaW5nLWNoYXItaW5kZXhcIil7aXNTdXBwb3J0ZWQ9XCJhXCJbMF0hPVwiYVwifWVsc2UgaWYobmFtZT09XCJqc29uXCIpe2lzU3VwcG9ydGVkPWhhcyhcImpzb24tc3RyaW5naWZ5XCIpJiZoYXMoXCJqc29uLXBhcnNlXCIpfWVsc2V7dmFyIHZhbHVlLHNlcmlhbGl6ZWQ9J3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7aWYobmFtZT09XCJqc29uLXN0cmluZ2lmeVwiKXt2YXIgc3RyaW5naWZ5PUpTT04zLnN0cmluZ2lmeSxzdHJpbmdpZnlTdXBwb3J0ZWQ9dHlwZW9mIHN0cmluZ2lmeT09XCJmdW5jdGlvblwiJiZpc0V4dGVuZGVkO2lmKHN0cmluZ2lmeVN1cHBvcnRlZCl7KHZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIDF9KS50b0pTT049dmFsdWU7dHJ5e3N0cmluZ2lmeVN1cHBvcnRlZD1zdHJpbmdpZnkoMCk9PT1cIjBcIiYmc3RyaW5naWZ5KG5ldyBOdW1iZXIpPT09XCIwXCImJnN0cmluZ2lmeShuZXcgU3RyaW5nKT09J1wiXCInJiZzdHJpbmdpZnkoZ2V0Q2xhc3MpPT09dW5kZWYmJnN0cmluZ2lmeSh1bmRlZik9PT11bmRlZiYmc3RyaW5naWZ5KCk9PT11bmRlZiYmc3RyaW5naWZ5KHZhbHVlKT09PVwiMVwiJiZzdHJpbmdpZnkoW3ZhbHVlXSk9PVwiWzFdXCImJnN0cmluZ2lmeShbdW5kZWZdKT09XCJbbnVsbF1cIiYmc3RyaW5naWZ5KG51bGwpPT1cIm51bGxcIiYmc3RyaW5naWZ5KFt1bmRlZixnZXRDbGFzcyxudWxsXSk9PVwiW251bGwsbnVsbCxudWxsXVwiJiZzdHJpbmdpZnkoe2E6W3ZhbHVlLHRydWUsZmFsc2UsbnVsbCxcIlxceDAwXFxiXFxuXFxmXFxyIFwiXX0pPT1zZXJpYWxpemVkJiZzdHJpbmdpZnkobnVsbCx2YWx1ZSk9PT1cIjFcIiYmc3RyaW5naWZ5KFsxLDJdLG51bGwsMSk9PVwiW1xcbiAxLFxcbiAyXFxuXVwiJiZzdHJpbmdpZnkobmV3IERhdGUoLTg2NGUxMykpPT0nXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicmJnN0cmluZ2lmeShuZXcgRGF0ZSg4NjRlMTMpKT09J1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInJiZzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSk9PSdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyYmc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSk9PSdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJ31jYXRjaChleGNlcHRpb24pe3N0cmluZ2lmeVN1cHBvcnRlZD1mYWxzZX19aXNTdXBwb3J0ZWQ9c3RyaW5naWZ5U3VwcG9ydGVkfWlmKG5hbWU9PVwianNvbi1wYXJzZVwiKXt2YXIgcGFyc2U9SlNPTjMucGFyc2U7aWYodHlwZW9mIHBhcnNlPT1cImZ1bmN0aW9uXCIpe3RyeXtpZihwYXJzZShcIjBcIik9PT0wJiYhcGFyc2UoZmFsc2UpKXt2YWx1ZT1wYXJzZShzZXJpYWxpemVkKTt2YXIgcGFyc2VTdXBwb3J0ZWQ9dmFsdWVbXCJhXCJdLmxlbmd0aD09NSYmdmFsdWVbXCJhXCJdWzBdPT09MTtpZihwYXJzZVN1cHBvcnRlZCl7dHJ5e3BhcnNlU3VwcG9ydGVkPSFwYXJzZSgnXCIgIFwiJyl9Y2F0Y2goZXhjZXB0aW9uKXt9aWYocGFyc2VTdXBwb3J0ZWQpe3RyeXtwYXJzZVN1cHBvcnRlZD1wYXJzZShcIjAxXCIpIT09MX1jYXRjaChleGNlcHRpb24pe319aWYocGFyc2VTdXBwb3J0ZWQpe3RyeXtwYXJzZVN1cHBvcnRlZD1wYXJzZShcIjEuXCIpIT09MX1jYXRjaChleGNlcHRpb24pe319fX19Y2F0Y2goZXhjZXB0aW9uKXtwYXJzZVN1cHBvcnRlZD1mYWxzZX19aXNTdXBwb3J0ZWQ9cGFyc2VTdXBwb3J0ZWR9fXJldHVybiBoYXNbbmFtZV09ISFpc1N1cHBvcnRlZH1pZighaGFzKFwianNvblwiKSl7dmFyIGZ1bmN0aW9uQ2xhc3M9XCJbb2JqZWN0IEZ1bmN0aW9uXVwiO3ZhciBkYXRlQ2xhc3M9XCJbb2JqZWN0IERhdGVdXCI7dmFyIG51bWJlckNsYXNzPVwiW29iamVjdCBOdW1iZXJdXCI7dmFyIHN0cmluZ0NsYXNzPVwiW29iamVjdCBTdHJpbmddXCI7dmFyIGFycmF5Q2xhc3M9XCJbb2JqZWN0IEFycmF5XVwiO3ZhciBib29sZWFuQ2xhc3M9XCJbb2JqZWN0IEJvb2xlYW5dXCI7dmFyIGNoYXJJbmRleEJ1Z2d5PWhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtpZighaXNFeHRlbmRlZCl7dmFyIGZsb29yPU1hdGguZmxvb3I7dmFyIE1vbnRocz1bMCwzMSw1OSw5MCwxMjAsMTUxLDE4MSwyMTIsMjQzLDI3MywzMDQsMzM0XTt2YXIgZ2V0RGF5PWZ1bmN0aW9uKHllYXIsbW9udGgpe3JldHVybiBNb250aHNbbW9udGhdKzM2NSooeWVhci0xOTcwKStmbG9vcigoeWVhci0xOTY5Kyhtb250aD0rKG1vbnRoPjEpKSkvNCktZmxvb3IoKHllYXItMTkwMSttb250aCkvMTAwKStmbG9vcigoeWVhci0xNjAxK21vbnRoKS80MDApfX1pZighKGlzUHJvcGVydHk9e30uaGFzT3duUHJvcGVydHkpKXtpc1Byb3BlcnR5PWZ1bmN0aW9uKHByb3BlcnR5KXt2YXIgbWVtYmVycz17fSxjb25zdHJ1Y3RvcjtpZigobWVtYmVycy5fX3Byb3RvX189bnVsbCxtZW1iZXJzLl9fcHJvdG9fXz17dG9TdHJpbmc6MX0sbWVtYmVycykudG9TdHJpbmchPWdldENsYXNzKXtpc1Byb3BlcnR5PWZ1bmN0aW9uKHByb3BlcnR5KXt2YXIgb3JpZ2luYWw9dGhpcy5fX3Byb3RvX18scmVzdWx0PXByb3BlcnR5IGluKHRoaXMuX19wcm90b19fPW51bGwsdGhpcyk7dGhpcy5fX3Byb3RvX189b3JpZ2luYWw7cmV0dXJuIHJlc3VsdH19ZWxzZXtjb25zdHJ1Y3Rvcj1tZW1iZXJzLmNvbnN0cnVjdG9yO2lzUHJvcGVydHk9ZnVuY3Rpb24ocHJvcGVydHkpe3ZhciBwYXJlbnQ9KHRoaXMuY29uc3RydWN0b3J8fGNvbnN0cnVjdG9yKS5wcm90b3R5cGU7cmV0dXJuIHByb3BlcnR5IGluIHRoaXMmJiEocHJvcGVydHkgaW4gcGFyZW50JiZ0aGlzW3Byb3BlcnR5XT09PXBhcmVudFtwcm9wZXJ0eV0pfX1tZW1iZXJzPW51bGw7cmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLHByb3BlcnR5KX19dmFyIFByaW1pdGl2ZVR5cGVzPXtcImJvb2xlYW5cIjoxLG51bWJlcjoxLHN0cmluZzoxLHVuZGVmaW5lZDoxfTt2YXIgaXNIb3N0VHlwZT1mdW5jdGlvbihvYmplY3QscHJvcGVydHkpe3ZhciB0eXBlPXR5cGVvZiBvYmplY3RbcHJvcGVydHldO3JldHVybiB0eXBlPT1cIm9iamVjdFwiPyEhb2JqZWN0W3Byb3BlcnR5XTohUHJpbWl0aXZlVHlwZXNbdHlwZV19O2ZvckVhY2g9ZnVuY3Rpb24ob2JqZWN0LGNhbGxiYWNrKXt2YXIgc2l6ZT0wLFByb3BlcnRpZXMsbWVtYmVycyxwcm9wZXJ0eTsoUHJvcGVydGllcz1mdW5jdGlvbigpe3RoaXMudmFsdWVPZj0wfSkucHJvdG90eXBlLnZhbHVlT2Y9MDttZW1iZXJzPW5ldyBQcm9wZXJ0aWVzO2Zvcihwcm9wZXJ0eSBpbiBtZW1iZXJzKXtpZihpc1Byb3BlcnR5LmNhbGwobWVtYmVycyxwcm9wZXJ0eSkpe3NpemUrK319UHJvcGVydGllcz1tZW1iZXJzPW51bGw7aWYoIXNpemUpe21lbWJlcnM9W1widmFsdWVPZlwiLFwidG9TdHJpbmdcIixcInRvTG9jYWxlU3RyaW5nXCIsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLFwiaXNQcm90b3R5cGVPZlwiLFwiaGFzT3duUHJvcGVydHlcIixcImNvbnN0cnVjdG9yXCJdO2ZvckVhY2g9ZnVuY3Rpb24ob2JqZWN0LGNhbGxiYWNrKXt2YXIgaXNGdW5jdGlvbj1nZXRDbGFzcy5jYWxsKG9iamVjdCk9PWZ1bmN0aW9uQ2xhc3MscHJvcGVydHksbGVuZ3RoO3ZhciBoYXNQcm9wZXJ0eT0haXNGdW5jdGlvbiYmdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciE9XCJmdW5jdGlvblwiJiZpc0hvc3RUeXBlKG9iamVjdCxcImhhc093blByb3BlcnR5XCIpP29iamVjdC5oYXNPd25Qcm9wZXJ0eTppc1Byb3BlcnR5O2Zvcihwcm9wZXJ0eSBpbiBvYmplY3Qpe2lmKCEoaXNGdW5jdGlvbiYmcHJvcGVydHk9PVwicHJvdG90eXBlXCIpJiZoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCxwcm9wZXJ0eSkpe2NhbGxiYWNrKHByb3BlcnR5KX19Zm9yKGxlbmd0aD1tZW1iZXJzLmxlbmd0aDtwcm9wZXJ0eT1tZW1iZXJzWy0tbGVuZ3RoXTtoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCxwcm9wZXJ0eSkmJmNhbGxiYWNrKHByb3BlcnR5KSk7fX1lbHNlIGlmKHNpemU9PTIpe2ZvckVhY2g9ZnVuY3Rpb24ob2JqZWN0LGNhbGxiYWNrKXt2YXIgbWVtYmVycz17fSxpc0Z1bmN0aW9uPWdldENsYXNzLmNhbGwob2JqZWN0KT09ZnVuY3Rpb25DbGFzcyxwcm9wZXJ0eTtmb3IocHJvcGVydHkgaW4gb2JqZWN0KXtpZighKGlzRnVuY3Rpb24mJnByb3BlcnR5PT1cInByb3RvdHlwZVwiKSYmIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLHByb3BlcnR5KSYmKG1lbWJlcnNbcHJvcGVydHldPTEpJiZpc1Byb3BlcnR5LmNhbGwob2JqZWN0LHByb3BlcnR5KSl7Y2FsbGJhY2socHJvcGVydHkpfX19fWVsc2V7Zm9yRWFjaD1mdW5jdGlvbihvYmplY3QsY2FsbGJhY2spe3ZhciBpc0Z1bmN0aW9uPWdldENsYXNzLmNhbGwob2JqZWN0KT09ZnVuY3Rpb25DbGFzcyxwcm9wZXJ0eSxpc0NvbnN0cnVjdG9yO2Zvcihwcm9wZXJ0eSBpbiBvYmplY3Qpe2lmKCEoaXNGdW5jdGlvbiYmcHJvcGVydHk9PVwicHJvdG90eXBlXCIpJiZpc1Byb3BlcnR5LmNhbGwob2JqZWN0LHByb3BlcnR5KSYmIShpc0NvbnN0cnVjdG9yPXByb3BlcnR5PT09XCJjb25zdHJ1Y3RvclwiKSl7Y2FsbGJhY2socHJvcGVydHkpfX1pZihpc0NvbnN0cnVjdG9yfHxpc1Byb3BlcnR5LmNhbGwob2JqZWN0LHByb3BlcnR5PVwiY29uc3RydWN0b3JcIikpe2NhbGxiYWNrKHByb3BlcnR5KX19fXJldHVybiBmb3JFYWNoKG9iamVjdCxjYWxsYmFjayl9O2lmKCFoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSl7dmFyIEVzY2FwZXM9ezkyOlwiXFxcXFxcXFxcIiwzNDonXFxcXFwiJyw4OlwiXFxcXGJcIiwxMjpcIlxcXFxmXCIsMTA6XCJcXFxcblwiLDEzOlwiXFxcXHJcIiw5OlwiXFxcXHRcIn07dmFyIGxlYWRpbmdaZXJvZXM9XCIwMDAwMDBcIjt2YXIgdG9QYWRkZWRTdHJpbmc9ZnVuY3Rpb24od2lkdGgsdmFsdWUpe3JldHVybihsZWFkaW5nWmVyb2VzKyh2YWx1ZXx8MCkpLnNsaWNlKC13aWR0aCl9O3ZhciB1bmljb2RlUHJlZml4PVwiXFxcXHUwMFwiO3ZhciBxdW90ZT1mdW5jdGlvbih2YWx1ZSl7dmFyIHJlc3VsdD0nXCInLGluZGV4PTAsbGVuZ3RoPXZhbHVlLmxlbmd0aCxpc0xhcmdlPWxlbmd0aD4xMCYmY2hhckluZGV4QnVnZ3ksc3ltYm9scztpZihpc0xhcmdlKXtzeW1ib2xzPXZhbHVlLnNwbGl0KFwiXCIpfWZvcig7aW5kZXg8bGVuZ3RoO2luZGV4Kyspe3ZhciBjaGFyQ29kZT12YWx1ZS5jaGFyQ29kZUF0KGluZGV4KTtzd2l0Y2goY2hhckNvZGUpe2Nhc2UgODpjYXNlIDk6Y2FzZSAxMDpjYXNlIDEyOmNhc2UgMTM6Y2FzZSAzNDpjYXNlIDkyOnJlc3VsdCs9RXNjYXBlc1tjaGFyQ29kZV07YnJlYWs7ZGVmYXVsdDppZihjaGFyQ29kZTwzMil7cmVzdWx0Kz11bmljb2RlUHJlZml4K3RvUGFkZGVkU3RyaW5nKDIsY2hhckNvZGUudG9TdHJpbmcoMTYpKTticmVha31yZXN1bHQrPWlzTGFyZ2U/c3ltYm9sc1tpbmRleF06Y2hhckluZGV4QnVnZ3k/dmFsdWUuY2hhckF0KGluZGV4KTp2YWx1ZVtpbmRleF19fXJldHVybiByZXN1bHQrJ1wiJ307dmFyIHNlcmlhbGl6ZT1mdW5jdGlvbihwcm9wZXJ0eSxvYmplY3QsY2FsbGJhY2sscHJvcGVydGllcyx3aGl0ZXNwYWNlLGluZGVudGF0aW9uLHN0YWNrKXt2YXIgdmFsdWUsY2xhc3NOYW1lLHllYXIsbW9udGgsZGF0ZSx0aW1lLGhvdXJzLG1pbnV0ZXMsc2Vjb25kcyxtaWxsaXNlY29uZHMscmVzdWx0cyxlbGVtZW50LGluZGV4LGxlbmd0aCxwcmVmaXgscmVzdWx0O3RyeXt2YWx1ZT1vYmplY3RbcHJvcGVydHldfWNhdGNoKGV4Y2VwdGlvbil7fWlmKHR5cGVvZiB2YWx1ZT09XCJvYmplY3RcIiYmdmFsdWUpe2NsYXNzTmFtZT1nZXRDbGFzcy5jYWxsKHZhbHVlKTtpZihjbGFzc05hbWU9PWRhdGVDbGFzcyYmIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSxcInRvSlNPTlwiKSl7aWYodmFsdWU+LTEvMCYmdmFsdWU8MS8wKXtpZihnZXREYXkpe2RhdGU9Zmxvb3IodmFsdWUvODY0ZTUpO2Zvcih5ZWFyPWZsb29yKGRhdGUvMzY1LjI0MjUpKzE5NzAtMTtnZXREYXkoeWVhcisxLDApPD1kYXRlO3llYXIrKyk7Zm9yKG1vbnRoPWZsb29yKChkYXRlLWdldERheSh5ZWFyLDApKS8zMC40Mik7Z2V0RGF5KHllYXIsbW9udGgrMSk8PWRhdGU7bW9udGgrKyk7ZGF0ZT0xK2RhdGUtZ2V0RGF5KHllYXIsbW9udGgpO3RpbWU9KHZhbHVlJTg2NGU1Kzg2NGU1KSU4NjRlNTtob3Vycz1mbG9vcih0aW1lLzM2ZTUpJTI0O21pbnV0ZXM9Zmxvb3IodGltZS82ZTQpJTYwO3NlY29uZHM9Zmxvb3IodGltZS8xZTMpJTYwO21pbGxpc2Vjb25kcz10aW1lJTFlM31lbHNle3llYXI9dmFsdWUuZ2V0VVRDRnVsbFllYXIoKTttb250aD12YWx1ZS5nZXRVVENNb250aCgpO2RhdGU9dmFsdWUuZ2V0VVRDRGF0ZSgpO2hvdXJzPXZhbHVlLmdldFVUQ0hvdXJzKCk7bWludXRlcz12YWx1ZS5nZXRVVENNaW51dGVzKCk7c2Vjb25kcz12YWx1ZS5nZXRVVENTZWNvbmRzKCk7bWlsbGlzZWNvbmRzPXZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpfXZhbHVlPSh5ZWFyPD0wfHx5ZWFyPj0xZTQ/KHllYXI8MD9cIi1cIjpcIitcIikrdG9QYWRkZWRTdHJpbmcoNix5ZWFyPDA/LXllYXI6eWVhcik6dG9QYWRkZWRTdHJpbmcoNCx5ZWFyKSkrXCItXCIrdG9QYWRkZWRTdHJpbmcoMixtb250aCsxKStcIi1cIit0b1BhZGRlZFN0cmluZygyLGRhdGUpK1wiVFwiK3RvUGFkZGVkU3RyaW5nKDIsaG91cnMpK1wiOlwiK3RvUGFkZGVkU3RyaW5nKDIsbWludXRlcykrXCI6XCIrdG9QYWRkZWRTdHJpbmcoMixzZWNvbmRzKStcIi5cIit0b1BhZGRlZFN0cmluZygzLG1pbGxpc2Vjb25kcykrXCJaXCJ9ZWxzZXt2YWx1ZT1udWxsfX1lbHNlIGlmKHR5cGVvZiB2YWx1ZS50b0pTT049PVwiZnVuY3Rpb25cIiYmKGNsYXNzTmFtZSE9bnVtYmVyQ2xhc3MmJmNsYXNzTmFtZSE9c3RyaW5nQ2xhc3MmJmNsYXNzTmFtZSE9YXJyYXlDbGFzc3x8aXNQcm9wZXJ0eS5jYWxsKHZhbHVlLFwidG9KU09OXCIpKSl7dmFsdWU9dmFsdWUudG9KU09OKHByb3BlcnR5KX19aWYoY2FsbGJhY2spe3ZhbHVlPWNhbGxiYWNrLmNhbGwob2JqZWN0LHByb3BlcnR5LHZhbHVlKX1pZih2YWx1ZT09PW51bGwpe3JldHVyblwibnVsbFwifWNsYXNzTmFtZT1nZXRDbGFzcy5jYWxsKHZhbHVlKTtpZihjbGFzc05hbWU9PWJvb2xlYW5DbGFzcyl7cmV0dXJuXCJcIit2YWx1ZX1lbHNlIGlmKGNsYXNzTmFtZT09bnVtYmVyQ2xhc3Mpe3JldHVybiB2YWx1ZT4tMS8wJiZ2YWx1ZTwxLzA/XCJcIit2YWx1ZTpcIm51bGxcIn1lbHNlIGlmKGNsYXNzTmFtZT09c3RyaW5nQ2xhc3Mpe3JldHVybiBxdW90ZShcIlwiK3ZhbHVlKX1pZih0eXBlb2YgdmFsdWU9PVwib2JqZWN0XCIpe2ZvcihsZW5ndGg9c3RhY2subGVuZ3RoO2xlbmd0aC0tOyl7aWYoc3RhY2tbbGVuZ3RoXT09PXZhbHVlKXt0aHJvdyBUeXBlRXJyb3IoKX19c3RhY2sucHVzaCh2YWx1ZSk7cmVzdWx0cz1bXTtwcmVmaXg9aW5kZW50YXRpb247aW5kZW50YXRpb24rPXdoaXRlc3BhY2U7aWYoY2xhc3NOYW1lPT1hcnJheUNsYXNzKXtmb3IoaW5kZXg9MCxsZW5ndGg9dmFsdWUubGVuZ3RoO2luZGV4PGxlbmd0aDtpbmRleCsrKXtlbGVtZW50PXNlcmlhbGl6ZShpbmRleCx2YWx1ZSxjYWxsYmFjayxwcm9wZXJ0aWVzLHdoaXRlc3BhY2UsaW5kZW50YXRpb24sc3RhY2spO3Jlc3VsdHMucHVzaChlbGVtZW50PT09dW5kZWY/XCJudWxsXCI6ZWxlbWVudCl9cmVzdWx0PXJlc3VsdHMubGVuZ3RoP3doaXRlc3BhY2U/XCJbXFxuXCIraW5kZW50YXRpb24rcmVzdWx0cy5qb2luKFwiLFxcblwiK2luZGVudGF0aW9uKStcIlxcblwiK3ByZWZpeCtcIl1cIjpcIltcIityZXN1bHRzLmpvaW4oXCIsXCIpK1wiXVwiOlwiW11cIn1lbHNle2ZvckVhY2gocHJvcGVydGllc3x8dmFsdWUsZnVuY3Rpb24ocHJvcGVydHkpe3ZhciBlbGVtZW50PXNlcmlhbGl6ZShwcm9wZXJ0eSx2YWx1ZSxjYWxsYmFjayxwcm9wZXJ0aWVzLHdoaXRlc3BhY2UsaW5kZW50YXRpb24sc3RhY2spO2lmKGVsZW1lbnQhPT11bmRlZil7cmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KStcIjpcIisod2hpdGVzcGFjZT9cIiBcIjpcIlwiKStlbGVtZW50KX19KTtyZXN1bHQ9cmVzdWx0cy5sZW5ndGg/d2hpdGVzcGFjZT9cIntcXG5cIitpbmRlbnRhdGlvbityZXN1bHRzLmpvaW4oXCIsXFxuXCIraW5kZW50YXRpb24pK1wiXFxuXCIrcHJlZml4K1wifVwiOlwie1wiK3Jlc3VsdHMuam9pbihcIixcIikrXCJ9XCI6XCJ7fVwifXN0YWNrLnBvcCgpO3JldHVybiByZXN1bHR9fTtKU09OMy5zdHJpbmdpZnk9ZnVuY3Rpb24oc291cmNlLGZpbHRlcix3aWR0aCl7dmFyIHdoaXRlc3BhY2UsY2FsbGJhY2sscHJvcGVydGllcyxjbGFzc05hbWU7aWYodHlwZW9mIGZpbHRlcj09XCJmdW5jdGlvblwifHx0eXBlb2YgZmlsdGVyPT1cIm9iamVjdFwiJiZmaWx0ZXIpe2lmKChjbGFzc05hbWU9Z2V0Q2xhc3MuY2FsbChmaWx0ZXIpKT09ZnVuY3Rpb25DbGFzcyl7Y2FsbGJhY2s9ZmlsdGVyfWVsc2UgaWYoY2xhc3NOYW1lPT1hcnJheUNsYXNzKXtwcm9wZXJ0aWVzPXt9O2Zvcih2YXIgaW5kZXg9MCxsZW5ndGg9ZmlsdGVyLmxlbmd0aCx2YWx1ZTtpbmRleDxsZW5ndGg7dmFsdWU9ZmlsdGVyW2luZGV4KytdLChjbGFzc05hbWU9Z2V0Q2xhc3MuY2FsbCh2YWx1ZSksY2xhc3NOYW1lPT1zdHJpbmdDbGFzc3x8Y2xhc3NOYW1lPT1udW1iZXJDbGFzcykmJihwcm9wZXJ0aWVzW3ZhbHVlXT0xKSk7fX1pZih3aWR0aCl7aWYoKGNsYXNzTmFtZT1nZXRDbGFzcy5jYWxsKHdpZHRoKSk9PW51bWJlckNsYXNzKXtpZigod2lkdGgtPXdpZHRoJTEpPjApe2Zvcih3aGl0ZXNwYWNlPVwiXCIsd2lkdGg+MTAmJih3aWR0aD0xMCk7d2hpdGVzcGFjZS5sZW5ndGg8d2lkdGg7d2hpdGVzcGFjZSs9XCIgXCIpO319ZWxzZSBpZihjbGFzc05hbWU9PXN0cmluZ0NsYXNzKXt3aGl0ZXNwYWNlPXdpZHRoLmxlbmd0aDw9MTA/d2lkdGg6d2lkdGguc2xpY2UoMCwxMCl9fXJldHVybiBzZXJpYWxpemUoXCJcIiwodmFsdWU9e30sdmFsdWVbXCJcIl09c291cmNlLHZhbHVlKSxjYWxsYmFjayxwcm9wZXJ0aWVzLHdoaXRlc3BhY2UsXCJcIixbXSl9fWlmKCFoYXMoXCJqc29uLXBhcnNlXCIpKXt2YXIgZnJvbUNoYXJDb2RlPVN0cmluZy5mcm9tQ2hhckNvZGU7dmFyIFVuZXNjYXBlcz17OTI6XCJcXFxcXCIsMzQ6J1wiJyw0NzpcIi9cIiw5ODpcIlxcYlwiLDExNjpcIiAgXCIsMTEwOlwiXFxuXCIsMTAyOlwiXFxmXCIsMTE0OlwiXFxyXCJ9O3ZhciBJbmRleCxTb3VyY2U7dmFyIGFib3J0PWZ1bmN0aW9uKCl7SW5kZXg9U291cmNlPW51bGw7dGhyb3cgU3ludGF4RXJyb3IoKX07dmFyIGxleD1mdW5jdGlvbigpe3ZhciBzb3VyY2U9U291cmNlLGxlbmd0aD1zb3VyY2UubGVuZ3RoLHZhbHVlLGJlZ2luLHBvc2l0aW9uLGlzU2lnbmVkLGNoYXJDb2RlO3doaWxlKEluZGV4PGxlbmd0aCl7Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO3N3aXRjaChjaGFyQ29kZSl7Y2FzZSA5OmNhc2UgMTA6Y2FzZSAxMzpjYXNlIDMyOkluZGV4Kys7YnJlYWs7Y2FzZSAxMjM6Y2FzZSAxMjU6Y2FzZSA5MTpjYXNlIDkzOmNhc2UgNTg6Y2FzZSA0NDp2YWx1ZT1jaGFySW5kZXhCdWdneT9zb3VyY2UuY2hhckF0KEluZGV4KTpzb3VyY2VbSW5kZXhdO0luZGV4Kys7cmV0dXJuIHZhbHVlO2Nhc2UgMzQ6Zm9yKHZhbHVlPVwiQFwiLEluZGV4Kys7SW5kZXg8bGVuZ3RoOyl7Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO2lmKGNoYXJDb2RlPDMyKXthYm9ydCgpfWVsc2UgaWYoY2hhckNvZGU9PTkyKXtjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtzd2l0Y2goY2hhckNvZGUpe2Nhc2UgOTI6Y2FzZSAzNDpjYXNlIDQ3OmNhc2UgOTg6Y2FzZSAxMTY6Y2FzZSAxMTA6Y2FzZSAxMDI6Y2FzZSAxMTQ6dmFsdWUrPVVuZXNjYXBlc1tjaGFyQ29kZV07SW5kZXgrKzticmVhaztjYXNlIDExNzpiZWdpbj0rK0luZGV4O2Zvcihwb3NpdGlvbj1JbmRleCs0O0luZGV4PHBvc2l0aW9uO0luZGV4Kyspe2NoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtpZighKGNoYXJDb2RlPj00OCYmY2hhckNvZGU8PTU3fHxjaGFyQ29kZT49OTcmJmNoYXJDb2RlPD0xMDJ8fGNoYXJDb2RlPj02NSYmY2hhckNvZGU8PTcwKSl7YWJvcnQoKX19dmFsdWUrPWZyb21DaGFyQ29kZShcIjB4XCIrc291cmNlLnNsaWNlKGJlZ2luLEluZGV4KSk7YnJlYWs7ZGVmYXVsdDphYm9ydCgpfX1lbHNle2lmKGNoYXJDb2RlPT0zNCl7YnJlYWt9Y2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO2JlZ2luPUluZGV4O3doaWxlKGNoYXJDb2RlPj0zMiYmY2hhckNvZGUhPTkyJiZjaGFyQ29kZSE9MzQpe2NoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpfXZhbHVlKz1zb3VyY2Uuc2xpY2UoYmVnaW4sSW5kZXgpfX1pZihzb3VyY2UuY2hhckNvZGVBdChJbmRleCk9PTM0KXtJbmRleCsrO3JldHVybiB2YWx1ZX1hYm9ydCgpO2RlZmF1bHQ6YmVnaW49SW5kZXg7aWYoY2hhckNvZGU9PTQ1KXtpc1NpZ25lZD10cnVlO2NoYXJDb2RlPXNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpfWlmKGNoYXJDb2RlPj00OCYmY2hhckNvZGU8PTU3KXtpZihjaGFyQ29kZT09NDgmJihjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChJbmRleCsxKSxjaGFyQ29kZT49NDgmJmNoYXJDb2RlPD01Nykpe2Fib3J0KCl9aXNTaWduZWQ9ZmFsc2U7Zm9yKDtJbmRleDxsZW5ndGgmJihjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChJbmRleCksY2hhckNvZGU+PTQ4JiZjaGFyQ29kZTw9NTcpO0luZGV4KyspO2lmKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KT09NDYpe3Bvc2l0aW9uPSsrSW5kZXg7Zm9yKDtwb3NpdGlvbjxsZW5ndGgmJihjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbiksY2hhckNvZGU+PTQ4JiZjaGFyQ29kZTw9NTcpO3Bvc2l0aW9uKyspO2lmKHBvc2l0aW9uPT1JbmRleCl7YWJvcnQoKX1JbmRleD1wb3NpdGlvbn1jaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdChJbmRleCk7aWYoY2hhckNvZGU9PTEwMXx8Y2hhckNvZGU9PTY5KXtjaGFyQ29kZT1zb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtpZihjaGFyQ29kZT09NDN8fGNoYXJDb2RlPT00NSl7SW5kZXgrK31mb3IocG9zaXRpb249SW5kZXg7cG9zaXRpb248bGVuZ3RoJiYoY2hhckNvZGU9c291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pLGNoYXJDb2RlPj00OCYmY2hhckNvZGU8PTU3KTtwb3NpdGlvbisrKTtpZihwb3NpdGlvbj09SW5kZXgpe2Fib3J0KCl9SW5kZXg9cG9zaXRpb259cmV0dXJuK3NvdXJjZS5zbGljZShiZWdpbixJbmRleCl9aWYoaXNTaWduZWQpe2Fib3J0KCl9aWYoc291cmNlLnNsaWNlKEluZGV4LEluZGV4KzQpPT1cInRydWVcIil7SW5kZXgrPTQ7cmV0dXJuIHRydWV9ZWxzZSBpZihzb3VyY2Uuc2xpY2UoSW5kZXgsSW5kZXgrNSk9PVwiZmFsc2VcIil7SW5kZXgrPTU7cmV0dXJuIGZhbHNlfWVsc2UgaWYoc291cmNlLnNsaWNlKEluZGV4LEluZGV4KzQpPT1cIm51bGxcIil7SW5kZXgrPTQ7cmV0dXJuIG51bGx9YWJvcnQoKX19cmV0dXJuXCIkXCJ9O3ZhciBnZXQ9ZnVuY3Rpb24odmFsdWUpe3ZhciByZXN1bHRzLGhhc01lbWJlcnM7aWYodmFsdWU9PVwiJFwiKXthYm9ydCgpfWlmKHR5cGVvZiB2YWx1ZT09XCJzdHJpbmdcIil7aWYoKGNoYXJJbmRleEJ1Z2d5P3ZhbHVlLmNoYXJBdCgwKTp2YWx1ZVswXSk9PVwiQFwiKXtyZXR1cm4gdmFsdWUuc2xpY2UoMSl9aWYodmFsdWU9PVwiW1wiKXtyZXN1bHRzPVtdO2Zvcig7O2hhc01lbWJlcnN8fChoYXNNZW1iZXJzPXRydWUpKXt2YWx1ZT1sZXgoKTtpZih2YWx1ZT09XCJdXCIpe2JyZWFrfWlmKGhhc01lbWJlcnMpe2lmKHZhbHVlPT1cIixcIil7dmFsdWU9bGV4KCk7aWYodmFsdWU9PVwiXVwiKXthYm9ydCgpfX1lbHNle2Fib3J0KCl9fWlmKHZhbHVlPT1cIixcIil7YWJvcnQoKX1yZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSl9cmV0dXJuIHJlc3VsdHN9ZWxzZSBpZih2YWx1ZT09XCJ7XCIpe3Jlc3VsdHM9e307Zm9yKDs7aGFzTWVtYmVyc3x8KGhhc01lbWJlcnM9dHJ1ZSkpe3ZhbHVlPWxleCgpO2lmKHZhbHVlPT1cIn1cIil7YnJlYWt9aWYoaGFzTWVtYmVycyl7aWYodmFsdWU9PVwiLFwiKXt2YWx1ZT1sZXgoKTtpZih2YWx1ZT09XCJ9XCIpe2Fib3J0KCl9fWVsc2V7YWJvcnQoKX19aWYodmFsdWU9PVwiLFwifHx0eXBlb2YgdmFsdWUhPVwic3RyaW5nXCJ8fChjaGFySW5kZXhCdWdneT92YWx1ZS5jaGFyQXQoMCk6dmFsdWVbMF0pIT1cIkBcInx8bGV4KCkhPVwiOlwiKXthYm9ydCgpfXJlc3VsdHNbdmFsdWUuc2xpY2UoMSldPWdldChsZXgoKSl9cmV0dXJuIHJlc3VsdHN9YWJvcnQoKX1yZXR1cm4gdmFsdWV9O3ZhciB1cGRhdGU9ZnVuY3Rpb24oc291cmNlLHByb3BlcnR5LGNhbGxiYWNrKXt2YXIgZWxlbWVudD13YWxrKHNvdXJjZSxwcm9wZXJ0eSxjYWxsYmFjayk7aWYoZWxlbWVudD09PXVuZGVmKXtkZWxldGUgc291cmNlW3Byb3BlcnR5XX1lbHNle3NvdXJjZVtwcm9wZXJ0eV09ZWxlbWVudH19O3ZhciB3YWxrPWZ1bmN0aW9uKHNvdXJjZSxwcm9wZXJ0eSxjYWxsYmFjayl7dmFyIHZhbHVlPXNvdXJjZVtwcm9wZXJ0eV0sbGVuZ3RoO2lmKHR5cGVvZiB2YWx1ZT09XCJvYmplY3RcIiYmdmFsdWUpe2lmKGdldENsYXNzLmNhbGwodmFsdWUpPT1hcnJheUNsYXNzKXtmb3IobGVuZ3RoPXZhbHVlLmxlbmd0aDtsZW5ndGgtLTspe3VwZGF0ZSh2YWx1ZSxsZW5ndGgsY2FsbGJhY2spfX1lbHNle2ZvckVhY2godmFsdWUsZnVuY3Rpb24ocHJvcGVydHkpe3VwZGF0ZSh2YWx1ZSxwcm9wZXJ0eSxjYWxsYmFjayl9KX19cmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLHByb3BlcnR5LHZhbHVlKX07SlNPTjMucGFyc2U9ZnVuY3Rpb24oc291cmNlLGNhbGxiYWNrKXt2YXIgcmVzdWx0LHZhbHVlO0luZGV4PTA7U291cmNlPVwiXCIrc291cmNlO3Jlc3VsdD1nZXQobGV4KCkpO2lmKGxleCgpIT1cIiRcIil7YWJvcnQoKX1JbmRleD1Tb3VyY2U9bnVsbDtyZXR1cm4gY2FsbGJhY2smJmdldENsYXNzLmNhbGwoY2FsbGJhY2spPT1mdW5jdGlvbkNsYXNzP3dhbGsoKHZhbHVlPXt9LHZhbHVlW1wiXCJdPXJlc3VsdCx2YWx1ZSksXCJcIixjYWxsYmFjayk6cmVzdWx0fX19aWYoaXNMb2FkZXIpe2RlZmluZShmdW5jdGlvbigpe3JldHVybiBKU09OM30pfX0pKHRoaXMpfSx7fV0sNTA6W2Z1bmN0aW9uKF9kZXJlcV8sbW9kdWxlLGV4cG9ydHMpe21vZHVsZS5leHBvcnRzPXRvQXJyYXk7ZnVuY3Rpb24gdG9BcnJheShsaXN0LGluZGV4KXt2YXIgYXJyYXk9W107aW5kZXg9aW5kZXh8fDA7Zm9yKHZhciBpPWluZGV4fHwwO2k8bGlzdC5sZW5ndGg7aSsrKXthcnJheVtpLWluZGV4XT1saXN0W2ldfXJldHVybiBhcnJheX19LHt9XX0se30sWzFdKSgxKX0pOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbCcpXG4gICwgZWxlbWVudCA9IHJlcXVpcmUoJy4uLy4uL2VsZW1lbnQnKVxuICAsIHV0aWxIYXNoID0gcmVxdWlyZSgnLi4vLi4vLi4vdXRpbC9oYXNoJylcbiAgLCB2T2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vb2JqZWN0JylcblxuLyp0aGlzIGZpbGUgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCB0aGUgbmV0d29ya2RhdGEgQ2xhc3NcbiAgaXQgb25seSByZWFkcyBvdXQgbW9kZWxzIGZvciBlbGVtZW50cyBzbyB5b3UgY2FuIG1ha2UgYSBzdWJzY3JpcHRpb25cbiovXG5cbmZ1bmN0aW9uIHNvcnRGaWVsZCggZmlsdGVyLCBvYmogKSB7XG4gIGlmKCBmaWx0ZXIuc29ydCAmJiBmaWx0ZXIuc29ydC5maWVsZCApIFxuICB7XG4gICAgdmFyIHNvcnQgPSB7ICQ6e30gfVxuICAgIHNvcnQuJFtmaWx0ZXIuc29ydC5maWVsZF0gPSB0cnVlXG4gICAgdXRpbC5tZXJnZSggb2JqLCBzb3J0IClcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuLy9UT0RPOiBoYXMgdG8gd29yayBpbiB0aGUgaHViXG52YXIgZGlzYWJsZVNlbGVjdGlvbnMgPSB0cnVlXG5cbmV4cG9ydHMucGFyc2VEYXRhID0gZnVuY3Rpb24oIHZhbCwgZnJvbXRhcmdldHMsIGxvZ2dlciApIHtcblxuXG4gIC8vaW1wb3J0YW50IGZvciB1blN1YnNjcmliZSA/Pz9cbiAgICAvLyBjb25zb2xlLmxvZygnTEVUUyBQQVJTRSBEQVRBIScuY3lhbi5pbnZlcnNlICwgdmFsLCBKU09OLnN0cmluZ2lmeShmcm9tdGFyZ2V0cykpXG4gIFxuXG4gIC8vIGNvbnNvbGUubG9nKCdMRVRTIFBBUlNFIERBVEEhJy5jeWFuLmludmVyc2UgLCB2YWwsIEpTT04uc3RyaW5naWZ5KGZyb210YXJnZXRzKSlcblxuICBpZighdmFsKSByZXR1cm5cbiAgICAvLyBjb25zb2xlLmxvZygnTEVUUyBQQVJTRSBEQVRBITInLmN5YW4uaW52ZXJzZSAsIHZhbCwgSlNPTi5zdHJpbmdpZnkoZnJvbXRhcmdldHMpKVxuXG4gIHZhciBzdWJzb2JqID0ge31cbiAgICAsIGYgPSB2YWwuX2ZpbHRlclxuICAgICwgdGFyZ2V0cyA9IGZyb210YXJnZXRzIHx8IHZhbC5fX3N1YlxuXG4gIGlmICh0YXJnZXRzKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ3RhcmdldHMnLCB0YXJnZXRzKVxuICAgIGlmIChmICYmICFkaXNhYmxlU2VsZWN0aW9ucykge1xuICAgICAgaWYoIXN1YnNvYmpbJyonXSkgc3Vic29ialsnKiddPVtdXG4gICAgICBzdWJzb2JqWycqJ10ucHVzaChbXG4gICAgICAgIHV0aWwuY2xvbmUoZiwge3N1YnNPYmo6dHJ1ZSwgZm46dHJ1ZSwgdHlwZTp0cnVlfSlcbiAgICAgICAgLCBzb3J0RmllbGQoZiwgZnJvbXRhcmdldHMgfHwgeyAkOiB0YXJnZXRzIH0pXG4gICAgICBdKVxuXG4gICAgLy8gY29uc29sZS5sb2coICdJTSBET0lORyBTRUxFQ1RTIHBhcnNlRGF0ZWxleCcsIHN1YnNvYmogKVxuICAgIC8vVEVNUEZJWCEhISFcbiAgICBmb3IodmFyIGkgaW4gc3Vic29ialsnKiddWzFdICkge1xuICAgICAgLy93ZWwgZmYgZGUgZmllbGRzIG9vayBkb2VuIHByb2JcblxuICAgICAgc3Vic29ialtpXSA9IHN1YnNvYmpbJyonXVsxXVtpXVxuICAgIH1cbiAgICBkZWxldGUgc3Vic29ialsnKiddXG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAndGFyZ2V0cyBJTSBET0lORyBTRUxFQ1RTIHBhcnNlRGF0ZWxleCcsIHRhcmdldHMgKVxuXG4gICAgICBzdWJzb2JqID0gdGFyZ2V0c1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0xFVFMgUEFSU0UgREFUQSE0Jy5jeWFuLmludmVyc2UgLCB2YWwsIEpTT04uc3RyaW5naWZ5KGZyb210YXJnZXRzKSlcblxuICAgIC8vIGNvbnNvbGUud2FybiggJ2NhbnRcXCd0IGZpbmQgdGFyZ2V0IC0tIGxldHMgZG8gc3R1ZmYhJywgdmFsICApXG4gICAgLy9UT0RPOmd1YXJkIHZvb3IgYWxzIGhldCBoZXQgbmlldCB3aWwgLS0gbWlzY2hpZW5kIGRvb3IgX3N1YnMgem9la2VuXG5cbiAgICAvLyBpZih2YWwuX3BhdGgpIHtcbiAgICAvLyAgIGNvbnNvbGUubG9nKHZhbC5fcGF0aClcbiAgICAvLyB9XG5cbiAgICAvL25vIHRyYWdldHMgZG9udCBkbyBhbnl0aGluZz9cbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCdSRVNVTFQhJywgSlNPTi5zdHJpbmdpZnkoc3Vic29iaikpXG5cbiAgcmV0dXJuIHN1YnNvYmpcbn1cblxuZnVuY3Rpb24gc2V0RmxhZyggb2JqLCBzdHJpbmcsIGZsYWcsIGZpZWxkLCB2YWwsIGZyb20sIGVsZW0gKSB7XG5cblxuXG4gIHZhciBub25DbG91ZERhdGFCaW5kaW5nc1xuICAgICwgZnJvbUtleVxuXG4gICAgLCBiZVRyaXBwcGluXG5cblxuICBpZiggZnJvbSApIHtcbiAgICBmcm9tS2V5ID0gZnJvbS5fbmFtZSAhPT0gdm9pZCAwID8gZnJvbS5fbmFtZSA6IGZyb21cblxuICAgIGlmKCBmcm9tIGluc3RhbmNlb2Ygdk9iamVjdCkge1xuXG4gICAgICAvL3RlZ2Vub3ZlciBnZXN0ZWxkZSBiaWpcbiAgICAgIC8vIGlmKGZyb20uX190ID09PSA0KSB7XG4gICAgICAgIC8vIGlmKGZyb20uX3ZhbCAmJiBmcm9tLl92YWwuY2xvdWQpIHtcbiAgICAgICAgICAvL2hhYWwganVpc3QgZmllbGQgd2VnXG4gICAgICAgIC8vIH1cbiAgICAgIC8vIH0gXG4gICAgICAvLyBjb25zb2xlLmxvZygnRlJPTSEnLCBmcm9tLl9uYW1lLCBmcm9tLl9wYXRoIClcbiAgICAgIGZyb21LZXkgPSBmcm9tLl9uYW1lXG4gICAgfVxuXG4gICAgaWYoZnJvbSBpbnN0YW5jZW9mIEFycmF5ICYmIGZyb21bMV0pIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdiZSB0cmlwcGluZyEnLCBmcm9tKVxuICAgICAgLy8gICBmcm9tS2V5ID0gZnJvbVsxXSAmJiBmcm9tWzFdLl9uYW1lXG5cbiAgICAgIC8vIGJlVHJpcHBwaW4gPSBmcm9tWzBdLl9uYW1lXG5cbiAgICB9XG5cbiAgfVxuXG4gIHZhciBkZCA9IGVsZW0gJiYgZnJvbSAmJiAoIGVsZW0uX2QgfHwgZWxlbS5jaGVja1BhcmVudCgnZGF0YScsIHRydWUpIClcblxuICAvLyBpZihiZVRyaXBwcGluKSB7XG4gIC8vICAgY29uc29sZS5sb2coZGQsIGZyb21LZXksIGJlVHJpcHBwaW4pXG4gIC8vIH1cblxuXG4gIGlmIChmaWVsZCA9PT0gJ2NvbGxlY3Rpb24nKSB7XG4gICAgdmFyIG9iajJcblxuICAgIGlmIChmbGFnLmZpbHRlciAmJiBmbGFnLmZpbHRlci52YWwhPT10cnVlICYmICFkaXNhYmxlU2VsZWN0aW9ucykgXG4gICAge1xuICAgICAgLy9kaXQgbm9nIGhhbmRlbGVuIG9wIHJlZnNcbiAgICAgIG9iajIgPSB7fVxuXG5cbiAgICAgIC8vRU5BQkxFIEZPUiBTRUxFQ1RJT05cbiAgICAgIC8vIGlmIChzdHJpbmcgPT09IHRydWUpIHtcblxuICAgICAgLy8gICBzdHJpbmcgPSAnKidcbiAgICAgIC8vIH0gZWxzZSB7XG5cbiAgICAgIC8vICAgc3RyaW5nID0gc3RyaW5nICsgJy4qJ1xuICAgICAgLy8gfVxuICAgICAgdmFyIGYgPSBmbGFnLmZpbHRlci5yYXdcblxuICAgICAgICAvLyBjb25zb2xlLmxvZyggJ1NFVCBGTEFHJywgYXJndW1lbnRzIClcblxuXG4gIC8vIGNvbnNvbGUubG9nKCAnRklFTEQhOicsIGZpZWxkICwgJ0ZST006JywgZnJvbSwgIHN0cmluZy5zcGxpdCgnLicpLCBzdHJpbmcgKVxuXG4gICAgICB2YXIgYXJyID0gdXRpbC5wYXRoKG9iaiwgc3RyaW5nLnNwbGl0KCcuJyksIFtdKVxuXG4gICAgICBhcnIucHVzaCggXG4gICAgICAgIFtmLCB7XG4gICAgICAgICAgJDogc29ydEZpZWxkKGYsb2JqMilcbiAgICAgICAgfV1cbiAgICAgIClcblxuICAgICAgLy9vYmosIHBhdGgsIHZhbCwgb3ZlcndyaXRlXG5cbiAgICAgIC8vVEVNUEZJWCEhISFcbiAgICAgIHZhciB0ZW1wID0gdXRpbC5wYXRoKCBvYmosIHN0cmluZy5zcGxpdCgnLicpLCB7fSwgdHJ1ZSApXG4gICAgICBmb3IodmFyIGkgaW4gYXJyW2Fyci5sZW5ndGgtMV1bMV0gKSB7XG4gICAgICAgIC8vd2VsIGZmIGRlIGZpZWxkcyBvb2sgZG9lbiBwcm9iXG5cbiAgICAgICAgdGVtcFtpXSA9IGFyclthcnIubGVuZ3RoLTFdWzFdW2ldXG4gICAgICB9XG4gICAgICBhcnIgPSB0ZW1wXG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJ0lNIERPSU5HIFNFTEVDUFMgQ09MIENPTCEnLCBhcnIgKVxuXG5cbiAgICB9IGVsc2Uge1xuXG4gICAgICB2YXIgZiA9IHN0cmluZyA9PT0gdHJ1ZSA/ICckJyA6IHN0cmluZyArICcuJCdcbiAgICAgICAgLCBwID0gIGYuc3BsaXQoJy4nKVxuXG4gICAgICAgICwgc3BlY2lhbEZpeFxuXG4gICAgICBpZiggZGQgJiYgZGRbIGZyb21LZXkgXSApIFxuICAgICAge1xuICAgICAgICBub25DbG91ZERhdGFCaW5kaW5ncyA9IHRydWVcbiAgICAgICAgaWYoIHBbMF0gPT09IGZyb21LZXkgKSBcbiAgICAgICAge1xuICAgICAgICAgIHAuc2hpZnQoKVxuICAgICAgICAgIG5vbkNsb3VkRGF0YUJpbmRpbmdzID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggbm9uQ2xvdWREYXRhQmluZGluZ3MgKSBcbiAgICAgIHtcbiAgICAgICAgaWYoc3BlY2lhbEZpeCkge1xuICAgICAgICAgIG9iai5zcGVjaWFsRml4ID0gZnJvbUtleVxuICAgICAgICAgIGlmKGJlVHJpcHBwaW4pIHtcbiAgICAgICAgICAgIG9iai5zcGVjaWFsRml4ID0gWyBmcm9tS2V5LCBiZVRyaXBwcGluIF1cbiAgICAgICAgICB9XG4gICAgICAgICAgb2JqMiA9IHV0aWwucGF0aChvYmosIHAgLCB7fSlcbiAgICAgICAgICByZWFkTW9kZWwoZmxhZy5lbGVtZW50Ll92YWwgaW5zdGFuY2VvZiBlbGVtZW50ID8gZmxhZy5lbGVtZW50Ll92YWwgOiBmbGFnLmVsZW1lbnQuX3ZhbC5iYXNlLCBvYmoyIClcbiAgICAgICAgfVxuICAgICAgfSBcbiAgICAgIGVsc2UgXG4gICAgICB7XG4gICAgICAgIG9iajIgPSB1dGlsLnBhdGgob2JqLCBwICwge30pXG4gICAgICAgIHJlYWRNb2RlbChmbGFnLmVsZW1lbnQuX3ZhbCBpbnN0YW5jZW9mIGVsZW1lbnQgPyBmbGFnLmVsZW1lbnQuX3ZhbCA6IGZsYWcuZWxlbWVudC5fdmFsLmJhc2UsIG9iajIgKVxuICAgICAgfVxuXG4gICAgfVxuXG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggICd4eHhYWDExMTIyMjJYWHh4Jywgc3RyaW5nLCBvYmogKSAvLywgZnJvbUtleSwgZWxlbS5fZCwgZWxlbS5kYXRhLCBlbGVtLmNoZWNrUGFyZW50KCdkYXRhJywgdHJ1ZSkgKVxuXG5cbiAgfSBlbHNlIHtcblxuICAgIGlmKCBkZCAmJiBkZFsgZnJvbUtleSBdICkgXG4gICAge1xuICAgICAgbm9uQ2xvdWREYXRhQmluZGluZ3MgPSB0cnVlXG4gICAgfVxuXG4gICAgaWYgKCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheSApIFxuICAgIHtcbiAgICAgIGZvciAodmFyIGkgaW4gc3RyaW5nKSBcbiAgICAgIHtcbiAgICAgICAgaWYoIG5vbkNsb3VkRGF0YUJpbmRpbmdzIClcbiAgICAgICAge1xuICAgICAgICAgIC8vVE9ETzogdGhpcyBpcyBhIHRlbXBmaXhcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnTk9OIGNsb3VkIGJpbmRpbmdzJywgc3RyaW5nLCBzdHJpbmdbaV0pXG4gICAgICAgICAgaWYoIHN0cmluZ1tpXSBpbnN0YW5jZW9mIEFycmF5ICkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyFAIUAhQCcpXG4gICAgICAgICAgICBzdHJpbmdbaV0gPSBzdHJpbmdbaV1bMF1cbiAgICAgICAgICB9XG4gICAgICAgICAgc3RyaW5nW2ldID0gc3RyaW5nW2ldLnNwbGl0KCcuJylcbiAgICAgICAgICBpZiggc3RyaW5nW2ldWzBdID09PSBmcm9tS2V5ICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgc3RyaW5nW2ldLnNoaWZ0KClcbiAgICAgICAgICAgIHV0aWwucGF0aCggb2JqLCBzdHJpbmdbaV0sIHRydWUgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICAvL1RPRE86IHRoaXMgaXMgYSB0ZW1wZml4XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ09CSjonICwgb2JqLCAnU1RSSU5HW2ldOicsIHN0cmluZ1tpXSwgJ1NUUklORzonLCBzdHJpbmcsIGZyb21LZXkpXG4gICAgICAgICAgIGlmKCBzdHJpbmdbaV0gaW5zdGFuY2VvZiBBcnJheSApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcyIUAhQCFAJylcbiAgICAgICAgICAgIHN0cmluZ1tpXSA9IHN0cmluZ1tpXVswXVxuICAgICAgICAgIH1cbiAgICAgICAgICB1dGlsLnBhdGgob2JqLCBzdHJpbmdbaV0uc3BsaXQoJy4nKSwgdHJ1ZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gXG4gICAgZWxzZSBpZiAoIHN0cmluZyAhPT0gdHJ1ZSAmJiB0eXBlb2Ygc3RyaW5nID09PSAnc3RyaW5nJyApIFxuICAgIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coICAneHh4WFhYWHh4Jywgc3RyaW5nLCBvYmogKSAvLywgZnJvbUtleSwgZWxlbS5fZCwgZWxlbS5kYXRhLCBlbGVtLmNoZWNrUGFyZW50KCdkYXRhJywgdHJ1ZSkgKVxuXG4gICAgICBpZiggbm9uQ2xvdWREYXRhQmluZGluZ3MgKVxuICAgICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyggbm9uQ2xvdWREYXRhQmluZGluZ3MgLCAnTk9OQ0xPVUQnKVxuICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zcGxpdCgnLicpXG4gICAgICAgICAgaWYoIHN0cmluZ1swXSA9PT0gZnJvbUtleSApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0cmluZy5zaGlmdCgpXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnRklFTEQhOjIyMjIyMicsIHN0cmluZyApXG5cbiAgICAgICAgICAgIGlmKHN0cmluZy5sZW5ndGggPiAwKSB1dGlsLnBhdGgoIG9iaiwgc3RyaW5nLCB0cnVlIClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coIG5vbkNsb3VkRGF0YUJpbmRpbmdzICwgJ05PTkNMT1VEJywgc3RyaW5nLCBvYmogKVxuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyggICd4eHh4eCcsIHN0cmluZywgb2JqICkgLy8sIGZyb21LZXksIGVsZW0uX2QsIGVsZW0uZGF0YSwgZWxlbS5jaGVja1BhcmVudCgnZGF0YScsIHRydWUpIClcbiAgICAgICAgdXRpbC5wYXRoKCBvYmosIHN0cmluZy5zcGxpdCgnLicpLCB0cnVlIClcbiAgICAgIH1cbiAgICB9IFxuICAgIGVsc2UgXG4gICAge1xuICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0+IDInLmludmVyc2UsIHN0cmluZywgb2JqLCBmbGFnLCBmaWVsZClcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3h4eHh4eCcpXG4gICAgICAvLyBvYmpbJ19fI19fJ10gPSB0cnVlXG4gICAgICAvLyBvYmogPSB0cnVlO1xuICAgICAgLy8gY29uc29sZS5sb2coJyEhIScsb2JqLCBwYXJlbnQpO1xuICAgICAgLy8gb2JqWycjJ10gPSB0cnVlO1xuICAgIH1cbiAgICBcblxuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3JlKCBvYmosIGZsYWcsIGZpZWxkLCB2YWwsIGZyb20sIGVsZW0gKSB7XG5cbiAgLy8gY29uc29sZS5sb2coJ1NUT1JFJywgYXJndW1lbnRzIClcblxuICBpZiAoZmxhZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBmbGFnLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2V0RmxhZyhvYmosIGZsYWdbaV0uX2ZsYWcuZGF0YVsyXSwgZmxhZywgZmllbGQsIHZhbCwgZnJvbSwgZWxlbSApXG5cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0+Jy5yZWQsZmxhZylcblxuICAgIHNldEZsYWcob2JqLCBmbGFnLl9mbGFnLmRhdGFbMl0sIGZsYWcsIGZpZWxkLCB2YWwsIGZyb20sIGVsZW0gKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRNb2RlbCggZWxlbSwgb2JqLCB2YWwsIGZyb20gLCBpZ25vcmVmaWVsZCkge1xuXG4gIC8vIGNvbnNvbGUubG9nKCAnbGV0cyByZWFkIG1vZGVsJy55ZWxsb3cuaW52ZXJzZSwgdmFsICYmIHZhbC5fcGF0aCB8fCAnbm8gdmFsUGF0aCcsIGZyb20gJiYgZnJvbS5fcGF0aCB8fCAnbm8gZnJvbVBhdGgnICwgdmFsLCBlbGVtLCBvYmosIHZhbCwgZnJvbSApXG4gICAgLy9oaWVyIG1vZXQgaGV0IGdlY29tYmluZWVyZCB3b3JkZW4gbWV0IGVlbiB2YWx1ZSB3YWFyIGhldCBhYW4gZ2ViaW5kIGlzIVxuXG4gIGlmIChlbGVtLm1vZGVsICYmIChlbGVtLm1vZGVsLmZsYWdzfHxlbGVtLm1vZGVsLnN1YnNjcmlwdGlvbnx8ZWxlbS5tb2RlbC5maWVsZCkpIHtcbiAgICBcbiAgICAvLyBpZihvYmopIGNvbnNvbGUubG9nKCdYWFgxMjEyMTJYWFggQ09MTEVDVElPTicsICBlbGVtLm1vZGVsLmZpZWxkICYmIGVsZW0ubW9kZWwuZmllbGQudmFsIClcbiAgICAvLyBjb25zb2xlLmxvZygnU0VUIFNPUlRGSUVMRCEgMi4xMicsIEpTT04uc3RyaW5naWZ5KG9iaixmYWxzZSwyKSwgZWxlbS5tb2RlbC5maWVsZCAmJiBlbGVtLm1vZGVsLmZpZWxkLnZhbClcblxuICAgIHZhciBhID0gb2JqXG4gICAgICAsIGZpZWxkXG4gICAgICAsIGRvSXRJZ25vcmVGbGFnc1xuXG4gICAgICAvL1tcInVzZXJzXCIsIFwiVV9iYTMyMTVhMWIxMDM4YTcwXCIsIFwibmF2aWdhdGlvblwiLCBcImVwaXNvZGVcIl0gXG4gICAgLy8gY29uc29sZS5sb2coICdcXG5cXG5cXG5cXG5cXG4tLS0tLS0tLT4nLCBlbGVtLm1vZGVsLmZpZWxkICYmIGVsZW0ubW9kZWwuZmllbGQudmFsLCBlbGVtLm1vZGVsLnBhcnNpbmcgJiYgIWVsZW0ubW9kZWwucGFyc2VkICApXG5cbiAgICBpZihpZ25vcmVmaWVsZCkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ1NUT1AhIGlnbm9yZWZpZWxkJywgb2JqLCBlbGVtLm1vZGVsLmZpZWxkICYmIGVsZW0ubW9kZWwuZmllbGQudmFsLCBmcm9tLCBmcm9tICYmIGZyb20uX3BhdGgpXG4gICAgICAvLyBkZWJ1Z2dlclxuICAgIH1cbiAgICAvL1RPRE86IGNvbXBhcmUgYXJyYXlzIFxuICAgIGVsc2UgaWYoZWxlbS5tb2RlbC5maWVsZCAmJiBlbGVtLm1vZGVsLmZpZWxkLnZhbCAmJiAhZWxlbS5tb2RlbC5wYXJzaW5nICYmICFlbGVtLm1vZGVsUGFyc2VkICYmICggdHlwZW9mIGZyb20gIT09ICdzdHJpbmcnIHx8IGVsZW0ubW9kZWwuZmllbGQudmFsID09PSBmcm9tICApICApIHtcbiAgICAgIGZpZWxkID0gZWxlbS5tb2RlbC5maWVsZC52YWwuc3BsaXQoJy4nKVxuICAgICAgXG4gICAgICBpZiggZWxlbS5tb2RlbC5maWVsZC52YWwgPT09IGZyb20gKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0hFUkUgSVRTIElOVEVSRVNUSU5HIERPJywgZWxlbS5tb2RlbC5maWVsZC52YWwgLCBmcm9tIClcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYSA9IHV0aWwucGF0aChvYmosZmllbGQse30sdHJ1ZSlcbiAgICAgICAgZG9JdElnbm9yZUZsYWdzID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKGZyb20gJiYgZWxlbS5tb2RlbC5maWVsZCAmJiBlbGVtLm1vZGVsLmZpZWxkLnZhbCAhPT0gZnJvbSkge1xuICAgICAgICByZXR1cm4gdm9pZCAwXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoZWxlbS5tb2RlbCAmJiBlbGVtLm1vZGVsLnN1YnNjcmlwdGlvbiApIHtcblxuICAgICAgdmFyIHN1YnMgPSBlbGVtLm1vZGVsLnN1YnNjcmlwdGlvbi5yYXdcbiAgICAgIGlmKHN1YnMgPT09IHRydWUpIHtcbiAgICAgICAgaWYoZmllbGQpIHtcbiAgICAgICAgICBpZihmaWVsZC5sZW5ndGg+MSkge1xuICAgICAgICAgIGEgPSB1dGlsLnBhdGgob2JqLGZpZWxkLHRydWUsdHJ1ZSlcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2JqW2ZpZWxkWzBdXSA9IHRydWVcbiAgICAgICAgICAgIGEgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgc3ViID0gZWxlbS5tb2RlbC5zdWJzY3JpcHRpb24ucmF3XG4gICAgICAgIGlmKCB0eXBlb2Ygc3ViID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB2YXIgb2xkID0gc3ViXG4gICAgICAgICAgc3ViID0ge31cbiAgICAgICAgICBzdWJbb2xkXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICB1dGlsLm1lcmdlKGEsc3ViKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgaW4gZWxlbS5tb2RlbC5mbGFncykge1xuICAgICAgc3RvcmUoYSwgZWxlbS5tb2RlbC5mbGFnc1tpXSwgaSwgdmFsLCBmcm9tLCBlbGVtIClcbiAgICB9XG4gICAgXG4gIH1cblxuICBpZiggIWVsZW0ubW9kZWwgfHwgIWVsZW0ubW9kZWwuYmxvY2sgfHwgIWVsZW0ubW9kZWwuYmxvY2sudmFsICkge1xuXG4gICAgZm9yIChcbiAgICAgIHZhciBjaGlsZHJlbiA9IGVsZW0uY2hpbGRyZW5cbiAgICAgICwgY2hpbGRcbiAgICAgICwgY2hpbGQkID0gMFxuICAgICAgLCBjaGlsZHJlbiRsZW4gPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGhcbiAgICAgIDsgY2hpbGQkIDwgY2hpbGRyZW4kbGVuXG4gICAgICA7IGNoaWxkID0gY2hpbGQkKytcbiAgICApIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5bY2hpbGQkXVxuICAgICAgaWYgKCghY2hpbGQubW9kZWwgfHwgKCFjaGlsZC5tb2RlbC5pbmhlcml0IHx8IGNoaWxkLm1vZGVsLmluaGVyaXQudmFsIT09ZmFsc2UpKVxuICAgICAgICAmJiAhY2hpbGQuX2NvbCAmJiAhY2hpbGQuZGF0YSB8fCBjaGlsZC5fZGZyb20pIHsgLy9kaXQga2FuIGJldGVyIVxuICAgICAgICByZWFkTW9kZWwoY2hpbGQsIGEgfHwgb2JqLCB2YWwsIGZyb20gKVxuICAgICAgLy9lbGVtLCBvYmosIHZhbCwgZnJvbSAsIGlnbm9yZWZpZWxkLCBmaWVsZFxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmKG9ialsnX18jX18nXSkge1xuICAgIC8vIG9iai4kID0gdHJ1ZVxuICAgIC8vIHV0aWwubWVyZ2Uob2JqLCBvYmpbJ19fI19fJ10pXG4gICAgZGVsZXRlIG9ialsnX18jX18nXVxuICB9XG5cbiAgcmV0dXJuIGVsZW0ubW9kZWwgJiYgZWxlbS5tb2RlbC5ibG9jayAmJiBlbGVtLm1vZGVsLmJsb2NrLnZhbD09PSdhbGwnID8gdm9pZCAwIDogb2JqXG59XG5cbnV0aWwuZGVmaW5lKGVsZW1lbnQsICdnZXRNb2RlbCcsIGZ1bmN0aW9uKCB2YWwsIGZyb20sIGlnbm9yZWZpZWxkICkge1xuXG4gIHZhciBzdWJzY3JpcHRpb24gPSByZWFkTW9kZWwoIHRoaXMsIHt9LCB2YWwsIGZyb20sIGlnbm9yZWZpZWxkIClcblxuICAvLyBjb25zb2xlLmVycm9yKCdwYXJzZWQgc3Vic2NyaXB0aW9uIScsIEpTT04uc3RyaW5naWZ5KHN1YnNjcmlwdGlvbiwgZmFsc2UsIDIpIClcbiAgLy93YWFyb20ga29tdCBpZSAzeCBleHRyYT9cblxuICByZXR1cm4gIXV0aWwuZW1wdHkoIHN1YnNjcmlwdGlvbiApID8gc3Vic2NyaXB0aW9uIDogbnVsbFxufSkiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vLi4vb2JqZWN0JylcbiAgLCBkYXRhID0gcmVxdWlyZSgnLi4vLi4vLi4vZGF0YScpXG4gICwgVmFsdWUgPSByZXF1aXJlKCcuLi8uLi8uLi92YWx1ZScpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uLy4uLy4uL3V0aWwnKVxuICAsIHZpZ291ciA9IHJlcXVpcmUoJy4uLy4uLy4uLycpXG4gICwgX25ldHdvcmtkYXRhID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gdmlnb3VyLk5ldHdvcmtkYXRhID0gZGF0YS5uZXcoe1xuICAgICAgbWl4ZWQ6IDQsIC8vbWlzY2hpZW4gbmlldCBtaXhlZFxuICAgICAgbWVyZ2U6IHRydWVcbiAgICB9KVxuICAsIF9zdWIgPSAnc3Vic2NyaWJlJ1xuICAsIF91bnN1YiA9ICd1bicgKyBfc3ViXG4gICwgX2xpc3RlbmVyID0gJ0xpc3RlbmVyJ1xuICAsIF9hbCA9ICdhZGQnICsgX2xpc3RlbmVyXG4gICwgX3JsID0gJ3JlbW92ZScgKyBfbGlzdGVuZXJcbiAgLCBfcHJvdG8gPSBvYmplY3QucHJvdG90eXBlXG4gICwgX3Byb3RvQWRkTGlzdGVuZXIgPSBfcHJvdG9bX2FsXVxuICAsIF9wcm90b1JlbW92ZUxpc3RlbmVyID0gX3Byb3RvW19ybF1cbiAgLCBfY2hlY2tTdWJzY3JpcHRpb24gPSBmdW5jdGlvbiggZmllbGQsIHZhbCApIHtcbiAgICAgIHZhciBhID0gdGhpc1xuICAgICAgd2hpbGUgKGEgJiYgYS5fX3QgPT09IDQpIHtcbiAgICAgICAgaWYoYS5fX2Jsb2NrKSByZXR1cm5cbiAgICAgICAgYSA9IGEuX3ZhbFxuICAgICAgfVxuICAgICAgLy8gY29uc29sZS5sb2coZmllbGQsIGEpXG4gICAgICBpZigoYSBpbnN0YW5jZW9mIF9uZXR3b3JrZGF0YSkgJiYgYVtmaWVsZF0pIGFbZmllbGRdKHZhbCwgdGhpcylcbiAgICB9XG4gICwgViA9IHJlcXVpcmUoJy4uLy4uLy4uLycpXG5cbl9uZXR3b3JrZGF0YS5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfc3VicycsJ19jb21wbGV0ZScpXG4vLydfJyArIF9zdWIsICdfJyArIF91bnN1Yiwgd2UgZG9udCB1c2UgdGhlcmUgbm93XG4vLyBfc3Vic2NyaWJlKF9zdWIpO1xuLy8gX3N1YnNjcmliZShfdW5zdWIpO1xuXG5cbi8vVE9ETzogZml4IG1hcmshISEhISEhISEhISBtYXJrOnRydWVcbnV0aWwuZGVmaW5lKF9uZXR3b3JrZGF0YSxcbiAgJ2dldCcsIGZ1bmN0aW9uKCB2YWwsIHNldCwgbm90c2VsZiwgc3RhbXAgKSB7XG4gICAgXG4gICAgLy8gSU0gR0VUVElORyEgW1widXNlcnNcIiwgXCJ1X2JhMzIxNWExYjEwMzhhNzBcIiwgXCJtdHZEYXRhXCIsIFwiTkxcIiwgXCJubFwiLCBcInNob3dzXCJdIHVuZGVmaW5lZFxuICAgIC8vb2JqLCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYsIHVpZCwgaVxuICAgIC8vIHZhciBibGEgPSAodmFsIGluc3RhbmNlb2YgQXJyYXkpID8gdmFsIDogU3RyaW5nKHZhbCkuc3BsaXQoJy4nKVxuICAgIC8vIGNvbnNvbGUubG9nKCdJTSBHRVRUSU5HIScsIGJsYSwgdmFsLCBzZXQsIHRoaXMsIHRoaXMucGF0aClcblxuICAgIC8vVE9ETzogQWx3YXlzIGdpdmUgbWUgdGhlIG5vbi1mcm9tIGlzIHBvc3NpYmxlXG4gICAgLy8gY29uc29sZS53YXJuKCdHZXQgLS0gc2VsZiBpcyBub3cgb24gb24gZGVmdWFsdCBzaG91bGQgYmVjb21lIHNvbWV0aGluZyBkaWZmZXJlbnQhJylcbiAgICAvL29iaiwgcGF0aCwgdmFsLCBvdmVyd3JpdGUsIHdyaXRlSGFuZGxlciwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBzZWxmLFxuICAgIC8vY29uZGl0aW9uYWwgc2VsZlxuXG4gICAgcmV0dXJuIHRoaXMucGF0aFxuICAgICAgKCAodmFsIGluc3RhbmNlb2YgQXJyYXkpID8gdmFsIDogU3RyaW5nKHZhbCkuc3BsaXQoJy4nKVxuICAgICAgLCBzZXQgIT09IHZvaWQgMCA/IHNldCA6IHt9XG4gICAgICAsIGZhbHNlXG4gICAgICAsIGZhbHNlXG4gICAgICAsIGZhbHNlXG4gICAgICAsIHN0YW1wIHx8IGZhbHNlIC8vc3RhbXB5XG4gICAgICAsIHRydWVcbiAgICAgICwgIW5vdHNlbGZcbiAgICAgIClcblxuICB9LFxuICAvLyAnX2NoYW5nZXZvYmonLCBmdW5jdGlvbih2YWwsc3RhbXApIHtcbiAgLy8gICBjb25zb2xlLmVycm9yKHZhbCxzdGFtcClcbiAgLy8gICByZXR1cm4gX2NoYW5nZXZvYmouYXBwbHkodGhpcyxhcmd1bWVudHMpXG4gIC8vIH0sXG4gIC8vICdfaG9vaycsIGZ1bmN0aW9uKHZhbCwgcGFyYW0pIHtcbiAgLy8gICBmb3IgKHZhciBpIGluIHBhcmFtKSB7XG4gIC8vICAgICB0aGlzWydfJyArIGldID0gcGFyYW1baV07XG4gIC8vICAgfVxuICAvLyB9LCAvL2RvbnQgdXNlIHRoaXMgbm93IHNvIGxldHMgYWRkIHdoZW4gdXNlZFxuICBfYWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgLy8gY29uc29sZS5sb2coJ0xFVFMgR08hJywgX3N1YiwgdmFsLCAhIXRoaXNbX3N1Yl0pXG4gICAgaWYodGhpc1tfc3ViXSkgdGhpc1tfc3ViXSh2YWwpXG4gICAgX3Byb3RvQWRkTGlzdGVuZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gIH0sXG4gIF9ybCwgZnVuY3Rpb24oIHZhbCwgbWFyayApIHtcbiAgICBpZiAodGhpcy5fbGlzdGVuZXJzICYmIHRoaXNbX3Vuc3ViXSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBfTCcucmVkLmludmVyc2UsIG1hcmspXG4gICAgICB0aGlzW191bnN1Yl0oIG1hcmsgKVxuICAgIH1cbiAgICBfcHJvdG9SZW1vdmVMaXN0ZW5lci5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgfVxuKTtcblxuLy8tLS0tLS0tREFUQS0tLS0tLS0tLVxudXRpbC5kZWZpbmUoZGF0YSwgXG4gIF9hbCwgZnVuY3Rpb24odmFsKSB7XG4gICAgLy8gY29uc29sZS5sb2coJzAtLS0tLS0tLS0+Jyx2YWwpXG4gICAgaWYoIXRoaXMuX19ibG9jaykgX2NoZWNrU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgX3N1YiwgdmFsKTtcbiAgICBfcHJvdG9BZGRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9LFxuICBfcmwsIGZ1bmN0aW9uKHZhbCwgbWFyaykge1xuICAgICAvLyBjb25zb2xlLmVycm9yKCcyLjEgUkVNT1ZFIF9MJywgbWFyaywgdmFsLCBfdW5zdWIpXG4gICAgaWYoIXRoaXMuX19ibG9jaykgX2NoZWNrU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgX3Vuc3ViLCBtYXJrKTtcbiAgICBfcHJvdG9SZW1vdmVMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG4pO1xuXG4vLy0tLS0tLS1WYWx1ZS0tLS0tLS0tLVxuXG4vLyB1dGlsLmRlZmluZShWYWx1ZSwgLy90ZXN0IGlzIHRoaXMgaW1wYWN0cyBwZXJmb3JtYW5jZSB0byBtdWNoXG4vLyAgIF9hbCwgZnVuY3Rpb24odmFsKSB7XG4vLyAgICAgLy8gY29uc29sZS5sb2coJzAtLS0tLS0tLS0+Jyx2YWwpXG4vLyAgICAgaWYoIXRoaXMuX19ibG9jaykgX2NoZWNrU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgX3N1YiwgdmFsKTtcbi8vICAgICBfcHJvdG9BZGRMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuLy8gICB9LFxuLy8gICBfcmwsIGZ1bmN0aW9uKHZhbCwgbWFyaykge1xuLy8gICAgICAvLyBjb25zb2xlLmVycm9yKCcyLjEgUkVNT1ZFIF9MJywgbWFyaywgdmFsLCBfdW5zdWIpXG4vLyAgICAgaWYoIXRoaXMuX19ibG9jaykgX2NoZWNrU3Vic2NyaXB0aW9uLmNhbGwodGhpcywgX3Vuc3ViLCBtYXJrKTtcbi8vICAgICBfcHJvdG9SZW1vdmVMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuLy8gICB9XG4vLyApO1xuXG5cblxuXG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKVxuICAsIFZhbHVlID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUnKVxuICAsIGNvbmZpZyA9IHJlcXVpcmUoJy4uLy4uL3V0aWwvY29uZmlnJylcbiAgLCBwcm9jZXNzID0gcmVxdWlyZSgnLi4vLi4vdmFsdWUvZmxhZ3MvcHJvY2VzcycpXG4gICwgcmFmID0gcmVxdWlyZSgnLi4vLi4vYnJvd3Nlci9hbmltYXRpb24vcmFmJylcbiAgLCBwb3N0cG9uZSA9IHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxuICAsIHVhID0gcmVxdWlyZSgnLi4vLi4vYnJvd3Nlci91YScpXG5cblZhbHVlLnByb3RvdHlwZS5fYmxhY2tsaXN0LnB1c2goJ19sYXN0JylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IFZhbHVlKClcbi8vVE9ETzogLnBhcmFtcyAvdyBsaXN0ZW5lcnMhXG5cbmNvbmZpZy5oYXNoVXJsID0gdWEuZGV2aWNlID09PSAndHYnICYmIHVhLnBsYXRmb3JtID09PSAnbGcnID8gZmFsc2UgOiAgY29uZmlnLmhhc2hVcmxcblxuLy8gaGlzdG9yeS5wdXNoU3RhdGUoe30sICcnLCcnIClcbi8vIGhpc3RvcnkuZ28oMClcbi8vIGhpc3RvcnkuYmFjaygpXG5cbnZhciBwc3RhdGUgPSAhY29uZmlnLmhhc2hVcmwgLy89ICF3aW5kb3cuREVCVUckICYmIHdpbmRvdy5oaXN0b3J5ICYmIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZVxuICAsIGNudCA9IDBcbiAgLCB0aW1lZFN0YXRlXG4gICwgc3RhdGUgPSBwb3N0cG9uZSAoIHBzdGF0ZSA/IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgLy9sb2FkIGN1cnJlbnQgcGFyYW1zIGFzIHdlbGxcbiAgICAgIC8vc2FtZSBnb2VzIGZvciB0aGUgb3RoZXJcbiAgICAgIC8vd2UgY291bGQgYWRkIGEgZGVsYXkgaGVyZSFcbiAgICAgIGhyZWYgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuXG4gICAgICBjb25zb2xlLmxvZyh2YWwsICB2YWwucmVwbGFjZSgvIC9nLCAnKycpLnJlcGxhY2UoL14jXFwvLywgJycpLnRvTG93ZXJDYXNlKCkpXG5cbiAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSgge30sIHZhbCwgdmFsLnJlcGxhY2UoLyAvZywgJysnKS5yZXBsYWNlKC9eI1xcLy8sICcnKS50b0xvd2VyQ2FzZSgpIClcbiAgICB9IDogZnVuY3Rpb24odmFsKSB7XG4gICAgICBleHBvcnRzLmJsb2NrID0gdHJ1ZVxuICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSAnIy8nICsgdmFsLnJlcGxhY2UoLyAvZywgJysnKS50b0xvd2VyQ2FzZSgpXG4gICAgICBleHBvcnRzLmJsb2NrID0gZmFsc2VcbiAgICB9IClcbiAgLCBfc2V0ID0gVmFsdWUucHJvdG90eXBlLl9zZXRcbiAgLCBwYXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCFwc3RhdGUpIFxuICAgICAge1xuICAgICAgICB2YXIgdXJsID0gd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVxuICAgICAgICB2YXIgcGFyYW1zID0gJydcbiAgICAgICAgaWYoIHVybCAmJiB1cmwubGVuZ3RoID09PSAxICkge1xuICAgICAgICAgIHBhcmFtcyA9IHF1ZXJ5KCB1cmxbMF0gKVxuICAgICAgICAgIHVybFswXSA9IHVybFswXS5yZXBsYWNlKHBhcmFtcywgJycpXG4gICAgICAgICAgLy8gd2luZG93LmxvY2F0aW9uID0gJyMvJytwYXJhbXNcbiAgICAgICAgICAvLyByZXR1cm4gPSAneCdcbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZyggdXJsLCAoIHVybC5sZW5ndGggPiAxID8gdXJsWzFdLnJlcGxhY2UoL1xcKy9nLCAnICcpIDogJyAnICkuc2xpY2UoMSksIHBhcmFtcyApXG4gICAgICAgIC8vICtwYXJhbXNcbiAgICAgICAgcmV0dXJuICggdXJsLmxlbmd0aCA+IDEgPyB1cmxbMV0ucmVwbGFjZSgvXFwrL2csICcgJykgOiAnICcgKS5zbGljZSgxKStwYXJhbXNcbiAgICAgIH0gZWxzZSBcbiAgICAgIHtcbiAgICAgICAgXG4gICAgICAgIHZhciB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZlxuICAgICAgICBpZiggdXJsICkge1xuICAgICAgICAgIHBhcmFtcyA9IHF1ZXJ5KCB1cmwgKVxuICAgICAgICAgIHVybCA9IHVybC5yZXBsYWNlKHBhcmFtcywgJycpXG4gICAgICAgICAgLy8gd2luZG93LmxvY2F0aW9uID0gJyMvJytwYXJhbXNcbiAgICAgICAgICAvLyByZXR1cm4gPSAneCdcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBTdHJpbmcod2luZG93LmxvY2F0aW9uLmhyZWYpXG4gICAgICAgICAgICAgICAucmVwbGFjZShTdHJpbmcod2luZG93LmxvY2F0aW9uLm9yaWdpbikgKyAnLycsICcnKVxuICAgICAgICAgICAgICAgLnJlcGxhY2UoL14jXFwvLywgJycpXG4gICAgICAgICAgICAgICAucmVwbGFjZSgvXFwrL2csICcgJylcbiAgICAgICAgICAgICAgIHx8ICcnXG4gICAgICB9XG4gICAgfVxuICAsIHF1ZXJ5ID0gZnVuY3Rpb24oIHN0ciApIHtcbiAgICAgIGlmKCFzdHIpIHN0ciA9IHBhcnNlKCkgfHwgJydcbiAgICAgIHZhciBhcnIgPSBzdHIuc3BsaXQoJz8nKVxuICAgICAgICAsIGxlbiA9IGFyci5sZW5ndGhcbiAgICAgIHN0ciA9IGxlbiA+IDEgJiYgYXJyWyBhcnIubGVuZ3RoIC0gMSBdID8gJz8nK2FyclsgYXJyLmxlbmd0aCAtIDEgXSA6ICcnXG4gICAgICByZXR1cm4gc3RyXG4gICAgfVxuXG5leHBvcnRzLnBhcnNlID0gcGFyc2VcblxuLy9UT0RPOiBiYWNrIGJ0biBoaWphY2sgKGV2ZW50IGhpamFjayBhZGQgcmFuZG9tIHBhcmFtKVxuLy9UT0RPOiB1c2UgcmFmIGZvciB1cGRhdGVzXG5leHBvcnRzLnZhbCA9IHsgXG4gIHN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHN0ciA9IHBhcnNlKClcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoIHF1ZXJ5KCBzdHIgKSwgJycgKVxuICB9LFxuICBwYXJhbXM6IHtcbiAgICB2YWw6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcXVlcnkoKSB9LFxuICAgIGRlZmVyOmZ1bmN0aW9uKCB1cGRhdGUsIGFyZ3MgKSB7XG5cbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpIC8vbWF5YmUgbm90P1xuXG4gICAgICB2YXIgdmFsID0gdGhpcy52YWxcbiAgICAgICAgLCBwYXJhbXNcbiAgICAgICAgLCBuZXN0ZWRwYXJhbXNcbiAgICAgICAgLCBjXG5cbiAgICAgIGlmKCB2YWwgJiYgdmFsIT09dGhpcy5fbGFzdCApIHtcbiAgICAgICAgdGhpcy5fbGFzdCA9IHZhbFxuICAgICAgICBwYXJhbXMgPSB2YWwuc2xpY2UoMSkuc3BsaXQoJyYnKVxuICAgICAgICBuZXN0ZWRwYXJhbXMgPSB7fVxuICAgICAgICBmb3IoIHZhciBpIGluIHBhcmFtcyApIHtcbiAgICAgICAgICBjID0gcGFyYW1zW2ldLnNwbGl0KCc9JylcbiAgICAgICAgICBpZiggYy5sZW5ndGg+MSApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5lc3RlZHBhcmFtc1tjWzBdXSA9IGNbMV1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3VybDogbm8gW2tleV09W3ZhbHVlXSBmb3JtYXQgLS0gbm90IGltcGxlbWVudGVkIHlldCcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsID0gbmVzdGVkcGFyYW1zXG4gICAgICB9XG4gICAgICByYWYoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpIH0pXG4gICAgfVxuICB9LFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCB2LCBjdiApIHtcbiAgICByZXR1cm4gY3ZcbiAgfSxcbiAgZGVmZXI6IGZ1bmN0aW9uKCB1cGRhdGUsIGFyZ3MgKSB7XG4gICAgaWYoIGFyZ3NbMV0gJiYgYXJnc1sxXVswXSA9PT0gJ3UnICkgXG4gICAge1xuICAgICAgdGhpcy5jbGVhckNhY2hlKClcbiAgICAgIHJhZiggZnVuY3Rpb24oKSB7XG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9KVxuICAgIH0gZWxzZSBcbiAgICB7XG4gICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgdmFyIGEgPSAoIHR5cGVvZiBhcmdzWzBdID09PSAnc3RyaW5nJyAgPyBhcmdzWzBdIDogYXJnc1swXSAmJiBhcmdzWzBdLnZhbCB8fCB0aGlzLnZhbCApXG4gICAgICBpZihhKSBcbiAgICAgIHtcbiAgICAgICAgZXhwb3J0cy5ibG9ja3MgPSBjbnRcblxuICAgICAgICBzdGF0ZSggYSArIHRoaXMucGFyYW1zLnZhbCApXG4gICAgICB9XG4gICAgICByZXR1cm4gIHRydWVcbiAgICAgIC8vVE9ETzogdXBkYXRlKCB0cnVlICkgYmxvY2tzIGFsbCBjb25zZWN1dGl2ZSB1cGRhdGVzXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVybEV2ZW50KGUpIHtcbiAgdmFyIHN0YW1wXG5cbiAgaWYoICFjb25maWcuaGFzaFVybCB8fCBleHBvcnRzLmJsb2NrcyE9PWNudCApIFxuICB7XG4gICAgY250KytcbiAgICBzdGFtcCA9ICd1JytjbnRcbiAgICBleHBvcnRzLmNsZWFyQ2FjaGUoKVxuICAgIGV4cG9ydHMuc3RyaW5nLmNsZWFyQ2FjaGUoKSAvL21heWJlIG5vdCBjbGVhciBvbiBzdHJpbmc/XG4gICAgLy8gZXhwb3J0cy5fdXBkYXRlKCBwYXJzZSgpLCAndXJsJyApXG4gICAgZXhwb3J0cy5zdHJpbmcuX3VwZGF0ZSggZXhwb3J0cy5zdHJpbmcudmFsICwgc3RhbXAgKVxuICAgIGV4cG9ydHMucGFyYW1zLl91cGRhdGUoIGV4cG9ydHMuc3RyaW5nLnZhbCwgc3RhbXAgKVxuICAgIGV4cG9ydHMuX3VwZGF0ZSggZXhwb3J0cy5zdHJpbmcudmFsLCBzdGFtcCApXG4gICAgZXhwb3J0cy5fbHN0YW1wID0gbnVsbFxuXG4gIH0gZWxzZSB7XG4gICAgY250KytcbiAgfVxufVxuXG51dGlsLmRlZmluZSggZXhwb3J0cywgJ3VwZGF0ZScsIGZ1bmN0aW9uKCkge1xuICB1cmxFdmVudCgpXG59KVxuXG51dGlsLmRlZmluZSggZXhwb3J0cy5zdHJpbmcsICdyYXcnLCB7XG4gIGdldDpmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy52YWwucmVwbGFjZSggLyAvZywgJysnIClcbiAgfVxufSlcblxuaWYoIGNvbmZpZy5oYXNoVXJsIClcbntcbiAgd2luZG93Lm9uaGFzaGNoYW5nZSA9IHVybEV2ZW50XG59XG5lbHNlXG57XG4gIHdpbmRvdy5vbnBvcHN0YXRlID0gdXJsRXZlbnRcbn1cbi8vVE9ETzogYWRkIHBvcHN0YXRlXG5cbiIsIi8qXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xuLypcbi8qXG4gIHVzZXJhZ2VudCBzbmlmZmluZyBpcyBuZXZlciB1c2VkIGZvciBmZWF0dXJlIGRldGVjdGlvbiwgZm9yIGEgbXVsdGktc2NyZWVuIGFwcCB5b3UgZG8gbmVlZCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZGV2aWNlIGFsc28gd2hlbiBydW5uaW5nIGluIHRoZSBicm93c2VyXG4gIGhhcyBmaWVsZHMgVi51YS5wbGF0Zm9ybSwgZGV2aWNlLCBicm93c2VyIGFuZCB2ZXJzaW9uLiBUaGlzIGltcGxlbWVudGF0aW9uIHdoZW4gY29tcGlsZWQsIGlzIG9ubHkgNzAwIGJ5dGVzXG4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbi8qKlxuICogdGVzdFxuICogc2VhcmNoIGZvciByZWdleHBzIGluIHRoZSB1c2VyQWdlbnRcbiAqIGZuIGlzIGEgb24gc3VjY2VzIGNhbGxiYWNrXG4gKiBjaGVjayBodHRwOi8vd3d3LnVzZXJhZ2VudHN0cmluZy5jb20vIHRvIHRlc3QgZm9yIHVzZXJBZ2VudHNcbiAqIEBtZXRob2RcbiAqL1xuLCB0ZXN0ID0gZXhwb3J0cy50ZXN0ID0gZnVuY3Rpb24oIF91YSwgZm4gKSB7XG5cbiAgZm9yXG4gICggdmFyIHRlc3RzID0gdXRpbC5hcmcoIGFyZ3VtZW50cywgMSApXG4gICAgICAsIGkgPSB0ZXN0cy5sZW5ndGggLSAxXG4gICAgICAsIHF1ZXJ5ID0gdGVzdHNbaV1bMF1cbiAgICA7IHF1ZXJ5ICE9PSB0cnVlICYmICFuZXcgUmVnRXhwKCBxdWVyeSApLnRlc3QoIF91YSApXG4gICAgOyBxdWVyeSA9IHRlc3RzWy0taV1bMF1cbiAgKVxuXG4gIDtpZiggZm4uc2xpY2UgfHwgZm4uY2FsbCggdGhpcywgcXVlcnksIHRlc3RzW2ldICkgKVxuICB7XG4gICAgdGhpc1tmbl0gPSB0ZXN0c1tpXVsxXVxuICB9XG5cbn1cbiwgcGFyc2UgPSBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oX3VhLCBvYmopIHtcblxuICBpZiggIV91YSApXG4gIHtcbiAgICBvYmogPSBleHBvcnRzXG4gICAgX3VhID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKClcbiAgICAgICAgOiAnbm8gbmF2aWdhdG9yJ1xuICB9XG5cbiAgX3VhID0gX3VhLnRvTG93ZXJDYXNlKClcblxuICBpZiggIW9iaiApIG9iaiA9IHt9XG5cbiAgLy8gX3VhID0gJ3dlYm9zOyBsaW51eCAtIGxhcmdlIHNjcmVlbidcblxuICB2YXIgX2ZmID0gJ2ZpcmVmb3gnXG4gICAgLCBfYW5kcm9pZCA9ICdhbmRyb2lkJ1xuICAgICwgX21vYmlsZSA9ICcuK21vYmlsZSdcbiAgICAsIF93ZWJraXQgPSAnd2Via2l0J1xuICAgICwgX3BzID0gJ3BsYXlzdGF0aW9uJ1xuICAgICwgX3hib3ggPSAneGJveCdcbiAgICAsIF9saW51eCA9ICdsaW51eCdcbiAgICAsIF9jYXN0RGV0ZWN0ID0gJ2Nya2V5J1xuICAgICwgX2Nocm9tZWNhc3QgPSAnY2hyb21lY2FzdCdcbiAgICAsIF90YWJsZXQgPSAndGFibGV0J1xuICAgICwgX3dpbmRvd3MgPSAnd2luZG93cydcbiAgICAsIF9waG9uZSA9ICdwaG9uZSdcbiAgICAsIF9pcGhvbmVWZXJzaW9uXG5cbiAgdGVzdC5jYWxsXG4gICggb2JqXG4gICwgX3VhXG4gICwgZnVuY3Rpb24oIHF1ZXJ5LCBhcnIgKSB7XG5cbiAgICAgIG9iai5icm93c2VyID0gYXJyWzJdIHx8IHF1ZXJ5XG5cbiAgICAgIHZhciBfdiA9IF91YS5tYXRjaFxuICAgICAgKCBuZXcgUmVnRXhwXG4gICAgICAgICggJygoKFtcXFxcLyBddmVyc2lvbnwnXG4gICAgICAgICsgYXJyWzBdXG4gICAgICAgICsgJyg/IS4rdmVyc2lvbikpW1xcLyBdKXwgcnY6KShbMC05XXsxLDR9XFxcXC5bMC05XXswLDJ9KSdcbiAgICAgICAgKVxuICAgICAgKVxuXG4gICAgICBvYmoudmVyc2lvbiA9IF92ID8gTnVtYmVyKCBfdls0XSApIDogMFxuICAgICAgb2JqLnByZWZpeCA9IGFyclsxXVxuICAgICAgLy9UT0RPOiBhZGQgcHJlZml4IGZvciBvcGVyYSB2PjEyLjE1O1xuICAgICAgLy9UT0RPOiB3aW5kb3dzIGNoZWNrIGZvciBpZSAxMSBtYXkgYmUgdG9vIGdlbmVyYWw7XG4gICAgfVxuICAsIFsgdHJ1ZSwgX3dlYmtpdCBdXG4gICwgWyAnXFxcXCh3aW5kb3dzJywgJ21zJywgJ2llJyBdXG4gICwgWyAnc2FmYXJpJywgX3dlYmtpdCBdXG4gICwgWyBfZmYsICdNb3onIF1cbiAgLCBbICdvcGVyYScsICdPJyBdXG4gICwgWyAnbXNpZScsICdtcycsICdpZScgXVxuICAsIFsgJ2Nocm9tZXxjcmlvc1xcLycsIF93ZWJraXQsICdjaHJvbWUnIF1cbiAgKVxuXG4gIC8qKlxuICAqIHBsYXRmb3JtIGRldGVjdGlvblxuICAqL1xuICB0ZXN0LmNhbGxcbiAgKCBvYmpcbiAgLCBfdWFcbiAgLCAncGxhdGZvcm0nXG4gICwgWyB0cnVlLCBfd2luZG93cyBdXG4gICwgWyBfbGludXgsIF9saW51eCBdXG4gICwgWyAnbGcuezAsM31uZXRjYXN0JywgJ2xnJyBdIC8vVE9ETzpwcm9wYWJseSBuZWVkIHRvIGFkZCBtb3JlIVxuICAsIFsgX2ZmICsgX21vYmlsZSwgX2ZmIF1cbiAgLCBbICdtYWMgb3MgeCcsICdtYWMnIF1cbiAgLCBbICdpcGhvbmV8aXBvZHxpcGFkJywgJ2lvcycgXVxuICAsIFsgX3hib3gsIF94Ym94IF1cbiAgLCBbIF9wcywgX3BzIF1cbiAgLCBbIF9hbmRyb2lkLCBfYW5kcm9pZCBdXG4gICwgWyBfd2luZG93cywgX3dpbmRvd3MgXVxuICAsIFsgX2Nhc3REZXRlY3QsIF9jaHJvbWVjYXN0IF1cbiAgLCBbICdzbWFydC10djt8O3NhbXN1bmc7c21hcnR0dicsICdzYW1zdW5nJyBdIC8vU21hcnRUVjIwMTNcbiAgKVxuXG4gIC8qKlxuICAqIGRldmljZSBkZXRlY3Rpb25cbiAgKi9cbiAgdGVzdC5jYWxsXG4gICggb2JqXG4gICwgX3VhXG4gICwgJ2RldmljZSdcbiAgLCBbIHRydWUsICdkZXNrdG9wJyBdXG4gICwgWyBfd2luZG93cyArICcuK3RvdWNofGlwYWR8JyArIF9hbmRyb2lkLCAgX3RhYmxldCBdXG4gICwgWyAnaXBob25lfCgnICsgX2FuZHJvaWQgKyBfbW9iaWxlICsgJyl8KCcgKyBfZmYgKyBfbW9iaWxlICsgJyl8JyArIF93aW5kb3dzICsgJyBwaG9uZXxpZW1vYmlsZSdcbiAgICAsIF9waG9uZVxuICAgIF1cbiAgLCBbIF94Ym94ICsgJ3wnICsgX3BzLCAnY29uc29sZScgXVxuICAsIFsgJ3R2fHNtYXJ0dHZ8Z29vZ2xldHZ8YXBwbGV0dnxoYmJ0dnxwb3ZfdHZ8bmV0Y2FzdC50dnx3ZWJvcy4rbGFyZ2UnLCAndHYnIF1cbiAgLCBbIF9jYXN0RGV0ZWN0LCBfY2hyb21lY2FzdCBdXG4gICwgWyAnYW1hem9uLWZpcmVvcycsIF90YWJsZXQgXVxuICApXG5cbiAgLy9UT0RPOiBhbWF6b24gZmlyZXR2IGFuZCBwaG9uZVxuICAgIC8vIGFsZXJ0KHdpbmRvdy5pbm5lcldpZHRoKndpbmRvdy5pbm5lckhlaWdodCArICAnICAnKyA0MTQgKiA3MzYpXG4gIFxuICAvLzQxNCDDlyA3MzZcbiAgdmFyIGlwaG9uZTZwbHVzID0gNDE0ICogNzM2XG4gIGlmXG4gICggb2JqLnBsYXRmb3JtID09PSBfYW5kcm9pZFxuICAgICYmICF1dGlsLmlzTm9kZVxuICAgICYmIG9iai5kZXZpY2UgPT09IF9waG9uZVxuICAgICYmIHdpbmRvdy5pbm5lcldpZHRoKndpbmRvdy5pbm5lckhlaWdodCA+IGlwaG9uZTZwbHVzXG4gICAgLy8gJiYgfl91YS5pbmRleE9mKCdjcm9zc3dhbGsnKVxuICApXG4gIHtcbiAgICBvYmouZGV2aWNlID0gJ3RhYmxldCdcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuaWYoICF1dGlsLmlzTm9kZSApIFxueyBcbiAgcGFyc2UoKVxuICAvL1RPRE86IHRoaXMgaXMgdmVyeSB1Z2x5LCB0cnkgdG8gZmluZCBhIGJldHRlciBzb2x1dGlvblxuICBpZiggd2luZG93Ll9fdWFfXyApIFxuICB7XG4gICAgZm9yKCB2YXIgZmllbGQgaW4gd2luZG93Ll9fdWFfXyApXG4gICAge1xuICAgICAgZXhwb3J0c1tmaWVsZF0gPSB3aW5kb3cuX191YV9fW2ZpZWxkXVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIHByb3BcbiAqIHJlLXdyaXRlcyBqcyBwcm9wZXJ0aWVzIHRvIHRoZWlyIGNzcyBjb3VudGVycGFydFxuICogZS5nLiB3ZWJraXRUcmFuc2Zvcm0gLS0+IC13ZWJraXQtdHJhbnNmb3JtXG4gKiBub3cgaXRzIGNvbW1lbnRlZCBzaW5jZSBpdHMgbm90IG5lc3NlY2FyeSB5ZXRcbiAqIEBtZXRob2RcbiAqL1xuLy8gdGhpcy5wcm9wID0gZnVuY3Rpb24oc3RyKSB7XG4vLyAgcmV0dXJuIHN0ci5yZXBsYWNlKHRoaXMucHJlZml4LCctJyt0aGlzLnByZWZpeCsnLScpLnRvTG93ZXJDYXNlKCk7XG4vLyB9XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgIGRhdGEgPSByZXF1aXJlKCcuLycpXG4gICwgYmFzZSA9IHJlcXVpcmUoJy4uL2Jhc2UnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCBmbGFncyA9IHJlcXVpcmUoJy4uL3ZhbHVlL2ZsYWdzL2RhdGEnKVxuICAsIHZPYmplY3QgPSByZXF1aXJlKCcuLi9vYmplY3QnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKCBmdW5jdGlvbihiYXNlLCBleHRlbnNpb25zLCBtb2RlbGJsYWNrbGlzdCkge1xuXG4gIC8vIHZhciBfYmxhY2tsaXN0ID0gdXRpbC5hZGQoWydmbGFncycsICdyZWYnLCAncGFyc2UnLCAncGFyc2luZyddLCBtb2RlbGJsYWNrbGlzdCksXG4gICAgdmFyIF9jb21wYXJlID0gdXRpbC5jb21wYXJlQXJyYXlzLFxuICAgIG1ldGhvZHMgPSB7XG4gICAgICBfZFVwZGF0ZTogZnVuY3Rpb24ob2JqLCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIGluc3RhbmNlcywgYXJneDEsIGFyZ3gyICkge1xuICAgICAgICAvLyBpZih3aW5kb3cuaGVyZSkgY29uc29sZS5sb2coJ1gnLHN0YW1wKVxuICAgICAgICBpZiAodGhpcy5tb2RlbCkge1xuICAgICAgICAgIC8vJG5kYXRhXG4gICAgICAgICAgLy9UT0RPOiB2ZXJ5IGRpcnR5IGZpeCBnZXQgcmlkIG9mIHRoaXMhXG4gICAgICAgICAgaWYoIG9iaiA9PT0gJyRuZGF0YScgKXtcbiAgICAgICAgICAgIHZhbCA9IGZyb21cbiAgICAgICAgICAgIHN0YW1wID0gcmVtb3ZlXG4gICAgICAgICAgICBmcm9tID0gYWRkZWRcbiAgICAgICAgICAgIHJlbW92ZSA9IG9sZHZhbFxuICAgICAgICAgICAgYWRkZWQgPSBpbnN0YW5jZXNcbiAgICAgICAgICAgIG9sZHZhbCA9IGFyZ3gxXG4gICAgICAgICAgICBpbnN0YW5jZXMgPSBhcmd4MlxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyFAIyFAIyFAIyFAI0AhIyFAIyFAIyFAIycucmVkLmludmVyc2UpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gdmFyIG5vbiA9IDBcbiAgICAgICAgICAvLyAgICwgY250ID0gMFxuICAgICAgICAgIC8vIGZvciggdmFyIGkgaW4gYXJndW1lbnRzICkgXG4gICAgICAgICAgLy8ge1xuICAgICAgICAgIC8vICAgY250KytcbiAgICAgICAgICAvLyAgIGlmKCFhcmd1bWVudHNbaV0pIHtcbiAgICAgICAgICAvLyAgICAgbm9uKytcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyAgIGNvbnNvbGUubG9nKCBhcmd1bWVudHNbaV0gKVxuICAgICAgICAgIC8vIH1cbiAgICAgICAgICAvLyBpZihub24gPT09IGNudCkge1xuICAgICAgICAgIC8vICAgYWxlcnQoJ25vIGFyZ3MnKVxuICAgICAgICAgIC8vICAgcmV0dXJuIHRydWVcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICBpZiAoIXRoaXMuX2QgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB3aGlsZSAoIXRoaXMuX2QgJiYgcCkge1xuICAgICAgICAgICAgICBpZiAocC5fZCkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1NFVCBEQVRBJylcbiAgICAgICAgICAgICAgICB0aGlzLl9kU2V0KHAuX2QsIHRydWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdCA9IHRoaXMsXG4gICAgICAgICAgICBtb2RlbCA9IHQubW9kZWwsXG4gICAgICAgICAgICBmID0gbW9kZWwuZmxhZ3MsXG5cbiAgICAgICAgICAgIC8vIGYgPSBtb2RlbCA/IG1vZGVsLmZsYWdzIDogZmFsc2UgYmUgY2FyZWZ1bGwgd2l0aCB1cGRhdGVzIGluIHZhbHVlcyB0aGF0IGhhdmUgZGF0YVxuXG4gICAgICAgICAgICBwYXRoID0gdC5fZCAmJiB0Ll9kLl9wYXRoIHx8IFtdLFxuICAgICAgICAgICAgbmFtZSA9IChmcm9tIHx8IChmcm9tID0gKHQuX2QgJiYgdC5fZC5fdXBkYXRlT3JpZ2luKSkgJiYgIShmcm9tID09PSB0Ll9kICYmIChmcm9tID0gZmFsc2UpKSkgJiYgZnJvbS51cGRhdGVQYXRoLFxuICAgICAgICAgICAgZnJvbVBhdGggPSBmcm9tICYmIGZyb20uX3BhdGgsXG4gICAgICAgICAgICBtZXRob2QgPSBmdW5jdGlvbihpLCBmaWVsZCkge1xuXG4gICAgICAgICAgICAgIHZhciBzZWxlY3QsIHBhc3MsIGZyLCBsZmllbGQ7XG4gICAgICAgICAgICAgIC8vIGlmKCBmaWVsZC5fZmxhZ1syXS5fX3QpIHtcbiAgICAgICAgICAgICAgLy9tdWx0aXBsZSBmbGFncyFcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnRkxBRycuaW52ZXJzZSwgbmFtZSwgZmllbGQuX2ZsYWcpXG4gICAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgICBpZighZmllbGQuX2ZsYWcuZGF0YSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05PIERBVEEgRkxBRycsIG5hbWUsIGZpZWxkLl9mbGFnLCB2YWwsIG9iaiwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZpZWxkID0gZmllbGQuX2ZsYWcuZGF0YVsyXTtcblxuICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0RBVEEgVVBEQVRFJy5tYWdlbnRhLmludmVyc2UsXG4gICAgICAgICAgICAgICAvLyAgICAgICdvYmo6Jywgb2JqXG4gICAgICAgICAgICAgICAvLyAgICAsICd2YWw6JywgdmFsXG4gICAgICAgICAgICAgICAvLyAgICAsICdzdGFtcDonLCBzdGFtcFxuICAgICAgICAgICAgICAgLy8gICAgLCAnZnJvbTonLCBmcm9tXG4gICAgICAgICAgICAgICAvLyAgICAsICdyZW1vdmU6JywgcmVtb3ZlXG4gICAgICAgICAgICAgICAvLyAgICAsICdhZGRlZDonLCBhZGRlZFxuICAgICAgICAgICAgICAgLy8gICAgLCAnZmllbGQ6JywgZmllbGRcbiAgICAgICAgICAgICAgIC8vICApXG4gICAgICAgICAgICAgIC8vIHZhciB0ZXN0ID0gKGk9PT0ndGV4dCcgJiYgZmllbGQgPT09ICdyZWFsLmR1cmF0aW9uJylcbiAgICAgICAgICAgICAgLy8gaWYodGVzdCkgY29uc29sZS5sb2coZmllbGQsaSlcbiAgICAgICAgICAgICAgLy8gaWYodGVzdCkgcGFzcyA9IHRydWVcblxuICAgICAgICAgICAgICBpZiAoaSA9PT0gJ2NvbGxlY3Rpb24nICYmIHQuX2NvbEZpbHRlcikgcmV0dXJuXG4gICAgICAgICAgICAgIC8vaWYgbm90IG93biBjb2xmaWx0ZXIgLS0+IGhhbmRsZSB5b3Vyc2VsZiE7XG4gICAgICAgICAgICAgIC8vIGlmIGRhdGEgaGFzIGNoYW5nZWQgY2hhbmdlIGNvbGZpbHRlciBhZG4gc2VuZCB1cGRhdGVcbiAgICAgICAgICAgICAgLy9iZSBjYXJlZnVsbCAvdyBjaGFuZ2VzITsgdG9vIGNydWRlXG5cbiAgICAgICAgICAgICAgaWYgKGZpZWxkID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1BBU1MnLmludmVyc2UsbmFtZSlcbiAgICAgICAgICAgICAgICBwYXNzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChmaWVsZC5wb3ApIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lLCc/Pz8nKVxuXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4nLGZpZWxkLCBmaWVsZC5wb3ApXG5cbiAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkLmNvbmNhdCgpO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGZpZWxkLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWxmaWVsZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IHV0aWwuZ2V0KHQuX2QsIGZpZWxkW2pdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbGZpZWxkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZmllbGRbal0gPSBmaWVsZFtqXS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdETyBETyEnLmludmVyc2UsbmFtZSwgdC5fZCAmJiB0Ll9kLl91cGRhdGVPcmlnaW4pXG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhuYW1lLCBwYXRoLCBzZWxlY3QsIG9iaiwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBpbnN0YW5jZXMpXG5cbiAgICAgICAgICAgICAgICBmaWVsZCA9IGZpZWxkLnNwbGl0KCcuJylcblxuICAgICAgICAgICAgICAgIHNlbGVjdCA9IHV0aWwuZ2V0KHQuX2QsIGZpZWxkKVxuXG4gICAgICAgICAgICAgICAgaWYoIXNlbGVjdCAmJiB0Ll9kICYmIHQuX2QuZnJvbSAmJiBmaWVsZCApIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdOTyBTRUxFQ1QnLnJlZC5pbnZlcnNlLCB0Ll9kIClcbiAgICAgICAgICAgICAgICAgIHNlbGVjdCA9IHV0aWwuZ2V0KHQuX2QuZnJvbSwgZmllbGQpXG4gICAgICAgICAgICAgICAgICAvLyBpZihzZWxlY3QpIHtcbiAgICAgICAgICAgICAgICAgIC8vICAgLy8gY29uc29sZS5sb2coJ0ZPVU5EIFNFTEVDVCcuZ3JlZW4uaW52ZXJzZSwgc2VsZWN0KVxuICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgICBpZihzZWxlY3QgJiYgZnJvbSAmJiBmcm9tLl9fdCA9PT0gNCkgbGZpZWxkID0gdHJ1ZSAvL3Rlc3QgZGl0IG9mIGhldCBhbGxlcyBzbG93IG1hYWt0XG5cbiAgICAgICAgICAgICAgICAvLyBpZih0ZXN0JiZzZWxlY3QpIGNvbnNvbGUubG9nKHNlbGVjdC5fdmFsKVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFwYXNzICYmIGZyb20pIHtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd0ZXN0aW5nLi4uLj8nLCBuYW1lLCBmcm9tLCBzZWxlY3QsIGxmaWVsZClcbiAgICAgICAgICAgICAgICAvLyBpZih0ZXN0KSBjb25zb2xlLmxvZyhuYW1lLCBzZWxlY3QsIGxmaWVsZCwgZnJvbSk7XG5cbiAgICAgICAgICAgICAgICBmciA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGZyb21Gcm9tXG5cbiAgICAgICAgICAgICAgICBpZiAoIGZyb20gPT09IHNlbGVjdCB8fCAoIGZyb21Gcm9tID0gZnJvbS5mcm9tICkgPT09IHNlbGVjdCApIHtcbiAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAodC5fZC5fZmlsdGVyICYmIHNlbGVjdCAmJiBzZWxlY3QuX2FuY2VzdG9yKGZyb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvL2ZpZWxkIG9vayB2b29yIGFycmF5cyE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxmaWVsZCkge1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdnb3QgbGZpZWxkISEhIScpXG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBmaWVsZC5sZW5ndGg7IG4rKykge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChuYW1lICYmIF9jb21wYXJlKG5hbWUsIGZpZWxkW25dKSB8fCBmaWVsZFtuXVswXSA9PT0gbmFtZVswXSAmJiB1dGlsLmdldCh2YWwsIGZpZWxkW25dLmNvbmNhdCgpLnNoaWZ0KCkpKSBcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgoX2NvbXBhcmUocGF0aC5jb25jYXQoZmllbGRbbl0pLCBmcm9tUGF0aCkgfHwgX2NvbXBhcmUoZmllbGRbbl0sIGZyb21QYXRoKSkpIFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSEVSRT8nLmN5YW4uaW52ZXJzZSwgJ1xcblxcblxcbicsIHNlbGVjdC5mcm9tLnJhdywgJ3ZhbDonXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICwgdmFsLCAnZmllbGQ6JywgZmllbGQsICdmbicsIGZpZWxkW25dLCAnbjonLCBuLCAnY2hlY2sgZmllbGQ6JywgdmFsICYmIHZhbFtmaWVsZFtuXV0sICdyZWY6JywgdmFsLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnY29taW5nIHRydWdoJywgc2VsZWN0ICYmIGZyb20uX3ZhbCAhPT0gbnVsbCAmJiB2YWwsIGZpZWxkW25dXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICwgc2VsZWN0ICYmIGZyb20uX3ZhbCAhPT0gbnVsbCAmJiB2YWwgJiYgKCB2YWxbZmllbGRbbl1dIHx8IHZhbC5fX3QgPT09IDQgJiYgdmFsLmZyb21bZmllbGRbbl1dICkgKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy9UT0RPOiBuZWVkIHRvIGFkZCBtb3JlIGdhdXJkaW5nIGZvciB2YWwuJHBhdGggY2hlY2sgaWYgdGhpcyBpcyBjbG91ZCBhbmQgcmVmXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHNlbGVjdCAmJiBmcm9tLl92YWwgIT09IG51bGwgJiYgdmFsICYmICh2YWxbZmllbGRbbl1dIHx8IHZhbC4kcGF0aCB8fCB2YWwuX190ID09PSA0KSAmJiAoc2VsZWN0Ll9hbmNlc3Rvcihmcm9tKSB8fCBzZWxlY3QuZnJvbS5fYW5jZXN0b3IoIGZyb21Gcm9tICkgICkpICAvL1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWwsIGZpZWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyggJy0tLScsIHNlbGVjdCwgdmFsLCBmaWVsZCwgZnJvbSwgJ2Zyb21QYXRoOicgLCBmcm9tUGF0aCApXG5cbiAgICAgICAgICAgICAgICAgICAgaWYodmFsPT09bnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGlmKERFQlVHJCkgdC5fZC5ERUJVRyRsb2coJ2RhdGEvYmFzZSAtLS0+IEVSUk9SIHZhbCBpcyBudWxsICAtLS0+Jyt0Ll9kLl9yZW1vdmVkIClcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmKHZhbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogaGFuZGxlIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnXFxuXFxuXFxuIHVuZGVmaW5lZCB3aGF0IHRvIGRvIG5vdz8nLCBhcmd1bWVudHMsdGhpcylcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZWJ1Z2dlclxuICAgICAgICAgICAgICAgICAgICAgIC8vIHBhc3MgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcGFzcyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChuYW1lICYmIF9jb21wYXJlKG5hbWUsIGZpZWxkKSB8fCBmaWVsZFswXSA9PT0gbmFtZSAmJiBuYW1lWzBdICYmIHV0aWwuZ2V0KHZhbCwgZmllbGQuY29uY2F0KCkuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBmciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhdGggJiYgKF9jb21wYXJlKHBhdGguY29uY2F0KGZpZWxkKSwgZnJvbVBhdGgpIHx8IF9jb21wYXJlKGZpZWxkLCBmcm9tUGF0aCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZnIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxlY3QgJiYgKHZhbFtmaWVsZFswXV0pICYmIHNlbGVjdC5fYW5jZXN0b3IgJiYgc2VsZWN0Ll9hbmNlc3Rvcihmcm9tKSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHZhbCwgZmllbGQpO1xuICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiggdC5fX2NoZWNrS2V5c19fICkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdsZXRzIGNoZWNraiB0aGUga2V5cyEnKVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBmaWVsZCwgbmFtZSwgdmFsLCBwYXRoLCBzZWxlY3QsIHZhbFtmaWVsZFswXV0sIGZyb20sIHRoaXMgKVxuICAgICAgICAgICAgICAgICAgICAgIGZvciggdmFyIGtleSQgaW4gdC5fX2NoZWNrS2V5c19fICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIGZpZWxkID09PSB0Ll9fY2hlY2tLZXlzX19ba2V5JF0gfHwgZmllbGRbMF0gPT09IHQuX19jaGVja0tleXNfX1trZXkkXSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ21heWJlPz8hIUAjIUAnLCBpLCB0Ll9fY2hlY2tLZXlzX19ba2V5JF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3MgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2codmFsLCBmaWVsZFswXSwgZnJvbSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIHBhc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUEFTUz4+Pj4+Pj4+Pj8nLm1hZ2VudGEuaW52ZXJzZSwgcGFzcyA/ICdPSyEnLmdyZWVuLmludmVyc2UgOiAnTk8hJy5yZWQuaW52ZXJzZSAgXG4gICAgICAgICAgICAgIC8vICAgLCAndmFsOicuYmx1ZSwgdmFsXG4gICAgICAgICAgICAgIC8vICAgLCAnb2JqLl9wYXRoOicuYmx1ZSwgb2JqICYmIG9iai5fcGF0aFxuICAgICAgICAgICAgICAvLyAgICwgJ2ZpZWxkOicuYmx1ZSwgZmllbGRcbiAgICAgICAgICAgICAgLy8gICAsICdmcm9tUGF0aDonLmJsdWUsIGZyb21QYXRoXG4gICAgICAgICAgICAgIC8vICAgLCAnZnJvbTonLmJsdWUsIGZyb21cbiAgICAgICAgICAgICAgLy8gICAsICdzZWxlY3QnLmJsdWUsIHNlbGVjdFxuICAgICAgICAgICAgICAvLyAgIClcblxuICAgICAgICAgICAgICAvLyBpZighIHBhc3MgJiYgKVxuXG4gICAgICAgICAgICAgIC8vIHBhc3MgPSB0cnVlXG5cbiAgICAgICAgICAgICAgLy98fCByZW1vdmUgXG5cbiAgICAgICAgICAgICAgaWYgKHBhc3MgfHwgcmVtb3ZlIHx8IChpbnN0YW5jZXMgfHwgcmVtb3ZlIHx8IHNlbGVjdCAhPT0gdm9pZCAwKSAmJiAoICFmciB8fCByZW1vdmUgPT09IDEpKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndXBkYXRpbmchJy5jeWFuLmludmVyc2UsIGksIHZhbCwgaW5zdGFuY2VzLCByZW1vdmUsIHNlbGVjdCwgZnIsIGZyb20pXG4gICAgICAgICAgICAgICAgLy8gZGVidWdnZXJcbiAgICAgICAgICAgICAgICAvL3N0YW1wIG1lZWdldmVuPz8/P1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCAnRlJPTSEhISEhJy5ncmVlbi5pbnZlcnNlLCBmcm9tIClcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxcbiAgICAgICAgICAgICAgICB0W2ldLl91cGRhdGUodmFsLCBmYWxzZSwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCAhaW5zdGFuY2VzLCB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgIC8vYWRkIGFkdmFuY2VkIG1vZGVscyAobGlrZSBvbiB3ZWJzaXRlKVxuICAgICAgICAgICAgLy9ub3QgdGVzdGVkIGFuZCBzdGlsbCBwcmV0dHkgYnJva2VuXG4gICAgICAgICAgIHZhciBwYXJzZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kKSB7XG4gICAgICAgICAgICAgIHZhciB0ID0gdGhpcywgYVxuICAgICAgICAgICAgICAvL2lmIGFkZGVkIG9yIGZpcnN0IHJ1blxuICAgICAgICAgICAgICB0Lm1vZGVsLnZhbCAvL3NldCBfY2FsbGVyXG4gICAgICAgICAgICAgIC8vIGlmIChtb2RlbC5maWVsZCkgY29uc29sZS5sb2coJz8/Pz8nLCB0aGlzLmZpZWxkLCBtb2RlbC5maWVsZClcblxuICAgICAgICAgICAgICBpZiAobW9kZWwuZmllbGQpIGEgPSB1dGlsLmdldCh0Ll9kLCBtb2RlbC5maWVsZC52YWwpXG4gICAgICAgICAgICAgIGlmIChtb2RlbC5fdmFsKSBhID0gbW9kZWwuX3ZhbC5jYWxsKHQsIGEgfHwgdC5fZCkgfHwgYVxuICAgICAgICAgICAgICBpZiAoYSAmJiB0Ll9kICE9PSBhKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwucGFyc2luZyA9IHRydWVcbiAgICAgICAgICAgICAgICBpZihtb2RlbC5maWVsZCkgdGhpcy5tb2RlbFBhcnNlZCA9IG1vZGVsLmZpZWxkLnZhbFxuICAgICAgICAgICAgICAgIHRoaXMuX2RTZXQoYSlcbiAgICAgICAgICAgICAgICBtb2RlbC5wYXJzaW5nID0gZmFsc2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZXIuY2FsbCh0KVxuICAgICAgICAgIGlmIChpbnN0YW5jZXMpIHQuZWFjaEluc3RhbmNlKHBhcnNlciwgJ21vZGVsJylcbiAgICAgICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAgIGlmIChmICYmIChpbnN0YW5jZXMgfHwgdC5fZCkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gZikge1xuICAgICAgICAgICAgICBpZiAoIWZbaV0uX190KSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSBmW2ldLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZChpLCBmW2ldW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kKGksIGZbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgICAgICBpZih0aGlzLm1vZGVsLmNvbXBsZXRlKSB0aGlzLm1vZGVsLmNvbXBsZXRlLl92YWwuY2FsbCh0aGlzLGRhdGEpXG5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9kU2V0OiBmdW5jdGlvbih2YWwsIGRmcm9tKSB7XG5cblxuICAgICAgICAvLyBpZih2YWwpIHtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZygnX0RzZXQnLmN5YW4uaW52ZXJzZSwgdmFsLl9wYXRoLCBkZnJvbSlcbiAgICAgICAgLy8gfVxuICAgICAgICAvLyBpZih0aGlzLm1vZGVsLl9mbGFnICYmIHRoaXMubW9kZWwuX2ZsYWcucHJvY2VzcyAmJiAhdGhpcy5fX3Byb2Nlc3NpbmcpIHtcbiAgICAgICAgLy8gICBjb25zb2xlLmxvZygnb28yJylcbiAgICAgICAgLy8gICB0aGlzLm1vZGVsLl91cGRhdGUoKVxuICAgICAgICAvLyAgIHJldHVyblxuICAgICAgICAvLyB9XG5cbiAgICAgICAgaWYodGhpcy5tb2RlbC5fZmxhZyAmJiB0aGlzLm1vZGVsLl9mbGFnLmRlZmVyICAmJiAhdGhpcy5fX3Byb2Nlc3NpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fcEZsYWcgPSBbIHZhbCwgZGZyb20gXVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgLy9kZnJvbSBtb2V0IG5pZXQgbm9nIGVlbiBzdWJzY3JpYmUgZG9lbiEgLS0gYWxzIGhldCBnb2VkIGlzIGlzIHpuIHBhcmVudCBhbCBzdWJzY3JpYmVkXG5cbiAgICAgICAgaWYgKHRoaXMuX2QgJiYgdGhpcy5fZC5fX3QpIHRoaXMuX2QucmVtb3ZlTGlzdGVuZXIodHJ1ZSwgdGhpcylcbiAgICAgICAgdGhpcy5fZCA9IHZhbFxuICAgICAgICBpZiAoZGZyb20pIHRoaXMuX2Rmcm9tID0gdHJ1ZVxuICAgICAgICB0aGlzLl9kTGlzdGVuKClcblxuXG5cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgIH0sXG4gICAgICBfZExpc3RlbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSEVFRUVFRScsIHRoaXMubW9kZWwpXG5cbiAgICAgICAgLy8gaWYodGhpcy5tb2RlbC5fZmxhZyAmJiB0aGlzLm1vZGVsLl9mbGFnLnByb2Nlc3MgJiYgIXRoaXMuX19wcm9jZXNzaW5nKSB7XG4gICAgICAgIC8vICAgY29uc29sZS5sb2coJ29vMicpXG4gICAgICAgIC8vICAgdGhpcy5tb2RlbC5fdXBkYXRlKClcbiAgICAgICAgLy8gICByZXR1cm5cbiAgICAgICAgLy8gfVxuXG4gICAgICAgIC8vaGllciBnYWFuIHdlIHMgZmZ0amVzIHdlcmtlbiBtZXQgZWFjaFxuXG4gICAgICAgIC8vIHRoaXMuX2Rmcm9tID0gdHJ1ZTtcbiAgICAgICAgdmFyIF90aGlzXG5cbiAgICAgICAgaWYgKHRoaXMubW9kZWwgJiYgdGhpcy5fZCAmJiB0aGlzLl9kIGluc3RhbmNlb2Ygdk9iamVjdCkgXG4gICAgICAgIHsgLy90aGlzIG1vZGVsIG1heWJlIG5vdCBuZXNzZWNhcnk/XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0+Jy5jeWFuLmludmVyc2UsIHRoaXMuX2QgKVxuXG4gICAgICAgICAgdGhpcy5fZC5hZGRMaXN0ZW5lcihbdGhpcy5fZFVwZGF0ZSwgdGhpc10pXG5cbiAgICAgICAgICBfdGhpcyA9IHRoaXNcbiAgICAgICAgICBcbiAgICAgICAgICAvL2hpZXIgZmlsdGVyZW4gb3AgY2xvdWREYXRhIC0tLSBvb2sgd2Vya2VuIHZhbnVpdCByZW1vdmUhISFcbiAgICAgICAgICAgIC8vbmV2ZXIgZG8gZm9yIGNsb3VkIGRhdGFcbiAgICAgICAgIFxuICAgICAgICAgIGlmKCAhdGhpcy5fZC5jbG91ZCApXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5fZC5lYWNoKFxuICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgX3RoaXMuX19jaGVja0tleXNfXyA9IHRydWVcblxuICAgICAgICAgICAgICAgIGlmKHRoaXMuX190ID09PSA0ICkgdGhpcy5hZGRMaXN0ZW5lcihbIF90aGlzLl9kVXBkYXRlLCBfdGhpcywgJyRuZGF0YScsIHRoaXMgXSkgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy9ldmVudHVlZWwgLnZhbCBnZWJydWlrZW4gdm9vciBWYWx1ZXMgKmF3ZXNqdW1lIVxuICAgICAgICAgIC8vZXZlbnR1ZWVsIGhpZXIgZGluZ2VuIGFkZGVuIGFhbiBtb2RlbFxuXG4gICAgICAgIH0gXG4gICAgICAgIGVsc2UgaWYoIHRoaXMubW9kZWwgJiYgdGhpcy5fZCApIFxuICAgICAgICB7XG4gICAgICAgICAgZm9yKCB2YXIga2V5IGluIHRoaXMuX2QgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZighdGhpcy5fX2NoZWNrS2V5c19fIHx8IHRoaXMuX19jaGVja0tleXNfXyA9PT0gdHJ1ZSkgdGhpcy5fX2NoZWNrS2V5c19fID0gW11cbiAgICAgICAgICAgIGlmKCB0aGlzLl9kW2tleV0gaW5zdGFuY2VvZiB2T2JqZWN0IClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYoIXRoaXMuX19jaGVja0tleXNfXy5wdXNoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigneHh4eHh4JywgdGhpcywgdGhpcy5fX2NoZWNrS2V5c19fLCBrZXksIHRoaXMuX2QpXG4gICAgICAgICAgICAgICAgZGVidWdnZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9fY2hlY2tLZXlzX18ucHVzaCgga2V5IClcbiAgICAgICAgICAgICAgdGhpcy5fZFtrZXldLmFkZExpc3RlbmVyKFsgdGhpcy5fZFVwZGF0ZSwgdGhpcywgJyRuZGF0YScsIGtleSBdKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXBkYXRlRGF0YTogZnVuY3Rpb24oaW5zdGFuY2VzKSB7XG5cbiAgICAgICAgaWYodGhpcy5tb2RlbC5fZmxhZyAmJiB0aGlzLm1vZGVsLl9mbGFnLmRlZmVyICYmICF0aGlzLl9fcHJvY2Vzc2luZykge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdvbzInKVxuICAgICAgICAgIHRoaXMuX19wRmxhZ1UgPSBbIGluc3RhbmNlcyBdXG4gICAgICAgICAgdGhpcy5tb2RlbC5fdXBkYXRlKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnIURPSVQgdXBkYXRlRGF0YScuY3lhbi5pbnZlcnNlKVxuXG4gICAgICAgIHRoaXMuX2RVcGRhdGUodGhpcy5fZCwgdm9pZCAwLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGluc3RhbmNlcylcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4dGVuZCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGJhc2UuZXh0ZW5kKHtcbiAgICAgICAgbmFtZTogaSxcbiAgICAgICAgdHlwZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiAoZXh0ZW5zaW9ucyAmJiBleHRlbnNpb25zW2ldKSA/IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIG1ldGhvZHNbaV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICBleHRlbnNpb25zW2ldLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0gOiBtZXRob2RzW2ldXG4gICAgICB9KTtcbiAgICB9O1xuICBmb3IgKHZhciBpIGluIG1ldGhvZHMpIHtcbiAgICBleHRlbmQoaSlcbiAgfVxuICBiYXNlLmV4dGVuZCh7XG4gICAgbmFtZTogJ21vZGVsJyxcbiAgICBjYWNoZTogZmFsc2UsXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcblxuICAgICAgaWYodGhpcy5fX3BGbGFnIHx8IHRoaXMuX19wRmxhZ1UpIHtcbiAgICAgICAgLypcbiAgICAgICAgVE9ETzogdGVzdCBkZWZlciBiZXR0ZXIhISFcbiAgICAgICAgdGhpcy5fX3BGbGFnID0gWyB2YWwgXVxuICAgICAgICB0aGlzLl9fcEZsYWdVID0gWyB0cnVlIF1cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fX3Byb2Nlc3NpbmcgPSB0cnVlXG4gICAgICAgIHRoaXMubW9kZWwucGFyc2luZyA9IGZhbHNlXG4gICAgICAgIGlmKHRoaXMuX19wRmxhZykge1xuICAgICAgICAgIHRoaXMuX2RTZXQuYXBwbHkodGhpcyx0aGlzLl9fcEZsYWcpXG4gICAgICAgIH1cbiAgICAgICAgLy9zdWJzY3JpYmUgaGVsZW1hYWwgZnVja2VkIG1ldCBmaWVsZCBlcmJpalxuICAgICAgICBpZih0aGlzLl9fcEZsYWdVKSB7XG4gICAgICAgICAgdGhpcy51cGRhdGVEYXRhLmFwcGx5KHRoaXMsdGhpcy5fX3BGbGFnVSlcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fcEZsYWdVID0gbnVsbFxuICAgICAgICB0aGlzLl9fcEZsYWcgPSBudWxsXG4gICAgICAgIHRoaXMuX19wcm9jZXNzaW5nID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZih2YWwuZmllbGQgJiYgdmFsLmZpZWxkLnZhbCAhPT0gdGhpcy5tb2RlbFBhcnNlZCkge1xuICAgICAgICB2YXIgYSA9IHRoaXMubW9kZWxQYXJzZWQgJiYgdGhpcy5tb2RlbFBhcnNlZC5zcGxpdCgnLicpXG4gICAgICAgICAgLCBwYXJlbnRcbiAgICAgICAgdGhpcy5tb2RlbFBhcnNlZCA9IG51bGxcbiAgICAgICAgaWYodGhpcy5fZCkge1xuICAgICAgICAgIHBhcmVudCA9IHRoaXMuX2RcbiAgICAgICAgICBpZihhKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSBhLmxlbmd0aC0xOyBpID49MCA7IGktLSkge1xuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYocGFyZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMuX2RTZXQocGFyZW50KVxuICAgICAgICAgICAgICB0aGlzLnVwZGF0ZURhdGEodHJ1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVEYXRhKHRydWUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubW9kZWxQYXJzZWQgPSBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYoIHRoaXMuX2QgKVxuICAgICAge1xuICAgICAgICBpZiAoIHRoaXMuX2QuX190ICkgIFxuICAgICAgICB7XG4gICAgICAgICAgdGhpcy5fZC5yZW1vdmVMaXN0ZW5lciggdm9pZCAwLCB0aGlzIClcblxuICAgICAgICAgIGlmKCAhdGhpcy5fZC5jbG91ZCApXG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgICAgICAgdGhpcy5fZC5lYWNoKFxuICAgICAgICAgICAgICBmdW5jdGlvbigpIHsgXG4gICAgICAgICAgICAgICAgLy8gX3RoaXMuX19jaGVja0tleXNfXyA9IHRydWVcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9fdCA9PT0gNCApIHRoaXMucmVtb3ZlTGlzdGVuZXIoIHZvaWQgMCwgX3RoaXMgKSBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoIHRoaXMuX19jaGVja0tleXNfXykgXG4gICAgICAgIHtcbiAgICAgICAgICBmb3IoIHZhciBrZXkkIGluIHRoaXMuX19jaGVja0tleXNfXyApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmKCB0aGlzLl9kW3RoaXMuX19jaGVja0tleXNfX1trZXkkXV0gaW5zdGFuY2VvZiB2T2JqZWN0IClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhpcy5fZFt0aGlzLl9fY2hlY2tLZXlzX19ba2V5JF1dLnJlbW92ZUxpc3RlbmVyKCB2b2lkIDAsIHRoaXMgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBwYXJlbnQ6IGZ1bmN0aW9uKHBhcmVudCkge1xuICAgIC8vICAgaWYoIHBhcmVudC5kYXRhICYmICghcGFyZW50LnBhcmVudCB8fCBwYXJlbnQucGFyZW50LmRhdGEhPT1wYXJlbnQuZGF0YSkgKSB7XG5cbiAgICAvLyAgICAgY29uc29sZS5lcnJvcignV1RGPycpXG5cbiAgICAvLyAgICAgdGhpcy5kYXRhID0gcGFyZW50LmRhdGFcbiAgICAvLyAgIH1cbiAgICAvLyB9XG4gIH0sIHtcbiAgICBuYW1lOiAnZGF0YScsXG4gICAgdHlwZTogZmFsc2UsXG4gICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJz8nLHZhbClcbiAgICAgIGlmKCB0aGlzLl9kID09PSB2YWwgKSByZXR1cm5cblxuICAgICAgLy8gaWYoIXRoaXMubW9kZWwpIHRoaXMubW9kZWwgPSB7fSAvL2RpdCBtZXQgaGV0IG5vb2l0IHNldHRlbiB2YW4gZm1vZGVsIHNjaGVlbCBvcCBzaG93IGFsIDMvOSBzdWJzY3JpcHRpb25zXG4gICAgICAvL251IG5vZyBzaGFyZWQgc3VicyBtYWtlbiAtLSAnc2hvd3MnIChvb2sgbWV0ZWVuIHByb2Nlc3MpIGVuIGRhbiB3b3JkIHRoZXQgYWxzIGhldCBnb2VkIGlzIG5vZyBlZW4gc3R1ayBtaW5kZXJcbiAgICBcbiAgICAgIC8vIHRoaXMubW9kZWwgPSB7fSAvL3BhcyBvcCBtZXQgZGV6ZVxuICAgICAgLy8gY29uc29sZS5sb2coJz8yJylcblxuICAgICAgaWYoIHRoaXMubW9kZWwuX2ZsYWcgJiYgdGhpcy5tb2RlbC5fZmxhZy5kZWZlciApIHtcbiAgICAgICAgdGhpcy5fX3BGbGFnID0gWyB2YWwgXVxuICAgICAgICB0aGlzLl9fcEZsYWdVID0gWyB0cnVlIF1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJyFAIyFAIyFAIyBPT09PJy5yZWQpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBjb25zb2xlLmVycm9yKCchISEhIU1PREVMIC0tIGRpdCBtb2V0IHpvdmVlbCBtb2dlbGlqayBnZXJlZHVjZWQnLCB0aGlzLm1vZGVsKVxuXG4gICAgICB0aGlzLm1vZGVsLnBhcnNpbmcgPSBmYWxzZVxuICAgICAgdGhpcy5fZFNldCh2YWwpXG5cbiAgICAgIC8vc3Vic2NyaWJlIGhlbGVtYWFsIGZ1Y2tlZCBtZXQgZmllbGQgZXJiaWpcbiAgICAgIHRoaXMudXBkYXRlRGF0YSh0cnVlKVxuXG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RcbiAgICB9XG4gIH0pXG59KSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IE1hcmN1cyBCZXNqZXMsIG1hcmN1c0B2aWdvdXIuaW9cbiAqL1xudmFyIGRhdGEgPSByZXF1aXJlKCcuLycpLFxuICBjbnQgPSAwLFxuICBoYW5kbGVUZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih0ZXN0LCBzdWJzT2JqKSB7XG4gICAgLy8gY29uc29sZS5lcnJvcignaGFuZGxlVGVzdCEnLCB0ZXN0KVxuICAgIGlmICh0ZXN0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHRlc3QpO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzWzBdXG4gICAgICAgICAgLCB2YWxjaGVjayA9IGhhbmRsZUZpZWxkKGtleSwgdGVzdFtrZXldLCBzdWJzT2JqKVxuICAgICAgICAgIFxuICAgICAgICByZXR1cm4gc3Vic09iai5fY2hlY2sgPSBmdW5jdGlvbihkb2Mpe1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdURVNUSU5HJywgdGVzdCwgZG9jICYmIGRvYy5yYXcpXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2NoZWNraW5nIGZvciBrZXknLCBrZXkpXG4gICAgICAgICAgdmFyIHZhbCA9IGdldFZhbHVlKGRvYylcbiAgICAgICAgICByZXR1cm4gdmFsY2hlY2sodmFsKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbGlzdCA9IFtdLFxuICAgICAgICAgIGtleTtcbiAgICAgICAgZm9yICh2YXIgayA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgayA8IGw7IGsrKykge1xuICAgICAgICAgIGtleSA9IGtleXNba107XG4gICAgICAgICAgbGlzdC5wdXNoKGhhbmRsZUZpZWxkKGtleSwgdGVzdFtrZXldLCBzdWJzT2JqKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1YnNPYmouX2NoZWNrID0gbWFrZUFORChsaXN0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1YnNPYmouX2NoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBnZXRWYWx1ZShkb2MpID09PSB0ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5mdW5jdGlvbiBoYW5kbGVGaWVsZChrZXksIHZhbHVlLCBzdWJzT2JqKSB7XG4gIC8vIGNvbnNvbGUud2FybignaGFuZGxlRmllbGQgWycsIGtleSwgJ10gdmFsdWUnLCB2YWx1ZSlcbiAgdmFyIGNoZWNrO1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgJyRub3QnOlxuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBzdWJzT2JqKTtcbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICByZXR1cm4gZm9sbG93KGRvYykgPT09IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICByZXR1cm4gZG9jICE9PSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuZSc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gZG9jICE9PSB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckYW5kJzpcbiAgICAgIHZhciBsaXN0ID0gbWFrZUxpc3QodmFsdWUsIHN1YnNPYmopO1xuICAgICAgY2hlY2sgPSBtYWtlQU5EKGxpc3QpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5hbmQnOlxuICAgICAgdmFyIGxpc3QgPSBtYWtlTGlzdCh2YWx1ZSwgc3Vic09iaik7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0oZG9jKSA9PT0gZmFsc2UpIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckb3InOlxuICAgICAgdmFyIGxpc3QgPSBtYWtlTGlzdCh2YWx1ZSwgc3Vic09iaik7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0oZG9jKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRub3InOlxuICAgICAgdmFyIGxpc3QgPSBtYWtlTGlzdCh2YWx1ZSwgc3Vic09iaik7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0oZG9jKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRldmVyeSc6XG4gICAgICBzdWJzT2JqLnNldCgnJCcsIHt9KTtcbiAgICAgIC8vIHN1YnNPYmouJCA9IHtcbiAgICAgIC8vICAgX3VwOiBzdWJzT2JqXG4gICAgICAvLyB9O1xuICAgICAgdmFyIGZvbGxvdyA9IGhhbmRsZVRlc3QodmFsdWUsIHN1YnNPYmouJCk7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBpZiAoZG9jICYmIGRvYy5fX3QgPCAzKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgZG9jLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWZvbGxvdyh0aGlzKSkgcmV0dXJuICEocmVzdWx0ID0gZmFsc2UpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5ldmVyeSc6XG4gICAgICBzdWJzT2JqLnNldCgnJCcsIHt9KTtcbiAgICAgIC8vIHN1YnNPYmouJCA9IHtcbiAgICAgIC8vICAgX3VwOiBzdWJzT2JqXG4gICAgICAvLyB9O1xuICAgICAgdmFyIGZvbGxvdyA9IGhhbmRsZVRlc3QodmFsdWUsIHN1YnNPYmouJCk7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBpZiAoZG9jICYmIGRvYy5fX3QgPCAzKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGRvYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFmb2xsb3codGhpcykpIHJldHVybiByZXN1bHQgPSB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckJzpcbiAgICBjYXNlICckc29tZSc6XG4gICAgICBzdWJzT2JqLnNldCgnJCcsIHt9KTtcbiAgICAgIC8vIHN1YnNPYmouJCA9IHtcbiAgICAgIC8vICAgX3VwOiBzdWJzT2JqXG4gICAgICAvLyB9O1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHZhciBmb2xsb3cgPSBoYW5kbGVUZXN0KHZhbHVlLCBzdWJzT2JqLiQpO1xuICAgICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgIGlmIChkb2MgJiYgZG9jLl9fdCA8IDMpIHtcbiAgICAgICAgICAgIHZhciBmb3VuZDtcbiAgICAgICAgICAgIGRvYy5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICBpZiAoZm9sbG93KHRoaXMpKSByZXR1cm4gZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQgfHwgZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgICAgaWYgKGRvYyAmJiBkb2MuX190IDwgMykge1xuICAgICAgICAgICAgdmFyIGZvdW5kO1xuICAgICAgICAgICAgZG9jLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzID09PSB2YWx1ZSkgcmV0dXJuIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZvdW5kIHx8IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIHN1YnNPYmouJC5fY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgICByZXR1cm4gZG9jID09PSB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuc29tZSc6XG4gICAgICBzdWJzT2JqLnNldCgnJCcsIHt9KTtcbiAgICAgIC8vIHN1YnNPYmouJCA9IHtcbiAgICAgIC8vICAgX3VwOiBzdWJzT2JqXG4gICAgICAvLyB9O1xuICAgICAgdmFyIGZvbGxvdyA9IGhhbmRsZVRlc3QodmFsdWUsIHN1YnNPYmouJCk7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICBpZiAoZG9jICYmIGRvYy5fX3QgPCAzKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IHRydWU7XG4gICAgICAgICAgZG9jLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoZm9sbG93KHRoaXMpKSByZXR1cm4gIShyZXN1bHQgPSBmYWxzZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRsdCc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnYnVyayBsdCcsIGRvYywgdmFsdWUpXG4gICAgICAgIHJldHVybiBkb2MgPCB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbHRlJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MgPD0gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGd0JzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MgPiB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckZ3RlJzpcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiBkb2MgPj0gdmFsdWU7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJGNvbnRhaW5zJzpcbiAgICAgIHZhciByZWdleCA9IG5ldyBSZWdFeHAodmFsdWUsICdpJyk7XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gcmVnZXgudGVzdChkb2MpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuY29udGFpbnMnOlxuICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCh2YWx1ZSwgJ2knKTtcbiAgICAgIGNoZWNrID0gZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHJldHVybiAhcmVnZXgudGVzdChkb2MpO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRjb250YWluc2FsbCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICckbmNvbnRhaW5zYWxsJzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRoYXMnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIGRvYyAmJiBkb2NbdmFsdWVdICE9PSB2b2lkIDA7XG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJG5oYXMnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuICFkb2MgfHwgZG9jW3ZhbHVlXSA9PT0gdm9pZCAwO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRleGlzdHMnOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgcmV0dXJuIChkb2MgIT09IHZvaWQgMCAmJiBkb2MgIT09IG51bGwpID09PSB2YWx1ZTtcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlICckaW4nOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoZG9jID09PSB2YWx1ZVtpXSkgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRuaW4nOlxuICAgICAgY2hlY2sgPSBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoZG9jID09PSB2YWx1ZVtpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyRyZWdleCc6XG4gICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICByZXR1cm4gdmFsdWUudGVzdChkb2MpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICB2YXIgZHN1YnNPYmogPSBzdWJzT2JqW2tleV07XG5cbiAgICAgICAgaWYgKGRzdWJzT2JqKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2FscmVhZHkgbWFkZSB0aGF0IGRzdWJzT2JqIHdpdGgga2V5Jywga2V5KTtcbiAgICAgICAgICAvLyBkc3Vic09iai5fdXAgPSBzdWJzT2JqXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3Vic09iai5zZXQoa2V5LCB7fSk7XG4gICAgICAgICAgZHN1YnNPYmogPSBzdWJzT2JqW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZvbGxvdyA9IGhhbmRsZVRlc3QodmFsdWUsIGRzdWJzT2JqKTtcblxuICAgICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdURVNUSU5HOiBjaGVjayBPQkpFQ1QnLCBkb2MgJiYgZG9jLnJhdyB8fCBkb2MsICdmb3IgZmllbGQnLCBrZXkpXG4gICAgICAgICAgZG9jID0gZ2V0RmllbGQoZG9jLCBrZXkpXG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnd3VwcycsIGRvYyAmJiBkb2MucmF3IHx8IGRvYylcbiAgICAgICAgICByZXR1cm4gZm9sbG93KGRvYyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVjayA9IGZ1bmN0aW9uKGRvYykge1xuICAgICAgICAgIGRvYyA9IGdldEZpZWxkKGRvYywga2V5KVxuICAgICAgICAgIFxuICAgICAgICAgIC8vIGRvYyA9IGdldFZhbHVlKGRvYylcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVEVTVElORzogY2hlY2sgVkFMVUUnLCBkb2MgJiYgZG9jLnJhdyB8fCBkb2MsIHZhbHVlLCBkb2MgPT09IHZhbHVlKVxuICAgICAgICAgIHJldHVybiBkb2MgPT09IHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICBzdWJzT2JqLnNldChrZXksIHt9KTtcbiAgICAgICAgc3Vic09ialtrZXldLl9jaGVjayA9IGNoZWNrXG4gICAgICAgIC8vIHN1YnNPYmpba2V5XSA9IHtcbiAgICAgICAgLy8gICBfdXA6IHN1YnNPYmosXG4gICAgICAgIC8vICAgX2NoZWNrOiBmdW5jdGlvbihkb2MpIHtcbiAgICAgICAgLy8gICAgIHJldHVybiBkb2MgPT09IHZhbHVlO1xuICAgICAgICAvLyAgIH1cbiAgICAgICAgLy8gfTtcbiAgICAgIH1cblxuICB9XG4gIHJldHVybiBzdWJzT2JqID8gc3Vic09iai5fY2hlY2sgPSBjaGVjayA6IGNoZWNrO1xufVxuXG5mdW5jdGlvbiBtYWtlTGlzdChhcnIsIHN1YnNPYmopIHtcbiAgdmFyIGxpc3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcnIubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgbGlzdC5wdXNoKGhhbmRsZVRlc3QoYXJyW2ldLCBzdWJzT2JqKSk7XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbmZ1bmN0aW9uIG1ha2VBTkQobGlzdCwgc3Vic09iaikge1xuICByZXR1cm4gZnVuY3Rpb24oZG9jKSB7XG4gICAgdmFyIHZhbCA9IGdldFZhbHVlKGRvYyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0odmFsKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlKHRoaW5nKXtcbiAgdmFyIHZhbCA9IHRoaW5nICYmIHRoaW5nLmZyb20gJiYgdGhpbmcuZnJvbS52YWxcbiAgcmV0dXJuIHZhbCAhPT0gdm9pZCAwID8gdmFsIDogdGhpbmdcbiAgXG59XG5mdW5jdGlvbiBnZXRGaWVsZCh0aGluZywgZmllbGQpe1xuICAvLyBjb25zb2xlLmVycm9yKCdnZXRGaWVsZCBmaWVsZCcsIGZpZWxkLCAnZnJvbScsIHRoaW5nICYmIHRoaW5nLnJhdyB8fCB0aGluZylcbiAgdGhpbmcgPSBnZXRWYWx1ZSh0aGluZylcbiAgcmV0dXJuIHRoaW5nID8gZ2V0VmFsdWUodGhpbmdbZmllbGRdKSA6IHZvaWQgMFxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBWID0gcmVxdWlyZSgndmlnb3VyLWpzJyksXG4gIG9iamVjdCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFYuRGF0YSA9IG9iamVjdC5uZXcoKTtcbmV4cG9ydHMucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX19zdWInLCdfX2Jsb2NrJyk7XG51dGlsLmRlZmluZShleHBvcnRzLCAnX2hvb2snLCBmdW5jdGlvbih2YWwsIG9iaikge1xuICBpZiAob2JqLnN1YnNjcmlwdGlvbikge1xuICAgIHRoaXMuX19zdWIgPSBvYmouc3Vic2NyaXB0aW9uO1xuICAgIGRlbGV0ZSBvYmouc3Vic2NyaXB0aW9uO1xuICB9XG4gIGlmKG9iai5ibG9jaykge1xuICAgIHRoaXMuX19ibG9jayA9IHRydWVcbiAgICBkZWxldGUgb2JqLmJsb2NrXG4gIH1cbn0pO1xuXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBNYXJjdXMgQmVzamVzLCBtYXJjdXNAdmlnb3VyLmlvXG4gKi9cblxudmFyIGNvbmRpdGlvbnMgPSByZXF1aXJlKCcuL2NvbmRpdGlvbnMnKVxuICAsIHV0aWxIYXNoID0gcmVxdWlyZSgnLi4vdXRpbC9oYXNoJylcbiAgLCBWT2JqZWN0ID0gcmVxdWlyZSgnLi4vb2JqZWN0JylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG5cbi8qKlxuICogU2VsZWN0aW9uXG4gKiBDbGFzcyBleHRlbnRpb24gZm9yIHNlbGVjdGlvbiAvIGZpbHRlcmluZyBmdW5jdGlvbmFsaXR5XG4gKiBAQ2xhc3NcbiAqL1xuXG5leHBvcnRzLlN1YnNPYmogPSBWT2JqZWN0Lm5ldygpXG5leHBvcnRzLlN1YnNPYmoucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCggJ19yb290J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdfY2hlY2snXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ19zb3J0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdfdWlkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG5cbmV4cG9ydHMuZXh0ZW5kID0gdXRpbC5leHRlbmQoZnVuY3Rpb24oYmFzZSl7XG5cbiAgYmFzZS5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCAnX2ZpbHRlcidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX3VpZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLCAnX2hhc2gnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgJ19pbmRleENhY2hlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAsICdfc3Vic2NudCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gIHZhciBfdXBkYXRlID0gYmFzZS5wcm90b3R5cGUuX3VwZGF0ZVxuICAgICwgX2hvb2sgPSBiYXNlLnByb3RvdHlwZS5faG9va1xuICAgICwgX3JlbW92ZSA9IGJhc2UucHJvdG90eXBlLnJlbW92ZVxuXG4gIHV0aWwuZGVmaW5lKCBiYXNlXG4gICAgLCAncmVtb3ZlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBsXG4gICAgICAgIGlmKHRoaXMuX2ZpbHRlciAmJiAobCA9IHRoaXMubGVuZ3RoKSl7XG4gICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGw7IGkrKylcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2ldXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgfVxuICAgICwgJ2ZpbHRlcicsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyXG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ25ldyBmaWx0ZXIgXFxuIGZyb20gLS0tPicsIHRoaXMuX2ZpbHRlciwgJ1xcbiB0byAtLS0tPidcbiAgICAgICAgICAvLyAgICAgICAgICAgICwgdmFsXG4gICAgICAgICAgLy8gICAgICAgICAgICApXG4gICAgICAgICAgdGhpcy5fZmlsdGVyID0gdmFsIC8vbW9ldCBvb2sgd2Vya2VuIGFscyBkYXRhIG5vZyBnZWVuIHNlbGVjdGlvbiBpc1xuICAgICAgICAgIHRoaXMuX2J1aWxkKHVuZGVmaW5lZCwgdHJ1ZSlcbiAgICAgICAgICBfdXBkYXRlLmNhbGwoIHRoaXMsIHZvaWQgMCwgdGhpcy5zdGFtcCgpLCB2b2lkIDAsIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgLCBmYWxzZSwgdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLCAnX2hvb2snLCBmdW5jdGlvbih2YWwsIGZpbHRlcikge1xuICAgICAgICBpZiAoX2hvb2spIHtcbiAgICAgICAgICBfaG9vay5jYWxsKHRoaXMsIHZhbCwgZmlsdGVyKVxuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5lbXB0eShmaWx0ZXIpICYmIHZhbCkge1xuICAgICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzXG4gICAgICAgICAgc2VsZWN0aW9uLl9zdWJzY250ID0gMFxuICAgICAgICAgIHNlbGVjdGlvbi5fZmlsdGVyID0gZmlsdGVyXG5cbiAgICAgICAgICBzZWxlY3Rpb24uX2hhc2ggPSB1dGlsSGFzaCh2YWwuX3BhdGggKyBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIFsgZmlsdGVyLmNvbmRpdGlvblxuICAgICAgICAgICAgLCBmaWx0ZXIucmFuZ2VcbiAgICAgICAgICAgICwgZmlsdGVyLnNvcnRcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgKVxuICAgICAgICAgIC8vIW9ubHkgbmVzc2VjYXJ5IHNlcnZlcnNpZGUhXG4gICAgICAgICAgaWYgKCFzZWxlY3Rpb24uX3VpZCkgc2VsZWN0aW9uLl91aWQgPSBzZWxlY3Rpb24uX2hhc2hcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAsICdfYnVpbGQnLCBmdW5jdGlvbih2YWwsIG5vdXBkYXRlKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSB0aGlzXG4gICAgICAgIFxuICAgICAgICBpZiAoIXZhbCkgdmFsID0gc2VsZWN0aW9uLl92YWxcbiAgICAgICAgaWYoIXZhbCkgcmV0dXJuXG4gICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoKSBzZWxlY3Rpb24uX2NsZWFyKCkgXG5cbiAgICAgICAgdmFyIGxpc3QgPSBbXVxuICAgICAgICAgICwgaXRlbXNIYW5kbGVyID0gdGhpcy5faXRlbXNIYW5kbGVyXG4gICAgICAgICAgLCBmaWx0ZXIgPSBzZWxlY3Rpb24uX2ZpbHRlclxuICAgICAgICAgICwgc3Vic09iaiA9IGZpbHRlci5zdWJzT2JqIHx8IG5ldyBleHBvcnRzLlN1YnNPYmooe30sIHNlbGVjdGlvbilcbiAgICAgICAgICAsIHN0YW1wID0gdGhpcy5zdGFtcCgpXG4gICAgICAgICAgLCBzb3J0LCBpdGVtXG5cbiAgICAgICAgaWYgKHZhbC5fX3QgPT09IDQgJiYgIXZhbC5fZmlsdGVyKSB7XG4gICAgICAgICAgdmFsID0gdmFsLmZyb207XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsdGVyLnNvcnQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlci5zb3J0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZmlsdGVyLnNvcnQgPSB7XG4gICAgICAgICAgICAgIGZpZWxkOiBmaWx0ZXIuc29ydFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzb3J0ID0gZmlsdGVyLnNvcnRcbiAgICAgICAgICBpZiAoIXNvcnQuZm4pIHtcbiAgICAgICAgICAgIGlmICghc29ydC50eXBlKSBzb3J0LnR5cGUgPSAnc3RyaW5nJ1xuICAgICAgICAgICAgc29ydC5mbiA9IHNvcnRNYWtlcnNbc29ydC50eXBlXShzb3J0KVxuICAgICAgICAgIH1cbiAgICAgICAgICBzdWJzT2JqLnBhdGgoc29ydC5maWVsZC5zcGxpdCgnLicpLCB7fSkuc2V0KCdfc29ydCcsIHRydWUpXG4gICAgICAgIH1cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2J1aWxkaW5nPyEnKVxuICAgICAgICBpZiAoZmlsdGVyLmNvbmRpdGlvbikge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdmb3VuZCBjb25kaXRpb24nLCBmaWx0ZXIuY29uZGl0aW9uKVxuICAgICAgICAgIHZhciBwY250ID0gMFxuICAgICAgICAgICAgLCByY250ID0gMFxuICAgICAgICAgIHZhciBjaGVjayA9IGZpbHRlci5jaGVjayBcbiAgICAgICAgICAgICAgICAgfHwgKCBmaWx0ZXIuY2hlY2sgPSBjb25kaXRpb25zKCBmaWx0ZXIuY29uZGl0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICwgc3Vic09ialxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICBmaWx0ZXIuc3Vic09iaiA9IHN1YnNPYmpcbiAgICAgICAgICB2YWwuZWFjaChmdW5jdGlvbihmKSB7XG4gICAgICAgICAgICBpdGVtID0gdGhpc1xuICAgICAgICAgICAgaWYgKGl0ZW1zSGFuZGxlcikgaXRlbXNIYW5kbGVyKGl0ZW0sIHN1YnNPYmosIHNlbGVjdGlvbilcbiAgICAgICAgICAgIGlmIChjaGVjayhpdGVtKSkge1xuICAgICAgICAgICAgICBwY250KytcbiAgICAgICAgICAgICAgbGlzdC5wdXNoKGl0ZW0pXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdGlvbi5faGFzKGl0ZW0pICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0tID4gcmVtb3ZlZCBmcm9tIHNlbGVjdGlvbiBieSBjb25kaXRpb246J1xuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAsIGl0ZW0ucmF3XG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgdW5zdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbilcbiAgICAgICAgICAgICAgaWYoIW5vdXBkYXRlKXtcbiAgICAgICAgICAgICAgICBfdXBkYXRlLmNhbGwoc2VsZWN0aW9uLCBpdGVtLCBzdGFtcCwgc2VsZWN0aW9uLCBpdGVtLCBmYWxzZSwgbnVsbClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByY250KytcbiAgICAgICAgICAgIH0gZWxzZSB7IFxuICAgICAgICAgICAgICByY250KytcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyYW4gY29uZGl0aW9uOiBwYXNzZWQ6JywgcGNudCwgJ3JlamVjdHM6JywgcmNudClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWwuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChpdGVtc0hhbmRsZXIpIGl0ZW1zSGFuZGxlcih0aGlzLCBzdWJzT2JqLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICBsaXN0LnB1c2godGhpcylcbiAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyLnN1YnNPYmogPSBzdWJzT2JqXG5cbiAgICAgICAgaWYgKHNvcnQgJiYgbGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgbGlzdC5zb3J0KGZpbHRlci5zb3J0LmZuKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksIGl0ZW1cblxuICAgICAgICB2YXIgcmFuZ2UgPSBmaWx0ZXIucmFuZ2VcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgaWYgKCEocmFuZ2UgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICAgIHJhbmdlID0gZmlsdGVyLnJhbmdlID0gWzAsIGZpbHRlci5yYW5nZV1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxpc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbmV3bGlzdCA9IGxpc3Quc3BsaWNlKHJhbmdlWzBdLCByYW5nZVsxXSlcbiAgICAgICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyBpdGVtID0gbGlzdFstLWldOykge1xuICAgICAgICAgICAgICBpZihzZWxlY3Rpb24uX2hhcyhpdGVtKSAhPT0gdm9pZCAwKXtcbiAgICAgICAgICAgICAgICB1bnN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIC8vIGlmKCFub3VwZGF0ZSl7XG4gICAgICAgICAgICAgICAgLy8gICBfdXBkYXRlLmNhbGwoc2VsZWN0aW9uLCBpdGVtLCBzdGFtcCwgc2VsZWN0aW9uLCBpdGVtLCBmYWxzZVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgLCBudWxsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ID0gbmV3bGlzdFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCwgaXRlbTsgaXRlbSA9IGxpc3RbLS1pXTspIHtcbiAgICAgICAgICBzZWxlY3Rpb25baV0gPSBpdGVtXG4gICAgICAgICAgdmFyIGlzbmV3ID0gc2VsZWN0aW9uLl9oYXMoaXRlbSkgPT09IHZvaWQgMFxuICAgICAgICAgIHN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uLCBpKVxuICAgICAgICAgIC8vIGlmIChpc25ldykge1xuICAgICAgICAgIC8vICAgaWYoIW5vdXBkYXRlKXtcbiAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ2RvaW5nIHVwZGF0ZSB3aWNrZWRzJylcbiAgICAgICAgICAvLyAgICAgX3VwZGF0ZS5jYWxsKHNlbGVjdGlvbiwgaXRlbSwgc3RhbXAsIHNlbGVjdGlvbiwgZmFsc2UsIGl0ZW0sIG51bGwpICBcbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0aW9uLmxlbmd0aCA9IGxpc3QubGVuZ3RoXG4gICAgICB9XG4gICAgLCAnX3VwZGF0ZScsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9maWx0ZXIpIHtcbiAgICAgICAgICAgLy8gaWYod2luZG93LmhlcmUpIGNvbnNvbGUubG9nKCdodXBzIF91cGRhdGUgb24gc2VsZWN0aW9uIScpXG5cbiAgICAgICAgICB2YXIgc2VsZWN0aW9uID0gdGhpc1xuICAgICAgICAgICAgLCB1cGF0aCA9IHNlbGVjdGlvbi51cGRhdGVQYXRoXG5cbiAgICAgICAgICBpZiAodXBhdGhbMF0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgdmFyIHNob3J0cGF0aCA9IHVwYXRoLmxlbmd0aCA9PT0gMVxuICAgICAgICAgICAgICAsIGl0ZW1yZW1vdmUgPSBzaG9ydHBhdGggJiYgcmVtb3ZlXG4gICAgICAgICAgICAgICwgaXRlbSA9IGl0ZW1yZW1vdmUgPyBzZWxlY3Rpb24uX2xmcm9tIDogc2VsZWN0aW9uLnZhbFt1cGF0aFswXV1cbiAgICAgICAgICAgICAgLCByZWxldmFudFxuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLl92YWwuX2ZpbHRlcikge1xuICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLl92YWwuX2hhcyhpdGVtKSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5faGFzKGl0ZW0pICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fY2hlY2tJdGVtKGl0ZW0sIGZhbHNlLCB2YWwsIHN0YW1wKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhpbnQgPSBpdGVtcmVtb3ZlID8gZmFsc2UgOiAoc2hvcnRwYXRoICYmIGFkZGVkKSA/IHZvaWQgMCA6IHVwYXRoXG5cbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uX2NoZWNrSXRlbShpdGVtLCBoaW50LCB2YWwsIHN0YW1wKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX3VwZGF0ZS5hcHBseShzZWxlY3Rpb24sIGFyZ3VtZW50cykgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdoaXQgb24gc2VsZWN0aW9uIGl0c2VsZj8hJylcbiAgICAgICAgICAgIGlmICghZnJvbSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnXFxuPj4+Pj4+IGhpdCBvbiBzZWxlY3Rpb24gaXRzZWxmIChWLkRhdGEpJylcbiAgICAgICAgICAgICAgaWYgKHJlbW92ZSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoKSBzZWxlY3Rpb24uX2NsZWFyKCkgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX2J1aWxkKClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF91cGRhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgLy8gaWYod2luZG93LmhlcmUpIGNvbnNvbGUubG9nKCdodXBzIF91cGRhdGUgb24gc2VsZWN0aW9uIScsdGhpcylcbiAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ1NFTEVDVCcsIHRoaXMsIGFyZ3VtZW50cywgdGhpcy5fcGF0aClcbiAgICAgICAgICByZXR1cm4gX3VwZGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAsICdfaGFzJywgZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICB2YXIgaW5kZXhDYWNoZSA9IGl0ZW0uX2luZGV4Q2FjaGVcbiAgICAgICAgICAsIHVpZCA9IHRoaXMuX3VpZFxuICAgICAgICAgICwgaWNcblxuICAgICAgICBpZiAoaW5kZXhDYWNoZSAmJiB1aWQgJiYgKGljID0gaW5kZXhDYWNoZVt1aWRdKSkge1xuICAgICAgICAgIHJldHVybiBpY1swXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgLCAnX2NsZWFyJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpc1xuICAgICAgICBzZWxmLmVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgIHNlbGZbZl0gPSB2b2lkIDBcbiAgICAgICAgICBkZWxldGUgc2VsZltmXVxuICAgICAgICB9KVxuICAgICAgICBzZWxmLmxlbmd0aCA9IDBcbiAgICAgIH1cbiAgICAsICdfY2hlY2tJdGVtJywgZnVuY3Rpb24oaXRlbSwgaGludCwgdmFsLCBzdGFtcCkge1xuICAgICAgICBpZighaXRlbSkgeyByZXR1cm4gfVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnX2NoZWNrSXRlbSEnLCBpdGVtLnJhdywgaGludClcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHRoaXNcbiAgICAgICAgICAsIGZyb20gPSBpdGVtXG4gICAgICAgICAgLCBmaWx0ZXIgPSBzZWxlY3Rpb24uX2ZpbHRlclxuICAgICAgICAgICwgc29ydCA9IGZpbHRlci5zb3J0XG4gICAgICAgICAgLCByYW5nZSA9IGZpbHRlci5yYW5nZVxuICAgICAgICAgICwgcmFuZ2VkID0gcmFuZ2UgJiYgISggIHJhbmdlWzBdID09PSAwIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJhbmdlWzFdID49IHNlbGVjdGlvbi5fdmFsLmxlbmd0aCBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCBzZWxlY3Rpb24ubGVuZ3RoIDwgcmFuZ2VbMV0gLSByYW5nZVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAsIHJlbW92ZWQgPSBoaW50ID09PSBmYWxzZSB8fCBpdGVtLl9yZW1vdmVkXG4gICAgICAgICAgLCBhZGRlZCwgaW5kZXgsIGlzaW5cbiAgICAgICAgICAsIHJlc3VsdCA9IGlzaW4gPSAoaW5kZXggPSBzZWxlY3Rpb24uX2hhcyhpdGVtKSkgIT09IHZvaWQgMFxuXG4gICAgICAgIHZhciBjaGVjayA9IGZpbHRlci5jaGVja1xuICAgICAgICAgICwgcGFzcyA9IHJlbW92ZWQgXG4gICAgICAgICAgICAgICAgICAgPyBmYWxzZSBcbiAgICAgICAgICAgICAgICAgICA6ICghcmFuZ2VkICYmIGhpbnQgPT09IDEpIFxuICAgICAgICAgICAgICAgICAgICAgPyBpc2luIFxuICAgICAgICAgICAgICAgICAgICAgOiAhY2hlY2sgfHwgY2hlY2soaXRlbSlcblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PSBjaGVja2l0ZW0gaW4nLCBzZWxlY3Rpb24uX3BhdGgpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpdGVtd2V4JywgaXRlbS5fdmFsICYmIGl0ZW0uX3ZhbC5yYXcpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpc2luJywgaXNpbiwgJ3Bhc3MnLCBwYXNzLCAncmVzdWx0JywgcmVzdWx0KVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0tLS0tLSBjaGVja2VkIGl0ZW0nLCBwYXNzKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlZD8nLCByZW1vdmVkKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygncmFuZ2VkPyAocGFzcyA9PSBhbHJlYWR5IGluKScsICghcmFuZ2VkICYmIGhpbnQgPT09IDEpLCBpc2luKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnb2sgdGltZSBmb3IgY2hlY2tpbmcnLCBjaGVjaylcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NvbmRpdGlvbnMnLCBmaWx0ZXIuY29uZGl0aW9uKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnY2hlY2s/JywgY2hlY2sgJiYgY2hlY2soaXRlbSkpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tJylcbiAgICAgICAgXG4gICAgICAgIGlmIChpc2luICE9PSBwYXNzKSB7XG4gICAgICAgICAgaWYgKGlzaW4pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IDFcbiAgICAgICAgICAgIHVuc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICByZW1vdmVkID0gaXRlbVxuICAgICAgICAgICAgdmFyIG1hcmtcbiAgICAgICAgICAgIHdoaWxlIChtYXJrID0gc2VsZWN0aW9uWysraW5kZXhdKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGlvbltpbmRleCAtIDFdID0gbWFya1xuICAgICAgICAgICAgICBzdG9yZUluZGV4KG1hcmssIHNlbGVjdGlvbiwgaW5kZXggLSAxKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZW5kID0gaW5kZXggLSAxXG4gICAgICAgICAgICBzZWxlY3Rpb25bZW5kXSA9IG51bGxcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3Rpb25bZW5kXVxuXG4gICAgICAgICAgICB2YXIgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgIGlmIChyYW5nZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHNvcnQpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uX3ZhbC5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCAgc2VsZWN0aW9uLl9oYXModGhpcykgPT09IHZvaWQgMCBcbiAgICAgICAgICAgICAgICAgICAgICYmICghc2VsZWN0aW9uW2VuZF0gfHwgc29ydC5mbih0aGlzLCBzZWxlY3Rpb25bZW5kXSkgPCAwKSBcbiAgICAgICAgICAgICAgICAgICAgICYmICghY2hlY2sgfHwgY2hlY2sodGhpcykpXG4gICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSBzZWxlY3Rpb25bZW5kXSA9IHRoaXNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5fdmFsLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIHNlbGVjdGlvbi5faGFzKHRoaXMpID09PSB2b2lkIDAgXG4gICAgICAgICAgICAgICAgICAgICAmJiAoIWNoZWNrIHx8IGNoZWNrKHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlbWVudCA9IHNlbGVjdGlvbltlbmRdID0gdGhpc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uLmxlbmd0aC0tXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdG9yZUluZGV4KHJlcGxhY2VtZW50LCBzZWxlY3Rpb24sIGluZGV4IC0gMSlcbiAgICAgICAgICAgICAgYWRkZWQgPSByZXBsYWNlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgbmV3aW5kZXhcbiAgICAgICAgICAgIGlmIChzb3J0KSB7XG4gICAgICAgICAgICAgIHZhciBzb3J0Zm4gPSBzb3J0LmZuXG4gICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgICAgICAgaWYgKHNvcnRmbihpdGVtLCB0aGlzKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld2luZGV4ID0gZlxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG5ld2luZGV4ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSAxXG4gICAgICAgICAgICAgICAgbmV3aW5kZXggPSBOdW1iZXIobmV3aW5kZXgpXG4gICAgICAgICAgICAgICAgc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24sIG5ld2luZGV4KVxuICAgICAgICAgICAgICAgIGFkZGVkID0gaXRlbVxuICAgICAgICAgICAgICAgIGlmIChyYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZWQgPSBzZWxlY3Rpb25bc2VsZWN0aW9uLmxlbmd0aCAtIDFdXG4gICAgICAgICAgICAgICAgICB1bnN0b3JlSW5kZXgocmVtb3ZlZCwgc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmxlbmd0aCsrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHNlbGVjdGlvbi5sZW5ndGggLSAyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID49IG5ld2luZGV4KSB7XG4gICAgICAgICAgICAgICAgICBzdG9yZUluZGV4KHNlbGVjdGlvbltpbmRleF0sIHNlbGVjdGlvbiwgaW5kZXggKyAxKVxuICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uW2luZGV4ICsgMV0gPSBzZWxlY3Rpb25baW5kZXgtLV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW25ld2luZGV4XSA9IGl0ZW1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICghcmFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgICAgIG5ld2luZGV4ID0gc2VsZWN0aW9uLmxlbmd0aCsrXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uW25ld2luZGV4XSA9IGl0ZW1cbiAgICAgICAgICAgICAgICBzdG9yZUluZGV4KGl0ZW0sIHNlbGVjdGlvbiwgbmV3aW5kZXgpXG4gICAgICAgICAgICAgICAgYWRkZWQgPSBpdGVtXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXJhbmdlZCkge1xuICAgICAgICAgICAgICByZXN1bHQgPSAxXG4gICAgICAgICAgICAgIG5ld2luZGV4ID0gc2VsZWN0aW9uLmxlbmd0aCsrXG4gICAgICAgICAgICAgIHNlbGVjdGlvbltuZXdpbmRleF0gPSBpdGVtXG4gICAgICAgICAgICAgIHN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uLCBuZXdpbmRleClcbiAgICAgICAgICAgICAgYWRkZWQgPSBpdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGlzaW4gJiYgc29ydCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCc/Pz8nLCBzb3J0LCBzb3J0LmZpZWxkLCBoaW50KVxuXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ2lzaW4gKyBzb3J0ISByZXNvcnQ/JylcbiAgICAgICAgICBpZiAoaGludCAmJiBoaW50Lmxlbmd0aCAmJiBzb3J0LmZpZWxkKSB7XG4gICAgICAgICAgICBpZiAofnNvcnQuZmllbGQuaW5kZXhPZignLicpKSB7XG4gICAgICAgICAgICAgIHZhciBzb3J0cGF0aCA9IHNvcnQuZmllbGQuc3BsaXQoJy4nKVxuICAgICAgICAgICAgICBpZiAoIXV0aWwuY29tcGFyZUFycmF5cyhoaW50LnNsaWNlKDEpLCBzb3J0cGF0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChoaW50WzFdICE9PSBzb3J0LmZpZWxkKSByZXR1cm4gcmVzdWx0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc29sZS5sb2coJz8nKVxuXG4gICAgICAgICAgdmFyIG5ld2luZGV4XG4gICAgICAgICAgc2VsZWN0aW9uLmVhY2goZnVuY3Rpb24oZikge1xuICAgICAgICAgICAgaWYgKGYgIT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgdmFyIHMgPSBzb3J0LmZuKGl0ZW0sIHRoaXMpXG4gICAgICAgICAgICAgIGlmIChzID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmID09IGluZGV4ICsgMSkgcmV0dXJuIHRydWVcbiAgICAgICAgICAgICAgICBuZXdpbmRleCA9IGYgPCBpbmRleCA/IGYgOiBmIC0gMVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZiA+PSBpbmRleCArIDEgJiYgcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZiA+IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgbmV3aW5kZXggPSBmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbmV3aW5kZXgnLCBuZXdpbmRleClcbiAgICAgICAgICBpZiAobmV3aW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgdmFyIHRtcFxuICAgICAgICAgICAgaWYgKGluZGV4ID4gbmV3aW5kZXgpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gbmV3aW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0bXAgPSBzZWxlY3Rpb25baW5kZXhdID0gc2VsZWN0aW9uWy0taW5kZXhdXG4gICAgICAgICAgICAgICAgaWYgKHRtcCkgc3RvcmVJbmRleCh0bXAsIHNlbGVjdGlvbiwgaW5kZXggKyAxKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCBuZXdpbmRleCkge1xuICAgICAgICAgICAgICAgIHRtcCA9IHNlbGVjdGlvbltpbmRleF0gPSBzZWxlY3Rpb25bKytpbmRleF1cbiAgICAgICAgICAgICAgICBpZiAodG1wKSBzdG9yZUluZGV4KHRtcCwgc2VsZWN0aW9uLCBpbmRleCAtIDEpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGVjdGlvbltuZXdpbmRleF0gPSBpdGVtXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGVuZCA9IHNlbGVjdGlvbi5sZW5ndGggLSAxXG5cbiAgICAgICAgICBpZiAoICByYW5nZWQgXG4gICAgICAgICAgICAgJiYgKG5ld2luZGV4ID09IGVuZCB8fCBuZXdpbmRleCA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICYmIGluZGV4ID09IGVuZClcbiAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgIHZhciByZXBsYWNlZFxuICAgICAgICAgICAgc2VsZWN0aW9uLl92YWwuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgaWYgKCAgc2VsZWN0aW9uLl9oYXModGhpcykgPT09IHZvaWQgMCBcbiAgICAgICAgICAgICAgICAgJiYgc29ydC5mbih0aGlzLCBpdGVtKSA9PT0gLTEgXG4gICAgICAgICAgICAgICAgICYmICghY2hlY2sgfHwgY2hlY2sodGhpcykpXG4gICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIGlmICghcmVwbGFjZWQpIHJlcGxhY2VkID0gaXRlbVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbltlbmRdID0gaXRlbSA9IHRoaXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHN0b3JlSW5kZXgoaXRlbSwgc2VsZWN0aW9uLCBlbmQpXG4gICAgICAgICAgICBpZiAocmVwbGFjZWQpIHtcbiAgICAgICAgICAgICAgdW5zdG9yZUluZGV4KHJlcGxhY2VkLCBzZWxlY3Rpb24pXG4gICAgICAgICAgICAgIHJlbW92ZWQgPSByZXBsYWNlZFxuICAgICAgICAgICAgICBhZGRlZCA9IGl0ZW1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobmV3aW5kZXggIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgc3RvcmVJbmRleChpdGVtLCBzZWxlY3Rpb24sIE51bWJlcihuZXdpbmRleCkpXG4gICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gMSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGUgZnJvbSBfY2hlY2tJdGVtIScpXG4gICAgICAgICAgc2VsZWN0aW9uLl9fdXBkYXRlKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZWQsIGFkZGVkKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRcbiAgICAgIH1cbiAgICApXG5cbn0pXG5cbnZhciBzdG9yZUluZGV4ID0gZXhwb3J0cy5zdG9yZUluZGV4ID0gZnVuY3Rpb24oaXRlbSwgc2VsZWN0aW9uLCBpbmRleCkge1xuICAvLyBjb25zb2xlLmxvZygnc3RvcmVJbmRleCEgaXRlbScsIGl0ZW0uX25hbWUsICdAJywgaW5kZXgpXG4gIHZhciBpbmRleENhY2hlID0gaXRlbS5faW5kZXhDYWNoZVxuICAgICwgaWNcbiAgaWYgKGluZGV4Q2FjaGUpIHtcbiAgICBpYyA9IGluZGV4Q2FjaGVbc2VsZWN0aW9uLl91aWRdXG4gICAgaWYgKGljKSB7XG4gICAgICBpY1sxXSA9IGljWzBdXG4gICAgICBpY1swXSA9IGluZGV4XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4Q2FjaGVbc2VsZWN0aW9uLl91aWRdID0gW2luZGV4XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpdGVtLl9pbmRleENhY2hlID0ge31cbiAgICBpdGVtLl9pbmRleENhY2hlW3NlbGVjdGlvbi5fdWlkXSA9IFtpbmRleF1cbiAgfVxufVxuXG52YXIgdW5zdG9yZUluZGV4ID0gZXhwb3J0cy51bnN0b3JlSW5kZXggPSBmdW5jdGlvbihpdGVtLCBzZWxlY3Rpb24pIHtcbiAgdmFyIGluZGV4Q2FjaGUgPSBpdGVtLl9pbmRleENhY2hlXG4gIGlmIChpbmRleENhY2hlKSB7XG4gICAgdmFyIGljID0gaW5kZXhDYWNoZVtzZWxlY3Rpb24uX3VpZF1cbiAgICBpY1sxXSA9IGljWzBdXG4gICAgaWNbMF0gPSB2b2lkIDBcbiAgfVxufVxuXG52YXIgc29ydE1ha2VycyA9IHtcbiAgbnVtYmVyOiBmdW5jdGlvbihzb3J0KSB7XG4gICAgdmFyIGZpZWxkID0gc29ydC5maWVsZFxuICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgdmEgPSBhW2ZpZWxkXSAmJiBhW2ZpZWxkXS52YWxcbiAgICAgICAgLCB2YiA9IGJbZmllbGRdICYmIGJbZmllbGRdLnZhbFxuICAgICAgaWYgKHZhID09PSB2b2lkIDAgfHwgdmIgPT09IHZvaWQgMCkge1xuICAgICAgICByZXR1cm4gdmEgPT09IHZiIFxuICAgICAgICAgICAgICAgPyAwIFxuICAgICAgICAgICAgICAgOiB2YSA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICAgICA/IDEgXG4gICAgICAgICAgICAgICAgIDogLTFcbiAgICAgIH1cbiAgICAgIHJldHVybiBzb3J0Lm9yZGVyIFxuICAgICAgICAgICAgID8gKHZhIC0gdmIpICogLTEgXG4gICAgICAgICAgICAgOiB2YSAtIHZiXG4gICAgfVxuICB9LFxuICBzdHJpbmc6IGZ1bmN0aW9uKHNvcnQpIHtcbiAgICB2YXIgZmllbGQgPSBzb3J0LmZpZWxkXG4gICAgaWYgKH5maWVsZC5pbmRleE9mKCcuJykpIHtcbiAgICAgIHZhciBwYXRoID0gZmllbGQuc3BsaXQoJy4nKVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgYSA9IGdldERvdEZpZWxkVmFsKGEsIHBhdGgpXG4gICAgICAgIGIgPSBnZXREb3RGaWVsZFZhbChiLCBwYXRoKVxuICAgICAgICBpZiAoYSA9PT0gdm9pZCAwIHx8IGIgPT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldHVybiBhID09PSBiIFxuICAgICAgICAgICAgICAgICA/IDAgXG4gICAgICAgICAgICAgICAgIDogYSA9PT0gdm9pZCAwIFxuICAgICAgICAgICAgICAgICAgID8gMSBcbiAgICAgICAgICAgICAgICAgICA6IC0xXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlID0gYSA+IGIgXG4gICAgICAgICAgICAgICAgID8gMSBcbiAgICAgICAgICAgICAgICAgOiBhID09PSBiIFxuICAgICAgICAgICAgICAgICAgID8gMCBcbiAgICAgICAgICAgICAgICAgICA6IC0xXG4gICAgICAgIHJldHVybiBzb3J0Lm9yZGVyID8gcmUgKiAtMSA6IHJlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGEgPSBnZXRGaWVsZFZhbChhLCBmaWVsZClcbiAgICAgICAgYiA9IGdldEZpZWxkVmFsKGIsIGZpZWxkKVxuICAgICAgICB2YXIgd2Vha0EgPSBhID09PSB2b2lkIDAgfHwgYSA9PT0gbnVsbFxuICAgICAgICAgICwgd2Vha0IgPSBiID09PSB2b2lkIDAgfHwgYiA9PT0gbnVsbFxuICAgICAgICBpZiAod2Vha0EgfHwgd2Vha0IpIHtcbiAgICAgICAgICByZXR1cm4gYSA9PT0gYiA/IDAgOiB3ZWFrQSA/IDEgOiAtMVxuICAgICAgICB9XG4gICAgICAgIHZhciByZSA9IGEgPiBiIFxuICAgICAgICAgICAgICAgICA/IDEgXG4gICAgICAgICAgICAgICAgIDogYSA9PT0gYiBcbiAgICAgICAgICAgICAgICAgICA/IDAgXG4gICAgICAgICAgICAgICAgICAgOiAtMVxuICAgICAgICByZXR1cm4gc29ydC5vcmRlciA/IHJlICogLTEgOiByZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbChvYmosIGZpZWxkKSB7XG4gIHZhciB2ID0gb2JqLnZhbFxuICByZXR1cm4gdiAmJiB2W2ZpZWxkXSAmJiB2W2ZpZWxkXS52YWxcbn1cblxuZnVuY3Rpb24gZ2V0RG90RmllbGRWYWwob2JqLCBmaWVsZCkge1xuICB2YXIgdiA9IG9iai5wYXRoKGZpZWxkKVxuICByZXR1cm4gdiAmJiB2LnZhbFxufVxuXG5mdW5jdGlvbiBwdXRTb3J0KHBhdGgpIHtcbiAgdmFyIG9iaiA9IHBhcnQgPSB7fVxuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGgubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcGFydCA9IHBhcnRbcGF0aFtpXV0gPSB7XG4gICAgICBfdXA6IHBhcnRcbiAgICB9XG4gIH1cbiAgcGFydC5fc29ydCA9IHRydWVcbiAgcmV0dXJuIG9ialxufVxuIiwiLy9WIG9ubHkgdXNlZCBhcyBhIHJlZmVyZW5jZSBub3cuLi5cbiIsIi8qXG5jb2xvcnMuanNcblxuQ29weXJpZ2h0IChjKSAyMDEwXG5cbk1hcmFrIFNxdWlyZXNcbkFsZXhpcyBTZWxsaWVyIChjbG91ZGhlYWQpXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS5cblxuKi9cblxudmFyIGlzSGVhZGxlc3MgPSBmYWxzZTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlzSGVhZGxlc3MgPSB0cnVlO1xufVxuXG5pZiAoIWlzSGVhZGxlc3MpIHtcbiAgdmFyIGV4cG9ydHMgPSB7fTtcbiAgdmFyIG1vZHVsZSA9IHt9O1xuICB2YXIgY29sb3JzID0gZXhwb3J0cztcbiAgZXhwb3J0cy5tb2RlID0gXCJicm93c2VyXCI7XG59IGVsc2Uge1xuICBleHBvcnRzLm1vZGUgPSBcImNvbnNvbGVcIjtcbn1cblxuLy9cbi8vIFByb3RvdHlwZXMgdGhlIHN0cmluZyBvYmplY3QgdG8gaGF2ZSBhZGRpdGlvbmFsIG1ldGhvZCBjYWxscyB0aGF0IGFkZCB0ZXJtaW5hbCBjb2xvcnNcbi8vXG52YXIgYWRkUHJvcGVydHkgPSBmdW5jdGlvbiAoY29sb3IsIGZ1bmMpIHtcbiAgZXhwb3J0c1tjb2xvcl0gPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkoc3RyKTtcbiAgfTtcbiAgU3RyaW5nLnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fKGNvbG9yLCBmdW5jKTtcbn07XG5cbmZ1bmN0aW9uIHN0eWxpemUoc3RyLCBzdHlsZSkge1xuXG4gIHZhciBzdHlsZXM7XG5cbiAgaWYgKGV4cG9ydHMubW9kZSA9PT0gJ2NvbnNvbGUnKSB7XG4gICAgc3R5bGVzID0ge1xuICAgICAgLy9zdHlsZXNcbiAgICAgICdib2xkJyAgICAgIDogWydcXHgxQlsxbScsICAnXFx4MUJbMjJtJ10sXG4gICAgICAnaXRhbGljJyAgICA6IFsnXFx4MUJbM20nLCAgJ1xceDFCWzIzbSddLFxuICAgICAgJ3VuZGVybGluZScgOiBbJ1xceDFCWzRtJywgICdcXHgxQlsyNG0nXSxcbiAgICAgICdpbnZlcnNlJyAgIDogWydcXHgxQls3bScsICAnXFx4MUJbMjdtJ10sXG4gICAgICAnc3RyaWtldGhyb3VnaCcgOiBbJ1xceDFCWzltJywgICdcXHgxQlsyOW0nXSxcbiAgICAgIC8vdGV4dCBjb2xvcnNcbiAgICAgIC8vZ3JheXNjYWxlXG4gICAgICAnd2hpdGUnICAgICA6IFsnXFx4MUJbMzdtJywgJ1xceDFCWzM5bSddLFxuICAgICAgJ2dyZXknICAgICAgOiBbJ1xceDFCWzkwbScsICdcXHgxQlszOW0nXSxcbiAgICAgICdibGFjaycgICAgIDogWydcXHgxQlszMG0nLCAnXFx4MUJbMzltJ10sXG4gICAgICAvL2NvbG9yc1xuICAgICAgJ2JsdWUnICAgICAgOiBbJ1xceDFCWzM0bScsICdcXHgxQlszOW0nXSxcbiAgICAgICdjeWFuJyAgICAgIDogWydcXHgxQlszNm0nLCAnXFx4MUJbMzltJ10sXG4gICAgICAnZ3JlZW4nICAgICA6IFsnXFx4MUJbMzJtJywgJ1xceDFCWzM5bSddLFxuICAgICAgJ21hZ2VudGEnICAgOiBbJ1xceDFCWzM1bScsICdcXHgxQlszOW0nXSxcbiAgICAgICdyZWQnICAgICAgIDogWydcXHgxQlszMW0nLCAnXFx4MUJbMzltJ10sXG4gICAgICAneWVsbG93JyAgICA6IFsnXFx4MUJbMzNtJywgJ1xceDFCWzM5bSddLFxuICAgICAgLy9iYWNrZ3JvdW5kIGNvbG9yc1xuICAgICAgLy9ncmF5c2NhbGVcbiAgICAgICd3aGl0ZUJHJyAgICAgOiBbJ1xceDFCWzQ3bScsICdcXHgxQls0OW0nXSxcbiAgICAgICdncmV5QkcnICAgICAgOiBbJ1xceDFCWzQ5OzU7OG0nLCAnXFx4MUJbNDltJ10sXG4gICAgICAnYmxhY2tCRycgICAgIDogWydcXHgxQls0MG0nLCAnXFx4MUJbNDltJ10sXG4gICAgICAvL2NvbG9yc1xuICAgICAgJ2JsdWVCRycgICAgICA6IFsnXFx4MUJbNDRtJywgJ1xceDFCWzQ5bSddLFxuICAgICAgJ2N5YW5CRycgICAgICA6IFsnXFx4MUJbNDZtJywgJ1xceDFCWzQ5bSddLFxuICAgICAgJ2dyZWVuQkcnICAgICA6IFsnXFx4MUJbNDJtJywgJ1xceDFCWzQ5bSddLFxuICAgICAgJ21hZ2VudGFCRycgICA6IFsnXFx4MUJbNDVtJywgJ1xceDFCWzQ5bSddLFxuICAgICAgJ3JlZEJHJyAgICAgICA6IFsnXFx4MUJbNDFtJywgJ1xceDFCWzQ5bSddLFxuICAgICAgJ3llbGxvd0JHJyAgICA6IFsnXFx4MUJbNDNtJywgJ1xceDFCWzQ5bSddXG4gICAgfTtcbiAgfSBlbHNlIGlmIChleHBvcnRzLm1vZGUgPT09ICdicm93c2VyJykge1xuICAgIHN0eWxlcyA9IHtcbiAgICAgIC8vc3R5bGVzXG4gICAgICAnYm9sZCcgICAgICA6IFsnPGI+JywgICc8L2I+J10sXG4gICAgICAnaXRhbGljJyAgICA6IFsnPGk+JywgICc8L2k+J10sXG4gICAgICAndW5kZXJsaW5lJyA6IFsnPHU+JywgICc8L3U+J10sXG4gICAgICAnaW52ZXJzZScgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOmJsYWNrO2NvbG9yOndoaXRlO1wiPicsICAnPC9zcGFuPiddLFxuICAgICAgJ3N0cmlrZXRocm91Z2gnIDogWyc8ZGVsPicsICAnPC9kZWw+J10sXG4gICAgICAvL3RleHQgY29sb3JzXG4gICAgICAvL2dyYXlzY2FsZVxuICAgICAgJ3doaXRlJyAgICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6d2hpdGU7XCI+JywgICAnPC9zcGFuPiddLFxuICAgICAgJ2dyZXknICAgICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6Z3JheTtcIj4nLCAgICAnPC9zcGFuPiddLFxuICAgICAgJ2JsYWNrJyAgICAgOiBbJzxzcGFuIHN0eWxlPVwiY29sb3I6YmxhY2s7XCI+JywgICAnPC9zcGFuPiddLFxuICAgICAgLy9jb2xvcnNcbiAgICAgICdibHVlJyAgICAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOmJsdWU7XCI+JywgICAgJzwvc3Bhbj4nXSxcbiAgICAgICdjeWFuJyAgICAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOmN5YW47XCI+JywgICAgJzwvc3Bhbj4nXSxcbiAgICAgICdncmVlbicgICAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOmdyZWVuO1wiPicsICAgJzwvc3Bhbj4nXSxcbiAgICAgICdtYWdlbnRhJyAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOm1hZ2VudGE7XCI+JywgJzwvc3Bhbj4nXSxcbiAgICAgICdyZWQnICAgICAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOnJlZDtcIj4nLCAgICAgJzwvc3Bhbj4nXSxcbiAgICAgICd5ZWxsb3cnICAgIDogWyc8c3BhbiBzdHlsZT1cImNvbG9yOnllbGxvdztcIj4nLCAgJzwvc3Bhbj4nXSxcbiAgICAgIC8vYmFja2dyb3VuZCBjb2xvcnNcbiAgICAgIC8vZ3JheXNjYWxlXG4gICAgICAnd2hpdGVCRycgICAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6d2hpdGU7XCI+JywgICAnPC9zcGFuPiddLFxuICAgICAgJ2dyZXlCRycgICAgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOmdyYXk7XCI+JywgICAgJzwvc3Bhbj4nXSxcbiAgICAgICdibGFja0JHJyAgICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpibGFjaztcIj4nLCAgICc8L3NwYW4+J10sXG4gICAgICAvL2NvbG9yc1xuICAgICAgJ2JsdWVCRycgICAgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOmJsdWU7XCI+JywgICAgJzwvc3Bhbj4nXSxcbiAgICAgICdjeWFuQkcnICAgICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpjeWFuO1wiPicsICAgICc8L3NwYW4+J10sXG4gICAgICAnZ3JlZW5CRycgICAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6Z3JlZW47XCI+JywgICAnPC9zcGFuPiddLFxuICAgICAgJ21hZ2VudGFCRycgICA6IFsnPHNwYW4gc3R5bGU9XCJiYWNrZ3JvdW5kLWNvbG9yOm1hZ2VudGE7XCI+JywgJzwvc3Bhbj4nXSxcbiAgICAgICdyZWRCRycgICAgICAgOiBbJzxzcGFuIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjpyZWQ7XCI+JywgICAgICc8L3NwYW4+J10sXG4gICAgICAneWVsbG93QkcnICAgIDogWyc8c3BhbiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6eWVsbG93O1wiPicsICAnPC9zcGFuPiddXG4gICAgfTtcbiAgfSBlbHNlIGlmIChleHBvcnRzLm1vZGUgPT09ICdub25lJykge1xuICAgIHJldHVybiBzdHIgKyAnJztcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZygndW5zdXBwb3J0ZWQgbW9kZSwgdHJ5IFwiYnJvd3NlclwiLCBcImNvbnNvbGVcIiBvciBcIm5vbmVcIicpO1xuICB9XG4gIHJldHVybiBzdHlsZXNbc3R5bGVdWzBdICsgc3RyICsgc3R5bGVzW3N0eWxlXVsxXTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUaGVtZSh0aGVtZSkge1xuXG4gIC8vXG4gIC8vIFJlbWFyazogVGhpcyBpcyBhIGxpc3Qgb2YgbWV0aG9kcyB0aGF0IGV4aXN0XG4gIC8vIG9uIFN0cmluZyB0aGF0IHlvdSBzaG91bGQgbm90IG92ZXJ3cml0ZS5cbiAgLy9cbiAgdmFyIHN0cmluZ1Byb3RvdHlwZUJsYWNrbGlzdCA9IFtcbiAgICAnX19kZWZpbmVHZXR0ZXJfXycsICdfX2RlZmluZVNldHRlcl9fJywgJ19fbG9va3VwR2V0dGVyX18nLCAnX19sb29rdXBTZXR0ZXJfXycsICdjaGFyQXQnLCAnY29uc3RydWN0b3InLFxuICAgICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ3RvTG9jYWxlU3RyaW5nJywgJ3RvU3RyaW5nJywgJ3ZhbHVlT2YnLCAnY2hhckNvZGVBdCcsXG4gICAgJ2luZGV4T2YnLCAnbGFzdEluZGV4b2YnLCAnbGVuZ3RoJywgJ2xvY2FsZUNvbXBhcmUnLCAnbWF0Y2gnLCAncmVwbGFjZScsICdzZWFyY2gnLCAnc2xpY2UnLCAnc3BsaXQnLCAnc3Vic3RyaW5nJyxcbiAgICAndG9Mb2NhbGVMb3dlckNhc2UnLCAndG9Mb2NhbGVVcHBlckNhc2UnLCAndG9Mb3dlckNhc2UnLCAndG9VcHBlckNhc2UnLCAndHJpbScsICd0cmltTGVmdCcsICd0cmltUmlnaHQnXG4gIF07XG5cbiAgT2JqZWN0LmtleXModGhlbWUpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICBpZiAoc3RyaW5nUHJvdG90eXBlQmxhY2tsaXN0LmluZGV4T2YocHJvcCkgIT09IC0xKSB7XG4gICAgICBjb25zb2xlLmxvZygnd2FybjogJy5yZWQgKyAoJ1N0cmluZy5wcm90b3R5cGUnICsgcHJvcCkubWFnZW50YSArICcgaXMgcHJvYmFibHkgc29tZXRoaW5nIHlvdSBkb25cXCd0IHdhbnQgdG8gb3ZlcnJpZGUuIElnbm9yaW5nIHN0eWxlIG5hbWUnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAodHlwZW9mKHRoZW1lW3Byb3BdKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYWRkUHJvcGVydHkocHJvcCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBleHBvcnRzW3RoZW1lW3Byb3BdXSh0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgYWRkUHJvcGVydHkocHJvcCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciByZXQgPSB0aGlzO1xuICAgICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgdGhlbWVbcHJvcF0ubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgIHJldCA9IGV4cG9ydHNbdGhlbWVbcHJvcF1bdF1dKHJldCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cblxuLy9cbi8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgZGVmYXVsdCBzdHlsZXMgYW5kIGNvbG9yc1xuLy9cbnZhciB4ID0gWydib2xkJywgJ3VuZGVybGluZScsICdzdHJpa2V0aHJvdWdoJywgJ2l0YWxpYycsICdpbnZlcnNlJywgJ2dyZXknLCAnYmxhY2snLCAneWVsbG93JywgJ3JlZCcsICdncmVlbicsICdibHVlJywgJ3doaXRlJywgJ2N5YW4nLCAnbWFnZW50YScsICdncmV5QkcnLCAnYmxhY2tCRycsICd5ZWxsb3dCRycsICdyZWRCRycsICdncmVlbkJHJywgJ2JsdWVCRycsICd3aGl0ZUJHJywgJ2N5YW5CRycsICdtYWdlbnRhQkcnXTtcbnguZm9yRWFjaChmdW5jdGlvbiAoc3R5bGUpIHtcblxuICAvLyBfX2RlZmluZUdldHRlcl9fIGF0IHRoZSBsZWFzdCB3b3JrcyBpbiBtb3JlIGJyb3dzZXJzXG4gIC8vIGh0dHA6Ly9yb2JlcnRueW1hbi5jb20vamF2YXNjcmlwdC9qYXZhc2NyaXB0LWdldHRlcnMtc2V0dGVycy5odG1sXG4gIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBvbmx5IHdvcmtzIGluIENocm9tZVxuICBhZGRQcm9wZXJ0eShzdHlsZSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzdHlsaXplKHRoaXMsIHN0eWxlKTtcbiAgfSk7XG59KTtcblxuZnVuY3Rpb24gc2VxdWVuY2VyKG1hcCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghaXNIZWFkbGVzcykge1xuICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZSgvKCApLywgJyQxJyk7XG4gICAgfVxuICAgIHZhciBleHBsb2RlZCA9IHRoaXMuc3BsaXQoXCJcIiksIGkgPSAwO1xuICAgIGV4cGxvZGVkID0gZXhwbG9kZWQubWFwKG1hcCk7XG4gICAgcmV0dXJuIGV4cGxvZGVkLmpvaW4oXCJcIik7XG4gIH07XG59XG5cbnZhciByYWluYm93TWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhaW5ib3dDb2xvcnMgPSBbJ3JlZCcsICd5ZWxsb3cnLCAnZ3JlZW4nLCAnYmx1ZScsICdtYWdlbnRhJ107IC8vUm9ZIEcgQmlWXG4gIHJldHVybiBmdW5jdGlvbiAobGV0dGVyLCBpLCBleHBsb2RlZCkge1xuICAgIGlmIChsZXR0ZXIgPT09IFwiIFwiKSB7XG4gICAgICByZXR1cm4gbGV0dGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3R5bGl6ZShsZXR0ZXIsIHJhaW5ib3dDb2xvcnNbaSsrICUgcmFpbmJvd0NvbG9ycy5sZW5ndGhdKTtcbiAgICB9XG4gIH07XG59KSgpO1xuXG5leHBvcnRzLnRoZW1lcyA9IHt9O1xuXG5leHBvcnRzLmFkZFNlcXVlbmNlciA9IGZ1bmN0aW9uIChuYW1lLCBtYXApIHtcbiAgYWRkUHJvcGVydHkobmFtZSwgc2VxdWVuY2VyKG1hcCkpO1xufTtcblxuZXhwb3J0cy5hZGRTZXF1ZW5jZXIoJ3JhaW5ib3cnLCByYWluYm93TWFwKTtcbmV4cG9ydHMuYWRkU2VxdWVuY2VyKCd6ZWJyYScsIGZ1bmN0aW9uIChsZXR0ZXIsIGksIGV4cGxvZGVkKSB7XG4gIHJldHVybiBpICUgMiA9PT0gMCA/IGxldHRlciA6IGxldHRlci5pbnZlcnNlO1xufSk7XG5cbmV4cG9ydHMuc2V0VGhlbWUgPSBmdW5jdGlvbiAodGhlbWUpIHtcbiAgaWYgKHR5cGVvZiB0aGVtZSA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgZXhwb3J0cy50aGVtZXNbdGhlbWVdID0gcmVxdWlyZSh0aGVtZSk7XG4gICAgICBhcHBseVRoZW1lKGV4cG9ydHMudGhlbWVzW3RoZW1lXSk7XG4gICAgICByZXR1cm4gZXhwb3J0cy50aGVtZXNbdGhlbWVdO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFwcGx5VGhlbWUodGhlbWUpO1xuICB9XG59O1xuXG5cbmFkZFByb3BlcnR5KCdzdHJpcENvbG9ycycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIChcIlwiICsgdGhpcykucmVwbGFjZSgvXFx4MUJcXFtcXGQrbS9nLCAnJyk7XG59KTtcblxuLy8gcGxlYXNlIG5vXG5mdW5jdGlvbiB6YWxnbyh0ZXh0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VsID0ge1xuICAgIFwidXBcIiA6IFtcbiAgICAgICfMjScsICfMjicsICfMhCcsICfMhScsXG4gICAgICAnzL8nLCAnzJEnLCAnzIYnLCAnzJAnLFxuICAgICAgJ82SJywgJ82XJywgJ82RJywgJ8yHJyxcbiAgICAgICfMiCcsICfMiicsICfNgicsICfMkycsXG4gICAgICAnzIgnLCAnzYonLCAnzYsnLCAnzYwnLFxuICAgICAgJ8yDJywgJ8yCJywgJ8yMJywgJ82QJyxcbiAgICAgICfMgCcsICfMgScsICfMiycsICfMjycsXG4gICAgICAnzJInLCAnzJMnLCAnzJQnLCAnzL0nLFxuICAgICAgJ8yJJywgJ82jJywgJ82kJywgJ82lJyxcbiAgICAgICfNpicsICfNpycsICfNqCcsICfNqScsXG4gICAgICAnzaonLCAnzasnLCAnzawnLCAnza0nLFxuICAgICAgJ82uJywgJ82vJywgJ8y+JywgJ82bJyxcbiAgICAgICfNhicsICfMmidcbiAgICBdLFxuICAgIFwiZG93blwiIDogW1xuICAgICAgJ8yWJywgJ8yXJywgJ8yYJywgJ8yZJyxcbiAgICAgICfMnCcsICfMnScsICfMnicsICfMnycsXG4gICAgICAnzKAnLCAnzKQnLCAnzKUnLCAnzKYnLFxuICAgICAgJ8ypJywgJ8yqJywgJ8yrJywgJ8ysJyxcbiAgICAgICfMrScsICfMricsICfMrycsICfMsCcsXG4gICAgICAnzLEnLCAnzLInLCAnzLMnLCAnzLknLFxuICAgICAgJ8y6JywgJ8y7JywgJ8y8JywgJ82FJyxcbiAgICAgICfNhycsICfNiCcsICfNiScsICfNjScsXG4gICAgICAnzY4nLCAnzZMnLCAnzZQnLCAnzZUnLFxuICAgICAgJ82WJywgJ82ZJywgJ82aJywgJ8yjJ1xuICAgIF0sXG4gICAgXCJtaWRcIiA6IFtcbiAgICAgICfMlScsICfMmycsICfMgCcsICfMgScsXG4gICAgICAnzZgnLCAnzKEnLCAnzKInLCAnzKcnLFxuICAgICAgJ8yoJywgJ8y0JywgJ8y1JywgJ8y2JyxcbiAgICAgICfNnCcsICfNnScsICfNnicsXG4gICAgICAnzZ8nLCAnzaAnLCAnzaInLCAnzLgnLFxuICAgICAgJ8y3JywgJ82hJywgJyDSiSdcbiAgICBdXG4gIH0sXG4gIGFsbCA9IFtdLmNvbmNhdChzb3VsLnVwLCBzb3VsLmRvd24sIHNvdWwubWlkKSxcbiAgemFsZ28gPSB7fTtcblxuICBmdW5jdGlvbiByYW5kb21OdW1iZXIocmFuZ2UpIHtcbiAgICB2YXIgciA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIHJhbmdlKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzX2NoYXIoY2hhcmFjdGVyKSB7XG4gICAgdmFyIGJvb2wgPSBmYWxzZTtcbiAgICBhbGwuZmlsdGVyKGZ1bmN0aW9uIChpKSB7XG4gICAgICBib29sID0gKGkgPT09IGNoYXJhY3Rlcik7XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvb2w7XG4gIH1cblxuICBmdW5jdGlvbiBoZUNvbWVzKHRleHQsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmVzdWx0ID0gJycsIGNvdW50cywgbDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zW1widXBcIl0gPSBvcHRpb25zW1widXBcIl0gfHwgdHJ1ZTtcbiAgICBvcHRpb25zW1wibWlkXCJdID0gb3B0aW9uc1tcIm1pZFwiXSB8fCB0cnVlO1xuICAgIG9wdGlvbnNbXCJkb3duXCJdID0gb3B0aW9uc1tcImRvd25cIl0gfHwgdHJ1ZTtcbiAgICBvcHRpb25zW1wic2l6ZVwiXSA9IG9wdGlvbnNbXCJzaXplXCJdIHx8IFwibWF4aVwiO1xuICAgIHRleHQgPSB0ZXh0LnNwbGl0KCcnKTtcbiAgICBmb3IgKGwgaW4gdGV4dCkge1xuICAgICAgaWYgKGlzX2NoYXIobCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByZXN1bHQgPSByZXN1bHQgKyB0ZXh0W2xdO1xuICAgICAgY291bnRzID0ge1widXBcIiA6IDAsIFwiZG93blwiIDogMCwgXCJtaWRcIiA6IDB9O1xuICAgICAgc3dpdGNoIChvcHRpb25zLnNpemUpIHtcbiAgICAgIGNhc2UgJ21pbmknOlxuICAgICAgICBjb3VudHMudXAgPSByYW5kb21OdW1iZXIoOCk7XG4gICAgICAgIGNvdW50cy5taW4gPSByYW5kb21OdW1iZXIoMik7XG4gICAgICAgIGNvdW50cy5kb3duID0gcmFuZG9tTnVtYmVyKDgpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ21heGknOlxuICAgICAgICBjb3VudHMudXAgPSByYW5kb21OdW1iZXIoMTYpICsgMztcbiAgICAgICAgY291bnRzLm1pbiA9IHJhbmRvbU51bWJlcig0KSArIDE7XG4gICAgICAgIGNvdW50cy5kb3duID0gcmFuZG9tTnVtYmVyKDY0KSArIDM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY291bnRzLnVwID0gcmFuZG9tTnVtYmVyKDgpICsgMTtcbiAgICAgICAgY291bnRzLm1pZCA9IHJhbmRvbU51bWJlcig2KSAvIDI7XG4gICAgICAgIGNvdW50cy5kb3duID0gcmFuZG9tTnVtYmVyKDgpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBhcnIgPSBbXCJ1cFwiLCBcIm1pZFwiLCBcImRvd25cIl07XG4gICAgICBmb3IgKHZhciBkIGluIGFycikge1xuICAgICAgICB2YXIgaW5kZXggPSBhcnJbZF07XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8PSBjb3VudHNbaW5kZXhdOyBpKyspIHtcbiAgICAgICAgICBpZiAob3B0aW9uc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdCArIHNvdWxbaW5kZXhdW3JhbmRvbU51bWJlcihzb3VsW2luZGV4XS5sZW5ndGgpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGVDb21lcyh0ZXh0KTtcbn1cblxuXG4vLyBkb24ndCBzdW1tb24gemFsZ29cbmFkZFByb3BlcnR5KCd6YWxnbycsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHphbGdvKHRoaXMpO1xufSk7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gIHJlcXVpcmUoJy4vbGliLycpO1xuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0cyBwYXJzZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB0cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnNvY2tldCcpO1xudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgcGFyc2Vqc29uID0gcmVxdWlyZSgncGFyc2Vqc29uJyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBOb29wIGZ1bmN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9XG5cbi8qKlxuICogU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gdXJpIG9yIG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldCh1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja2V0KSkgcmV0dXJuIG5ldyBTb2NrZXQodXJpLCBvcHRzKTtcblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBpZiAodXJpICYmICdvYmplY3QnID09IHR5cGVvZiB1cmkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IG51bGw7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgdXJpID0gcGFyc2V1cmkodXJpKTtcbiAgICBvcHRzLmhvc3QgPSB1cmkuaG9zdDtcbiAgICBvcHRzLnNlY3VyZSA9IHVyaS5wcm90b2NvbCA9PSAnaHR0cHMnIHx8IHVyaS5wcm90b2NvbCA9PSAnd3NzJztcbiAgICBvcHRzLnBvcnQgPSB1cmkucG9ydDtcbiAgICBpZiAodXJpLnF1ZXJ5KSBvcHRzLnF1ZXJ5ID0gdXJpLnF1ZXJ5O1xuICB9XG5cbiAgdGhpcy5zZWN1cmUgPSBudWxsICE9IG9wdHMuc2VjdXJlID8gb3B0cy5zZWN1cmUgOlxuICAgIChnbG9iYWwubG9jYXRpb24gJiYgJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2wpO1xuXG4gIGlmIChvcHRzLmhvc3QpIHtcbiAgICB2YXIgcGllY2VzID0gb3B0cy5ob3N0LnNwbGl0KCc6Jyk7XG4gICAgb3B0cy5ob3N0bmFtZSA9IHBpZWNlcy5zaGlmdCgpO1xuICAgIGlmIChwaWVjZXMubGVuZ3RoKSB7XG4gICAgICBvcHRzLnBvcnQgPSBwaWVjZXMucG9wKCk7XG4gICAgfSBlbHNlIGlmICghb3B0cy5wb3J0KSB7XG4gICAgICAvLyBpZiBubyBwb3J0IGlzIHNwZWNpZmllZCBtYW51YWxseSwgdXNlIHRoZSBwcm90b2NvbCBkZWZhdWx0XG4gICAgICBvcHRzLnBvcnQgPSB0aGlzLnNlY3VyZSA/ICc0NDMnIDogJzgwJztcbiAgICB9XG4gIH1cblxuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWUgfHxcbiAgICAoZ2xvYmFsLmxvY2F0aW9uID8gbG9jYXRpb24uaG9zdG5hbWUgOiAnbG9jYWxob3N0Jyk7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydCB8fCAoZ2xvYmFsLmxvY2F0aW9uICYmIGxvY2F0aW9uLnBvcnQgP1xuICAgICAgIGxvY2F0aW9uLnBvcnQgOlxuICAgICAgICh0aGlzLnNlY3VyZSA/IDQ0MyA6IDgwKSk7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5IHx8IHt9O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHRoaXMucXVlcnkpIHRoaXMucXVlcnkgPSBwYXJzZXFzLmRlY29kZSh0aGlzLnF1ZXJ5KTtcbiAgdGhpcy51cGdyYWRlID0gZmFsc2UgIT09IG9wdHMudXBncmFkZTtcbiAgdGhpcy5wYXRoID0gKG9wdHMucGF0aCB8fCAnL2VuZ2luZS5pbycpLnJlcGxhY2UoL1xcLyQvLCAnJykgKyAnLyc7XG4gIHRoaXMuZm9yY2VKU09OUCA9ICEhb3B0cy5mb3JjZUpTT05QO1xuICB0aGlzLmpzb25wID0gZmFsc2UgIT09IG9wdHMuanNvbnA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMuZW5hYmxlc1hEUiA9ICEhb3B0cy5lbmFibGVzWERSO1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbSB8fCAndCc7XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnRyYW5zcG9ydHMgPSBvcHRzLnRyYW5zcG9ydHMgfHwgWydwb2xsaW5nJywgJ3dlYnNvY2tldCddO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICB0aGlzLmNhbGxiYWNrQnVmZmVyID0gW107XG4gIHRoaXMucG9saWN5UG9ydCA9IG9wdHMucG9saWN5UG9ydCB8fCA4NDM7XG4gIHRoaXMucmVtZW1iZXJVcGdyYWRlID0gb3B0cy5yZW1lbWJlclVwZ3JhZGUgfHwgZmFsc2U7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZnggfHwgbnVsbDtcbiAgdGhpcy5rZXkgPSBvcHRzLmtleSB8fCBudWxsO1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2UgfHwgbnVsbDtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0IHx8IG51bGw7XG4gIHRoaXMuY2EgPSBvcHRzLmNhIHx8IG51bGw7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycyB8fCBudWxsO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkIHx8IG51bGw7XG5cbiAgdGhpcy5vcGVuKCk7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogdGhpcy5wYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBmb3JjZUpTT05QOiB0aGlzLmZvcmNlSlNPTlAsXG4gICAganNvbnA6IHRoaXMuanNvbnAsXG4gICAgZm9yY2VCYXNlNjQ6IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgZW5hYmxlc1hEUjogdGhpcy5lbmFibGVzWERSLFxuICAgIHRpbWVzdGFtcFJlcXVlc3RzOiB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzLFxuICAgIHRpbWVzdGFtcFBhcmFtOiB0aGlzLnRpbWVzdGFtcFBhcmFtLFxuICAgIHBvbGljeVBvcnQ6IHRoaXMucG9saWN5UG9ydCxcbiAgICBzb2NrZXQ6IHRoaXMsXG4gICAgcGZ4OiB0aGlzLnBmeCxcbiAgICBrZXk6IHRoaXMua2V5LFxuICAgIHBhc3NwaHJhc2U6IHRoaXMucGFzc3BocmFzZSxcbiAgICBjZXJ0OiB0aGlzLmNlcnQsXG4gICAgY2E6IHRoaXMuY2EsXG4gICAgY2lwaGVyczogdGhpcy5jaXBoZXJzLFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogdGhpcy5yZWplY3RVbmF1dGhvcml6ZWRcbiAgfSk7XG5cbiAgcmV0dXJuIHRyYW5zcG9ydDtcbn07XG5cbmZ1bmN0aW9uIGNsb25lIChvYmopIHtcbiAgdmFyIG8gPSB7fTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBvW2ldID0gb2JqW2ldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbztcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0cmFuc3BvcnQgdG8gdXNlIGFuZCBzdGFydHMgcHJvYmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblNvY2tldC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRyYW5zcG9ydDtcbiAgaWYgKHRoaXMucmVtZW1iZXJVcGdyYWRlICYmIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgJiYgdGhpcy50cmFuc3BvcnRzLmluZGV4T2YoJ3dlYnNvY2tldCcpICE9IC0xKSB7XG4gICAgdHJhbnNwb3J0ID0gJ3dlYnNvY2tldCc7XG4gIH0gZWxzZSBpZiAoMCA9PSB0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgLy8gRW1pdCBlcnJvciBvbiBuZXh0IHRpY2sgc28gaXQgY2FuIGJlIGxpc3RlbmVkIHRvXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgJ05vIHRyYW5zcG9ydHMgYXZhaWxhYmxlJyk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gUmV0cnkgd2l0aCB0aGUgbmV4dCB0cmFuc3BvcnQgaWYgdGhlIHRyYW5zcG9ydCBpcyBkaXNhYmxlZCAoanNvbnA6IGZhbHNlKVxuICB2YXIgdHJhbnNwb3J0O1xuICB0cnkge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aGlzLnRyYW5zcG9ydHMuc2hpZnQoKTtcbiAgICB0aGlzLm9wZW4oKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCl7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uKHBhY2tldCl7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSlcbiAgICAsIGZhaWxlZCA9IGZhbHNlXG4gICAgLCBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuKCl7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09IG1zZy50eXBlICYmICdwcm9iZScgPT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybjtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlKCl7XG4gICAgb25lcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG4gIH1cblxuICAvL1doZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlKCl7XG4gICAgb25lcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gIH1cblxuICAvL1doZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSh0byl7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy9SZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAoKXtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcblxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHVibGljXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJldkJ1ZmZlckxlbjsgaSsrKSB7XG4gICAgaWYgKHRoaXMuY2FsbGJhY2tCdWZmZXJbaV0pIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tCdWZmZXJbaV0oKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuICB0aGlzLmNhbGxiYWNrQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoID09IDApIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgZm4pIHtcbiAgaWYgKCdjbG9zaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICB0aGlzLmNhbGxiYWNrQnVmZmVyLnB1c2goZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NpbmcnO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBzZWxmLm9uQ2xvc2UoJ2ZvcmNlZCBjbG9zZScpO1xuICAgICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICAgIHNlbGYudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cEFuZENsb3NlKCkge1xuICAgICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkZScsIGNsZWFudXBBbmRDbG9zZSk7XG4gICAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgY2xvc2UoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3YWl0Rm9yVXBncmFkZSgpIHtcbiAgICAgIC8vIHdhaXQgZm9yIHVwZ3JhZGUgdG8gZmluaXNoIHNpbmNlIHdlIGNhbid0IHNlbmQgcGFja2V0cyB3aGlsZSBwYXVzaW5nIGEgdHJhbnNwb3J0XG4gICAgICBzZWxmLm9uY2UoJ3VwZ3JhZGUnLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgICAgc2VsZi5vbmNlKCd1cGdyYWRlRXJyb3InLCBjbGVhbnVwQW5kQ2xvc2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgdGhpcy5vbmNlKCdkcmFpbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgICAgICB3YWl0Rm9yVXBncmFkZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy51cGdyYWRpbmcpIHtcbiAgICAgIHdhaXRGb3JVcGdyYWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnY2xvc2luZycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGluIG5leHQgdGljaywgc28gZGV2ZWxvcGVycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgc2VsZi5jYWxsYmFja0J1ZmZlciA9IFtdO1xuICAgICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgICB9LCAwKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnQ7XG5cbi8qKlxuICogVHJhbnNwb3J0IGFic3RyYWN0IGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gVHJhbnNwb3J0IChvcHRzKSB7XG4gIHRoaXMucGF0aCA9IG9wdHMucGF0aDtcbiAgdGhpcy5ob3N0bmFtZSA9IG9wdHMuaG9zdG5hbWU7XG4gIHRoaXMucG9ydCA9IG9wdHMucG9ydDtcbiAgdGhpcy5zZWN1cmUgPSBvcHRzLnNlY3VyZTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnk7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLnNvY2tldCA9IG9wdHMuc29ja2V0O1xuICB0aGlzLmVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gU1NMIG9wdGlvbnMgZm9yIE5vZGUuanMgY2xpZW50XG4gIHRoaXMucGZ4ID0gb3B0cy5wZng7XG4gIHRoaXMua2V5ID0gb3B0cy5rZXk7XG4gIHRoaXMucGFzc3BocmFzZSA9IG9wdHMucGFzc3BocmFzZTtcbiAgdGhpcy5jZXJ0ID0gb3B0cy5jZXJ0O1xuICB0aGlzLmNhID0gb3B0cy5jYTtcbiAgdGhpcy5jaXBoZXJzID0gb3B0cy5jaXBoZXJzO1xuICB0aGlzLnJlamVjdFVuYXV0aG9yaXplZCA9IG9wdHMucmVqZWN0VW5hdXRob3JpemVkO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihUcmFuc3BvcnQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBBIGNvdW50ZXIgdXNlZCB0byBwcmV2ZW50IGNvbGxpc2lvbnMgaW4gdGhlIHRpbWVzdGFtcHMgdXNlZFxuICogZm9yIGNhY2hlIGJ1c3RpbmcuXG4gKi9cblxuVHJhbnNwb3J0LnRpbWVzdGFtcHMgPSAwO1xuXG4vKipcbiAqIEVtaXRzIGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1RyYW5zcG9ydH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChtc2csIGRlc2MpIHtcbiAgdmFyIGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICBlcnIudHlwZSA9ICdUcmFuc3BvcnRFcnJvcic7XG4gIGVyci5kZXNjcmlwdGlvbiA9IGRlc2M7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3BlbnMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gICAgdGhpcy5kb09wZW4oKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5kb0Nsb3NlKCk7XG4gICAgdGhpcy5vbkNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgbXVsdGlwbGUgcGFja2V0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLndyaXRlKHBhY2tldHMpO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IG5vdCBvcGVuJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gb3BlblxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gIHRoaXMub25QYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpO1xudmFyIFhIUiA9IHJlcXVpcmUoJy4vcG9sbGluZy14aHInKTtcbnZhciBKU09OUCA9IHJlcXVpcmUoJy4vcG9sbGluZy1qc29ucCcpO1xudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0IHRyYW5zcG9ydHMuXG4gKi9cblxuZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcbmV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyhvcHRzKXtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG4gIHZhciB4cyA9IGZhbHNlO1xuICB2YXIganNvbnAgPSBmYWxzZSAhPT0gb3B0cy5qc29ucDtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgeGQgPSBvcHRzLmhvc3RuYW1lICE9IGxvY2F0aW9uLmhvc3RuYW1lIHx8IHBvcnQgIT0gb3B0cy5wb3J0O1xuICAgIHhzID0gb3B0cy5zZWN1cmUgIT0gaXNTU0w7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgb3B0cy54c2NoZW1lID0geHM7XG4gIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdChvcHRzKTtcblxuICBpZiAoJ29wZW4nIGluIHhociAmJiAhb3B0cy5mb3JjZUpTT05QKSB7XG4gICAgcmV0dXJuIG5ldyBYSFIob3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFqc29ucCkgdGhyb3cgbmV3IEVycm9yKCdKU09OUCBkaXNhYmxlZCcpO1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBKU09OUFBvbGxpbmc7XG5cbi8qKlxuICogQ2FjaGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gKi9cblxudmFyIHJOZXdsaW5lID0gL1xcbi9nO1xudmFyIHJFc2NhcGVkTmV3bGluZSA9IC9cXFxcbi9nO1xuXG4vKipcbiAqIEdsb2JhbCBKU09OUCBjYWxsYmFja3MuXG4gKi9cblxudmFyIGNhbGxiYWNrcztcblxuLyoqXG4gKiBDYWxsYmFja3MgY291bnQuXG4gKi9cblxudmFyIGluZGV4ID0gMDtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5ICgpIHsgfVxuXG4vKipcbiAqIEpTT05QIFBvbGxpbmcgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEpTT05QUG9sbGluZyAob3B0cykge1xuICBQb2xsaW5nLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgdGhpcy5xdWVyeSA9IHRoaXMucXVlcnkgfHwge307XG5cbiAgLy8gZGVmaW5lIGdsb2JhbCBjYWxsYmFja3MgYXJyYXkgaWYgbm90IHByZXNlbnRcbiAgLy8gd2UgZG8gdGhpcyBoZXJlIChsYXppbHkpIHRvIGF2b2lkIHVubmVlZGVkIGdsb2JhbCBwb2xsdXRpb25cbiAgaWYgKCFjYWxsYmFja3MpIHtcbiAgICAvLyB3ZSBuZWVkIHRvIGNvbnNpZGVyIG11bHRpcGxlIGVuZ2luZXMgaW4gdGhlIHNhbWUgcGFnZVxuICAgIGlmICghZ2xvYmFsLl9fX2VpbykgZ2xvYmFsLl9fX2VpbyA9IFtdO1xuICAgIGNhbGxiYWNrcyA9IGdsb2JhbC5fX19laW87XG4gIH1cblxuICAvLyBjYWxsYmFjayBpZGVudGlmaWVyXG4gIHRoaXMuaW5kZXggPSBjYWxsYmFja3MubGVuZ3RoO1xuXG4gIC8vIGFkZCBjYWxsYmFjayB0byBqc29ucCBnbG9iYWxcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjYWxsYmFja3MucHVzaChmdW5jdGlvbiAobXNnKSB7XG4gICAgc2VsZi5vbkRhdGEobXNnKTtcbiAgfSk7XG5cbiAgLy8gYXBwZW5kIHRvIHF1ZXJ5IHN0cmluZ1xuICB0aGlzLnF1ZXJ5LmogPSB0aGlzLmluZGV4O1xuXG4gIC8vIHByZXZlbnQgc3B1cmlvdXMgZXJyb3JzIGZyb20gYmVpbmcgZW1pdHRlZCB3aGVuIHRoZSB3aW5kb3cgaXMgdW5sb2FkZWRcbiAgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5zY3JpcHQpIHNlbGYuc2NyaXB0Lm9uZXJyb3IgPSBlbXB0eTtcbiAgICB9LCBmYWxzZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gICAgdGhpcy5pZnJhbWUgPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIFxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrIHNlbGYuaWZyYW1lSWQgKydcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2goZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG4iLCIvKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5KCl7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUihvcHRzKXtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPSBnbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHxcbiAgICAgIHBvcnQgIT0gb3B0cy5wb3J0O1xuICAgIHRoaXMueHMgPSBvcHRzLnNlY3VyZSAhPSBpc1NTTDtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG9wdHMpe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy54cyA9IHRoaXMueHM7XG4gIG9wdHMuYWdlbnQgPSB0aGlzLmFnZW50IHx8IGZhbHNlO1xuICBvcHRzLnN1cHBvcnRzQmluYXJ5ID0gdGhpcy5zdXBwb3J0c0JpbmFyeTtcbiAgb3B0cy5lbmFibGVzWERSID0gdGhpcy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICBvcHRzLnBmeCA9IHRoaXMucGZ4O1xuICBvcHRzLmtleSA9IHRoaXMua2V5O1xuICBvcHRzLnBhc3NwaHJhc2UgPSB0aGlzLnBhc3NwaHJhc2U7XG4gIG9wdHMuY2VydCA9IHRoaXMuY2VydDtcbiAgb3B0cy5jYSA9IHRoaXMuY2E7XG4gIG9wdHMuY2lwaGVycyA9IHRoaXMuY2lwaGVycztcbiAgb3B0cy5yZWplY3RVbmF1dGhvcml6ZWQgPSB0aGlzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy54cyA9ICEhb3B0cy54cztcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuaXNCaW5hcnkgPSBvcHRzLmlzQmluYXJ5O1xuICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gb3B0cy5zdXBwb3J0c0JpbmFyeTtcbiAgdGhpcy5lbmFibGVzWERSID0gb3B0cy5lbmFibGVzWERSO1xuXG4gIC8vIFNTTCBvcHRpb25zIGZvciBOb2RlLmpzIGNsaWVudFxuICB0aGlzLnBmeCA9IG9wdHMucGZ4O1xuICB0aGlzLmtleSA9IG9wdHMua2V5O1xuICB0aGlzLnBhc3NwaHJhc2UgPSBvcHRzLnBhc3NwaHJhc2U7XG4gIHRoaXMuY2VydCA9IG9wdHMuY2VydDtcbiAgdGhpcy5jYSA9IG9wdHMuY2E7XG4gIHRoaXMuY2lwaGVycyA9IG9wdHMuY2lwaGVycztcbiAgdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQgPSBvcHRzLnJlamVjdFVuYXV0aG9yaXplZDtcblxuICB0aGlzLmNyZWF0ZSgpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oKXtcbiAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50LCB4ZG9tYWluOiB0aGlzLnhkLCB4c2NoZW1lOiB0aGlzLnhzLCBlbmFibGVzWERSOiB0aGlzLmVuYWJsZXNYRFIgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICBkZWJ1ZygneGhyIG9wZW4gJXM6ICVzJywgdGhpcy5tZXRob2QsIHRoaXMudXJpKTtcbiAgICB4aHIub3Blbih0aGlzLm1ldGhvZCwgdGhpcy51cmksIHRoaXMuYXN5bmMpO1xuICAgIGlmICh0aGlzLnN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5pc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICB9O1xuICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHNlbGYub25Mb2FkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBgZXJyb3JgIGV2ZW50IGhhbmRsZXIgdGhhdCdzIHVzZXItc2V0XG4gICAgICAgICAgLy8gZG9lcyBub3QgdGhyb3cgaW4gdGhlIHNhbWUgdGljayBhbmQgZ2V0cyBjYXVnaHQgaGVyZVxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHNlbGYub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAodHJ1ZSk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oZnJvbUVycm9yKXtcbiAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICBpZiAodGhpcy5oYXNYRFIoKSkge1xuICAgIHRoaXMueGhyLm9ubG9hZCA9IHRoaXMueGhyLm9uZXJyb3IgPSBlbXB0eTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcbiAgfVxuXG4gIGlmIChmcm9tRXJyb3IpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoKGUpIHt9XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGxvYWQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25Mb2FkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGRhdGE7XG4gIHRyeSB7XG4gICAgdmFyIGNvbnRlbnRUeXBlO1xuICAgIHRyeSB7XG4gICAgICBjb250ZW50VHlwZSA9IHRoaXMueGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKS5zcGxpdCgnOycpWzBdO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgZGF0YSA9IHRoaXMueGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSAnb2snO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIHRoaXMub25FcnJvcihlKTtcbiAgfVxuICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgdGhpcy5vbkRhdGEoZGF0YSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgaXQgaGFzIFhEb21haW5SZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmhhc1hEUiA9IGZ1bmN0aW9uKCl7XG4gIHJldHVybiAndW5kZWZpbmVkJyAhPT0gdHlwZW9mIGdsb2JhbC5YRG9tYWluUmVxdWVzdCAmJiAhdGhpcy54cyAmJiB0aGlzLmVuYWJsZXNYRFI7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuICBSZXF1ZXN0LnJlcXVlc3RzID0ge307XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlciwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVubG9hZEhhbmRsZXIoKSB7XG4gIGZvciAodmFyIGkgaW4gUmVxdWVzdC5yZXF1ZXN0cykge1xuICAgIGlmIChSZXF1ZXN0LnJlcXVlc3RzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBSZXF1ZXN0LnJlcXVlc3RzW2ldLmFib3J0KCk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG4gIHZhciBwZW5kaW5nID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSgpe1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpe1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0gK25ldyBEYXRlICsgJy0nICsgVHJhbnNwb3J0LnRpbWVzdGFtcHMrKztcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyB0aGlzLmhvc3RuYW1lICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXG4vKipcbiAqIGB3c2AgZXhwb3NlcyBhIFdlYlNvY2tldC1jb21wYXRpYmxlIGludGVyZmFjZSBpblxuICogTm9kZSwgb3IgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyLlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQgfTtcblxuICAvLyBTU0wgb3B0aW9ucyBmb3IgTm9kZS5qcyBjbGllbnRcbiAgb3B0cy5wZnggPSB0aGlzLnBmeDtcbiAgb3B0cy5rZXkgPSB0aGlzLmtleTtcbiAgb3B0cy5wYXNzcGhyYXNlID0gdGhpcy5wYXNzcGhyYXNlO1xuICBvcHRzLmNlcnQgPSB0aGlzLmNlcnQ7XG4gIG9wdHMuY2EgPSB0aGlzLmNhO1xuICBvcHRzLmNpcGhlcnMgPSB0aGlzLmNpcGhlcnM7XG4gIG9wdHMucmVqZWN0VW5hdXRob3JpemVkID0gdGhpcy5yZWplY3RVbmF1dGhvcml6ZWQ7XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldil7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cbiAqIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWxvdWdocmFuLzIwNTIwMDZcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5pZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuICAmJiAvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9O1xufVxuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFja2V0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldHNbaV0sIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIC8vU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgLy9oYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgIC8vdGhyb3cgYW4gZXJyb3JcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH1cbiAgLy8gZmFrZSBkcmFpblxuICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gIHNldFRpbWVvdXQob25kcmFpbiwgMCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MylcbiAgICB8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9ICtuZXcgRGF0ZTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgdGhpcy5ob3N0bmFtZSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBzY2hlbWUgbXVzdCBiZSBzYW1lIHdoZW4gdXNpZ24gWERvbWFpblJlcXVlc3RcbiAgLy8gaHR0cDovL2Jsb2dzLm1zZG4uY29tL2IvaWVpbnRlcm5hbHMvYXJjaGl2ZS8yMDEwLzA1LzEzL3hkb21haW5yZXF1ZXN0LXJlc3RyaWN0aW9ucy1saW1pdGF0aW9ucy1hbmQtd29ya2Fyb3VuZHMuYXNweFxuICB2YXIgeHNjaGVtZSA9IG9wdHMueHNjaGVtZTtcblxuICAvLyBYRG9tYWluUmVxdWVzdCBoYXMgYSBmbG93IG9mIG5vdCBzZW5kaW5nIGNvb2tpZSwgdGhlcmVmb3JlIGl0IHNob3VsZCBiZSBkaXNhYmxlZCBhcyBhIGRlZmF1bHQuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdXRvbWF0dGljL2VuZ2luZS5pby1jbGllbnQvcHVsbC8yMTdcbiAgdmFyIGVuYWJsZXNYRFIgPSBvcHRzLmVuYWJsZXNYRFI7XG5cbiAgLy8gWE1MSHR0cFJlcXVlc3QgY2FuIGJlIGRpc2FibGVkIG9uIElFXG4gIHRyeSB7XG4gICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAmJiAoIXhkb21haW4gfHwgaGFzQ09SUykpIHtcbiAgICAgIHJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIC8vIFVzZSBYRG9tYWluUmVxdWVzdCBmb3IgSUU4IGlmIGVuYWJsZXNYRFIgaXMgdHJ1ZVxuICAvLyBiZWNhdXNlIGxvYWRpbmcgYmFyIGtlZXBzIGZsYXNoaW5nIHdoZW4gdXNpbmcganNvbnAtcG9sbGluZ1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20veXVqaW9zYWthL3NvY2tlLmlvLWllOC1sb2FkaW5nLWV4YW1wbGVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhEb21haW5SZXF1ZXN0ICYmICF4c2NoZW1lICYmIGVuYWJsZXNYRFIpIHtcbiAgICAgIHJldHVybiBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHsgfVxuXG4gIGlmICgheGRvbWFpbikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaChlKSB7IH1cbiAgfVxufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGEsIGIpe1xuICB2YXIgZm4gPSBmdW5jdGlvbigpe307XG4gIGZuLnByb3RvdHlwZSA9IGIucHJvdG90eXBlO1xuICBhLnByb3RvdHlwZSA9IG5ldyBmbjtcbiAgYS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBhO1xufTsiLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOCxcbiAgLy8gd2hlcmUgdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGxvY2FsU3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcbmV4cG9ydHMuZGlzYWJsZSA9IGRpc2FibGU7XG5leHBvcnRzLmVuYWJsZSA9IGVuYWJsZTtcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XG5leHBvcnRzLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAqL1xuXG5leHBvcnRzLm5hbWVzID0gW107XG5leHBvcnRzLnNraXBzID0gW107XG5cbi8qKlxuICogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuICpcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyY2FzZWQgbGV0dGVyLCBpLmUuIFwiblwiLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xuXG4vKipcbiAqIFByZXZpb3VzbHkgYXNzaWduZWQgY29sb3IuXG4gKi9cblxudmFyIHByZXZDb2xvciA9IDA7XG5cbi8qKlxuICogUHJldmlvdXMgbG9nIHRpbWVzdGFtcC5cbiAqL1xuXG52YXIgcHJldlRpbWU7XG5cbi8qKlxuICogU2VsZWN0IGEgY29sb3IuXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2VsZWN0Q29sb3IoKSB7XG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1twcmV2Q29sb3IrKyAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlYnVnKG5hbWVzcGFjZSkge1xuXG4gIC8vIGRlZmluZSB0aGUgYGRpc2FibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGRpc2FibGVkKCkge1xuICB9XG4gIGRpc2FibGVkLmVuYWJsZWQgPSBmYWxzZTtcblxuICAvLyBkZWZpbmUgdGhlIGBlbmFibGVkYCB2ZXJzaW9uXG4gIGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG5cbiAgICB2YXIgc2VsZiA9IGVuYWJsZWQ7XG5cbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxuICAgIHZhciBjdXJyID0gK25ldyBEYXRlKCk7XG4gICAgdmFyIG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcbiAgICBzZWxmLmRpZmYgPSBtcztcbiAgICBzZWxmLnByZXYgPSBwcmV2VGltZTtcbiAgICBzZWxmLmN1cnIgPSBjdXJyO1xuICAgIHByZXZUaW1lID0gY3VycjtcblxuICAgIC8vIGFkZCB0aGUgYGNvbG9yYCBpZiBub3Qgc2V0XG4gICAgaWYgKG51bGwgPT0gc2VsZi51c2VDb2xvcnMpIHNlbGYudXNlQ29sb3JzID0gZXhwb3J0cy51c2VDb2xvcnMoKTtcbiAgICBpZiAobnVsbCA9PSBzZWxmLmNvbG9yICYmIHNlbGYudXNlQ29sb3JzKSBzZWxmLmNvbG9yID0gc2VsZWN0Q29sb3IoKTtcblxuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIGFyZ3NbMF0gPSBleHBvcnRzLmNvZXJjZShhcmdzWzBdKTtcblxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcbiAgICAgIC8vIGFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVvXG4gICAgICBhcmdzID0gWyclbyddLmNvbmNhdChhcmdzKTtcbiAgICB9XG5cbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgYXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16JV0pL2csIGZ1bmN0aW9uKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcbiAgICAgIGlmIChtYXRjaCA9PT0gJyUlJykgcmV0dXJuIG1hdGNoO1xuICAgICAgaW5kZXgrKztcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcbiAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZm9ybWF0dGVyKSB7XG4gICAgICAgIHZhciB2YWwgPSBhcmdzW2luZGV4XTtcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG4gICAgICAgIC8vIG5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBpbmRleC0tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuXG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBleHBvcnRzLmZvcm1hdEFyZ3MpIHtcbiAgICAgIGFyZ3MgPSBleHBvcnRzLmZvcm1hdEFyZ3MuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuICAgIHZhciBsb2dGbiA9IGVuYWJsZWQubG9nIHx8IGV4cG9ydHMubG9nIHx8IGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7XG4gICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH1cbiAgZW5hYmxlZC5lbmFibGVkID0gdHJ1ZTtcblxuICB2YXIgZm4gPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKSA/IGVuYWJsZWQgOiBkaXNhYmxlZDtcblxuICBmbi5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cbiAgcmV0dXJuIGZuO1xufVxuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcbiAgZXhwb3J0cy5zYXZlKG5hbWVzcGFjZXMpO1xuXG4gIHZhciBzcGxpdCA9IChuYW1lc3BhY2VzIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoIXNwbGl0W2ldKSBjb250aW51ZTsgLy8gaWdub3JlIGVtcHR5IHN0cmluZ3NcbiAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcbiAgICBpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xuICBleHBvcnRzLmVuYWJsZSgnJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcbiAgdmFyIGksIGxlbjtcbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yIChpID0gMCwgbGVuID0gZXhwb3J0cy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChleHBvcnRzLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICpcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobXN8c2Vjb25kcz98c3xtaW51dGVzP3xtfGhvdXJzP3xofGRheXM/fGR8eWVhcnM/fHkpPyQvaS5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybjtcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGhhc0JpbmFyeSA9IHJlcXVpcmUoJ2hhcy1iaW5hcnknKTtcbnZhciBzbGljZUJ1ZmZlciA9IHJlcXVpcmUoJ2FycmF5YnVmZmVyLnNsaWNlJyk7XG52YXIgYmFzZTY0ZW5jb2RlciA9IHJlcXVpcmUoJ2Jhc2U2NC1hcnJheWJ1ZmZlcicpO1xudmFyIGFmdGVyID0gcmVxdWlyZSgnYWZ0ZXInKTtcbnZhciB1dGY4ID0gcmVxdWlyZSgndXRmOCcpO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlIGFyZSBydW5uaW5nIGFuIGFuZHJvaWQgYnJvd3Nlci4gVGhhdCByZXF1aXJlcyB1cyB0byB1c2VcbiAqIEFycmF5QnVmZmVyIHdpdGggcG9sbGluZyB0cmFuc3BvcnRzLi4uXG4gKlxuICogaHR0cDovL2doaW5kYS5uZXQvanBlZy1ibG9iLWFqYXgtYW5kcm9pZC9cbiAqL1xuXG52YXIgaXNBbmRyb2lkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQW5kcm9pZC9pKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBpbiBQaGFudG9tSlMuXG4gKiBVcGxvYWRpbmcgYSBCbG9iIHdpdGggUGhhbnRvbUpTIGRvZXMgbm90IHdvcmsgY29ycmVjdGx5LCBhcyByZXBvcnRlZCBoZXJlOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTEzOTVcbiAqIEB0eXBlIGJvb2xlYW5cbiAqL1xudmFyIGlzUGhhbnRvbUpTID0gL1BoYW50b21KUy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogV2hlbiB0cnVlLCBhdm9pZHMgdXNpbmcgQmxvYnMgdG8gZW5jb2RlIHBheWxvYWRzLlxuICogQHR5cGUgYm9vbGVhblxuICovXG52YXIgZG9udFNlbmRCbG9icyA9IGlzQW5kcm9pZCB8fCBpc1BoYW50b21KUztcblxuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5cbnZhciBwYWNrZXRzID0gZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46ICAgICAwICAgIC8vIG5vbi13c1xuICAsIGNsb3NlOiAgICAxICAgIC8vIG5vbi13c1xuICAsIHBpbmc6ICAgICAyXG4gICwgcG9uZzogICAgIDNcbiAgLCBtZXNzYWdlOiAgNFxuICAsIHVwZ3JhZGU6ICA1XG4gICwgbm9vcDogICAgIDZcbn07XG5cbnZhciBwYWNrZXRzbGlzdCA9IGtleXMocGFja2V0cyk7XG5cbi8qKlxuICogUHJlbWFkZSBlcnJvciBwYWNrZXQuXG4gKi9cblxudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcblxuLyoqXG4gKiBDcmVhdGUgYSBibG9iIGFwaSBldmVuIGZvciBibG9iIGJ1aWxkZXIgd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYiA9IHJlcXVpcmUoJ2Jsb2InKTtcblxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCB1dGY4ZW5jb2RlLCBjYWxsYmFjaykge1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2Ygc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cblxuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXRmOGVuY29kZSkge1xuICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICB1dGY4ZW5jb2RlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBtaWdodCBiZSBhbiBvYmplY3Qgd2l0aCB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogZGF0YUFzQmFzZTY0U3RyaW5nIH1cbiAgaWYgKGRhdGEgJiYgZGF0YS5iYXNlNjQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmFzZTY0T2JqZWN0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gIHZhciBlbmNvZGVkID0gcGFja2V0c1twYWNrZXQudHlwZV07XG5cbiAgLy8gZGF0YSBmcmFnbWVudCBpcyBvcHRpb25hbFxuICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgIGVuY29kZWQgKz0gdXRmOGVuY29kZSA/IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG5mdW5jdGlvbiBlbmNvZGVCYXNlNjRPYmplY3QocGFja2V0LCBjYWxsYmFjaykge1xuICAvLyBwYWNrZXQgZGF0YSBpcyBhbiBvYmplY3QgeyBiYXNlNjQ6IHRydWUsIGRhdGE6IGRhdGFBc0Jhc2U2NFN0cmluZyB9XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXSArIHBhY2tldC5kYXRhLmRhdGE7XG4gIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGhlbHBlcnMgZm9yIGJpbmFyeSB0eXBlc1xuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICB2YXIgY29udGVudEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciByZXN1bHRCdWZmZXIgPSBuZXcgVWludDhBcnJheSgxICsgZGF0YS5ieXRlTGVuZ3RoKTtcblxuICByZXN1bHRCdWZmZXJbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICByZXN1bHRCdWZmZXJbaSsxXSA9IGNvbnRlbnRBcnJheVtpXTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjayhyZXN1bHRCdWZmZXIuYnVmZmVyKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gIGZyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgIHBhY2tldC5kYXRhID0gZnIucmVzdWx0O1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHRydWUsIGNhbGxiYWNrKTtcbiAgfTtcbiAgcmV0dXJuIGZyLnJlYWRBc0FycmF5QnVmZmVyKHBhY2tldC5kYXRhKTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKGRvbnRTZW5kQmxvYnMpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBpZiAodXRmOGRlY29kZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHlwZSA9IGRhdGEuY2hhckF0KDApO1xuXG4gICAgaWYgKE51bWJlcih0eXBlKSAhPSB0eXBlIHx8ICFwYWNrZXRzbGlzdFt0eXBlXSkge1xuICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zdWJzdHJpbmcoMSkgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICB9XG4gIH1cblxuICB2YXIgYXNBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgdHlwZSA9IGFzQXJyYXlbMF07XG4gIHZhciByZXN0ID0gc2xpY2VCdWZmZXIoZGF0YSwgMSk7XG4gIGlmIChCbG9iICYmIGJpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgIHJlc3QgPSBuZXcgQmxvYihbcmVzdF0pO1xuICB9XG4gIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiByZXN0IH07XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihtc2csIGJpbmFyeVR5cGUpIHtcbiAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgaWYgKCFnbG9iYWwuQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiB7IGJhc2U2NDogdHJ1ZSwgZGF0YTogbXNnLnN1YnN0cigxKSB9IH07XG4gIH1cblxuICB2YXIgZGF0YSA9IGJhc2U2NGVuY29kZXIuZGVjb2RlKG1zZy5zdWJzdHIoMSkpO1xuXG4gIGlmIChiaW5hcnlUeXBlID09PSAnYmxvYicgJiYgQmxvYikge1xuICAgIGRhdGEgPSBuZXcgQmxvYihbZGF0YV0pO1xuICB9XG5cbiAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKS5cbiAqXG4gKiAgICAgPGxlbmd0aD46ZGF0YVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDExOmhlbGxvIHdvcmxkMjpoaVxuICpcbiAqIElmIGFueSBjb250ZW50cyBhcmUgYmluYXJ5LCB0aGV5IHdpbGwgYmUgZW5jb2RlZCBhcyBiYXNlNjQgc3RyaW5ncy4gQmFzZTY0XG4gKiBlbmNvZGVkIHN0cmluZ3MgYXJlIG1hcmtlZCB3aXRoIGEgYiBiZWZvcmUgdGhlIGxlbmd0aCBzcGVjaWZpZXJcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBmdW5jdGlvbiAocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICB9XG5cbiAgdmFyIGlzQmluYXJ5ID0gaGFzQmluYXJ5KHBhY2tldHMpO1xuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBpc0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFkb250U2VuZEJsb2JzKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCAhaXNCaW5hcnkgPyBmYWxzZSA6IHN1cHBvcnRzQmluYXJ5LCB0cnVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJydcbiAgICAsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKCc6JyAhPSBjaHIpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlLCB0cnVlKTtcblxuICAgICAgICBpZiAoZXJyLnR5cGUgPT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgICBpICs9IG47XG4gICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gIH1cblxuICBpZiAobGVuZ3RoICE9ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgdmFyIG51bWJlclRvb0xvbmcgPSBmYWxzZTtcbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAxOyA7IGkrKykge1xuICAgICAgaWYgKHRhaWxBcnJheVtpXSA9PSAyNTUpIGJyZWFrO1xuXG4gICAgICBpZiAobXNnTGVuZ3RoLmxlbmd0aCA+IDMxMCkge1xuICAgICAgICBudW1iZXJUb29Mb25nID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuXG4gICAgaWYobnVtYmVyVG9vTG9uZykgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG5cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUsIHRydWUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcbiIsIlxuLyoqXG4gKiBHZXRzIHRoZSBrZXlzIGZvciBhbiBvYmplY3QuXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGtleXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKXtcbiAgdmFyIGFyciA9IFtdO1xuICB2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGkpKSB7XG4gICAgICBhcnIucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFmdGVyXG5cbmZ1bmN0aW9uIGFmdGVyKGNvdW50LCBjYWxsYmFjaywgZXJyX2NiKSB7XG4gICAgdmFyIGJhaWwgPSBmYWxzZVxuICAgIGVycl9jYiA9IGVycl9jYiB8fCBub29wXG4gICAgcHJveHkuY291bnQgPSBjb3VudFxuXG4gICAgcmV0dXJuIChjb3VudCA9PT0gMCkgPyBjYWxsYmFjaygpIDogcHJveHlcblxuICAgIGZ1bmN0aW9uIHByb3h5KGVyciwgcmVzdWx0KSB7XG4gICAgICAgIGlmIChwcm94eS5jb3VudCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FmdGVyIGNhbGxlZCB0b28gbWFueSB0aW1lcycpXG4gICAgICAgIH1cbiAgICAgICAgLS1wcm94eS5jb3VudFxuXG4gICAgICAgIC8vIGFmdGVyIGZpcnN0IGVycm9yLCByZXN0IGFyZSBwYXNzZWQgdG8gZXJyX2NiXG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJhaWwgPSB0cnVlXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAvLyBmdXR1cmUgZXJyb3IgY2FsbGJhY2tzIHdpbGwgZ28gdG8gZXJyb3IgaGFuZGxlclxuICAgICAgICAgICAgY2FsbGJhY2sgPSBlcnJfY2JcbiAgICAgICAgfSBlbHNlIGlmIChwcm94eS5jb3VudCA9PT0gMCAmJiAhYmFpbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIi8qKlxuICogQW4gYWJzdHJhY3Rpb24gZm9yIHNsaWNpbmcgYW4gYXJyYXlidWZmZXIgZXZlbiB3aGVuXG4gKiBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgaXMgbm90IHN1cHBvcnRlZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnJheWJ1ZmZlciwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBhcnJheWJ1ZmZlci5ieXRlTGVuZ3RoO1xuICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gIGVuZCA9IGVuZCB8fCBieXRlcztcblxuICBpZiAoYXJyYXlidWZmZXIuc2xpY2UpIHsgcmV0dXJuIGFycmF5YnVmZmVyLnNsaWNlKHN0YXJ0LCBlbmQpOyB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkgeyBzdGFydCArPSBieXRlczsgfVxuICBpZiAoZW5kIDwgMCkgeyBlbmQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA+IGJ5dGVzKSB7IGVuZCA9IGJ5dGVzOyB9XG5cbiAgaWYgKHN0YXJ0ID49IGJ5dGVzIHx8IHN0YXJ0ID49IGVuZCB8fCBieXRlcyA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgQXJyYXlCdWZmZXIoMCk7XG4gIH1cblxuICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuICB2YXIgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoZW5kIC0gc3RhcnQpO1xuICBmb3IgKHZhciBpID0gc3RhcnQsIGlpID0gMDsgaSA8IGVuZDsgaSsrLCBpaSsrKSB7XG4gICAgcmVzdWx0W2lpXSA9IGFidltpXTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LmJ1ZmZlcjtcbn07XG4iLCIvKlxuICogYmFzZTY0LWFycmF5YnVmZmVyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbmlrbGFzdmgvYmFzZTY0LWFycmF5YnVmZmVyXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEyIE5pa2xhcyB2b24gSGVydHplblxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG4oZnVuY3Rpb24oY2hhcnMpe1xuICBcInVzZSBzdHJpY3RcIjtcblxuICBleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpLFxuICAgIGksIGxlbiA9IGJ5dGVzLmxlbmd0aCwgYmFzZTY0ID0gXCJcIjtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTMpIHtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpXSA+PiAyXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2ldICYgMykgPDwgNCkgfCAoYnl0ZXNbaSArIDFdID4+IDQpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1soKGJ5dGVzW2kgKyAxXSAmIDE1KSA8PCAyKSB8IChieXRlc1tpICsgMl0gPj4gNildO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2kgKyAyXSAmIDYzXTtcbiAgICB9XG5cbiAgICBpZiAoKGxlbiAlIDMpID09PSAyKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAxKSArIFwiPVwiO1xuICAgIH0gZWxzZSBpZiAobGVuICUgMyA9PT0gMSkge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMikgKyBcIj09XCI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2U2NDtcbiAgfTtcblxuICBleHBvcnRzLmRlY29kZSA9ICBmdW5jdGlvbihiYXNlNjQpIHtcbiAgICB2YXIgYnVmZmVyTGVuZ3RoID0gYmFzZTY0Lmxlbmd0aCAqIDAuNzUsXG4gICAgbGVuID0gYmFzZTY0Lmxlbmd0aCwgaSwgcCA9IDAsXG4gICAgZW5jb2RlZDEsIGVuY29kZWQyLCBlbmNvZGVkMywgZW5jb2RlZDQ7XG5cbiAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAxXSA9PT0gXCI9XCIpIHtcbiAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMl0gPT09IFwiPVwiKSB7XG4gICAgICAgIGJ1ZmZlckxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhcnJheWJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWZmZXJMZW5ndGgpLFxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlidWZmZXIpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9NCkge1xuICAgICAgZW5jb2RlZDEgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpXSk7XG4gICAgICBlbmNvZGVkMiA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMV0pO1xuICAgICAgZW5jb2RlZDMgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzJdKTtcbiAgICAgIGVuY29kZWQ0ID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSszXSk7XG5cbiAgICAgIGJ5dGVzW3ArK10gPSAoZW5jb2RlZDEgPDwgMikgfCAoZW5jb2RlZDIgPj4gNCk7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMiAmIDE1KSA8PCA0KSB8IChlbmNvZGVkMyA+PiAyKTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQzICYgMykgPDwgNikgfCAoZW5jb2RlZDQgJiA2Myk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFycmF5YnVmZmVyO1xuICB9O1xufSkoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCIpO1xuIiwiLyoqXG4gKiBDcmVhdGUgYSBibG9iIGJ1aWxkZXIgZXZlbiB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iQnVpbGRlciA9IGdsb2JhbC5CbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuV2ViS2l0QmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLk1TQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLk1vekJsb2JCdWlsZGVyO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2IgY29uc3RydWN0b3IgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JTdXBwb3J0ZWQgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgdmFyIGIgPSBuZXcgQmxvYihbJ2hpJ10pO1xuICAgIHJldHVybiBiLnNpemUgPT0gMjtcbiAgfSBjYXRjaChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKipcbiAqIENoZWNrIGlmIEJsb2JCdWlsZGVyIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iQnVpbGRlclN1cHBvcnRlZCA9IEJsb2JCdWlsZGVyXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5hcHBlbmRcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmdldEJsb2I7XG5cbmZ1bmN0aW9uIEJsb2JCdWlsZGVyQ29uc3RydWN0b3IoYXJ5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBiYiA9IG5ldyBCbG9iQnVpbGRlcigpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGJiLmFwcGVuZChhcnlbaV0pO1xuICB9XG4gIHJldHVybiAob3B0aW9ucy50eXBlKSA/IGJiLmdldEJsb2Iob3B0aW9ucy50eXBlKSA6IGJiLmdldEJsb2IoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICBpZiAoYmxvYlN1cHBvcnRlZCkge1xuICAgIHJldHVybiBnbG9iYWwuQmxvYjtcbiAgfSBlbHNlIGlmIChibG9iQnVpbGRlclN1cHBvcnRlZCkge1xuICAgIHJldHVybiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn0pKCk7XG4iLCJcbi8qXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gaGFzQmluYXJ5O1xuXG4vKipcbiAqIENoZWNrcyBmb3IgYmluYXJ5IGRhdGEuXG4gKlxuICogUmlnaHQgbm93IG9ubHkgQnVmZmVyIGFuZCBBcnJheUJ1ZmZlciBhcmUgc3VwcG9ydGVkLi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYW55dGhpbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gaGFzQmluYXJ5KGRhdGEpIHtcblxuICBmdW5jdGlvbiBfaGFzQmluYXJ5KG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKF9oYXNCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiEgaHR0cDovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHA6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cDovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoY29kZVBvaW50cy5tYXAoZnVuY3Rpb24oeCkge1xuXHRcdC8vIFx0cmV0dXJuICdVKycgKyB4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRcdC8vIH0pKSk7XG5cblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0dmFyIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCdnbG9iYWwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9ICdYTUxIdHRwUmVxdWVzdCcgaW4gZ2xvYmFsICYmXG4gICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCJcbi8qKlxuICogUmV0dXJucyBgdGhpc2AuIEV4ZWN1dGUgdGhpcyB3aXRob3V0IGEgXCJjb250ZXh0XCIgKGkuZS4gd2l0aG91dCBpdCBiZWluZ1xuICogYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBsZWZ0LWhhbmQgc2lkZSksIGFuZCBgdGhpc2AgcG9pbnRzIHRvIHRoZVxuICogXCJnbG9iYWxcIiBzY29wZSBvZiB0aGUgY3VycmVudCBKUyBleGVjdXRpb24uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcbiIsIlxudmFyIGluZGV4T2YgPSBbXS5pbmRleE9mO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgaWYgKGluZGV4T2YpIHJldHVybiBhcnIuaW5kZXhPZihvYmopO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhcnJbaV0gPT09IG9iaikgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufTsiLCIvKipcbiAqIEpTT04gcGFyc2UuXG4gKlxuICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJ2YWxpZGNoYXJzID0gL15bXFxdLDp7fVxcc10qJC87XG52YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcbnZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG52YXIgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xudmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XG52YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2Vqc29uKGRhdGEpIHtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJ0cmltTGVmdCwgJycpLnJlcGxhY2UocnRyaW1SaWdodCwgJycpO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICBpZiAoZ2xvYmFsLkpTT04gJiYgSlNPTi5wYXJzZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICB9XG5cbiAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgJ0AnKVxuICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXG4gICAgICAucmVwbGFjZShydmFsaWRicmFjZXMsICcnKSkpIHtcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBkYXRhKSkoKTtcbiAgfVxufTsiLCIvKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xuICB2YXIgcXJ5ID0ge307XG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiBxcnk7XG59O1xuIiwiLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cbnZhciBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gICAgdmFyIHNyYyA9IHN0cixcbiAgICAgICAgYiA9IHN0ci5pbmRleE9mKCdbJyksXG4gICAgICAgIGUgPSBzdHIuaW5kZXhPZignXScpO1xuXG4gICAgaWYgKGIgIT0gLTEgJiYgZSAhPSAtMSkge1xuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGIpICsgc3RyLnN1YnN0cmluZyhiLCBlKS5yZXBsYWNlKC86L2csICc7JykgKyBzdHIuc3Vic3RyaW5nKGUsIHN0ci5sZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpLFxuICAgICAgICB1cmkgPSB7fSxcbiAgICAgICAgaSA9IDE0O1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgICB9XG5cbiAgICBpZiAoYiAhPSAtMSAmJiBlICE9IC0xKSB7XG4gICAgICAgIHVyaS5zb3VyY2UgPSBzcmM7XG4gICAgICAgIHVyaS5ob3N0ID0gdXJpLmhvc3Quc3Vic3RyaW5nKDEsIHVyaS5ob3N0Lmxlbmd0aCAtIDEpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmF1dGhvcml0eSA9IHVyaS5hdXRob3JpdHkucmVwbGFjZSgnWycsICcnKS5yZXBsYWNlKCddJywgJycpLnJlcGxhY2UoLzsvZywgJzonKTtcbiAgICAgICAgdXJpLmlwdjZ1cmkgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB1cmk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XG5cbi8qKlxuICogV2ViU29ja2V0IGNvbnN0cnVjdG9yLlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQgPyB3cyA6IG51bGw7XG5cbi8qKlxuICogV2ViU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSB0aGlyZCBgb3B0c2Agb3B0aW9ucyBvYmplY3QgZ2V0cyBpZ25vcmVkIGluIHdlYiBicm93c2Vycywgc2luY2UgaXQnc1xuICogbm9uLXN0YW5kYXJkLCBhbmQgdGhyb3dzIGEgVHlwZUVycm9yIGlmIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9laW5hcm9zL3dzL2lzc3Vlcy8yMjdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtPYmplY3QpIG9wdHMgKG9wdGlvbmFsKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB3cyh1cmksIHByb3RvY29scywgb3B0cykge1xuICB2YXIgaW5zdGFuY2U7XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmkpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKFdlYlNvY2tldCkgd3MucHJvdG90eXBlID0gV2ViU29ja2V0LnByb3RvdHlwZTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9jb3JlLmpzJylcbnJlcXVpcmUoJy4vbGliL2RvbmUuanMnKVxucmVxdWlyZSgnLi9saWIvZXM2LWV4dGVuc2lvbnMuanMnKVxucmVxdWlyZSgnLi9saWIvbm9kZS1leHRlbnNpb25zLmpzJykiLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc2FwID0gcmVxdWlyZSgnYXNhcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gUHJvbWlzZTtcbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKHR5cGVvZiB0aGlzICE9PSAnb2JqZWN0JykgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3JylcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IGEgZnVuY3Rpb24nKVxuICB2YXIgc3RhdGUgPSBudWxsXG4gIHZhciB2YWx1ZSA9IG51bGxcbiAgdmFyIGRlZmVycmVkcyA9IFtdXG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIHRoaXMudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgcmV0dXJuIG5ldyBzZWxmLmNvbnN0cnVjdG9yKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaGFuZGxlKG5ldyBIYW5kbGVyKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkLCByZXNvbHZlLCByZWplY3QpKVxuICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGUoZGVmZXJyZWQpIHtcbiAgICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICAgIGRlZmVycmVkcy5wdXNoKGRlZmVycmVkKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGFzYXAoZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY2IgPSBzdGF0ZSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZFxuICAgICAgaWYgKGNiID09PSBudWxsKSB7XG4gICAgICAgIChzdGF0ZSA/IGRlZmVycmVkLnJlc29sdmUgOiBkZWZlcnJlZC5yZWplY3QpKHZhbHVlKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHZhciByZXRcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldCA9IGNiKHZhbHVlKVxuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVmZXJyZWQucmVqZWN0KGUpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXQpXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc29sdmUobmV3VmFsdWUpIHtcbiAgICB0cnkgeyAvL1Byb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHNlbGYpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgcHJvbWlzZSBjYW5ub3QgYmUgcmVzb2x2ZWQgd2l0aCBpdHNlbGYuJylcbiAgICAgIGlmIChuZXdWYWx1ZSAmJiAodHlwZW9mIG5ld1ZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgbmV3VmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgIHZhciB0aGVuID0gbmV3VmFsdWUudGhlblxuICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkb1Jlc29sdmUodGhlbi5iaW5kKG5ld1ZhbHVlKSwgcmVzb2x2ZSwgcmVqZWN0KVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGF0ZSA9IHRydWVcbiAgICAgIHZhbHVlID0gbmV3VmFsdWVcbiAgICAgIGZpbmFsZSgpXG4gICAgfSBjYXRjaCAoZSkgeyByZWplY3QoZSkgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVqZWN0KG5ld1ZhbHVlKSB7XG4gICAgc3RhdGUgPSBmYWxzZVxuICAgIHZhbHVlID0gbmV3VmFsdWVcbiAgICBmaW5hbGUoKVxuICB9XG5cbiAgZnVuY3Rpb24gZmluYWxlKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkZWZlcnJlZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspXG4gICAgICBoYW5kbGUoZGVmZXJyZWRzW2ldKVxuICAgIGRlZmVycmVkcyA9IG51bGxcbiAgfVxuXG4gIGRvUmVzb2x2ZShmbiwgcmVzb2x2ZSwgcmVqZWN0KVxufVxuXG5cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHJlc29sdmUsIHJlamVjdCl7XG4gIHRoaXMub25GdWxmaWxsZWQgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IG51bGxcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbFxuICB0aGlzLnJlc29sdmUgPSByZXNvbHZlXG4gIHRoaXMucmVqZWN0ID0gcmVqZWN0XG59XG5cbi8qKlxuICogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiAqIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGFyZSBvbmx5IGNhbGxlZCBvbmNlLlxuICpcbiAqIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiAqL1xuZnVuY3Rpb24gZG9SZXNvbHZlKGZuLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICB0cnkge1xuICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKGRvbmUpIHJldHVyblxuICAgICAgZG9uZSA9IHRydWVcbiAgICAgIG9uRnVsZmlsbGVkKHZhbHVlKVxuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChkb25lKSByZXR1cm5cbiAgICAgIGRvbmUgPSB0cnVlXG4gICAgICBvblJlamVjdGVkKHJlYXNvbilcbiAgICB9KVxuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChkb25lKSByZXR1cm5cbiAgICBkb25lID0gdHJ1ZVxuICAgIG9uUmVqZWN0ZWQoZXgpXG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKVxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJylcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlXG5Qcm9taXNlLnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHZhciBzZWxmID0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMudGhlbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogdGhpc1xuICBzZWxmLnRoZW4obnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZXJyXG4gICAgfSlcbiAgfSlcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8vVGhpcyBmaWxlIGNvbnRhaW5zIHRoZSBFUzYgZXh0ZW5zaW9ucyB0byB0aGUgY29yZSBQcm9taXNlcy9BKyBBUElcblxudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL2NvcmUuanMnKVxudmFyIGFzYXAgPSByZXF1aXJlKCdhc2FwJylcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlXG5cbi8qIFN0YXRpYyBGdW5jdGlvbnMgKi9cblxuZnVuY3Rpb24gVmFsdWVQcm9taXNlKHZhbHVlKSB7XG4gIHRoaXMudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCkge1xuICAgIGlmICh0eXBlb2Ygb25GdWxmaWxsZWQgIT09ICdmdW5jdGlvbicpIHJldHVybiB0aGlzXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGFzYXAoZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJlc29sdmUob25GdWxmaWxsZWQodmFsdWUpKVxuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHJlamVjdChleCk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuVmFsdWVQcm9taXNlLnByb3RvdHlwZSA9IFByb21pc2UucHJvdG90eXBlXG5cbnZhciBUUlVFID0gbmV3IFZhbHVlUHJvbWlzZSh0cnVlKVxudmFyIEZBTFNFID0gbmV3IFZhbHVlUHJvbWlzZShmYWxzZSlcbnZhciBOVUxMID0gbmV3IFZhbHVlUHJvbWlzZShudWxsKVxudmFyIFVOREVGSU5FRCA9IG5ldyBWYWx1ZVByb21pc2UodW5kZWZpbmVkKVxudmFyIFpFUk8gPSBuZXcgVmFsdWVQcm9taXNlKDApXG52YXIgRU1QVFlTVFJJTkcgPSBuZXcgVmFsdWVQcm9taXNlKCcnKVxuXG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHZhbHVlXG5cbiAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gTlVMTFxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFVOREVGSU5FRFxuICBpZiAodmFsdWUgPT09IHRydWUpIHJldHVybiBUUlVFXG4gIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHJldHVybiBGQUxTRVxuICBpZiAodmFsdWUgPT09IDApIHJldHVybiBaRVJPXG4gIGlmICh2YWx1ZSA9PT0gJycpIHJldHVybiBFTVBUWVNUUklOR1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgdGhlbiA9IHZhbHVlLnRoZW5cbiAgICAgIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UodGhlbi5iaW5kKHZhbHVlKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmVqZWN0KGV4KVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3IFZhbHVlUHJvbWlzZSh2YWx1ZSlcbn1cblxuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyKVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzb2x2ZShbXSlcbiAgICB2YXIgcmVtYWluaW5nID0gYXJncy5sZW5ndGhcbiAgICBmdW5jdGlvbiByZXMoaSwgdmFsKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodmFsICYmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgIHZhciB0aGVuID0gdmFsLnRoZW5cbiAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbCh2YWwsIGZ1bmN0aW9uICh2YWwpIHsgcmVzKGksIHZhbCkgfSwgcmVqZWN0KVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyZ3NbaV0gPSB2YWxcbiAgICAgICAgaWYgKC0tcmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgcmVzb2x2ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgcmVqZWN0KGV4KVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlcyhpLCBhcmdzW2ldKVxuICAgIH1cbiAgfSlcbn1cblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgXG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59XG5cblByb21pc2UucmFjZSA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgXG4gICAgdmFsdWVzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpe1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSlcbiAgfSk7XG59XG5cbi8qIFByb3RvdHlwZSBNZXRob2RzICovXG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBvblJlamVjdGVkKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLy9UaGlzIGZpbGUgY29udGFpbnMgdGhlbi9wcm9taXNlIHNwZWNpZmljIGV4dGVuc2lvbnMgdGhhdCBhcmUgb25seSB1c2VmdWwgZm9yIG5vZGUuanMgaW50ZXJvcFxuXG52YXIgUHJvbWlzZSA9IHJlcXVpcmUoJy4vY29yZS5qcycpXG52YXIgYXNhcCA9IHJlcXVpcmUoJ2FzYXAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFByb21pc2VcblxuLyogU3RhdGljIEZ1bmN0aW9ucyAqL1xuXG5Qcm9taXNlLmRlbm9kZWlmeSA9IGZ1bmN0aW9uIChmbiwgYXJndW1lbnRDb3VudCkge1xuICBhcmd1bWVudENvdW50ID0gYXJndW1lbnRDb3VudCB8fCBJbmZpbml0eVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpc1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB3aGlsZSAoYXJncy5sZW5ndGggJiYgYXJncy5sZW5ndGggPiBhcmd1bWVudENvdW50KSB7XG4gICAgICAgIGFyZ3MucG9wKClcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChmdW5jdGlvbiAoZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycilcbiAgICAgICAgZWxzZSByZXNvbHZlKHJlcylcbiAgICAgIH0pXG4gICAgICB2YXIgcmVzID0gZm4uYXBwbHkoc2VsZiwgYXJncylcbiAgICAgIGlmIChyZXMgJiYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXMgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiByZXMudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXNvbHZlKHJlcylcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5Qcm9taXNlLm5vZGVpZnkgPSBmdW5jdGlvbiAoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cylcbiAgICB2YXIgY2FsbGJhY2sgPSB0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nID8gYXJncy5wb3AoKSA6IG51bGxcbiAgICB2YXIgY3R4ID0gdGhpc1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKS5ub2RlaWZ5KGNhbGxiYWNrLCBjdHgpXG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgcmVqZWN0KGV4KSB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2FsbGJhY2suY2FsbChjdHgsIGV4KVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5Qcm9taXNlLnByb3RvdHlwZS5ub2RlaWZ5ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjdHgpIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpc1xuXG4gIHRoaXMudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhc2FwKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBudWxsLCB2YWx1ZSlcbiAgICB9KVxuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgYXNhcChmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsYmFjay5jYWxsKGN0eCwgZXJyKVxuICAgIH0pXG4gIH0pXG59XG4iLCJcbi8vIFVzZSB0aGUgZmFzdGVzdCBwb3NzaWJsZSBtZWFucyB0byBleGVjdXRlIGEgdGFzayBpbiBhIGZ1dHVyZSB0dXJuXG4vLyBvZiB0aGUgZXZlbnQgbG9vcC5cblxuLy8gbGlua2VkIGxpc3Qgb2YgdGFza3MgKHNpbmdsZSwgd2l0aCBoZWFkIG5vZGUpXG52YXIgaGVhZCA9IHt0YXNrOiB2b2lkIDAsIG5leHQ6IG51bGx9O1xudmFyIHRhaWwgPSBoZWFkO1xudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgcmVxdWVzdEZsdXNoID0gdm9pZCAwO1xudmFyIGlzTm9kZUpTID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIC8qIGpzaGludCBsb29wZnVuYzogdHJ1ZSAqL1xuXG4gICAgd2hpbGUgKGhlYWQubmV4dCkge1xuICAgICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgICB2YXIgdGFzayA9IGhlYWQudGFzaztcbiAgICAgICAgaGVhZC50YXNrID0gdm9pZCAwO1xuICAgICAgICB2YXIgZG9tYWluID0gaGVhZC5kb21haW47XG5cbiAgICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgICAgICAgaGVhZC5kb21haW4gPSB2b2lkIDA7XG4gICAgICAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXNrKCk7XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGlzTm9kZUpTKSB7XG4gICAgICAgICAgICAgICAgLy8gSW4gbm9kZSwgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgY29uc2lkZXJlZCBmYXRhbCBlcnJvcnMuXG4gICAgICAgICAgICAgICAgLy8gUmUtdGhyb3cgdGhlbSBzeW5jaHJvbm91c2x5IHRvIGludGVycnVwdCBmbHVzaGluZyFcblxuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBjb250aW51YXRpb24gaWYgdGhlIHVuY2F1Z2h0IGV4Y2VwdGlvbiBpcyBzdXBwcmVzc2VkXG4gICAgICAgICAgICAgICAgLy8gbGlzdGVuaW5nIFwidW5jYXVnaHRFeGNlcHRpb25cIiBldmVudHMgKGFzIGRvbWFpbnMgZG9lcykuXG4gICAgICAgICAgICAgICAgLy8gQ29udGludWUgaW4gbmV4dCBldmVudCB0byBhdm9pZCB0aWNrIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZmx1c2gsIDApO1xuICAgICAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tYWluLmVudGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBicm93c2VycywgdW5jYXVnaHQgZXhjZXB0aW9ucyBhcmUgbm90IGZhdGFsLlxuICAgICAgICAgICAgICAgIC8vIFJlLXRocm93IHRoZW0gYXN5bmNocm9ub3VzbHkgdG8gYXZvaWQgc2xvdy1kb3ducy5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZG9tYWluKSB7XG4gICAgICAgICAgICBkb21haW4uZXhpdCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZmx1c2hpbmcgPSBmYWxzZTtcbn1cblxuaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAvLyBOb2RlLmpzIGJlZm9yZSAwLjkuIE5vdGUgdGhhdCBzb21lIGZha2UtTm9kZSBlbnZpcm9ubWVudHMsIGxpa2UgdGhlXG4gICAgLy8gTW9jaGEgdGVzdCBydW5uZXIsIGludHJvZHVjZSBhIGBwcm9jZXNzYCBnbG9iYWwgd2l0aG91dCBhIGBuZXh0VGlja2AuXG4gICAgaXNOb2RlSlMgPSB0cnVlO1xuXG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZsdXNoKTtcbiAgICB9O1xuXG59IGVsc2UgaWYgKHR5cGVvZiBzZXRJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIC8vIEluIElFMTAsIE5vZGUuanMgMC45Kywgb3IgaHR0cHM6Ly9naXRodWIuY29tL05vYmxlSlMvc2V0SW1tZWRpYXRlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoID0gc2V0SW1tZWRpYXRlLmJpbmQod2luZG93LCBmbHVzaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc2V0SW1tZWRpYXRlKGZsdXNoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0gZWxzZSBpZiAodHlwZW9mIE1lc3NhZ2VDaGFubmVsICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgLy8gbW9kZXJuIGJyb3dzZXJzXG4gICAgLy8gaHR0cDovL3d3dy5ub25ibG9ja2luZy5pby8yMDExLzA2L3dpbmRvd25leHR0aWNrLmh0bWxcbiAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2g7XG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKDApO1xuICAgIH07XG5cbn0gZWxzZSB7XG4gICAgLy8gb2xkIGJyb3dzZXJzXG4gICAgcmVxdWVzdEZsdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZsdXNoLCAwKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBhc2FwKHRhc2spIHtcbiAgICB0YWlsID0gdGFpbC5uZXh0ID0ge1xuICAgICAgICB0YXNrOiB0YXNrLFxuICAgICAgICBkb21haW46IGlzTm9kZUpTICYmIHByb2Nlc3MuZG9tYWluLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgICAgZmx1c2hpbmcgPSB0cnVlO1xuICAgICAgICByZXF1ZXN0Rmx1c2goKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzYXA7XG5cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi8nKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBNYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbG9va3VwO1xuXG4vKipcbiAqIE1hbmFnZXJzIGNhY2hlLlxuICovXG5cbnZhciBjYWNoZSA9IGV4cG9ydHMubWFuYWdlcnMgPSB7fTtcblxuLyoqXG4gKiBMb29rcyB1cCBhbiBleGlzdGluZyBgTWFuYWdlcmAgZm9yIG11bHRpcGxleGluZy5cbiAqIElmIHRoZSB1c2VyIHN1bW1vbnM6XG4gKlxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYScpO2BcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2InKTtgXG4gKlxuICogV2UgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlIGJhc2VkIG9uIHNhbWUgc2NoZW1lL3BvcnQvaG9zdCxcbiAqIGFuZCB3ZSBpbml0aWFsaXplIHNvY2tldHMgZm9yIGVhY2ggbmFtZXNwYWNlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9va3VwKHVyaSwgb3B0cykge1xuICBpZiAodHlwZW9mIHVyaSA9PSAnb2JqZWN0Jykge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgdmFyIHBhcnNlZCA9IHVybCh1cmkpO1xuICB2YXIgc291cmNlID0gcGFyc2VkLnNvdXJjZTtcbiAgdmFyIGlkID0gcGFyc2VkLmlkO1xuICB2YXIgaW87XG5cbiAgaWYgKG9wdHMuZm9yY2VOZXcgfHwgb3B0c1snZm9yY2UgbmV3IGNvbm5lY3Rpb24nXSB8fCBmYWxzZSA9PT0gb3B0cy5tdWx0aXBsZXgpIHtcbiAgICBkZWJ1ZygnaWdub3Jpbmcgc29ja2V0IGNhY2hlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgaW8gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFjYWNoZVtpZF0pIHtcbiAgICAgIGRlYnVnKCduZXcgaW8gaW5zdGFuY2UgZm9yICVzJywgc291cmNlKTtcbiAgICAgIGNhY2hlW2lkXSA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgICB9XG4gICAgaW8gPSBjYWNoZVtpZF07XG4gIH1cblxuICByZXR1cm4gaW8uc29ja2V0KHBhcnNlZC5wYXRoKTtcbn1cblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDtcblxuLyoqXG4gKiBgY29ubmVjdGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNvbm5lY3QgPSBsb29rdXA7XG5cbi8qKlxuICogRXhwb3NlIGNvbnN0cnVjdG9ycyBmb3Igc3RhbmRhbG9uZSBidWlsZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xuZXhwb3J0cy5Tb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgZWlvID0gcmVxdWlyZSgnZW5naW5lLmlvLWNsaWVudCcpO1xudmFyIFNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIG9iamVjdCA9IHJlcXVpcmUoJ29iamVjdC1jb21wb25lbnQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6bWFuYWdlcicpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvMicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNYW5hZ2VyO1xuXG4vKipcbiAqIGBNYW5hZ2VyYCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5naW5lIGluc3RhbmNlIG9yIGVuZ2luZSB1cmkvb3B0c1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTWFuYWdlcih1cmksIG9wdHMpe1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTWFuYWdlcikpIHJldHVybiBuZXcgTWFuYWdlcih1cmksIG9wdHMpO1xuICBpZiAodXJpICYmICgnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gdW5kZWZpbmVkO1xuICB9XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCAnL3NvY2tldC5pbyc7XG4gIHRoaXMubnNwcyA9IHt9O1xuICB0aGlzLnN1YnMgPSBbXTtcbiAgdGhpcy5vcHRzID0gb3B0cztcbiAgdGhpcy5yZWNvbm5lY3Rpb24ob3B0cy5yZWNvbm5lY3Rpb24gIT09IGZhbHNlKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25BdHRlbXB0cyhvcHRzLnJlY29ubmVjdGlvbkF0dGVtcHRzIHx8IEluZmluaXR5KTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheShvcHRzLnJlY29ubmVjdGlvbkRlbGF5IHx8IDEwMDApO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KG9wdHMucmVjb25uZWN0aW9uRGVsYXlNYXggfHwgNTAwMCk7XG4gIHRoaXMucmFuZG9taXphdGlvbkZhY3RvcihvcHRzLnJhbmRvbWl6YXRpb25GYWN0b3IgfHwgMC41KTtcbiAgdGhpcy5iYWNrb2ZmID0gbmV3IEJhY2tvZmYoe1xuICAgIG1pbjogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpLFxuICAgIG1heDogdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heCgpLFxuICAgIGppdHRlcjogdGhpcy5yYW5kb21pemF0aW9uRmFjdG9yKClcbiAgfSk7XG4gIHRoaXMudGltZW91dChudWxsID09IG9wdHMudGltZW91dCA/IDIwMDAwIDogb3B0cy50aW1lb3V0KTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMudXJpID0gdXJpO1xuICB0aGlzLmNvbm5lY3RlZCA9IFtdO1xuICB0aGlzLmVuY29kaW5nID0gZmFsc2U7XG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RlciA9IG5ldyBwYXJzZXIuRW5jb2RlcigpO1xuICB0aGlzLmRlY29kZXIgPSBuZXcgcGFyc2VyLkRlY29kZXIoKTtcbiAgdGhpcy5hdXRvQ29ubmVjdCA9IG9wdHMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlO1xuICBpZiAodGhpcy5hdXRvQ29ubmVjdCkgdGhpcy5vcGVuKCk7XG59XG5cbi8qKlxuICogUHJvcGFnYXRlIGdpdmVuIGV2ZW50IHRvIHNvY2tldHMgYW5kIGVtaXQgb24gYHRoaXNgXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZW1pdEFsbCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIHRoaXMubnNwc1tuc3BdLmVtaXQuYXBwbHkodGhpcy5uc3BzW25zcF0sIGFyZ3VtZW50cyk7XG4gIH1cbn07XG5cbi8qKlxuICogVXBkYXRlIGBzb2NrZXQuaWRgIG9mIGFsbCBzb2NrZXRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudXBkYXRlU29ja2V0SWRzID0gZnVuY3Rpb24oKXtcbiAgZm9yICh2YXIgbnNwIGluIHRoaXMubnNwcykge1xuICAgIHRoaXMubnNwc1tuc3BdLmlkID0gdGhpcy5lbmdpbmUuaWQ7XG4gIH1cbn07XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKE1hbmFnZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgcmVjb25uZWN0aW9uYCBjb25maWcuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSB0cnVlL2ZhbHNlIGlmIGl0IHNob3VsZCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb24gPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uO1xuICB0aGlzLl9yZWNvbm5lY3Rpb24gPSAhIXY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggcmVjb25uZWN0aW9uIGF0dGVtcHRzIGJlZm9yZSBnaXZpbmcgdXBcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uQXR0ZW1wdHMgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHM7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXkgPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXk7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNaW4odik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuTWFuYWdlci5wcm90b3R5cGUucmFuZG9taXphdGlvbkZhY3RvciA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yO1xuICB0aGlzLl9yYW5kb21pemF0aW9uRmFjdG9yID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRKaXR0ZXIodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgdGhpcy5iYWNrb2ZmICYmIHRoaXMuYmFja29mZi5zZXRNYXgodik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbigpIHtcbiAgLy8gT25seSB0cnkgdG8gcmVjb25uZWN0IGlmIGl0J3MgdGhlIGZpcnN0IHRpbWUgd2UncmUgY29ubmVjdGluZ1xuICBpZiAoIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbiAmJiB0aGlzLmJhY2tvZmYuYXR0ZW1wdHMgPT09IDApIHtcbiAgICAvLyBrZWVwcyByZWNvbm5lY3Rpb24gZnJvbSBmaXJpbmcgdHdpY2UgZm9yIHRoZSBzYW1lIHJlY29ubmVjdGlvbiBsb29wXG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihmbil7XG4gIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuICBkZWJ1Zygnb3BlbmluZyAlcycsIHRoaXMudXJpKTtcbiAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IGZhbHNlO1xuXG4gIC8vIGVtaXQgYG9wZW5gXG4gIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbihkYXRhKXtcbiAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuICAgIHNlbGYuY2xlYW51cCgpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgZm4oZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT25seSBkbyB0aGlzIGlmIHRoZXJlIGlzIG5vIGZuIHRvIGhhbmRsZSB0aGUgZXJyb3JcbiAgICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cbiAgICAvLyBzZXQgdGltZXJcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdvcGVuJyk7XG5cbiAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgLy8gbWFyayBhcyBvcGVuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgLy8gYWRkIG5ldyBzdWJzXG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24obnNwKXtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKXtcbiAgICAgIHNvY2tldC5pZCA9IHNlbGYuZW5naW5lLmlkO1xuICAgICAgaWYgKCF+aW5kZXhPZihzZWxmLmNvbm5lY3RlZCwgc29ja2V0KSkge1xuICAgICAgICBzZWxmLmNvbm5lY3RlZC5wdXNoKHNvY2tldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihzb2NrZXQpe1xuICB2YXIgaW5kZXggPSBpbmRleE9mKHRoaXMuY29ubmVjdGVkLCBzb2NrZXQpO1xuICBpZiAofmluZGV4KSB0aGlzLmNvbm5lY3RlZC5zcGxpY2UoaW5kZXgsIDEpO1xuICBpZiAodGhpcy5jb25uZWN0ZWQubGVuZ3RoKSByZXR1cm47XG5cbiAgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghc2VsZi5lbmNvZGluZykge1xuICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcbiAgICBzZWxmLmVuY29kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24oZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0pO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpe1xuICB2YXIgc3ViO1xuICB3aGlsZSAoc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCkpIHN1Yi5kZXN0cm95KCk7XG5cbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVuZ2luZSAmJiB0aGlzLmVuZ2luZS5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLmNsZWFudXAoKTtcbiAgdGhpcy5iYWNrb2ZmLnJlc2V0KCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZyB8fCB0aGlzLnNraXBSZWNvbm5lY3QpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy5iYWNrb2ZmLmF0dGVtcHRzID49IHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzKSB7XG4gICAgZGVidWcoJ3JlY29ubmVjdCBmYWlsZWQnKTtcbiAgICB0aGlzLmJhY2tvZmYucmVzZXQoKTtcbiAgICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdF9mYWlsZWQnKTtcbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkZWxheSA9IHRoaXMuYmFja29mZi5kdXJhdGlvbigpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuc2tpcFJlY29ubmVjdCkgcmV0dXJuO1xuXG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RpbmcnLCBzZWxmLmJhY2tvZmYuYXR0ZW1wdHMpO1xuXG4gICAgICAvLyBjaGVjayBhZ2FpbiBmb3IgdGhlIGNhc2Ugc29ja2V0IGNsb3NlZCBpbiBhYm92ZSBldmVudHNcbiAgICAgIGlmIChzZWxmLnNraXBSZWNvbm5lY3QpIHJldHVybjtcblxuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmJhY2tvZmYuYXR0ZW1wdHM7XG4gIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIHRoaXMuYmFja29mZi5yZXNldCgpO1xuICB0aGlzLnVwZGF0ZVNvY2tldElkcygpO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBoYXNCaW4gPSByZXF1aXJlKCdoYXMtYmluYXJ5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIEludGVybmFsIGV2ZW50cyAoYmxhY2tsaXN0ZWQpLlxuICogVGhlc2UgZXZlbnRzIGNhbid0IGJlIGVtaXR0ZWQgYnkgdGhlIHVzZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIGV2ZW50cyA9IHtcbiAgY29ubmVjdDogMSxcbiAgY29ubmVjdF9lcnJvcjogMSxcbiAgY29ubmVjdF90aW1lb3V0OiAxLFxuICBkaXNjb25uZWN0OiAxLFxuICBlcnJvcjogMSxcbiAgcmVjb25uZWN0OiAxLFxuICByZWNvbm5lY3RfYXR0ZW1wdDogMSxcbiAgcmVjb25uZWN0X2ZhaWxlZDogMSxcbiAgcmVjb25uZWN0X2Vycm9yOiAxLFxuICByZWNvbm5lY3Rpbmc6IDFcbn07XG5cbi8qKlxuICogU2hvcnRjdXQgdG8gYEVtaXR0ZXIjZW1pdGAuXG4gKi9cblxudmFyIGVtaXQgPSBFbWl0dGVyLnByb3RvdHlwZS5lbWl0O1xuXG4vKipcbiAqIGBTb2NrZXRgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KGlvLCBuc3Ape1xuICB0aGlzLmlvID0gaW87XG4gIHRoaXMubnNwID0gbnNwO1xuICB0aGlzLmpzb24gPSB0aGlzOyAvLyBjb21wYXRcbiAgdGhpcy5pZHMgPSAwO1xuICB0aGlzLmFja3MgPSB7fTtcbiAgaWYgKHRoaXMuaW8uYXV0b0Nvbm5lY3QpIHRoaXMub3BlbigpO1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuc3VicykgcmV0dXJuO1xuXG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBcIk9wZW5zXCIgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuc3ViRXZlbnRzKCk7XG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuICBpZiAoaGFzQmluKGFyZ3MpKSB7IHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UOyB9IC8vIGJpbmFyeVxuICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXJUeXBlLCBkYXRhOiBhcmdzIH07XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT0gdGhpcy5uc3ApIHtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICBkZWxldGUgdGhpcy5pZDtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgaWYgKHBhY2tldC5uc3AgIT0gdGhpcy5uc3ApIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uKGlkKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgdmFyIHR5cGUgPSBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0s7XG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gIHZhciBmbiA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBmbi5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnN1YnMpIHtcbiAgICAvLyBjbGVhbiBzdWJzY3JpcHRpb25zIHRvIGF2b2lkIHJlY29ubmVjdGlvbnNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy5zdWJzID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuRElTQ09OTkVDVCB9KTtcbiAgfVxuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIC8vIGZpcmUgZXZlbnRzXG4gICAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBwYXJzZXVyaSA9IHJlcXVpcmUoJ3BhcnNldXJpJyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50OnVybCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gdXJsO1xuXG4vKipcbiAqIFVSTCBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IEFuIG9iamVjdCBtZWFudCB0byBtaW1pYyB3aW5kb3cubG9jYXRpb24uXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gd2luZG93LmxvY2F0aW9uLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB1cmwodXJpLCBsb2Mpe1xuICB2YXIgb2JqID0gdXJpO1xuXG4gIC8vIGRlZmF1bHQgdG8gd2luZG93LmxvY2F0aW9uXG4gIHZhciBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uO1xuICBpZiAobnVsbCA9PSB1cmkpIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyBsb2MuaG9zdDtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgxKSkge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSBsb2MuaG9zdG5hbWUgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCEvXihodHRwcz98d3NzPyk6XFwvXFwvLy50ZXN0KHVyaSkpIHtcbiAgICAgIGRlYnVnKCdwcm90b2NvbC1sZXNzIHVybCAlcycsIHVyaSk7XG4gICAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGxvYykge1xuICAgICAgICB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgdXJpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJpID0gJ2h0dHBzOi8vJyArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwYXJzZVxuICAgIGRlYnVnKCdwYXJzZSAlcycsIHVyaSk7XG4gICAgb2JqID0gcGFyc2V1cmkodXJpKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSB0cmVhdCBgbG9jYWxob3N0OjgwYCBhbmQgYGxvY2FsaG9zdGAgZXF1YWxseVxuICBpZiAoIW9iai5wb3J0KSB7XG4gICAgaWYgKC9eKGh0dHB8d3MpJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc4MCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKC9eKGh0dHB8d3MpcyQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnNDQzJztcbiAgICB9XG4gIH1cblxuICBvYmoucGF0aCA9IG9iai5wYXRoIHx8ICcvJztcblxuICAvLyBkZWZpbmUgdW5pcXVlIGlkXG4gIG9iai5pZCA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgb2JqLmhvc3QgKyAnOicgKyBvYmoucG9ydDtcbiAgLy8gZGVmaW5lIGhyZWZcbiAgb2JqLmhyZWYgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIG9iai5ob3N0ICsgKGxvYyAmJiBsb2MucG9ydCA9PSBvYmoucG9ydCA/ICcnIDogKCc6JyArIG9iai5wb3J0KSk7XG5cbiAgcmV0dXJuIG9iajtcbn1cbiIsIlxuLyoqXG4gKiBFeHBvc2UgYEJhY2tvZmZgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gQmFja29mZjtcblxuLyoqXG4gKiBJbml0aWFsaXplIGJhY2tvZmYgdGltZXIgd2l0aCBgb3B0c2AuXG4gKlxuICogLSBgbWluYCBpbml0aWFsIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIFsxMDBdXG4gKiAtIGBtYXhgIG1heCB0aW1lb3V0IFsxMDAwMF1cbiAqIC0gYGppdHRlcmAgWzBdXG4gKiAtIGBmYWN0b3JgIFsyXVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEJhY2tvZmYob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgdGhpcy5tcyA9IG9wdHMubWluIHx8IDEwMDtcbiAgdGhpcy5tYXggPSBvcHRzLm1heCB8fCAxMDAwMDtcbiAgdGhpcy5mYWN0b3IgPSBvcHRzLmZhY3RvciB8fCAyO1xuICB0aGlzLmppdHRlciA9IG9wdHMuaml0dGVyID4gMCAmJiBvcHRzLmppdHRlciA8PSAxID8gb3B0cy5qaXR0ZXIgOiAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGJhY2tvZmYgZHVyYXRpb24uXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uKCl7XG4gIHZhciBtcyA9IHRoaXMubXMgKiBNYXRoLnBvdyh0aGlzLmZhY3RvciwgdGhpcy5hdHRlbXB0cysrKTtcbiAgaWYgKHRoaXMuaml0dGVyKSB7XG4gICAgdmFyIHJhbmQgPSAgTWF0aC5yYW5kb20oKTtcbiAgICB2YXIgZGV2aWF0aW9uID0gTWF0aC5mbG9vcihyYW5kICogdGhpcy5qaXR0ZXIgKiBtcyk7XG4gICAgbXMgPSAoTWF0aC5mbG9vcihyYW5kICogMTApICYgMSkgPT0gMCAgPyBtcyAtIGRldmlhdGlvbiA6IG1zICsgZGV2aWF0aW9uO1xuICB9XG4gIHJldHVybiBNYXRoLm1pbihtcywgdGhpcy5tYXgpIHwgMDtcbn07XG5cbi8qKlxuICogUmVzZXQgdGhlIG51bWJlciBvZiBhdHRlbXB0cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgbWluaW11bSBkdXJhdGlvblxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQmFja29mZi5wcm90b3R5cGUuc2V0TWluID0gZnVuY3Rpb24obWluKXtcbiAgdGhpcy5tcyA9IG1pbjtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXhpbXVtIGR1cmF0aW9uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5CYWNrb2ZmLnByb3RvdHlwZS5zZXRNYXggPSBmdW5jdGlvbihtYXgpe1xuICB0aGlzLm1heCA9IG1heDtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBqaXR0ZXJcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkJhY2tvZmYucHJvdG90eXBlLnNldEppdHRlciA9IGZ1bmN0aW9uKGppdHRlcil7XG4gIHRoaXMuaml0dGVyID0gaml0dGVyO1xufTtcblxuIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtUeXBlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lKSB7XG4gIGlmICghZGVidWcuZW5hYmxlZChuYW1lKSkgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcblxuICByZXR1cm4gZnVuY3Rpb24oZm10KXtcbiAgICBmbXQgPSBjb2VyY2UoZm10KTtcblxuICAgIHZhciBjdXJyID0gbmV3IERhdGU7XG4gICAgdmFyIG1zID0gY3VyciAtIChkZWJ1Z1tuYW1lXSB8fCBjdXJyKTtcbiAgICBkZWJ1Z1tuYW1lXSA9IGN1cnI7XG5cbiAgICBmbXQgPSBuYW1lXG4gICAgICArICcgJ1xuICAgICAgKyBmbXRcbiAgICAgICsgJyArJyArIGRlYnVnLmh1bWFuaXplKG1zKTtcblxuICAgIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4XG4gICAgLy8gd2hlcmUgYGNvbnNvbGUubG9nYCBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICAgIHdpbmRvdy5jb25zb2xlXG4gICAgICAmJiBjb25zb2xlLmxvZ1xuICAgICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLlxuICovXG5cbmRlYnVnLm5hbWVzID0gW107XG5kZWJ1Zy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWUuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZW5hYmxlID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5kZWJ1ZyA9IG5hbWU7XG4gIH0gY2F0Y2goZSl7fVxuXG4gIHZhciBzcGxpdCA9IChuYW1lIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pXG4gICAgLCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hbWUgPSBzcGxpdFtpXS5yZXBsYWNlKCcqJywgJy4qPycpO1xuICAgIGlmIChuYW1lWzBdID09PSAnLScpIHtcbiAgICAgIGRlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lLnN1YnN0cigxKSArICckJykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lICsgJyQnKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZGlzYWJsZSA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnLmVuYWJsZSgnJyk7XG59O1xuXG4vKipcbiAqIEh1bWFuaXplIHRoZSBnaXZlbiBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5kZWJ1Zy5odW1hbml6ZSA9IGZ1bmN0aW9uKG1zKSB7XG4gIHZhciBzZWMgPSAxMDAwXG4gICAgLCBtaW4gPSA2MCAqIDEwMDBcbiAgICAsIGhvdXIgPSA2MCAqIG1pbjtcblxuICBpZiAobXMgPj0gaG91cikgcmV0dXJuIChtcyAvIGhvdXIpLnRvRml4ZWQoMSkgKyAnaCc7XG4gIGlmIChtcyA+PSBtaW4pIHJldHVybiAobXMgLyBtaW4pLnRvRml4ZWQoMSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzZWMpIHJldHVybiAobXMgLyBzZWMgfCAwKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5kZWJ1Zy5lbmFibGVkID0gZnVuY3Rpb24obmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG4vLyBwZXJzaXN0XG5cbnRyeSB7XG4gIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSBkZWJ1Zy5lbmFibGUobG9jYWxTdG9yYWdlLmRlYnVnKTtcbn0gY2F0Y2goZSl7fVxuIiwiXG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gX2hhc0JpbmFyeShvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgICAoZ2xvYmFsLkZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChfaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIGlmIChvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSAmJiBfaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIF9oYXNCaW5hcnkoZGF0YSk7XG59XG4iLCJcbi8qKlxuICogSE9QIHJlZi5cbiAqL1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBSZXR1cm4gb3duIGtleXMgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMua2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iail7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBvd24gdmFsdWVzIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnZhbHVlcyA9IGZ1bmN0aW9uKG9iail7XG4gIHZhciB2YWxzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICB2YWxzLnB1c2gob2JqW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFscztcbn07XG5cbi8qKlxuICogTWVyZ2UgYGJgIGludG8gYGFgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhXG4gKiBAcGFyYW0ge09iamVjdH0gYlxuICogQHJldHVybiB7T2JqZWN0fSBhXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbihhLCBiKXtcbiAgZm9yICh2YXIga2V5IGluIGIpIHtcbiAgICBpZiAoaGFzLmNhbGwoYiwga2V5KSkge1xuICAgICAgYVtrZXldID0gYltrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGxlbmd0aCBvZiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMubGVuZ3RoID0gZnVuY3Rpb24ob2JqKXtcbiAgcmV0dXJuIGV4cG9ydHMua2V5cyhvYmopLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgZW1wdHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5pc0VtcHR5ID0gZnVuY3Rpb24ob2JqKXtcbiAgcmV0dXJuIDAgPT0gZXhwb3J0cy5sZW5ndGgob2JqKTtcbn07IiwiLyoqXG4gKiBQYXJzZXMgYW4gVVJJXG4gKlxuICogQGF1dGhvciBTdGV2ZW4gTGV2aXRoYW4gPHN0ZXZlbmxldml0aGFuLmNvbT4gKE1JVCBsaWNlbnNlKVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJlID0gL14oPzooPyFbXjpAXSs6W146QFxcL10qQCkoaHR0cHxodHRwc3x3c3x3c3MpOlxcL1xcLyk/KCg/OigoW146QF0qKSg/OjooW146QF0qKSk/KT9AKT8oKD86W2EtZjAtOV17MCw0fTopezIsN31bYS1mMC05XXswLDR9fFteOlxcLz8jXSopKD86OihcXGQqKSk/KSgoKFxcLyg/OltePyNdKD8hW14/I1xcL10qXFwuW14/I1xcLy5dKyg/Ols/I118JCkpKSpcXC8/KT8oW14/I1xcL10qKSkoPzpcXD8oW14jXSopKT8oPzojKC4qKSk/KS87XG5cbnZhciBwYXJ0cyA9IFtcbiAgICAnc291cmNlJywgJ3Byb3RvY29sJywgJ2F1dGhvcml0eScsICd1c2VySW5mbycsICd1c2VyJywgJ3Bhc3N3b3JkJywgJ2hvc3QnXG4gICwgJ3BvcnQnLCAncmVsYXRpdmUnLCAncGF0aCcsICdkaXJlY3RvcnknLCAnZmlsZScsICdxdWVyeScsICdhbmNob3InXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNldXJpKHN0cikge1xuICB2YXIgbSA9IHJlLmV4ZWMoc3RyIHx8ICcnKVxuICAgICwgdXJpID0ge31cbiAgICAsIGkgPSAxNDtcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgdXJpW3BhcnRzW2ldXSA9IG1baV0gfHwgJyc7XG4gIH1cblxuICByZXR1cm4gdXJpO1xufTtcbiIsIi8qZ2xvYmFsIEJsb2IsRmlsZSovXG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50c1xuICovXG5cbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBidWZmZXJzID0gW107XG4gIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cbiAgZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEpIHtcbiAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gICAgaWYgKGlzQnVmKGRhdGEpKSB7XG4gICAgICB2YXIgcGxhY2Vob2xkZXIgPSB7IF9wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aCB9O1xuICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcGFjayA9IHBhY2tldDtcbiAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEpO1xuICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59O1xuXG4vKipcbiAqIFJlY29uc3RydWN0cyBhIGJpbmFyeSBwYWNrZXQgZnJvbSBpdHMgcGxhY2Vob2xkZXIgcGFja2V0IGFuZCBidWZmZXJzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIGV2ZW50IHBhY2tldCB3aXRoIHBsYWNlaG9sZGVyc1xuICogQHBhcmFtIHtBcnJheX0gYnVmZmVycyAtIGJpbmFyeSBidWZmZXJzIHRvIHB1dCBpbiBwbGFjZWhvbGRlciBwb3NpdGlvbnNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjb25zdHJ1Y3RlZCBwYWNrZXRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICB2YXIgY3VyUGxhY2VIb2xkZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhKSB7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciBidWYgPSBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRhdGFbaV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGRhdGFba2V5XSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgcGFja2V0LmRhdGEgPSBfcmVjb25zdHJ1Y3RQYWNrZXQocGFja2V0LmRhdGEpO1xuICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgcmV0dXJuIHBhY2tldDtcbn07XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIF9yZW1vdmVCbG9icyhvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2ldLCBpLCBvYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmogJiYgIWlzQnVmKG9iaikpIHsgLy8gYW5kIG9iamVjdFxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBfcmVtb3ZlQmxvYnMob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIF9yZW1vdmVCbG9icyhibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIganNvbiA9IHJlcXVpcmUoJ2pzb24zJyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xudmFyIGlzQnVmID0gcmVxdWlyZSgnLi9pcy1idWZmZXInKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0JJTkFSWV9BQ0snLFxuICAnRVJST1InXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG4vKipcbiAqIEVuY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuXG4vKipcbiAqIERlY29kZXIgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuXG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChpc0J1ZihvYmopIHx8IG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59O1xuXG4vKipcbiAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZGVjb2RlU3RyaW5nKHN0cikge1xuICB2YXIgcCA9IHt9O1xuICB2YXIgaSA9IDA7XG5cbiAgLy8gbG9vayB1cCB0eXBlXG4gIHAudHlwZSA9IE51bWJlcihzdHIuY2hhckF0KDApKTtcbiAgaWYgKG51bGwgPT0gZXhwb3J0cy50eXBlc1twLnR5cGVdKSByZXR1cm4gZXJyb3IoKTtcblxuICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHAudHlwZSkge1xuICAgIHZhciBidWYgPSAnJztcbiAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9ICctJykge1xuICAgICAgYnVmICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoaSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgaWYgKGJ1ZiAhPSBOdW1iZXIoYnVmKSB8fCBzdHIuY2hhckF0KGkpICE9ICctJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGF0dGFjaG1lbnRzJyk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAubnNwID0gJy8nO1xuICB9XG5cbiAgLy8gbG9vayB1cCBpZFxuICB2YXIgbmV4dCA9IHN0ci5jaGFyQXQoaSArIDEpO1xuICBpZiAoJycgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgPT0gc3RyLmxlbmd0aCkgYnJlYWs7XG4gICAgfVxuICAgIHAuaWQgPSBOdW1iZXIocC5pZCk7XG4gIH1cblxuICAvLyBsb29rIHVwIGpzb24gZGF0YVxuICBpZiAoc3RyLmNoYXJBdCgrK2kpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHAuZGF0YSA9IGpzb24ucGFyc2Uoc3RyLnN1YnN0cihpKSk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgIHJldHVybiBlcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIGRlYnVnKCdkZWNvZGVkICVzIGFzICVqJywgc3RyLCBwKTtcbiAgcmV0dXJuIHA7XG59XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn07XG5cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAqICAgYSByZWNvbnN0cnVjdGVkIHBhY2tldCBvYmplY3QgaWYgYWxsIGJ1ZmZlcnMgaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUudGFrZUJpbmFyeURhdGEgPSBmdW5jdGlvbihiaW5EYXRhKSB7XG4gIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PSB0aGlzLnJlY29uUGFjay5hdHRhY2htZW50cykgeyAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICB2YXIgcGFja2V0ID0gYmluYXJ5LnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgIHRoaXMuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgIHJldHVybiBwYWNrZXQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59O1xuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gaXNCdWY7XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIGJ1ZmZlciBvciBhbiBhcnJheWJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xufVxuIiwiLyohIEpTT04gdjMuMi42IHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTMsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAod2luZG93KSB7XG4gIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gIHZhciBnZXRDbGFzcyA9IHt9LnRvU3RyaW5nLCBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gRGV0ZWN0IG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBuYXRpdmVKU09OID0gdHlwZW9mIEpTT04gPT0gXCJvYmplY3RcIiAmJiBKU09OO1xuXG4gIC8vIFNldCB1cCB0aGUgSlNPTiAzIG5hbWVzcGFjZSwgcHJlZmVycmluZyB0aGUgQ29tbW9uSlMgYGV4cG9ydHNgIG9iamVjdCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIHZhciBKU09OMyA9IHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIGlmIChKU09OMyAmJiBuYXRpdmVKU09OKSB7XG4gICAgLy8gRXhwbGljaXRseSBkZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGluIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBKU09OMy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICBKU09OMy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMsIEphdmFTY3JpcHQgZW5naW5lcywgYW5kIGFzeW5jaHJvbm91cyBtb2R1bGVcbiAgICAvLyBsb2FkZXJzLCB1c2luZyB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgaWYgYXZhaWxhYmxlLlxuICAgIEpTT04zID0gd2luZG93LkpTT04gPSBuYXRpdmVKU09OIHx8IHt9O1xuICB9XG5cbiAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgdHJ5IHtcbiAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgIHZhciBzdHJpbmdpZnkgPSBKU09OMy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICB9XG4gICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgIHZhciBwYXJzZSA9IEpTT04zLnBhcnNlO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIGlmICghaGFzKFwianNvblwiKSkge1xuICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG4gICAgdmFyIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiO1xuICAgIHZhciBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCI7XG4gICAgdmFyIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbiAgICB2YXIgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB2YXIgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICBpZiAoIShpc1Byb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbDogQSBzZXQgb2YgcHJpbWl0aXZlIHR5cGVzIHVzZWQgYnkgYGlzSG9zdFR5cGVgLlxuICAgIHZhciBQcmltaXRpdmVUeXBlcyA9IHtcbiAgICAgICdib29sZWFuJzogMSxcbiAgICAgICdudW1iZXInOiAxLFxuICAgICAgJ3N0cmluZyc6IDEsXG4gICAgICAndW5kZWZpbmVkJzogMVxuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGBwcm9wZXJ0eWAgdmFsdWUgaXMgYVxuICAgIC8vIG5vbi1wcmltaXRpdmUuXG4gICAgdmFyIGlzSG9zdFR5cGUgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnID8gISFvYmplY3RbcHJvcGVydHldIDogIVByaW1pdGl2ZVR5cGVzW3R5cGVdO1xuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBzaXplKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSAnZnVuY3Rpb24nICYmIGlzSG9zdFR5cGUob2JqZWN0LCAnaGFzT3duUHJvcGVydHknKSA/IG9iamVjdC5oYXNPd25Qcm9wZXJ0eSA6IGlzUHJvcGVydHk7XG4gICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIGlzTGFyZ2UgPSBsZW5ndGggPiAxMCAmJiBjaGFySW5kZXhCdWdneSwgc3ltYm9scztcbiAgICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgICBzeW1ib2xzID0gdmFsdWUuc3BsaXQoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGlzTGFyZ2UgPyBzeW1ib2xzW2luZGV4XSA6IGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KGluZGV4KSA6IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgSlNPTjMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBmaWx0ZXIgPT0gXCJvYmplY3RcIiAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgSlNPTjMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSh0aGlzKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIG9iamVjdCA9IHJlcXVpcmUoJy4vJyk7XG5cbnV0aWwuZGVmaW5lKG9iamVjdCxcbiAgLyoqXG4gICAqIFYuT2JqZWN0J3MgZXF1aXZhbGVudCB0byBBcnJheS5wdXNoKClcbiAgICogQG1ldGhvZCBwdXNoXG4gICAqIEBwYXJhbSAge0FyZ3VtZW50c30gIFRoZSBpdGVtKHMpIHRvIGFkZCB0byB0aGUgYXJyYXlcbiAgICogQHJldHVybiB7TnVtYmVyfSAgICAgVGhlIG5ldyBsZW5ndGggb2YgdGhlIGFycmF5XG4gICAqL1xuICAncHVzaCcsIGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3B1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sXG4gICdfcHVzaCcsIGZ1bmN0aW9uKHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tKSB7XG4gICAgLy9hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tXG4gICAgdGhpcy5sZW5ndGgrKztcbiAgICB0aGlzLnNldCgodGhpcy5sZW5ndGggLSAxKSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb20pO1xuICAgIHJldHVybiB0aGlzW3RoaXMubGVuZ3RoIC0gMV07XG4gIH0sXG4gIC8qKlxuICAgKiBWLk9iamVjdCdzIGVxdWl2YWxlbnQgdG8gQXJyYXkucG9wKClcbiAgICogQG1ldGhvZCBwb3BcbiAgICogQHJldHVybiB7Kn0gIFRoZSByZW1vdmVkIGFycmF5IGl0ZW1cbiAgICovXG4gICdwb3AnLCBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fX3QgPT09IDEpIHtcbiAgICAgIHZhciBsID0gdGhpcy5sZW5ndGhcbiAgICAgIGlmKGwgIT09IDApe1xuICAgICAgICB0ID0gdGhpc1tsIC0gMV07XG4gICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgIHQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICAvLyByZXR1cm4gdDsgLy9wcmV0dHkgd2VpcmQgc2luY2UgdGhpcyBvYmplY3QgYWx3YXlzIGhhcyB2YWx1ZSBudWxsO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFYuT2JqZWN0J3MgZXF1aXZhbGVudCB0byBBcnJheS5zcGxpY2UoKVxuICAgKiBAbWV0aG9kIHNwbGljZVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIGluZGV4ICAgQW4gaW50ZWdlciB0aGF0IHNwZWNpZmllcyBhdCB3aGF0IHBvc2l0aW9uIHRvIGFkZC9yZW1vdmUgaXRlbXMsIFVzZSBuZWdhdGl2ZSB2YWx1ZXMgdG8gc3BlY2lmeSB0aGUgcG9zaXRpb24gZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheVxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9ICAgIGhvd21hbnkgVGhlIG51bWJlciBvZiBpdGVtcyB0byBiZSByZW1vdmVkLiBJZiBzZXQgdG8gMCwgbm8gaXRlbXMgd2lsbCBiZSByZW1vdmVkXG4gICAqIEBwYXJhbSAge0FyZ3VtZW50c30gICAgICAgICBUaGUgbmV3IGl0ZW0ocykgdG8gYmUgYWRkZWQgdG8gdGhlIGFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBBIG5ldyBhcnJheSBjb250YWluaW5nIHRoZSByZW1vdmVkIGl0ZW1zLCBpZiBhbnlcbiAgICovXG4gICdzcGxpY2UnLCBmdW5jdGlvbihpbmRleCwgaG93bWFueSkgeyAvL2NhbiBiZWNvbWUgc2hvcnRlcjtcbiAgICBpZiAoaW5kZXggPiAtMSAmJiB0aGlzLl9fdCA9PT0gMSkgeyAvL2hvdyBtYW55IGFuZCAtaSBhcmUgaWdub3JlZFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aCwgc2hpZnQ7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKHNoaWZ0KSB7XG4gICAgICAgICAgaWYgKGkgPT09IGwgLSAxKSB7XG4gICAgICAgICAgICAvLyB0aGlzLmxlbmd0aC0tO1xuICAgICAgICAgICAgdGhpc1tpXSA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSB0aGlzW2kgKyAxXTtcbiAgICAgICAgICAgIHRoaXNbaV0uX25hbWUgPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpID09PSBsIC0gMSkge1xuICAgICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICAgICAgICB0aGlzW2ldLnJlbW92ZSgpO1xuICAgICAgICAgICAgICB0aGlzW2ldID0gdGhpc1tpICsgMV07XG4gICAgICAgICAgICAgIHRoaXNbaV0uX25hbWUgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEFkZHMgdmFsdWUgdG8gYXJyYXkgaWYgaXQgaXMgbm90IGNvbnRhaW5lZCBpbiBhcnJheSwgZXhlY3V0ZXMgaGFuZGxlciBvbiBlbmNvdW50ZXJpbmcgdmFsIGluIGFycmF5XG4gICAqIEBtZXRob2QgaW5jbHVkZVxuICAgKiBAcGFyYW0gIHsqfSAgICAgICAgIHZhbCAgICAgICBWYWx1ZSB0byBhZGRcbiAgICogQHBhcmFtICB7RnVuY3Rpb259ICBbaGFuZGxlcl0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBlbmNvdW50ZXJpbmcgdmFsIGluIGFycmF5XG4gICAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgICAgICAgIFRydWUvZmFsc2VcbiAgICovXG4gICdpbmNsdWRlJywgZnVuY3Rpb24odmFsLCBoYW5kbGVyLCBhcnIpIHtcbiAgICByZXR1cm4gdXRpbC5pbmNsdWRlKHRoaXMsIHZhbCwgaGFuZGxlciwgYXJyKTtcbiAgfSxcbiAgJ2NvbmNhdCcsIGZ1bmN0aW9uKHZhbCkgeyBcblxuICAgIC8vIGlmKCF2YWwpIHtcbiAgICAvLyAgIHJldHVyblxuICAgIC8vIH1cbiAgICBcbiAgICB2YXIgYXJyID0gdGhpc1xuICAgIHZhciBsbCA9IGFyci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWwubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBhcnIuX3B1c2godmFsW2ldLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBhcnIuX3VwZGF0ZSh2YWwpO1xuICAgIHJldHVybiBhcnI7XG4gIH0sXG4gICdtb3ZlSXRlbScsIGZ1bmN0aW9uKGZyb20sIHRvKSB7IHZhciBhcnIgPSB0aGlzXG4gICAgaWYodG8gPT09IHZvaWQgMCkgdG8gPSBhcnIubGVuZ3RoIC0gMVxuICAgIGlmKGZyb20gPT09IHRvKSByZXR1cm5cbiAgICB2YXIgbW92ZXIgPSBhcnJbZnJvbV1cbiAgICBpZighbW92ZXIpIHJldHVyblxuICAgIHZhciBzdGVwID0gZnJvbSA8IHRvID8gMSA6IC0xXG4gICAgZG8ge1xuICAgICAgYXJyW2Zyb21dID0gbnVsbFxuICAgICAgYXJyLnNldChmcm9tLCBhcnJbZnJvbSArIHN0ZXBdLCB0cnVlKVxuICAgICAgZnJvbSArPSBzdGVwXG4gICAgfSB3aGlsZShmcm9tICE9PSB0bylcbiAgICBhcnJbdG9dID0gbnVsbFxuICAgIGFyci5zZXQodG8sIG1vdmVyLCB0cnVlKVxuICB9XG4pXG4iLCJcblxudmFyIFZPYmplY3QgPSByZXF1aXJlKCd2aWdvdXItanMvb2JqZWN0JykuaW5qZWN0KFxuICAgIHJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZS9sZW5ndGgnKVxuICApLFxuICB1dGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwnKSxcbiAgdWlkID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvaWQnKVxuXG52YXIgU0FNRVBBVEggPSAnY291bGQgbm90IGNyZWF0ZSBjb21wb3VuZCBvZiB0d28gT2JqZWN0cyB3aXRoIHRoZSBzYW1lIHBhdGgnXG5cbi8vIGZ1bmN0aW9uIENvbXBvdW5kKHZhbCl7XG4vLyAgIHZhciBjb21wb3VuZCA9IHRoaXNcbi8vICAgY29tcG91bmQuJHNvdXJjZXMgPSBuZXcgU291cmNlTGlzdChjb21wb3VuZCwgdmFsKVxuLy8gICB0aGlzLl9fdCA9IDJcbi8vIH1cblxuLy8gdmFyIERhdGEgPSByZXF1aXJlKCd2aWdvdXItanMvZGF0YScpXG5cbnZhciBDb21wb3VuZCA9IFZPYmplY3QubmV3KHZvaWQgMCwgZnVuY3Rpb24odmFsKXtcbiAgdmFyIGNvbXBvdW5kID0gdGhpc1xuICBjb21wb3VuZC4kc291cmNlcyA9IG5ldyBTb3VyY2VMaXN0KGNvbXBvdW5kLCB2YWwpXG4gIHRoaXMuX190ID0gMlxuICByZXR1cm4gZmFsc2Vcbn0pXG51dGlsLmRlZmluZShDb21wb3VuZCwgJ19jbGFzcycsIFZPYmplY3QpXG5cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb3VuZFxuLy8gQ29tcG91bmQucHJvdG90eXBlID0gbmV3IFZPYmplY3QoKVxuXG5Db21wb3VuZC5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKFxuICAnJHNvdXJjZXMnXG4pXG5cbnV0aWwuZGVmaW5lKCBDb21wb3VuZCxcbiAgJ19hYnNvcmInLCBmdW5jdGlvbiBfYWJzb3JiKGVudHJ5KSB7XG4gICAgdmFyIGNvbXBvdW5kID0gdGhpc1xuICAgIHZhciBzb3VyY2UgPSBlbnRyeS5zb3VyY2VcbiAgICB2YXIgcHJlZml4ID0gZW50cnkubmFtZVxuICAgIFxuICAgIHZhciBlbmRwb2ludCA9IHNvdXJjZVxuICAgIHdoaWxlKGVuZHBvaW50ICYmIGVuZHBvaW50Ll9fdCA9PT0gNCAmJiAhZW5kcG9pbnQuX2ZpbHRlcikge1xuICAgICAgZW5kcG9pbnQgPSBlbmRwb2ludC5fdmFsXG4gICAgfVxuICAgIGVudHJ5LmVuZHBvaW50ID0gZW5kcG9pbnRcbiAgICBcbiAgICBpZihlbmRwb2ludCkge1xuICAgICAgZW5kcG9pbnQuZWFjaChmdW5jdGlvbiBhYnNvcmJFYWNoKCl7XG4gICAgICAgIGNvbXBvdW5kLnNldChwcmVmaXggKyAnLScgK3RoaXMuX25hbWUsIHRoaXMpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGNvbXBvdW5kLmVhY2goZnVuY3Rpb24gY2xlYW5PbGQoKXtcbiAgICAgIHZhciBwb2ludGVyID0gdGhpc1xuICAgICAgdmFyIHBvaW50ZWQgPSBwb2ludGVyLl92YWxcblxuICAgICAgLy8gc2tpcCBjbGVhbnVwIGNoZWNrIG9uIGNvbnN0cnVjdGlvblxuICAgICAgaWYoIWNvbXBvdW5kLiRzb3VyY2VzKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHdheSB0byBjaGVjayBpZiB0aGluZyBpcyBzdGlsbCBpbiBhbiBlbnBvaW50XG4gICAgICAvLyBnZXQgdGhlIGVuZHBvaW50IHRoZSBpdGVtIHNob3VsZCBiZSBpblxuICAgICAgdmFyIHNvdXJjZW5hbWUgPSBwb2ludGVyLl9uYW1lLnNwbGl0KCctJylbMF1cbiAgICAgIHZhciBlcCA9IGNvbXBvdW5kLiRzb3VyY2VzW3NvdXJjZW5hbWVdLmVuZHBvaW50XG4gICAgICB2YXIgb2tcbiAgICAgIGVwLmVhY2goZnVuY3Rpb24gb2tDaGVjaygpe1xuICAgICAgICBpZih0aGlzID09PSBwb2ludGVkKSB7XG4gICAgICAgICAgcmV0dXJuIG9rID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaWYoIW9rKSB7XG4gICAgICAgIHBvaW50ZXIucmVtb3ZlKClcbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICAnX2FkZENvbXBvdW5kTGlzdGVuZXInLCBmdW5jdGlvbiBfYWRkQ29tcG91bmRMaXN0ZW5lcihlbnRyeSkge1xuICAgIHZhciBjb21wb3VuZCA9IHRoaXNcbiAgICBlbnRyeS5zb3VyY2Uub24oZnVuY3Rpb24gY29tcG91bmRMaXN0ZW5lcigpe1xuICAgICAgLy8gY29uc29sZS5sb2coJ2NoYW5nZSBpbiBzb3VyY2UsIHJ1biBhYnNvcmIgb24nLCBlbnRyeSwgXG4gICAgICAvLyAgICdcXG52YWwnLCBhcmd1bWVudHNbMF0sXG4gICAgICAvLyAgICdcXG5zdGFtcCcsIGFyZ3VtZW50c1sxXVxuICAgICAgLy8gKVxuICAgICAgY29tcG91bmQuX2Fic29yYihlbnRyeSlcbiAgICB9KVxuICB9XG4pXG5cbmZ1bmN0aW9uIFNvdXJjZUxpc3QoY29tcG91bmQsIHZhbCkge1xuICB2YXIgc291cmNlbGlzdCA9IHRoaXNcbiAgc291cmNlbGlzdC5fcGFyZW50ID0gY29tcG91bmRcbiAgaWYodmFsKXtcbiAgICBpZighKHZhbCBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgdmFsID0gW3ZhbF1cbiAgICB9XG4gICAgdGhpcy5wdXNoLmFwcGx5KHRoaXMsIHZhbClcbiAgfVxufVxuXG5Tb3VyY2VMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gcHVzaFNvdXJjZSgpe1xuICB2YXIgc291cmNlbGlzdCA9IHRoaXNcbiAgdmFyIGNvbXBvdW5kID0gc291cmNlbGlzdC5fcGFyZW50XG5cbiAgLy8gY29uc29sZS5sb2coJ3B1c2ggZGF0IHNvdXJjZXMnLCBhcmd1bWVudHMubGVuZ3RoKVxuICB2YXIgYWwgPSBhcmd1bWVudHMubGVuZ3RoXG4gIGZvcih2YXIgaSA9IDAsIHNvdXJjZTsgc291cmNlID0gYXJndW1lbnRzW2ldIDsgaSsrKXtcblxuICAgIHZhciBzb3VyY2VuYW1lID0gdWlkKClcblxuICAgIC8vIGNvbnNvbGUubG9nKCdTT1VSQ0VOQU1FIElTJywgc291cmNlbmFtZSlcblxuICAgIHZhciBlbnRyeSA9IHNvdXJjZWxpc3Rbc291cmNlbmFtZV0gPSB7XG4gICAgICBuYW1lOiBzb3VyY2VuYW1lLFxuICAgICAgc291cmNlOiBzb3VyY2VcbiAgICB9XG5cbiAgICBjb21wb3VuZC5fYWJzb3JiKGVudHJ5KVxuICAgIGNvbXBvdW5kLl9hZGRDb21wb3VuZExpc3RlbmVyKGVudHJ5KVxuXG4gIH1cbn1cblxuXG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpXG5cbi8qKlxuICogRmxhZ3MgYXJlIHNwZWNpYWwgcHJvcGVydGllcyB3aGVyZSBhIGZ1bmN0aW9uIGlzIGNhbGxlZFxuICogZGlmZmVyZW50IGZyb20gb3BlcmF0b3JzIHNpbmNlIGZsYWdzIG1heSBoYXZlIG5vdGhpbmcgdG8gZG8gd2l0aCB2YWx1ZSBjYWxjdWxhdGlvblxuICogZXh0ZW5kcyBkZWZhdWx0IHNldCBmcm9tIFYuT2JqZWN0XG4gKiBAcHJvcGVydHlcbiAqL1xuLyoqXG4gKiBBZGRzIG5ldyBmbGFncyB0byBWLk9iamVjdFxuICogQG1ldGhvZCBleHRlbmRcbiAqIEBwYXJhbSAge09iamVjdH0gICBvYmplY3QgVi5PYmplY3QgdG8gZXh0ZW5kIGZsYWdzIHRvXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gW3NldF0gIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKGZ1bmN0aW9uKG9iamVjdCwgc2V0KSB7XG4gIFxuICAvL211bHRpcGxlIGZsYWdzIFxuICBcbiAgLy8gYWJzdHJhY3QgZmxhZ3MgYXJyYXkgYXdheSFcbiAgLy8gXG4gIC8vIGZsYWdzIG9iamVjdCAtLT4gZmllbGRcbiAgLy8gXG4gIC8vIGNoZWNrIC93IGNhc2VzXG4gIC8vIGNoZWNrIC93IHBhcmVudFxuICAvLyBmbGFnNCBpcyBkeW5hbWljIGhhcyBzdGFjayBhcyBvcHRpb25cbiAgXG4gIHZhciBfcHJvdG8gPSBvYmplY3QucHJvdG90eXBlXG4gICAgLCBfY29udmVydCA9IF9wcm90by5jb252ZXJ0XG4gICAgLCBfc2V0ID0gX3Byb3RvLl9zZXRcbiAgICAsIF9yZW1vdmUgPSBfcHJvdG8uX3JlbW92ZVxuICAgICwgX2NoZWNrID0gZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGY7XG4gICAgICBmb3IgKHZhciBpIGluIG9iamVjdC5mbGFncy5keW5hbWljKSB7XG4gICAgICAgIGYgPSBvYmplY3QuZmxhZ3MuZHluYW1pY1tpXShuYW1lKVxuICAgICAgICBpZihmKSBicmVha1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZcbiAgICB9XG4gICAgLCBjaGVja0lmRmxhZ092ZXJ3cml0ZSA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgZm9yKHZhciBpIGluIHZhbCkge1xuICAgICAgICBpZihvYmplY3QuZmxhZ3NbaV0gfHwgX2NoZWNrKGkpKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICBpZiAoIXNldCkgc2V0ID0gX3Byb3RvLnNldFxuXG4gIF9wcm90by5fYmxhY2tsaXN0LnB1c2goJ19mbGFnJyk7XG4gIHV0aWwuZGVmaW5lKG9iamVjdCxcbiAgICAvKipcbiAgICAgKiBbZGVzY3JpcHRpb25dXG4gICAgICogQG1ldGhvZCBjb252ZXJ0XG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB2YWwgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAnY29udmVydCcsIGZ1bmN0aW9uKHZhbCkge1xuXG4gICAgICAvL2hpZXIgb29rIHdlZXIgZm9yXG4gICAgICB2YXIgb2JqID0gX2NvbnZlcnQuY2FsbCh0aGlzLCB2YWwpO1xuXG4gICAgICAvLyBjb25zb2xlLmxvZygnSSBTSE9VTEQgQkUgQ09OVkVSVElORyEnLCB2YWwsIG9iaiwgdGhpcy5fZmxhZylcblxuXG5cblxuXG4gICAgICBpZiAodGhpcy5fZmxhZyAmJiAoIXZhbCB8fCAhdXRpbC5pc09iaih2YWwpIHx8IHZhbC52YWwgfHwgY2hlY2tJZkZsYWdPdmVyd3JpdGUodmFsKSApKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0kgU0hPVUxEIEJFIENPTlZFUlRJTkchIHN0ZXAgMicpXG5cbiAgICAgICAgLy9mZiB1c2VWYWwgZ2VicnVpa2VuXG5cbiAgICAgICAgZm9yKHZhciBpIGluIHRoaXMuX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgZmxhZyA9IHRoaXMuX2ZsYWdbaV1cbiAgICAgICAgICBpZiAoIWZsYWdbNF0gfHwgIWZsYWdbNF0uc3RhY2spIHtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ0NPTlZFUlQgTkVFRFMgRklYJy5yZWQuYm9sZC5pbnZlcnNlKVxuXG4gICAgICAgICAgICBpZiAob2JqID09PSBmbGFnWzFdKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcyIENPTlZFUlQgTkVFRFMgRklYJy5yZWQuYm9sZC5pbnZlcnNlKVxuICAgICAgICAgICAgICBvYmogPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoudmFsID09PSBmbGFnWzFdKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCczIENPTlZFUlQgTkVFRFMgRklYJy5yZWQuYm9sZC5pbnZlcnNlKVxuICAgICAgICAgICAgICBkZWxldGUgb2JqLnZhbDtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBvYmpbZmxhZ1swXV0gPSBmbGFnWzJdXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy9zdGlsbCBoYXZlIHRvIHRha2UgY2FyZSBvZiB0aGlzIHNpdHVhdGlvblxuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcigndHJ5aW5nIGNvbnZlcnQgYSBzdGFjay1keW5hbWljIGZsYWcnLCBmbGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjb25zb2xlLmxvZygnQ09OVkVSVEVEIC0tLS0+JyxvYmopXG5cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcbiAgICAvKipcbiAgICAgIEBwcm9wZXJ0eSBfX2ZsYWdzX19cbiAgICAqL1xuICAgICdfX2ZsYWdzX18nLCB7fSxcbiAgICAvKipcbiAgICAgKiBbZGVzY3JpcHRpb25dXG4gICAgICogQG1ldGhvZCByZW1vdmVcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IGZyb20gICBbZGVzY3JpcHRpb25dXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSB1cGRhdGUgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhbXAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAgICovXG4gICAgJ19yZW1vdmUnLCBmdW5jdGlvbihmcm9tLCB1cGRhdGUsIHN0YW1wKSB7XG5cbiAgICAgIGlmKHRoaXMuX2ZsYWcpIHtcbiAgICAgICAgZm9yKHZhciBpIGluIHRoaXMuX2ZsYWcpIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhpLCB0aGlzLl9mbGFnKVxuICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgIC8vZm9yIFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdfcmVtb3ZlJylcbiAgICAgICAgICBpZiAoZmxhZykge1xuICAgICAgICAgICAgLy9kaXQgbW9ldCB3ZWwgZmYgbHVra2VuXG4gICAgICAgICAgICBpZiAob2JqZWN0LmZsYWdzW2ZsYWdbMF1dKSB7XG4gICAgICAgICAgICAgIG9iamVjdC5mbGFnc1tmbGFnWzBdXS5yZW1vdmUgJiYgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmxhZ1s0XS5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZmxhZyA9IG51bGxcbiAgICAgIH1cblxuICAgICAgX3JlbW92ZS5jYWxsKHRoaXMsIGZyb20sIHVwZGF0ZSwgc3RhbXApO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBtZXRob2QgX3NldFxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gdmFsICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gc3RhbXAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gZnJvbSAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gcmVtb3ZlICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEBwYXJhbSAge1t0eXBlXX0gbm91cGRhdGUgW2Rlc2NyaXB0aW9uXVxuICAgICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICAgICdfc2V0JywgZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBub3VwZGF0ZSkge1xuICAgICAgLy8gY29uc29sZS5sb2coJ21ha2UgX3NldCcsdGhpcy5fbmFtZSx2YWwpO1xuICAgICAgX3NldC5jYWxsKHRoaXMsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgbm91cGRhdGUpXG5cbiAgICAgIC8vZmxhZyBtb2V0IGR1cyBvb2sgbWVlciBlZW4gY29waWVkIHZhbHVlIHdvcmRlblxuXG4gICAgICAvLyBjb25zb2xlLmxvZygnX3NldCcsIHRoaXMuX2ZsYWcsIHZhbClcblxuXG4gICAgICBpZih0aGlzLl9mbGFnKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ292ZXJ3cml0ZT4/LS0tLScsIHRoaXMuX2ZsYWcsIHZhbClcblxuICAgICAgICBmb3IodmFyIGkgaW4gdGhpcy5fZmxhZykge1xuICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgIGlmIChmbGFnKSB7XG4gICAgICAgICAgICB2YXIgc2V0RmwgPSBvYmplY3QuZmxhZ3NbZmxhZ1swXV0gfHwgZmxhZ1s0XVxuICAgICAgICAgICAgLy93aGF0IHRvIGRvIHdpdGggcmVzZXQ/XG4gICAgICAgICAgICAvL2NoYW5nZSBmaXhlbiBiaWogY2FzZXM/XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcyIG92ZXJ3cml0ZT4/LS0tLScsIGZsYWcsIHRoaXMuX3ZhbCwgdGhpcy5fdmFsICE9PSBmbGFnWzFdKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5fdmFsICE9PSBmbGFnWzFdICYmIHNldEZsLnVzZVZhbCkge1xuXG4gICAgICAgICAgICAgIC8vIG51IGZmIGhpZXIgb29rIG5vZyFcblxuICAgICAgICAgICAgICBpZiAob2JqZWN0LmZsYWdzW2ZsYWdbMF1dKSB7XG5cbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIGZsYWcgbm9ybWFsJyxmbGFnLCBmbGFnWzRdLCBpLCB0aGlzKVxuXG4gICAgICAgICAgICAgICAgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dLnJlbW92ZSAmJiBvYmplY3QuZmxhZ3NbZmxhZ1swXV0ucmVtb3ZlLmNhbGwodGhpcywgZmxhZylcbiAgICAgICAgICAgICAgICAvL2lmIHRoaXMgZW1wdHlcbiAgICAgICAgICAgICAgICAvLyBkZWxldGUgdGhpcy5fZmxhZztcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgICAgICAgIGlmKHV0aWwuZW1wdHkodGhpcy5fZmxhZykpIHtcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHRoaXMuX3VwZGF0ZSgpXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZsYWdbNV0pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIGZsYWcgL3cgZmxhZ1s0XSBhbmQgbm90IGZsYWdbNV0nLGZsYWcsIGZsYWdbNF0sIGkpXG4gICAgICAgICAgICAgICAgZmxhZ1s0XS5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgICAgICAvLyBpZih0aGlzLilcbiAgICAgICAgICAgICAgICAvL2RlbGV0ZSB0aGlzLl9mbGFnO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9mbGFnW2ldXG4gICAgICAgICAgICAgICAgaWYodXRpbC5lbXB0eSh0aGlzLl9mbGFnKSkge1xuICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0LmZsYWdzW2ZsYWdbMF1dICYmIG9iamVjdC5mbGFnc1tmbGFnWzBdXS5yZXNldCAmJiBmbGFnWzNdICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1JFU0VUVElORyAtLSBpbmdub3JlIC93IGEgY2xlYXIhJyxmbGFnWzBdKSBcbiAgICAgICAgICAgICAgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dLnNldC5jYWxsKHRoaXMsIGZsYWdbMl0sIHN0YW1wLCB0cnVlLCB0aGlzLl9uYW1lKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBbZGVzY3JpcHRpb25dXG4gICAgICogQG1ldGhvZCBzZXRcbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5hbWUgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHZhbCAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHZvYmogICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YW1wICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vdXBkYXRlIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICAgKi9cbiAgICAnc2V0JywgZnVuY3Rpb24obmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUpIHtcbiAgICAgIHZhciBmbCA9IG9iamVjdC5mbGFnc1tuYW1lXSB8fCBfY2hlY2sobmFtZSlcbiAgICAgICAgLCByXG4gICAgICAgICwgc2FtZVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKG5hbWUsIHZhbCwgdm9iailcblxuICAgICAgaWYgKGZsKSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NldD4/LS0tLScsIG5hbWUsIHZhbCwgdGhpcy5fZmxhZylcbiAgICAgICBcbiAgICAgIGlmKHZhbD09PWZhbHNlKSB7XG4gICAgICAgICAgLy9zdGFjayAtLSBhbGxlIGZsYWdzIG5hbWUgcHJvdmlkZW4hXG4gICAgICAgICAgdmFyIGkgPSBmbC5zdGFja3x8bmFtZSBcbiAgICAgICAgICAgICwgZmxhZyA9IHRoaXMuX2ZsYWcgJiYgdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgIGlmKGZsYWcgJiYgZmwucmVtb3ZlKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGZsLnJlbW92ZS5jYWxsKHRoaXMsIGZsYWcsIG5hbWUpXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVNT1ZFIEZMQUcgRlJPTSBGQUxTRScuaW52ZXJzZSwgZmwsIG5hbWUsIHZhbCwgc3RhbXAsIHRoaXMpXG4gICAgICAgICAgICBpZighZCkge1xuICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgICAgICBpZih1dGlsLmVtcHR5KHRoaXMuX2ZsYWcpKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ZsYWcgaXMgZW1wdHksIGRlbGV0ZScpXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gXG4gICAgICAgICAgciA9IHRydWVcbiAgICAgICAgICAvLyBpZih0aGlzLl9mbGFnKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICBpZih0aGlzLl9mbGFnKSB7XG4gICAgICAgICAgLy9jaGVjayBpZiBuZWVkIHRvIHJlbW92ZSEgLS0gb25seSBpbiBjYXNlXG4gICAgICAgICAgZm9yKHZhciBpIGluIHRoaXMuX2ZsYWcpIHtcbiAgICAgICAgICAgIHZhciBmbGFnID0gdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgICAgaWYgKGZsYWcgJiYgZmwucmVtb3ZlKSB7XG5cbiAgICAgICAgICAgICAgaWYoIWZsLnN0YWNrICYmIG5hbWUgPT09IGZsYWdbMF0pIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tPicsZmxhZ1swXSlcbiAgICAgICAgICAgICAgICBpZih2YWwhPT1mbGFnWzJdKSB7XG4gICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlIGZsYWchIC0tLT4gb3ZlcndyaXRlIGJ5bXlzZWxmIC0tLT4nLCBmbGFnWzBdLCAgc2V0RmwsICdieTonICxuYW1lLCBmbCwgdmFsLCBmbGFnWzJdKVxuICAgICAgICAgICAgICAgICAgZmwucmVtb3ZlLmNhbGwodGhpcywgZmxhZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHNhbWUgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWZsLnN0YWNrIHx8IGZsLnN0YWNrICE9PSBmbGFnWzBdKSB7XG5cbiAgICAgICAgICAgICAgICAvL3RoaXMuX2ZsYWdcblxuICAgICAgICAgICAgICAgIC8vaWYgdmFsOnRydWUgXG4gICAgICAgICAgICAgICAgLy9nbyBjaGVjayBpZiB5b3UgbmVlZCB0byByZW1vdmUgbW9mb3NcblxuICAgICAgICAgICAgICAgIHZhciBzZXRGbCA9IG9iamVjdC5mbGFnc1tmbGFnWzBdXSB8fCBmbGFnWzRdXG5cbiAgICAgICAgICAgICAgICBpZihzZXRGbC51c2VWYWwgJiYgZmwudXNlVmFsKSB7XG5cbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgZmxhZyEgLS0gY2xlYXJseSBoYXMgc29tZSB1c2VWYWwnLCBmbGFnWzBdLCAgc2V0RmwsICdieTonICxuYW1lLCBmbClcblxuICAgICAgICAgICAgICAgICAgc2V0RmwucmVtb3ZlLmNhbGwodGhpcywgZmxhZyk7XG4gICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmxhZ1tpXVxuICAgICAgICAgICAgICAgICAgaWYodXRpbC5lbXB0eSh0aGlzLl9mbGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnZmxhZyBpcyBlbXB0eSwgZGVsZXRlJylcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZsYWdcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZW1vdmUgZmxhZyEnLCBmbGFnLCBmbGFnWzBdLCBmbGFnWzRdLCAgb2JqZWN0LmZsYWdzW2ZsYWdbMF1dICAsIGZsLCBuYW1lKSAvL2NoZWNrIGlmIGl0IG5lZWRzIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICAgICAgICAvLyB2YXIgZmwgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9mbCA9IG9iamVjdC5mbGFnc1tuYW1lXSB8fCBfY2hlY2sobmFtZSlcbiAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIC8vaGllciBpZXRzIG1lZSBkb2VuIHdlZXIgem9la2VuIG5hYXIgZmxhZyBzZXRcblxuXG4gICAgICAgICAgICAgICAgLy9kbyB0aGUgc3BlY2lhbCBjaGVjayBpZiB2YWx1ZSBpcyB0aWdodCB0byBmbGFnIGNoZWNrIChmb3IgYm90aCEgZmwudmFsdWUpXG5cbiAgICAgICAgICAgICAgICAvLyBmbC5yZW1vdmUuY2FsbCh0aGlzLCBmbGFnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBpZighc2FtZSkge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTRVQgRkxBRycuaW52ZXJzZSwgbmFtZSwgdmFsLCBzdGFtcCwgdGhpcylcbiAgICAgICAgICBmbC5zZXQuY2FsbCh0aGlzLCB2YWwsIHN0YW1wLCBmYWxzZSwgbmFtZSk7XG4gICAgICAgICAgciA9IHRydWUgLy9uaWV0IGFsdGlqZCB3YWFyIG9mY291cnNlIVxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLS0nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdGTEFHIElTIFNBTUUnLnJlZC5pbnZlcnNlLCBuYW1lLCB2YWwsIHN0YW1wLCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAgIHRoaXNbbmFtZV0gJiYgdGhpc1tuYW1lXS5yZW1vdmUoZmFsc2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHIgPSBzZXQuY2FsbCh0aGlzLCBuYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9KTtcbiAgb2JqZWN0LmZsYWdzID0gX3Byb3RvLl9fZmxhZ3NfXztcbiAgdXRpbC5kZWZpbmUob2JqZWN0LmZsYWdzLCAnZHluYW1pYycsIHt9KTtcbn0pIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCBoYXNoID0gcmVxdWlyZSgnLi4vdXRpbC9oYXNoJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZChmdW5jdGlvbihiYXNlKSB7XG4gIGJhc2UucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX19ocCcpXG4gIHV0aWwuZGVmaW5lKCBiYXNlXG4gICwgJ19oYXNocGF0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9faHAgfHwgKHRoaXMuX19ocCA9IGhhc2godGhpcy5fcGF0aC50b1N0cmluZygpKSlcbiAgICAgIH1cbiAgICB9XG4gIClcbn0pIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCB2aWdvdXIgPSByZXF1aXJlKCcuLi8nKVxuICAsIGluamVjdCA9IHJlcXVpcmUoJy4uL3V0aWwvaW5qZWN0Jylcbi8qKlxuICogVi5PYmplY3RzIGFyZSB1c2VkIGluc3RlYWQgb2Ygbm9ybWFsIG9iamVjdHMgaW4gdmlnb3VyIGxpc3RlbmVycyBhcmUgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcmVtb3ZlZFxuICogdHlwZTogX190IDogMSA9IGFycmF5ICwgMiA9IG9iamVjdCAsIDMgPSBoYXMgZmllbGQgKGNhbiBuZXZlciBiZSBhbiBhcnJheSkgLCA0ID0gZmllbGQgcmVmIHRvIG90aGVyIFYuT2JqZWN0XG4gKiBub3RlIHlvdSBjYW4gbWFrZSBhbiBvYmplY3Qgb3V0IG9mIGEgZmllbGQgb3IgZmllbGQgcmVmIHRoZSB0eXBlIHdpbGwgYmUgMyBvciA0IHRob3VnaCFcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtICB7Kn0gICAgICBbdmFsXSAgICBWYWx1ZVxuICogQHBhcmFtICB7T2JqZWN0fSBbcGFyZW50XSBQYXJlbnRvYmplY3RcbiAqL1xudmFyIG9iamVjdCA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHZpZ291ci5PYmplY3QgPSBmdW5jdGlvbih2YWwsIGhvb2ssIHBhcmVudCkge1xuICBpZiAocGFyZW50KSB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgaWYgKGhvb2sgJiYgdGhpcy5faG9vaykgdGhpcy5faG9vayh2YWwsIGhvb2spXG4gIGlmICh2YWwgIT09IHZvaWQgMCkgdGhpcy52YWwgPSB2YWxcbn1cbm9iamVjdC5pbmplY3QgPSBpbmplY3Rcbi8qKlxuICogVXNlZCB0byBzZXQgLnZhbFxuICogQG1ldGhvZCBfc2V0XG4gKiBAcGFyYW0gIHsqfSAgICAgICAgICAgICAgdmFsICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgIFtzdGFtcCA9IG5ldyBzdGFtcF0gIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge09iamVjdHxCb29sZWFufSBbZnJvbV0gICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgW25vdXBkYXRlXSAgICAgICAgICAgV2hlbiB0cnVlLCBubyB1cGRhdGVzXG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgICAgW2FkZF0gICAgICAgICAgICAgICAgV2hlbiB0cnVlLCB0aGlzIGlzIGFuIGFkZFxuICovXG52YXIgX3NldCA9IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIG5vdXBkYXRlLCBhZGQpIHtcblxuICBpZih2YWw9PT1udWxsKSB7XG4gICAgaWYgKCFzdGFtcCkgc3RhbXAgPSB0aGlzLnN0YW1wKClcbiAgICB0aGlzLnJlbW92ZShmYWxzZSwgZmFsc2UsIGZhbHNlLCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpXG4gIH1cblxuICBpZiAoIXRoaXMuX190IHx8IHRoaXMuX190IDwgMyB8fCAoIHZhbCAhPT0gdGhpcy5fdmFsIHx8IHRoaXMuX2lnbm9yZVZhbHVlICkgKSB7XG5cbiAgICAvLyBjb25zb2xlLmVycm9yKHRoaXMpXG4gICAgaWYoIXRoaXMuc3RhbXApIHtcbiAgICAgIC8vbW9ldCBhbGxlbWFhbCBldmVudCBlbWl0dGVycyB3b3JkZW4gKG9uKCdlcnJvcicpKVxuICAgICAgLy90aGlzLl91cGRhdGUoJ2Vycm9yJykgZW4gYW5kZXJzIFYuZGVidWcuZXJyb3IuX3VwZGF0ZSggJ29iamVjdCcgKVxuICAgICAgY29uc29sZS5lcnJvciggJ0VSUk9SIGluIHZpZ291ci1qcy9vYmplY3QsICBPQkpFQ1Qgbm8gLnN0YW1wJywgdGhpcyApXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoIXN0YW1wKSBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuXG4gICAgdmFyIG9sZHZhbCA9IHRoaXMuX3ZhbFxuICAgICAgLCBuZXN0ZWR2YWxcbiAgICAgICwgbm9zZXRcbiAgICAgICwgaXNTZXRcbiAgICAgICwgaXNBcnJheVxuICAgICAgLCB2YWxJc1NldFxuXG4gICAgaWYgKHRoaXMuX2NoYW5nZXZvYmogXG4gICAgICAmJiAoKHRoaXMuX190IDwgNCAmJiB2YWwgaW5zdGFuY2VvZiBvYmplY3QpIFxuICAgICAgfHwgdGhpcy5fX3QgPT09IDQgJiYgKCghdGhpcy5fbWl4ZWR8fHRoaXMuX21peGVkPT09NCkgfHwgdmFsIGluc3RhbmNlb2YgQXJyYXkgXG4gICAgICAgIHx8ICh2YWwgaW5zdGFuY2VvZiBPYmplY3QgXG4gICAgICAgICAgJiYgKHZhbCBpbnN0YW5jZW9mIG9iamVjdCB8fCB2YWwudmFsKSkpKSkgeyAvL3RyeSB0byBtYWtlIHRoaXMgc2hvcnRlclxuICAgICAgICAgdGhpcy5fY2hhbmdldm9iaih2YWwsIHN0YW1wKVxuICAgICAgICAgaWYodGhpcy5fbWl4ZWQ9PT00KSB0aGlzLl92YWwgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHZpZ291ci5CYXNlICYmICh2YWwgaW5zdGFuY2VvZiB2aWdvdXIuQmFzZSkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSwgc3RhbXApXG4gICAgICB0aGlzLl9fdCA9IDVcbiAgICAgIHRoaXMuX3ZhbCA9IHZhbFxuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2Ygb2JqZWN0KSB7XG4gICAgICBpZiAoKHRoaXMuX190IDwgMyAmJiAhdGhpcy5fbWl4ZWQpIHx8IHRoaXMuX190ID09PSAxKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKHRydWUsIHRydWUsIGZhbHNlLCB2b2lkIDAsIHN0YW1wKSAvL2NoZWNrIGlmIDJuZCBwYXJhbSB0cnVlIGlzIGFic29sdXRlbHkgbmVzc2VjYXJ5IChlbHNlIGl0IHdpbGwgYmUgcmVtb3ZlZClcbiAgICAgIH1cbiAgICAgIHRoaXMuX3ZhbCA9IHZhbFxuICAgICAgdGhpcy5fX3QgPSA0XG4gICAgICBpZiAodGhpcy5fc2V0dm9iaikgdGhpcy5fc2V0dm9iaih2YWwpXG4gICAgfSBlbHNlIHtcblxuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCAmJiB0eXBlb2YgdmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgIHRoaXMuX3ZhbCA9IHZvaWQgMFxuICAgICAgICAgIHRoaXMuX190ID0gMVxuICAgICAgICAgIHRoaXMubGVuZ3RoID0gdmFsLmxlbmd0aFxuICAgICAgICAgIG5vc2V0ID0gdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgdmFsLCBmYWxzZSwgc3RhbXApXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNldChpLCB2YWxbaV0sIGZhbHNlLCBzdGFtcCwgbm91cGRhdGUsIHRydWUpICYmIG5vc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICBub3NldCA9IHRydWVcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5vc2V0ID0gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAvL25vcm1hbCBvYmplY3RcblxuICAgICAgICAgIGlmICh2YWwuY2xlYXIpIHtcbiAgICAgICAgICAgIG5vc2V0ID0gdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBzdGFtcClcbiAgICAgICAgICAgIGRlbGV0ZSB2YWwuY2xlYXJcbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fX3QgPT09IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX21peGVkICE9PSAxICYmIHRoaXMuX21peGVkIT09NCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRydWUsIHRydWUsIGZhbHNlLCBmYWxzZSwgc3RhbXApIC8vb21taXRpbmcgc3RhbXAgY2FuIGJlIGEgcHJvYmxlbVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzQXJyYXkgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX21lcmdlICYmICghdGhpcy5fbWl4ZWQgfHwgdGhpcy5fX3QgPT09IDIpKSB7XG4gICAgICAgICAgICAgIG5vc2V0ID0gdGhpcy5yZW1vdmUodHJ1ZSwgdHJ1ZSwgdmFsLCBmYWxzZSwgc3RhbXApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWwudmFsICYmIHV0aWwuaXNPYmoodmFsLnZhbCkpIHtcbiAgICAgICAgICAgIHZhbElzU2V0ID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy5fJHNldFZhbCggbmV3IHRoaXMuX2NsYXNzKHZhbC52YWwsIGZhbHNlLCB0aGlzKSwgc3RhbXAsIGZyb20sIHRydWUpXG4gICAgICAgICAgICB0aGlzLl92YWwuX2NvbnRhaW5lZCA9IHRydWVcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9taXhlZCkge1xuICAgICAgICAgICAgdGhpcy5fdmFsID0gdm9pZCAwIC8vdGhpcyBtZXNzZXMgdXAgcHJvcGVydHkgdXBkYXRlcyEhICh5b3VyaSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWlzQXJyYXkpIHRoaXMuX190ID0gMlxuXG4gICAgICAgICAgZm9yICh2YXIgaiBpbiB2YWwpIHtcbiAgICAgICAgICAgIGlmICghdXRpbC5jaGVja0FycmF5KHRoaXMuX2JsYWNrbGlzdCwgaikpIHtcbiAgICAgICAgICAgICAgaWYgKGogPT09ICd2YWwnKSB7XG4gICAgICAgICAgICAgICAgaWYoIXZhbElzU2V0KSBpc1NldCA9IHRoaXMuXyRzZXRWYWwoIHZhbC52YWwsIHN0YW1wLCBmcm9tLCB0cnVlIClcbiAgICAgICAgICAgICAgICBuZXN0ZWR2YWwgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vZG8gbm90IGFsd2F5cyBpZ25vcmUgdXBkYXRlcyBhdCB0aGlzIHBvaW50XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNldChqLCB2YWxbal0sIGZhbHNlLCBzdGFtcCwgbm91cGRhdGUsIHRydWUpICYmIG5vc2V0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgbm9zZXQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5vc2V0ID0gZmFsc2UgLy90aGlzIGlzIHRoZSBwbGFjZSB3aGVyZSBzZXQgaXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICgodGhpcy5fX3QgPCAzICYmICF0aGlzLl9taXhlZCkgfHwgdGhpcy5fX3QgPT09IDEpIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZSh0cnVlLCB0cnVlLCBmYWxzZSwgZmFsc2UsIHN0YW1wKVxuICAgICAgICAgIGlmICh0aGlzLl9fdCA9PT0gMSkgZGVsZXRlIHRoaXMubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gdGhpcy5fdmFsICYmICF0aGlzLl9pZ25vcmVWYWx1ZSApIHtcbiAgICAgICAgICAvL21heWJlIHVzZSBzdGFtcCBmb3IgaWdub3JlVmFsdWUgYXMgd2VsbD9cbiAgICAgICAgICBpZiAobm9zZXQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aGlzLl9fdCA9IDNcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl92YWwgPSB2YWxcbiAgICAgICAgICB0aGlzLl9fdCA9IDNcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVzdGVkdmFsKSB7XG5cbiAgICAgIGlmICh0aGlzLl9zZXQgJiYgKGlzU2V0ICE9PSBmYWxzZSB8fCBub3NldCA9PT0gZmFsc2UpKSB7XG4gICAgICAgIHRoaXMuX3NldCh2YWwsIHN0YW1wLCBmcm9tLCBmYWxzZSwgbm91cGRhdGUsIGFkZCwgb2xkdmFsKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc2V0KSB7XG4gICAgICBpZiAoIW5vc2V0KSB7XG4gICAgICAgIHRoaXMuX3NldCh2YWwsIHN0YW1wLCBmcm9tLCBmYWxzZSwgbm91cGRhdGUsIGFkZCwgb2xkdmFsKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYod2luZG93LnNtdXQpIGNvbnNvbGUubG9nKCchMScsYXJndW1lbnRzKVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZih3aW5kb3cuc211dCkgY29uc29sZS5sb2coJyExJyxhcmd1bWVudHMpXG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxufSxcbi8qKlxuICogc3RhbXBcbiAqIHBhaW50IHRoZSBzZXQgb3JpZ2luXG4gKiBAbWV0aG9kXG4gKi9cbl9zdGFtcCA9IDAsXG5fcGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zLCBsaXN0KSB7XG4gIGZvciAodmFyIGkgPSBsaXN0Lmxlbmd0aCAtIDEsIHA7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKHBhcmFtcyAmJiBwYXJhbXNbbGlzdFtpXV0hPT12b2lkIDApIHtcbiAgICAgIHAgPSAnXycgKyBsaXN0W2ldXG4gICAgICB1dGlsLmRlZmluZSh0aGlzLCBwLCBwYXJhbXNbbGlzdFtpXV0pXG4gICAgfVxuICB9XG59XG4vKipcbiogR2VuZXJhdGVzIHVuaXF1ZSBzdGFtcFxuKiBAbWV0aG9kIHN0YW1wXG4qIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyBzdGFtcFxuKi9cbmV4cG9ydHMuc3RhbXAgPSBmdW5jdGlvbigpIHtcbi8vaWYgc3RhbXAgPiB4IHJlc2V0ID9cbnJldHVybiBfc3RhbXArK1xufVxuXG5leHBvcnRzLnNldCA9IF9zZXRcblxuLy8gb2JqZWN0VXRpbHMuZXh0ZW5kKGV4cG9ydHMpOyAgXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgY29uc3RydWN0b3IgYmFzZWQgb24gYSBWLk9iamVjdFxuICogUGFyYW1zIGNhbiBiZSBwYXNzZWRcbiAqIE1peGVkIGNyZWF0ZXMgbWl4ZWQgdHlwZXMgZm9yIHRoZSBuZXcgY2xhc3MgaS5lIGhhdmluZyBhIHN0cmluZyBhbmQgcHJvcGVydGllc1xuICogQG1ldGhvZCBuZXdcbiAqIEBwYXJhbSAge09iamVjdH0gcGFyYW1zIFBhcmFtZXRlcnNvYmplY3RcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIFJldHVybnMgVi5PYmplY3RcbiAqL1xuLy8gd2luZG93LmNudCA9IDBcbi8vIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4vLyAgIHdpbmRvdy5zbXV0ID0gdHJ1ZVxuLy8gfSwyMDAwKVxuXG5vYmplY3QubmV3ID0gZnVuY3Rpb24ocGFyYW1zLCBjb25zdHJ1Y3Rvcikge1xuICB2YXIgdk9iaiA9IGZ1bmN0aW9uKHZhbCwgaG9vaywgcGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50KSB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgICAgIHZhciBjb25yZXN1bHRcbiAgICAgIGlmIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBjb25yZXN1bHQgPSBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLGFyZ3VtZW50cylcbiAgICAgIH1cbiAgICAgIGlmIChob29rICYmIHRoaXMuX2hvb2spIHRoaXMuX2hvb2sodmFsLCBob29rKVxuICAgICAgaWYgKHRoaXMuX29uQ29uc3RydWN0KSB0aGlzLl9vbkNvbnN0cnVjdCh2YWwsIGhvb2spXG5cbiAgICAgIGlmKHZhbCAhPT0gdm9pZCAwICYmIGNvbnJlc3VsdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy52YWwgPSB2YWxcbiAgICAgIH1cbiAgICB9LFxuICAgIHByb3RvID0gdk9iai5wcm90b3R5cGUgPSBuZXcgdGhpcygpXG4gIHZPYmoubmV3ID0gb2JqZWN0Lm5ld1xuICB2T2JqLmluamVjdCA9IGluamVjdCAvL25vdCBoYW5kZWxlZCB3ZWxsIHlldFxuICB1dGlsLmRlZmluZSh2T2JqLCAnX2JsYWNrbGlzdCcsIHByb3RvLl9ibGFja2xpc3QuY29uY2F0KCkpXG4gIF9wYXJhbXMuY2FsbCh2T2JqLCBwYXJhbXMsIFsnbWl4ZWQnLCAnbWVyZ2UnXSlcbiAgdXRpbC5kZWZpbmUodk9iaiwgJ19jbGFzcycsIHZPYmopXG4gIHJldHVybiB2T2JqXG59XG5cbnV0aWwuZGVmaW5lKG9iamVjdCxcblxuLy8gJ19zZXQsIHNldCAsICdcblxuICdfJHNldFZhbCcsIF9zZXQsXG5cbi8qKlxuICogSXRlbXMgaW4gdGhlIGJsYWNrbGlzdCBza2lwcGVkIGluIGVhY2ggZnVuY3Rpb25cbiAqIEBtZXRob2QgX2JsYWNrbGlzdFxuICovXG4nX2JsYWNrbGlzdCcsIFsnXycsICdfXycsICdfX3QnLCAnX3ZhbCcsICdsZW5ndGgnLCAnX25hbWUnLCAnX3BhcmVudCcsICdfY29udGFpbmVkJywgJ19yZW1vdmVkJywnZXh0ZW5zaW9ucycsICdfX2NhY2hlZFBhdGgnLCAnX2lnbm9yZVZhbHVlJywgJ19pbmRleENhY2hlJ10sXG4vKipcbiAqIFJlcGxhY2VzIGRlZmF1bHQgY29uc3RydWN0b3IgcHJvcGVydHkgLG5lY2Vzc2FyeSBmb3IgY2xhc3NlcyBtYWRlIHdpdGggVi5PYmplY3QubmV3XG4gKiBAY29uc3RydWN0b3IgX2NsYXNzXG4gKi9cbidfY2xhc3MnLCBvYmplY3QsXG4vKipcbiAqIFN0YW1wIGlzIGEgbWV0aG9kIG9mIFZPYmplY3Qgc28gdGhhdCBpdCBjYW4gYmUgZXh0ZW5kZWQgaW4gc3ViY2xhc3Nlc1xuICogQHJldHVybiB7Kn0gYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYSBtdXRhdGlvblxuICovXG4nc3RhbXAnLCBvYmplY3Quc3RhbXAsXG4vKipcbiAqIFVzZWQgdG8gZ2V0IC52YWwgd2hpY2ggcmV0dXJucyBmaWVsZCB2YWx1ZXMgaS5lLiBhIHN0cmluZ1xuICogQG1ldGhvZCBfZ2V0XG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHZhbHVlXG4gKi9cbidfZ2V0JywgZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IHNlbGYuX190XG4gICAgLCB2YWxcblxuICBpZiAodHlwZSA8IDMpIHtcbiAgICByZXR1cm4gc2VsZlxuICB9IGVsc2Uge1xuICAgIHZhbCA9IHNlbGYuX3ZhbFxuICAgIHJldHVybiAodHlwZSAhPT0gNCkgPyB2YWwgOiB2YWwgJiYgdmFsLl9nZXQoKVxuICB9XG59LFxuLyoqXG4gKiBVc2VkIHRvIGdldCAudmFsIHdoaWNoIHJldHVybnMgZmllbGQgdmFsdWVzIGkuZS4gYSBzdHJpbmdcbiAqIFNldCBjcmVhdGVzIGluc3RhbmNlcyBvZiB0aGUgX2NsYXNzIGZvciBuZXN0ZWQgcHJvcGVydGllc1xuICogQHByb3BlcnR5XG4gKi9cbid2YWwnLCB7XG4gIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgLy8gd2luZG93LmNudCsrXG4gICAgLy8gaWYod2luZG93LnNtdXQpIHtcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3Iod2luZG93LmNudCwgJ3doYXRzIGhhcHBlbmluZycsIHRoaXMuX3BhdGgsIHRoaXMuX3Byb3AgJiYgdGhpcy5fcHJvcC5uYW1lLCB0aGlzLCB0aGlzLl91cGRhdGVPcmlnaW4pXG4gICAgLy8gfVxuICAgIHJldHVybiB0aGlzLl8kc2V0VmFsKHZhbClcbiAgfSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0KClcbiAgfVxufSxcbi8qKlxuICogQWRkIGEgcHJvcGVydHkgdG8gYSBvYmplY3RcbiAqIEBtZXRob2Qgc2V0XG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBuYW1lICAgICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAgeyp9ICAgICAgIHZhbCAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7Qm9vbGVhbn0gW3ZvYmpdICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICBbc3RhbXAgPSBuZXcgc3RhbXBdIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge0Jvb2xlYW59IFtub3VwZGF0ZV0gICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbidzZXQnLCBmdW5jdGlvbiggbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb20gKSB7XG5cbiAgLy9mdW5jdGlvbiggbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb20gKSBcblxuICAvLyBjb25zb2xlLmxvZyhuYW1lLCBzdGFtcClcblxuICBmcm9tID0gZnJvbSAmJiB0aGlzXG4gIGlmICghdm9iaiAmJiAodGhpc1tuYW1lXSBpbnN0YW5jZW9mIG9iamVjdCkpIHtcbiAgICBpZiAodGhpcy5fJHNldFZhbC5jYWxsKHRoaXNbbmFtZV0sIHZhbCwgc3RhbXAsIGZyb20sIG5vdXBkYXRlKSA9PT0gZmFsc2UgJiYgc3RhbXApIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodm9iaikge1xuICAgICAgaWYodGhpc1tuYW1lXSkgdGhpc1tuYW1lXS5yZW1vdmUoKVxuICAgICAgdGhpc1tuYW1lXSA9IHZhbFxuICAgICAgdGhpc1tuYW1lXS5fbmFtZSA9IG5hbWVcbiAgICAgIHRoaXNbbmFtZV0uX3BhcmVudCA9IHRoaXNcbiAgICAgIGlmKCFub3VwZGF0ZSkgdmFsLl91cGRhdGUodmFsLCBzdGFtcCB8fCB0aGlzLnN0YW1wKCksIGZyb20sIHZvaWQgMCwgdHJ1ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tuYW1lXSA9IG5ldyB0aGlzLl9jbGFzcyh2b2lkIDAsIGZhbHNlLCB0aGlzKVxuICAgICAgdGhpc1tuYW1lXS5fbmFtZSA9IG5hbWVcbiAgICAgIHRoaXMuXyRzZXRWYWwuY2FsbCh0aGlzW25hbWVdLCB2YWwsIHN0YW1wLCBmcm9tLCBub3VwZGF0ZSwgdHJ1ZSlcbiAgICB9XG4gICAgaWYgKHRoaXMuX190ID09PSAxICYmIHRoaXMuX3NldEFycmF5SXRlbSkge1xuICAgICAgdGhpcy5fc2V0QXJyYXlJdGVtKCB0aGlzW25hbWVdLCB2YWwgKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufSxcbi8qKlxuICogUmVtb3ZlcyBhIFYuT2JqZWN0IGluY2x1ZGluZyBhbGwgbmVzdGVkIGZpZWxkcyBhbmQgdmFsdWVzXG4gKiBAbWV0aG9kIHJlbW92ZVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIFtuZXN0ZWRdICAgICAgICAgICAgIFdoZW4gdHJ1ZSByZW1vdmUgbmVzdGVkIG9iamVjdHNcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBbYmxdICAgICAgICAgICAgICAgICBXaGVuIHRydWUgZG9lc24ndCByZW1vdmUgYmxhY2tsaXN0ZWQgaXRlbXNcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBbbm90XSAgICAgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcGFyYW0gIHtCb29sZWFufE9iamVjdH0gW2Zyb21dICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICogQHBhcmFtICB7TnVtYmVyfSAgICAgICAgIFtzdGFtcCA9IG5ldyBzdGFtcF0gIFtkZXNjcmlwdGlvbl1cbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgICBbbm91cGRhdGVdICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG4gLy8gICAgdGhpcy5yZW1vdmUoZmFsc2UsIGZhbHNlLCBmYWxzZSwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKVxuXG4ncmVtb3ZlJywgZnVuY3Rpb24obmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpIHsgLy9ubyB1cGRhdGUgZmlyc3QgPiAoZXh0ZW5kZWQgaW4gc2VsZWN0aW9uLmpzKVxuICBpZiAoIW5lc3RlZCkgdGhpcy5fcmVtb3ZlZCA9IHRydWVcbiAgdmFyIHIsIGksIG9sZHZhbFxuICBpZiAoIXN0YW1wKSBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuICAvLyBjb25zb2xlLmxvZygnU1RBUlQnLHN0YW1wLHRoaXMuX25hbWUpO1xuICBpZiAoIW5lc3RlZCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnQpIHtcbiAgICAgIHRoaXMuX3BhcmVudFt0aGlzLl9uYW1lXSA9IG51bGxcbiAgICAgIGRlbGV0ZSB0aGlzLl9wYXJlbnRbdGhpcy5fbmFtZV1cbiAgICB9XG4gICAgaWYgKHRoaXMuX3ZhbCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodGhpcy5fdmFsIGluc3RhbmNlb2Ygb2JqZWN0ICYmIHRoaXMuX3ZhbC5fY29udGFpbmVkKSB7XG4gICAgICAgIHRoaXMuX3ZhbC5yZW1vdmUoZmFsc2UsIGZhbHNlLCBmYWxzZSwgZnJvbSB8fCB0aGlzLCBzdGFtcCwgbm91cGRhdGUpXG4gICAgICB9XG4gICAgICBvbGR2YWwgPSB0aGlzLl92YWxcbiAgICAgIHRoaXMuX3ZhbCA9IG51bGxcbiAgICB9XG4gIH1cbiAgZm9yIChpIGluIHRoaXMpIHtcbiAgICBpZiAoKCFub3QgfHwgIW5vdFtpXSkgJiYgIXV0aWwuY2hlY2tBcnJheSh0aGlzLl9ibGFja2xpc3QsIGkpKSB7XG4gICAgICBpZiAodGhpc1tpXSBpbnN0YW5jZW9mIG9iamVjdCkge1xuICAgICAgICByID0gZmFsc2VcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ0RFTEVURScsc3RhbXAsaSx0aGlzW2ldKTtcbiAgICAgICAgdGhpc1tpXS5yZW1vdmUoZmFsc2UsIGZhbHNlLCBmYWxzZSwgZnJvbSB8fCB0aGlzLCBzdGFtcCwgbm91cGRhdGUpXG4gICAgICB9XG4gICAgICB0aGlzW2ldID0gbnVsbFxuICAgICAgZGVsZXRlIHRoaXNbaV0gLy9kZWxldGUgaXMgcHJldHR5IG5hc3R5IGZvciBwZXJmb3JtYW5jZVxuICAgIH1cbiAgfVxuICBpZiAoIW5lc3RlZCkge1xuICAgIGlmICh0aGlzLl9yZW1vdmUpIHtcbiAgICAgIC8vclxuICAgICAgdGhpcy5fcmVtb3ZlKGZyb20sIG5vdXBkYXRlID8gZmFsc2UgOiBmcm9tIC8qfHxyKi8gLCBzdGFtcCwgb2xkdmFsKTtcbiAgICAgIGlmICghYmwpIHtcbiAgICAgICAgZm9yICh2YXIgaiBpbiB0aGlzKSB7XG4gICAgICAgICAgaWYgKHRoaXNbal0gIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKGogIT09ICdfcGFyZW50JyAmJiB0aGlzW2pdIGluc3RhbmNlb2Ygb2JqZWN0ICYmIHRoaXNbal0uX2NvbnRhaW5lZCkge1xuICAgICAgICAgICAgICB0aGlzW2pdLnJlbW92ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzW2pdID0gbnVsbFxuICAgICAgICAgICAgZGVsZXRlIHRoaXNbal1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fcmVtb3ZlZCA9IHRydWVcbiAgfVxuICByZXR1cm4gclxufSlcblxuXG4vLy0tLS10aGlzIGhhcyB0byBiZSBpbml0aWFsaXplZCBhZnRlciBkZWZpbmluZyB0aGUgYmxhY2tsaXN0IHByb3BlcnR5O1xuZXhwb3J0cy5saXN0ZW4gPSByZXF1aXJlKCcuL2xpc3RlbicpXG5yZXF1aXJlKCcuL2FycmF5JylcbnJlcXVpcmUoJy4vdXRpbCcpIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJylcbiAgLCB2T2JqZWN0ID0gcmVxdWlyZSgnLi8nKVxuICAsIFYgPSByZXF1aXJlKCcuLi8nKVxuICAvL1RPRE86IHRoaXMgaXMgYSB0ZW1wIGZpeCB0byBlbXVsYXRlIG9uIG5leHQgdGlja1xuICAsIHJhZiA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2FuaW1hdGlvbi9yYWYnKVxuICAsIFByb21pc2UgPSByZXF1aXJlKCdwcm9taXNlJylcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKCBvYmosIGZuLCBtYXJrLCBvcmlnaW5hbCApIHtcbiAgLy92YWwsIG1hcmssIHNraXBjaGVjaywgaWdub3JldmFsLCBvcmdpbmFsXG4gIGlmKCBtYXJrICkgXG4gIHtcbiAgICAvLyBjb25zb2xlLmxvZygnaGV5IGdvdCBvcmdpbmFsIScsIG9yaWdpbmFsKVxuICAgIC8vbiggdmFsLCBtYXJrLCBza2lwY2hlY2ssIGlnbm9yZXZhbCwgb3JpZ2luYWwgKVxuICAgIG9iai5hZGRMaXN0ZW5lcihbIGZuLCBtYXJrIF0sIHRydWUsIGZhbHNlLCBmYWxzZSwgb3JpZ2luYWwgIClcbiAgfSBcbiAgZWxzZSBcbiAge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnaGV5IGdvdCBvcmdpbmFsIScsIG9yaWdpbmFsKVxuXG4gICAgb2JqLmFkZExpc3RlbmVyKCBmbiwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgb3JpZ2luYWwgKVxuICB9XG59XG5cbi8qXG4gIF91cGRhdGUgY2FsbHMgbGlzdGVuZXJzIG9uIGEgZ2l2ZW4gT2JqZWN0IChsaXN0ZW5lcnMgaW5jbHVkZSBsaW5raW5nIGZpZWxkcyBpbiBvdGhlciBWLk9iamVjdHMpXG4gIFYuT2JqZWN0Ll91cGRhdGUgY2FuIGJlIG1vZGlmaWVkIHRvIGNoYW5nZSB1cGRhdGUgYmVoYXZpb3I6XG4gICAgLSBzdGFuZGFyZDogdXBkYXRlIE9iamVjdCBhbmQgaXQncyBwYXJlbnRzIC8gYW5jZXN0b3JzIHJlY3Vyc2l2ZWx5LlxuICAgIC0gcGFyZW50T25seTogdXBkYXRlIE9iamVjdCBhbmQgb25seSBpdHMgZGlyZWN0IHBhcmVudC5cbiAgICAtIGp1c3QgX3VwZGF0ZTogdXBkYXRlIG9ubHkgdGhlIE9iamVjdC5cbiovXG52YXIgX3VwZGF0ZSA9IGV4cG9ydHMuX3VwZGF0ZSA9IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdGVzdCkge1xuXG4gIC8vIGlmKHdpbmRvdy5oZXJlKSBjb25zb2xlLmxvZygnVVBEQVRFIScsdGhpcy5fcGF0aClcblxuICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICAsIGlcbiAgICAsIGxpc3RlbmVyXG5cbiAgaWYgKF9sKSB7XG4gICAgZm9yIChpID0gX2wubGVuZ3RoOyBsaXN0ZW5lciA9IF9sWy0taV07KSB7IC8vb3JkZXIgaXMgaXJyZWxldmFudFxuICAgICAgaWYgKGxpc3RlbmVyIGluc3RhbmNlb2Ygdk9iamVjdCkge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCd1cGRhdGU/Pz8/PycsIGxpc3RlbmVyLl9wYXRoLCB0aGlzLl9wYXRoLCBmcm9tKVxuXG4gICAgICAgIC8vIGlmIChmcm9tKSB7XG4gICAgICAgIGxpc3RlbmVyLl9sZnJvbSA9IGZyb20gfHwgdGhpc1xuICAgICAgICAgIC8vIH1cblxuICAgICAgICBsaXN0ZW5lci5fdXBkYXRlKHZhbCwgc3RhbXAsIGZhbHNlLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpXG5cbiAgICAgICAgaWYgKGxpc3RlbmVyKSBsaXN0ZW5lci5fbGZyb20gPSBudWxsXG5cbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJbMF0pIHtcbiAgICAgICAgaWYoIXRlc3QgfHwgIXRlc3QobGlzdGVuZXIpKSB7XG4gICAgICAgICAgaWYgKGxpc3RlbmVyLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGwgPSBsaXN0ZW5lci5sZW5ndGggLSAyXG4gICAgICAgICAgICAgICwgbDIgPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICAgICwgYSA9IFtdLCBqID0gLTFcbiAgICAgICAgICAgICAgLCBsYSA9IGwgKyBsMlxuICAgICAgICAgICAgICA7IGogPCBsYVxuICAgICAgICAgICAgICA7IGFbKytqXSA9IGogPCBsXG4gICAgICAgICAgICAgICAgPyBsaXN0ZW5lcltqICsgMl1cbiAgICAgICAgICAgICAgICA6IGogPT09IGwgPyB0aGlzIDogYXJndW1lbnRzW2ogLSBsIC0gMV1cbiAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgbGlzdGVuZXJbMF0uYXBwbHkobGlzdGVuZXJbMV0sIGEpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVyWzBdLmNhbGwobGlzdGVuZXJbMV0sIHRoaXMsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cbi8vIHV0aWwuZGVmaW5lKHZPYmplY3QsIFxuLy8gICAnX25vZGVQYXRoXycsIGZ1bmN0aW9uKCkge1xuLy8gICAgIGlmKHRoaXMuX2NhbGxlcikge1xuXG4vLyAgICAgICB2YXIgYXJyID0gW11cbi8vICAgICAgIHZhciBwID0gdGhpcy5fY2FsbGVyXG5cbi8vICAgICAgIHdoaWxlKHApIHtcbi8vICAgICAgICAgYXJyLnB1c2goIHAuX25hbWUgfHwgcC5fbm9kZSAmJiBwLl9ub2RlLmNsYXNzTmFtZSApXG4vLyAgICAgICAgIHAgPSBwLl9ub2RlICYmIHAucGFyZW50XG4vLyAgICAgICB9XG4vLyAgICAgICBhcnIucmV2ZXJzZSgpXG4vLyAgICAgICByZXR1cm4gYXJyXG5cblxuLy8gICAgIH1cbi8vICAgfVxuXG4vLyApXG5cblxudk9iamVjdC5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfbGlzdGVuZXJzJywgJ19saXN0ZW5zJywgJ19sZnJvbScsICdfbGlzdGVuTWFwJyk7XG5cbnV0aWwuZGVmaW5lKHZPYmplY3QsXG4gIC8qKlxuICAgKiBfc2V0XG4gICAqIGlzIGNhbGxlZCB3aGVuIGEgdmFsdWUgaXMgc2V0XG4gICAqIEBtZXRob2RcbiAgICovXG4gICdfc2V0JywgZnVuY3Rpb24odmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBub3VwZGF0ZSwgYWRkZWQsIG9sZHZhbCkge1xuICAgIGlmICghbm91cGRhdGUpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuX3BhdGgsIHZhbClcbiAgICAgIHRoaXMuX3VwZGF0ZSh2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwpO1xuICAgIH1cbiAgfSxcblxuICAnaXMnLCBmdW5jdGlvbiAodmFsLCBjYiwgbmV4dFRpY2sgKSB7XG5cbiAgICAvL29uIHJlbW92YWwgb2YgcHJvbWlzZSByZW1vdmUgbGlzdGVuZXJcblxuICAgIGlmKCFjYiB8fCAoIHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgIG5leHRUaWNrID0gY2JcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ215IG1vZm8nLCBuZXh0VGljaylcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiggcmVzb2x2ZSwgcmVqZWN0ICkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnMzEyMTIzMTIzMjEzJywgdmFsKVxuICAgICAgICBfdGhpcy5pcyggdmFsLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXNvbHZlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbiAgICAgICAgfSwgbmV4dFRpY2spXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb25zb2xlLmVycm9yKCdsZXp6Z28nKVxuICAgICAgdmFyIGNieCA9IG5leHRUaWNrID8gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgICAgICAgICwgX3RoaXMgPSB0aGlzXG4gICAgICAgIHJhZihmdW5jdGlvbigpIHtcbiAgICAgICAgICBjYi5jYWxsKF90aGlzKVxuICAgICAgICB9KVxuICAgICAgfSA6IGNiXG4gICAgICAvL1RPRE86IGFkZCBvcmlnaW5hbCBpZiBpdHMgbm90IFxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJy0tLS0tLS0tLS0tLS0tJywgdmFsKVxuXG4gICAgICBpZih2YWw9PT0nbG9hZGVkJykge1xuICAgICAgICBpZih0aGlzLiRsb2FkZWQgfHwgdGhpcy5mcm9tLiRsb2FkZWQpIHtcbiAgICAgICAgICBjYnguY2FsbCh0aGlzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub25jZSgnbG9hZGVkJywgY2J4KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmV0XG4gICAgICAgIC8vIHZhciBpZ25vcmVcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignMSFAI0AjISFAIycsIHJldCwgdmFsKVxuXG4gICAgICAgIGlmKHRoaXMudmFsID09IHZhbCApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCcyIUAjQCMhIUAjJywgcmV0LCB2YWwpXG5cbiAgICAgICAgICByZXR1cm4gY2J4LmNhbGwodGhpcylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCchQCN4eHh4eDEyMTIxMjEyMTIyMTEyQCMhIUAjJywgcmV0LCB2YWwpXG5cbiAgICAgICAgICByZXQgPSAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykgJiYgdmFsLmNhbGwodGhpcylcbiAgICAgICAgICAvLyBpZ25vcmUgPSB0cnVlXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignMjIyMjIyMjIyMiFAI0AjISFAIycsIHJldCwgdmFsKVxuICAgICAgICB9XG4gICAgICAgIGlmKHJldCkge1xuICAgICAgICAgIGlmKCByZXQgaW5zdGFuY2VvZiBQcm9taXNlICkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5lcnJvcigncHJvbWlzZScpXG4gICAgICAgICAgICByZXR1cm4gcmV0XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/ISEhJylcbiAgICAgICAgICAgIHJldHVybiBjYnguY2FsbCh0aGlzKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCcyMjIyMiFAIUAjIUAjJywgdmFsKVxuICAgICAgICAgIGlmKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMub25jZSh2YWwsIGNieClcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uY2Uoe1xuICAgICAgICAgICAgICAkdmFsOiB2YWxcbiAgICAgICAgICAgIH0sIGNieClcbiAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBfX3VwZGF0ZVxuICAgKiBjYWxscyBsaXN0ZW5lcnMgYXR0YWNoZWQgdG8gdGhlIE9iamVjdFxuICAgKiB0eXBlcyAtLSBmdW5jdGlvbiBvciBWLk9iamVjdFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX191cGRhdGUnLCBfdXBkYXRlLFxuICAvKipcbiAgICogX3VwZGF0ZVxuICAgKiBlc2NhbGF0ZXMgYW4gdXBkYXRlIHVwIGl0J3Mgc3RydWN0dXJlIGFuZCBjYWxscyBfX3VwZGF0ZSB0byBjYWxsIGxpc3RlbmVyc1xuICAgKiB0eXBlcyAtLSBmdW5jdGlvbiBvciBWLk9iamVjdFxuICAgKiBAbWV0aG9kXG4gICAqL1xuICAnX3VwZGF0ZScsIGZ1bmN0aW9uKHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgdGVzdCkgeyAvL2hlcmUgeW91IGNhbiBzZWUgaWYgaXRzIGFuIHVwZGF0ZSBmcm9tIGFub3RoZXIgb2JqZWN0IChmcm9tKVxuICAgIC8vIGNvbnNvbGUubG9nKCdWLk9iamVjdCBPRyBfdXBkYXRlJywgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKVxuICAgIHZhciBjdXJyID0gdGhpcyxcbiAgICBzID0gdHJ1ZVxuXG4gICAgd2hpbGUgKGN1cnIpIHtcbiAgICAgIC8vIHZhciBwID0gY3Vyci5fcGF0aFxuICAgICAgLy8gX3VwZGF0ZSBbXCJjbGllbnRzXCIsIFwiVl8ycHhjZXd2M2c0a1wiXSBcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdfdXBkYXRlJywgcCwgdmFsLCBmcm9tIHx8ICgoIXMgJiYgdGhpcykgPyB0aGlzIDogdm9pZCAwLCB0aGlzKSApXG5cbiAgICAgIC8vVE9ETyAxMCBkb3VibGUgY2hlY2sgdGhpc1xuICAgICAgY3Vyci5fX3VwZGF0ZSh2YWwsIHN0YW1wLCBmcm9tIHx8IChzIT09dHJ1ZSkgPyB0aGlzIDogZmFsc2UgLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIHRlc3QpXG4gICAgICBjdXJyID0gZnJvbSA/IGZhbHNlIDogY3Vyci5fcGFyZW50XG4gICAgICBzID0gZmFsc2VcbiAgICAgIGlmIChyZW1vdmUpIHJlbW92ZSA9IDFcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBfcmVtb3ZlXG4gICAqIGNhbGxlZCBvbiByZW1vdmVcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ19yZW1vdmUnLCBmdW5jdGlvbihmcm9tLCB1cGRhdGUsIHN0YW1wLCBvbGR2YWwpIHtcbiAgICBpZiAodXBkYXRlICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5fdXBkYXRlKG51bGwsIHN0YW1wLCBmcm9tLCB0cnVlLCBmYWxzZSwgb2xkdmFsKTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigpO1xuICAgIHZhciBfbCA9IHRoaXMuX2xpc3RlbnMsXG4gICAgICBpLCBsaXN0ZW5lcjtcbiAgICBpZiAoX2wpIHtcbiAgICAgIC8vb3B0aW1pemUgbGF0ZXJcbiAgICAgIC8vdGhpcyx0aGlzIGlzIHdlaXJkIHRvIGFsd2F5cyB1c2UgdGhpcy4uLlxuICAgICAgZm9yIChpID0gX2wubGVuZ3RoIC0gMTsgaSA+PSAwOyBfbFtpLS1dLnJlbW92ZUxpc3RlbmVyKHRoaXMsIHZvaWQgMCwgZmFsc2UsIHRydWUpKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBfc2V0dm9ialxuICAgKiBpZiBhIHZhbHVlIGlzIHNldCB0byBhIFYuT2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICovXG4gICdfc2V0dm9iaicsIGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhbC5hZGRMaXN0ZW5lcih0aGlzKTtcbiAgfSxcbiAgLyoqXG4gICAqIF9jaGFuZ2V2b2JqXG4gICAqIGlmIGEgdmFsdWUgaXMgY2hhbmdlZCBmcm9tIGEgVi5PYmplY3RcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ19jaGFuZ2V2b2JqJywgZnVuY3Rpb24odmFsKSB7XG4gICAgaWYgKHRoaXMuX190ID09PSA0KSB7XG4gICAgICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5zLFxuICAgICAgICBfdmFsID0gdGhpcy5fdmFsLFxuICAgICAgICBpO1xuICAgICAgaWYgKF9sKSB7XG4gICAgICAgIGZvciAoaSA9IF9sLmxlbmd0aDsgaSA+PSAwOyBfbFstLWldICYmIF9sW2ldLnJlbW92ZUxpc3RlbmVyKHRoaXMsIHRoaXMpKTtcbiAgICAgIH1cbiAgICAgIGlmIChfdmFsIGluc3RhbmNlb2Ygdk9iamVjdCAmJiBfdmFsLl9jb250YWluZWQpIHtcbiAgICAgICAgX3ZhbC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBhZGRMaXN0ZW5lclxuICAgKiBhZGRzIGEgbGlzdGVuZXIgdG8gYW4gb2JqZWN0IGNhbiBiZSBhIGZ1bmN0aW9uIG9yIFYuT2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICovXG4gICdhZGRMaXN0ZW5lcicsIGZ1bmN0aW9uKCB2YWwsIG1hcmssIHNraXBjaGVjaywgaWdub3JldmFsLCBvcmlnaW5hbCApIHtcbiAgICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5lcnMgfHwgKHRoaXMuX2xpc3RlbmVycyA9IFtdKSxcbiAgICAgIHRhcmdldCwgZztcblxuICAgIGlmKG9yaWdpbmFsKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnT1JHSU5BTCEnLCBvcmlnaW5hbClcbiAgICAgIGlmKCF0aGlzLl9saXN0ZW5NYXApIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuTWFwID0gW11cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL21vcmUgc3BlZWQgdm9vciBjaGVja2FycmF5XG4gICAgaWYgKG1hcmspIHtcbiAgICAgIGcgPSB1dGlsLmNoZWNrQXJyYXkoX2wsIHZhbFsxXSwgMSk7XG4gICAgICBpZiAoZyA9PT0gZmFsc2VcbiAgICAgICAgfHwgIWlnbm9yZXZhbCAmJiB1dGlsLmNoZWNrQXJyYXkoX2wsIHZhbFswXSwgMCkgPT09IGZhbHNlXG4gICAgICAgIHx8IChtYXJrICE9PSB0cnVlICYmIG1hcmsuY2FsbCh0aGlzLCBfbFtnXSwgX2wsIGcsIHZhbCkgPT09IHRydWUpKSB7XG4gICAgICAgIFxuICAgICAgICAvL1RPRE86IGZpeCB0aGlzIHVsdHJhIGRpcnR5IHN0dWZmXG4gICAgICAgIGlmKCBvcmlnaW5hbCAmJiB2YWwgIT09IG9yZ2luYWwgKSB7XG4gICAgICAgICAgdGhpcy5fbGlzdGVuTWFwLnB1c2goWyBvcmdpbmFsLCB2YWwgXSlcbiAgICAgICAgfVxuXG4gICAgICAgIF9sLnB1c2godmFsKTtcbiAgICAgIH0gZWxzZSAge1xuICAgICAgICAgcmV0dXJuIF9sW2ddO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXZhbC5fX3QgfHwgIXV0aWwuY2hlY2tBcnJheShfbCwgdmFsKSkge1xuXG4gICAgICBpZiggb3JpZ2luYWwgJiYgdmFsICE9PSBvcmlnaW5hbCApIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuTWFwLnB1c2goWyBvcmlnaW5hbCwgdmFsIF0pXG4gICAgICB9XG5cbiAgICAgIF9sLnB1c2godmFsKTtcbiAgICB9XG4gICAgaWYgKG1hcmsgfHwgdmFsIGluc3RhbmNlb2Ygdk9iamVjdCkge1xuICAgICAgdGFyZ2V0ID0gbWFyayA/IHZhbFsxXSA6IHZhbDtcbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiB2T2JqZWN0KSB7XG4gICAgICAgIF9saSA9IHRhcmdldC5fbGlzdGVucyB8fCAodGFyZ2V0Ll9saXN0ZW5zID0gW10pO1xuICAgICAgICBpZiAoc2tpcGNoZWNrIHx8ICF1dGlsLmNoZWNrQXJyYXkoX2xpLCB0aGlzKSkge1xuXG4gICAgICAgICAgaWYoIG9yaWdpbmFsICYmIHZhbCAhPT0gb3JpZ2luYWwgKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5NYXAucHVzaChbIG9yaWdpbmFsLCB2YWwgXSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfbGkucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgICdvbmNlJywgZnVuY3Rpb24oIHZhbCwgbWV0aG9kLCBtYXJrICkge1xuXG4gICAgLy92YWwsIG1hcmssIHNraXBjaGVjaywgaWdub3JldmFsLCBvcmdpbmFsXG5cbiAgICAvL1RPRE86dW5pZnkgL3cgb25cbiAgICB2YXIgbXZhbFxuXG4gICAgdmFyIGxpc3RlbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCBtdmFsLCBtYXJrIClcbiAgICAgIC8vIHRoaXMucmVtb3ZlTGlzdGVuZXIoIGxpc3RlbiApXG5cbiAgICAgIG12YWwuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAvL29yaWdpbmFsIHBlcmhhcHM/Pz8/XG4gICAgfVxuXG4gICAgaWYoIG1ldGhvZCApIHtcbiAgICAgIG12YWwgPSBtZXRob2RcbiAgICAgIHRoaXMub24oIHZhbCwgbGlzdGVuLCBmYWxzZSwgbXZhbCApIC8vZGV6ZSBmbiBtb2V0IHdlbCBnZXJlbW92ZWQgd29yZGVuIGdlYmV1cmQgbnUgbmlldCFcbiAgICB9IGVsc2Uge1xuICAgICAgbXZhbCA9IHZhbFxuICAgICAgdGhpcy5vbiggbGlzdGVuLCBmYWxzZSwgZmFsc2UsIG12YWwgKVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzXG5cbiAgfSxcbiAgJ29uJywgZnVuY3Rpb24oIHZhbCwgbWV0aG9kLCBtYXJrLCBvcmlnaW5hbCApIHtcbiAgICAgIC8qKlxuICAgICAgICAqIHZhbCBjYW4gYmUgYSBjb25kaXRpb24gb3IgYSBjb21wYXJpc29uIG9yIGEgbWV0aG9kXG4gICAgICAqKi9cbiAgICAgIGlmKCBWLkJhc2UgJiYgbWV0aG9kIGluc3RhbmNlb2YgVi5CYXNlICkgXG4gICAgICB7XG4gICAgICAgIG1hcmsgPSBtZXRob2QgLy9tYWtlIGV4Y2VwdGlvbiBmb3IgdmFsdWVzIVxuICAgICAgICBtZXRob2QgPSBudWxsXG4gICAgICB9XG5cbiAgICAgIGlmKCFvcmlnaW5hbCkge1xuICAgICAgICBvcmlnaW5hbCA9IG1ldGhvZFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3NldCBvcmlnaW5hbCEnLCBvcmlnaW5hbCwgbWV0aG9kIClcbiAgICAgIH1cblxuICAgICAgaWYoICFtZXRob2QgKSBcbiAgICAgIHtcbiAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCB2YWwsIG1hcmssIG9yaWdpbmFsIClcbiAgICAgIH1cbiAgICAgIGVsc2UgXG4gICAgICB7XG4gICAgICAgIGlmKCB1dGlsLmlzT2JqKCB2YWwgKSApXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBjb25zb2xlLndhcm4oJ3RoaXMgd2lsbCBiZWNvbWUgYSBjb25kaXRpb24gbGF0ZXIgb24gZm9yIG5vdyBpdHMgbm90IHN1cHBvcnRlZCEsIGNvbmRpdGlvbnMgd2lsbCBiZSB1c2VkIGV2ZXlyd2hlcmUnKVxuICAgICAgICAgIC8vSGFzIHRvIGJlY29tZSBhIGNvbmRpdGlvblxuICAgICAgICAgIGlmKHZhbC4kdmFsKSB7XG4gICAgICAgICAgICBfYWRkTGlzdGVuZXIoIHRoaXMsIGZ1bmN0aW9uKCBudmFsICkge1xuICAgICAgICAgICAgICBpZiggdGhpcy52YWwgPT09IHZhbC4kdmFsICkgLy9tb3JlIGNoZWNrc1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndGhpcyB3aWxsIGJlY29tZSBhIGNvbmRpdGlvbiBsYXRlciBvbiBmb3Igbm93IGl0cyBub3Qgc3VwcG9ydGVkISwgY29uZGl0aW9ucyB3aWxsIGJlIHVzZWQgZXZleXJ3aGVyZScpXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vSGFzIHRvIGJlY29tZSBhIGNvbmRpdGlvblxuXG5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKCB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIClcbiAgICAgICAge1xuICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwgKSB7XG4gICAgICAgICAgICBpZiggdmFsLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFxuICAgICAgICB7XG5cbiAgICAgICAgICBpZiggdXRpbC5pc09iaiggbWV0aG9kICkgKVxuICAgICAgICAgIHtcblxuICAgICAgICAgICAgbWFyayA9IHZhbFxuXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VudGVzdGVkIC0tIGFkZCBhcyBtYXJrJylcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKSB7XG4gICAgICAgICAgICAgIGlmKCByZW1vdmUgKSAvL21vcmUgY2hlY2tzXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIG1hcmssIG9yaWdpbmFsIClcblxuXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYoIHZhbCA9PT0gJ3JlbW92ZScgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vdmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbFxuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApIHtcbiAgICAgICAgICAgICAgaWYoIHJlbW92ZSApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgICAvL1RPRE86IGluIHJlZG8gdGhpcyB3aWxsIGJlIGRvbmUgZGlmZmVyZW50bHkgKGV2ZW50IHR5cGVzIGFyZSBzcGVjaWFsIGRvbmUpXG4gICAgICAgICAgZWxzZSBpZiggdmFsID09PSAnbG9hZGVkJyApIHtcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBhZGRlZCApIC8vd2Vya3QgbmlldCE7XG4gICAgICAgICAgICAgIC8vX19mcm9tbWV0aG9kXG5cbiAgICAgICAgICAgICAgaWYoIHRoaXMuJGxvYWRlZCB8fCB0aGlzLmZyb20uJGxvYWRlZCApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCB2YWwgPT09ICdhZGRlZCcgKVxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF9hZGRMaXN0ZW5lciggdGhpcywgZnVuY3Rpb24oIG52YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwgKSB7XG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCBhZGRlZCApIC8vd2Vya3QgbmlldCE7XG4gICAgICAgICAgICAgIGlmKCBhZGRlZCApIC8vbW9yZSBjaGVja3NcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmKCB2YWwgPT09ICdzZWxmJyApXG4gICAgICAgICAge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCApIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coIGFkZGVkICkgLy93ZXJrdCBuaWV0ITtcblxuICAgICAgICAgICAgICAvL1RPRE86IHB1dCBvbiBpbiBhIGRpZmZlcmVudCBmaWxlXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdTSE9VTEQgRE8gU0VMRiEnLCBhcmd1bWVudHMsIGZyb20gKSAvL3pvIHdyb25nIVxuXG4gICAgICAgICAgICAgIGlmKCB0aGlzLl92YWwgPT09IG52YWwgXG4gICAgICAgICAgICAgIHx8ICF2YWwgJiYgdGhpcy5fdXBkYXRlT3JpZ2luPT09dGhpcyAvL3ByZXR0eSBzbG93IGNoZWNrICwgaXRzIHRoZXJlIHRvIGNoZWNrIHdoZW4gc29tZW9uZSBjYWxsIC51cGRhdGUgZm9yIGV4YW1wbGVcbiAgICAgICAgICAgICAgKSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbWFyaywgb3JpZ2luYWwgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAge1xuICAgICAgICAgICAgX2FkZExpc3RlbmVyKCB0aGlzLCBmdW5jdGlvbiggbnZhbCApIHtcbiAgICAgICAgICAgICAgaWYoIG52YWwgPT09IHZhbCB8fCB0aGlzLnZhbCA9PT0gdmFsIHx8IHRoaXMuX3ZhbCA9PT0gdmFsICkgLy9tb3JlIGNoZWNrc1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBtYXJrLCBvcmlnaW5hbCApXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgLyoqXG4gICAqIHJlbW92ZUxpc3RlbmVyXG4gICAqIGlmIG5vIHZhbCByZW1vdmVzIGFsbCBsaXN0ZW5lcnNcbiAgICogbWFyayBjaGVja3MgaW4gYXJyYXkgb24gcG9zaXRpb24gMSBmb3IgdW5pcXVlbmVzc1xuICAgKiByZW1vdmUgaXMgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIG1hcmtcbiAgICogQG1ldGhvZFxuICAgKi9cbiAgJ3JlbW92ZUxpc3RlbmVyJywgZnVuY3Rpb24odmFsLCBtYXJrLCByZW1vdmUsIG5vYnJlYWspIHtcbiAgICAvLyBjb25zb2xlLmxvZygncmVtb3ZlTGlzdGVuZXIhJywgdGhpcy5fcGF0aCwgdGhpcy5fbGlzdGVuZXJzICYmIHRoaXMuX2xpc3RlbmVycy5sZW5ndGhcbiAgICAvLyAgICwgJ1xcbm1hcms6XFxuJywgbWFyayAmJiBtYXJrLnJhd1xuICAgIC8vICAgLCAnXFxudmFsOlxcbicsIHZhbCAmJiB2YWwubmFtZVxuICAgIC8vICAgLCAnXFxudmFsOlxcbicsIHZhbFxuICAgIC8vIClcbiAgICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5lcnMsXG4gICAgICBpO1xuICAgIGlmIChfbCkge1xuICAgICAgZm9yIChpID0gX2wubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgLy9tYXliZSBjaGVja2luZyBtYXJrIGFsbCB0aGUgdGltZSBpcyB0b28gc2xvdz9cbiAgICAgICAgdmFyIGxpc3RlbmVyID0gX2xbaV1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICghbWFyayAmJiAhdmFsKVxuICAgICAgICAgIHx8ICh2YWwgJiYgbGlzdGVuZXIgPT09IHZhbCkgLy9mYWxzZSB2b29yIG1hcmtcbiAgICAgICAgICB8fCAobWFyayE9PWZhbHNlICYmICgobGlzdGVuZXIgaW5zdGFuY2VvZiBBcnJheSkgJiYgKChtYXJrICYmIGxpc3RlbmVyWzFdID09PSBtYXJrICYmICghdmFsfHxsaXN0ZW5lclswXT09PXZhbCkpIHx8IHZhbCAmJiBsaXN0ZW5lclsxXSA9PT0gdmFsKSlcbiAgICAgICAgICAgICYmICghcmVtb3ZlXG4gICAgICAgICAgICAgIHx8IChyZW1vdmUgPT09IHRydWUgIC8vZGl0IG1vZXQgbGF0ZXIgd2VnIGlzIGRhbiBhbGxlZW4gZWVuIGZ1bmN0aWUgaXMgbnUgb3ZlcmJvZGlnIChjaGVjayBib3ZlbilcbiAgICAgICAgICAgICAgICA/IGxpc3RlbmVyWzBdID09PSB2YWxcbiAgICAgICAgICAgICAgICA6IHJlbW92ZS5jYWxsKHRoaXMsIGxpc3RlbmVyLCBtYXJrKSkpKVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnbWFyay5fbGlzdGVucz8nLCAhIShtYXJrICYmIG1hcmsuX2xpc3RlbnMpXG4gICAgICAgICAgLy8gICAgICwgJ1xcbmlzIHZPYmplY3Q/JywgbGlzdGVuZXIgaW5zdGFuY2VvZiB2T2JqZWN0XG4gICAgICAgICAgLy8gICAgICwgJ1xcbmlzIG1hcmtlZD8nLCBsaXN0ZW5lciBpbnN0YW5jZW9mIEFycmF5XG4gICAgICAgICAgLy8gICApXG4gICAgICAgICAgdmFyIGZvY3VzID0gbWFya1xuICAgICAgICAgICAgPyBtYXJrXG4gICAgICAgICAgICA6IGxpc3RlbmVyIGluc3RhbmNlb2Ygdk9iamVjdFxuICAgICAgICAgICAgICA/IGxpc3RlbmVyXG4gICAgICAgICAgICAgIDogbGlzdGVuZXIgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgID8gbGlzdGVuZXJbMV1cbiAgICAgICAgICAgICAgICA6IGZhbHNlXG4gICAgICAgICAgdmFyIGxpc3RlbnMgPSBmb2N1cyAmJiBmb2N1cy5fbGlzdGVuc1xuICAgICAgICAgIGlmKGxpc3RlbnMpe1xuICAgICAgICAgICAgZm9yKHZhciBqID0gbGlzdGVucy5sZW5ndGgtMSA7IGogPj0gMCA7IGotLSl7XG4gICAgICAgICAgICAgIGlmKGxpc3RlbnNbal0gPT09IHRoaXMpe1xuICAgICAgICAgICAgICAgIGxpc3RlbnMuc3BsaWNlKGosIDEpXG4gICAgICAgICAgICAgICAgaWYobGlzdGVucy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICBmb2N1cy5fbGlzdGVucyA9IG51bGxcbiAgICAgICAgICAgICAgICBpZihmb2N1cy5fX3QgPT09IDQgJiYgbGlzdGVuZXIuX3ZhbCA9PT0gdGhpcylcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLl92YWwgPSB2b2lkIDBcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIF9sLnNwbGljZShpLCAxKVxuICAgICAgICAgIGlmIChfbC5sZW5ndGggPT09IDApIHRoaXMuX2xpc3RlbmVycyA9IG51bGw7XG4gICAgICAgICAgaWYgKHZhbCAmJiAhbm9icmVhaykgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvL1RPRE86IHRoaXMgaGFzIHRvIGJlIHJlZmFjdG9yZWQgQVNBUCEgZG8gd2hlbiBuZXcgZGVzaWduIHBoYXNlIGZvciB2b2JqZWN0K2Jhc2UgaXMgZ29pbmcgZG93blxuICAgICAgaWYoIHRoaXMuX2xpc3Rlbk1hcCAmJiB2YWwgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdpbSBoZXJlIScsIHZhbClcbiAgICAgICAgdmFyIHBpdlxuICAgICAgICBmb3IodmFyIGkgPSAwLCBfbGVuID0gdGhpcy5fbGlzdGVuTWFwLmxlbmd0aDsgaSA8IF9sZW47IGkrKyApIHtcbiAgICAgICAgICBpZiggdGhpcy5fbGlzdGVuTWFwW2ldWzBdID09PSB2YWwgKSB7XG4gICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2hleSBpdHMgdGhlIGxpc3Rlbm1hcCEnLCB2YWwpXG4gICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lciggdGhpcy5fbGlzdGVuTWFwW2ldWzFdIClcbiAgICAgICAgICAgICBwaXYgPSBpXG4gICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKCBwaXYgIT09IHZvaWQgMCApIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5NYXAuc3BsaWNlKHBpdiwgMSlcbiAgICAgICAgICBpZih0aGlzLl9saXN0ZW5NYXAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5NYXAgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICB9KTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgVk9iamVjdCA9IHJlcXVpcmUoJy4vJyksXG4gIFYgPSByZXF1aXJlKCcuLi8nKVxuICBfYyA9IHV0aWwuY2hlY2tBcnJheVxuXG4vKipcbiAqIEdldHMvc2V0cyBWT2JqZWN0IG9yaWdpblxuICogSW4gYSBjaGFpbiBvZiBWLk9iamVjdHMgZS5nLiB4LnZhbCA9IHksIHkudmFsID0geiAtLS0+IHguZnJvbSByZXR1cm5zIHo7XG4gKiBAbWV0aG9kIGZyb21cbiAqIEBwYXJhbSAge09iamVjdH0gb2JqIFtkZXNjcmlwdGlvbl1cbiAqIEByZXR1cm4ge09iamVjdH0gICAgIFtkZXNjcmlwdGlvbl1cbiAqL1xudmFyIF9jb3JlU2V0ID0gVk9iamVjdC5zZXQsXG4gIF9mcm9tID0gdGhpcy5mcm9tID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHZhbCA9IG9iaixcbiAgICAgIGxhc3Q7XG5cbiAgICB3aGlsZSAodmFsIGluc3RhbmNlb2YgVk9iamVjdCkge1xuICAgICAgLy8gY29uc29sZS5sb2codmFsKVxuICAgICAgaWYodmFsLl9maWx0ZXIpIHtcbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignSVMgU0VMRUNJVE9OJywgdmFsKVxuICAgICAgfVxuICAgICAgbGFzdCA9IHZhbDtcbiAgICAgIHZhbCA9IHZhbC5fdmFsO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdCAhPT0gb2JqID8gbGFzdCA6IGZhbHNlO1xuICB9LFxuICBfbGFzdExGcm9tID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgd2hpbGUgKG9iaiAmJiBvYmouX190ID09PSA0KSB7XG4gICAgICBpZiAob2JqLl9sZnJvbSkge1xuICAgICAgICByZXR1cm4gb2JqLl9sZnJvbTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IG9iai5fdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgcGF0aFxuICAgKiBAbWV0aG9kIF91cGRhdGVQYXRoXG4gICAqIEBwYXJhbSAge09iamVjdH0gICAgdGlsbCBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICBSZXR1cm5zIHBhdGhcbiAgICovXG4gIF91cGRhdGVQYXRoID0gZnVuY3Rpb24odGlsbCwgc3RhcnQpIHtcbiAgICB2YXIgcGFyZW50ID0gdGhpcyxcbiAgICAgIGxmcm9tLFxuICAgICAgcGF0aCA9IFtdOyAvL3JlZHVjZSBhbW91bnQgb2YgbmV3IGFycmF5c1xuICAgIHdoaWxlIChwYXJlbnQgJiYgKHBhcmVudC5fbmFtZSAhPT0gdm9pZCAwIHx8IHN0YXJ0KSkge1xuICAgICAgbGZyb20gPSBwYXJlbnQuX2xmcm9tIHx8IF9sYXN0TEZyb20ocGFyZW50KVxuICAgICAgaWYgKGxmcm9tKSB7XG4gICAgICAgIHZhciBhID0gX3VwZGF0ZVBhdGguY2FsbChsZnJvbSksXG4gICAgICAgICAgYyA9IHBhcmVudC5mcm9tLl9uYW1lO1xuICAgICAgICB1dGlsLmFkZChhLCBwYXRoKTtcbiAgICAgICAgcGF0aCA9IGE7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgYyA9IGEuaW5kZXhPZihjKTtcbiAgICAgICAgICBhLnNwbGljZShjLCBhLmxlbmd0aCAtIGMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICE9PSB0aWxsKSB7XG4gICAgICAgIHBhdGgucHVzaChwYXJlbnQuX25hbWUpO1xuICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcmVudCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0+JyxwYXRoKVxuICAgIHJldHVybiB0aWxsID8gcGF0aC5yZXZlcnNlKCkgOiBwYXRoO1xuICB9XG5cbnV0aWwuZGVmaW5lKFZPYmplY3QsXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBsaW5rZWQgY29udGFpbmVycywgdXNlcyBzbGljZSBvbiBhcnJheXNcbiAgICogUmVtb3ZlcyBhbGwgX2xpc3RlbmVyc1xuICAgKiBAbWV0aG9kIGRlc3Ryb3lcbiAgICovXG4gICAndG9TdHJpbmcnLCBmdW5jdGlvbiggY29tcHJlc3NlZCApIHtcbiAgICAgIHJldHVybiBjb21wcmVzc2VkIFxuICAgICAgICAgICAgID8gSlNPTi5zdHJpbmdpZnkoIHRoaXMucmF3ICkgXG4gICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSggdGhpcy5yYXcsIGZhbHNlLCAyIClcbiAgIH0sXG4gICAncmVmZXJlbmNlTGV2ZWwnLCBmdW5jdGlvbihsaW5rZWQpIHtcbiAgICAgIHZhciBsaW5rID0gdGhpc1xuICAgICAgdmFyIGNudCA9IDBcblxuICAgICAgLy8gY29uc29sZS5sb2cobGluaywgbGluay5fX3QpXG5cbiAgICAgIHdoaWxlKGxpbmsgJiYgbGluay5fX3QpIHtcbiAgICAgICAgaWYobGluaz09PWxpbmtlZCkge1xuICAgICAgICAgIHJldHVybiBjbnRcbiAgICAgICAgfVxuICAgICAgICBsaW5rID0gbGluay5fdmFsXG4gICAgICAgIGNudCsrXG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgIH0sXG4gICdkZXN0cm95JywgZnVuY3Rpb24obmVzdGVkLCBibCwgbm90LCBmcm9tLCBzdGFtcCwgbm91cGRhdGUpIHtcbiAgICBpZighc3RhbXApXG4gICAgICBzdGFtcCA9IHRoaXMuc3RhbXAoKVxuXG4gICAgdGhpcy5fcmVtb3ZlZCA9IHRydWVcbiAgICB0aGlzLmRlc3Ryb3lSZWZlcmVuY2VzKG5lc3RlZCwgYmwsIG5vdCwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKVxuICAgIHRoaXMucmVtb3ZlKG5lc3RlZCwgYmwsIG5vdCwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKVxuICB9LFxuICAnZGVzdHJveVJlZmVyZW5jZXMnLCBmdW5jdGlvbihuZXN0ZWQsIGJsLCBub3QsIGZyb20sIHN0YW1wLCBub3VwZGF0ZSkge1xuICAgIGlmKCFzdGFtcClcbiAgICAgIHN0YW1wID0gdGhpcy5zdGFtcCgpXG5cbiAgICB2YXIgX2wgPSB0aGlzLl9saXN0ZW5lcnNcbiAgICAgICwgcGFyZW50XG4gICAgICAvLyAsIGl0ZW1cbiAgICBpZiAoX2wpIHtcbiAgICAgIGZvciAodmFyIGkgPSBfbC5sZW5ndGgsIHJlZjsgcmVmID0gX2xbLS1pXTspIHtcbiAgICAgICAgLy8gaWYobGlzdGVuZXIgaW5zdGFuY2VvZiBBcnJheSl7XG4gICAgICAgIC8vICAgaWYobGlzdGVuZXIpXG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gcmVmID0gIGluc3RhbmNlb2YgQXJyYXkgPyBfbFtpXVsxXSA6IF9sW2ldO1xuICAgICAgICBpZiAocmVmIGluc3RhbmNlb2YgVk9iamVjdCkge1xuICAgICAgICAgIHBhcmVudCA9IHJlZi5fcGFyZW50O1xuICAgICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Ll9fdCA9PT0gMSkge1xuICAgICAgICAgICAgcGFyZW50LnNwbGljZShyZWYuX25hbWUsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWYucmVtb3ZlKG5lc3RlZCwgYmwsIG5vdCwgZnJvbSwgc3RhbXAsIG5vdXBkYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBwYXNzZWQgZnVuY3Rpb24gb24gZWFjaCBpdGVtLlxuICAgKiBTa2lwcyBpdGVtcyBpbiB0aGUgYmxhY2tsaXN0LlxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgZm4gICBmdW5jdGlvbiB0byBwZXJmb3JtIG9uIGVhY2hcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICBkZWVwIElmIHRydWUsIHJlcGVhdHMgZWFjaG1ldGhvZCBvbiBuZXN0ZWQgZmllbGRzXG4gICAqIEBwYXJhbSAge0FyZ3VtZW50c30gYXJnICBBcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgZnVuY3Rpb25cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdlYWNoJywgZnVuY3Rpb24oZm4sIGRlZXAsIGFyZykge1xuICAgIC8vdHJ5IHRvIG1ha2UgdGhpcyBhIGxvdCBzaG9ydGVyXG4gICAgdmFyIGksIGl0ZW07XG4gICAgaWYgKGFyZyAhPT0gdm9pZCAwKSB7XG4gICAgICBhcmcgPSB1dGlsLmFyZyhhcmd1bWVudHMsIDIpO1xuICAgICAgZm9yIChpIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKCFfYyh0aGlzLl9ibGFja2xpc3QsIGkpKSB7XG4gICAgICAgICAgaXRlbSA9IHRoaXNbaV07XG4gICAgICAgICAgaWYgKGZuLmFwcGx5KGl0ZW0sIGFyZykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGVlcCAmJiAoaXRlbS5fX3QgIT09IDQgfHwgaXRlbS5fY29udGFpbmVkKSkge1xuICAgICAgICAgICAgaWYgKGl0ZW0uZWFjaC5hcHBseShpdGVtLCBhcmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gdGhpcykge1xuICAgICAgICBpZiAoIV9jKHRoaXMuX2JsYWNrbGlzdCwgaSkpIHtcbiAgICAgICAgICBpdGVtID0gdGhpc1tpXTtcbiAgICAgICAgICBpZiAoZm4uY2FsbChpdGVtLCBpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZWVwICYmIChpdGVtLl9fdCAhPT0gNCB8fCBpdGVtLl9jb250YWluZWQpKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5lYWNoKGZuLCBkZWVwLCBhcmcpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJlYWwgcGF0aFxuICAgKiBAYXR0cmlidXRlIF9wYXRoXG4gICAqL1xuICAgICdfcGF0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzXG4gICAgICAgICAgLCBwYXRoID0gW11cblxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIHBhcmVudC5fbmFtZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcGF0aC5wdXNoKHBhcmVudC5fbmFtZSk7XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAnX2NhY2hlZFBhdGgnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX2NhY2hlZFBhdGggfHwgKHRoaXMuX19jYWNoZWRQYXRoID0gdGhpcy5fcGF0aC5qb2luKCcuJykpXG4gICAgICB9XG4gICAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVwZGF0ZSBwYXRoXG4gICAqIEBhdHRyaWJ1dGUgdXBkYXRlUGF0aFxuICAgKi9cbiAgJ3VwZGF0ZVBhdGgnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhID0gX3VwZGF0ZVBhdGguY2FsbCh0aGlzLCB0aGlzLCB0cnVlKSxcbiAgICAgICAgbmFtZSA9IHRoaXMuX25hbWU7XG4gICAgICBuYW1lICE9PSB2b2lkIDAgJiYgYS51bnNoaWZ0KG5hbWUpO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUga2V5cyBvZiBhbiBvYmplY3RcbiAgICogQGF0dHJpYnV0ZSBrZXlzXG4gICAqL1xuICAna2V5cycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGksIGFyciA9IFtdO1xuICAgICAgZm9yIChpIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKCFfYyh0aGlzLl9ibGFja2xpc3QsIGkpKSB7XG4gICAgICAgICAgYXJyLnB1c2goaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBBbmNlc3RvclxuICAgKiBhbHNvIHJldHVybiB0cnVlIHdoZW4gb2JqZWN0IGlzIG9iamVjdCB0byBiZSBjb21wYXJlZCB0b1xuICAgKiBAYXR0cmlidXRlIGtleXNcbiAgICovXG4gIC8vdC5fZCA9PT0gZnJvbS5fcGFyZW50IHx8IHQuX2QgPT09IGZyb21cbiAgJ19hbmNlc3RvcicsIGZ1bmN0aW9uKG9iaikge1xuICAgIC8vIGNvbnNvbGUubG9nKCdBTkNFU1RPUicucmVkLmludmVyc2UsIG9iaiwgdGhpcylcbiAgICB2YXIgcCA9IHRoaXNcbiAgICB3aGlsZSAocCkge1xuICAgICAgaWYgKG9iaiA9PT0gcCkgcmV0dXJuIHRydWVcbiAgICAgIHAgPSBwLl9wYXJlbnRcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQgYSBmaWVsZCBhdCBmaXJzdCBvY2N1cmVuY2UgaW4gdGhlIHBhcmVudCBjaGFpblxuICAgKiBAbWV0aG9kIGNoZWNrUGFyZW50XG4gICAqIEBwYXJhbSAge1N0cmluZ30gIGZpZWxkIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gZ2V0ICAgV2hlbiB0cnVlIHJldHVybnMgZm91bmQgaW5zdGVhZCBvZiBjdXJyZW50XG4gICAqIEByZXR1cm4ge09iamVjdH0gICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdjaGVja1BhcmVudCcsIHV0aWwuY2hlY2tQYXJlbnRGYWN0b3J5KCdfcGFyZW50JyksXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9ybWFsIG9iamVjdCwgYW5kIGtlZXBzIGxpbmtzIHRvIFYuT2JqZWN0c1xuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSAgeyp9ICAgICAgW3ZhbF0gW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdjb252ZXJ0JywgZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIG9iaiA9IHt9LCBsID0gMFxuICAgIGlmICghdmFsIHx8IHZhbC52YWwpIG9iai52YWwgPSB0aGlzLl92YWxcbiAgICBpZiAodGhpcy5fX3QgPT09IDEpIHtcbiAgICAgIG9iaiA9IFtdXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbCsrXG4gICAgICAgIG9ialtpXSA9IHRoaXNbaV0uY29udmVydCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICAgIGlmICghdmFsIHx8IHZhbFtpXSE9PXZvaWQgMCkge1xuICAgICAgICAgIGwrK1xuICAgICAgICAgIG9ialtpXSA9IHRoaXMuY29udmVydCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICAgIGlmICh2YWwpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgICAgIGlmIChvYmpbaV0gPT09IHZvaWQgMCkgb2JqW2ldID0gdm9pZCAwXG4gICAgICAgIGwrK1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWwgJiYgKCF2YWwgfHwgdmFsLnZhbCkpIG9iaiA9IG9iai52YWxcbiAgICByZXR1cm4gb2JqXG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbm9ybWFsIG9iamVjdFxuICAgKiBAYXR0cmlidXRlIHJhd1xuICAgKi9cbiAgJ3JhdycsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICB0eXBlID0gc2VsZi5fZmlsdGVyID8gMiA6IHNlbGYuX190LFxuICAgICAgICBvYmosIGksIGw7XG4gICAgICBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fdmFsICYmIHNlbGYuX3ZhbC5yYXc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIHNlbGYudmFsOyAvL3doZW4gdGhlIHR5cGUgaXMgbWl4ZWQgYWx3YXlzIHVzZXMgdmFsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodHlwZSA9PT0gMSkge1xuICAgICAgICAgIG9iaiA9IFtdO1xuICAgICAgICAgIGZvciAoaSA9IC0xLCBsID0gc2VsZi5sZW5ndGggLSAxOyBpIDwgbDsgc2VsZlsrK2ldICYmIG9iai5wdXNoKHNlbGZbaV0ucmF3KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2JqID0ge307XG4gICAgICAgICAgZm9yIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgIGlmICghX2Moc2VsZi5fYmxhY2tsaXN0LCBpKSAmJiBzZWxmW2ldKSB7XG4gICAgICAgICAgICAgIG9ialtpXSA9IHNlbGZbaV0ucmF3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEdldHMvc2V0cyBvYmplY3Qgb3JpZ2luXG4gICAqIEluIGEgY2hhaW4gb2YgVi5PYmplY3RzIGUuZy4geC52YWwgPSB5LCB5LnZhbCA9IHogLS0tPiB4LmZyb20gcmV0dXJucyB6O1xuICAgKiBAYXR0cmlidXRlIGZyb21cbiAgICovXG4gICdmcm9tJywge1xuICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICB2YXIgZm91bmQgPSBfZnJvbSh0aGlzKVxuICAgICAgX2NvcmVTZXQuY2FsbChmb3VuZCB8fCB0aGlzLCB2YWwpXG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9mcm9tKHRoaXMpIHx8IHRoaXNcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBNZXJnZSBhbnkgb2JqZWN0IGludG8gYW5vdGhlciBvYmplY3RcbiAgICogU2hhbGxvdyBmb3IgYSBzaGFsbG93IG1lcmdlXG4gICAqIEBtZXRob2QgbWVyZ2VcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgb2JqICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBzaGFsbG93ICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge051bWJlcn0gIHN0YW1wICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gbm91cGRhdGUgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICAnbWVyZ2UnLCBmdW5jdGlvbiBtZXJnZSggb2JqLCBzaGFsbG93LCBzdGFtcCwgbm91cGRhdGUsIGJsb2NrLCBzb3J0ZWQsIGRlZmVyVXBkYXRlcyApIHtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdNRVJHRS0tLS0+Jywgb2JqIClcblxuICAgIHZhciBtZXJnZUFycmF5ID0gdGhpcy5fbWVyZ2VBcnJheVxuICAgICAgLCByXG4gICAgICAsIGlcbiAgICAgICwgc3RvcFxuICAgICAgLCBydFxuICAgICAgLCBjb2JqXG4gICAgICAsIHRvYmpcbiAgICAgICwgdG9wTGV2ZWxcblxuICAgIGlmKCFkZWZlclVwZGF0ZXMpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdOTyBkZWZlclVwZGF0ZXMnLnllbGxvdy5pbnZlcnNlKVxuICAgICAgdG9wTGV2ZWwgPSB0cnVlXG4gICAgICBkZWZlclVwZGF0ZXMgPSBbXVxuICAgIH1cbiAgICAvL0ZJWE1FOiBtYWtlIGl0IGJldHRlciBsb25nIG5hbWVzIGV0YywgY29kZSBmb3JtYXR0aW5nXG5cbiAgICBpZiAoICFzdGFtcCApIHN0YW1wID0gdGhpcy5zdGFtcCgpXG5cbiAgICBpZiAoIHRoaXMuX190ID09PSAxICkge1xuICAgICAgaWYgKG1lcmdlQXJyYXkpIHtcbiAgICAgICAgbWVyZ2VBcnJheSggb2JqLCBzdGFtcCwgbm91cGRhdGUgKSAvL2hpZXIgbW9ldCBvb2sgZmYgZGVmZXJVcGRhdGVzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBqIGluIG9iaikge1xuICAgICAgICAgIGNvYmogPSBvYmpbal1cbiAgICAgICAgICB0b2JqID0gdGhpc1tqXVxuICAgICAgICAgIGlmICgoaiA9IE51bWJlcihqKSkgPiAtMSkge1xuICAgICAgICAgICAgciA9IHRydWVcbiAgICAgICAgICAgIGlmICh0b2JqKSB7XG4gICAgICAgICAgICAgIHRvYmoubWVyZ2UoY29iaiwgZmFsc2UsIHN0YW1wLCB0cnVlLCBibG9jaywgc29ydGVkLCBkZWZlclVwZGF0ZXMgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGogPiB0aGlzLmxlbmd0aCAtIDEpIHRoaXMubGVuZ3RoID0gaiArIDFcbiAgICAgICAgICAgICAgdGhpcy5zZXQoaiwgY29iaiwgZmFsc2UsIHN0YW1wLCB0cnVlLCB0cnVlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIHN0b3AgPSB0cnVlXG4gICAgICAgIGNvYmogPSBvYmpbaV1cbiAgICAgICAgdG9iaiA9IHRoaXNbaV1cbiAgICAgICAgaWYgKGkgIT09ICd2YWwnICYmICFfYyh0aGlzLl9ibGFja2xpc3QsIGkpKSB7XG4gICAgICAgICAgaWYgKCFzaGFsbG93ICYmIHRvYmogJiYgdXRpbC5pc09iaihjb2JqKSkgeyAvL2NvYmogaW5zdGFuY2VvZiBPYmplY3QgJiYgKHR5cGVvZiBjb2JqICE9PSAnZnVuY3Rpb24nKSAmJiBjb2JqLl9fdCAhPT0gMylcbiAgICAgICAgICAgIGlmIChjb2JqLmNsZWFyKSB7XG4gICAgICAgICAgICAgIF9jb3JlU2V0LmNhbGwodG9iaiwgY29iaiwgc3RhbXAsIGZhbHNlLCB0cnVlKVxuICAgICAgICAgICAgICByID0gdHJ1ZVxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKCctLS0tIG1lcmdlIC93IHVwZGF0ZSB0aGF0cyBtb3MgZGVmIHdyb25nIScsIGksIGRlZmVyVXBkYXRlcylcbiAgICAgICAgICAgICAgLy9kZWZlclVwZGF0ZXNcblxuICAgICAgICAgICAgICBydCA9IHRvYmoubWVyZ2UoY29iaiwgZmFsc2UsIHN0YW1wLCB0cnVlLCBibG9jaywgc29ydGVkLCBkZWZlclVwZGF0ZXMgKVxuICAgICAgICAgICAgICBpZiAociAhPT0gdHJ1ZSkgciA9IHJ0XG5cbiAgICAgICAgICAgICAgaWYgKCFydCkgXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnMDAwMCcpXG4gICAgICAgICAgICAgICAgb2JqW2ldID0gdm9pZCAwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICBpZiAodG9iaiAmJiB0b2JqLl92YWwgPT09IGNvYmopIHsgLy9jaGFuZ2VkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiAwIGFuZCBmYWxzZSwgbm93IGFsc28gZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiAxIGFuZCAnMSdcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLSAyIHVwZGF0ZSB0aGF0cyBtb3MgZGVmIHdyb25nIScsIGkpXG5cbiAgICAgICAgICAgICAgaWYgKHIgIT09IHRydWUpIHIgPSBmYWxzZVxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnPz8/Pz8/PycpXG4gICAgICAgICAgICAgIG9ialtpXSA9IHZvaWQgMFxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0gMyB1cGRhdGUgdGhhdHMgbW9zIGRlZiB3cm9uZyEnLCBpKVxuICAgICAgICAgICAgICBpZihjb2JqPT09bnVsbCAmJiB0aGlzW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tpXS5yZW1vdmUoIGZhbHNlLCBmYWxzZSwgZmFsc2UsIHZvaWQgMCwgc3RhbXAgKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCchPycuYm9sZCwgaSwgdGhpc1tpXSlcbiAgICAgICAgICAgICAgICAvL25hbWUsIHZhbCwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBmcm9tXG4gICAgICAgICAgICAgICAgdGhpcy5zZXQoIGksIGNvYmosIGZhbHNlLCBzdGFtcCwgdHJ1ZSApXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJyF4eHh4PycsIGkpXG4gICAgICAgICAgICAgICAgaWYodGhpc1tpXSAmJiB0aGlzW2ldLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdwdXNoIHB1c2gnLmdyZWVuLCAgSlNPTi5zdHJpbmdpZnkob2JqKSApXG4gICAgICAgICAgICAgICAgICBkZWZlclVwZGF0ZXMucHVzaCggW3RoaXNbaV0sIGNvYmpdIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9hZGQgZGl0IG5hYXIgbGlzdFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcikgciA9IHJ0O1xuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybihyLCBydClcblxuICAgICAgICAgICAgICBpZiAoIXJ0KSBcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vVE9ETzogVEVNUCBGSVggRE9OVCBLTk9XIElGIFRISVMgV09SS1MhXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJz8/Pz8/Pz8yMjIyMicpXG4gICAgICAgICAgICAgICAgLy8gb2JqW2ldID0gdm9pZCAwXG4gICAgICAgICAgICAgICAgLy8gY29uc29sZS53YXJuKCdjYW50IGJlIHJpZ2h0IScpXG4gICAgICAgICAgICAgICAgLy9TVVBFUiBDQVJFRlVMTCBXSVRIIFRISVMgUiBUSElORyEhISEhXG4gICAgICAgICAgICAgICAgciA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9iai52YWwpIHtcbiAgICAgICAgcnQgPSBfY29yZVNldC5jYWxsKHRoaXMsIG9iai52YWwsIHN0YW1wLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgciA9IHJ0XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFydCkge1xuICAgICAgICAgIG9iai52YWwgPSB2b2lkIDBcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RvcCkge1xuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICByID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHIgPSAociAhPT0gZmFsc2UpIHx8IHJcbiAgICB9XG5cbiAgICBpZiAocikge1xuICAgICAgaWYgKCFibG9jaykge1xuICAgICAgICAvLyBhbGVydChub3VwZGF0ZSlcbiAgICAgICAgaWYgKG5vdXBkYXRlKSB7XG5cbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnISE/Pz8/Pz8/Pz8/PyBOT1VQREFURScuYmx1ZSwgSlNPTi5zdHJpbmdpZnkob2JqKSlcblxuICAgICAgICAgIGlmKHRvcExldmVsKSB7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnVVBEQVRFPj8nLm1hZ2VudGEuaW52ZXJzZSwgb2JqLCBKU09OLnN0cmluZ2lmeSggb2JqICksIG5vdXBkYXRlLCBzdGFtcClcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZShvYmosIHN0YW1wKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX191cGRhdGUob2JqLCBzdGFtcClcbiAgICAgICAgICAgIGRlZmVyVXBkYXRlcy5wdXNoKFsgdGhpcywgb2JqIF0pXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFxuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCcyVVBEQVRFPj8nLmN5YW4uaW52ZXJzZSwgdG9wTGV2ZWwsIGRlZmVyVXBkYXRlcywgb2JqLCBub3VwZGF0ZSwgc3RhbXApXG5cbiAgICAgICAgICB0aGlzLl91cGRhdGUoIG9iaiwgc3RhbXAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgXG5cbiAgICBpZih0b3BMZXZlbCAmJiBkZWZlclVwZGF0ZXMpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnZGVmZXJlZCB1cGRhY2UnLCB0b3BMZXZlbCwgZGVmZXJVcGRhdGVzKVxuICAgICAgZm9yKHZhciBkZiBpbiBkZWZlclVwZGF0ZXMpIHtcbiAgICAgICAgaWYoIGRlZmVyVXBkYXRlc1tkZl1bMF0gJiYgZGVmZXJVcGRhdGVzW2RmXVswXS5fX3VwZGF0ZSApIHtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZygnREVGRVJFRCEhISEnLmN5YW4uaW52ZXJzZSwgZGYsIGRlZmVyVXBkYXRlc1tkZl1bMV0sIHN0YW1wIClcbiAgICAgICAgICBkZWZlclVwZGF0ZXNbZGZdWzBdLl9fdXBkYXRlKCBkZWZlclVwZGF0ZXNbZGZdWzFdLCBzdGFtcCApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJcbiAgfSxcbiAgLyoqXG4gICAqIENvcGllcyBhbiBvYmplY3QgYW5kIHJldHVybnMgYSBuZXcgb25lLCBjYW4gYWxzbyBwYXNzIGEgbWVyZ2Ugb2JqZWN0XG4gICAqIEBtZXRob2RcbiAgICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgb2JqICAgICAgIE9iamVjdCB0byBjb3B5XG4gICAqIEBwYXJhbSAge0Jvb2xlYW59ICAgICAgIFtzaGFsbG93XSBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gIFtsaXN0XSAgICBUYWtlcyBhbnkgb2JqZWN0IHdpdGggLmxlbmd0aFxuICAgKiBAcGFyYW0gIHtPYmplY3R9ICAgICAgICBbcGFyZW50XSAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ2Nsb25lJywgZnVuY3Rpb24ob2JqLCBzaGFsbG93LCBsaXN0LCBwYXJlbnQpIHsgLy9zdXBwb3J0IHNoYWxsb3chOyBjaGVjayBvYmogY29weSBvbmx5IHdoYXQgaXMgbmVzc2VjYXJ5IGFkZGVkIG1ha2VzaG9ydCAsIG1hZGUgcGFyZW50IHNob3J0ZXJcbiAgICB2YXIgY29weSA9IG5ldyB0aGlzLl9jbGFzcygpLFxuICAgICAgX3ZhbCA9IHRoaXMuX3ZhbCxcbiAgICAgIGk7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgY29weS5fcGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICBjb3B5Ll9fdCA9IHRoaXMuX190O1xuICAgIGlmICh0aGlzLl9fdCA9PT0gMSkge1xuICAgICAgY29weS5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKGxpc3QpIHtcbiAgICAgIC8vbGlzdFxuICAgICAgZm9yICh2YXIgaiA9IGxpc3QubGVuZ3RoIC0gMSwgaXRlbTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgaXRlbSA9IGxpc3Rbal07XG5cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBBcnJheSAmJiB0aGlzW2l0ZW1bMF1dKSB7XG4gICAgICAgICAgaWYoaXRlbVsxXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29weVtpdGVtWzBdXSA9IHV0aWwuY2xvbmUodGhpc1tpdGVtWzBdXSwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvcHlbaXRlbVswXV0gPSBpdGVtWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzW2l0ZW1dKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coaXRlbSlcbiAgICAgICAgICBjb3B5W2l0ZW1dID0gdGhpc1tpdGVtXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoX3ZhbCAmJiAoX3ZhbCBpbnN0YW5jZW9mIFZPYmplY3QgJiYgX3ZhbC5fY29udGFpbmVkKSkge1xuICAgICAgY29weS52YWwgPSBfdmFsLmNsb25lKGNvcHksIGZhbHNlLCBsaXN0LCBjb3B5KTtcbiAgICAgIGNvcHkuX3ZhbC5fY29udGFpbmVkID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgVk9iamVjdC5zZXQuY2FsbChjb3B5LCBfdmFsLCBmYWxzZSwgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGkgaW4gdGhpcykge1xuICAgICAgaWYgKCFfYyh0aGlzLl9ibGFja2xpc3QsIGkpKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGkpXG4gICAgICAgIGlmICghc2hhbGxvdykge1xuICAgICAgICAgIGlmICh0aGlzW2ldIGluc3RhbmNlb2YgVk9iamVjdCkge1xuICAgICAgICAgICAgLy9mdW5jdGlvbiggbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb20gKVxuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnLS0tLS0+MScsIGksIHRoaXNbaV0uY2xvbmUodm9pZCAwLCBmYWxzZSwgbGlzdCwgY29weSkpXG4gICAgICAgICAgICAvL3N0YW1wIHZvaWQgMFxuICAgICAgICAgICAgY29weS5zZXQoaSwgdGhpc1tpXS5jbG9uZSh2b2lkIDAsIGZhbHNlLCBsaXN0LCBjb3B5KSwgdHJ1ZSwgZmFsc2UsIHRydWUpXG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0tPjInLCBpLCB1dGlsLmNsb25lKHRoaXNbaV0pKVxuXG4gICAgICAgICAgICBjb3B5W2ldID0gdXRpbC5jbG9uZSh0aGlzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9mdW5jdGlvbiggbmFtZSwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIGZyb20gKVxuICAgICAgICAgIGNvcHkuc2V0KGksIHRoaXNbaV0sIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9iaiAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAodXRpbC5pc09iaihvYmopKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdNRVJHRS0tLS0tPicsIG9iaiwgc2hhbGxvdylcbiAgICAgICAgY29weS5tZXJnZShvYmosIHNoYWxsb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVk9iamVjdC5zZXQuY2FsbChjb3B5LCBvYmosIGZhbHNlLCBmYWxzZSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgY29weS5fX3QgPSB0aGlzLl9fdDtcbiAgICByZXR1cm4gY29weTtcbiAgfSxcbiAgLyoqXG4gICAqIFJldHVybnMgb2JqZWN0IG9uIHRoZSBlbmQgb2YgYSBkZWZpbmVkIHBhdGhcbiAgICogQG1ldGhvZCBwYXRoXG4gICAqIEBwYXJhbSAge0FycmF5fSAgICAgcGF0aCAgICAgICAgICAgQXJyYXkgb2YgZmllbGRzIGluIHBhdGhcbiAgICogQHBhcmFtICB7Kn0gICAgICAgICBbdmFsXSAgICAgICAgICBXaGVuIGRlZmluZWQsIHZhbCB3aWxsIGJlIHNldCBvbiBlbmRwb2ludCBvZiBwYXRoIGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAgICogQHBhcmFtICB7Qm9vbGVhbn0gICBbb3ZlcndyaXRlXSAgICBJZiB0cnVlLCB2YWwgV0lMTCBvdmVyd3JpdGUgZXhpc3RpbmcgdmFsdWUgb24gZW5kcG9pbnQgb2YgcGF0aCB3aGVuIGFscmVhZHkgZGVmaW5lZFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gIFt3cml0ZUhhbmRsZXJdIENhbGxiYWNrIG9uIHdyaXRlXG4gICAqIEByZXR1cm4geyp9ICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0IG9uIHRoZSBlbmQgb2YgYSBkZWZpbmVkIHBhdGhcbiAgICovXG4gICdwYXRoJywgZnVuY3Rpb24ocGF0aCwgdmFsLCBvdmVyd3JpdGUsIHdyaXRlSGFuZGxlciwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBzZWxmKSB7XG4gICAgaWYoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSBwYXRoID0gcGF0aC5zcGxpdCgnLicpO1xuICAgIHJldHVybiB1dGlsLnBhdGgodGhpcywgcGF0aCwgdmFsLCBvdmVyd3JpdGUsIHdyaXRlSGFuZGxlciwgdm9iaiwgc3RhbXAsIG5vdXBkYXRlLCBzZWxmKTtcbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgb2JqZWN0IGZyb20gc3BlY2lmaWVkIHBhdGguIFdoZW4gcGF0aCBpcyBhIHN0cmluZyBjaGVja3MgZm9yICdkb3Rub3RhdGlvbicuXG4gICAqIEBtZXRob2QgZ2V0XG4gICAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gcGF0aCBEZWZpbmVzIGZpZWxkIHtzdHJpbmd9IG9yIHBhdGgge2FycmF5fCdkb3Qtbm90YXRpb24nfVxuICAgKiBAcmV0dXJuIHsqfSAgICAgICAgICAgICAgICAgb2JqW3BhdGhdfG5lc3RlZCBvYmplY3QvdmFsdWVcbiAgICovXG4gICdnZXQnLCBmdW5jdGlvbihwYXRoLCBzZWxmKSB7IC8vZ2V0IGRvZXMgbm90IG5lZWQgYW4gYXJyYXkgYXMgcGF0aFxuICAgIHJldHVybiB1dGlsLmdldCh0aGlzLCBwYXRoLCBzZWxmKTtcbiAgfSxcblxuICAvLyh2YWwsIHN0YW1wLCBmcm9tLCBub3VwZGF0ZSwgYWRkKVxuICAvLyAnJHNldCcsIGZ1bmN0aW9uKCB2YWwsIHN0YW1wLCBmcm9tLCB1cGRhdGUgKSB7IC8vZ2V0IGRvZXMgbm90IG5lZWQgYW4gYXJyYXkgYXMgcGF0aFxuXG4gIC8vICAgcmV0dXJuIFZPYmplY3Quc2V0LmNhbGwoIHRoaXMsIHZhbCwgc3RhbXAsIGZyb20sICF1cGRhdGUgKVxuICAgIFxuICAvLyAgICAgJ19zZXQnLCBmdW5jdGlvbih2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIG5vdXBkYXRlLCBhZGRlZCwgb2xkdmFsKSB7XG4gIC8vICAgaWYgKCFub3VwZGF0ZSkge1xuICAvLyAgICAgKHZhbCwgc3RhbXAsIGZyb20sIG5vdXBkYXRlLCBhZGQpXG4gIC8vICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLl9wYXRoLCB2YWwpXG4gIC8vICAgICB0aGlzLl91cGRhdGUodmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKTtcbiAgLy8gICB9XG4gICAgXG5cbiAgLy8gfSxcbiAgLyoqXG4gICAqIENoZWNrIGlmIG9iaiBpcyBlbXB0eSBleGNsdWRlIGZpZWxkIG5hbWVzIHBhc3NlZCB0byBsaXN0XG4gICAqIEBtZXRob2QgZW1wdHlcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZS9mYWxzZVxuICAgKi9cbiAgJ2VtcHR5Jywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdXRpbC5lbXB0eSh0aGlzLCB0aGlzLl9ibGFja2xpc3QpO1xuICAgIH1cbiAgfSxcbiAgJyRlbXB0eScsIGZ1bmN0aW9uKCBleGNsdWRlcywgdXBkYXRlICkge1xuICAgICAgLy9nZXQgZG9lcyBub3QgbmVlZCBhbiBhcnJheSBhcyBwYXRoXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICB0aGlzLmVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgIGlmKCBcbiAgICAgICAgICAgICFleGNsdWRlcyBcbiAgICAgICAgICAgICAgfHwgdHlwZW9mIGV4Y2x1ZGVzID09PSAnc3RyaW5nJyAgXG4gICAgICAgICAgICAgICAgID8ga2V5ICE9PSBleGNsdWRlcyBcbiAgICAgICAgICAgICAgICAgOiAhdXRpbC5jaGVja0FycmF5KCBleGNsdWRlcywga2V5ICkgXG4gICAgICAgICAgKVxuICAgICAgICB7XG4gICAgICAgICAgaWYoIHRoaXMucmVtb3ZlICkgXG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmUoIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSApXG4gICAgICAgICAgfSBcbiAgICAgICAgICBlbHNlIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUud2FybiggJyRlbXB0eSBub24tdk9iamVjdCBvYmplY3QudXRpbCByZW1vdmUnLCB0aGlzLCBrZXkgKVxuICAgICAgICAgICAgX3RoaXNba2V5XSA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgXG4gICAgICBpZiggdGhpcy5jbGVhckNhY2hlICkgdGhpcy5jbGVhckNhY2hlKClcblxuICAgICAgaWYoIHVwZGF0ZSApXG4gICAgICB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgnZW1wdHknKVxuICAgICAgfVxuICB9LFxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVi5PYmplY3QgZnJvbSB3aGljaCB0aGUgY3VycmVudCB1cGRhdGUgb3JpZ2luYXRlZC5cbiAgICogQG1ldGhvZCBfdXBkYXRlT3JpZ2luXG4gICAqIEByZXR1cm4ge1YuT2JqZWN0fSBvcmlnaW4gb2YgdGhlIHVwZGF0ZVxuICAgKi9cbiAgJ191cGRhdGVPcmlnaW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrID0gdGhpcztcbiAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ2dldCBVUERBVEUgT1JJR0lOJywgdGhpcy5fcGF0aCwgdGhpcy5fbGZyb20pXG4gICAgICB3aGlsZSAobWFyay5fbGZyb20pIHtcblxuICAgICAgICAvL2lmIFYuQ2xvdWREYXRhXG4gICAgICAgLy8gY29uc29sZS5lcnJvciggJ191cGRhdGUgdGhhdCBvcmlnaW4hJywgbWFyay5fcGF0aCApXG4gICAgICAgIG1hcmsgPSBtYXJrLl9sZnJvbTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXJrO1xuICAgIH1cbiAgfSxcbiAgJ19vcmlnaW4nLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBtYXJrID0gdGhpcztcbiAgICAgIHdoaWxlIChtYXJrICYmIG1hcmsuX190ID09PSA0KSB7XG4gICAgICAgIG1hcmsgPSBtYXJrLl92YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFyaztcbiAgICB9XG4gIH1cbilcblxuXG4vL2FkZCBmaW5kXG5cbiIsInZhciB1dGlsID0gcmVxdWlyZSgnLi4vJylcbiAgLCBhamF4XG4gICwgUEFDS0FHRSA9ICcvcGFja2FnZS5qc29uJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiggY2FsbGJhY2ssIHBhcmFtcywgcGFja2FnZUZpbGUsIG5vUmVwbGFjZSApIHtcblxuICBwYWNrYWdlRmlsZSA9IHBhY2thZ2VGaWxlIHx8ICggdXRpbC5pc05vZGUgPyB7fSA6IHdpbmRvdy5wYWNrYWdlIClcblxuICB2YXIgb2JqID0ge31cbiAgICAsIHJlcSA9IG1vZHVsZS5leHBvcnRzXG4gICAgLCBjYiA9IGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBwY2tnICkge1xuXG4gICAgICBvYmogPSBwY2tnLnZpZ291clxuICAgICAgcmVxLnBhcnNlKCBvYmosIHBhY2thZ2VGaWxlLCByZXEuX2NoZWNrcyApXG5cbiAgICAgIGlmKCFub1JlcGxhY2UpIG1vZHVsZS5leHBvcnRzID0gb2JqXG4gICAgICBjYWxsYmFjayhvYmopXG4gICAgfVxuXG4gIC8vZGVmYXVsdCBvcHRpb24gYWRkIG1vcmUhXG4gIGlmKCFwYXJhbXMpIHtcbiAgICBleHBvcnRzLm9wdGlvbnMudmFsKG9iaiwgY2IsIGZhbHNlLCBwYWNrYWdlRmlsZSApXG4gIH0gZWxzZSBpZihleHBvcnRzLm9wdGlvbnNbcGFyYW1zXSkge1xuICAgIGV4cG9ydHMub3B0aW9uc1twYXJhbXNdKG9iaiwgY2IsIGZhbHNlLCBwYWNrYWdlRmlsZSApXG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5vcHRpb25zLnZhbChvYmosIGNiLCBwYXJhbXMsIHBhY2thZ2VGaWxlIClcbiAgfVxuICByZXR1cm4gb2JqXG59XG5cbmlmKHV0aWwuaXNOb2RlKSB7XG4gIGV4cG9ydHMub3B0aW9ucyA9IHtcbiAgICB2YWw6ZnVuY3Rpb24oIG9iaiwgY2FsbGJhY2ssIHBhcmFtcywgcGNrZyApIHtcbiAgICAgIGNhbGxiYWNrKCBwY2tnIClcbiAgICB9XG4gIH1cbn0gZWxzZSB7XG4gIGFqYXggPSByZXF1aXJlKCAnLi4vLi4vYnJvd3Nlci9uZXR3b3JrL2FqYXgnIClcbiAgZXhwb3J0cy5vcHRpb25zID0ge1xuICAgIHZhbDpmdW5jdGlvbihvYmosIGNhbGxiYWNrLCBwYXJhbXMpIHtcbiAgICAgIGlmKCAhd2luZG93LnBhY2thZ2UgKSB7XG4gICAgICAgIHZhciBkb21haW4gPSAhd2luZG93LmNvcmRvdmEgJiYgU3RyaW5nKHdpbmRvdy5sb2NhdGlvbilcbiAgICAgICAgICAgIC5tYXRjaCgvaHR0cHM/OlxcL1xcLyhbXlxcL10rKS8pXG5cbiAgICAgICAgaWYoZG9tYWluKSBkb21haW4gPSBkb21haW5bMF1cbiAgICAgICAgIFxuICAgICAgICBhamF4KHtcbiAgICAgICAgICB1cmw6cGFyYW1zICYmIHBhcmFtcy51cmwgPyBwYXJhbXMudXJsIDogZG9tYWluK1BBQ0tBR0UsXG4gICAgICAgICAgZmFsbGJhY2s6IFtcbiAgICAgICAgICAgICAgeyB1cmw6IFBBQ0tBR0UgfSAvL2ZvciB0ZXN0aW5nXG4gICAgICAgICAgICAsIHBhcmFtcyAmJiBwYXJhbXMuZmFsbGJhY2sgPyBwYXJhbXMuZmFsbGJhY2sgOiB7IHVybDogX19kaXJuYW1lK1BBQ0tBR0UgfVxuICAgICAgICAgICAgLCB7IHVybDogJy4uLycrUEFDS0FHRSB9XG4gICAgICAgICAgICAsIHsgdXJsOiAnLi4vLi4vJytQQUNLQUdFIH1cbiAgICAgICAgICAgICwgeyB1cmw6ICcuLi8uLi8uLi8nK1BBQ0tBR0UgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgY29tcGxldGU6ZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgd2luZG93LnBhY2thZ2UgPSBkYXRhXG4gICAgICAgICAgICBpZihjYWxsYmFjaykgY2FsbGJhY2soZGF0YSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2UgaWYoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sod2luZG93LnBhY2thZ2UpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuaW5qZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGV4cG9ydHMuX2NoZWNrcyA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgcmV0dXJuIGV4cG9ydHNcbn1cblxuZXhwb3J0cy5sb29wID0gZnVuY3Rpb24ob2JqLCBvcHRpb24sIHBja2d2YWwsIG1lcmdlLCBmbiwgcGFyYW1zICkge1xuICBpZihmbikge1xuICAgIHZhciB2YWwgPSBvcHRpb24ob2JqLHBja2d2YWwsbWVyZ2UsIHBhcmFtcylcbiAgICBpZih2YWwpIHsgdXRpbC5tZXJnZShvYmosdmFsKSB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKHZhciBoIGluIG9ialtvcHRpb25dKSB7XG4gICAgICBpZigocGNrZ3ZhbD09PWgpKSB7XG4gICAgICAgIHV0aWwubWVyZ2Uob2JqLG1lcmdlW2hdKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oIG9iaiwgcGNrZywgb3B0aW9ucywgcGFyYW1zICkge1xuIGlmKCEob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgIG9wdGlvbnMgPSBbb3B0aW9uc11cbiB9XG5cbiBmb3IodmFyIGkgaW4gb3B0aW9ucykge1xuICAgIGZvcih2YXIgY2hlY2sgaW4gb3B0aW9uc1tpXSkge1xuICAgICAgdmFyIHBja2d2YWwgPSB1dGlsLmdldChwY2tnLGNoZWNrKVxuICAgICAgICAsIG9wdGlvbiA9IG9wdGlvbnNbaV1bY2hlY2tdXG5cbiAgICAgIGV4cG9ydHMubG9vcChvYmosIG9wdGlvbiwgcGNrZ3ZhbCwgb2JqW29wdGlvbnNbaV1bY2hlY2tdXSwgdHlwZW9mIG9wdGlvbiA9PT0gJ2Z1bmN0aW9uJyxwYXJhbXMpXG4gICAgfVxuICB9XG4gIHJldHVybiBvYmpcbn1cbiIsInZhciB1YSA9IHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvdWEnKVxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8nKVxuICAsIERhdGEgPSByZXF1aXJlKCcuLi8uLi9kYXRhJykuaW5qZWN0KHJlcXVpcmUoJy4uLy4uL2RhdGEvc2VsZWN0aW9uJykpXG4vKlxuc2VsZWN0aW9uIVxuXG4qL1xuYmxhID0gZXhwb3J0c1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24ob2JqLCBwY2tndmFsLCBtZXJnZSwgcGFyYW1zKSB7XG4gIHZhciBfdWEgPSB1YVxuXG4gIGlmKHBhcmFtcyAmJiBwYXJhbXMudWEpIHtcbiAgICBfdWEgPSB1YS5wYXJzZShwYXJhbXMudWEudG9Mb3dlckNhc2UoKSx7fSlcbiAgfVxuXG4gIC8vIGNvbnNvbGUubG9nKCdIRVJFIScsb2JqLHBja2d2YWwsbWVyZ2UpXG4gIHZhciBjb25kXG4gICAgLCB1YWNsb25lID0gbmV3IERhdGEoe2JsYTp1dGlsLmNsb25lKF91YSl9KVxuXG4gIGlmKG9iai51YSkge1xuICAgIGZvcih2YXIgaSBpbiBvYmoudWEpIHtcbiAgICAgIGlmKF91YS5wbGF0Zm9ybT09PWl8fF91YS5kZXZpY2U9PT1pfHxfdWEuYnJvd3Nlcj09PWkpIHtcbiAgICAgICAgcmV0dXJuIG9iai51YVtpXVxuICAgICAgfSBlbHNlIGlmKG9iai51YVtpXS5jb25kaXRpb24pIHtcbiAgICAgICAgaWYoIWNvbmQpIHtcbiAgICAgICAgICBjb25kID0gbmV3IERhdGEodWFjbG9uZSwgb2JqLnVhW2ldKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmQuZmlsdGVyID0gb2JqLnVhW2ldXG4gICAgICAgIH1cbiAgICAgICAgaWYoY29uZC5sZW5ndGgpIHtcbiAgICAgICAgICBkZWxldGUgb2JqLnVhW2ldLmNvbmRpdGlvblxuICAgICAgICAgIGNvbmQucmVtb3ZlKClcbiAgICAgICAgICByZXR1cm4gb2JqLnVhW2ldXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gIC8vYmxhYmxhXG5cbiAgLy8gY29uc29sZS5sb2coJ1NVQk9CSj8/Pycsb2JqKVxuXG5cbiAgZGVsZXRlIG9iai5zdWJzT2JqXG5cbiAgaWYoY29uZCkgY29uZC5yZW1vdmUoKVxufVxuXG4iLCJ2YXIgZGVidWcgPSBleHBvcnRzXG5cbkRFQlVHJCA9IGRlYnVnXG5cbi8qXG4gIGNvbnNvbGUubG9nKCd1dGlsL3Rlc3QgXFxuXFxuaWYgeW91IHdhbnQgdG8gY2hlY2sgbWVtb3J5IHVzYWdlIHN0YXJ0IGNocm9tZSB1c2luZzogXFxuXFxuIG9wZW4gLWEgR29vZ2xlXFxcXCBDaHJvbWUgLS1hcmdzIC0tZW5hYmxlLW1lbW9yeS1pbmZvIFxcbicpXG4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCcuLi8nKVxuICAsIGlzTm9kZSA9IHV0aWwuaXNOb2RlIC8vaGFzIHRvIGJlY29tZSBwYXJ0IG9mIHV0aWxcbiAgLCBWID0gcmVxdWlyZSgnLi4vLi4vJylcbiAgLCBsb2cgPSBkZWJ1Zy5sb2cgPSByZXF1aXJlKCcuL2xvZycpXG4gICwgZGVidWdsb2cgPSBsb2cubG9nZ2VyKCdERUJVRyQnLCAncmFpbmJvdycpXG5cbmRlYnVnLnBlcmYgPSBkZWJ1Zy5wZXJmb3JtYW5jZSA9IHJlcXVpcmUoJy4vcGVyZm9ybWFuY2UnKVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5pZighaXNOb2RlKSB7XG4gIGRlYnVnLmNhc2VzID0gcmVxdWlyZSgnLi4vLi4vYnJvd3Nlci9jYXNlcy8nKVxuICBleHBvcnRzLmJvZHkgPSBkb2N1bWVudC5ib2R5LmJhc2VcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZS5leHBvcnRzLCAnZG9tYWluJywge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAvL2RlYnVnZ2VyIC0tLSBjYW4gZ28gYXdheSB3aXRoIGEgdHJhbnNmb3JtXG4gICAgICByZXR1cm4gU3RyaW5nKHdpbmRvdy5sb2NhdGlvbilcbiAgICAgICAgLm1hdGNoKC9odHRwcz86XFwvXFwvKFteXFwvXSspLylbMV1cbiAgICAgICAgLnJlcGxhY2UoLzouKy8sICcnKVxuICAgIH1cbiAgfSlcblxufSBlbHNlIHtcbiAgdmFyIERFQlVHID0gcHJvY2Vzcy5lbnYuREVCVUdcbiAgaWYoREVCVUcpe1xuICAgIHZhciBsZXZlbHMgPSBERUJVRy5zcGxpdCgnLCcpXG4gICAgZm9yKHZhciBsIGluIGxldmVscyl7XG4gICAgICB2YXIgdHdvID0gbGV2ZWxzW2xdLnNwbGl0KCc6JylcbiAgICAgIERFQlVHJC5sZXZlbFt0d29bMF1dID0gdHdvWzFdID8gTnVtYmVyKHR3b1sxXSkgOiAzXG4gICAgfVxuICB9XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV4cG9ydHMuaW50ID0gZnVuY3Rpb24ocmFuZCwgZm4pIHtcbiAgZnVuY3Rpb24gZnVuYygpIHtcbiAgICByYW5kID0gcmFuZHx8MTAwMFxuICAgIHJldHVybiB+fihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkqcmFuZCkpXG4gIH1cbiAgcmV0dXJuIGZuID8gZnVuYygpIDogZnVuY1xufVxuXG5leHBvcnRzLnRleHQgPSBmdW5jdGlvbiAobGVuZ3RoLCBmbiwgc3RyLCBub2xpbmVzLCBzdHJpY3QpIHtcbiAgaWYgKGZuKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMudGV4dChcbiAgICAgICAgTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogbGVuZ3RoKSArIDEsIGZhbHNlLCBzdHIsIG5vbGluZXMsIHN0cmljdFxuICAgICAgKVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgcyA9IFsnLicsICcuJywgJy4nLCAnOycsICcsJ11cbiAgICAgICwgYiA9IFsnYWInLCAnYWJsZScsICd6bycsICd4JywgJ2xheCcsICdidXInLCAncmVtJywgJ2x1cicsICdmdXInLCAnanVyJywgJ2xleCcsICdyZXgnLCAnd3VyZCcsXG4gICAgICAgICdzaHVyJywgJ2J1cm4nLCAnaGVwcycsICdhJywgJ2knLCAneScsICd1JywgJ2UnLCAncCcsICdsJywgJ3NwbHVyZiddXG4gICAgICAsIG91dHB1dCA9ICcnXG4gICAgICAsIG5vc3BhY2UgPSAwXG5cbiAgICBpZiAoc3RyKSBiID0gc3RyXG5cbiAgICBzdHIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYltNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiAoYi5sZW5ndGggLSAxKSldXG4gICAgfVxuICAgIGlmICghbGVuZ3RoKSBsZW5ndGggPSB+fiAoTWF0aC5yYW5kb20oKSAqIDEwMSlcbiAgICBmb3IgKHZhciBpID0gMCwgZzsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoICFzdHJpY3QgJiYgKCFvdXRwdXRbb3V0cHV0Lmxlbmd0aCAtIDFdXG4gICAgICAgIHx8IG91dHB1dFtvdXRwdXQubGVuZ3RoIC0gMl0gPT09ICcuJ1xuICAgICAgICB8fCBvdXRwdXRbb3V0cHV0Lmxlbmd0aCAtIDJdID09PSAnXFxuJylcbiAgICAgICkge1xuICAgICAgICBnID0gc3RyKClcbiAgICAgICAgb3V0cHV0ICs9IGdbMF0udG9VcHBlckNhc2UoKSArIGcuc2xpY2UoMSlcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBvdXRwdXQgKz0gc3RyKClcbiAgICAgIH1cbiAgICAgIG5vc3BhY2UrK1xuICAgICAgaWYgKCFzdHJpY3QgJiYgfn4oTWF0aC5yYW5kb20oKSAqIChub3NwYWNlIC8gMikpKSB7XG4gICAgICAgIHZhciBiciA9IGZhbHNlXG4gICAgICAgICAgLCB2XG4gICAgICAgIGlmICghbm9saW5lcyAmJiB+fihNYXRoLnJhbmRvbSgpICogMjEpID4gMTcpIHtcbiAgICAgICAgICB2ID0gc1t+fihNYXRoLnJhbmRvbSgpICogKHMubGVuZ3RoIC0gMSkpXVxuICAgICAgICAgIG91dHB1dCArPSB2XG4gICAgICAgICAgaWYgKHYgPT09ICcuJyAmJiB+fihNYXRoLnJhbmRvbSgpICogMTEpID4gNikge1xuICAgICAgICAgICAgYnIgPSB0cnVlXG4gICAgICAgICAgICBvdXRwdXQgKz0gJ1xcbidcbiAgICAgICAgICAgIGlmICh+fihNYXRoLnJhbmRvbSgpICogMTEpID4gNykgb3V0cHV0ICs9ICdcXG4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJyKSBvdXRwdXQgKz0gJyAnXG4gICAgICAgIG5vc3BhY2UgPSAwXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxufVxuXG5leHBvcnRzLmRhdGEgPSBmdW5jdGlvbiAocG9wdWxhdGUsIGxldmVsLCBvYmosIGNudCwgcHJldikge1xuICBpZiAoIW9iaikgb2JqID0ge31cbiAgaWYgKCFjbnQpIGNudCA9IDBcbiAgaWYgKCFsZXZlbCkgbGV2ZWwgPSAwXG4gIGZvciAodmFyIGkgaW4gcG9wdWxhdGUpIHtcbiAgICBpZiAoKHBvcHVsYXRlW2ldIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgJiYgcG9wdWxhdGVbaV0ubGVuZ3RoICYmIHBvcHVsYXRlW2ldLnZhbFxuICAgICkge1xuICAgICAgaWYgKHBvcHVsYXRlICYmIHBvcHVsYXRlW2ldKSB7XG4gICAgICAgIG9ialtpXSA9IFtdXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9wdWxhdGVbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBvYmpbaV1bal0gPSB0eXBlb2YgcG9wdWxhdGVbaV0udmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHBvcHVsYXRlW2ldLnZhbCgpXG4gICAgICAgICAgICA6IGV4cG9ydHMuZGF0YShwb3B1bGF0ZVtpXS52YWwsIChsZXZlbCArIDEpLCBmYWxzZSwgaiArIDEsIG9iailcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICgocG9wdWxhdGVbaV0gaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgICAmJiAodHlwZW9mIHBvcHVsYXRlW2ldICE9PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgb2JqW2ldID0gZXhwb3J0cy5kYXRhKHBvcHVsYXRlW2ldLCAobGV2ZWwgKyAxKSwgb2JqW2ldLCBmYWxzZSwgY250LCBvYmopXG4gICAgfVxuICAgIGVsc2UgaWYgKHBvcHVsYXRlICYmIHBvcHVsYXRlW2ldKSB7XG4gICAgICBvYmpbaV0gPSAodHlwZW9mIHBvcHVsYXRlW2ldID09PSAnZnVuY3Rpb24nKVxuICAgICAgPyBwb3B1bGF0ZVtpXS5jYWxsKG9iaiwgY250LCBwcmV2KVxuICAgICAgOiBwb3B1bGF0ZVtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9iajtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5kZWJ1Zy5kb3dubG9hZCA9IGZ1bmN0aW9uKGZpbGVuYW1lLCB0ZXh0KSB7XG4gIHZhciBwb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIHBvbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgsJyArIGVuY29kZVVSSUNvbXBvbmVudCh0ZXh0KSk7XG4gIHBvbS5zZXRBdHRyaWJ1dGUoJ2Rvd25sb2FkJywgZmlsZW5hbWUpO1xuICBwb20uY2xpY2soKTtcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmRlYnVnLnJlbW90ZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHZhciBmaWxlcmVmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgZmlsZXJlZi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwidGV4dC9qYXZhc2NyaXB0XCIpXG4gIGZpbGVyZWYuc2V0QXR0cmlidXRlKFwic3JjXCIsICdodHRwOi8vanNjb25zb2xlLmNvbS9yZW1vdGUuanM/JytpZClcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZENoaWxkKGZpbGVyZWYpXG59XG5cbmRlYnVnLmZpbmRTY3JpcHQgPSBmdW5jdGlvbihub2RlLG5hbWUsc3RyaWN0KSB7XG5cbiAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzXG4gICAgLCBleHRlbnNpb24gPSBuYW1lLm1hdGNoKC9cXC4oW2EtekEtWjAtOV17MSwzMH0pJC8pWzFdXG4gICAgLCByZWdFeHAgPSAhc3RyaWN0ICYmIG5ldyBSZWdFeHAobmFtZSsnJCcpXG4gICAgLCBmaWVsZCA9IGV4dGVuc2lvbiA9PT0gJ2pzJyA/ICdzcmMnIDogJ2hyZWYnXG5cbiAgZm9yKHZhciBpIGluIGNoaWxkcmVuKSB7XG5cbiAgICBpZihzdHJpY3QgPyBjaGlsZHJlbltpXVtmaWVsZF09PT1uYW1lIDogcmVnRXhwLnRlc3QoY2hpbGRyZW5baV1bZmllbGRdKSkge1xuICAgICAgcmV0dXJuIGNoaWxkcmVuW2ldXG4gICAgfVxuXG4gIH1cblxuICAvLyBjb25zb2xlLmxvZygnbm90Zm91bmQnLCBuYW1lKVxufVxuXG5mdW5jdGlvbiBwcm9tcHR5IChtc2csIHZhbHVlLCBjYikge1xuICAgIHZhciBkaWFsb2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgICAgICwgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpXG4gICAgICAgICwgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIilcbiAgICAgICAgLCBvayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIilcbiAgICAgICAgLCBjYW5jZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpXG4gICAgcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShtc2cpKVxuICAgIGlucHV0LnR5cGUgPSBcInRleHRcIlxuICAgIGlucHV0LnZhbHVlID0gdmFsdWVcbiAgICBpbnB1dC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiXG4gICAgb2suYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJPS1wiKSlcbiAgICBjYW5jZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJDYW5jZWxcIikpXG4gICAgb2suYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGhpZGVEaWFsb2coKVxuICAgICAgICBjYihpbnB1dC52YWx1ZSlcbiAgICB9KVxuICAgIGNhbmNlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaGlkZURpYWxvZygpXG4gICAgICAgIGNiKG51bGwpXG4gICAgfSlcbiAgICBkaWFsb2cuYXBwZW5kQ2hpbGQocClcbiAgICBkaWFsb2cuYXBwZW5kQ2hpbGQoaW5wdXQpXG4gICAgZGlhbG9nLmFwcGVuZENoaWxkKG9rKVxuICAgIGRpYWxvZy5hcHBlbmRDaGlsZChjYW5jZWwpXG4gICAgZGlhbG9nLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiXG4gICAgZGlhbG9nLnN0eWxlLnRvcCA9IDI1ICsgXCJweFwiXG4gICAgZGlhbG9nLnN0eWxlLmxlZnQgPSA1MCArIFwicHhcIlxuICAgIGRpYWxvZy5zdHlsZS56SW5kZXggPSAxMDAwXG4gICAgZGlhbG9nLnN0eWxlLmZvbnRTaXplID0gIDI0ICsgJ3B4J1xuICAgIGRpYWxvZy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIndoaXRlXCJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGRpYWxvZylcbiAgICBmdW5jdGlvbiBoaWRlRGlhbG9nKCkge1xuICAgICAgICBkaWFsb2cucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChkaWFsb2cpXG4gICAgfVxufVxuXG5kZWJ1Zy5uYXRpdmUgPSBmdW5jdGlvbihkZWYsIHBhcnNlLCBjYiwgZmlsZSkge1xuICBpZighZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldicpKSB7XG4gICAgdmFyIGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIGVsZW0uaWQgPSAnZGV2J1xuICAgIGVsZW0uc3R5bGUuekluZGV4ID0gOTk5OTk5OVxuICAgIGVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXG4gICAgZWxlbS5zdHlsZS5sZWZ0ID0gJzJweCdcbiAgICBlbGVtLnN0eWxlLnRvcCA9ICc4MHB4J1xuICAgIGVsZW0uc3R5bGUucGFkZGluZyA9ICcxNXB4J1xuICAgIGVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoNTAsNTAsNTAsMC44KSdcbiAgICBlbGVtLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc1MCUnXG4gICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKSB7XG4gICAgICBwcm9tcHR5KCdJUCcsIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkZXZpcCcpIHx8IGRlZiB8fCAnaHR0cDovLzEwLjAuMS4yOjgwODAnLCBmdW5jdGlvbiAoaXApIHtcbiAgICAgICAgaWYgKGlwKSB7XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2RldmlwJyxpcClcbiAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYWxlcnQoJ3gnKVxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdkZXZpcCcpXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGVsZW0pXG4gIH1cblxuICBpZighZmlsZSkge1xuICAgIGZpbGUgPSAnYnVpbGQnXG4gIH1cblxuICBpZiggbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2RldmlwJykgKSB7XG4gICAgREVCVUckLnJlbW90ZVJlc291cmNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkZXZpcCcpKycvYnVuZGxlLmNzcycsZmlsZSsnLmNzcycsZmFsc2UpXG4gICAgaWYoREVCVUckLnJlbW90ZVJlc291cmNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdkZXZpcCcpKycvYnVuZGxlLmpzJyxmaWxlKycuanMnLGZhbHNlKSkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RldicpLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMjU1LDAsMC44KSdcbiAgICAgIGlmKGNiKSBjYihsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnZGV2aXAnKSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBcbiAgfVxufVxuXG4vL2hpZXIgcmVtb3RlcmVzb3VyY2UgZ2VicnVpa2VuXG5kZWJ1Zy5yZW1vdGVSZXNvdXJjZSA9IGZ1bmN0aW9uKHNyYywgcmVwbGFjZSwgc3RyaWN0KSB7XG4gIGNvbnNvbGUubG9nKCdyZW1vdGUgcmVzb3VyY2UnLHNyYylcbiAgdmFyIHN0cmljdCA9IHN0cmljdCAhPT0gdm9pZCAwID8gc3RyaWN0IDogdHJ1ZVxuICAgICwgZXh0ZW5zaW9uID0gc3JjLm1hdGNoKC9cXC4oW2EtekEtWjAtOV17MSwzMH0pJC8pWzFdXG4gICAgLCBmaWxlcmVmID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChleHRlbnNpb249PT0nanMnID8gJ3NjcmlwdCcgOiAnbGluaycpXG4gICAgLCBoZWFkID0gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXVxuICAgICwgYm9keSA9IGRvY3VtZW50LmJvZHlcbiAgICAsIGZvdW5kXG4gICAgLCBmaWxlU3JjXG5cbiAgaWYoIXJlcGxhY2UpIHtcbiAgICBzdHJpY3QgPSBmYWxzZVxuICAgIHJlcGxhY2UgPSBzcmMubWF0Y2goZXh0ZW5zaW9uPT09J2pzJ1xuICAgICAgPyAvKFxcLykoW2EtekEtWjAtOS1fKyRdKXswLDMwfVxcLmpzJC9cbiAgICAgIDogLyhcXC8pKFthLXpBLVowLTktXyskXSl7MCwzMH1cXC5jc3MkL1xuICAgIClbMF0uc2xpY2UoMSlcblxuXG4gIH1cblxuICBmaWxlU3JjID0gc3JjKyc/Jysgfn4oTWF0aC5yYW5kb20oKSo5OTk5OTk5KVxuXG4gIGlmKGV4dGVuc2lvbj09PSdqcycpIHtcbiAgICBmaWxlcmVmLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJ0ZXh0L2phdmFzY3JpcHRcIilcbiAgICBmaWxlcmVmLnNldEF0dHJpYnV0ZShcInNyY1wiLCBmaWxlU3JjKVxuICB9IGVsc2Uge1xuICAgIGZpbGVyZWYuc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcInRleHQvY3NzXCIpXG4gICAgZmlsZXJlZi5zZXRBdHRyaWJ1dGUoXCJyZWxcIiwgXCJzdHlsZXNoZWV0XCIpXG4gICAgZmlsZXJlZi5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsIGZpbGVTcmMpXG4gICAgZmlsZXJlZi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBmaWxlU3JjKVxuICB9XG5cbiAgZm91bmQgPSBkZWJ1Zy5maW5kU2NyaXB0KGhlYWQscmVwbGFjZSxzdHJpY3QpXG5cbiAgaWYoIWZvdW5kKSB7XG4gICAgICBjb25zb2xlLmxvZyhib2R5LCBmb3VuZCwgJyFAIUAjIUAjSlMnKVxuXG4gICAgZm91bmQgPSBkZWJ1Zy5maW5kU2NyaXB0KGJvZHkscmVwbGFjZSxzdHJpY3QpXG4gIH1cbiAgaWYoZm91bmQpIHtcblxuICAgIGNvbnNvbGUubG9nKCdyZW1vdGUgcmVzb3VyY2UgZm91bmQ6Jyxmb3VuZCwgZm91bmQuc3JjICwgZmlsZVNyYywgc3JjKVxuXG4gICAgdmFyIHBhcmVudCA9IGZvdW5kLnBhcmVudE5vZGVcbiAgICBpZihTdHJpbmcoZm91bmQuc3JjKS5pbmRleE9mKHNyYyk+LTEpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHBhcmVudC5yZW1vdmVDaGlsZChmb3VuZClcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZmlsZXJlZilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG4iLCJ2YXIgZGVidWcgPSByZXF1aXJlKCcuLycpIFxuICAsIHV0aWwgPSByZXF1aXJlKCcuLi8nKSBcbiAgLCBpc05vZGUgPSB1dGlsLmlzTm9kZSAvL2hhcyB0byBiZWNvbWUgcGFydCBvZiB1dGlsXG4gICwgViA9IHJlcXVpcmUoJy4uLy4uLycpXG4gICwgcmVwbFxuICAsIGNvbG9yc1xuICAsIG9yaWdDb25zb2xlID0gY29uc29sZVxuICAsIGNvbG9ycyA9IHtcbiAgICAgIGdyZWVuOicjNTZkYjY4JyxcbiAgICAgIHJlZDonI2ZmMDAwMCcsXG4gICAgICBncmV5OicjY2NjJyxcbiAgICAgIHllbGxvdzonI2UwZTY3YycsXG4gICAgICBjeWFuOicjMDBmZmZmJyxcbiAgICAgIG1hZ2VudGE6JyNmZjAwZmYnLFxuICAgICAgYmx1ZTonIzExMTFmZicsXG4gICAgICB3aGl0ZTonI2ZmZidcbiAgICB9XG4gICwgc3R5bGVzID0ge1xuICAgICAgYm9sZDonZm9udC13ZWlnaHQ6Ym9sZDtmb250LXNpemU6MTZweDtsaW5lLWhlaWdodDoxNXB4JyxcbiAgICAgIHVuZGVybGluZTonYm9yZGVyLWJvdHRvbToxcHggc29saWQnLFxuICAgICAgaXRhbGljOidmb250LXN0eWxlOml0YWxpYycsXG4gICAgICBpbnZlcnNlOmZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIGlmKGNvbG9yKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbG9yKyc7YmFja2dyb3VuZC1jb2xvcjojMzMzO3BhZGRpbmc6NXB4O2xpbmUtaGVpZ2h0OjIwcHgnXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICdjb2xvcjonK2NvbG9ycy53aGl0ZSsnO2JhY2tncm91bmQtY29sb3I6IzMzMztwYWRkaW5nOjVweDtsaW5lLWhlaWdodDoyMHB4J1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG5kZWJ1Zy5sZXZlbCA9IFxueyBERUJVRyQ6IEluZmluaXR5XG4sIHRlc3Q6MlxufVxuXG5cblxuLypcbmJvbGRcbml0YWxpY1xudW5kZXJsaW5lXG5pbnZlcnNlXG55ZWxsb3dcbmN5YW5cbndoaXRlXG5tYWdlbnRhXG5ncmVlblxucmVkXG5ncmV5XG5ibHVlXG5yYWluYm93XG56ZWJyYVxucmFuZG9tXG4qL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgbG9nT2JqZWN0XG4gICwgcGFyc2VPYmplY3RcbiAgLCBMT0dcbiAgLCBJTkZPXG4gICwgRVJST1JcbiAgLCBERVRBSUxcblxuaWYgKCFpc05vZGUpIHsgXG5cbiAgTE9HID0gJzonXG4gIElORk8gPSAnOjonXG4gIEVSUk9SID0gJ0VSUkVYISdcbiAgREVUQUlMID0gJzo6OidcblxuICAvLyBjb25zb2xlID0ge31cbiAgZnVuY3Rpb24gbG9nbGluayhpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gY29uc29sZS5sb2coaSwgYXJndW1lbnRzKVxuICAgICAgLy8gY29uc29sZS5sb2cobmV3IEVycm9yKCkuc3RhY2spXG5cbiAgICAgIG9yaWdDb25zb2xlW2ldLmFwcGx5KG9yaWdDb25zb2xlLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG5cbiAgLy8gZm9yKHZhciBpIGluIG9yaWdDb25zb2xlKSB7XG4gIC8vICAgaWYoaSAhPT0gJ2xvZycpIGNvbnNvbGVbaV0gPSBsb2dsaW5rKGkpXG4gIC8vIH1cblxuICB2YXIgQ29sb3IgPSBmdW5jdGlvbih2YWwsY29kZSxzKSB7XG4gICAgdGhpcy5jb2xvciA9ICAocyA/IGNvZGUgOiAnY29sb3I6ICcrY29kZSkrJzsnXG4gICAgdGhpcy52YWwgPSBuZXcgU3RyaW5nKCclYycrdmFsKVxuICB9XG4gIFxuICAvLyBjb25zb2xlLmxvZyA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vICAgdmFyIG5leHQgPSBmYWxzZVxuXG4gIC8vICAgZm9yKHZhciBpPTAsIGFyZywgcmFyZ3M9W10sIGFyZ3MgPSBhcmd1bWVudHMsbGVuID0gYXJncy5sZW5ndGg7aTxsZW47aSsrKSB7XG4gIC8vICAgICBhcmcgPSBhcmdzW2ldXG4gIC8vICAgICBpZihhcmcgaW5zdGFuY2VvZiBDb2xvcikge1xuICAvLyAgICAgICBpZihyYXJncy5sZW5ndGgpe1xuICAvLyAgICAgICAgIG5leHQgPSB1dGlsLmFyZyhhcmdzLCBpKVxuICAvLyAgICAgICAgIGJyZWFrXG4gIC8vICAgICAgIH1lbHNle1xuICAvLyAgICAgICAgIHJhcmdzLnB1c2goYXJnLnZhbC52YWx1ZU9mKCksIGFyZy5jb2xvcilcbiAgLy8gICAgICAgfVxuICAvLyAgICAgICAvLyBsb2dnZXIoYXJnLnZhbC52YWx1ZU9mKCksIGFyZy5jb2xvcilcbiAgLy8gICAgIH0gZWxzZSB7XG4gIC8vICAgICAgIHJhcmdzLnB1c2goYXJnKVxuICAvLyAgICAgfVxuICAvLyAgIH1cbiAgLy8gICAvLyBsb2dnZXIoJ25vdyBsb2cnLCByYXJncylcbiAgLy8gICBpZihyYXJncy5sZW5ndGgpIGxvZ2dlci5hcHBseShvcmlnQ29uc29sZSxyYXJncylcbiAgLy8gICAvLyBsb2dnZXIoJ25leHQnLCBuZXh0KVxuICAvLyAgIGlmKG5leHQubGVuZ3RoKSBjb25zb2xlLmxvZy5hcHBseShudWxsLG5leHQpXG5cbiAgLy8gfVxuXG4gIGZ1bmN0aW9uIGNvbG9yKGksIENsYXNzLCBzdHlsZSkge1xuICAgIHV0aWwuZGVmaW5lKENsYXNzIHx8IFN0cmluZyxpLHtcbiAgICAgIGdldDpmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoQ2xhc3MpIHtcbiAgICAgICAgICBpZih0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSBzdHlsZSh0aGlzLmNvbG9yKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yKz0oc3R5bGV8fCgnY29sb3I6Jytjb2xvcnNbaV0pKSsnOydcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcyA9IGNvbG9yc1tpXVxuICAgICAgICAgIGlmKHN0eWxlKSB7XG4gICAgICAgICAgICBpZih0eXBlb2Ygc3R5bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcyA9IHN0eWxlKClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM9c3R5bGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLHMsc3R5bGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgLy8gZnVuY3Rpb24gbG9nZ2VyKCkge1xuXG5cbiAgLy8gICBvcmlnQ29uc29sZS5sb2cuYXBwbHkob3JpZ0NvbnNvbGUsYXJndW1lbnRzKVxuXG5cbiAgLy8gfVxuXG4gIC8vIGZvcih2YXIgaSBpbiBjb2xvcnMpIHsgY29sb3IoaSkgfVxuICAvLyBmb3IodmFyIGkgaW4gc3R5bGVzKSB7IGNvbG9yKGksIGZhbHNlLCBzdHlsZXNbaV0pIH0gIFxuICAvLyBmb3IodmFyIGkgaW4gY29sb3JzKSB7IGNvbG9yKGksIENvbG9yKSB9XG4gIC8vIGZvcih2YXIgaSBpbiBzdHlsZXMpIHsgY29sb3IoaSwgQ29sb3IsIHN0eWxlc1tpXSkgfSAgXG5cbiAgcGFyc2VPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZih0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykgcmV0dXJuIG9ialxuICAgIHZhciBzdHIgPSAnJ1xuICAgIGZvcih2YXIgaSBpbiBvYmopIHtcbiAgICAgIHN0ciArPSBpICsgJyA6ICcgKyAodHlwZW9mIG9ialtpXSA9PT0gJ3N0cmluZycgXG4gICAgICAgID8gIG9ialtpXSBcbiAgICAgICAgOiBKU09OLnN0cmluZ2lmeShvYmpbaV0sZmFsc2UsMikpIFxuICAgICAgKyAnXFxuJ1xuICAgIH1cbiAgICByZXR1cm4gc3RyLmludmVyc2UuZ3JlZW5cbiAgfVxuICBcbiAgbG9nT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgY29uc29sZS5sb2cocGFyc2VPYmplY3Qob2JqKSlcbiAgfVxuICBcbn0gZWxzZSB7XG4gIHJlcGwgPSByZXF1aXJlKCdyZXBsJylcbiAgY29sb3JzID0gcmVxdWlyZSgnY29sb3JzJylcblxuICBMT0cgPSAnbG9nICAnLmdyZXlcbiAgSU5GTyA9ICdpbmZvICcuZ3JlZW5cbiAgRVJST1IgPSAnZXJyb3InLnJlZFxuICBERVRBSUwgPSAnLS0tLS0nLmdyZXlcblxuICBkZWJ1Zy5yZXBsID0gZnVuY3Rpb24oKSB7XG4gICAgcmVwbC5zdGFydCgnPicpXG4gICAgcmV0dXJuIGRlYnVnXG4gIH1cbiAgaWYocmVwbC5jb250ZXh0KSByZXBsLmNvbnRleHQuREVCVUckID0gREVCVUckXG5cbiAgY29uc29sZS5ncm91cCA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdcXG5fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fJy5ncmV5KVxuICB9ICAgICAgXG4gIGNvbnNvbGUuZ3JvdXBFbmQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZygnX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX1xcbicuZ3JleSlcbiAgfVxuICB2YXIgbl91dGlsID0gcmVxdWlyZSgndXRpbCcpXG4gIHBhcnNlT2JqZWN0ID0gZnVuY3Rpb24ob2JqKXtcbiAgICByZXR1cm4gbl91dGlsLmluc3BlY3Qob2JqLHtjb2xvcnM6dHJ1ZSwgZGVwdGg6IDUwfSlcbiAgfVxuICBsb2dPYmplY3QgPSBmdW5jdGlvbihvYmope1xuICAgIGNvbnNvbGUubG9nKHBhcnNlT2JqZWN0KG9iaikpXG4gIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudXRpbC5kZWZpbmUoT2JqZWN0LCdERUJVRyRsb2cnLCBmdW5jdGlvbihtc2cscykge1xuICBpZihjb25zb2xlLmdyb3VwKSBjb25zb2xlLmdyb3VwKClcbiAgaWYodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICBtc2cgPSBtc2dcbiAgfSBlbHNlIHtcbiAgICBtc2cgPSBmYWxzZVxuICB9XG4gIHZhciBoID0gJ0pTT04gJysobXNnfHwnIG5vcm1hbCcpXG4gIGRlYnVnLmxvZy5oZWFkZXIoaClcbiAgaWYoZGVidWcubGV2ZWwudGVzdD4xKSBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeSh0aGlzLGZhbHNlLDIpKVxuICBpZihzKSB7XG4gICAgY29uc29sZS5sb2coJ1xcbicpXG4gICAgZGVidWcubG9nLmZuLmFwcGx5KHRoaXMsdXRpbC5hcmcoYXJndW1lbnRzLDEpKSBcbiAgfVxuICAvLyBkZWJ1Zy5sb2cuZW5kKGgpXG4gIGlmKGNvbnNvbGUuZ3JvdXApIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcyxmYWxzZSwyKVxufSlcblxuaWYoIWlzTm9kZSAmJiBsb2NhbFN0b3JhZ2UpIHtcbiAgdXRpbC5kZWZpbmUobG9jYWxTdG9yYWdlLCdERUJVRyRsb2cnLCBmdW5jdGlvbihtc2cscykge1xuICAgIGlmKGNvbnNvbGUuZ3JvdXApIGNvbnNvbGUuZ3JvdXAoKVxuICAgIGlmKHR5cGVvZiBtc2cgPT09ICdzdHJpbmcnKSB7XG4gICAgICBtc2cgPSBtc2dcbiAgICB9IGVsc2Uge1xuICAgICAgbXNnID0gZmFsc2VcbiAgICB9XG4gICAgdmFyIGggPSAnbG9jYWxTdG9yYWdlICcrKG1zZ3x8JyBub3JtYWwnKVxuICAgIGRlYnVnLmxvZy5oZWFkZXIoaClcblxuICAgIHZhciBvYmogPSB7fVxuICAgIGZvcih2YXIgaSBpbiB0aGlzKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZyhpLCB0aGlzKVxuICAgICAgIHRyeSB7IG9ialtpXSA9SlNPTi5wYXJzZSh0aGlzW2ldKSB9IGNhdGNoKGUpe1xuICAgICAgICBvYmpbaV0gPSB0aGlzW2ldXG4gICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKClcblxuICAgIGlmKGRlYnVnLmxldmVsLnRlc3Q+MSkgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkob2JqLGZhbHNlLDIpKVxuICAgIGlmKHMpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdcXG4nKVxuICAgICAgZGVidWcubG9nLmZuLmFwcGx5KHRoaXMsdXRpbC5hcmcoYXJndW1lbnRzLDEpKSBcbiAgICB9XG4gICAgLy8gZGVidWcubG9nLmVuZChoKVxuICAgIGlmKGNvbnNvbGUuZ3JvdXApIGNvbnNvbGUuZ3JvdXBFbmQoKVxuICAgIHJldHVybiBvYmpcbiAgfSlcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGxvZyA9IG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IHtcbiAgc3RhY2s6IGZhbHNlLFxuICBpOmZ1bmN0aW9uKG5yKSB7XG4gICAgbnIgPSB0aGlzLmluZGVudFxuICAgIHZhciBzdHIgPSAnJ1xuICAgIGZvcih2YXIgaSBpbiBucikge1xuICAgICAgc3RyKz0nICAnXG4gICAgfVxuICAgIHJldHVybiBzdHJcbiAgfSxcbiAgcGFyc2U6IHBhcnNlT2JqZWN0LFxuICBvYmplY3Q6IGxvZ09iamVjdCxcbiAgZGVmYXVsdDogZnVuY3Rpb24obGFiZWwsIGxldmVsKXtcbiAgICBpZihsYWJlbCBpbnN0YW5jZW9mIE9iamVjdClcbiAgICAgIGZvcih2YXIgbCBpbiBsYWJlbClcbiAgICAgICAgc2V0RGVmYXVsdChsLCBsYWJlbFtsXSlcbiAgICBlbHNlXG4gICAgICBzZXREZWZhdWx0KGxhYmVsLCBsZXZlbClcbiAgfSxcbiAgbG9nZ2VyOmZ1bmN0aW9uKGxhYmVsLCBjb2xvciwgbGV2ZWwpe1xuICAgIGxvZy5kZWZhdWx0KGxhYmVsLCBsZXZlbCB8fCAxKVxuICAgIFxuICAgIGZ1bmN0aW9uIGxvZ2dlcigpe1xuICAgICAgdmFyIGxldmVsID0gZGVidWcubGV2ZWwuZ2xvYmFsICE9PSB1bmRlZmluZWQgPyBkZWJ1Zy5sZXZlbC5nbG9iYWwgOiBkZWJ1Zy5sZXZlbFtsYWJlbF1cbiAgICAgIGlmKGxldmVsID4gMikge1xuLy8gICAgICAgICBjb25zb2xlLmxvZy5hcHBseShudWxsLCBbbGFiZWxbY29sb3JdLmJvbGQsIExPR10uY29uY2F0KHV0aWwuYXJnKGFyZ3VtZW50cykpKVxuICAgICAgICBpZihsb2cuc3RhY2spIGNvbnNvbGUubG9nKHNtYWxsU3RhY2sobG9nLnN0YWNrKS5ncmV5KVxuICAgICAgfVxuICAgIH1cblxuICAgIGxvZ2dlci5pbmZvID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBsZXZlbCA9IGRlYnVnLmxldmVsLmdsb2JhbCAhPT0gdW5kZWZpbmVkID8gZGVidWcubGV2ZWwuZ2xvYmFsIDogZGVidWcubGV2ZWxbbGFiZWxdXG4gICAgICBpZihsZXZlbCA+IDEpIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkobnVsbCwgW2xhYmVsW2NvbG9yXS5ib2xkLCBJTkZPXS5jb25jYXQodXRpbC5hcmcoYXJndW1lbnRzKSkpXG4gICAgICAgIGlmKGxvZy5zdGFjaykgY29uc29sZS5sb2coc21hbGxTdGFjayhsb2cuc3RhY2spLmdyZXkpXG4gICAgICB9XG4gICAgICAgIFxuICAgIH1cbiAgICBsb2dnZXIuZXJyb3IgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGxldmVsID0gZGVidWcubGV2ZWwuZ2xvYmFsICE9PSB1bmRlZmluZWQgPyBkZWJ1Zy5sZXZlbC5nbG9iYWwgOiBkZWJ1Zy5sZXZlbFtsYWJlbF1cbiAgICAgIGlmKGxldmVsID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShudWxsLCBbbGFiZWxbY29sb3JdLmJvbGQsIEVSUk9SXS5jb25jYXQodXRpbC5hcmcoYXJndW1lbnRzKSkpXG4gICAgICAgIGlmKGxvZy5zdGFjaykgY29uc29sZS5sb2coc21hbGxTdGFjayhsb2cuc3RhY2spLmdyZXkpXG4gICAgICB9XG4gICAgfVxuICAgIGxvZ2dlci5kZXRhaWwgPSBmdW5jdGlvbigpe1xuICAgICAgdmFyIGxldmVsID0gZGVidWcubGV2ZWwuZ2xvYmFsICE9PSB1bmRlZmluZWQgPyBkZWJ1Zy5sZXZlbC5nbG9iYWwgOiBkZWJ1Zy5sZXZlbFtsYWJlbF1cbiAgICAgIGlmKGxldmVsID4gMykge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShudWxsLCBbbGFiZWxbY29sb3JdLmJvbGQsIERFVEFJTF0uY29uY2F0KHV0aWwuYXJnKGFyZ3VtZW50cykpKVxuICAgICAgICBpZihsb2cuc3RhY2spIGNvbnNvbGUubG9nKHNtYWxsU3RhY2sobG9nLnN0YWNrKS5ncmV5KVxuICAgICAgfSAgICAgIFxuICAgIH1cbiAgICBsb2dnZXIucGFyc2UgPSBwYXJzZU9iamVjdFxuICAgIHJldHVybiBsb2dnZXJcbiAgfSxcbiAgbGFiZWw6IGZ1bmN0aW9uKGxhYmVsLCBzdHlsZSwgbG9nKXtcbiAgICAgIGlmKGlzTm9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShudWxsLCBsb2cpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseSggbnVsbFxuICAgICAgICAgICwgWyclYyAnK2xhYmVsKycgJywgc3R5bGVdLmNvbmNhdChsb2cpXG4gICAgICAgIClcbiAgICAgIH1cbiAgfSxcbiAgaGVhZGVyOmZ1bmN0aW9uKG1zZykge1xuICAgIHRoaXMuX2xoID0gbXNnXG4gICAgY29uc29sZS5sb2cobXNnLmludmVyc2UpXG4gIH0sXG4gIGhlYWRlcjI6ZnVuY3Rpb24obXNnKSB7XG4gICAgdGhpcy5fbGggPSBtc2dcbiAgICBjb25zb2xlLmxvZyhtc2cuZ3JleS5pbnZlcnNlKVxuICB9LFxuICBlbmQ6ZnVuY3Rpb24obXNnKSB7XG4gICAgY29uc29sZS5sb2coKCdlbmQgWycrbXNnKyddJykuZ3JleS5pbnZlcnNlKVxuICB9LFxuICBsZXZlbDpmdW5jdGlvbihsZXZlbCxmaWVsZCkge1xuICAgIGlmKGxldmVsID49IGRlYnVnLmxldmVsLnRlc3QgXG4gICAgICB8fCAgZGVidWcubGV2ZWxbbGV2ZWxdIFxuICAgICAgfHwgZmllbGQgJiYgZGVidWcubGV2ZWxbbGV2ZWxdPj1maWVsZCApIFxuICAgICAgY29uc29sZS5sb2cuYXBwbHkodGhpcyx1dGlsLmFyZyhhcmd1bWVudHMsMSkpXG4gIH0sXG4gIGZuOmZ1bmN0aW9uKGFyZykge1xuICAgIGRlYnVnLmxvZy5pbmRlbnQrK1xuICAgIGlmKHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFyZy5jYWxsKHRoaXMsdXRpbC5hcmcoYXJndW1lbnRzLDEpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmxvZyhhcmd1bWVudHMpXG4vLyAgICAgICBjb25zb2xlLmxvZy5hcHBseSh0aGlzLGFyZ3VtZW50cylcbiAgICB9XG4gICAgZGVidWcubG9nLmluZGVudC0tXG4gIH0sXG4gIGluZGVudDowXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBzbWFsbFN0YWNrKGxpbmVzKXtcbiAgaWYoIWxpbmVzKSBsaW5lcyA9IDFcbiAgdmFyIHN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2suc3BsaXQoJ1xcbicpXG4gICAgLCBsID0gM1xuICAgICwgcmVzdWx0ID0gW11cbiAgICAsIGVuZFxuXG4gIHdoaWxlKGxpbmVzLS0pe1xuICAgIGxpbmUgPSBzdGFja1tsKytdXG4gICAgZW5kID0gbGluZVtsaW5lLmxlbmd0aC0xXSA9PT0gJyknID8gbGluZS5sZW5ndGgtMSA6IGxpbmUubGVuZ3RoXG4gICAgcmVzdWx0LnB1c2gobGluZS5zbGljZShsaW5lLmluZGV4T2YoJy8nKSwgZW5kKSlcbiAgfVxuXG4gIHJldHVybiByZXN1bHQuam9pbignXFxuJykuZ3JleVxuICBcbn1cblxuZnVuY3Rpb24gc2V0RGVmYXVsdChsYWJlbCwgbGV2ZWwpe1xuICBpZihkZWJ1Zy5sZXZlbFtsYWJlbF0gPT09IHZvaWQgMCkgZGVidWcubGV2ZWxbbGFiZWxdID0gbGV2ZWxcbn1cblxuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbi8vICAgY29uc29sZS5sb2coJ2xvZyBsZXZlbHM6XFxuJywgbG9nLnBhcnNlKGRlYnVnLmxldmVsKSlcbn0sMClcblxuLy9Mb2NhbHN0b3JhZ2VcblxuLypcbnZhciBsb2NhbFN0b3JhZ2VTcGFjZSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBhbGxTdHJpbmdzID0gJyc7XG4gICAgICAgIGZvcih2YXIga2V5IGluIHdpbmRvdy5sb2NhbFN0b3JhZ2Upe1xuICAgICAgICAgICAgaWYod2luZG93LmxvY2FsU3RvcmFnZS5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICBhbGxTdHJpbmdzICs9IHdpbmRvdy5sb2NhbFN0b3JhZ2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxsU3RyaW5ncyA/IDMgKyAoKGFsbFN0cmluZ3MubGVuZ3RoKjE2KS8oOCoxMDI0KSkgKyAnIEtCJyA6ICdFbXB0eSAoMCBLQiknO1xuICAgIH07XG5cbiovXG5cbnV0aWwuZGVmaW5lKGRlYnVnLCdsb2NhbFN0b3JhZ2VTaXplJywge1xuICBnZXQ6ZnVuY3Rpb24oKSB7XG4gIHZhciB0b3RhbCA9IDBcbiAgZm9yKHZhciB4IGluIGxvY2FsU3RvcmFnZSkge1xuICAgIHZhciBrYnl0ZXMgPSAoKCh4Lmxlbmd0aCtsb2NhbFN0b3JhZ2VbeF0ubGVuZ3RoKSkvKDEwMjQpKVxuICAgIHRvdGFsKz1rYnl0ZXNcbiAgICAvLyBjb25zb2xlLmxvZygoeCtcIjpcIitrYnl0ZXMudG9GaXhlZCgxMCkrXCIgS0JcIikuZ3JleSlcbiAgfVxuICBjb25zb2xlLmxvZygnTE9DQUwgU1RPUkFHRSBTSVpFIFRPVEFMJy5pbnZlcnNlLmdyZWVuLCAodG90YWwvMTAyNCkudG9GaXhlZCg1KSsnIE1CJylcbiAgcmV0dXJuIHRvdGFsKjEwMjRcbn1cbn0pXG5cbnV0aWwuZGVmaW5lKGRlYnVnLCdsb2NhbFN0b3JhZ2VLZXlzU2l6ZScsIHtcbiAgZ2V0OmZ1bmN0aW9uKCkge1xuICB2YXIgdG90YWwgPSAwXG4gIGZvcih2YXIgeCBpbiBsb2NhbFN0b3JhZ2UpIHtcbiAgICB2YXIga2J5dGVzID0gKCgoeC5sZW5ndGgpKS8oMTAyNCkpXG4gICAgdG90YWwrPWtieXRlc1xuICAgIC8vIGNvbnNvbGUubG9nKCh4K1wiOlwiK2tieXRlcy50b0ZpeGVkKDEwKStcIiBLQlwiKS5ncmV5KVxuICB9XG4gIGNvbnNvbGUubG9nKCdMT0NBTCBTVE9SQUdFIEtFWSBTSVpFIFRPVEFMJy5pbnZlcnNlLmdyZWVuLCAodG90YWwvMTAyNCkudG9GaXhlZCg1KSsnIE1CJylcbiAgcmV0dXJuIHRvdGFsKjEwMjRcbn1cbn0pXG5cblxuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi8nKSBcbiAgLCBkZWJ1ZyA9IHJlcXVpcmUoJy4vJykgXG4gICwgaXNOb2RlID0gdXRpbC5pc05vZGUgLy9oYXMgdG8gYmVjb21lIHBhcnQgb2YgdXRpbFxuICAsIG9zXG5cbmlmIChpc05vZGUpIHsgXG4gIG9zID0gcmVxdWlyZSgnb3MnKVxufSBlbHNlIHtcbiAgY29uc29sZS5sb2coJ0RFQlVHIFxcblxcbmlmIHlvdSB3YW50IHRvIGNoZWNrIG1lbW9yeSB1c2FnZSBzdGFydCBjaHJvbWUgdXNpbmc6IFxcblxcbiBvcGVuIC1hIEdvb2dsZVxcXFwgQ2hyb21lIC0tYXJncyAtLWVuYWJsZS1tZW1vcnktaW5mbyAtLWpzLWZsYWdzPVwiLS1leHBvc2UtZ2NcIlxcbicuZ3JleSlcbn1cblxuZnVuY3Rpb24gX3Rlc3QobWV0aG9kLCBuYW1lLCBjb21wbGV0ZSwgY2FsbCwgYXJncywgbm9sb2cpIHtcbiAgdmFyIHN0YXJ0ID0gZXhwb3J0cy5ub3coKVxuICAgICwgbWVtb3J5c3RhcnQgPSBleHBvcnRzLm1lbW9yeSgpXG4gICAgLCBtZW1vcnllbmRcbiAgICAsIG1lbVxuICAgICwgdGltZVxuICAgICwgZW5kXG4gICAgLCBzdWIgXG4gIGlmICghbmFtZSkgbmFtZSA9ICdURVNUIFBFUkZPUk1BTkNFJ1xuICBpZiAoY2FsbCkge1xuICAgIHN1YiA9IG1ldGhvZC5hcHBseShjYWxsLCBhcmdzKVxuICB9IFxuICBlbHNlIHtcbiAgICBzdWIgPSBtZXRob2QuYXBwbHkodGhpcywgYXJncylcbiAgfVxuICBlbmQgPSBleHBvcnRzLm5vdygpXG4gIG1lbW9yeWVuZCA9IGV4cG9ydHMubWVtb3J5KClcbiAgbWVtID0gKG1lbW9yeWVuZCAtIG1lbW9yeXN0YXJ0KVxuICB0aW1lID0gZW5kIC0gc3RhcnQgLSAoc3ViIHx8IDApXG4gIGlmIChjb21wbGV0ZSkge1xuICAgIGNvbXBsZXRlKCgodGltZSkgLyAxMDAwKSwgKG1lbW9yeWVuZCAtIG1lbW9yeXN0YXJ0KSlcbiAgfSBcbiAgZWxzZSBpZiAoIW5vbG9nKSB7XG4gICAgaWYoZGVidWcubGV2ZWwudGVzdD4wKSB7XG4gICAgICBjb25zb2xlLmxvZyggXG4gICAgICAgIG5hbWUuaW52ZXJzZSAsICdcXG5wYXJzZSB0aW1lOiAnIFxuICAgICAgICArICgoZW5kIC0gc3RhcnQpIC8gMTAwMCkgXG4gICAgICAgICsgJyBzZWMnICsgKG1lbSA/ICdcXG5tZW1vcnkgdXNlZCAoYXBwcm94aW1hdGUpOiAnIFxuICAgICAgICArIG1lbSArICcgYnl0ZXMnIDogJycpXG4gICAgICApXG4gICAgfVxuICB9XG4gIHJldHVybiB0aW1lXG59XG5cblxuXG52YXIgb2xkQ2hlY2sgPSBbXVxuZGVidWcuY291bnROZXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiggb2JqLCBhbW91bnQgKSB7XG4gIFxuICBhbW91bnQgPSB7dmFsOjB9XG5cbiAgdmFyIGNoZWNrbm93ID0gW11cblxuICBkZWJ1Zy5jb3VudExpc3RlbmVycyggb2JqLCBhbW91bnQsIGNoZWNrbm93ICkgXG5cbiAgdmFyIG5ld2xpc3RuZXJzID0gW11cblxuICBmb3IoIHZhciBpIGluIGNoZWNrbm93ICkge1xuXG4gICAgaWYoIHV0aWwuY2hlY2tBcnJheSggb2xkQ2hlY2ssIGNoZWNrbm93W2ldICkgPT09IGZhbHNlICkge1xuICAgICAgLy8gY29uc29sZS5sb2coY2hlY2tub3dbaV0pXG4gICAgICAvLyBpZiggdHlwZW9mIGNoZWNrbm93W2ldID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgY2hlY2tub3dbaV0gPT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdsZXRzIHB1c2gnKVxuICAgICAgICAvLyBpZighdXRpbC5lbXB0eShjaGVja25vd1tpXSkpIHtcbiAgICAgICAgbmV3bGlzdG5lcnMucHVzaCggY2hlY2tub3dbaV0gKVxuICAgICAgICAvLyB9XG4gICAgICAvLyB9XG4gICAgfVxuICB9XG5cbiAgb2xkQ2hlY2sgPSBjaGVja25vd1xuXG4gIHJldHVybiB7XG4gICAgYW1vdW50OiBhbW91bnQudmFsXG4gICwgbmV3Y2hlY2tzOiBuZXdsaXN0bmVyc1xuICB9XG5cbn1cblxuXG5kZWJ1Zy5jb3VudExpc3RlbmVycyA9IGZ1bmN0aW9uKG9iaiwgYW1vdW50LCBjaGVja2VkKSB7XG4gIHZhciBhbW91bnQgXG4gICAgLCBjaGVja2VkIFxuXG4gIGlmKCFjaGVja2VkKSB7XG4gICAgY2hlY2tlZCA9IFtdXG4gIH1cblxuICBpZih1dGlsLmNoZWNrQXJyYXkoY2hlY2tlZCwgb2JqKSE9PWZhbHNlIHx8ICFvYmopIHtcbiAgICByZXR1cm4gYW1vdW50LnZhbFxuICB9XG4gIGNoZWNrZWQucHVzaChvYmopXG5cbiAgaWYoIWFtb3VudCkgYW1vdW50ID0ge3ZhbDowfVxuICBpZihvYmouX2xpc3RlbmVycykge1xuICAgIGFtb3VudC52YWwrPW9iai5fbGlzdGVuZXJzLmxlbmd0aFxuICB9XG5cbiAgaWYoIW9iai5lYWNoKSB7XG5cbiAgICBpZihvYmogaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICAgIGZvcih2YXIgaSBpbiBvYmopIHtcbiAgICAgICAgaWYob2JqW2ldICYmICggb2JqW2ldLl9fdCB8fCBvYmpbaV0uX2Zyb20gfHwgb2JqLl9mcm9tICYmIGkgPT09J2Nsb3VkJykgKSBkZWJ1Zy5jb3VudExpc3RlbmVycyhvYmpbaV0sYW1vdW50LGNoZWNrZWQpXG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7XG5cbiAgICBvYmouZWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBkZWJ1Zy5jb3VudExpc3RlbmVycyh0aGlzLGFtb3VudCxjaGVja2VkKVxuICAgIH0pXG5cbiAgfVxuXG4gIHJldHVybiBhbW91bnQudmFsXG59XG5cbmRlYnVnLmNvdW50U3VicyA9IGZ1bmN0aW9uKG9iaiwgYW1vdW50LCBrZXkpIHtcbiAgdmFyIGFtb3VudCBcbiAgaWYoIWFtb3VudCkgYW1vdW50ID0ge3ZhbDowfVxuICBpZihvYmouX3N1YnMpIHtcbiAgICBjb25zb2xlLmxvZygnISEhISFTVUInLCBvYmouX3BhdGgsIG9iai5fc3VicylcbiAgICBhbW91bnQudmFsKz1vYmouX3N1YnMubGVuZ3RoXG4gIH1cbiAgICBcbiAgaWYoIW9iai5lYWNoKSB7XG4gICAgY29uc29sZS5sb2coJ25vIEVBQ0ghJywga2V5KVxuICB9XG4gIC8vIGNvbnNvbGUubG9nKG9iaiwgb2JqLl9zdWJzKVxuICBvYmouZWFjaChmdW5jdGlvbihpKSB7XG4gICAgZGVidWcuY291bnRTdWJzKHRoaXMsYW1vdW50LGkpXG4gIH0pXG4gIHJldHVybiBhbW91bnQudmFsXG59XG5cbmZ1bmN0aW9uIF9kb25lKHBhcmFtcywgdGltZSwgbWVtKSB7XG4gIGlmIChwYXJhbXMuY29tcGxldGUpIHtcbiAgICBwYXJhbXMuY29tcGxldGUodGltZSwgbWVtLCBwYXJhbXMsIGV4cG9ydHMuYXZlcmFnZSh0aW1lKVswXSwgZXhwb3J0cy5hdmVyYWdlKHRpbWUpWzFdKVxuICB9IGVsc2Uge1xuICAgIGlmKGRlYnVnLmxldmVsLnRlc3Q+MCkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgIHBhcmFtcy5uYW1lLmludmVyc2UgXG4gICAgICAgICwgJyBuPScgKyBwYXJhbXMubG9vcCBcbiAgICAgICAgKyAnXFxucGFyc2UgdGltZTonIFxuICAgICAgICArIChwYXJhbXMuZXh0ZW5zaXZlIFxuICAgICAgICAgID8gKCcgXFxuXFxuJyArIHRpbWUuam9pbignIHNlY1xcbicpICsgJyBzZWNcXG5cXG4nKSBcbiAgICAgICAgICA6ICcnKSBcbiAgICAgICAgKyAnYXZlcmFnZTogJyArIGV4cG9ydHMuYXZlcmFnZSh0aW1lKVsxXSBcbiAgICAgICAgKyAnIHNlY1xcbnRvdGFsOiAnIFxuICAgICAgICArIGV4cG9ydHMuYXZlcmFnZSh0aW1lKVswXSArICcgc2VjJylcbiAgICB9XG4gICAgLy8rKG1lbS5sZW5ndGg+MCA/ICdcXG5tZW1vcnkgdXNlZCAoYXBwcm94aW1hdGUpOiAnK21lbSsnIGtiJyA6ICcnKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmdW5jdGlvbiAocGFyYW1zLCBmbikge1xuICBpZiAoZm4gJiYgdHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gX3Rlc3QoZm4sIHBhcmFtcylcbiAgfSBcbiAgZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBfdGVzdChwYXJhbXMpXG4gIH0gXG4gIGVsc2UgaWYgKHBhcmFtcyBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIGlmKCFwYXJhbXMubmFtZSkgcGFyYW1zLm5hbWUgPSAncGVyZm9ybWFuY2UgdGVzdCdcblxuICAgIGlmIChwYXJhbXMubG9vcCkge1xuICAgICAgLy90ZXN0aW5nIG1lbW9yeSBpbiBsb29wIGlzIGhhcmQgc2luY2UgdGhlIGdjIGFsbW9zdCBuZXZlciBtYWtlcyBpdCBiZWZvcmUgbmV4dCBpdGVyYXRpb247XG4gICAgICB2YXIgdGltZSA9IFtdXG4gICAgICAgICwgbWVtID0gW11cbiAgICAgICAgLCBjYWxsYmFjayA9IGZ1bmN0aW9uIChfdGltZSwgbWVtb3J5KSB7XG4gICAgICAgICAgdGltZS5wdXNoKF90aW1lKVxuICAgICAgICAgIGlmIChtZW1vcnkpIG1lbS5wdXNoKG1lbW9yeSlcbiAgICAgICAgfVxuXG4gICAgICBpZihwYXJhbXMuaW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIGNudCA9IDBcbiAgICAgICAgICAsIGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGNudCsrXG4gICAgICAgICAgICAgIGlmKGNudD09PXBhcmFtcy5sb29wLTEpIHtcbiAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbClcbiAgICAgICAgICAgICAgICAgX2RvbmUocGFyYW1zLCB0aW1lLCBtZW0pIFxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF90ZXN0KHBhcmFtcy5tZXRob2QsIGZhbHNlLCBjYWxsYmFjaylcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxwYXJhbXMuaW50ZXJ2YWwpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gcGFyYW1zLmxvb3A7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICBfdGVzdChwYXJhbXMubWV0aG9kLCBmYWxzZSwgY2FsbGJhY2spXG4gICAgICAgIH1cbiAgICAgICAgX2RvbmUocGFyYW1zLCB0aW1lLCBtZW0pIFxuICAgICAgfSBcbiAgICAgIHJldHVybiBleHBvcnRzLmF2ZXJhZ2UodGltZSlcbiAgICB9IFxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIF90ZXN0KHBhcmFtcy5tZXRob2RcbiAgICAgICAgLCBwYXJhbXMubmFtZVxuICAgICAgICAsIHBhcmFtcy5jb21wbGV0ZVxuICAgICAgICAsIHBhcmFtcy5jYWxsXG4gICAgICAgICwgcGFyYW1zLmFyZ3NcbiAgICAgICAgLCBwYXJhbXMubm9sb2cpXG4gICAgfVxuICB9XG59XG5cbmlmKGRlYnVnLmxvZykgZGVidWcubG9nLmRlZmF1bHQoJ3Rlc3QnLCA0KVxuXG5leHBvcnRzLm5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlzTm9kZVxuICAgID8gcHJvY2Vzcy5ocnRpbWUoKVswXSAqIDEwMDAgKyBwcm9jZXNzLmhydGltZSgpWzFdICogMC4wMDAwMDEgXG4gICAgOiAod2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgXG4gICAgICA/IHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKSBcbiAgICAgIDogbmV3IERhdGUoKS5nZXRUaW1lKCkpXG59XG5cbmV4cG9ydHMubWVtb3J5ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNOb2RlIFxuICAgID8gcHJvY2Vzcy5tZW1vcnlVc2FnZSgpLmhlYXBVc2VkIFxuICAgIDogKHdpbmRvdyAmJiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm1lbW9yeSBcbiAgICAgID8gd2luZG93LnBlcmZvcm1hbmNlLm1lbW9yeS51c2VkSlNIZWFwU2l6ZSAqIDAuMDAwOTc2NTYyIFxuICAgICAgOiAwKVxufVxuXG5leHBvcnRzLmF2ZXJhZ2UgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgdmFyIG51bWJlciA9IDBcbiAgZm9yICh2YXIgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgbnVtYmVyICs9IGFycmF5W2ldXG4gIH1cbiAgcmV0dXJuIFtudW1iZXIsIG51bWJlciAvIGFycmF5Lmxlbmd0aF1cbn1cbiIsInZhciBnID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgID8gZ2xvYmFsXG4gICAgICAgICAgOiBmYWxzZVxuICAsIGhhc0xTID0gdHlwZW9mIGxvY2FsU3RvcmFnZSAhPT0gJ3VuZGVmaW5lZCdcbiAgLCBoYXNQUiA9IHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJ1xuXG52YXIgRyA9IG1vZHVsZS5leHBvcnRzID0gXG4gIHsgc2Vzc2lvbjogZnVuY3Rpb24oa2V5LCB2YWwpe1xuICAgICAgcmV0dXJuIGdldFNldChnLCBrZXksIHZhbClcbiAgICB9XG4gICwgZW52OiBmdW5jdGlvbihrZXksIHZhbCl7XG4gICAgICBpZihoYXNMUylcbiAgICAgICAgcmV0dXJuIGdldFNldChsb2NhbFN0b3JhZ2UsIGtleSwgdmFsLCAnZ2V0SXRlbScsICdzZXRJdGVtJylcbiAgICAgIGVsc2UgaWYoaGFzUFIpXG4gICAgICAgIHJldHVybiBnZXRTZXQocHJvY2Vzcy5lbnYsIGtleSwgdmFsKVxuICAgIH1cbiAgfVxuXG5mdW5jdGlvbiBnZXRTZXQodGhpbmcsIGtleSwgdmFsLCBnZXR0ZXIsIHNldHRlcil7XG4gIGlmKCF0aGluZylcbiAgICByZXR1cm5cblxuICBpZih2YWwgPT09IHZvaWQgMCl7XG4gICAgaWYoZ2V0dGVyKVxuICAgICAgcmV0dXJuIHRoaW5nW2dldHRlcl0oa2V5KVxuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGluZ1trZXldXG4gIH1lbHNle1xuICAgIGlmKHNldHRlcil7XG4gICAgICB0aGluZ1tzZXR0ZXJdKGtleSwgdmFsKVxuICAgICAgcmV0dXJuIHZhbFxuICAgIH1lbHNle1xuICAgICAgcmV0dXJuIHRoaW5nW2tleV0gPSB2YWxcbiAgICB9XG4gIH1cbn0iLCIvL2NoZWNrIHRoaXMgZm9yIG1vcmUgY29tcHJlc3Npb24gaHR0cDovL3d3dy5odG1sZ29vZGllcy5jb20vaHRtbDUvY2xpZW50L29wdGltaXppbmctd2Vic29ja2V0cy1iYW5kd2lkdGguaHRtbCNmYmlkPTZRWng4bmFwdTIwXG5cbi8qXG52YXIgY3JjVGFibGVcbiAgLCBjcmVhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjcmNUYWJsZSA9IFtdXG4gICAgICBmb3IgKHZhciBjLCBuID0gMCwgazsgbiA8IDI1NjsgYyA9ICsrbikge1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwgODsgaysrLCBjID0gKChjICYgMSkgPyAoKDB4RURCODgzMjApIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSkpO1xuICAgICAgICBjcmNUYWJsZVtuXSA9IGNcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmNUYWJsZVxuICAgIH1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xuICBmb3IgKHZhciB0YWIgPSBjcmNUYWJsZSB8fCBjcmVhdGUoKSwgY3JjID0gLTEsIGkgPSAwLCBsID0gc3RyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNyYyA9IChjcmMgPj4+IDgpIF4gdGFiWyhjcmMgXiBzdHIuY2hhckNvZGVBdChpKSkgJiAweEZGXVxuICB9XG4gIHJldHVybiBleHBvcnRzLmVuY29kZSgoKGNyYyBeICgtMSkpID4+PiAwKSlcbn1cblxuXG4qL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihrZXksIHNlZWQpIHtcbiAgdmFyIHJlbWFpbmRlciwgYnl0ZXMsIGgxLCBoMWIsIGMxLCBjMWIsIGMyLCBjMmIsIGsxLCBpO1xuICBzZWVkID0gMVxuXG4gIHJlbWFpbmRlciA9IGtleS5sZW5ndGggJiAzOyAvLyBrZXkubGVuZ3RoICUgNFxuICBieXRlcyA9IGtleS5sZW5ndGggLSByZW1haW5kZXI7XG4gIGgxID0gc2VlZDtcbiAgYzEgPSAweGNjOWUyZDUxO1xuICBjMiA9IDB4MWI4NzM1OTM7XG4gIGkgPSAwO1xuICBcbiAgd2hpbGUgKGkgPCBieXRlcykge1xuICAgICAgazEgPSBcbiAgICAgICAgKChrZXkuY2hhckNvZGVBdChpKSAmIDB4ZmYpKSB8XG4gICAgICAgICgoa2V5LmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDgpIHxcbiAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMTYpIHxcbiAgICAgICAgKChrZXkuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMjQpO1xuICAgICsraTtcbiAgICBcbiAgICBrMSA9ICgoKChrMSAmIDB4ZmZmZikgKiBjMSkgKyAoKCgoazEgPj4+IDE2KSAqIGMxKSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICAgIGsxID0gKGsxIDw8IDE1KSB8IChrMSA+Pj4gMTcpO1xuICAgIGsxID0gKCgoKGsxICYgMHhmZmZmKSAqIGMyKSArICgoKChrMSA+Pj4gMTYpICogYzIpICYgMHhmZmZmKSA8PCAxNikpKSAmIDB4ZmZmZmZmZmY7XG5cbiAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSAoaDEgPDwgMTMpIHwgKGgxID4+PiAxOSk7XG4gICAgaDFiID0gKCgoKGgxICYgMHhmZmZmKSAqIDUpICsgKCgoKGgxID4+PiAxNikgKiA1KSAmIDB4ZmZmZikgPDwgMTYpKSkgJiAweGZmZmZmZmZmO1xuICAgIGgxID0gKCgoaDFiICYgMHhmZmZmKSArIDB4NmI2NCkgKyAoKCgoaDFiID4+PiAxNikgKyAweGU2NTQpICYgMHhmZmZmKSA8PCAxNikpO1xuICB9XG4gIFxuICBrMSA9IDA7XG4gIFxuICBzd2l0Y2ggKHJlbWFpbmRlcikge1xuICAgIGNhc2UgMzogazEgXj0gKGtleS5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4ZmYpIDw8IDE2O1xuICAgIGNhc2UgMjogazEgXj0gKGtleS5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4ZmYpIDw8IDg7XG4gICAgY2FzZSAxOiBrMSBePSAoa2V5LmNoYXJDb2RlQXQoaSkgJiAweGZmKTtcbiAgICBcbiAgICBrMSA9ICgoKGsxICYgMHhmZmZmKSAqIGMxKSArICgoKChrMSA+Pj4gMTYpICogYzEpICYgMHhmZmZmKSA8PCAxNikpICYgMHhmZmZmZmZmZjtcbiAgICBrMSA9IChrMSA8PCAxNSkgfCAoazEgPj4+IDE3KTtcbiAgICBrMSA9ICgoKGsxICYgMHhmZmZmKSAqIGMyKSArICgoKChrMSA+Pj4gMTYpICogYzIpICYgMHhmZmZmKSA8PCAxNikpICYgMHhmZmZmZmZmZjtcbiAgICBoMSBePSBrMTtcbiAgfVxuICBcbiAgaDEgXj0ga2V5Lmxlbmd0aDtcblxuICBoMSBePSBoMSA+Pj4gMTY7XG4gIGgxID0gKCgoaDEgJiAweGZmZmYpICogMHg4NWViY2E2YikgKyAoKCgoaDEgPj4+IDE2KSAqIDB4ODVlYmNhNmIpICYgMHhmZmZmKSA8PCAxNikpICYgMHhmZmZmZmZmZjtcbiAgaDEgXj0gaDEgPj4+IDEzO1xuICBoMSA9ICgoKChoMSAmIDB4ZmZmZikgKiAweGMyYjJhZTM1KSArICgoKChoMSA+Pj4gMTYpICogMHhjMmIyYWUzNSkgJiAweGZmZmYpIDw8IDE2KSkpICYgMHhmZmZmZmZmZjtcbiAgaDEgXj0gaDEgPj4+IDE2O1xuXG4gIHJldHVybiAoaDEgPj4+IDApLnRvU3RyaW5nKDM2KVxufVxuXG4vLyBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggc3RyIClcbi8vIHtcbi8vICAgdmFyIEZOVjFfMzJBX0lOSVQgPSAweDgxMWM5ZGM1O1xuLy8gICB2YXIgaHZhbCA9IEZOVjFfMzJBX0lOSVQ7XG4vLyAgIGZvciAoIHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSApXG4vLyAgIHtcbi8vICAgICBodmFsIF49IHN0ci5jaGFyQ29kZUF0KGkpO1xuLy8gICAgIGh2YWwgKz0gKGh2YWwgPDwgMSkgKyAoaHZhbCA8PCA0KSArIChodmFsIDw8IDcpICsgKGh2YWwgPDwgOCkgKyAoaHZhbCA8PCAyNCk7XG4vLyAgIH1cbi8vICAgcmV0dXJuIGh2YWwgPj4+IDA7XG4vLyB9XG5cbi8qKlxuICogRW5jb2RlIHRvIGJhc2UgNjIgKHVybCBzYXZlKVxuKi9cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gYyAoYSwgYikge1xuICBiID0gYiB8fCBcIlwiXG4gIHJldHVybiB+fiBhIFxuICAgICAgID8gYyhhIC8gNjIsIFN0cmluZy5mcm9tQ2hhckNvZGUoKChhICU9IDYyKSA+IDkgXG4gICAgICAgICAgPyBhID4gMzUgPyAyOSA6IDg3IFxuICAgICAgICAgIDogNDgpICsgYSkgKyBiKSBcbiAgICAgICA6IGJcbn1cblxuLyoqXG4gKiBkZWNvZGUgYmFzZSA2MlxuKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgZm9yIChiID0gYyA9IDA7IGQgPSBhLmNoYXJDb2RlQXQoYysrKTsgYiA9IGIgKiA2MiArIGQgLSBbICwgNDgsIDI5LCA4N11bZCA+PiA1XSk7XG4gIHJldHVybiBiXG59XG5cblxuLy8gZXhwb3J0cy5kZWNvZGU2NFxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpZChwcmUsIGxldmVsKXtcbiAgdmFyIHIgPSBybmQoKVxuICBpZihsZXZlbCkgXG4gICAgd2hpbGUobGV2ZWwtLSl7XG4gICAgICByICs9IHJuZCgpXG4gICAgfVxuICByZXR1cm4gcHJlID8gcHJlICsgciA6IHJcbn1cblxuZnVuY3Rpb24gcm5kKCl7XG4gIHJldHVybiBOdW1iZXIoU3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpKS50b1N0cmluZygzNilcbn0iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5yZXF1aXJlKCcuL29iamVjdCcpIC8vdGhlc2UgdGhpbmdzIGFkZCBleHRyYSBtZXRob2RzIHRvIHV0aWwgZm9yIHJlYWRhYmlsaXR5IGluIGEgc2VwZXJhdGUgbW9kdWxlXG5yZXF1aXJlKCcuL3Byb3AnKVxuXG5cbmV4cG9ydHMuaXNOb2RlID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSA/IHRydWUgOiBmYWxzZVxuXG4vKipcbiAqIEFkZCBpcyBzaW1pbGFyIHRvIC5wdXNoIGl0IHJldHVybnMgdGhlIGFycmF5IGluc3RlYWQgb2YgbGVuZ3RoXG4gKiBDYW4gYmUgZXh0ZW5kZWQgdG8gc3VwcG9ydCBtb3JlIHR5cGVzIGUuZy4gYWRkIGFuIG9iamVjdCB0byBhbm90aGVyXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtICB7QXJyYXl9ICBvYmogVGFyZ2V0XG4gKiBAcGFyYW0gIHtPYmplY3R9IGFkZCBPYmplY3QgdG8gYWRkXG4gKiBAZGVwcmVjYXRlZFxuICovXG5leHBvcnRzLmFkZCA9IGZ1bmN0aW9uIChvYmosIGFkZCkge1xuICBpZiAoYWRkKSBvYmoucHVzaC5hcHBseShvYmosIGFkZCk7XG4gIHJldHVybiBvYmpcbn1cblxuLyoqXG4gKiBGaW5kcyBpdGVtcyBpbiBhbiBhcnJheVxuICogQG1ldGhvZCBjaGVja0FycmF5XG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl9ICAgICAgICAgICAgICAgICBsaXN0ICBEZWZpbmVzIHRoZSBsaXN0IHdoZXJlIHlvdSB3YW50IHRvIHNlYXJjaCB0aHJvdWdoLCBvbmx5IHVzZXMgLmxlbmd0aCBmaWVsZFxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgdmFsICAgRGVmaW5lcyB0aGUgdmFsdWUgeW91IHdhbnQgdG8gc2VhcmNoIGZvclxuICogQHBhcmFtICB7Qm9vbGVhbnxTdHJpbmd8TnVtYmVyfSAgICAgICAgW2luZGV4XSBXaGVuIGluZGV4IGlzIHRydWUgcmV0dXJuIHRoZSBpbmRleCBpbnN0ZWFkIG9mIHRydWUgb3IgZmFsc2UsIHdoZW4gaW5kZXggYW5kIGluZGV4ICE9PSB0cnVlIGluZGV4IGlzIHVzZWQgYXMgYSBmaWVsZCBpbiBvYmplY3RzIGluIHRoZSBhcnJheVxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICAgICAgICAgICAgICAgICAgW2ZpZWxkXSBXaGVuIGZpZWxkIHJldHVybiBmaWVsZCBpbnN0ZWFkIG9mIGluZGV4IG9yIHRydWVcbiAqIEByZXR1cm4geyp9XG4gKi9cbmV4cG9ydHMuY2hlY2tBcnJheSA9IGZ1bmN0aW9uIChsaXN0LCB2YWwsIGluZGV4LCBmaWVsZCkge1xuICB2YXIgYXJyID0gaW5kZXggaW5zdGFuY2VvZiBBcnJheVxuICBpZighbGlzdCkgcmV0dXJuIGZhbHNlXG4gIGZvciAodmFyIGkgPSAwLCBsID0gbGlzdC5sZW5ndGgsIHQ7IGkgPCBsOyBpKyspIHtcbiAgICB0ID0gbGlzdFtpXVxuICAgIGlmIChpbmRleCAhPT0gdm9pZCAwKSB7XG4gICAgICBpZiAoaW5kZXggPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHQgPT09IHZhbCkgcmV0dXJuIGlcbiAgICAgIH0gZWxzZSBpZiAoYXJyID8gZXhwb3J0cy5wYXRoKHQsaW5kZXgpPT09dmFsIDogdFtpbmRleF0gPT09IHZhbCkgcmV0dXJuIGZpZWxkID8gdCA6IGlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHQgPT09IHZhbCkgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogUGFzcyBhcmd1bWVudHMgKGFyZ3VtZW50cykgYW5kIHJldHVybiBhIG5ldyBhcnJheSwgd2hlbiBpbmRleCByZXR1cm4gYSBuZXcgYXJyYXkgc2xpY2VkIGZyb20gaW5kZXhcbiAqIEBtZXRob2QgYXJnXG4gKiBAcGFyYW0gIHtBcmd1bWVudHN9IGFyZ3MgICAgICAgIEFyZ3VtZW50c1xuICogQHBhcmFtICB7TnVtYmVyfSAgICBbaW5kZXggPSAwXSBXaGVuIGluZGV4IHJldHVybiBhIG5ldyBhcnJheSBzbGljZWQgZnJvbSBpbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cbmV4cG9ydHMuYXJnID0gZnVuY3Rpb24gKGFyZ3MsIGluZGV4KSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAhaW5kZXggPyAwIDogaW5kZXgpXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgb2JqIGlzIGVtcHR5IGV4Y2x1ZGUgZmllbGQgbmFtZXMgcGFzc2VkIHRvIGxpc3RcbiAqIEBtZXRob2QgZW1wdHlcbiAqIEBwYXJhbSAge09iamVjdH0gICAgICAgb2JqICBPYmplY3RcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gbGlzdCBUYWtlcyBhbnkgb2JqZWN0IHdpdGggLmxlbmd0aFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgICAgICAgIFRydWUvZmFsc2VcbiAqL1xuZXhwb3J0cy5lbXB0eSA9IGZ1bmN0aW9uIChvYmosIGxpc3QpIHtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoIWxpc3QgfHwgIXRoaXMuY2hlY2tBcnJheShsaXN0LCBpKSkgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZXhwb3J0cy5pbmplY3QgPSByZXF1aXJlKCcuL2luamVjdCcpXG4iLCJcbnZhciBWID0gcmVxdWlyZSgnLi4vJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi8nKVxuXG52YXIgJFRFU1RcbmlmKCF1dGlsLmlzTm9kZSkge1xuICAkVEVTVCA9IHdpbmRvdy4kVEVTVFxufVxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZnVuY3Rpb24oZXh0ZW5kKSB7XG5cbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHNcblxuICBpZihhcmdzWzBdJiZhcmdzWzBdLiRURVNUKSB7XG4gICAgICRURVNUID0gd2luZG93LiRURVNUID0gdHJ1ZVxuICB9XG5cbiAgaWYoICh0eXBlb2YgdGhpcyA9PT0gJ2Z1bmN0aW9uJykgfHwgKFYuQmFzZSAmJiAodGhpcyBpbnN0YW5jZW9mIFYuQmFzZSkpIHx8IHR5cGVvZiB0aGlzID09PSAnb2JqZWN0Jykge1xuICAgIGlmKChWLkJhc2UgXG4gICAgICAgICYmICh0aGlzPT09Vi5CYXNlIFxuICAgICAgICB8fCAodGhpcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBWLkJhc2UpXG4gICAgICAgIHx8ICh0aGlzIGluc3RhbmNlb2YgVi5CYXNlKSlcbiAgICAgICkpIHsgXG4gICAgICBhcmdzID0gdXRpbC5hcmcoYXJncylcbiAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKVxuICAgICAgZXh0ZW5kID0gdGhpc1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5qZWN0LmFwcGx5KHRoaXMsYXJncylcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgIG1ha2VFeHRlbmQoZXh0ZW5kLCBhcmdzW2ldKVxuICB9XG4gIHJldHVybiBleHRlbmRcbn1cblxuZnVuY3Rpb24gbWFrZUV4dGVuZChleHRlbmQsIG1vZHVsZSkge1xuICBpZigkVEVTVCkgY29uc29sZS5sb2coJzknLCBtb2R1bGUsIGV4dGVuZClcbiAgaWYobW9kdWxlLmV4dGVuZCkge1xuICAgIGlmKCRURVNUKSBjb25zb2xlLmxvZygnOS4xJywgZXh0ZW5kKVxuICAgICBtb2R1bGUuZXh0ZW5kKGV4dGVuZClcbiAgfSBlbHNlIGlmKG1vZHVsZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGFyciA9IG1vZHVsZS5jb25jYXQoKVxuICAgICAgLCBtb2QgPSBhcnJbMF1cbiAgICBhcnJbMF0gPSBleHRlbmRcbiAgICAgaWYoJFRFU1QpIGNvbnNvbGUubG9nKCc5LjInKVxuICAgIG1vZC5leHRlbmQuYXBwbHkobW9kLGFycilcbiAgfSBcbn0gXG5cbmZ1bmN0aW9uIGluamVjdCgpIHtcbiAgaWYoJFRFU1QpIGNvbnNvbGUubG9nKCc1JylcbiAgLy9kbyBzcGVjaWFsIHN0dWZmIHZvb3IgYmxhY2tsaXN0XG4gIC8vIEN1c3RvbS5wcm90b3R5cGUgPSBuZXcgdGhpcygpIC8vbGlnaHRlclxuICB2YXIgQ3VzdG9tXG4gICAgLCBleHRlbmRSZXNpZHVlID0gW11cbiAgICAsIEFzcGVjdHMgPSBbdGhpc11cblxuICBmb3IgKHZhciBpID0gMCwgQXNwZWN0LCBhcmdzID0gYXJndW1lbnRzLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgXG4gICAgQXNwZWN0ID0gYXJnc1tpXVxuXG4gICAgaWYodHlwZW9mIEFzcGVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYoIUN1c3RvbSkge1xuICAgICAgICBDdXN0b20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gQXNwZWN0cy5sZW5ndGg7IGogPCBsZW47ICBqKyspIHtcbiAgICAgICAgICAgIEFzcGVjdHNbal0uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbmhlcml0cyggQ3VzdG9tLCB0aGlzIClcbiAgICAgIH1cbiAgICAgIEFzcGVjdHMucHVzaChBc3BlY3QpXG4gICAgICBmb3IgKHZhciBtZXRob2QkIGluIEFzcGVjdC5wcm90b3R5cGUpIGlmICh7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKEFzcGVjdC5wcm90b3R5cGUsIG1ldGhvZCQpKSB7XG4gICAgICAgIGlmIChtZXRob2QkID09PSAnY29uc3RydWN0b3InKSBjb250aW51ZVxuICAgICAgICBDdXN0b20ucHJvdG90eXBlW21ldGhvZCRdID0gQXNwZWN0LnByb3RvdHlwZVttZXRob2QkXVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZigkVEVTVCkgY29uc29sZS5sb2coJzYnKVxuICAgICAgaWYoQ3VzdG9tKSB7XG4gICAgICAgICAgICAgIGlmKCRURVNUKSBjb25zb2xlLmxvZygnNycpXG5cbiAgICAgICBtYWtlRXh0ZW5kKEN1c3RvbSAsIEFzcGVjdClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGlmKCRURVNUKSBjb25zb2xlLmxvZygnOCcpXG4gICAgICAgIGV4dGVuZFJlc2lkdWUucHVzaChBc3BlY3QpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYoIUN1c3RvbSkgQ3VzdG9tID0gdGhpc1xuICBcbiAgZm9yKHZhciBqIGluIGV4dGVuZFJlc2lkdWUpIHtcbiAgICAvLyBjb25zb2xlLmxvZygnOC4nK2osIGV4dGVuZFJlc2lkdWVbal0sIEN1c3RvbSlcbiAgICBtYWtlRXh0ZW5kKEN1c3RvbSxleHRlbmRSZXNpZHVlW2pdKVxuICB9XG5cbiAgcmV0dXJuIEN1c3RvbVxufVxuXG5mdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlXG4gICAgKCBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgLCB7IGNvbnN0cnVjdG9yOiBcbiAgICAgICAgeyB2YWx1ZTogY3RvclxuICAgICAgICAsIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICwgd3JpdGFibGU6IHRydWVcbiAgICAgICAgLCBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIClcbn1cblxuLypcbiBEaXQgbW9ldCB3b3JkZW4gZ2VhZGQgdm9vciBWLk9iamVjdHNcbi8qXG4gIG9iamVjdC5uZXcgPSBmdW5jdGlvbihwYXJhbXMsIGNvbnN0cnVjdG9yKSB7XG4gIHZhciB2T2JqID0gZnVuY3Rpb24odmFsLCBob29rLCBwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQpIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICAgICAgaWYgKGhvb2sgJiYgdGhpcy5faG9vaykgdGhpcy5faG9vayh2YWwsIGhvb2spXG4gICAgICBpZiAodGhpcy5fb25Db25zdHJ1Y3QpIHRoaXMuX29uQ29uc3RydWN0KHZhbCwgaG9vaylcbiAgICAgIGlmICh2YWwgIT09IHZvaWQgMCkgdGhpcy52YWwgPSB2YWxcbiAgICAgIC8vIGNvbnNvbGUubG9nKGNvbnN0cnVjdG9yKVxuICAgICAgaWYoY29uc3RydWN0b3IpIGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKSAgXG4gICAgfSxcbiAgICBwcm90byA9IHZPYmoucHJvdG90eXBlID0gbmV3IHRoaXMoKVxuICB2T2JqLm5ldyA9IG9iamVjdC5uZXdcbiAgdXRpbC5kZWZpbmUodk9iaiwgJ19ibGFja2xpc3QnLCBwcm90by5fYmxhY2tsaXN0LmNvbmNhdCgpKVxuICBfcGFyYW1zLmNhbGwodk9iaiwgcGFyYW1zLCBbJ21peGVkJywgJ21lcmdlJ10pXG4gIHV0aWwuZGVmaW5lKHZPYmosICdfY2xhc3MnLCB2T2JqKVxuICByZXR1cm4gdk9ialxufVxuXG52ZWVsIGRpbmdlbiB3ZXJrZW4gYWxzIGV4dGVuc2lvbiBuaWV0IGFscyBsb3NzZSBjbGFzcyAtLSBcblxuKi9cblxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSByZXF1aXJlKCcuLycpXG4gICwgdmlnb3VyID0gcmVxdWlyZSgnLi4vJykgLy9vbmx5IGhlcmUgdG8gYmUgYWJsZSB0byB1c2UgdXRpbCB3aXRob3V0IHZpZ291ci5PYmplY3QgbWF5YmUgcmVmYWN0b3IgdGhpcyBhd2F5P1xuICAsIERPVCA9ICcuJ1xuXG4vKipcbiAqIGxvb2t1cFxuICogcG9seWZpbGwgaWYgX19sb29rdXBTZXR0ZXJfXyBkb2VzIG5vdCBleGlzdDtcbiAqL1xuZXhwb3J0cy5sb29rdXAgPSBPYmplY3QuX19sb29rdXBTZXR0ZXJfXyB8fCBmdW5jdGlvbiAoaSkge1xuICB2YXIgdCA9IHRoaXNcbiAgICAsIGFcbiAgd2hpbGUgKHQpIHtcbiAgICBhID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCBpKVxuICAgIGlmIChhICYmIGEuc2V0KSByZXR1cm4gdHJ1ZVxuICAgIHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodClcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNldCBhIHZhbCB0byBhbiBmaWVsZCBvbiBhIG9iamVjdCwgd2hldGhlciBpdCBpcyBhIHZpZ291ci5PYmplY3Qgb3IgYSByZWd1bGFyIG9iamVjdFxuICogQG1ldGhvZCBzZXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogICBEZWZpbmVzIHRhcmdldCBPYmplY3RcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZCBUYXJnZXQgZmllbGRcbiAqIEBwYXJhbSB7Kn0gICAgICB2YWwgICBWYWx1ZSB0byBzZXRcbiAqIEB0b2RvICAgICAgICAgICAgICAgICBNb3ZlIHRoaXMgZnVuY3Rpb24gdG8gYSBkaWZmZXJlbnQgbW9kdWxlIChlLmcuICdjb252ZW5pZW5jZScgbW9kdWxlKVxuICovXG5leHBvcnRzLnNldCA9IGZ1bmN0aW9uIChvYmosIGZpZWxkLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSkge1xuICByZXR1cm4gKHZpZ291ci5PYmplY3QgJiYgKG9iaiBpbnN0YW5jZW9mIHZpZ291ci5PYmplY3QpKVxuICAgID8gb2JqLnNldChmaWVsZCwgdmFsLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUpXG4gICAgOiAob2JqW2ZpZWxkXSA9IHZhbClcbn1cblxuXG4vKipcbiAqIFJldHVybnMgb2JqZWN0IG9uIHRoZSBlbmQgb2YgYSBkZWZpbmVkIHBhdGhcbiAqIEBtZXRob2QgcGF0aFxuICogQGV4YW1wbGVcbiAqIC8vIHJldHVybnMgb2JqLmEuYi5jXG4gKiB2YXIgb2JqID0geyBhOiB7IGI6IHsgYzogMSB9fX1cbiAqIFYudXRpbC5vYmplY3QucGF0aChvYmosWydhJywnYicsJ2MnXSlcbiAqIEBwYXJhbSAge09iamVjdH0gICAgb2JqICAgICAgICAgICAgT2JqZWN0IHRvIHNlYXJjaFxuICogQHBhcmFtICB7QXJyYXl9ICAgICBwYXRoICAgICAgICAgICBBcnJheSBvZiBmaWVsZHMgaW4gcGF0aFxuICogQHBhcmFtICB7Kn0gICAgICAgICBbdmFsXSAgICAgICAgICBXaGVuIGRlZmluZWQsIHZhbCB3aWxsIGJlIHNldCBvbiBlbmRwb2ludCBvZiBwYXRoIGlmIG5vdCBhbHJlYWR5IGRlZmluZWRcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgW292ZXJ3cml0ZV0gICAgSWYgdHJ1ZSwgdmFsIFdJTEwgb3ZlcndyaXRlIGV4aXN0aW5nIHZhbHVlIG9uIGVuZHBvaW50IG9mIHBhdGggd2hlbiBhbHJlYWR5IGRlZmluZWRcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSAgW3dyaXRlSGFuZGxlcl0gQ2FsbGJhY2sgb24gd3JpdGVcbiAqIEBwYXJhbSAge0Jvb2xlYW59ICAgW25vdXBkYXRlXSAgICAgV2hlbiB0cnVlLCB1cGRhdGVzIHdpbGwgYmUgc2tpcHBlZCBvbiB3cml0ZVxuICogQHBhcmFtICB7TnVtYmVyfSAgICBbaSA9IDBdICAgICAgICBTdGFydGluZyBwb2ludCBmb3Igc2VhcmNoaW5nIHRocm91Z2ggcGF0aFxuICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qgb24gdGhlIGVuZCBvZiBhIGRlZmluZWQgcGF0aFxuICovXG5cbmV4cG9ydHMucGF0aCA9IGZ1bmN0aW9uICggb2JqLCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYsIHVpZCwgaSApIHtcbiAgaWYgKCFpKSBpID0gMFxuXG4gIHZhciBmaWVsZCA9IHBhdGhbaV1cbiAgICAsIHJlc3VsdFxuICAgICwgY1xuICAgICwgdGFyZ2V0ID0gKCFzZWxmICYmIG9iaiAmJiBvYmouX190ID09PSA0KSA/IG9iai5mcm9tW2ZpZWxkXSA6IG9iaiAmJiBvYmpbZmllbGRdXG4gICAgLCBsID0gaSA8IHBhdGgubGVuZ3RoIC0gMVxuXG4gIC8vIGlmKGZpZWxkID09PSB2b2lkIDApIHtcbiAgLy8gICB0aHJvdyBuZXcgRXJyb3IoJ3BhdGggbXVzdCBub3QgY29udGFpbiB1bmRlZmluZWQnKVxuICAvLyB9XG5cbiAgaWYgKGwgJiYgISh0YXJnZXQgaW5zdGFuY2VvZiBPYmplY3QpKSB0YXJnZXQgPSB2b2lkIDBcblxuICBpZiAoKHZhbCAhPT0gdm9pZCAwKSAmJiAodGFyZ2V0ID09PSB2b2lkIDAgfHwgKCFsICYmIG92ZXJ3cml0ZSkpKSB7XG4gICAgYyA9IHRydWVcbiAgICBleHBvcnRzLnNldChvYmosIGZpZWxkLCBsID8ge30gOiB2YWwsIGwgPyBmYWxzZSA6IHZvYmosIHN0YW1wLCBub3VwZGF0ZSlcbiAgICB0YXJnZXQgPSBvYmpbZmllbGRdXG4gIH1cblxuICBpZiAobCkge1xuICAgIHJlc3VsdCA9IHRhcmdldFxuICAgICAgPyB0aGlzLnBhdGgodGFyZ2V0LCBwYXRoLCB2YWwsIG92ZXJ3cml0ZSwgd3JpdGVIYW5kbGVyLCB2b2JqLCBzdGFtcCwgbm91cGRhdGUsIHNlbGYsIHVpZCwgKytpKVxuICAgICAgOiB0YXJnZXRcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAoIXNlbGYgJiYgdGFyZ2V0ICYmIHRhcmdldC5fX3QgPT09IDQpID8gdGFyZ2V0LmZyb20gOiB0YXJnZXQ7XG4gICAgaWYgKGMgJiYgd3JpdGVIYW5kbGVyKSB3cml0ZUhhbmRsZXIocmVzdWx0KVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEFkZHMgcGF0aCB1c2luZyAnZG90LW5vdGF0aW9uJ1xuICogQG1ldGhvZCBkb3RGaWVsZFxuICogQGV4YW1wbGVcbiAqIC8vIHJldHVybnMgYmx1cjp7ZDp7YTp7czp7fX19fVxuICogdmFyIGJsdXIgPSB7fTtcbiAqIFYudXRpbC5vYmplY3QuZG90RmllbGQoYmx1ciwnZC5hLnMnKTtcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICAgT2JqZWN0IHdoZXJlIGZpZWxkIHdpbGwgYmUgYWRkZWRcbiAqIEBwYXJhbSAge1N0cmluZ30gZmllbGQgU3RyaW5nIHVzaW5nICdkb3Qtbm90YXRpb24nXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgIFJldHVybnMgZmllbGRcbiAqL1xuZXhwb3J0cy5kb3RGaWVsZCA9IGZ1bmN0aW9uIChvYmosIGZpZWxkKSB7XG4gIGlmICh+ZmllbGQuaW5kZXhPZihET1QpKSB7XG4gICAgdmFyIHBhdGggPSBmaWVsZC5zcGxpdChET1QpXG4gICAgICAsIGZpcnN0ID0gcGF0aC5zaGlmdCgpXG4gICAgICAsIHZhbCA9IHt9XG4gICAgdGhpcy5wYXRoKHZhbCwgcGF0aCwgb2JqW2ZpZWxkXSlcbiAgICBkZWxldGUgb2JqW2ZpZWxkXVxuICAgIG9ialtmaXJzdF0gPSB2YWxcbiAgICBmaWVsZCA9IGZpcnN0XG4gIH1cbiAgcmV0dXJuIGZpZWxkXG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBsaXN0cyBjb250YWluIGlkZW50aWNhbCBjb250ZW50XG4gKiBAbWV0aG9kIGNvbXBhcmVBcnJheXNcbiAqIEBwYXJhbSAge0FycmF5fE9iamVjdH0gYSAgICAgICAgIFRha2VzIGFueSBvYmplY3Qgd2l0aCAubGVuZ3RoXG4gKiBAcGFyYW0gIHtBcnJheXxPYmplY3R9IGIgICAgICAgICBUYWtlcyBhbnkgb2JqZWN0XG4gKiBAcGFyYW0gIHtCb29sZWFufSAgICAgIGtleXMgICAgICB1c2UgT2JqZWN0LmtleXMgZm9yIGJcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgICAgVHJ1ZS9mYWxzZVxuICogQHRvZG8gICAgICAgICAgICAgICAgICBNYXliZSBjaGFuZ2UgdGl0bGUgPT4gY29tcGFyZUxpc3RzXG4gKi9cbmV4cG9ydHMuY29tcGFyZUFycmF5cyA9IGZ1bmN0aW9uKGEsIGIsIGtleXMpIHtcbiAgdmFyIGJsID0ga2V5cyA/IE9iamVjdC5rZXlzKGIpLmxlbmd0aCA6IGIubGVuZ3RoXG4gIGlmIChhLmxlbmd0aCAhPT0gYmwpIHJldHVybiBmYWxzZVxuICBmb3IgKHZhciBpID0gYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChhW2ldICE9IGJbaV0pIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogR2V0cyBvYmplY3QgZnJvbSBzcGVjaWZpZWQgcGF0aC4gV2hlbiBwYXRoIGlzIGEgc3RyaW5nIGNoZWNrcyBmb3IgJ2RvdG5vdGF0aW9uJy5cbiAqIEBtZXRob2QgZ2V0XG4gKiBAZXhhbXBsZVxuICogLy8gcmV0dXJucyAnZm9vJ1xuICogdmFyIGEgPSB7Yjp7YzonZm9vJ319XG4gKiBWLnV0aWwub2JqZWN0LmdldChhLCdiLmMnKVxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBvYmogIERlZmluZXMgb2JqZWN0IG9yIFYuVmFsdWVcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gcGF0aCBEZWZpbmVzIGZpZWxkIHtzdHJpbmd9IG9yIHBhdGgge2FycmF5fCdkb3Qtbm90YXRpb24nfVxuICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICAgIG9ialtwYXRoXXxuZXN0ZWQgb2JqZWN0L3ZhbHVlXG4gKi9cbmV4cG9ydHMuZ2V0ID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgc2VsZikge1xuICAvL1RPRE86IG1ha2Ugb25lIGludGVyZmFjZSBmb3IgZ2V0XG5cbiAgaWYgKCFvYmogfHwgIXBhdGgpIHJldHVyblxuICBpZiAoIXNlbGYgJiYgb2JqLl9fdCA9PT0gNCAmJiAhb2JqLl9maWx0ZXIpIG9iaiA9IG9iai5mcm9tXG4gIGlmICghKHBhdGggaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICBpZiAofnBhdGguaW5kZXhPZihET1QpKSB7XG4gICAgICBwYXRoID0gcGF0aC5zcGxpdChET1QpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoIXNlbGYgJiYgb2JqW3BhdGhdICYmIG9ialtwYXRoXS5mcm9tKSB8fCBvYmpbcGF0aF1cbiAgICB9XG4gIH1cbiAgLy9zZWxmIGlzIHRvbyBmYXIgYXdheSBpbiB0aGUgYXJndW1lbnRzXG4gIHJldHVybiB0aGlzLnBhdGgob2JqLCBwYXRoLCB2b2lkIDAsIGZhbHNlLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgc2VsZilcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYW4gb2JqZWN0IGlzIGFuIGluc3RhbmNlIG9mIGFuIG9iamVjdCBhbmQgbm90IGEgZnVuY3Rpb24gLCBWLk9iamVjdCBvciBWLkJhc2VcbiAqIEBtZXRob2QgaXNPYmpcbiAqIEBwYXJhbSAge09iamVjdH0gIG9iaiBPYmplY3QgdG8gaW5zcGVjdFxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgIFRydWUvRmFsc2VcbiAqL1xuZXhwb3J0cy5pc09iaiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIChvYmogaW5zdGFuY2VvZiBPYmplY3RcbiAgICAmJiB0eXBlb2Ygb2JqICE9PSAnZnVuY3Rpb24nXG4gICAgJiYgKCF2aWdvdXIuT2JqZWN0IHx8ICEob2JqIGluc3RhbmNlb2Ygdmlnb3VyLk9iamVjdCkpXG4gICAgJiYgKCF2aWdvdXIuQmFzZSB8fCAhKG9iaiBpbnN0YW5jZW9mIHZpZ291ci5CYXNlKSkpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgdmFsdWUgLCB0YWtlcyBjdXN0b20gb2JqZWN0cyBpbnRvIGFjY291bnQgKG5ldyBvYmouY29uc3RydWN0b3IoKSlcbiAqIEBtZXRob2QgY2xvbmVcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqIE9iamVjdCB0byBjbG9uZVxuICogQHJldHVybiB7T2JqZWN0fSAgICAgUmV0dXJucyBjbG9uZVxuICovXG5leHBvcnRzLmNsb25lID0gZnVuY3Rpb24gKG9iaiwgZXhjbHVkZSwgc2hhbGxvdykge1xuICBpZiAodGhpcy5pc09iaihvYmopKSB7XG4gICAgdmFyIGNvcHkgPSBuZXcgb2JqLmNvbnN0cnVjdG9yKClcbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgaWYoIWV4Y2x1ZGUgfHwgIWV4Y2x1ZGVbaV0pXG4gICAgICAgIGNvcHlbaV0gPSAhc2hhbGxvd1xuICAgICAgICAgID8gdGhpcy5jbG9uZShvYmpbaV0sIGV4Y2x1ZGUpXG4gICAgICAgICAgOiBvYmpbaV1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHlcbiAgfVxuICByZXR1cm4gb2JqXG59O1xuXG4vKipcbiAqIE1lcmdlcyBvYmplY3QgYiBpbnRvIG9iamVjdCBhIGFuZCByZXR1cm5zIG9iamVjdCBhXG4gKiBAbWV0aG9kIG1lcmdlXG4gKiBAcGFyYW0gIHtPYmplY3R9IGEgT2JqZWN0IGFcbiAqIEBwYXJhbSAge09iamVjdH0gYiBPYmplY3QgYlxuICogQHJldHVybiB7T2JqZWN0fSAgIE9iamVjdCBhXG4gKi9cbmV4cG9ydHMubWVyZ2UgPSBmdW5jdGlvbiAoYSwgYiwgbm9yZWZzLCBvdmVyd3JpdGUpIHtcbiAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgdmFyIGFpc29iaiA9IHV0aWwuaXNPYmooYVtpXSlcbiAgICAgICwgYmlzb2JqID0gdXRpbC5pc09iaihiW2ldKVxuXG4gICAgaWYgKGFpc29iaiAmJiBiaXNvYmopIHtcbiAgICAgIHV0aWwubWVyZ2UoYVtpXSwgYltpXSwgbm9yZWZzLCBvdmVyd3JpdGUpXG4gICAgfSBlbHNlIGlmKCFub3JlZnMgfHwgIWJpc29iail7XG4gICAgICBpZiggb3ZlcndyaXRlID09PSB2b2lkIDBcbiAgICAgICB8fCAhKGkgaW4gYSlcbiAgICAgICB8fCB0eXBlb2Ygb3ZlcndyaXRlID09PSAnZnVuY3Rpb24nICYmIG92ZXJ3cml0ZShhW2ldLCBiW2ldKVxuICAgICAgICApe1xuICAgICAgICBhW2ldID0gYltpXVxuICAgICAgfVxuXG4gICAgfWVsc2V7XG4gICAgICBhW2ldID0gYltpXSBpbnN0YW5jZW9mIEFycmF5ID8gW10gOiB7fVxuICAgICAgdXRpbC5tZXJnZShhW2ldLCBiW2ldLCBub3JlZnMsIG92ZXJ3cml0ZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFcbn1cblxuLy8gZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oYSwgYiwgYkZyb20sIGopIHtcbi8vICAgdmFyIHNhbWUgPSB0cnVlO1xuLy8gICBpZihiIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4vLyAgICAgZm9yKHZhciBpIGluIGIpIHtcbi8vICAgICAgIGlmKGFbaV0hPT12b2lkIDApIHtcbi8vICAgICAgICAgaWYoZXhwb3J0cy5yZXNvbHZlKGFbaV0sYltpXSxiRnJvbSA/IGJGcm9tW2ldIDogYltpXSxpKSkge1xuLy8gICAgICAgICAgIGlmKGJGcm9tKSB7XG4vLyAgICAgICAgICAgICBkZWxldGUgYkZyb21baV1cbi8vICAgICAgICAgICB9XG4vLyAgICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgICAgc2FtZSA9IGZhbHNlXG4vLyAgICAgICAgIH1cbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHNhbWUgPSBmYWxzZVxuLy8gICAgICAgfVxuLy8gICAgIH1cbi8vICAgICBpZihzYW1lKSB7XG4vLyAgICAgICBpZighKGJGcm9tJiZqIT09dm9pZCAwKSkgcmV0dXJuIHRydWVcbi8vICAgICAgIGRlbGV0ZSBiRnJvbVtqXVxuLy8gICAgIH1cbi8vICAgICByZXR1cm4gc2FtZTtcbi8vICAgfSBlbHNlIHtcbi8vICAgICBpZihhPT1iKSB7XG4vLyAgICAgICBpZihiRnJvbSYmaiE9PXZvaWQgMCkge1xuLy8gICAgICAgICBkZWxldGUgYkZyb21bal1cbi8vICAgICAgIH1cbi8vICAgICAgIHJldHVybiB0cnVlXG4vLyAgICAgfVxuLy8gICB9XG4vLyB9XG5cbmV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKGEsIGIsIGJGcm9tLCBqKSB7XG4gIC8vIGNvbnNvbGUubG9nKCdsb2xyZXNvbHZlXFxuJyxiRnJvbSlcbiAgdmFyIHNhbWUgPSB0cnVlO1xuICBpZihiIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgZm9yKHZhciBpIGluIGIpIHtcbiAgICAgIGlmKGFbaV0hPT12b2lkIDApIHtcbiAgICAgICAgaWYoZXhwb3J0cy5yZXNvbHZlKGFbaV0sYltpXSwoYkZyb20hPT12b2lkIDAgJiYgYkZyb20hPT1udWxsKSA/IGJGcm9tW2ldIDogYltpXSxpKSkge1xuICAgICAgICAgIGlmKGJGcm9tIT09dm9pZCAwICYmIGJGcm9tIT09bnVsbCkge1xuICAgICAgICAgICAgaWYoYkZyb21baV09PT1udWxsKSB7XG4gICAgICAgICAgICAgIHNhbWUgPSBmYWxzZVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGJGcm9tW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNhbWUgPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzYW1lID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoc2FtZSkge1xuICAgICAgaWYoIShiRnJvbSYmaiE9PXZvaWQgMCkpIHJldHVybiB0cnVlXG4gICAgICBkZWxldGUgYkZyb21bal1cbiAgICB9XG4gICAgcmV0dXJuIHNhbWU7XG4gIH0gZWxzZSB7XG4gICAgaWYoYT09Yikge1xuICAgICAgaWYoYkZyb20mJmohPT12b2lkIDApIHtcbiAgICAgICAgZGVsZXRlIGJGcm9tW2pdXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgdmFsdWUgdG8gYXJyYXkgaWYgaXQgaXMgbm90IGNvbnRhaW5lZCBpbiBhcnJheSwgZXhlY3V0ZXMgaGFuZGxlciBvbiBlbmNvdW50ZXJpbmcgdmFsIGluIGFycmF5XG4gKiBAbWV0aG9kIGluY2x1ZGVcbiAqIEBwYXJhbSAge09iamVjdHxBcnJheX0gICBvYmogICAgICAgVGFrZXMgYW55IG9iamVjdCB3aXRoIC5sZW5ndGhcbiAqIEBwYXJhbSAgeyp9ICAgICAgICAgICAgICB2YWwgICAgICAgVmFsdWUgdG8gYWRkXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgW2hhbmRsZXJdIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZW5jb3VudGVyaW5nIHZhbCBpbiBhcnJheVxuICogQHBhcmFtICB7Qm9vbGVhbn0gICAgICAgIGFyciAgICAgICBJbmNsdWRlIGVsZW1lbnRzIG9mIHZhbCBzZXBhcmF0ZWx5IHJhdGhlciB0aGFuIGluY2x1ZGluZyB2YWwgaXRzZWxmXG4gKiBAcmV0dXJuIHtCb29sZWFufSAgICAgICAgICAgICAgICAgIFRydWUvZmFsc2VcbiAqL1xuZXhwb3J0cy5pbmNsdWRlID0gZnVuY3Rpb24gKG9iaiwgdmFsLCBoYW5kbGVyLCBhcnIpIHtcblxuICBpZihhcnIgJiYgdmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgcmV0ID0gZmFsc2VcbiAgICBmb3IodmFyIGkgPSAwICwgbGVuID0gdmFsLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXQgPSBleHBvcnRzLmluY2x1ZGUob2JqLCB2YWxbaV0sIGhhbmRsZXIpXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIHZhciBpID0gMFxuICAgICwgbCA9IG9iai5sZW5ndGhcbiAgICAsIGZpZWxkXG4gICAgLCBjaGVja1xuXG4gIGlmIChvYmouX190ID09PSAxKSB7XG4gICAgZm9yICg7aSA8IGw7IGkrKykge1xuICAgICAgZmllbGQgPSBjaGVjayA9IG9ialtpXVxuICAgICAgaWYgKGNoZWNrLl9fdCA9PT0gNCkgY2hlY2sgPSBjaGVjay5mcm9tXG4gICAgICBpZiAoY2hlY2sgPT09IHZhbCB8fCBjaGVjay52YWwgPT09IHZhbCkge1xuICAgICAgICBpZiAoaGFuZGxlcikgaGFuZGxlcihmaWVsZClcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIG9iai5wdXNoKHZhbClcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgZm9yICg7aSA8IGw7IGkrKykge1xuICAgICAgaWYgKG9ialtpXSA9PT0gdmFsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgICBvYmoucHVzaCh2YWwpXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnRzLmNoYW5nZVR5cGUgPSBmdW5jdGlvbiggb2JqICkge1xuICB2YXIgcmVzdWx0XG4gIGlmKG9iaiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmVzdWx0ID0ge31cbiAgICBmb3IodmFyIGk9MCxsZW49b2JqLmxlbmd0aDtpPGxlbjtpKyspIHtcbiAgICAgIHJlc3VsdFtpXT1vYmpbaV1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gW11cbiAgICBmb3IodmFyIGkgaW4gb2JqKSB7XG4gICAgICByZXN1bHQucHVzaChvYmpbaV0pXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuLyoqXG4gKiBFbnN1cmVzIGEgdmFsdWUgaXMgbm90IG9yIGNvbnRhaW5zIG5vIFYuT2JqZWN0cywgb25seSB0aGVpciBcInJhd1wiIHZlcnNpb25zXG4gKiBUaGlzIG5lZWRzIHRvIGJlIHVuaWZpZWQgd2l0aCBjb252ZXJ0LCBvciBhdCBsZWFzdCBnZXQgYSBiZXR0ZXIgbmFtZS5cbiAqIEBtZXRob2QgcmF3XG4gKiBAcGFyYW0gIHsqfSAgIHZhbCAgIHRoZSB2YWx1ZSB0byBiZSBwcm9jZXNzZWRcbiAqIEByZXR1cm4geyp9ICAgICAgICAgdGhlIHByb2Nlc3NlZCB2YWx1ZVxuICovXG5leHBvcnRzLnJhdyA9IGZ1bmN0aW9uKCB2YWwsIHJwYXJhbXMgKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBPYmplY3QpIHtcbiAgICBpZiAodmFsIGluc3RhbmNlb2Ygdmlnb3VyLk9iamVjdCkge1xuICAgICAgcmV0dXJuIHZhbC5yYXdcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJlc3VsdFxuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHJlc3VsdCA9IFtdXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMucmF3KHZhbFtpXSwgcnBhcmFtcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0ge31cbiAgICAgICAgZm9yICh2YXIgZiBpbiB2YWwpIHtcbiAgICAgICAgICByZXN1bHRbZl0gPSB0aGlzLnJhdyh2YWxbZl0sIHJwYXJhbXMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbFxuICB9XG59XG5cbi8vYWRkIGxldmVsIGFuZCBzdG9wcyBmb3IgY2VydGFpbiBicmFuY2hlc1xuZXhwb3J0cy53YWxrID0gZnVuY3Rpb24ob2JqLCBmbiApIHtcbiAgZm9yKHZhciBpIGluIG9iaikge1xuICAgIGlmKG9ialtpXSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgaWYoIWZuKGksIG9ialtpXSwgb2JqLCB0cnVlKSkge1xuICAgICAgICBpZihleHBvcnRzLndhbGsob2JqW2ldLCBmbikpIHJldHVybiB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZihmbihpLCBvYmpbaV0sIG9iaikpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5jaGVja1BhcmVudEZhY3RvcnkgPSBmdW5jdGlvbiggcGFyZW50RmllbGQgKSB7XG4gIHJldHVybiBmdW5jdGlvbihmaWVsZCwgZ2V0LCBsaW5rcywgbWF0Y2gpIHtcbiAgICBpZihnZXQmJmdldCE9PXRydWUpIHtcbiAgICAgIG1hdGNoID0gZ2V0XG4gICAgICBnZXQgPSBmYWxzZVxuICAgIH1cbiAgICB2YXIgZmllbGRzID0gZmllbGQgaW5zdGFuY2VvZiB2aWdvdXIuT2JqZWN0ID8gZmFsc2UgOiBmaWVsZCxcbiAgICAgIGN1cnIgPSB0aGlzLFxuICAgICAgZm91bmQ7XG4gICAgd2hpbGUgKGN1cnIpIHtcbiAgICAgIGZvdW5kID0gZmllbGRzID09PSBmYWxzZSA/IGN1cnIgPT09IGZpZWxkIDogZXhwb3J0cy5nZXQoY3VyciwgZmllbGRzLCAhbGlua3MpO1xuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIGlmKG1hdGNoKSB7XG4gICAgICAgICAgaWYobWF0Y2ggPT09IGZvdW5kIHx8IChmb3VuZCBpbnN0YW5jZW9mIHZpZ291ci5PYmplY3QpICYmIGZvdW5kLnZhbCA9PT0gbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiAhZ2V0ICYmIGZpZWxkcyA/IGN1cnIgOiBmb3VuZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuICFnZXQgJiYgZmllbGRzID8gY3VyciA6IGZvdW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjdXJyID0gY3VycltwYXJlbnRGaWVsZF07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuZGlzam9pbiA9IGZ1bmN0aW9uIGRpc2pvaW4oYSwgYiwgY2hlY2spIHtcbiAgLy8gY29uc29sZS5sb2coJ2Rpc2pvaW4hJylcbiAgdmFyIGZuY2hlY2sgPSB0eXBlb2YgY2hlY2sgPT09ICdmdW5jdGlvbidcbiAgXG4gIGEgPSBnZXRFbmRwb2ludChhKVxuICBiID0gZ2V0RW5kcG9pbnQoYilcblxuICBhLmVhY2goZnVuY3Rpb24oKXtcbiAgICB2YXIgaXRlbV9hID0gdGhpc1xuICAgIHZhciBpdGVtX2FfZnJvbSA9IGl0ZW1fYS5mcm9tXG4gICAgdmFyIHJlbW92ZVxuICAgIGIuZWFjaChmdW5jdGlvbigpe1xuICAgICAgdmFyIGl0ZW1fYiA9IHRoaXNcbiAgICAgIHZhciBpdGVtX2JfZnJvbSA9IGl0ZW1fYi5mcm9tXG4gICAgICBcbiAgICAgIFxuICAgICAgaWYoZm5jaGVjayl7XG4gICAgICAgIHJlbW92ZSA9IGNoZWNrKGl0ZW1fYV9mcm9tLCBpdGVtX2JfZnJvbSlcbiAgICAgIH0gZWxzZSBpZihjaGVjayA9PT0gdHJ1ZSl7XG4gICAgICAgIHJlbW92ZSA9IGl0ZW1fYV9mcm9tID09PSBpdGVtX2JfZnJvbVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2NvbXBhcmUgYScsIGl0ZW1fYV9mcm9tLnJhdywgJ3RvIGInLCBpdGVtX2JfZnJvbS5yYXcpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdmaWVsZCcsIGNoZWNrKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnYTonLCBpdGVtX2FfZnJvbVtjaGVja10udmFsKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnYjonLCBpdGVtX2JfZnJvbVtjaGVja10udmFsKVxuICAgICAgICAvLyBjb25zb2xlLmxvZygnc2FtZTonLCBpdGVtX2FfZnJvbVtjaGVja10udmFsID09PSBpdGVtX2JfZnJvbVtjaGVja10udmFsKVxuXG4gICAgICAgIHJlbW92ZSA9IGl0ZW1fYV9mcm9tW2NoZWNrXSAmJiBpdGVtX2JfZnJvbVtjaGVja10gJiZcbiAgICAgICAgICBpdGVtX2FfZnJvbVtjaGVja10udmFsID09PSBpdGVtX2JfZnJvbVtjaGVja10udmFsXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlXG4gICAgfSlcbiAgICBpZihyZW1vdmUpe1xuICAgICAgLy8gY29uc29sZS5sb2coJ1lFUyBDSEVDSyBSRU1PVkUnKVxuICAgICAgLy8gVE9ETzogXG4gICAgICBpdGVtX2EucmVtb3ZlKClcbiAgICB9XG4gIH0pXG5cbn1cblxuZnVuY3Rpb24gZ2V0RW5kcG9pbnQob2JqKXtcbiAgd2hpbGUob2JqICYmIG9iai5fX3QgPT09IDQgJiYgIW9iai5fZmlsdGVyKXtcbiAgICBvYmogPSBvYmouX3ZhbFxuICB9XG4gIHJldHVybiBvYmpcbn1cbiIsIi8vcHJvY2Vzc2VzXG52YXIgdk9iamVjdCA9IHJlcXVpcmUoJy4uL29iamVjdCcpXG5cbi8vIGNvbnNvbGUubG9nKCdpbml0IHByb2Nlc3MhJylcblxubW9kdWxlLmV4cG9ydHMgPSB7fVxuIiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSByZXF1aXJlKCcuLycpXG4gICwgViA9IHJlcXVpcmUoJy4uLycpXG4vKipcbiAqIFNldHN0b3JlcyBhcmUgdXNlZCB0byBhdm9pZCB1cGRhdGVzIHRyb3VnaG91dCBwcm90b3R5cGUgY2hhaW5zIGZvciBjaGFuZ2VzIG9mIGZpZWxkcyBvbiBvYmplY3RzXG4gKiBJdCB1c2VzIHR3byBmaWVsZHNcbiAqICAgLl9fIHRvIGluZGljYXRlIG93biB2YWx1ZXMgZm9yIHBpZWNlcyBvZiBhbiBvYmplY3QgaW5oZXJpdGVkIHRyb3VnaCB0aGUgcHJvdG90eXBlIGNoYWluXG4gKiAgIC5fIGlzIHRoZSByZWZlbmNlIGJhY2sgdG8gdGhlIG9iamVjdHMgYXMgc3RlIGluIHRoZSBwcm90b3R5cGVcbiAqIEBjb25zdHJ1Y3RvciBzZXRzdG9yZVxuICovXG5leHBvcnRzLnNldHN0b3JlID0gZnVuY3Rpb24oKSB7XG4gIGlmICggIXRoaXMuX18gKSB0aGlzLl9fID0ge31cbn1cblxuLy9UT0RPOiByZWNvbnN0cnVjdCB2YWx1ZSB1c2luZyBwaWVjZXMgb2Ygb2JqZWN0cyBpbiBfX1xuXG5leHBvcnRzLmdldFN0b3JlID0gZnVuY3Rpb24oIG5hbWUgKSB7XG4gIHJldHVybiB0aGlzLl9fIFxuICAgICAgICAgID8gKCB0aGlzLl9fW25hbWVdICE9PSB2b2lkIDAgXG4gICAgICAgICAgICA/IHRoaXMuX19bbmFtZV0gXG4gICAgICAgICAgICA6IHRoaXMuX1tuYW1lXVxuICAgICAgICAgICAgKSBcbiAgICAgICAgICA6IHRoaXMuXyAmJiB0aGlzLl9bbmFtZV1cbn1cblxuZnVuY3Rpb24gZXh0ZW5zaW9ucyggZXh0ZW5kLCBmbiwgYmFzZSwgYXJncywgZXh0ZW5kZWQgKSB7XG4gICAgXG4gIGlmKHdpbmRvdy4kVEVTVCkge1xuICAgIGNvbnNvbGUubG9nKDEyLCBleHRlbmQpXG4gIH1cblxuICBpZiggIWV4dGVuZC5leHRlbnNpb25zICkgXG4gIHtcbiAgICBpZihiYXNlKSB7XG4gICAgICBleHRlbmQuZXh0ZW5zaW9ucyA9IFtdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGV4dGVuZClcbiAgICAgIGlmKFYuT2JqZWN0ICYmIGV4dGVuZCBpbnN0YW5jZW9mIFYuT2JqZWN0ICkge1xuICAgICAgICB1dGlsLmRlZmluZSggZXh0ZW5kLCAnZXh0ZW5zaW9ucycsW10pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvL2dlYnJ1aWsgZGV6ZSBleHRlbnNpb24gc3R5bG9cbiAgICAgICAgdXRpbC5kZWZpbmUoIGV4dGVuZCwgJ2V4dGVuc2lvbnMnLHt2YWw6W10sIHNldENsYXNzOnRydWV9IClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBjb25zb2xlLmxvZyggJ0VYVEVORCcucmVkLCBleHRlbmQuZXh0ZW5zaW9ucywgYmFzZSwgZm4sIHRoaXMsIGV4dGVuZGVkIClcblxuICBpZiggdXRpbC5jaGVja0FycmF5KCBleHRlbmQuZXh0ZW5zaW9ucywgdGhpcyApPT09ZmFsc2UgKSBcbiAge1xuXG4gICAgLy8gY29uc29sZS5sb2coICdFWFRFTkQgLTInLnJlZCwgdGhpcyApXG5cbiAgICBpZiggIWV4dGVuZGVkICkgZXh0ZW5kLmV4dGVuc2lvbnMgPSBbIHRoaXMgXS5jb25jYXQoIGV4dGVuZC5leHRlbnNpb25zICkgXG5cbiAgICAgIC8vIGNvbnNvbGUubG9nKCAnRVhURU5EIC0zJy5yZWQsIGV4dGVuZC5leHRlbnNpb25zIClcbiAgICAgIC8vc29tZXRoaW4gd2VpcmQhXG5cbiAgICAvLyBjb25zb2xlLmxvZyggJ0VYVEVORCAtMycucmVkLCB0aGlzLCBleHRlbmQsIGV4dGVuZC5leHRlbnNpb25zLmxlbmd0aCApXG5cbiAgICB2YXIgbXlBcmdzID0gdXRpbC5hcmcoIGFyZ3MgKVxuICAgIGlmKCBiYXNlICYmICFleHRlbmRlZCApIHtcbiAgICAgIG15QXJnc1swXSA9IGJhc2VcbiAgICB9XG4gICAgaWYod2luZG93LiRURVNUKSBjb25zb2xlLmVycm9yKCc/P3h4eD8nLCBteUFyZ3MsIGZuLCB0aGlzKVxuICAgIHZhciByZXQgPSBmbi5hcHBseSggdGhpcywgbXlBcmdzICkgLy90aGlzIGlzIHRoZSBhcHAsIGV4dGVuZCBpcyB0aGUgZXh0ZW5zaW9uIFxuICAgIGlmKHdpbmRvdy4kVEVTVCwgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfSBlbHNlIHtcbiAgICBpZih3aW5kb3cuJFRFU1QpIGNvbnNvbGUuZXJyb3IoJz8/PycpXG4gIH1cblxufVxuXG5leHBvcnRzLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXG5cbiAgdmFyIGV4dGVuZEFycmF5ID0gdXRpbC5hcmcoIGFyZ3VtZW50cyApXG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGV4dGVuZCkge1xuXG4gICAgaWYod2luZG93LiRURVNUKSBjb25zb2xlLmxvZygnMTAgLS0tPicsIGV4dGVuZClcblxuICAgIHZhciBiYXNlXG4gICAgICAsIHByb3RvXG5cbiAgICBpZiggdHlwZW9mIGV4dGVuZCA9PT0gJ2Z1bmN0aW9uJyApIFxuICAgIHtcbiAgICAgIGlmKCBWLkJhc2UgJiYgKCBleHRlbmQucHJvdG90eXBlIGluc3RhbmNlb2YgVi5CYXNlICkgKSB7XG4gICAgICAgIGJhc2UgPSBleHRlbmQuYmFzZVxuICAgICAgICBwcm90byA9IHRydWVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3RvID0gZXh0ZW5kLnByb3RvdHlwZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiggVi5CYXNlICYmICggZXh0ZW5kIGluc3RhbmNlb2YgVi5CYXNlICkgKSBcbiAgICB7XG4gICAgICBwcm90byA9IGV4dGVuZFxuICAgIH1cblxuICAgIGZvclxuICAgICggXG4gICAgICB2YXIgZm5cbiAgICAgICAgLCByZXRcbiAgICAgICAgLCBhcmdzID0gdXRpbC5hcmcoIGFyZ3VtZW50cyApXG4gICAgICAgICwgZXh0ZW5kQXJyXG4gICAgICAgICwgeEFyZ1xuICAgICAgICAsIGkgPSAwXG4gICAgICAgICwgbGVuID0gZXh0ZW5kQXJyYXkubGVuZ3RoXG4gICAgICAgIDsgaSA8IGxlblxuICAgICAgICA7IGkgKysgXG4gICAgKSBcbiAgICB7ICAgIFxuICAgICAgaWYoZXh0ZW5kQXJyYXlbaV0gaW5zdGFuY2VvZiBBcnJheSkgXG4gICAgICB7XG4gICAgICAgIGV4dGVuZEFyciA9IGV4dGVuZEFycmF5W2ldWzBdXG4gICAgICAgIHhBcmcgPSB1dGlsLmFyZyhleHRlbmRBcnJheVtpXSwxKVxuICAgICAgICB4QXJnLnVuc2hpZnQoZXh0ZW5kKVxuICAgICAgfSBlbHNlIFxuICAgICAge1xuICAgICAgICB4QXJnID0gYXJnc1xuICAgICAgICBleHRlbmRBcnIgPSBleHRlbmRBcnJheVtpXVxuICAgICAgfVxuXG4gICAgICBpZih3aW5kb3cuJFRFU1QpIHtcbiAgICAgICAgY29uc29sZS5sb2coJzExJywgIGV4dGVuZEFyci5leHRlbmQgPyAgZXh0ZW5kQXJyIDogdGhpcywgYmFzZSB8fCBwcm90byAgKVxuICAgICAgfVxuXG4gICAgICByZXQgPSBleHRlbnNpb25zLmNhbGwgXG4gICAgICAoIGV4dGVuZEFyci5leHRlbmQgPyAgZXh0ZW5kQXJyIDogdGhpcyBcbiAgICAgICwgYmFzZSB8fCBwcm90byB8fCBleHRlbmRcbiAgICAgICwgZXh0ZW5kQXJyLmV4dGVuZCB8fCAgZXh0ZW5kQXJyXG4gICAgICAsIGJhc2VcbiAgICAgICwgeEFyZ1xuICAgICAgLCBleHRlbmRBcnIuZXh0ZW5kID8gdHJ1ZSA6IGZhbHNlIFxuICAgICAgKSBcbiAgICAgIHx8IGV4dGVuZFxuXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG59XG5cbi8qKlxuICogQWRkIGlzIHVzZWQgYXMgYSBzaG9ydGN1dCBtZXRob2QgZm9yIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBhbmQgZXh0ZW5kcyBzZXRzdG9yZSBmdW5jdGlvbmFsaXR5IHRvIG5vcm1hbCBwcm90b3R5cGVzXG4gKiBAbWV0aG9kIGFkZFxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgICBvYmogIFdoZW4gb2JqIGlzIGEgY29uc3RydWN0b3IgaXQgc2VsZWN0cyBvYmoucHJvdG90eXBlLCB3aGVuIG9iaiBpcyBhIG5vcm1hbCBvYmplY3QgdGhpcyBpcyB1c2VkIGluc3RlYWRcbiAqIEBwYXJhbSAge1N0cmluZ3xBcnJheX0gICAgbmFtZSBXaGVuIG5hbWUgaXMgYSBzdHJpbmcgaXQgYWRkcyB0aGUgbmFtZSBmb3IgdGhlIG9iamVjdCwgd2hlbiBuYW1lIGlzIGEgYXJyYXkgZG8gdGhlIHNhbWUgc2V0dGluZyBmb3IgZWFjaCBuYW1lXG4gKiBAcGFyYW0gIHtPYmplY3R8RnVuY3Rpb259IHZhbCAgV2hlbiB2YWwgaXMgYW4gb2JqZWN0ICwgdXNlIHRoaXMgb2JqZWN0IGZvciBPYmplY3QuZGVmaW5lUHJvcGVydHkgd2l0aCBkZWZhdWx0IGZvciBlbnVtbWVyYWJsZTpmYWxzZSwgd2hlbiBvYmplY3QgaXMgZW1wdHkgYWRkcyB7dmFsdWU6e30sZW5udW1lcmFibGU6ZmFsc2V9LCB3aGVuIHZhbCBpcyBhIGZ1bmN0aW9uIGl0IGF1dG9tYXRpY2FsbHkgd3JhcHMgYSBwcm9wZXJ0eSBkZWZpbml0aW9uIG9iamVjdCB3aXRoIHt2YWx1ZTogdmFsICwgZW51bW1lcmFibGU6ZmFsc2V9LCB3aGVuIHZhbCBpcyBub3QgYSBmdW5jdGlvbiBhbmQgbm90IGFuIG9iamVjdCAoYm9vbGVhbiwgc3RyaW5nLCBudW1iZXIpIGFkZHMgc3BlY2lhbCBzZXRzdG9yZSB2YWx1ZVxuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgICBbc2V0XSAgQWRkcyBjdXN0b20gc2V0dGVycyB0byBhIHNldHN0b3JlIG9iamVjdCwgd2hlbiBzZXQgaXMgYSBzdHJpbmcgdGhlIGFkZCBmdW5jdGlvbnMgaW50ZXJwcmV0cyB0aGUgYXJndW1lbnRzIGFzIG5hbWUgOiBwcm9wZXJ0eSBkZWZpbml0aW9uIHBhaXJzXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgIFtnZXRdICBBZGRzIGN1c3RvbSBnZXR0ZXJzIHRvIGEgc2V0c3RvcmUgb2JqZWN0XG4gKiBAXG4gKi9cbmV4cG9ydHMuZGVmaW5lID0gZnVuY3Rpb24gKG9iaiwgbmFtZSwgdmFsLCBzZXQsIGdldCwgaWQpIHtcbiAgaWYgKHR5cGVvZiBzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIF9hcmdzID0gdXRpbC5hcmcoYXJndW1lbnRzKVxuICAgIGZvciAodmFyIGkgPSAxLCBsID0gX2FyZ3MubGVuZ3RoOyBpIDwgbDsgaSArPSAyKSB7XG4gICAgICBleHBvcnRzLmRlZmluZShvYmosIF9hcmdzW2ldLCBfYXJnc1tpICsgMV0pXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChuYW1lIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbmFtZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgZXhwb3J0cy5kZWZpbmUob2JqLCBuYW1lW2ldLCB2YWwpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nIHx8IHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHZhbCA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogdmFsLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF2YWwgfHwgKCAhKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkgfHwgdmFsLnNldENsYXNzICApKSB7XG5cbiAgICAgICAgaWYoIHZhbCAmJiB2YWwuc2V0Q2xhc3MgKSB7XG4gICAgICAgICAgdmFsID0gdmFsLnZhbFxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3RvID0gb2JqLnByb3RvdHlwZSB8fCBvYmpcblxuXG4gICAgICAgIC8vXG5cbiAgICAgICAgLy9UT0RPOiBub3QgYSBnb29kIHNvbHV0aW9uIC0tIGhhcyB0byByZWRlZmluZSBjb25zdGFudGx5ICggdG9vIGhlYXZ5IClcbiAgICAgICAgLy8gaWYoIHByb3RvICE9PSBvYmoucHJvdG90eXBlICYmIHByb3RvLl8gKSB7XG4gICAgICAgIC8vICAgIC8vVE9ETzogdGhpcyBjYW4gZ28gY29tcGxldGVseSB3cm9uZyB3aGVuIHlvdSBleHBlY3QgaW5oZXJpdGFuY2Ugbm90IHRvIGJyZWFrIHdoZW4gbWFraW5nIGEgbmV3IGNsYXNzIVxuICAgICAgICAvLyAgICBpZiggcHJvdG8uY29uc3RydWN0b3IucHJvdG90eXBlLl8gPT09IHByb3RvLl8gKSB7XG4gICAgICAgIC8vICAgICAgIHZhciBvbGQgPSBwcm90by5fXG4gICAgICAgIC8vICAgICAgIHByb3RvLl8gPSB7fVxuICAgICAgICAvLyAgICAgICBmb3IodmFyIGtleSBpbiBvbGQpIHtcbiAgICAgICAgLy8gICAgICAgICBwcm90by5fW2tleV0gPSBvbGRba2V5XVxuICAgICAgICAvLyAgICAgICB9XG4gICAgICAgIC8vICAgIH1cbiAgICAgICAgLy8gfVxuICAgICAgICBcbiAgICAgICAgLy9tYXliZSBtYWtlIGludG8gYSBtZXRob2RcbiAgICAgICAgaWYoIGlkKSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ0RFRklORSEgRE8gSVQnLnJlZC5pbnZlcnNlLCBuYW1lLCBpZCwgcHJvdG8pXG4gICAgICAgICAgaWYgKCFwcm90by5fXykgcHJvdG8uX18gPSB7fVxuICAgICAgICAgIHByb3RvLl9fW25hbWVdID0gdmFsXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFwcm90by5fKSBwcm90by5fID0ge31cbiAgICAgICAgICBwcm90by5fW25hbWVdID0gdmFsXG4gICAgICAgIH1cblxuXG5cbiAgICAgIFxuXG4gICAgICAgIC8vaWYgcHJvdG8gaXMgbm90IGEgcHJvdG90eXBlIChob3cgdG8gY2hlY2s/KSB0aGVuIHVzZSBfXyBwZXJoYXBzP1xuXG4gICAgICAgIC8vbW9ldCBoaWVyIG5pZXQgYWx0aWpkIHplIGVpZ3VoIHdvcmRlbiBnZW1hYWt0P1xuXG4gICAgICAgLy9kZWZhdWx0IGRpdCBpcyBlaWdlbmxpamsgaGV0IGVuaWdlIGRhdCBtaXMgZ2FhdFxuXG4gICAgICAgIHZhciBzZXR0ZXIgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgZXhwb3J0cy5zZXRzdG9yZS5jYWxsKHRoaXMpXG4gICAgICAgICAgICAgIC8vVE9ETzogZml4IGNsb3N1cmUgZm9yIHZhbFxuICAgICAgICAgICAgICBpZiAodmFsIHx8IHZhbCA9PT0gMCB8fCB2YWwgPT09IGZhbHNlKSB0aGlzLl9fW25hbWVdID0gdmFsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgLCB3c2V0ID0gZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAgIHZhbCA9IHNldC5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgICAgICAgIHNldHRlci5jYWxsKHRoaXMsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLCBnZXR0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuZ2V0U3RvcmUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAsIHdnZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIHByb3AgPSBnZXR0ZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldC5jYWxsKHRoaXMsIHByb3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIHZhbCA9IHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBnZXQgPyB3Z2V0IDogZ2V0dGVyLFxuICAgICAgICAgIHNldDogc2V0ID8gd3NldCA6IHNldHRlclxuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAoIXZhbC5lbnVtZXJhYmxlKSB7XG4gICAgICAgIGlmICh1dGlsLmVtcHR5KHZhbCkpIHZhbC52YWx1ZSA9IHt9XG4gICAgICAgIHZhbC5jb25maWd1cmFibGUgPSB0cnVlXG4gICAgICAgIHZhbC5lbnVtZXJhYmxlID0gZmFsc2VcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iai5wcm90b3R5cGUgfHwgb2JqLCBuYW1lLCB2YWwpXG5cbiAgICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmoucHJvdG90eXBlIHx8IG9iaiwgbmFtZSwgdmFsKVxuICAgICAgLy9tYXllYiBkbyBib3RoP1xuICAgIH1cbiAgfVxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBiYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpXG4gICwgVmFsdWUgPSByZXF1aXJlKCcuLycpXG4gICwgb2JqZWN0U2V0ID0gcmVxdWlyZSgnLi4vb2JqZWN0Jykuc2V0XG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAvLyAsIHJhZiA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvYW5pbWF0aW9uL3JhZicpXG5cbmV4cG9ydHMuY2xvbmVsaXN0ID0gW1xuICBbICdfYmFzZScsIGZhbHNlIF0sICdfY2FsbGVyJywgJ19wcm9wJywgJ19uYW1lJywgJ19za2lwJ1xuXVxuXG5mdW5jdGlvbiByZXNvbHZlTGlzdGVuZXIoIGxpc3RlbmVyLCB2YWwsIHByb3AsIGluc3RhbmNlICkge1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBpZiAoIGxpc3RlbmVyLl9iaW5kID09PSBpbnN0YW5jZSAmJiBsaXN0ZW5lci5fX3QgPT09IDQgKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnYmluZCByZXNvbHZlJy5yZWQuYm9sZCwgdmFsIClcbiAgICAgIGxpc3RlbmVyLnZhbCA9IHZhbFxuICAgIH1cbiAgICBlbHNlIGlmICghbGlzdGVuZXIuX2JpbmQgKSB7IFxuXG4gICAgICBpZiggbGlzdGVuZXIuX190ID09PSA0ICYmIGxpc3RlbmVyLl92YWwgPT09IHByb3AgKVxuICAgICAge1xuICAgICAgICAvLyBsaXN0ZW5lci52YWwgPSBcbiAgICAgICAgbGlzdGVuZXIudmFsID0gdmFsXG4gICAgICAgIGNvbnNvbGUubG9nKCctLS0tLS0tLS0tJywgbGlzdGVuZXIuX190IClcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3VsdGltYXRlIHVnbHkhJylcbiAgICAgICAgdmFsLmFkZExpc3RlbmVyKGxpc3RlbmVyKSAvL2RpdCBmaXhlZCAgXG4gICAgICB9XG5cbiAgICAgIC8vVE9ETzogaW1wbGVtZW50IHRoaXMgbGF0ZXJcbiAgICAgIC8vIGlmKCBsaXN0ZW5lciBpbnN0YW5jZW9mIEFycmF5ICkge1xuICAgICAgLy8gICB2YXIgbWFyayA9IGxpc3RlbmVyWzFdXG4gICAgICAvLyAgIGlmKCBtYXJrICkge1xuICAgICAgLy8gICAgIGlmKCBtYXJrID09PSBwcm9wLl9iYXNlIHx8IG1hcmsgPT09IGluc3RhbmNlIHx8IGluc3RhbmNlIGluc3RhbmNlb2YgbWFyay5fY2xhc3MgKSB7XG4gICAgICAvLyAgICAgICAvL1RPRE86IHByb3BhYmx5IG5lZWQgdG8gY2hlY2sgZm9yIGluaGVyaXRhbmNlICggbWFyayBpbnN0YW5jZSBvZiBwcm9wLl9iYXNlKVxuICAgICAgLy8gICAgICAgLy8gY29uc29sZS5sb2coJ21hcmsgcmVzb2x2ZScuZ3JlZW4uaW52ZXJzZSwgbGlzdGVuZXIpXG4gICAgICAvLyAgICAgICAvLyB2YWwuYWRkTGlzdGVuZXIoWyBsaXN0ZW5lclswXSAsIGluc3RhbmNlIF0sIHRydWUpXG4gICAgICAvLyAgICAgfVxuICAgICAgLy8gICB9XG4gICAgICAvLyB9XG5cbiAgICAgIFxuICAgICAgLy8gdmFsLmFkZExpc3RlbmVyKF9saXN0ZW5lcnNbaV0pXG4gICAgfVxuICB9XG59XG5cbi8vIGZ1bmN0aW9uIHJlc29sdmVMaXN0ZW5lciggKSB7XG5cbi8vIH1cblxuLyoqXG4gKiBWLnZhbHVlLmJhc2UudHlwZVxuICogRGVmaW5lcyB0aGUgYmFzZSB0eXBlIHVzZWQgaW4gVi5WYWx1ZVxuICogQHR5cGVcbiAqL1xuZXhwb3J0cy50eXBlID0ge1xuICB0eXBlOiBWYWx1ZSxcbiAgLyoqXG4gICAqIERlZmluZXMgd2hhdCB0aGlzIHR5cGUgd2lsbCBkbyBvbiBjcmVhdGlvbi5cbiAgICogQG1ldGhvZCBjcmVhdGVcbiAgICogQHBhcmFtICB7Kn0gdmFsICAgICAgICAgICAgICBWYWx1ZVxuICAgKiBAcGFyYW0gIHtbdHlwZV19ICBbcHJvcF0gICAgIFtkZXNjcmlwdGlvbl0gLy9XT1JEVCBOSUVUIEdFQlJVSUtUXG4gICAqIEBwYXJhbSAge09iamVjdH0gIFtzZXR0aW5nc10gU2V0dGluZ29iamVjdFxuICAgKiBAcGFyYW0gIHtCb29sZWFufSBbbm91cGRhdGVdIFdoZW4gdHJ1ZSwgZG9lc24ndCB1cGRhdGUgdGhlIFYuVmFsdWVcbiAgICogQHJldHVybiB7T2JqZWN0fSAgICAgICAgICAgICBSZXR1cm5zIHRoZSBWLlZhbHVlXG4gICAqL1xuICBjcmVhdGU6IGZ1bmN0aW9uKHZhbCwgcHJvcCwgc2V0dGluZ3MsIG5vdXBkYXRlKSB7XG4gICAgdmFyIHYgPSBuZXcgVmFsdWUoKVxuICAgIHYuX2Jhc2UgPSB0aGlzXG4gICAgdi5fY2FsbGVyID0gdi5fYmFzZVxuICAgIHYuX3Byb3AgPSBzZXR0aW5nc1xuICAgIC8vIGNvbnNvbGUubG9nKCdzZXQnKVxuICAgIG9iamVjdFNldC5jYWxsKHYsIHZhbCwgZmFsc2UsIGZhbHNlLCB0cnVlKVxuICAgIC8vIGNvbnNvbGUubG9nKCdkb25lIHNldHRpbmcnKVxuICAgIGlmICh0aGlzLl9jbGFzcykgdGhpcy5fY2xhc3MucHJvdG90eXBlLl9bc2V0dGluZ3MubmFtZV0gPSB2XG4gICAgaWYgKHNldHRpbmdzLnNldCkge1xuICAgICAgaWYgKCFzZXR0aW5ncy5fdnNldCkge1xuICAgICAgICBzZXR0aW5ncy5fdnNldCA9IGZ1bmN0aW9uKHN0YW1wLCBmcm9tLCByZW1vdmUsIGN2YWwpIHtcbiAgICAgICAgICAvLyB2YXIgdCA9IHRoaXNcbiAgICAgICAgICAvLyB0Ll9fcyA9IHRydWVcbiAgICAgICAgICAvLyBpZighdC5fcykge1xuICAgICAgICAgICAgLy8gcmFmKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnSU0gSEVSRT8nKVxuICAgICAgICAgICAgICAvLyB0Ll9fcyA9IG51bGxcbiAgICAgICAgICAgICAgc2V0dGluZ3Muc2V0LmNhbGwoXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGVyXG4gICAgICAgICAgICAgICAgfHwgdGhpcy5fYmFzZVxuICAgICAgICAgICAgICAgIHx8IHRoaXMsIHRoaXMsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGN2YWxcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgLy8gfSlcbiAgICAgICAgICAvLyB9XG5cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFub3VwZGF0ZSkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnVVBEQVRFIGNyZWF0aW9uJylcbiAgICAgICAgdi5fdXBkYXRlKHZhbClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZcbiAgfSxcbiAgLyoqXG4gICAqIERlZmluZXMgd2hhdCB0aGlzIHR5cGUgd2lsbCBkbyBvbiBzZXQuXG4gICAqIEBtZXRob2Qgc2V0XG4gICAqIEBwYXJhbSAgeyp9ICAgICAgdmFsICAgICAgVmFsdWVcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wICAgICBQcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ3NvYmplY3RcbiAgICogQHJldHVybiB7Kn0gICAgICAgICAgICAgICBSZXR1cm5zIHZhbHVlXG4gICAqL1xuICBzZXQ6IGZ1bmN0aW9uKHZhbCwgcHJvcCwgc2V0dGluZ3MpIHtcblxuICAgIGlmKCFwcm9wKSByZXR1cm5cbiAgICAvLyBjb25zb2xlLmxvZygnU0VUIEZVTiEnKVxuICAgIHByb3AuX2NhbGxlciA9IHRoaXNcbiAgICAvL2RlemUgYmluZCB6b3UgYWxsZWVuIG1vZXRlbiB3ZXJrZW4gdm9vciBhbHMgamUgaWV0cyBvcCBoZXQgZXhhY3QgZ29lZGUgbW9tbWVudCBjaGFuZ2VkIVxuXG4gICAgcHJvcC5fYmluZCA9IGZhbHNlXG4gICAgaWYgKHRoaXMgIT09IHByb3AuX2Jhc2UpIHtcbiAgICAgIHZhciBfbGlzdGVuZXJzID0gcHJvcC5fbGlzdGVuZXJzXG4gICAgICAgICwgX2IgPSBwcm9wLl9iYXNlXG4gICAgICAgICwgaVxuICAgICAgICAsIF90aGlzID0gdGhpc1xuXG4gICAgICB1dGlsLnNldHN0b3JlLmNhbGwodGhpcylcbiAgICAgIGV4cG9ydHMuY2xvbmVsaXN0WzBdWzFdID0gdGhpcyAvL2JlZXRqZSBkaXJ0eS4uLlxuXG4gICAgICAvL2Nsb25lIGlzIGFsd2F5cyB1c2VkIHRvIGdldCByaWQgb2YgZmxhZ3NcbiAgICAgIGlmICh2YWwgIT09IHZvaWQgMCAmJiAhdmFsLmNsZWFyKSB7XG4gICAgICAgIHZhbCA9IHByb3AuY2xvbmUodmFsLCBmYWxzZSwgZXhwb3J0cy5jbG9uZWxpc3QpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZihwcm9wLl9mbGFnKSB7XG4gICAgICAgIC8vICAgdmFsdWUuZmxhZ3NbcHJvcC5fZmxhZ1swXV0ucmVtb3ZlICYmIHZhbHVlLmZsYWdzW3Byb3AuX2ZsYWdbMF1dLnJlbW92ZS5jYWxsKHRoaXMscHJvcC5fZmxhZylcbiAgICAgICAgLy8gfVxuICAgICAgICAvL2xpc3RlbmVyIG9uIG5lc3RlZCBjaGlsZCBvbiBwYXJlbnRcblxuICAgICAgICAgLy8tLS0+ICBuZXcgd2lkdGggZm9yIHRoaXMgb25lXG4gICAgICAgICAvLyAtLS0+ICBoZXkgYSBsaXN0ZW5lciBvbiBtZSAvdyBhIGJpbmQgb24gbXkgaW5zdGFuY2UhXG4gICAgICAgICAvLyAgLS0tLT4gYWRkIGxpc3RlbmVyIHRvIG1lIChsaXN0ZW5lciBvbiBjbGFzcyBwcm9wKVxuICAgICAgICAgLy8gICAtLS0tLT4gaGV5IGxldHMgcmVzZXQgdGhpcyBsaXR0bGUgZ3V5cyB3aWR0aFxuICAgICAgICAgLy8gICAgLS0tLS0tPiAgbGV0cyBhZGQgTGlzdGVuZXJcbiAgICAgICAgIC8vICAgICAtLS0tLS0tLT4gIGRvdWJsZSBsaXN0ZW5lcnMgb24gdGhpcyBvbmVcbiAgICAgICAgdmFyIHYgPSBuZXcgVmFsdWUoKVxuICAgICAgICB2Ll9iYXNlID0gdGhpc1xuICAgICAgICB2Ll9wcm9wID0gc2V0dGluZ3NcbiAgICAgICAgdi5fY2FsbGVyID0gdGhpc1xuXG4gICAgICAgIC8vIGNsZWFuIEZMQUdTIGZyb20gbm9kZSFcbiAgICAgICAgaWYodmFsKSBkZWxldGUgdmFsLmNsZWFyXG4gICAgICAgIHYudmFsID0gdmFsXG4gICAgICAgIHZhbCA9IHZcbiAgICAgIH1cblxuICAgICAgdGhpcy5fX1tzZXR0aW5ncy5uYW1lXSA9IHZhbFxuXG4gICAgICBpZiggdGhpcy5fY2xhc3MgKSB0aGlzLl9jbGFzcy5wcm90b3R5cGUuX1tzZXR0aW5ncy5uYW1lXSA9IHZhbFxuXG4gICAgICAvLyBmb3IgZWFjaCBmaWVsZCAob25seSAxIGxldmVsIGRlZXAgZm9yIG5vdylcbiAgICAgIHByb3AuZWFjaFxuICAgICAgKCBcbiAgICAgICAgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ3Jlc29sdmUnLCBwcm9wLl9wcm9wLm5hbWUsIGtleSlcbiAgICAgICAgICAgaWYoIHRoaXMuX2xpc3RlbmVycyApIHtcbiAgICAgICAgICAgIGZvciAoaSA9ICB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZUxpc3RlbmVyKCB0aGlzLl9saXN0ZW5lcnNbaV0sIHZhbFtrZXldLCBwcm9wLCBfdGhpcyApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1RPRE86IGNoZWNrIGlmIHRoaXMgaXMgbmVzc2VjYXJ5XG4gICAgICAgICAgICBpZih2YWxba2V5XS52YWwgIT09IHRoaXMudmFsKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2YWxba2V5XSkgXG4gICAgICAgICAgICAgIC8vIHZhbFtrZXldLl91cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuXG4gICAgICBpZiggX2xpc3RlbmVycyApIHtcblxuICAgICAgICBmb3IgKGkgPSBfbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgcmVzb2x2ZUxpc3RlbmVyKCBfbGlzdGVuZXJzW2ldLCB2YWwsIHByb3AsIF90aGlzIClcbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIHZhbCA9IG51bGxcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdVUERBQ0UgLS0tLScueWVsbG93KVxuICAgICAgdGhpc1tzZXR0aW5ncy5uYW1lXS5fdXBkYXRlKHZhbClcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsXG4gIH0sXG4gIC8qKlxuICAgRGVmaW5lcyB3aGF0IHRoaXMgdHlwZSB3aWxsIGRvIG9uIGdldC5cbiAgICogQG1ldGhvZCBnZXRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwcm9wICAgICBQcm9wZXJ0aWVzXG4gICAqIEBwYXJhbSAge09iamVjdH0gc2V0dGluZ3MgU2V0dGluZ29iamVjdFxuICAgKiBAcmV0dXJuIHtPYmplY3R9ICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgKi9cbiAgZ2V0OiBmdW5jdGlvbihwcm9wLCBzZXR0aW5ncykge1xuICAgIC8vIGNvbnNvbGUubG9nKCdHRVRUSU5HIScsIHByb3AsIHNldHRpbmdzLm5hbWUpXG4gICAgaWYgKHByb3ApIHByb3AuX2NhbGxlciA9IHRoaXNcbiAgICBpZiAoc2V0dGluZ3MuZ2V0KSByZXR1cm4gc2V0dGluZ3MuZ2V0LmNhbGwodGhpcywgcHJvcClcbiAgICByZXR1cm4gcHJvcFxuICB9XG59IiwiLyohXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCwgVmlnb3VyLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogQGF1dGhvcjogSmltIGRlIEJlZXIsIGppbUB2aWdvdXIuaW9cbiAqL1xudmFyIGZsYWdzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpLFxuICBvYmplY3QgPSByZXF1aXJlKCcuLi8uLi9vYmplY3QnKSxcbiAgb3duTW9kZWwgPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgaWYgKCFiYXNlLl9fIHx8ICFiYXNlLl9fLm1vZGVsKSB7IC8vbWF5YmUgYSB1dGlsaXR5PyB1c2UgaXQgYXQgZGlmZmVyZW50IHNwb3RzIGxpa2Ugc2V0dGluZ3NcbiAgICAgIGJhc2UubW9kZWwgPSB7fTtcbiAgICAgIGlmICghYmFzZS5fLm1vZGVsKSB7XG4gICAgICAgIGJhc2UuX2RMaXN0ZW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2UubW9kZWw7XG4gIH07XG4vKipcbiAqIGRhdGFcbiAqIGRhdGEgYWRkcyBhIHJlZmVyZW5jZSB0byB0aGUgZGF0YSBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBiYXNlIGNsYXNzO1xuICogaWYgdGhlcmUgaXMgbm90IF9iYXNlLm1vZGVsIHVzZSBkYXRhLmJhc2UuZXh0ZW5kKGJhc2VDbGFzcyk7XG4gKiBAZmxhZ1xuICovXG5mbGFncy5kYXRhID0ge1xuICB1c2VWYWw6dHJ1ZSwgLy8ocmVzZXQ/Pz8pXG4gIHNldDogZnVuY3Rpb24odmFsLCBzdGFtcCwgcmVzZXQpIHtcblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AubmFtZScpLFxuICAgICAgbmFtZSA9IGN1cnJlbnQuX3Byb3AubmFtZSxcbiAgICAgIGJhc2UgPSBjdXJyZW50Ll9iYXNlLFxuICAgICAgbW9kZWwgPSBvd25Nb2RlbChiYXNlKTtcbiAgICBpZiAobW9kZWwuZmxhZ3MgJiYgbW9kZWwuZmxhZ3NbbmFtZV0pIHtcbiAgICAgIGlmICghKG1vZGVsLmZsYWdzW25hbWVdIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICAgIG1vZGVsLmZsYWdzW25hbWVdID0gW21vZGVsLmZsYWdzW25hbWVdXTtcbiAgICAgIH1cbiAgICAgIGlmICghdXRpbC5jaGVja0FycmF5KG1vZGVsLmZsYWdzW25hbWVdLCB0aGlzKSkge1xuICAgICAgICBtb2RlbC5mbGFnc1tuYW1lXS5wdXNoKHRoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWJhc2UubW9kZWwuZmxhZ3MpIHtcbiAgICAgICAgYmFzZS5tb2RlbC5mbGFncyA9IHt9O1xuICAgICAgfVxuICAgICAgYmFzZS5tb2RlbC5mbGFnc1tuYW1lXSA9IHRoaXM7XG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ0xFWlogU0VUIElUIScsIHZhbCwgc3RhbXAsIHJlc2V0LCBjdXJyZW50KVxuXG4gICAgdmFyIGdldERhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5fZDtcbiAgICAgIGlmIChkYXRhID09PSB2b2lkIDApIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXM7XG4gICAgICAgIHdoaWxlIChkYXRhID09PSB2b2lkIDAgJiYgcGFyZW50KSB7XG5cbiAgICAgICAgICAvLyBpZihwYXJlbnQubW9kZWwgJiYgKCFwYXJlbnQubW9kZWwuaW5oZXJpdCB8fCBwYXJlbnQubW9kZWwuaW5oZXJpdC52YWwhPT1mYWxzZSkpIHtcbiAgICAgICAgICAvLyAgIHJldHVybiBkYXRhXG4gICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgLy8gY29uc29sZS5lcnJvcignc2V0IGl0IC93IHBhcmVudCEnLCB0aGlzLm5hbWUsIHBhcmVudC5uYW1lKVxuXG4gICAgICAgICAgaWYgKHBhcmVudC5fZCkge1xuXG4gICAgICAgICAgICBpZihwYXJlbnQubW9kZWwgJiYgcGFyZW50Lm1vZGVsLmZpZWxkICYmIHBhcmVudC5tb2RlbC5maWVsZC52YWwgIT09IHBhcmVudC5tb2RlbFBhcnNlZCkge1xuICAgICAgICAgICAgICBwYXJlbnQuX2QgPSBwYXJlbnQuX2RbcGFyZW50Lm1vZGVsLmZpZWxkLnZhbF0gfHwgcGFyZW50Ll9kLmZyb21bcGFyZW50Lm1vZGVsLmZpZWxkLnZhbF1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignaGV0IGhleSBpdHMgcGFyZW50IG1vZGVsJywgcGFyZW50Lm1vZGVsLmZpZWxkLnZhbClcbiAgICAgICAgICAgICAgLy8gcGFyZW50Lm1vZGVsID0ge31cbiAgICAgICAgICAgICAgcGFyZW50Lm1vZGVsUGFyc2VkID0gcGFyZW50Lm1vZGVsLmZpZWxkLnZhbFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZihwYXIpXG5cbiAgICAgICAgICAgIGlmKHRoaXMubW9kZWwmJnRoaXMubW9kZWwuZmllbGQgJiYgdGhpcy5tb2RlbFBhcnNlZCAhPT0gdGhpcy5tb2RlbC5maWVsZC52YWwpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignaGV5IGhleSBoZXkhIGkgZ290IGEgbW9kZWwgbXlzZWxmIScsIHRoaXMubW9kZWwuZmllbGQudmFsLCBwYXJlbnQuX2Qua2V5cywgcGFyZW50Ll9kKVxuXG4gICAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kU2V0KHBhcmVudC5fZFt0aGlzLm1vZGVsLmZpZWxkLnZhbF0gfHwgcGFyZW50Ll9kLmZyb21bdGhpcy5tb2RlbC5maWVsZC52YWxdLCB0cnVlKTtcbiAgICAgICAgICAgICAgLy8gdGhpcy5tb2RlbCA9IHt9XG4gICAgICAgICAgICAgIHRoaXMubW9kZWxQYXJzZWQgPSB0aGlzLm1vZGVsLmZpZWxkLnZhbFxuICAgICAgICAgICAgICAvLyB0aGlzLm1vZGVsLnBhcnNlZCA9IHRoaXMubW9kZWwuZmllbGQudmFsXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkYXRhID0gdGhpcy5fZFNldChwYXJlbnQuX2QsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIC8vIGlmKHBhcmVudC5tb2RlbCAmJiBwYXJlbnQubW9kZWwuZmllbGQpIHtcbiAgICAgICAgICAgIC8vICAgY29uc29sZS5lcnJvcignaXQgaXMgYSBmaWVsZCEnLCBwYXJlbnQubW9kZWwuZmllbGQudmFsKVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQubm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuYmFzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG4gICAgaWYgKHZhbCBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgdmFyIHYgPSB2YWwudmFsIHx8IHZhbDtcbiAgICAgIHRoaXMuX3ZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IGdldERhdGEuY2FsbCh0aGlzKTtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLS0+Jyx2LGRhdGEpXG4gICAgICAgIHJldHVybiBkYXRhICYmIHYuY2FsbCh0aGlzLCBkYXRhKTtcbiAgICAgIH07XG4gICAgICB2YWwgPSB2YWwubGlzdGVuIHx8IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YSA9IGdldERhdGEuY2FsbCh0aGlzKSxcbiAgICAgICAgICByZXQ7XG4gICAgICAgIGRhdGEgPSB2YWwgPT09IHRydWUgPyBkYXRhIDogdXRpbC5nZXQoZGF0YSwgdmFsKTtcbiAgICAgICAgaWYgKGRhdGEgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHJldCA9IGRhdGEuX190ICYmICFkYXRhLl9maWx0ZXIgJiYgZGF0YS52YWw7XG4gICAgICAgICAgaWYgKCFyZXQgJiYgcmV0ICE9PSAwICYmIHJldCAhPT0gJycpIHsgLy93ZWlyZFxuICAgICAgICAgICAgcmV0ID0gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmKCF0aGlzLl9mbGFnKSB0aGlzLl9mbGFnID0ge31cblxuICAgIC8vIHRoaXMuX19sdmFsID0gZmFsc2VcbiAgICAvLyBjdXJyZW50Ll9jYWxsZXIuc2V0U2V0dGluZyh7XG4gICAgLy8gICBuYW1lOiBuYW1lLFxuICAgIC8vICAgcGFyZW50OiBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAvLyAgICAgY29uc29sZS5sb2coJyFAIyFAIyFAIycpXG4gICAgLy8gICAgIHRoaXMudXBkYXRlRGF0YSgpXG4gICAgLy8gICB9XG4gICAgLy8gfSk7XG5cbiAgICB0aGlzLl9mbGFnLmRhdGEgPSBbJ2RhdGEnLCB0aGlzLl92YWwsIHZhbCwgbmFtZV07XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNoZWNrUGFyZW50KCdfcHJvcC5uYW1lJyksXG4gICAgICBtb2RlbCA9IG93bk1vZGVsKGN1cnJlbnQuX2Jhc2UpLFxuICAgICAgdCA9IHRoaXM7XG4gICAgaWYgKG1vZGVsICYmIG1vZGVsLmZsYWdzKSB7XG4gICAgICBmb3IgKHZhciBpIGluIG1vZGVsLmZsYWdzKSB7XG4gICAgICAgIGlmIChpID09PSBjdXJyZW50Ll9wcm9wLm5hbWUpIHtcbiAgICAgICAgICB2YXIgaXRlbSA9IG1vZGVsLmZsYWdzW2ldO1xuICAgICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2Ygb2JqZWN0IHx8IGl0ZW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBtb2RlbC5mbGFnc1tpXSA9IG51bGw7XG4gICAgICAgICAgICBkZWxldGUgbW9kZWwuZmxhZ3NbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1vZGVsLmZsYWdzW2ldLnNwbGljZSh1dGlsLmNoZWNrQXJyYXkoaXRlbSwgdCksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl91cGRhdGUoKSAvL3BhcyBoaWVybWVlIG9wIVxuICAgIC8vIHZhciB0ID0gdGhpc1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAvL2RlemUgcGFzIHVpdHZvZXJlbiBuYWRhdCBhbGxlIGtsYWFyIGlzISBkaXQgaXMgZGlydHkhXG4gICAgICB0Ll91cGRhdGUoKVxuICAgIH0sMClcbiAgfVxufTsiLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgdmFsdWUgPSByZXF1aXJlKCcuLi8nKSxcbiAgICBiYXNlID0gcmVxdWlyZSgnLi4vYmFzZScpLFxuICAgIGZsYWdzID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0L2ZsYWdzJyk7XG4gICAgXG4gICAgYmFzZS5jbG9uZWxpc3QucHVzaChbJ19mbGFnJywgdHJ1ZV0pOyAvL3RydWUgY2xvbmUhXG4gICAgZmxhZ3MuZXh0ZW5kKHZhbHVlKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHZhbHVlLmZsYWdzOyIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBmbGFncyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi8nKVxuICAsIHZhbHVlID0gcmVxdWlyZSgnLi4vJylcbiAgLCB1dGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpXG4gICwgdk9iamVjdCA9IHJlcXVpcmUoJy4uLy4uL29iamVjdCcpXG5cblxuLy90b2RvIGFkZCBlbGVtZW50IHNpZ25hdHVyZSBpbiBmcm9tIHNvIGl0IGNhbiB0cmF2ZWwgdHJvdWdoIHVwZGF0ZXMgLS0tIGlmIHBhcmVudCAobmVlZCBsZXNzIGZ1bmt5IHRoaW5ncylcblxuLyoqXG4gKiBwYXJlbnRcbiAqIHBhcmVudCBtYWtlcyBpdCBwb3NzaWJsZSB0byBhZGQgbGlzdGVuZXJzIHRvIHBhcmVudCBwcm9wZXJ0aWVzXG4gKiB1c2luZyBtdWx0aXBsZSBwYXJlbnQgcHJvcGVydGllcyBpbiBvbmUgcHJvcGVydHkgaXMgc3RpbGwgdmVyeSB3cm9uZ1xuICogQGZsYWdcbiAqL1xudmFsdWUucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnX3BhcmVudFN0b3JlJylcblxuZnVuY3Rpb24gYmFzZVJlc2V0KGJhc2UsbmFtZSkge1xuICBpZihiYXNlICYmIGJhc2Uubm9kZSkge1xuICAgIGlmKG5hbWU9PT0neCcgfHwgbmFtZSA9PT0neScpIGJhc2UuY2xlYW5Db29yZGluYXRlcyhuYW1lKVxuICAgIGlmKGJhc2VbbmFtZV0pIHtcbiAgICAgIGJhc2VbbmFtZV0uX3Byb3AuX3ZzZXQuY2FsbChiYXNlW25hbWVdKVxuICAgIH1cbiAgfVxufVxuXG5cbi8vIHdpbmRvdy5wY2hlY2sgPSAwXG5cbi8vIHdpbmRvdy5wcHJvcHMgPSB7fVxuXG4vL2Jhc2UsdnNldCx0LHR5cGUsbXBhcmVudCxmYmFzZSwgdiwgdmFsLCBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCB0cnVlLCBmaXJzdFNraXBcbmZ1bmN0aW9uIGNoZWNrZXIodnNldCwgdCwgdHlwZSwgbXBhcmVudCwgZmJhc2UsIHYsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgZmlyc3QsIGZpcnN0U2tpcCwgcCkge1xuICBpZihwJiYodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBtcGFyZW50KSB8fCAgKCFwICYmIHRoaXMucGFyZW50PT09bXBhcmVudCkgfHwgZmlyc3RTa2lwICkge1xuXG4gICAgLy8gcGNoZWNrKytcblxuICAgIHZhciBzXG4gICAgICAsIGJhc2UgPSB0aGlzLl9mcm9tLmJhc2Uubm9kZSAmJiB0aGlzLl9mcm9tLmJhc2VcbiAgICAgICwgbmFtZSA9IHQuX3Byb3AubmFtZVxuXG4gICAgLy8gaWYoIXdpbmRvdy5wcHJvcHNbbmFtZV0pIHdpbmRvdy5wcHJvcHNbbmFtZV0gPSAwXG5cbiAgICAvLyB3aW5kb3cucHByb3BzW25hbWVdKytcblxuXG4gICAgdC5fY2FsbGVyID0gdGhpc1xuXG4gICAgLy9nYXVyZCB2b29yIGNoYW5nZXMgLS0gaWYgbm8gY2hhbmdlIC0tIGRvIG5vdGhpbmdcbiAgICB2c2V0LmNhbGwodCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgdmFsKVxuXG4gICAgaWYoYmFzZSYmYmFzZVtuYW1lXSYmYmFzZVtuYW1lKydfX3AnXSE9PXN0YW1wKSB7XG4gICAgICB0Ll9jYWxsZXIgPSBiYXNlXG4gICAgICB0Ll9jYWxsZXJbbmFtZSsnX19wJ10gPSBzdGFtcFxuICAgICAgdnNldC5jYWxsKHQsIHN0YW1wLCBmcm9tLCByZW1vdmUsIHZhbClcbiAgICAgIHQuX2NhbGxlciA9IHRoaXNcbiAgICAgIHM9dHJ1ZVxuICAgIH1cblxuICAgIC8vIGNvbnNvbGUubG9nKHRoaXMubm9kZSlcbiAgICBmb3IodmFyIGkgaW4gdC5fbGlzdGVuZXJzKSB7XG4gICAgICBpZih0Ll9saXN0ZW5lcnNbaV0ucG9wICYmIHQuX2xpc3RlbmVyc1tpXVsyXT09PSdwYXJlbnQnKSB7XG4gICAgICAgIGlmKHQuX2xpc3RlbmVyc1tpXVsxXS5fbHN0YW1wPT09c3RhbXApIHtcbiAgICAgICAgICB0Ll9saXN0ZW5lcnNbaV1bMV0uX2xzdGFtcD1udWxsXG4gICAgICAgIH1cbiAgICAgICAgdC5fbGlzdGVuZXJzW2ldWzBdLmNhbGwodC5fbGlzdGVuZXJzW2ldWzFdLCB0eXBlLCB0aGlzLCBiYXNlLCB2LCB2YWwsIHN0YW1wLCBmcm9tLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIHRydWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9yZXNldCB0aGlzLl9mcm9tLmJhc2VbdC5fcHJvcC5uYW1lXT09PXRcbiAgICBpZihzKSBiYXNlUmVzZXQoYmFzZSwgbmFtZSlcblxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhhbmRsZXIodHlwZSxtcGFyZW50LGZiYXNlLHYsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCxmaXJzdFNraXAsaW5oZXJpdCkge1xuXG4gIHZhciB0ID0gdGhpc1xuXG4gIHRoaXMuX3BhcmVudFN0b3JlWzBdID0gbXBhcmVudFxuXG4gIHRoaXMuX3VwZGF0ZSh2YWwsIGZyb20gPyB0aGlzLnN0YW1wKCkgOiBzdGFtcCwgZnJvbSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBmYWxzZSwgZmFsc2UsIGZ1bmN0aW9uKCkge1xuICAgIHZhciB2c2V0ID0gIHRoaXMuY2hlY2tQYXJlbnQoJ19wcm9wLl92c2V0JywgdHJ1ZSlcbiAgICAgICwgYmFzZSA9IHRoaXMuY2hlY2tQYXJlbnQoJ19iYXNlJywgdHJ1ZSlcbiAgICAgICwgY29tcGxleFBhcmVudCA9IHRydWVcbiAgICAgICwgcFxuXG4gICAgaWYoIChtcGFyZW50PT09YmFzZS5wYXJlbnQgJiYgZnJvbSkgICkge1xuICAgICAgcCA9IHRydWVcbiAgICB9XG5cbiAgICBjaGVja2VyLmNhbGwoYmFzZSx2c2V0LHQsdHlwZSxtcGFyZW50LGZiYXNlLCB2LCB2YWwsIHN0YW1wLCBmYWxzZSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCB0cnVlLCBmaXJzdFNraXApXG5cbiAgICBiYXNlLmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHtcbiAgICAgY2hlY2tlci5jYWxsKHRoaXMsIHZzZXQsIHQsdHlwZSwgbXBhcmVudCxmYmFzZSwgdiwgdmFsLCBzdGFtcCwgZmFsc2UsIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgZmFsc2UsIHApXG4gICAgfSwgdC5fcHJvcC5uYW1lKVxuXG4gICAgdk9iamVjdC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHRoaXMsIHZhbCwgc3RhbXAsIGZhbHNlLCByZW1vdmUsIGFkZGVkLCBvbGR2YWwsIGZ1bmN0aW9uKGwpIHtcbiAgICAgIHJldHVybiBsWzJdPT09J3BhcmVudCdcbiAgICB9KVxuXG4gICAgaWYoIWluaGVyaXQgJiYgdi5fY2FsbGVyICYmIG1wYXJlbnQhPT12Ll9jYWxsZXIpIHtcbiAgICAgIHVwZGF0ZUhhbmRsZXIuY2FsbCh0aGlzLHR5cGUsdi5fY2FsbGVyLGZiYXNlLCB2LCB2YWwsIHN0YW1wLCBmYWxzZSwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLGZpcnN0U2tpcCx0cnVlKVxuICAgIH1cblxuICB9KVxufVxuXG5mdW5jdGlvbiBfcGFyZW50KHBhcmVudCwgbm91cGRhdGUsIHByb3AsIGZsYWcsIHJlc2V0KSB7XG5cbiAgLy8gY29uc29sZS5sb2coJ19wYXJlbnQgY2FsbCcuY3lhbi5pbnZlcnNlLCBmbGFnKVxuXG4gIHZhciBfbHBhcmVudCA9IHByb3AuX3BhcmVudFN0b3JlWzBdXG4gICAgLCBwbmFtZSA9IGZsYWdbMl0gICAvL2ZsYWdzLnBhcmVudC52YWxcbiAgICAsIHBwcm9wID0gcGFyZW50W3BuYW1lXVxuICAgICwgZmJhc2UgPSB0aGlzLl9mcm9tLmJhc2VcbiAgICAsIG5ld1BcbiAgICAsIGJhc2VTZXRcblxuICBpZiAoIXBwcm9wKSByZXR1cm5cblxuICAvLyBjb25zb2xlLmxvZygnQUREIExJU1RFTkVSIFRPIFBBUkVOVCcpXG5cbiAgcHByb3AuYWRkTGlzdGVuZXIoXG4gICAgWyB1cGRhdGVIYW5kbGVyXG4gICAgLCBwcm9wXG4gICAgLCAncGFyZW50J1xuICAgICwgcGFyZW50XG4gICAgLCB0aGlzIC8vZmJhc2VcbiAgXSwgZnVuY3Rpb24obCxsaXN0ZW5lcnMsaW5kZXgpIHtcblxuICAgIGlmKGxbM10hPT1wYXJlbnQgJiYgIF9scGFyZW50IT09cGFyZW50ICYmIGxbNF0hPT1mYmFzZSkge1xuICAgICAgcHJvcC5fcGFyZW50U3RvcmVbMF0gPSBwYXJlbnRcbiAgICAgIGxbNF0gPSBmYmFzZVxuICAgICAgbmV3UCA9IHRydWUgLy9ob2UgZGV6ZSBzbWFydCBhZnZhbmdlbj9cbiAgICB9XG4gIH0sIGZhbHNlLCB0cnVlKVxuXG4gIC8vIGlmKHJlc2V0KSB7XG4gIC8vICAgZm9yKHZhciBpIGluIHBwcm9wLl9saXN0ZW5lcnMpIHtcbiAgLy8gICAgIGlmKHBwcm9wLl9saXN0ZW5lcnNbaV0ucG9wICYmIHBwcm9wLl9saXN0ZW5lcnNbaV1bMV09PT1mYmFzZVtwcm9wLl9wcm9wLm5hbWVdKSB7XG4gIC8vICAgICAgIGlmKHBwcm9wIT09cGFyZW50Ll9mcm9tLmJhc2VbcG5hbWVdKSB7XG4gIC8vICAgICAgICAgcHByb3AuX2xpc3RlbmVycy5zcGxpY2UoaSwxKVxuICAvLyAgICAgICAgIGJyZWFrO1xuICAvLyAgICAgICB9XG4gIC8vICAgICB9XG4gIC8vICAgfVxuICAvLyB9XG5cbiAgaWYgKG5ld1AgfHwgKCFfbHBhcmVudCB8fCAoX2xwYXJlbnQgIT09IHBhcmVudCAmJiBfbHBhcmVudFtwbmFtZV0gIT09IHBwcm9wKSApICkge1xuICAgIHByb3AuX3BhcmVudFN0b3JlWzBdID0gcGFyZW50XG4gICAgaWYgKCFub3VwZGF0ZSkge1xuICAgICAgcHJvcC5fY2FsbGVyID0gKGJhc2VTZXQgPSBmYmFzZS5ub2RlICYmIGZiYXNlIHx8IHByb3AuX2Jhc2UpXG4gICAgICBwcm9wLl9wcm9wLl92c2V0LmNhbGwocHJvcCwgcHJvcClcbiAgICAgIHByb3AuX2NhbGxlciA9IHRoaXNcbiAgICAgIHVwZGF0ZUhhbmRsZXIuY2FsbChwcm9wLCdwYXJlbnQnLHBhcmVudCxmYmFzZSxwcHJvcCxmYWxzZSx2T2JqZWN0LnN0YW1wKCksZmFsc2UsZmFsc2UsZmFsc2UsZmFsc2UsdHJ1ZSx0cnVlKVxuICAgICAgYmFzZVJlc2V0KGJhc2VTZXQscHJvcC5fcHJvcC5uYW1lKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBfaW5pdCh2YWwsIGZsYWcsIHJlc2V0KSB7XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudFxuICAvLyBjb25zb2xlLmxvZygndHJ5IHBhcmVudCcsIGZsYWcsIHBhcmVudClcbiAgaWYgKHBhcmVudCkgX3BhcmVudC5jYWxsKHRoaXMsIHBhcmVudCwgdHJ1ZSwgdmFsLCBmbGFnLCByZXNldClcbn1cblxuZnVuY3Rpb24gX3ZhbCh2YWwpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50IHx8IHZhbC5jaGVja1BhcmVudCgnX3BhcmVudFN0b3JlLjAnLCB0cnVlKVxuICAvL2ZsYWdzLnBhcmVudC52YWxcbiAgaWYocGFyZW50ICYmICF2YWwuX2ZsYWcucGFyZW50KSB7XG4gICAgY29uc29sZS5lcnJvcignTk8gUEFSRU5UIEZMQUchJylcbiAgICByZXR1cm5cbiAgfVxuICAvLyBjb25zb2xlLmxvZygnLS0tLT4nLHZhbC5fZmxhZy5wYXJlbnRbMl0pXG4gIGlmIChwYXJlbnQgKSByZXR1cm4gcGFyZW50W3ZhbC5fZmxhZy5wYXJlbnRbMl1dLnZhbFxufVxuXG5mbGFncy5wYXJlbnQgPVxueyByZXNldDogdHJ1ZVxuLCB1c2VWYWw6IHRydWVcbiwgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCkge1xuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AubmFtZScpLFxuICAgICAgbmFtZSA9IGN1cnJlbnQuX3Byb3AubmFtZVxuICAgIC8vZmxhZ3MucGFyZW50LnZhbFxuICAgIGlmKCF0aGlzLl9mbGFnKSB0aGlzLl9mbGFnID0ge31cblxuICAgICAgLy9vdmVyd3JpdGluZyBwcmV2aW91cyBwYXJlbnRcbiAgICAgIC8vXG4gICAgLy8gY29uc29sZS5sb2coJ1NFVCBQQVJFTlQtLS0tPicpXG4gICAgdGhpcy5fZmxhZy5wYXJlbnQgPSBbJ3BhcmVudCcsIF92YWwsIHZhbCwgdGhpc11cbiAgICBpZiAoIWN1cnJlbnQuX3BhcmVudFN0b3JlKSBjdXJyZW50Ll9wYXJlbnRTdG9yZSA9IFtmYWxzZV1cblxuICAgIC8vIGNvbnNvbGUubG9nKCdHT1RTIFBBUkVOVFNUT1JFIScsIHJlc2V0LCBjdXJyZW50Ll9wYXJlbnRTdG9yZSwgdGhpcy5fZmxhZy5wYXJlbnQpXG5cbiAgICBjdXJyZW50Ll9wYXJlbnRTdG9yZS5wdXNoKHRoaXMpXG4gICAgLy9zZXRQYXJlbnQgc2V0dGluZ3NcbiAgICAvLyBjb25zb2xlLmxvZygnLS0tPiBDUkVBVEUgU0VUVElORycueWVsbG93LmludmVyc2UpXG4gICAgY3VycmVudC5fY2FsbGVyLnNldFNldHRpbmcoe1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHBhcmVudDogZnVuY3Rpb24ocGFyZW50KSB7XG5cbiAgICAgICAgLy8gY29uc29sZS5sb2coJy0tLT4gU0VUIFNFVFRJTkcnLnllbGxvdy5pbnZlcnNlKVxuXG4gICAgICAgIGZvciAodmFyIHN0b3JlID0gdGhpc1tuYW1lXS5fcGFyZW50U3RvcmUsIGkgPSBzdG9yZSA/IHN0b3JlLmxlbmd0aCAtIDEgOiAwOyBpID4gMDsgaS0tKSB7XG4gICAgICAgICAgaWYoc3RvcmVbaV0uX2ZsYWcucGFyZW50KSB7XG4gICAgICAgICAgICBfcGFyZW50LmNhbGwodGhpcywgcGFyZW50LCBmYWxzZSwgdGhpc1tuYW1lXSwgc3RvcmVbaV0uX2ZsYWcucGFyZW50KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCcyIE5PIFBBUkVOVCBGTEFHIScpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy90cnkgdG8gbWluaW1pemUgdmFsIGNhbHVsYXRpb25zXG4gICAgdGhpcy5fdmFsID0gX3ZhbFxuICAgIHRoaXMuX3NraXAgPSB0cnVlXG4gICAgLy9vbkluaXQgKGlmIGl0IGFscmVhZHkgaGFzIHNvbWUgcGFyZW50cylcbiAgICBfaW5pdC5jYWxsKGN1cnJlbnQuX2Jhc2UsIGN1cnJlbnQsIHRoaXMuX2ZsYWcucGFyZW50LCByZXNldClcbiAgICAvL3JlQXR0YWNoIGxpc3RlbmVycyBmb3IgaW5zdGFuY2VzXG4gICAgY3VycmVudC5fYmFzZS5lYWNoSW5zdGFuY2UoX2luaXQsIG5hbWUsIGN1cnJlbnQsIHRoaXMuX2ZsYWcucGFyZW50KVxuICB9XG4sIHJlbW92ZTogZnVuY3Rpb24oZmxhZykge1xuXG4gICAgLy8gY29uc29sZS5sb2coJ1JFTU9WRSBQQVJFTlQnLmN5YW4uaW52ZXJzZSlcblxuICAgIHZhciBjdXJyZW50ID0gdGhpcy5jaGVja1BhcmVudCgnX3Byb3AubmFtZScpLFxuICAgICAgYmFzZSA9IGN1cnJlbnQuX2Jhc2UsXG4gICAgICBsaXN0ZW5zID0gY3VycmVudC5fbGlzdGVucyxcbiAgICAgIG5hbWUgPSBjdXJyZW50Ll9wcm9wLm5hbWUsXG4gICAgICB2YWwgPSBmbGFnWzJdLCAgLy9mbGFncy5wYXJlbnQudmFsXG4gICAgICBwYXJlbnRTdG9yZSA9IGN1cnJlbnQuX3BhcmVudFN0b3JlLFxuICAgICAgcmVtb3ZlbGlzdGVuZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50W3ZhbF0pIHtcbiAgICAgICAgICBpZiAobGlzdGVucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5jaGVja0FycmF5KGxpc3RlbnMsIHBhcmVudFt2YWxdKSkge1xuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVNT1ZFIExJU1RFTkVSIScsIHBhcmVudFt2YWxdLCBsaXN0ZW5zLmxlbmd0aCwgcGFyZW50W3ZhbF0uX2xpc3RlbmVycy5sZW5ndGgsIHBhcmVudFt2YWxdLl9saXN0ZW5lcnMgLCBjdXJyZW50KVxuXG5cbiAgICAgICAgICAgICAgLy9tb3JlIHNwZWNpZmljIG9ubHkgcmVtb3ZlIGlmIHZhbCBtYXRjaGVzIC0tLSBzdG9yZSBmdW5jdGlvblxuICAgICAgICAgICAgICBwYXJlbnRbdmFsXS5yZW1vdmVMaXN0ZW5lciggZmFsc2UsIGN1cnJlbnQgKVxuXG4gICAgICAgICAgICAgIC8vbWFyayA9IGZhbHNlXG5cblxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVNT1ZFIExJU1RFTkVSISAtLSByZXN1bHQgLS0gbm8gdXBkYXRlPycsIGxpc3RlbnMubGVuZ3RoKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICB0aGlzLl92YWwgPSAwXG5cbiAgICBpZiAobGlzdGVucyAmJiAhcmVtb3ZlbGlzdGVuZXIuY2FsbChiYXNlKSkge1xuICAgICAgYmFzZS5lYWNoSW5zdGFuY2UocmVtb3ZlbGlzdGVuZXIsIG5hbWUpXG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ1BBUkVOVFNUT1JFJywgcGFyZW50U3RvcmUsIGN1cnJlbnQpXG4gICAgcGFyZW50U3RvcmUuc3BsaWNlKHV0aWwuY2hlY2tBcnJheShwYXJlbnRTdG9yZSwgdGhpcywgdHJ1ZSksIDEpXG5cbiAgICBpZiAocGFyZW50U3RvcmUubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBjb25zb2xlLmxvZygnLS0tPiBSRU1PVkUgU0VUVElORycueWVsbG93LmludmVyc2UsIHBhcmVudFN0b3JlKVxuICAgICAgYmFzZS5yZW1vdmVTZXR0aW5nKG5hbWUsICdwYXJlbnQnKSAvL2ZmIGNvcmlnZXJlbiB2b29yIGFuZGVyZSBwYXJlbnQgc2V0dGluZ3MhISEgb3AgYW5kZXJlIGZpZWxkc1xuICAgICAgLy9kaXQgbWFha3QgaGV0IGhlbGVtYWFsIGthcG90IVxuICAgICAgLy8gY29uc29sZS53YXJuKCdSRU1PVkUgUEFSRU5UU1RPUkUhJylcbiAgICAgIGN1cnJlbnQuX3BhcmVudFN0b3JlID0gbnVsbFxuICAgIH1cbiAgfVxufSIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxuLy9UT0RPOiBmbGFncyBvbiB0aGUgYmFzaXMgb2YgcGF0aCAoIHNpbWlsYWlyIHRvIGNhc2VzIClcblxuLy9UT0RPOiBtYWtlIFZhbHVlIGZsYWdzIG1vcmUgaW5qZWN0YWJsZVxudmFyIGZsYWdzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCAnLi8nIClcbiAgLCBwcm9jZXNzZXMgPSByZXF1aXJlKCAnLi4vLi4vdXRpbC9wcm9jZXNzJyApXG4gICwgVmFsdWUgPSByZXF1aXJlKCAnLi4vJyApXG4gICwgdXRpbCA9IHJlcXVpcmUoICcuLi8uLi91dGlsJyApXG4gICwgYWpheCA9IHJlcXVpcmUoJy4uLy4uL2Jyb3dzZXIvbmV0d29yay9hamF4JylcbiAgLCB2T2JqZWN0ID0gcmVxdWlyZSgnLi4vLi4vb2JqZWN0JylcblxuLy9UT0RPOiBtYXliZSBhZGQgcHJvbWlzZVxuXG5leHBvcnRzLmNyZWF0ZSA9IGZ1bmN0aW9uKCBmbGFnLCBzZXR0aW5ncywgQ29uc3RydWN0b3IsIGV4dGVuZGZsYWdzICkge1xuXG4gIGlmKCAhZXh0ZW5kZmxhZ3MgKSBleHRlbmRmbGFncyA9IGZsYWdzXG4gIGlmKCAhQ29uc3RydWN0b3IgKSBDb25zdHJ1Y3RvciA9IFZhbHVlXG5cbiAgdmFyIHRlbXBTdG9yZSA9ICdfX3RlbXAnK2ZsYWcrJ19fJ1xuICAgICwgaW5Qcm9ncmVzcyA9ICAnX19pbnByb2dyZXNzJytmbGFnKydfXydcbiAgICAsIG9yaWdVcGRhdGUgPSBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX3VwZGF0ZVxuICAgICwgb25jZSA9IHNldHRpbmdzICYmIHNldHRpbmdzLm9uY2VcbiAgICAsIGRlZmVyTWV0aG9kID0gc2V0dGluZ3MgJiYgc2V0dGluZ3MuZGVmZXJNZXRob2RcbiAgICAsIG9yaWdTZXRcbiAgICAsIG9yaWdSZW1vdmVcbiAgICAsIGRlZmVyZmxhZyA9IFxuICAgICAgeyByZXNldDogdHJ1ZVxuICAgICAgLCBzZXQ6IGZ1bmN0aW9uKCB2YWwsIHN0YW1wLCByZXNldCApIHtcbiAgICAgICAgICBpZiggIXRoaXMuX2ZsYWcgKSB0aGlzLl9mbGFnID0ge31cbiAgICAgICAgICB0aGlzLl9mbGFnW2ZsYWddID0gWyBmbGFnLCBmYWxzZSwgdmFsLCB0aGlzIF1cbiAgICAgICAgfVxuICAgICAgLCByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBkZWZlciA9IHRoaXMuX2ZsYWcgJiYgdGhpcy5fZmxhZ1tmbGFnXVxuICAgICAgICAgICAgLCB2b2JqXG5cbiAgICAgICAgICBpZiggZGVmZXIgJiYgZGVmZXJbMV0gKVxuICAgICAgICAgIHtcblxuICAgICAgICAgICAgLy8gaWYoIGRlZmVyTWV0aG9kICkgXG4gICAgICAgICAgICAvLyB7XG4gICAgICAgICAgICAgIC8vIHZvYmogPSBkZWZlck1ldGhvZC5jYWxsKCBfdGhpcywgYXJyLCBkZWZlclsyXSwgX3RoaXNbdGVtcFN0b3JlXSwgb3JpZ1VwZGF0ZSwgQ29uc3RydWN0b3IgKVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgLy8gaWYoKSB7XG4gICAgICAgICAgICAgIHZvYmogPSB0eXBlb2YgZGVmZXJbMl0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICAgICAgPyBwcm9jZXNzZXNbZGVmZXJbMl1dXG4gICAgICAgICAgICAgICAgICAgOiB0eXBlb2YgZGVmZXJbMl0gIT09ICdmdW5jdGlvbicgJiYgZGVmZXJbMl1cbiAgICAgICAgICAgIC8vIH1cblxuICAgICAgICAgICAgaWYoIHZvYmogJiYgdm9iai5yZW1vdmVMaXN0ZW5lciApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZvYmoucmVtb3ZlTGlzdGVuZXIoIGRlZmVyWzFdIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYoIHZvYmogJiYgdm9iaiAhPT0gdHJ1ZSApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvciggdmFyIHZvYmokIGluIHZvYmogKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdm9iai5yZW1vdmVMaXN0ZW5lciggdm9ialt2b2JqJF0gKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cblxuICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoXG4gICggdGVtcFN0b3JlXG4gICwgaW5Qcm9ncmVzc1xuICAsICdfaGlzdG9yeSdcbiAgLy8gLCAnX2luaXRpYWxpc2VkJ1xuICApXG5cbiAgaWYoIGRlZmVyTWV0aG9kICkge1xuICAgIHNldHRpbmdzLmRlZmVyTWV0aG9kID0gbnVsbFxuICB9XG5cbiAgIGlmKCBvbmNlICkge1xuICAgIHNldHRpbmdzLm9uY2UgPSBudWxsXG4gICAgQ29uc3RydWN0b3IucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCggb25jZSApXG4gIH1cblxuICBpZiggc2V0dGluZ3MgKSB7XG4gICAgZm9yKCB2YXIga2V5IGluIHNldHRpbmdzIClcbiAgICB7XG4gICAgICBpZigga2V5ID09PSAnc2V0JyApXG4gICAgICB7XG4gICAgICAgIG9yaWdTZXQgPSBkZWZlcmZsYWcuc2V0XG4gICAgICAgIGRlZmVyZmxhZy5zZXQgPSBmdW5jdGlvbiggdmFsLCBzdGFtcCwgcmVzZXQgKSB7XG4gICAgICAgICAgc2V0dGluZ3Muc2V0LmNhbGwoIHRoaXMsIG9yaWdTZXQsIGFyZ3VtZW50cyApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYoIGtleSA9PT0gJ3JlbW92ZScgKVxuICAgICAge1xuICAgICAgICBvcmlnUmVtb3ZlID0gZGVmZXJmbGFnLnJlbW92ZVxuICAgICAgICBkZWZlcmZsYWcucmVtb3ZlID0gZnVuY3Rpb24oIHZhbCwgc3RhbXAsIHJlc2V0ICkge1xuICAgICAgICAgIHNldHRpbmdzLnJlbW92ZS5jYWxsKCB0aGlzLCBvcmlnUmVtb3ZlLCBhcmd1bWVudHMgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIFxuICAgICAge1xuICAgICAgICBkZWZlcmZsYWdba2V5XSA9IHNldHRpbmdzW2tleV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBleHRlbmRmbGFnc1tmbGFnXSA9IGRlZmVyZmxhZ1xuXG4gIC8vZXh0ZW5kIHVwZGF0ZVxuICB1dGlsLmRlZmluZVxuICAoIENvbnN0cnVjdG9yXG4gICwgJ191cGRhdGUnXG4gICwgZnVuY3Rpb24oIHZhbCwgc3RhbXAgKSB7XG5cblxuXG4gICAgICBpZiggKCB0aGlzLl9mbGFnICYmIHRoaXMuX2ZsYWdbZmxhZ10gKSAmJiAoICFvbmNlIHx8ICF0aGlzW29uY2VdICkgKSAvLyYmICF0aGlzLl9pbml0aWFsaXNlZCBcbiAgICAgIHtcblxuICAgICAgICAvLyB0aGlzLmNsZWFyQ2FjaGUoKVxuXG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ191cGRhY2UnLCB2YWwsIHRoaXMuX3BhdGgpXG5cbiAgICAgICAgLy8gY29uc29sZS5lcnJvciggJyRFRUVFRTEnLCB0aGlzLl9wYXRoKVxuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMuX3BhdGgsIHZhbCwgc3RhbXApXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgICAsIGRlZmVyID0gX3RoaXMuX2ZsYWcgJiYgX3RoaXMuX2ZsYWdbZmxhZ11cbiAgICAgICAgICAsIHRlbXBkZWZlciA9IF90aGlzW3RlbXBTdG9yZV1cbiAgICAgICAgICAsIGFkZFxuICAgICAgICAgICwgYXJyXG4gICAgICAgICAgLCB2b2JqXG4gICAgICAgICAgLCByZWN1clxuICAgICAgICAgICwgZm5cblxuICAgICAgICBpZiggIXRlbXBkZWZlciApXG4gICAgICAgIHtcbiAgICAgICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gdGVtcGRlZmVyID0gW11cbiAgICAgICAgICBhZGQgPSB0cnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy9UT0RPOiBmaXggY2FjaGluZyBzdGFtcCwgbW9zdCBlZmZpY2llbnQgYnV0IG1heSBicmVhayB0aGluZ3MgL3cgaW5zdGFuY2VzIGV0Y1xuICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzdGFtcCBjYWhjaW5nJywgdGhpcy5fcGF0aClcblxuICAgICAgICAgIGlmKCBzdGFtcCAmJiB0ZW1wZGVmZXJbMF1bMV0gIT09IHN0YW1wIClcbiAgICAgICAgICB7XG5cbiAgICAgICAgICAgIC8vIHRlbXBkZWZlci5wdXNoKHV0aWwuYXJnKCBhcmd1bWVudHMgKSlcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdzdGFtcCBjYWhjaW5nIHBhc3MnICwgdGhpcy5fcGF0aCwgdGVtcGRlZmVyKVxuICAgICAgICAgICAgLy8gdGVtcGRlZmVyWzBdWzBdID0gdmFsXG4gICAgICAgICAgICAvLyB0ZW1wZGVmZXJbMF1bMV0gPSBzdGFtcFxuICAgICAgICAgICAgdmFyIGFyZyA9IHV0aWwuYXJnKGFyZ3VtZW50cylcbiAgICAgICAgICAgIGZvcih2YXIgaSBpbiBhcmcpIHtcbiAgICAgICAgICAgICAgdGVtcGRlZmVyWzBdW2ldID0gYXJnW2ldXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG5cbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignX3VwZGFjZSAzJywgdmFsLCB0aGlzLl9wYXRoKVxuXG4gICAgICAgICAvLyBpZih0aGlzLl9uYW1lID09PSAnJHRlc3QnKSBjb25zb2xlLmxvZygnc3RvcCBpdHMnKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgYXJyID0gdXRpbC5hcmcoIGFyZ3VtZW50cyApXG5cbiAgICAgICAgLy8gY29uc29sZS5lcnJvcignX3VwZGFjZSAyJywgdmFsLCB0aGlzLl9wYXRoKVxuXG4gICAgICAgIHRlbXBkZWZlci5wdXNoKCBhcnIgKVxuXG4gICAgICAgIGlmKCBhZGQgKVxuICAgICAgICB7XG4gICAgICAgICAgLy8gaWYodGhpcy5fbmFtZSA9PT0gJyR0ZXN0JykgY29uc29sZS5lcnJvcignZG8gaXQgMScpXG5cbiAgICAgICAgICBpZiggZGVmZXJNZXRob2QgKSBcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2b2JqID0gZGVmZXJNZXRob2QuY2FsbCggX3RoaXMsIGFyciwgZGVmZXJbMl0sIHRlbXBTdG9yZSwgb3JpZ1VwZGF0ZSwgQ29uc3RydWN0b3IsIGluUHJvZ3Jlc3MgKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZvYmogPSB0eXBlb2YgZGVmZXJbMl0gPT09ICdzdHJpbmcnXG4gICAgICAgICAgICAgICA/IHByb2Nlc3Nlc1tkZWZlclsyXV1cbiAgICAgICAgICAgICAgIDogZGVmZXJbMl1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiggdm9iaiApXG4gICAgICAgICAge1xuXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdoZXlobzIhISEhIScsIHZhbCx0aGlzLl9wYXRoKVxuXG4gICAgICAgICAgXG4gICAgICAgICAgICAvL1RPRE86IHJlcGxhY2Ugd2l0aCBhIHN0YW5kYXJkIGZ1bmN0aW9uLCBsb3NlIHRoZSBleHRyYSBjbG9zdXJlIVxuICAgICAgICAgICAgcmVjdXIgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICBpZiggb25jZSApIFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgX3RoaXNbb25jZV0gPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9kaXQgb29rIGt1bm5lbiBtZWVnZXZlblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0xFVFMgVFJZJylcblxuICAgICAgICAgICAgICAvL1RPRE86IHVzaW5nIGEgY2xvc3VyZSBoZXJlIG1heSBub3QgYmUgbmVzc2VjYXJ5IGFueW1vcmUsIHVzZSBhbm90aGVyIGlkZW50aWZpZXJcbiAgICAgICAgICAgICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0ZW1wZGVmZXIubGVuZ3RoOyBpKysgKSB7IC8vbGVuZ3RoIG5lZWRzIHRvIHVwZGF0ZVxuICAgICAgICAgICAgICAgIC8vIF90aGlzLl9jYWxsZXIgPSB0ZW1wZGVmZXJbaV0uc3BsaWNlKCB0ZW1wZGVmZXJbaV0ubGVuZ3RoLTEsIDEgKVxuICAgICAgICAgICAgICAgIC8vIHRlbXBkZWZlcltpXVsxXSA9IHRoaXMuc3RhbXAoKVxuICAgICAgICAgICAgICAgIC8vIHRyeXtcbiAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ0xFVFMgVFJZIGdvIGdvIGdvJyx2YWwsIGksIHRlbXBkZWZlcltpXSlcbiAgICAgICAgICAgICAgICAgIC8vIHZhciBzdGFtcHggPSB0ZW1wZGVmZXJbaV1bMV1cbiAgICAgICAgICAgICAgICAgICAgLy8gLCB2YWx4ID0gdGVtcGRlZmVyW2ldWzBdXG5cbiAgICAgICAgICAgICAgICAgIG9yaWdVcGRhdGUuYXBwbHkoIF90aGlzLCB0ZW1wZGVmZXJbaV0gKSAgXG5cbiAgICAgICAgICAgICAgICAgIC8vIGlmKCAodGVtcGRlZmVyW2ldWzFdICYmIHRlbXBkZWZlcltpXVsxXSE9PXN0YW1weCkgfHwgKHRlbXBkZWZlcltpXVswXSAmJiB0ZW1wZGVmZXJbaV1bMF0hPT12YWx4KSApIHtcbiAgICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS53YXJuKCdkZWZlciBuZXcgdXBkYXRlIHdpdGhpbiB0aGUgbG9vcCBub3cgaXQgZmlyZXMhIC0tIGJlIGNhcmVmdWxsIG1heSBicmVhaycpXG4gICAgICAgICAgICAgICAgICAvLyAgIHZhciByZWYgPSB0ZW1wZGVmZXJbaV1cbiAgICAgICAgICAgICAgICAgIC8vICAgLy8gc2V0VGltZW91dCggZnVuY3Rpb24oKSB7IFxuICAgICAgICAgICAgICAgICAgLy8gICAgIF90aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgICAgICAgICAgLy8gICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4gICAgICAgICAgICAgICAgICAvLyAgICAgX3RoaXNbaW5Qcm9ncmVzc10gPSBudWxsXG4gICAgICAgICAgICAgICAgICAvLyAgICAgX3RoaXMuY2xlYXJSZWZlcmVuY2VzQ2FjaGUoKVxuICAgICAgICAgICAgICAgICAgLy8gICAgIC8vIGNvbnNvbGUubG9nKCc/Pz8/PycscmVmKVxuICAgICAgICAgICAgICAgICAgLy8gICAgIF90aGlzLl91cGRhdGUuYXBwbHkoIF90aGlzLCByZWYgKSBcbiAgICAgICAgICAgICAgICAgIC8vICAgLy8gfSAsMTAwKSBcbiAgICAgICAgICAgICAgICAgIC8vICAgLy8gYWxlcnQoJ25ldyB1cGRhdGUgc2V0IHdpdGhpbiBsb29wIScpXG5cbiAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAvLyB9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcignV0EnLCBlKX1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vbGlzdGVuZXIgZ2V0cyByZW1vdmVkIGJ1dCBvcmRlciBpcyBkaWZmZXJlbnRcbiAgICAgICAgICAgICAgaWYoIHRoaXMucmVtb3ZlTGlzdGVuZXIgKSB0aGlzLnJlbW92ZUxpc3RlbmVyKCByZWN1ciApXG5cbiAgICAgICAgICAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYoIHR5cGVvZiB2b2JqID09PSAnZnVuY3Rpb24nIClcbiAgICAgICAgICAgIHtcblxuICAgICAgICAgICAgICBpZiggIV90aGlzW2luUHJvZ3Jlc3NdIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm4gPSBmdW5jdGlvbiggdmFsICkge1xuICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBpZiggdmFsIT09dHJ1ZSAmJiBfdGhpc1tpblByb2dyZXNzXSApIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXNbaW5Qcm9ncmVzc10oKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgX3RoaXNbaW5Qcm9ncmVzc10gPSBudWxsXG4gICAgICAgICAgICAgICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF90aGlzW2luUHJvZ3Jlc3NdID0gcmVjdXJcblxuICAgICAgICAgICAgICAgIGlmKCB2b2JqLmNhbGwoIHRoaXMsIGZuICwgYXJyLCB0ZW1wZGVmZXIgKSA9PT0gdHJ1ZSApXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcbiAgICAgICAgICAgICAgICAgIF90aGlzW2luUHJvZ3Jlc3NdID0gbnVsbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBlbHNlXG4gICAgICAgICAgICAgICAgLy8ge1xuICAgICAgICAgICAgICAgIC8vICAgY29uc29sZS5sb2coICc/JyApXG4gICAgICAgICAgICAgICAgLy8gICAvL1RPRE86IGNoZWNrIGlmIHRoaXMgaXMgdGhlIGJlc3Qgd2F5LCAodXBkYXRpbmcgcmVjdXIsIG9yIG1heWViIGp1c3QgdXNlIHRoZSBzYW1lIHJlY3VyKVxuICAgICAgICAgICAgICAgIC8vICAgX3RoaXMuX2RlZmVyaW5wcm9ncmVzcyA9IHJlY3VyXG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiggdm9iaiA9PT0gdHJ1ZSApXG4gICAgICAgICAgICB7XG5cbiAgICAgICAgICAgICAgaWYoIHRoaXMudmFsIHx8IHRoaXMudmFsID09PSAwIClcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG9yaWdVcGRhdGUuYXBwbHkoIF90aGlzLCBhcnIgKVxuICAgICAgICAgICAgICAgIF90aGlzW3RlbXBTdG9yZV0gPSBudWxsXG4gICAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCAnbm8gdmFsdWUhIGZyb20gZGVmZXIgdHlwZTonLCBmbGFnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKCAhdm9iai5hZGRMaXN0ZW5lciApXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGZvciggdmFyIHZvYmokIGluIHZvYmogKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdm9ialt2b2JqJF0uYWRkTGlzdGVuZXIoIHJlY3VyIClcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAge1xuXG4gICAgICAgICAgICAgIHZvYmouYWRkTGlzdGVuZXIoIHJlY3VyIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmZXJbMV0gPSByZWN1clxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG4gICAgICBlbHNlXG4gICAgICB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCBmbGFnLCBvbmNlLCAnc2hvdWxkIGRvIG9yaWcgdXBkYXRlIGJpdGNoZXMhJywgYXJndW1lbnRzLCB0aGlzIClcbiAgICAgICAgb3JpZ1VwZGF0ZS5hcHBseSggdGhpcywgYXJndW1lbnRzIClcbiAgICAgIH1cblxuICAgIH1cbiAgKVxuXG59IFxuXG4vL1RPRE86IGluamVjdGFibGVcbi8vVE9ETzpfdGVtcGRlZmVyIGhvZWZ0IG5pZXQgYWx0aWpkIG1hYWsgY3JlYXRlIC0tIHVwZGF0ZSB0eXBlIGZsYWdcbi8vYWx3YXlzIHVwZGF0ZSBtZXRob2Rcbi8vIGV4cG9ydHMuY3JlYXRlKCAnZm9yY2UnLCBcbi8vIHsgZGVmZXJNZXRob2Q6IGZ1bmN0aW9uKCBhcmdzLCB2b2JqLCB0ZW1wU3RvcmUsIHVwZGF0ZSApIHtcbi8vICAgICB2YXIgX3RoaXMgPSB0aGlzXG4vLyAgICAgLy9kaXQgeml0IG5hdHV1cmxpamsgZGllcGVyIVxuLy8gICAgIF90aGlzLl9za2lwID0gdHJ1ZSAvL21heWJlIGNoZWNrIGlmIGl0IHJseSBnZXRzIHJlc2V0P1xuLy8gICAgIF90aGlzLl9pZ25vcmVWYWx1ZSA9IHRydWVcbi8vICAgICBfdGhpcy5jbGVhckNhY2hlKClcbi8vICAgICBfdGhpc1sgdGVtcFN0b3JlIF0gPSBudWxsXG4vLyAgICAgdXBkYXRlLmFwcGx5KCBfdGhpcywgYXJncyApXG4vLyAgIH0gIFxuLy8gfSlcbi8vZGV6ZSBtb2V0IG5vZyB3YXQgZGllcGVyXG5cbi8vIGV4cG9ydHMuY3JlYXRlKCAnaGlzdG9yeScsIFxuLy8geyBkZWZlck1ldGhvZDogZnVuY3Rpb24oIGFyZ3MsIHZvYmosIHRlbXBTdG9yZSwgdXBkYXRlLCBDb25zdHJ1Y3RvciApIHtcbi8vICAgICAvL3ZvYmogb3B0aW9uIHZvb3IgZmxhZ1xuLy8gICAgIGlmKCF0aGlzLl9oaXN0b3J5KSB0aGlzLl9oaXN0b3J5ID0gW11cblxuLy8gICAgIHRoaXMuX2hpc3RvcnkudW5zaGlmdCggYXJncyApXG4vLyAgICAgdGhpc1t0ZW1wU3RvcmVdID0gbnVsbCAvL3RvdGFsIGNvbnRyb2whIChvbGQgaW5jbHVkaW5nIGFyZ3VtZW50cylcblxuLy8gICAgIC8vYWxscmlnaHQgdGhhdCB3b3JrcyB0aGlzLmNsZWFyQ2FjaGUoKSAvL2NhY2hlIGRpbmdlbiBhZGRlblxuLy8gICAgIHVwZGF0ZS5hcHBseSggdGhpcywgYXJncyApXG4vLyAgIH1cbi8vIH0pXG5cbi8vIGV4cG9ydHMuY3JlYXRlKCAnJHR5cGUnLCBcbi8vIHsgZGVmZXJNZXRob2Q6IGZ1bmN0aW9uKCBhcmdzLCB2b2JqLCB0ZW1wU3RvcmUsIHVwZGF0ZSApIHtcbi8vICAgICB2YXIgX3RoaXMgPSB0aGlzXG4vLyAgICAgICAsIGhhdmVUb1VwZGF0ZVxuXG4vLyAgICAgLy9hcnJheXMgZXRjXG4vLyAgICAgX3RoaXMuY2xlYXJDYWNoZSgpXG5cbi8vICAgICBpZiggdm9iaiA9PT0gdHJ1ZSApXG4vLyAgICAge1xuLy8gICAgICAgaWYoIF90aGlzLnZhbCApIGhhdmVUb1VwZGF0ZSA9IHRydWVcbi8vICAgICB9XG4vLyAgICAgZWxzZSBpZiggdm9iaiA9PT0gJ3N0cmluZycgKVxuLy8gICAgIHtcbi8vICAgICAgIGlmKCB0eXBlb2YgX3RoaXMudmFsID09PSAnc3RyaW5nJyApIGhhdmVUb1VwZGF0ZSA9IHRydWVcbi8vICAgICB9XG4vLyAgICAgZWxzZSBpZiggdm9iaiA9PT0gJ251bWJlcicgKVxuLy8gICAgIHtcbi8vICAgICAgIGlmKCB0eXBlb2YgX3RoaXMudmFsID09PSAnbnVtYmVyJyApIGhhdmVUb1VwZGF0ZSA9IHRydWVcbi8vICAgICB9XG4vLyAgICAgZWxzZSBpZiggdHlwZW9mIHZvYmogPT09ICdmdW5jdGlvbicgKVxuLy8gICAgIHtcbi8vICAgICAgIGlmKCB2b2JqLmFwcGx5KCBfdGhpcywgYXJncyApICkgaGF2ZVRvVXBkYXRlID0gdHJ1ZVxuLy8gICAgIH1cblxuLy8gICAgIGlmKCBoYXZlVG9VcGRhdGUgKSB7XG4vLyAgICAgICBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuLy8gICAgICAgdXBkYXRlLmFwcGx5KCBfdGhpcywgYXJncyApXG4vLyAgICAgfVxuLy8gICB9ICBcbi8vIH0pXG5cbmV4cG9ydHMuY3JlYXRlKCAnJGJ1YmJsZScsIHsgXG4gIGRlZmVyTWV0aG9kOiBmdW5jdGlvbiggYXJncywgdm9iaiwgdGVtcFN0b3JlLCB1cGRhdGUgKSB7XG4gICAgdmFyIF90aGlzID0gdGhpc1xuICAgIHZhciBkb1VwZGF0ZVxuICAgIHZhciByZWZlcmVuY2VzXG4gICAgX3RoaXNbdGVtcFN0b3JlXSA9IG51bGxcblxuICAgIGlmKCB2b2JqICkge1xuICAgICAgaWYocmVmZXJlbmNlcyA9IHZvYmoucmVmZXJlbmNlcykge1xuICAgICAgICBpZihyZWZlcmVuY2VzIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgaWYocmVmZXJlbmNlcy4kbHRlIFxuICAgICAgICAgICAgJiYgX3RoaXMucmVmZXJlbmNlTGV2ZWwoX3RoaXMuX3VwZGF0ZU9yaWdpbikgPD0gcmVmZXJlbmNlcy4kbHRlIFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYocmVmZXJlbmNlcyA+IC0xKSB7XG4gICAgICAgICAgLy9hbHNvIG1heGltdW0gZm9yIGV4YW1wbGVcbiAgICAgICAgICAvLyBjb25zb2xlLmVycm9yKF90aGlzLl9wYXRoLCBfdGhpcy5yZWZlcmVuY2VMZXZlbChfdGhpcy5fdXBkYXRlT3JpZ2luKSwgJ3VPcmlnaW5QYXRoJywgX3RoaXMuX3VwZGF0ZU9yaWdpbi5fcGF0aCwgJy5fdmFsJyxfdGhpcy5fdmFsLl9wYXRoLCAgJ2Nsb3VkJywgISFfdGhpcy5fdmFsLmNsb3VkKVxuICAgICAgICAgIGlmKCBfdGhpcy5yZWZlcmVuY2VMZXZlbChfdGhpcy5fdXBkYXRlT3JpZ2luKSA9PT0gcmVmZXJlbmNlcyApIHtcbiAgICAgICAgICAgIGRvVXBkYXRlID0gdHJ1ZVxuICAgICAgICAgIH0gXG4gICAgICAgIH0gXG4gICAgICAgIC8vIGVsc2UgaWYocmVmZXJlbmNlcyA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyAgIC8vb25seSBpZiByZWZmZXJlbmNlXG4gICAgICAgIC8vICAgaWYoX3RoaXMucmVmZXJlbmNlTGV2ZWwoX3RoaXMuX3VwZGF0ZU9yaWdpbikhPT1mYWxzZSkge1xuICAgICAgICAvLyAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgIC8vICAgfSBcbiAgICAgICAgXG4gICAgICAgIC8vIH1cblxuICAgICAgfSBlbHNlIGlmKCB2b2JqICYmIHZvYmouc2VsZiA9PT0gdHJ1ZSApe1xuXG4gICAgICAgICAgaWYoIGFyZ3NbMl0gPT09IHZvaWQgMCB8fCB0aGlzLl92YWwgPT09IGFyZ3NbMF0gfHwgIWFyZ3NbMF0gJiYgdGhpcy5fdXBkYXRlT3JpZ2luPT09dGhpcykge1xuICAgICAgICAgICAgZG9VcGRhdGUgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihkb1VwZGF0ZSkgeyAgXG4gICAgICAgICAgdXBkYXRlLmFwcGx5KF90aGlzLCBhcmdzKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzLmNsZWFyUmVmZXJlbmNlc0NhY2hlKClcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUuYXBwbHkoX3RoaXMsIGFyZ3MpXG4gICAgICB9XG5cbiAgIFxuICB9ICBcbn0pXG5cbmV4cG9ydHMuY3JlYXRlKCAnZGVmZXInIClcblxuLy9UT0RPOiB2T2JqIGZsYWcgKCBhY2Nlc3NhYmxlIHRyb3VnaCBvYmplY3RbZmxhZ10gKVxuXG5WYWx1ZS5vcGVyYXRvcnMucmVzcG9uc2VEYXRhID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiBvcGVyYXRvcj09PWZhbHNlID8gdmFsIDogb3BlcmF0b3Jcbn1cblxuLy92b2JqIHBhcnNlciFcblxuZXhwb3J0cy5jcmVhdGUoICdhamF4JywgXG57IHJlbW92ZTogZnVuY3Rpb24oIHJlbW92ZSwgYXJncyApIHtcbiAgICAvL1RPRE86IGFqYXggY2FsbCBzdG9wXG4gICAgcmVtb3ZlLmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgfVxuLCBzZXQ6ZnVuY3Rpb24oIHNldCwgYXJncykge1xuLy8gICAgIGNvbnNvbGUubG9nKCdzZXQgYWpheCBkZWZlcicpXG4gICAgaWYoICEgdGhpcy5sb2FkaW5nICkge1xuICAgICAgLy9uYW1lLCB2YWwsIHZvYmosIHN0YW1wLCBub3VwZGF0ZSwgZnJvbVxuICAgICAgdGhpcy5zZXQoICdsb2FkaW5nJywgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSApXG4gICAgfVxuICAgIHNldC5hcHBseSggdGhpcywgYXJncyApXG4gIH1cbiwgZGVmZXJNZXRob2Q6IGZ1bmN0aW9uKCBhcmdzLCB2b2JqLCB0ZW1wU3RvcmUsIHVwZGF0ZSwgQ29uc3RydWN0b3IgKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyAgXG5cbiAgICByZXR1cm4gdm9iaiAmJiBmdW5jdGlvbiggdXBkYXRlLCBhcmdzICkge1xuXG4gICAgICB2YXIgb3JpZ3UgPSB1cGRhdGVcblxuICAgICAgdXBkYXRlID0gZnVuY3Rpb24oIHR5cGUsIGtpbGwgKSB7XG4gICAgICAgIF90aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgICBfdGhpcy5fc2tpcCA9IHRydWVcbiAgICAgICAgX3RoaXMuX2lnbm9yZVZhbHVlID0gdHJ1ZVxuICAgICAgICBpZiggdHlwZSApIHtcbiAgICAgICAgICBhcmdzWzBdID0gdHlwZVxuICAgICAgICAgIGlmKCEgKCBfdGhpcy5fdmFsIGluc3RhbmNlb2Ygdk9iamVjdCApICkge1xuICAgICAgICAgICAgX3RoaXMudmFsID0gdHlwZVxuICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgICAgaWYoIF90aGlzLmxvYWRpbmcgKSBfdGhpcy5sb2FkaW5nLnZhbCA9IGZhbHNlXG4gICAgICAgIG9yaWd1KCBraWxsIClcbiAgICAgICAgX3RoaXMuX2lnbm9yZVZhbHVlID0gbnVsbFxuICAgICAgfVxuXG4gICAgICBpZiggdHlwZW9mIHZvYmogPT09ICdvYmplY3QnIClcbiAgICAgIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IHZvYmpcbiAgICAgICAgdm9iaiA9IHt9XG4gICAgICAgIGZvciggdmFyIGtleSBpbiBwYXJhbXMgKSB7XG4gICAgICAgICAgaWYoIGtleSA9PT0gJ2RlZmVyJyApIHtcbiAgICAgICAgICAgIHZvYmpba2V5XSA9IHBhcmFtc1trZXldXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmKCF2b2JqW2tleV0pIHtcbiAgICAgICAgICAgICAgaWYoIGtleSAhPT0gJ2NvbXBsZXRlJyAmJiBrZXkgIT09ICdlcnJvcicgJiYgdHlwZW9mIHBhcmFtc1trZXldID09PSAnZnVuY3Rpb24nICkge1xuICAgICAgICAgICAgICAgIHZvYmpbIGtleSBdID0gcGFyYW1zWyBrZXkgXS5jYWxsKCBfdGhpcywgdm9iaiwgYXJnc1swXSwgYXJncyApXG4gICAgICAgICAgICAgICAgaWYoICF2b2JqW2tleV0gKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2b2JqW2tleV0gPSBwYXJhbXNba2V5XVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYoIHZvYmpba2V5XSBpbnN0YW5jZW9mIHZPYmplY3QgKSB7XG4gICAgICAgICAgICAgICAgdm9ialtrZXldID0gdm9ialtrZXldLnZhbCAvL2N1c3RvbSBnZXQgb3IgcmF3XG4gICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlb2Ygdm9iaiA9PT0gJ2Z1bmN0aW9uJyApIFxuICAgICAge1xuICAgICAgICB2b2JqID0gdm9iai5jYWxsKCBfdGhpcywgdm9iaiwgYXJnc1swXSwgYXJncyApXG4gICAgICAgIGlmKCF2b2JqKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiggdHlwZW9mIHZvYmogPT09ICdzdHJpbmcnICkgXG4gICAgICB7XG4gICAgICAgIHZvYmogPSB7IHVybDogdm9iaiB9XG4gICAgICB9XG5cbiAgICAgIGlmKCB2b2JqLnVybCBpbnN0YW5jZW9mIHZPYmplY3QgKSB7XG4gICAgICAgIHZvYmoudXJsID0gdm9iai51cmwudmFsXG4gICAgICB9XG5cbiAgICAgIGlmKCAhdm9iaiB8fCAhKCB2b2JqLnVybCB8fCB2b2JqLmFwaSApICkgXG4gICAgICB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIHZhciBjb21wbGV0ZSA9IHZvYmouY29tcGxldGVcbiAgICAgICAgLCBlcnJvciA9IHZvYmouZXJyb3JcblxuICAgICAgdm9iai5jb21wbGV0ZSA9IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICBpZiggdm9iai5kZWZlciApIFxuICAgICAgICB7XG4gICAgICAgICAgdm9iai5kZWZlci5jYWxsKCBfdGhpcywgdXBkYXRlLCBhcmdzLCBudWxsLCBkYXRhLCB2b2JqIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICBpZighX3RoaXMucmVzcG9uc2VEYXRhKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXQoICdyZXNwb25zZURhdGEnLCBkYXRhIClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5yZXNwb25zZURhdGEubWVyZ2UoIGRhdGEgKVxuICAgICAgICAgIH1cbiAgICAgICAgICA7Y29tcGxldGUgJiYgY29tcGxldGUoIGRhdGEgKVxuICAgICAgICAgIHVwZGF0ZSggJ3N1Y2Nlc3MnIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2b2JqLmVycm9yID0gZnVuY3Rpb24oIGVyciApIHtcbiAgICAgICAgaWYoIHZvYmouZGVmZXIgKSBcbiAgICAgICAge1xuICAgICAgICAgIHZvYmouZGVmZXIuY2FsbCggX3RoaXMsIHVwZGF0ZSwgYXJncywgZXJyLCB2b2JqIClcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgIHtcbiAgICAgICAgICBpZiggX3RoaXMucmVzcG9uc2VEYXRhIClcbiAgICAgICAgICB7IFxuICAgICAgICAgICAgX3RoaXMucmVzcG9uc2VEYXRhLmVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG4gICAgICAgICAgICAgIGlmKCAhQ29uc3RydWN0b3Iub3BlcmF0b3JzW2tleV0gJiYgIUNvbnN0cnVjdG9yLmZsYWdzW2tleV0gKVxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUoKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpcy5zZXQoICdyZXNwb25zZURhdGEnICwgdm9pZCAwIClcbiAgICAgICAgICBpZiggZXJyb3IgKSBlcnJvciggZGF0YSApXG4gICAgICAgICAgdXBkYXRlKCAnZXJyb3InIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggX3RoaXMubG9hZGluZyApIHtcbiAgICAgICAgLy9UT0RPOmNvcnJlY3QgcmVzcG9uc2VzIG1hbmFnZW1ldCAtLSBwcmV0dHkgZWFzeSB0b2RvXG4gICAgICAgIF90aGlzLmxvYWRpbmcudmFsID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBhamF4KCB2b2JqICkgLy9UT0RPOiBsZXQgaXQgcmV0dXJuIGEgcHJvbWlzZVxuICAgIH0gIFxuICB9XG59KVxuXG4vL3RlbXAgYXJncyBcblxuLy9UT0RPOiBkaXQgbGF0ZXIgdmVydmFuZ2VuIG1ldCBsb2NhbCBmbGFncyAoYXBpKVxuLy9UT0RPOiB1bmlmeSBhamF4IGhpZXJtZWUgdm9vciBvbmNzaXRlbnQgZXJyb3IgaGFuZGVsaW5nIC0tIG9mIGV4dGVuc2lvbiBvcCBhamF4XG5leHBvcnRzLmNyZWF0ZSggJ2FwaURlZmVyJywgXG57IHJlbW92ZTogZnVuY3Rpb24oIHJlbW92ZSwgYXJncyApIHtcbiAgICAvL1RPRE86IGFqYXggY2FsbCBzdG9wXG4gICAgcmVtb3ZlLmFwcGx5KCB0aGlzLCBhcmdzIClcbiAgfVxuLCBzZXQ6ZnVuY3Rpb24oIHNldCwgYXJncykge1xuICAgIGlmKCEgdGhpcy5sb2FkaW5nICkge1xuICAgICAgdGhpcy5zZXQoICdsb2FkaW5nJywgZmFsc2UsIGZhbHNlLCBmYWxzZSwgdHJ1ZSApXG4gICAgfVxuICAgIHNldC5hcHBseSggdGhpcywgYXJncyApXG4gIH1cbiwgZGVmZXJNZXRob2Q6IGZ1bmN0aW9uKCBhcmdzLCB2b2JqLCB0ZW1wU3RvcmUsIHVwZGF0ZSwgQ29uc3RydWN0b3IsIGluUHJvZ3Jlc3MgKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcyAgXG4gICBcbiAgICByZXR1cm4gdm9iaiAmJiBmdW5jdGlvbiggdXBkYXRlLCBhcmdzICkge1xuXG4gICAgICBpZiggIWFyZ3NbMF0gfHwgYXJnc1swXS5hcGlEZWZlciApIHJldHVybiB0cnVlXG5cbiAgICAgIHZhciB3cmFwcGVkVXBkYXRlID0gZnVuY3Rpb24oIHZhbCwga2lsbCApIHtcblxuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCdETyBETyBETycsIHZhbCwgX3RoaXMsIHRlbXBTdG9yZSwgX3RoaXNbdGVtcFN0b3JlXSlcblxuICAgICAgICAvLyBfdGhpc1t0ZW1wU3RvcmVdID0gbnVsbFxuICAgICAgICAgICBcbiAgICAgICAgLy8gX3RoaXNbaW5Qcm9ncmVzc10gPSBudWxsXG5cblxuICAgICAgICBfdGhpcy5sb2FkaW5nLnZhbCA9IGZhbHNlXG4gICAgICAgIGlmKCB2YWwgJiYgdmFsIT09dHJ1ZSApIFxuICAgICAgICB7XG4gICAgICAgICAgX3RoaXMudmFsID0gYXJnc1swXSA9IHZhbFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1cGRhdGUoIHZhbCApIC8vdmFsIC0tIHZhbFxuICAgICAgICAgIH0gY2F0Y2goIGVyciApIHtcbiAgICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoICdERUVQRVIgRVJST1IgSU4gQVBJIERFRkVSICwgU09NRVRISU5HIFdST05HIC93IHRoaXMgQVBJJywgdmFsIClcbiAgICAgICAgICAgIC8vYmVzdCBleGFtcGxlIGlzIGZhY2Vib29rIGxvZ2luIHRydWUgYW5kIGdvbmUgYnV0IG9ubHkgd2VoIHRoZSAubG9hZGluZyBpcyB0aGVyZVxuICAgICAgICAgICAgLy9tb3N0IGJlIGEgdmVyeSBkZWVwIGlzc3VlcyBpIGdldXNzLi4uIGhhcmQgdG8gcmVjcmVhdGUgXG4gICAgICAgICAgICBfdGhpcy50eXBlID0gZXJyXG5cbiAgICAgICAgICAgIC8vdGhpcyBpcyB3cm9uZyBtaXNzZXMgX3RoaXMgY2FsbCBhbmQgb3RoZXIgYXJnc1xuICAgICAgICAgICAgdXBkYXRlKCAnZXJyb3InIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5jbGVhckNhY2hlKClcbiAgICAgICAgICBfdGhpcy5fdmFsID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgICBlbHNlIFxuICAgICAgICB7XG4gICAgICAgICAgLy90aGlzIGlzIHdyb25nIG1pc3NlcyBfdGhpcyBjYWxsIGFuZCBvdGhlciBhcmdzXG4gICAgICAgICAgdXBkYXRlKCB2YWwgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBcbiAgICAgIF90aGlzLmxvYWRpbmcudmFsID0gdHJ1ZVxuICAgICAgdmFyIGFwaSA9IF90aGlzLmNoZWNrUGFyZW50KCAnYXBpJywgdHJ1ZSApXG5cbiAgICAgIGlmKCBhcGkgJiYgYXBpLnZhbCAhPT0gdHJ1ZSApIFxuICAgICAge1xuXG4gICAgICAgIGFwaS5vbmNlKGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAgICAgaWYoIHZhbCA9PT0gJ2Vycm9yJyApIFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQ2FjaGUoKSAvL2hpZXIgZmYgZWVuIGZ1bmN0aWUgdm9vciBtYWtlbiFcbiAgICAgICAgICAgIF90aGlzLnZhbCA9IGFyZ3NbMF0gPSAnZXJyb3InXG4gICAgICAgICAgICBfdGhpcy50eXBlID0gdGhpcy50eXBlIHx8ICdhcGknXG4gICAgICAgICAgICBfdGhpcy5sb2FkaW5nLnZhbCA9IGZhbHNlXG4gICAgICAgICAgICB3cmFwcGVkVXBkYXRlKClcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiggdmFsID09PSB0cnVlIClcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2b2JqLmNhbGwoIF90aGlzLCB3cmFwcGVkVXBkYXRlLCBhcmdzIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGFwaS52YWwgPSB0cnVlXG4gICAgICB9IFxuICAgICAgZWxzZVxuICAgICAge1xuICAgICAgICB2b2JqLmNhbGwoIF90aGlzLCB3cmFwcGVkVXBkYXRlLCBhcmdzIClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pXG5cbmV4cG9ydHMuY3JlYXRlKCAnaW5pdCcsIFxueyBzZXQ6IGZ1bmN0aW9uKCBzZXQsIGFyZ3MgKSB7XG4gICAgaWYoICF0aGlzLmluaXRpYWxpc2VkIClcbiAgICB7XG4gICAgICBzZXQuYXBwbHkoIHRoaXMsIGFyZ3MgKSAvL25pZXQgbm9kaWchXG4gICAgfVxuICB9XG4sIHJlbW92ZTogZnVuY3Rpb24oIHJlbW92ZSwgYXJncyApIHtcbiAgICByZW1vdmUuYXBwbHkoIHRoaXMsIGFyZ3MgKVxuICAgIHRoaXMuaW5pdGlhbGlzZWQgPSBudWxsXG4gIH1cbiwgb25jZTogJ2luaXRpYWxpc2VkJ1xufSlcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG52YXIgZmxhZ3MgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vJyk7XG5cbi8qKlxuICogc2VsZlxuICogQGZsYWdcbiAqL1xuZmxhZ3Muc2VsZiA9IHtcbiAgcmVzZXQ6IHRydWUsXG4gIHVzZVZhbDp0cnVlLFxuICBzZXQ6IGZ1bmN0aW9uKHZhbCwgc3RhbXAsIHJlc2V0KSB7XG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLmNoZWNrUGFyZW50KCdfcHJvcC5uYW1lJylcbiAgICBpZiAoY3VycmVudC5fYmFzZSAmJiBjdXJyZW50Ll9iYXNlW3ZhbF0pIHtcbiAgICAgIGN1cnJlbnQuX2Jhc2VbdmFsXS5hZGRMaXN0ZW5lcih0aGlzKVxuICAgICAgdGhpcy5fdmFsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzW3ZhbF0gJiYgdGhpc1t2YWxdLnZhbFxuICAgICAgfVxuICAgICAgaWYoIXRoaXMuX2ZsYWcpICB0aGlzLl9mbGFnID0ge31cbiAgICAgIHRoaXMuX2ZsYWcuc2VsZiA9IFsnc2VsZicsIHRoaXMuX3ZhbCwgdmFsLCB0aGlzXVxuICAgIH1cbiAgfVxufTtcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cblxudmFyIGZsYWdzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLycpXG4vKipcbiAqIGxpc3RlblxuICogYWRkcyBsaXN0ZW5lcnMgdG8gYSBWLlZhbHVlXG4gKiBAcHJvcGVydHlcbiAqKi9cbmZsYWdzLmxpc3RlbiA9IHtcbiAgcmVzZXQ6dHJ1ZSxcbiAgc2V0OiBmdW5jdGlvbih2YWwsIHN0YW1wLCByZXNldCkge1xuICAgIGlmKCF2YWwpXG4gICAge1xuICAgICAgY29uc29sZS5lcnJvcignbm8gdmFsIGluIGZsYWdzIGxpc3RlbiEnKVxuLy8gICAgICAgZGVidWdnZXJcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZighdGhpcy5fZmxhZykgdGhpcy5fZmxhZyA9IHt9XG4gICAgLy9ldmVudHVlZWwgbWVyZ2VuIVxuICAgICAgXG4gICAgLy8gY29uc29sZS5sb2coJ2xpc3RlbicuY3lhbi5pbnZlcnNlLCByZXNldCwgdmFsKVxuICAgIC8vaWYgcmVzZXQgbWFrZSBzdXJlIGl0cyByZXNldHRlZCBjb3JyZWN0bHkhXG4gICAgdGhpcy5fZmxhZy5saXN0ZW4gPSBbJ2xpc3RlbicsIGZhbHNlLCB2YWwsIHRoaXMgXSBcbiAgICBpZiAodmFsIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIGZvciAodmFyIGkgPSB2YWwubGVuZ3RoIC0gMTsgaSA+PSAwOyB2YWxbaS0tXS5hZGRMaXN0ZW5lcih0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vb2tcbiAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgIC8vIHZhbC5hZGRMaXN0ZW5lcihmdW5jdGlvbigpIHtcbiAgICAgIC8vICAgY29uc29sZS5sb2coJ1RST1VHSCBMSVNURU4hISEhJy5tYWdlbnRhLmludmVyc2UsIHZhbC5fcGF0aClcbiAgICAgIC8vICAgLy8gX3RoaXMuX3VwZGF0ZS5hcHBseShfdGhpcywgYXJndW1lbnRzKVxuICAgICAgLy8gfSkgXG4gICAgICB2YWwuYWRkTGlzdGVuZXIodGhpcykgLy9kaXQgbW9ldCBiZXRlciAocmVtb3ZlIGxpc3RlbmVyIGlmIHBvc3NpYmxlKVxuICAgIH1cbiAgfSxcbiAgcmVtb3ZlOmZ1bmN0aW9uKCkge1xuICAgIGlmKHRoaXMuX2ZsYWcmJnRoaXMuX2ZsYWcubGlzdGVuKSB7XG4gICAgICB2YXIgdmFsID0gdGhpcy5fZmxhZy5saXN0ZW5bMl1cbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBmb3IgKHZhciBpID0gdmFsLmxlbmd0aCAtIDE7IGkgPj0gMDsgdmFsW2ktLV0ucmVtb3ZlTGlzdGVuZXIodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsLnJlbW92ZUxpc3RlbmVyKHRoaXMpIC8vZGl0IG1vZXQgYmV0ZXIgKHJlbW92ZSBsaXN0ZW5lciBpZiBwb3NzaWJsZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTQsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IEppbSBkZSBCZWVyLCBqaW1Admlnb3VyLmlvXG4gKi9cbnZhciBvYmplY3QgPSByZXF1aXJlKCAnLi4vb2JqZWN0JyApXG4gICwgdXRpbCA9IHJlcXVpcmUoICcuLi91dGlsJyApXG4gICwgdmlnb3VyID0gcmVxdWlyZSggJy4uLycgKVxuXG4vKipcbiAqIHZpZ291ci5WYWx1ZVxuICogdiB2YWx1ZXMgYXJlIG9wdGltaXplZCBmb3IgdXNlIGluIGNvbWJpbmF0aW9uIC93IGluc3RhbmNlcyBvZiB2aWdvdXJCYXNlLCBoYXZlIG9wZXJhdG9ycyBhbmQgc3VwcG9ydCBtZXRob2QgdmFsdWVzXG4gKiBAQ2xhc3NcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gdmlnb3VyLlZhbHVlID0gb2JqZWN0Lm5ldyhcbnsgbWl4ZWQ6IHRydWVcbiwgbWVyZ2U6IHRydWVcbn0pXG5cbi8vcGFyZW50IHByb2JsZW1zXG5cbnZhciBfZ2V0T3BlcmF0b3IgPSBmdW5jdGlvbiggdmFsLCBmb3JjZSwgaSwgdCwgYmluZCwgb3BlcmF0b3JzICkge1xuICB2YXIgZiA9IHRbaV0uX2dldChiaW5kLCBmb3JjZSwgdmFsKTtcbiAgaWYgKGYgIT09IHZvaWQgMCAmJiBmICE9PSBudWxsKSB7XG4gICAgdmFsID0gb3BlcmF0b3JzW2ldKHZhbCB8fCAoKHR5cGVvZiBmID09PSAnc3RyaW5nJykgPyAnJyA6IDApLCBmKTtcbiAgfVxuICByZXR1cm4gdmFsO1xufTtcblxuZXhwb3J0cy5wcm90b3R5cGUuX2JsYWNrbGlzdC5wdXNoKCdfbHN0YW1wJywgJ19jbGVhckNhY2hlJywgJ19sdmFsJywgJ19fbHZhbCcsJ19fX2x2YWwnLCAnX2Jhc2UnLCAnX2NhbGxlcicsICdfYmluZCcsICdfcHJvcCcsICdfaW5zdGFuY2VzJywgJ19za2lwJywgJ19vdmVyd3JpdGUnKVxuLy9fY2FsbGVyIHN0YW1wIGZvciBnZXQgZm9yIGx2YWxzIChsYXN0IHZhbHVlcylcbnV0aWwuZGVmaW5lKGV4cG9ydHMsXG4gICdjbGVhckNhY2hlJywgZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fX19sdmFsID0gbnVsbFxuICAgIHRoaXMuX19sdmFsID0gbnVsbFxuICAgIHRoaXMuX2x2YWwgPSBudWxsIFxuICB9LFxuICAnY2xlYXJSZWZlcmVuY2VzQ2FjaGUnLCBmdW5jdGlvbigpIHtcbiAgICBmcm9tID0gdGhpcy5fdmFsXG4gICAgd2hpbGUoZnJvbSkge1xuICAgICAgaWYoZnJvbS5jbGVhckNhY2hlKSBmcm9tLmNsZWFyQ2FjaGUoKVxuICAgICAgaWYoZnJvbSAmJiBmcm9tLl92YWwpIHtcbiAgICAgICAgZnJvbSA9IGZyb20uX3ZhbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJvbSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gICdpZ25vcmVDYWNoZScsIHsgZ2V0OmZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHQgPSB0aGlzXG4gICAgICB3aGlsZSh0KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdob2Ugeml0IGhldD8/Jyx0IClcbiAgICAgICAgaWYoIHQuX3Byb3AgJiYgdC5fcHJvcC5jYWNoZSA9PT0gZmFsc2UgKSByZXR1cm4gdHJ1ZVxuICAgICAgICB0ID0gdC5fcGFyZW50XG4gICAgICB9IFxuICAgIH0gXG4gIH0sXG4gIC8qKlxuICAgKiBVc2VkIHRvIGdldCAudmFsIHdoaWNoIGNhbGN1bGF0ZXMgYSBjb25zdHJ1Y3RlZCB2YWx1ZVxuICAgKiBfYmluZCBpcyB2ZXJ5IGltcG9ydGFudCBiaW5kcyBsaXN0ZW5lcnMgdG8gc3BlY2lmaWMgaW5zdGFuY2VzXG4gICAqIEBtZXRob2QgX2dldFxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGJpbmQgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBmb3JjZSBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgICdfZ2V0JywgZnVuY3Rpb24oYmluZCwgZm9yY2UsIGN1cnJlbnRWYWwpIHtcblxuICAgIGlmKHRoaXMuX2NsZWFyQ2FjaGUpIHtcbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgfVxuXG4gICAgLy8gY29uc29sZS5sb2coJ19nZXQnLHRoaXMuX25hbWUsIHRoaXMuX3ZhbCx0aGlzKTtcbiAgICBpZiAodGhpcy5fb3ZlcndyaXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3ZlcndyaXRlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2x2YWwgJiYgdGhpcy5fbHZhbCAhPT0gMCB8fCBmb3JjZSkge1xuICAgICAgdmFyIHZhbCA9IHRoaXMuX3ZhbCxcbiAgICAgICAgbm9sdmFsLFxuICAgICAgICBvcGVyYXRvcnMgPSB0aGlzLm9wZXJhdG9ycztcblxuICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIG9iamVjdCkge1xuICAgICAgICB2YWwgPSB2YWwuX2dldCh0aGlzLl9iaW5kIHx8IGJpbmQsIGZvcmNlLCBjdXJyZW50VmFsKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdSSUdIVCBIRVJFJywgY3VycmVudFZhbClcbiAgICAgICAgdmFyIGEgPSB0aGlzO1xuICAgICAgICBpZiAoIWJpbmQpIHtcbiAgICAgICAgICB3aGlsZSAoYS5fcGFyZW50ICYmICFhLl9jYWxsZXIpIHtcbiAgICAgICAgICAgIGEgPSBhLl9wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbCA9IHZhbC5jYWxsKGJpbmQgfHwgYS5fY2FsbGVyIHx8IGEuX2Jhc2UgfHwgdGhpcywgdGhpcywgY3VycmVudFZhbCk7IC8vaWYgY3VycmVudHZhbCBlbHNlIHNvbWV0aGluZyBlbHNlO1xuICAgICAgICBub2x2YWwgPSB0cnVlO1xuICAgICAgICAvL2ZvciBmdW5jdGlvbnMgeW91IG5lZWQgdG8gY2xlYXIgX2x2YWwgc2luY2UgeW91IG5ldmVyIGtub3cgaWYgdGhlcmUgaXMgc29tZXRoaW5nIGluIHRoZSBmdW5jdGlvbiB1cGRhdGVkXG4gICAgICB9XG4gICAgICBpZiAob3BlcmF0b3JzKSB7XG4gICAgICAgIGlmICh0aGlzLl9fdCA9PT0gMSAmJiBvcGVyYXRvcnNbdGhpcy5fbmFtZV0pIHsgXG4gICAgICAgICAgLy9vcGVyYXRvciBpcyBhbiBhcnJheVxuICAgICAgICAgIHZhbCA9IDA7IC8vc3RyaW5nXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaiA8IGw7IGorKykge1xuICAgICAgICAgICAgaWYgKHRoaXNbal0pIHtcbiAgICAgICAgICAgICAgdmogPSB0aGlzW2pdLl9nZXQoYmluZCwgZmFsc2UsIChjdXJyZW50VmFsIHx8IDApICsgdmFsKTtcbiAgICAgICAgICAgICAgaWYgKCF2aikge1xuICAgICAgICAgICAgICAgIHZqID0gMDsgLy9zdHJpbmdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodHlwZW9mIHZqID09PSAnc3RyaW5nJyAmJiB2YWwgPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWwgPSAnJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YWwgKz0gdmo7IC8vb25seSBhZGQgbm8gb3BlcmF0b3Igc3R1ZmZcbiAgICAgICAgICAgICAgaWYgKCF0aGlzW2pdLl9sdmFsKSB7XG4gICAgICAgICAgICAgICAgbm9sdmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvL2Fsc28gYWRkIGJlZm9yZVxuICAgICAgICAgIHZhciBvcmRlcmVkO1xuICAgICAgICAgIGZvciAodmFyIGkgaW4gdGhpcykge1xuICAgICAgICAgICAgaWYgKG9wZXJhdG9yc1tpXSkge1xuICAgICAgICAgICAgICBpZiAoIW9wZXJhdG9yc1tpXS5vcmRlcikge1xuICAgICAgICAgICAgICAgIGlmICghZm9yY2UgJiYgdGhpc1tpXS5fbHN0YW1wICE9PSB0aGlzLl9sc3RhbXAgJiYgdGhpc1tpXS5fX3QgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsID0gX2dldE9wZXJhdG9yKHZhbCwgZm9yY2UsIGksIHRoaXMsIGJpbmQsIG9wZXJhdG9ycyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2x2YWwgJiYgIXRoaXNbaV0uX2x2YWwpIHtcbiAgICAgICAgICAgICAgICAgIG5vbHZhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChvcmRlcmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIW9yZGVyZWQucG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyZWQgPSBbb3JkZXJlZF07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgbyA9IG9wZXJhdG9yc1tpXS5vcmRlcixcbiAgICAgICAgICAgICAgICAgICAgb2wgPSBvcmRlcmVkLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBoID0gMDsgaCAhPT0gdHJ1ZSAmJiBoIDw9IG9sOyBoKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggPT09IG9sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG8gPCBvcGVyYXRvcnNbb3JkZXJlZFtoXV0ub3JkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhID0gb3JkZXJlZFtoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRbb2xdID0gaTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWQucHVzaChhKTtcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChoID09PSBvbCAmJiBvID4gb3BlcmF0b3JzW29yZGVyZWRbaF1dLm9yZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb3JkZXJlZC5wdXNoKGkpO1xuICAgICAgICAgICAgICAgICAgICAgIGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG9yZGVyZWQgPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvL3Nob3J0ZXJcbiAgICAgICAgICBpZiAob3JkZXJlZCkge1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2cob3JkZXJlZCk7XG4gICAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICAgIGkgPSBvcmRlcmVkLnBvcCA/ICh4ID0gMSkgJiYgb3JkZXJlZFswXSA6IG9yZGVyZWQ7XG4gICAgICAgICAgICB3aGlsZSAoaSAmJiB0aGlzW2ldKSB7XG4gICAgICAgICAgICAgIGlmICghZm9yY2UgJiYgdGhpc1tpXS5fbHN0YW1wICE9PSB0aGlzLl9sc3RhbXAgJiYgdGhpc1tpXS5fX3QgPT09IDEpIGZvcmNlID0gdHJ1ZVxuICAgICAgICAgICAgICB2YWwgPSBfZ2V0T3BlcmF0b3IodmFsLCBmb3JjZSwgaSwgdGhpcywgYmluZCwgb3BlcmF0b3JzKTtcbiAgICAgICAgICAgICAgaWYgKCFub2x2YWwgJiYgIXRoaXNbaV0uX2x2YWwpIG5vbHZhbCA9IHRydWVcbiAgICAgICAgICAgICAgaSA9IG9yZGVyZWRbeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbm9sdmFsICYmICFmb3JjZSkge1xuICAgICAgICB0aGlzLl9sdmFsID0gdmFsO1xuICAgICAgICB0aGlzLl9fbHZhbCA9IHZhbDtcbiAgICAgIH0gZWxzZSBpZiAoISh0aGlzLl9iYXNlICYmIHRoaXMuX2Jhc2UuaW5zdGFuY2VzKSkge1xuICAgICAgICB0aGlzLl9fbHZhbCA9IHZhbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9fbHZhbDtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBGaXJlcyBhbGwgbGlzdGVuZXJzXG4gICAqIEBtZXRob2QgdXBkYXRlXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gaW5zdGFuY2UgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IG5vaW5zdGFuY2VzIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBzdGFtcCAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gZnJvbSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHJlbW92ZSAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBhZGRlZCAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEByZXR1cm4ge1t0eXBlXX0gICAgICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgJ3VwZGF0ZScsXG4gIGZ1bmN0aW9uKGluc3RhbmNlLCBub2luc3RhbmNlcywgaW5zdGFuY2VzVXBkYXRlcywgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQpIHtcbiAgICAvL2lzIHRoaXMgcmVhbGx5IG5lc3NlY2FyeT9cbiAgICB0aGlzLl91cGRhdGUuY2FsbCggdGhpcywgdm9pZCAwLCBzdGFtcCB8fCB0aGlzLnN0YW1wKCksIGZyb20sIHJlbW92ZSwgZmFsc2UsIGZhbHNlLCBub2luc3RhbmNlcywgaW5zdGFuY2UsIGluc3RhbmNlc1VwZGF0ZXMgICk7IC8vdGhpcy52YWxcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLyoqXG4gICAqIEV4dGVuZHMgdmlnb3VyT2JqZWN0Ll91cGRhdGVcbiAgICogQWRkcyBsb2FkcyBvZiBzdHVmZiB0byBvcHRpbWl6ZSB1cGRhdGVzIGZvciBjYWxjdWxhdGlvbnNcbiAgICogQG1ldGhvZCBfdXBkYXRlXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gdmFsICAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IHN0YW1wICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBmcm9tICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gcmVtb3ZlICAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gIHtbdHlwZV19IGFkZGVkICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtICB7W3R5cGVdfSBub2luc3RhbmNlcyBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSAge1t0eXBlXX0gaW5zdGFuY2UgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgICAgICAgICAgIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gICdfdXBkYXRlJyxcbiAgZnVuY3Rpb24oIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgbm9pbnN0YW5jZXMsIGluc3RhbmNlLCBpbnN0YW5jZXNVcGRhdGVzICkge1xuXG4gICAgdmFyIHQgPSB0aGlzLFxuICAgICAgYmFzZSA9IHQuX2Jhc2U7XG5cbiAgICBpZiAodmFsIGluc3RhbmNlb2YgZXhwb3J0cyAmJiAhdC5fYmluZCkgXG4gICAge1xuICAgICAgaWYgKHZhbC5fY2FsbGVyKSB7XG4gICAgICAgIHQuX2JpbmQgPSB2YWwuX2NhbGxlcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoICghdC5fbHN0YW1wKSB8fCB0Ll9sc3RhbXAgIT09IHN0YW1wICApIHtcblxuICAgIC8vIHZhciBvcGVyYXRvcnMgPSB0Lm9wZXJhdG9yc1xuICAgIC8vIHZhciBsdmFsIFxuICAgIC8vIHZhciBjYWxjVmFsXG4gICAgLy8gdmFyIHBhc3NWYWx1ZUNhY2hlIFxuXG4gICAgLy8gaWYoICF0Lmlnbm9yZUNhY2hlICkge1xuICAgIC8vICAgLy9UT0RPOiB0aGlzIGlzIGEgdGVtcG9yYXJ5IGZpeCBuZWVkcyB0byBiZSBmYXN0ZXJcbiAgICAvLyAgIC8vbWFrZSB0aGlzIGEgbWV0aG9kXG4gICAgLy8gICBmdW5jdGlvbiBjbGVhbnVwKHQpIHtcbiAgICAvLyAgIFx0dC5fbHZhbCA9IHZvaWQgMFxuICAgIC8vICAgXHR0Ll9fbHZhbCA9IHZvaWQgMCBcbiAgICAvLyAgIFx0aWYodC5fdmFsIGluc3RhbmNlb2Ygb2JqZWN0ICkge1xuICAgIC8vICAgXHRcdC8vVE9ETzogaWYgc3R1ZmYgZG9lc250IHVwZGF0ZSB1bmNvbW1lbnQgdGhpcyBsaW5lXG4gICAgLy8gICBcdFx0Ly8gY2xlYW51cCh0Ll92YWwpXG4gICAgLy8gICBcdH1cbiAgXHQgLy8gICAgZm9yKHZhciAkZmllbGQgaW4gdCkge1xuICBcdCAvLyAgICBcdGlmKG9wZXJhdG9yc1skZmllbGRdKSB7XG4gIFx0IC8vICAgIFx0XHRjbGVhbnVwKHRbJGZpZWxkXSlcbiAgXHQgLy8gICAgXHR9IGVsc2UgaWYoJGZpZWxkID4gLTEpIHtcbiAgXHQgLy8gICAgXHRcdGNsZWFudXAodFskZmllbGRdKVxuICBcdCAvLyAgICBcdH1cbiAgXHQgLy8gICAgfVxuICAgIC8vIFx0fVxuICAgIC8vICAgY2xlYW51cCh0KVxuXG4gICAgLy8gICBsdmFsID0gdC5fX19sdmFsXG4gICAgLy8gICBjYWxjVmFsID0gdC52YWxcbiAgICAvLyAgIHBhc3NWYWx1ZUNhY2hlID0gbHZhbCA9PT0gdm9pZCAwIHx8IGx2YWwgIT09IGNhbGNWYWxcbiAgICAvLyAgIHQuX19fbHZhbCA9IGNhbGNWYWxcblxuICAgIC8vIH0gZWxzZSB7XG5cbiAgICAgIC8vIHQuY2xlYXJDYWNoZSgpXG4gICAgICAvLyBwYXNzVmFsdWVDYWNoZSA9IHRydWVcbiAgICAvLyB9XG5cbiAgICAgLy8gaWYgKCAgcGFzc1ZhbHVlQ2FjaGUgfHwgKCBiYXNlICYmIGJhc2UuaW5zdGFuY2VzICkgfHwgdC5fc2tpcCApIHsgLy9wYXNzIHRoaXMgY2FsY3VsYXRpb24gdG8gdnNldCBlbHNlIGl0cyB0b28gaGVhdnk7XG5cbiAgICB0Ll9sdmFsID0gZmFsc2UgIFxuICAgIC8vIHQuX3NraXAgPSB0cnVlXG4gICAgaWYoYmFzZSAmJiBiYXNlLmluc3RhbmNlcyB8fCB0Ll9za2lwIHx8IHQuX19sdmFsID09PSB2b2lkIDAgfHwgdC5fX19sdmFsICE9PSB0LnZhbCApIHtcblxuICAgICAgLy8gaWYod2luZG93LnNtdXQpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ3d0ZiBpcyBoYXBwZW5pbmchISEhJywgdC5fcGF0aCwgdCwgdC5fdXBkYXRlT3JpZ2luLCBhcmd1bWVudHMpXG4gICAgICAvLyB9XG5cbiAgICAgICAgdmFyIHByb3AgPSB0Ll9wcm9wLFxuICAgICAgICAgIHBhcmVudCA9IHQuX3BhcmVudCxcbiAgICAgICAgICB2c2V0ID0gcHJvcCAmJiBwcm9wLl92c2V0O1xuXG4gICAgICAgIHZhciBvcGVyYXRvcnMgPSB0Lm9wZXJhdG9yc1xuICBcbiAgICAgICAgLy9tYWtlIHRoaXMgYmV0dGVyXG4gICAgICAgIGlmICghKGZyb20gJiYgcmVtb3ZlKSAmJiBvcGVyYXRvcnMgJiYgKG9wZXJhdG9yc1t0Ll9uYW1lXSB8fCAocGFyZW50ICYmIHBhcmVudC5fX3QgPT09IDEgJiYgb3BlcmF0b3JzW3BhcmVudC5fbmFtZV0gJiYgKCFmcm9tIHx8IHQuX25hbWUgPT0gcGFyZW50Lmxlbmd0aCAtIDEpKSkpIHtcbiAgICAgICAgICAvL3dvcmtzIGZvciBhcnJheXMgc2luY2UgYXJyYXlzIGFyZSBhbHdheXMgcmVwbGFjZWQgb24gdXBkYXRlICwgdXBkYXRpbmcgYW4gaW5kaXZpZHVhbCBpdGVtIHVzaW5nIC5zZXQgd2lsbCBub3QgcmVzdWx0IGluIGFuIHVwZGF0ZSBhdCB0aGlzIHBvbnQgd2hpY2ggaGFzIHRvIGJlIHJlc29sdmVkXG4gICAgICAgICAgdmFyIF9vcCA9IHRoaXMuX3BhcmVudDtcbiAgICAgICAgICB3aGlsZSAob3BlcmF0b3JzW19vcC5fbmFtZV0pIHtcbiAgICAgICAgICAgIF9vcC5fbHZhbCA9IGZhbHNlOyAvL2lmIG5vIGNoYW5nZSB0byBsdmFsIGNhbiBnbyB3cm9uZy4uLlxuICAgICAgICAgICAgX29wID0gX29wLl9wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfb3ApIHtcbiAgICAgICAgICBcdC8vdGhpcyBnZWF0bHkgaW5jcmVhc2VzIHVwZGF0ZXMgbWF5IGJlIGltcG9ydGFudCBmb3IgYW5pbWF0aW9uIGJ1dCBub3QgbmVzc2VjYXJ5IGZvciBhbnl0aGluZyBlbHNlIVxuICAgICAgICAgICAgX29wLl91cGRhdGUodmFsLCBzdGFtcCwgdGhpcywgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsLCBub2luc3RhbmNlcywgaW5zdGFuY2UsIGluc3RhbmNlc1VwZGF0ZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0YW5jZXNVcGRhdGVzKSB7XG4gICAgICAgICAgaW5zdGFuY2VzVXBkYXRlcy5jYWxsKHQsIHZhbCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgYWRkZWQsIG9sZHZhbCwgbm9pbnN0YW5jZXMsIGluc3RhbmNlLCBpbnN0YW5jZXNVcGRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIGJhc2UgPSBpbnN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZzZXQpIHtcbiAgICAgICAgICAgIHQuX2NhbGxlciA9IGJhc2U7XG4gICAgICAgICAgICB2c2V0LmNhbGwodCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgdmFsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGJhc2UgJiYgdnNldCAmJiBiYXNlLmluc3RhbmNlcyAmJiAhbm9pbnN0YW5jZXMgJiYgcHJvcC51cGRhdGVpbnN0YW5jZXMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBiYXNlLmVhY2hJbnN0YW5jZShmdW5jdGlvbigpIHsgLy9sb29rIGZvciBjdXJyZW50IGNhbGxlciBpbnN0YW5jZSBwZXJoYXBzP1xuICAgICAgICAgICAgICB0Ll9jYWxsZXIgPSB0aGlzO1xuICAgICAgICAgICAgICB2c2V0LmNhbGwodCwgc3RhbXAsIGZyb20sIHJlbW92ZSwgdmFsKTtcbiAgICAgICAgICAgIH0sIHByb3AubmFtZSwgdCk7XG4gICAgICAgICAgICB0Ll9jYWxsZXIgPSBiYXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvL2Zvcm0gZ29uZSBsZXRzIHNlZSFcbiAgICAgICAgICAvL2Zyb20gc2VsZiBkb29yZ2V2ZW4gaW4gY2hhaW4gPT0tLSBpZiAhIG5vdCBmcm9tIGZyb20gLS0tPiAsIGV4dHJhIGFyZ1xuICAgICAgICAgIG9iamVjdC5wcm90b3R5cGUuX3VwZGF0ZS5jYWxsKHQsIHZhbCwgc3RhbXAsIGZyb20gfHwgdCwgcmVtb3ZlLCBhZGRlZCwgb2xkdmFsKVxuICAgICAgICB9XG5cbiAgICAgICAgLy9wYXMgb3AgbWV0IGRlemUhXG4gICAgICAgIHQuX2xzdGFtcCA9IHN0YW1wO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIC8vIGlmKHdpbmRvdy5zbXV0KSBjb25zb2xlLmxvZygnY2F0Y2ggaXQhJywgYXJndW1lbnRzKVxuICAgIH1cblxuXG4gICAgfVxuICB9KVxuXG4vL3JlcXVpcmluZyBvcGVyYXRvcnMgZG9lcyBub3QgYXV0b21hdGljbHkgcmVxdWlyZSB2aWdvdXJWYWx1ZSwgbWF5IGJlIGhhbmR5P1xudXRpbC5kZWZpbmUoZXhwb3J0cywgJ29wZXJhdG9ycycsIHtcbiAgdmFsdWU6IGV4cG9ydHMub3BlcmF0b3JzID0gcmVxdWlyZSgnLi9vcGVyYXRvcnMnKVxufSlcblxuXG5cbiIsInZhciBWYWx1ZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy92YWx1ZScpLFxuICB1dGlsID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwnKSxcbiAgVk9iamVjdCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9vYmplY3QnKVxuXG5leHBvcnRzLmV4dGVuZCA9IHV0aWwuZXh0ZW5kKFxuICBmdW5jdGlvbihUYXJnZXQpe1xuICAgIGlmKCBUYXJnZXQucHJvdG90eXBlIGluc3RhbmNlb2YgVk9iamVjdCB8fCBUYXJnZXQgPT09IFZPYmplY3QpIHtcbiAgICAgIC8vIFRPRE86IGZpeCB0aGlzIHRvIGFmZmVjdCBhbGwgVk9iamVjdCBibGFja2xpc3RzLi4uXG4gICAgICBUYXJnZXQucHJvdG90eXBlLl9ibGFja2xpc3QucHVzaCgnXyRsZW5ndGgnKVxuXG4gICAgICB1dGlsLmRlZmluZSggVGFyZ2V0LFxuICAgICAgICAnJGxlbmd0aCcsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IC4uLnNvIHdlIGRvbnQgaGF2ZSB0byBkbyBibGFja2xpc3QgY2hlY2s6XG4gICAgICAgICAgICB1dGlsLmluY2x1ZGUodGhpcy5fYmxhY2tsaXN0LCAnXyRsZW5ndGgnKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuXyRsZW5ndGggfHwgKHRoaXMuXyRsZW5ndGggPSBtYWtlTGVuZ3RoKHRoaXMpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBleHRlbmQgXCIkbGVuZ3RoXCIgb24gbm9uIFZPYmplY3QgQ2xhc3MnKVxuICAgIH1cbiAgfVxuKVxuXG5mdW5jdGlvbiBtYWtlTGVuZ3RoKGluc3RhbmNlKSB7XG4gIHZhciAkbGVuZ3RoID0gbmV3IFZhbHVlKHtcbiAgICB2YWw6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZ2V0TGVuZ3RoKGluc3RhbmNlKVxuICAgIH1cbiAgfSlcblxuICBpbnN0YW5jZS5vbihmdW5jdGlvbih2YWwpe1xuXG4gICAgLy8gdmFyIGlkZW50aWZpZXIgPSBpbnN0YW5jZS5fcGF0aC5sZW5ndGggXG4gICAgLy8gICA/IGluc3RhbmNlLl9wYXRoXG4gICAgLy8gICA6IGluc3RhbmNlLl9wcm9wICYmIGluc3RhbmNlLl9wcm9wLm5hbWVcbiAgICAvLyBjb25zb2xlLmxvZygnVVBEQVRFIE9OJywgaWRlbnRpZmllciwgJ1NISU5FIERBVCBMRU5HVEg/IScsICRsZW5ndGgudmFsXG4gICAgLy8gKVxuICAgIC8vIFRPRE86IG9ubHkgdXBkYXRlIGlmIGFkZGVkIG9yIHJlbW92ZWRcbiAgICAkbGVuZ3RoLl91cGRhdGUuYXBwbHkoJGxlbmd0aCwgYXJndW1lbnRzKVxuICB9KVxuXG4gIHJldHVybiAkbGVuZ3RoXG59XG5cbmZ1bmN0aW9uIGdldExlbmd0aCAoY3VycmVudCkge1xuICBpZighY3VycmVudCl7XG4gICAgcmV0dXJuIDBcbiAgfSBpZiAoY3VycmVudC5fZmlsdGVyKSB7XG4gICAgcmV0dXJuIGN1cnJlbnQubGVuZ3RoXG4gIH0gZWxzZSBpZiAoY3VycmVudC5fX3QgPT09IDQpIHtcbiAgICByZXR1cm4gZ2V0TGVuZ3RoKGN1cnJlbnQuX3ZhbClcbiAgfSBlbHNlIGlmIChjdXJyZW50Ll9fdCA8IDMpIHtcbiAgICByZXR1cm4gY3VycmVudC5rZXlzLmxlbmd0aFxuICB9IGVsc2UgaWYgKHR5cGVvZiBjdXJyZW50Ll92YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGN1cnJlbnQuX3ZhbC5sZW5ndGhcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMFxuICB9XG59XG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE0LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBKaW0gZGUgQmVlciwgamltQHZpZ291ci5pb1xuICovXG5cbiAgLypcbiAgICBFeHRlbnNpb24gZm9yIEJhc2UgY2xhc3NlcyB0byBjcmVhdGUgYW4gaW5oZXJpdGFibGUgb24gLSB2YWx1ZVxuICAqL1xuXG52YXIgVmFsdWUgPSByZXF1aXJlKCcuLycpXG4gICwgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIEJhc2UgPSByZXF1aXJlKCcuLi9iYXNlJylcblxuZXhwb3J0cy5leHRlbmQgPSB1dGlsLmV4dGVuZFxuKCBmdW5jdGlvbihiYXNlKVxuICB7XG4gICAgaWYoIGJhc2UgaW5zdGFuY2VvZiBCYXNlIClcbiAgICB7XG5cbiAgICAgIGJhc2UuZXh0ZW5kXG4gICAgICAoXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOidvbicsXG4gICAgICAgICAgc2V0OmZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmU6ZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAvL3JlbW92ZVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ltIGJlaW5nIHJlbW92ZWQhJylcbiAgICAgICAgICAgICBpZih0aGlzLm9uLiRyZW1vdmUpIHtcbiAgICAgICAgICAgICAgdGhpcy5vbi4kcmVtb3ZlLnVwZGF0ZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBuZXc6ZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICAvL2luaXRcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdJTklUIS0tLS0nLCB0aGlzLCB2YWwsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIGlmKHRoaXMub24uJG5ldykge1xuICAgICAgICAgICAgICB0aGlzLm9uLiRuZXcudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmVudDpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIC8vaW5pdFxuICAgICAgICAgICAgaWYodGhpcy5vbi4kcGFyZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMub24uJHBhcmVudC51cGRhdGUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVuZGVyOmZ1bmN0aW9uKHZhbCkge1xuICAgICAgICAgICAgLy9pbml0XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygnUkVOREVSIS0tLS0nLCB0aGlzLCB2YWwsIGFyZ3VtZW50cylcbiAgICAgICAgICAgIGlmKHRoaXMub24uJHJlbmRlcikge1xuICAgICAgICAgICAgICB0aGlzLm9uLiRyZW5kZXIudXBkYXRlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcblxuICAgIH1cbiAgICBlbHNlXG4gICAge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgZXh0ZW5kIFwib25cIiBvbiBub24gQmFzZSBDbGFzcycpXG4gICAgfVxuICB9XG4pXG4iLCIvKipcbiAqIG9wZXJhdG9yc1xuICogb3BlcmF0b3JzIGNhbiBiZSBzZXQgb24gVi5WYWx1ZS5vcGVyYXRvcnNcbiAqIGRlZmluZSBvcGVyYXRvcnMgb24gdGhpcyBtb2R1bGVcbiAqIEBwcm9wZXJ0eVxuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKVxuICAsIFYgPSByZXF1aXJlKCcuLi8nKVxuICBcbmV4cG9ydHMuYWRkID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgKyBvcGVyYXRvclxufVxuZXhwb3J0cy5zdWIgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCAtIG9wZXJhdG9yXG59XG5leHBvcnRzLm11bHRpcGx5ID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiB2YWwgKiBvcGVyYXRvclxufVxuZXhwb3J0cy5kaXZpZGUgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCAvIG9wZXJhdG9yXG59XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsID4gb3BlcmF0b3IgPyBvcGVyYXRvciA6IHZhbFxufVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCA8IG9wZXJhdG9yID8gb3BlcmF0b3IgOiB2YWxcbn1cbmV4cG9ydHMudHJhbnNmb3JtID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiBvcGVyYXRvciA9PT0gZmFsc2UgPyB2YWwgOiBvcGVyYXRvclxufVxuZXhwb3J0cy5hYnMgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIG9wZXJhdG9yID8gTWF0aC5hYnModmFsKSA6IHZhbFxufVxuZXhwb3J0cy5mbG9vciA9IGZ1bmN0aW9uKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gdmFsIHwgMFxufVxuZXhwb3J0cy5jZWlsID0gZnVuY3Rpb24gKCB2YWwsIG9wZXJhdG9yICkge1xuICByZXR1cm4gTWF0aC5jZWlsKCB2YWwgKVxufVxuZXhwb3J0cy5wcmVwZW5kID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiBvcGVyYXRvciArIHZhbFxufVxuZXhwb3J0cy5vciA9IGZ1bmN0aW9uICggdmFsLCBvcGVyYXRvciApIHtcbiAgcmV0dXJuIHZhbCB8fCBvcGVyYXRvclxufVxuZXhwb3J0cy53aGVuID0gZnVuY3Rpb24oIHZhbCwgb3BlcmF0b3IgKSB7XG4gIHJldHVybiBvcGVyYXRvciAmJiB2YWxcbn1cbmV4cG9ydHMuJGNvbnZlcnRUeXBlID0gZnVuY3Rpb24gKCB2YWwsIG9wZXJhdG9yICkge1xuICAvL2NvbnZlcnRUeXBlXG4gIGlmKCBvcGVyYXRvciA9PT0gJ2Jvb2xlYW4nIClcbiAgeyBcbiAgICByZXR1cm4gdmFsID8gdHJ1ZSA6IGZhbHNlXG4gIH0gXG4gIGVsc2UgaWYoIG9wZXJhdG9yID09PSAnbnVtYmVyJyApXG4gIHtcbiAgICAvL2RvIGlzTmFuIHN0YXJ0IHVzaW5nIGxvRGFzaCBmb3IgdGhpcyBraW5kIG9mIHN0dWZmICggYWxtb3N0IG5vdGhpbmcgKVxuICAgIC8vY29udmVydCBmYWxzeSBvciBOYU4gdmFsdWVzIHRvIDBcbiAgICByZXR1cm4gTnVtYmVyKCB2YWwgKVxuICB9XG59XG5cbmV4cG9ydHMuJGNvbnZlcnRUaW1lID0gZnVuY3Rpb24oIHRpbWUsIGRlY2ltYWxzICkge1xuICB2YXIgaHJzID0gfn4gKHRpbWUgLyAzNjAwKVxuICB2YXIgbWlucyA9IH5+ICgodGltZSAlIDM2MDApIC8gNjApXG4gIHZhciBzZWNzID0gIWlzTmFOKHBhcnNlRmxvYXQoZGVjaW1hbHMpKSAmJiBpc0Zpbml0ZShkZWNpbWFscylcbiAgICAgID8gKHRpbWUgJSA2MCkudG9GaXhlZChkZWNpbWFscykgOiB+fih0aW1lICUgNjApXG5cbiAgcmV0ID0gXCJcIjtcbiAgaWYgKGhycyA+IDApIHJldCArPSBcIlwiICsgaHJzICsgXCI6XCIgKyAobWlucyA8IDEwID8gXCIwXCIgOiBcIlwiKTtcbiAgcmV0ICs9IFwiXCIgKyBtaW5zICsgXCI6XCIgKyAoc2VjcyA8IDEwID8gXCIwXCIgOiBcIlwiKTtcbiAgcmV0ICs9IFwiXCIgKyBzZWNzO1xuICByZXR1cm4gcmV0IHx8IDA7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvbiggdmFsLCBvcGVyYXRvciApIHtcblxuLy8gY29uc29sZS5sb2coICc/Pz8/JywgdmFsIClcbiAgXG4gIC8vcGFzIG9wIG1ldCBkaWUgMFxuICBpZiggKCF2YWwgJiYgdmFsICE9PSAwKSB8fCB2YWwuX3ZhbCA9PT0gZmFsc2UgfHwgdmFsID09PSAnZXJyb3InIHx8IHZhbCA9PT0gJ3N1Y2Nlc3MnIClcbiAge1xuICAgIC8vVE9ETzogQXJyYXlzIGZvciBkZWZhdWx0IG9wZXJhdG9yXG4gICAgcmV0dXJuIG9wZXJhdG9yXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5leHBvcnRzLmRlZmF1bHQub3JkZXIgPSAxMDAwIiwibW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJykiLCJ2YXIgcGtnID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJylcbiAgLCBwbHVnaW5JZCA9IHBrZy5wbHVnaW4uaWRcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0ge31cblxuZXhwb3J0cy5nZXQgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgaWYgKCFjYikge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG4gIHRyeSB7XG4gICAgd2luZG93LnZpZ291ck5hdGl2ZS5icmlkZ2UocGx1Z2luSWQsICdnZXQnLCBvcHRzLCBjYilcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNiKGUpXG4gIH1cbn1cblxuZXhwb3J0cy5zZXQgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcbiAgaWYgKCFjYikge1xuICAgIGNiID0gb3B0c1xuICAgIG9wdHMgPSB7fVxuICB9XG4gIHRyeSB7XG4gICAgd2luZG93LnZpZ291ck5hdGl2ZS5icmlkZ2UocGx1Z2luSWQsICdzZXQnLCBvcHRzLCBjYilcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNiKGUpXG4gIH1cbn0iLCJtb2R1bGUuZXhwb3J0cz17XCJuYW1lXCI6XCJ2aWdvdXItbmF0aXZlLXN0YXR1c0JhclwiLFwidmVyc2lvblwiOlwiMjAxNS8wNi8xMCAxNTozMzoxNiBVVEMgKDAuMC4xKVwiLFwiYXV0aG9yXCI6e1wibmFtZVwiOlwiU2hhd24gSW5kZXJcIixcImVtYWlsXCI6XCJzaGF3bkB2aWdvdXIuaW9cIn0sXCJyZXBvc2l0b3J5XCI6e1widHlwZVwiOlwiZ2l0XCIsXCJ1cmxcIjpcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyLmdpdFwiLFwiYnJhbmNoXCI6XCJzaGF3bi1kZXZcIn0sXCJlbmdpbmVzXCI6e1wibm9kZVwiOlwiPj0wLjEwLjBcIn0sXCJtYWluXCI6XCJpbmRleC5qc1wiLFwic2NyaXB0c1wiOntcInN0YXJ0XCI6XCJnYXN0b25cIixcInRlc3RcIjpcInRlc3QvdGVzdC5qc1wifSxcImRlc2NyaXB0aW9uXCI6XCJBbGxvd3Mgb25lIHRvIGNvbnRyb2wgdGhlIG5hdGl2ZSBzdGF0dXMgYmFyIGZyb20gYSB3ZWIgYXBwXCIsXCJrZXl3b3Jkc1wiOltcInZpZ291clwiLFwibmF0aXZlXCIsXCJwbHVnaW5cIixcInN0YXR1c0JhclwiXSxcImJ1Z3NcIjp7XCJ1cmxcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIvaXNzdWVzXCJ9LFwiaG9tZXBhZ2VcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXJcIixcImRlcGVuZGVuY2llc1wiOntcImdhc3RvblwiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL3ZpZ291ci1pby9nYXN0b24uZ2l0XCIsXCJ2aWdvdXItbmF0aXZlXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb20vdmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUuZ2l0XCIsXCJ2aWdvdXItZnNcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLWZzLmdpdFwiLFwidmlnb3VyLWRldi10b29sc1wiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tL3ZpZ291ci1pby92aWdvdXItZGV2LXRvb2xzLmdpdFwifSxcIm9wdGlvbmFsRGVwZW5kZW5jaWVzXCI6e30sXCJkZXZEZXBlbmRlbmNpZXNcIjp7XCJucG1cIjpcIl4yLjcuNlwiLFwibnBtbG9nXCI6XCJeMS4yLjBcIn0sXCJwbHVnaW5cIjp7XCJpZFwiOlwic3RhdHVzYmFyXCIsXCJhbmRyb2lkXCI6e1wiY2xhc3NOYW1lXCI6XCJpby52aWdvdXIucGx1Z2luLnN0YXR1c2Jhci5TdGF0dXNCYXJQbHVnaW5cIixcImluc3RhbnRpYXRpb25cIjpcIm5ldyBTdGF0dXNCYXJQbHVnaW4odGhpcywgd2ViVmlldylcIixcImxpYk5hbWVcIjpcInN0YXR1c2Jhci1kZWJ1Zy5hYXJcIn19LFwiZ2l0SGVhZFwiOlwiNTg4ZGU0NzIzY2JkZTY3M2ZiMjJiNGEyOGI3MDQ3MjA0NWQzYzhmZlwiLFwicmVhZG1lXCI6XCIjIHZpZ291ci1uYXRpdmUtc3RhdHVzQmFyXFxuQWxsb3dzIG9uZSB0byBjb250cm9sIHRoZSBuYXRpdmUgc3RhdHVzIGJhciBmcm9tIGEgd2ViIGFwcFxcblxcbiMjSW5zdGFsbFxcbmBucG0gaSB2aWdvdXItbmF0aXZlLXN0YXR1c0JhcmBcXG5cXG4jI1VzYWdlXFxuU2VlIFt0ZXN0L2luZGV4LmpzXSh0ZXN0L2luZGV4LmpzKVxcblxcbiMjQnVpbGRpbmcgYSBzZXQgb2YgbmF0aXZlIGFwcHMgZnJvbSB5b3VyIGNvZGViYXNlXFxuLSBgbnBtIHJ1biBidWlsZGBcXG4tIGBucG0gcnVuIGJ1aWxkIC0tIGlvcyBhbmRyb2lkYFwiLFwicmVhZG1lRmlsZW5hbWVcIjpcIlJFQURNRS5tZFwiLFwiX2lkXCI6XCJ2aWdvdXItbmF0aXZlLXN0YXR1c0JhckAwLjAuMVwiLFwiX3NoYXN1bVwiOlwiODFjYzI1OTEwYmU3ZjE1OTU0MTdjM2I4ZmRmYjgzODJiMTI0N2Y0N1wiLFwiX2Zyb21cIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIuZ2l0XCIsXCJfcmVzb2x2ZWRcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbS92aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS1zdGF0dXNCYXIuZ2l0IzU4OGRlNDcyM2NiZGU2NzNmYjIyYjRhMjhiNzA0NzIwNDVkM2M4ZmZcIixcInNoYVwiOlwiMC4wLjFcIn0iLCJ2YXIgYXBwID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxuICAuaW5qZWN0KFxuICAgIHJlcXVpcmUoICd2aWdvdXItanMvYXBwL2NvbnRlbnQnICksXG4gICAgcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdXNlcicgKVxuICApXG5cbnJlcXVpcmUoICcuL3VzZXInIClcbnJlcXVpcmUoICcuL3ZhbHVlcycgKVxucmVxdWlyZSggJy4vcGxheWJhY2snKVxucmVxdWlyZSggJy4vaW5pdCcgKVxuXG53aW5kb3cuYSA9IGFwcFxuIiwidmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgY29uZmlnID0gcmVxdWlyZSggJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycgKVxudmFyIHVzZXIgPSBhcHAudXNlclxuXG4vLyBwcmVsb2FkZXJcbmFwcC5jc3MgPSB7XG4gIGFkZENsYXNzOiAncHJlbG9hZCdcbn1cblxudXNlci5kYXRhLmlzKCAnbG9hZGVkJyApXG4gIC8vZG8gdGhpcyBsYXRlciB3aGVuIGNvbnRlbnQgZ2V0cyBib3VuZFxuICAudGhlbiggZnVuY3Rpb24oKSB7IFxuICAgIGFwcC5yZWFkeS52YWwgPSB0cnVlXG4gICAgLy9hZGQgdGhpcyBsYXRlclxuICAgIC8vIHJldHVybiBhcHAuY29udGVudC5pcyggJ2xvYWRlZCcgKSBcbiAgfSlcbiAgLmRvbmUoIGZ1bmN0aW9uKCkge1xuICAgIGFwcC5jc3MgPSB7XG4gICAgICByZW1vdmVDbGFzczogJ3ByZWxvYWQnXG4gICAgfVxuICB9KVxuXG5cblxuYXBwLmluaXRpYWxpc2VkLm9uY2UodHJ1ZSwgZnVuY3Rpb24oKSB7XG4gIC8vIGNvbnNvbGUubG9nKGRvY3VtZW50LmRvbWFpbi5yZXBsYWNlKC9cXDpcXGRcXGRcXGRcXGQvLCAnOjEwMDAxJykpXG5cbiAgYXBwLmNsb3VkID0gY29uZmlnLmNsb3VkID09PSAnZG9tYWluJyA/IGRvY3VtZW50LmRvbWFpbisgJzoxMDAwMScgIDogY29uZmlnLmNsb3VkXG4vLyA9PT09PT09XG4gIC8vIGlmKHdpbmRvdy5nYXN0b24gJiYgd2luZG93Lmdhc3Rvbi5zZXJ2ZXJBZGRyZXNzLmluZGV4T2YoJ3snKSA9PT0gLTEpIHtcbiAgLy8gICBhcHAuY2xvdWQgPSAnd3M6Ly8nICtcbiAgLy8gICAgIHdpbmRvdy5nYXN0b24uc2VydmVyQWRkcmVzcy5zcGxpdCgnLy8nKVsxXS5zcGxpdCgnOicpWzBdICsgXG4gIC8vICAgICAnOjEwMDAxJ1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIGFwcC5jbG91ZCA9ICd3czovLycgKyBjb25maWcuY2xvdWRcbiAgLy8gfVxuICBcbi8vID4+Pj4+Pj4gZGV2XG4gIHVzZXIudG9rZW4udmFsID0gJ2Z1dHVyZWxhbmQnXG59KVxuXG4vKiAgIFxuJ3dzOi8vJyBcbiAgKyB3aW5kb3cuZ2FzdG9uLnNlcnZlckFkZHJlc3Muc3BsaXQoJy8vJylbMV0uc3BsaXQoJzonKVswXVxuICArICc6MTAwMDEnLy9cbiovXG4iLCJ2YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBWYWx1ZSA9IHJlcXVpcmUoICd2aWdvdXItanMvdmFsdWUnIClcbnZhciBjYXNlcyA9IGFwcC5jYXNlc1xudmFyIHVzZXIgPSBhcHAudXNlclxuXG5hcHAuaXNQbGF5aW5nLnZhbCA9IHtcbiAgdmFsOiBmYWxzZSxcbiAgJGlzUmVjZWl2ZXI6dXNlci5yZWNlaXZlci5wbGF5aW5nXG59XG5cbmFwcC52b2x1bWUgPSB7XG4gIHZhbDoxLFxuICAkaXNSZWNlaXZlcjogdXNlci5yZWNlaXZlci52b2x1bWVcbn1cblxuY2FzZXMuJGlzUGxheWluZyA9IGFwcC5pc1BsYXlpbmdcblxuaWYoY2FzZXMuJGlzUGhvbmUpIHtcbiAgYXBwLnBvcHVwLm9uKGZ1bmN0aW9uKHZhbCkge1xuICAgIGlmKHZhbCkge1xuICAgICAgaWYoYXBwLmlzUGxheWluZy52YWw9PT10cnVlKSB7XG4gICAgICAgIGFwcC5pc1BsYXlpbmcuZnJvbS52YWwgPSBmYWxzZVxuICAgICAgICBhcHAucG9wdXAuaXMoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsID09PSBmYWxzZVxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhcHAuaXNQbGF5aW5nLmZyb20udmFsID0gdHJ1ZVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuY2FzZXMuJGlzRnVsbHNjcmVlbiA9IG5ldyBWYWx1ZSgge1xuICB2YWw6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBhcHAuc3RhdGUudmFsID09PSAncGxheWVyJ1xuICB9LFxuICBsaXN0ZW46IGFwcC5zdGF0ZVxufSApXG5cbi8vIGNhc2VzLiRpc0xvYWRpbmdWaWRlbyA9IG5ldyBWYWx1ZSgge1xuLy8gICB2YWw6IGZhbHNlLFxuLy8gICBkZWZlcjogZnVuY3Rpb24oIHVwZGF0ZSApIHtcbi8vICAgICB2YXIgX3RoaXMgPSB0aGlzXG4vLyAgICAgaWYgKCB0aGlzLl90aW1lciApIHtcbi8vICAgICAgIGNsZWFyVGltZW91dCggdGhpcy5fdGltZXIgKVxuLy8gICAgICAgdGhpcy5fdGltZXIgPSBudWxsXG4vLyAgICAgfVxuLy8gICAgIGlmICggdGhpcy5fdmFsICkge1xuLy8gICAgICAgdGhpcy5fdGltZXIgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcbi8vICAgICAgICAgX3RoaXMudmFsID0gZmFsc2Vcbi8vICAgICAgICAgX3RoaXMuX3RpbWVyID0gbnVsbFxuLy8gICAgICAgfSwgMjAwMCApXG4vLyAgICAgfVxuLy8gICAgIHVwZGF0ZSgpXG4vLyAgIH1cbi8vIH0gKVxuXG4vLyBhcHAuaXNQbGF5aW5nLm9uKCBmdW5jdGlvbiggdmFsICkge1xuLy8gICBpZiAoIGNhc2VzLiRpc0xvZ2dlZEluLnZhbCApIHtcbi8vICAgICBpZiAoIHZhbCA9PT0gdHJ1ZSApIHtcbi8vICAgICAgIC8vIFRPRE86IHRoaXMgY3Jhc2hlcyBub3csIHNvIGkgY29tbWVudGVkIGl0IG91dFxuLy8gICAgICAgLy8gdmFyIG1lZGlhID0gYXBwLnVzZXIubmF2aWdhdGlvbi5tZWRpYS5mcm9tXG4vLyAgICAgICAvLyBpZiAoIG1lZGlhLl9wYXJlbnQuX25hbWUgIT09ICdjaGFubmVscycgKSB7XG4vLyAgICAgICAvLyAgIHZhciBlcGkgPSBhcHAudXNlci51c2FnZS5mcm9tLmdldCggbWVkaWEuX2NvbnRlbnRQYXRoICksXG4vLyAgICAgICAvLyAgICAgc2hvdyA9IGVwaS5fcGFyZW50Ll9wYXJlbnQuX3BhcmVudC5fcGFyZW50XG5cbi8vICAgICAgIC8vICAgaWYgKCBzaG93ICkge1xuLy8gICAgICAgLy8gICAgIHNob3cuc2V0KCAnbWVkaWEnLCBtZWRpYSApXG4vLyAgICAgICAvLyAgIH1cbi8vICAgICAgIC8vIH1cbi8vICAgICB9XG4vLyAgIH1cbi8vIH0pXG4iLCJ2YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgdXNlciA9IGFwcC51c2VyLmluamVjdChcbiAgcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91c2VyL3Rva2VuJyksXG4gIHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdXNlci91c2FnZScpLFxuICByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VzZXIvbmF2aWdhdGlvbicpLFxuICByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VzZXIvbXVsdGlzY3JlZW4nKVxuKVxuXG51c2VyLnNldCh7XG4gIHNlYXJjaDogZmFsc2UsXG4gIGZvY3VzX3JvdzogJ3Nwb3RsaWdodCcsXG4gIC8vIGZvY3VzX2NoYW5uZWxzOjAsXG4gIGZvY3VzX2FjdG9yOjAsXG4gIGZvY3VzX2NoYW5uZWxzOjAsXG4gIGZvY3VzX3Nwb3RsaWdodDowLFxuICBmb2N1c193YXRjaGluZzowLFxuICBmb2N1c19yZWNvbW1lbmRlZDowLFxuICBmb2N1c19yZWxlYXNlczowLFxuICByZWNlbnRTZWFyY2hlczoge30sXG4gIHBvcHVwOjAsXG4gIHRyYWlsZXJNdXRlZDp0cnVlXG4gIC8vIHVybDogcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL25ldHdvcmsvdXJsJyApXG59KVxuXG5hcHAucG9wdXAudmFsID0gdXNlci5wb3B1cFxuXG52YXIgVmFsdWUgPSByZXF1aXJlKCd2aWdvdXItanMvdmFsdWUnKVxuXG5hcHAuZGV2aWNlTWVzc2FnZSA9IG5ldyBWYWx1ZSh7XG4gIHZhbDogdXNlci5yZWNlaXZlckNsaWVudCxcbiAgdHJhbnNmb3JtOiBmdW5jdGlvbiggYywgY3YgKXtcbiAgICB2YXIgdGl0bGUgPSBjdiAmJiBjdi5mcm9tICYmIGN2LmZyb20udGl0bGUgJiYgY3YuZnJvbS50aXRsZS52YWxcbiAgICAvLyBjb25zb2xlLmVycm9yKCdkZXZpY2VNZXNzYWdlISAnLCB0aXRsZSlcbiAgICByZXR1cm4gdGl0bGUgPyAnQ29ubmVjdGVkIHRvICcgKyB0aXRsZSA6ICdOb3QgQ29ubmVjdGVkJ1xuICB9XG59KVxuIiwidmFyIGFwcCA9IHJlcXVpcmUoJy4vJylcbnZhciB1c2VyID0gYXBwLnVzZXJcbnZhciBjYXNlcyA9IGFwcC5jYXNlc1xudmFyIFZhbHVlID0gcmVxdWlyZSgndmlnb3VyLWpzL3ZhbHVlJylcbiAgLy8gVE9ETzogYmFzZSB0aGlzIG9uIGRldmljZSByb2xlXG4vLyBhcHAuc3RhdGUudmFsID0ge1xuLy8gICBkZWZhdWx0OiAnZmlyc3QnXG4vLyB9XG5cbmFwcC5zdGF0ZS52YWwgPSBjYXNlcy4kaXNQaG9uZSA/ICdmaXJzdCcgOiAnc2Vjb25kJ1xuXG5hcHAuY3VycmVudCA9IG5ldyBWYWx1ZSh7XG4gIHZhbDogdXNlci5uYXZpZ2F0aW9uLmxhc3QsXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24odiwgbGFzdCkge1xuICAgIHZhciBrZXkgPSBsYXN0LmtleSAmJiBsYXN0LmtleS52YWxcbiAgICByZXR1cm4ga2V5ID09PSAncGFnZScgPyB1c2VyLm5hdmlnYXRpb24ucGFnZS52YWwgOiBrZXlcbiAgfSxcbiAgbGlzdGVuOiBbXG4gICAgdXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQsXG4gICAgdXNlci5uYXZpZ2F0aW9uLnBhZ2VcbiAgXVxufSlcblxuYXBwLnByZXZpb3VzID0gbmV3IFZhbHVlKHtcbiAgdmFsOmFwcC5jdXJyZW50LFxuICBkZWZlcjpmdW5jdGlvbih1cGRhdGUsYXJncyl7XG4gICAgdmFyIHZhbCA9IHRoaXMuX3ZhbC52YWxcbiAgICBpZih0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWwgIT09IHRoaXMuY3VycmVudCl7XG4gICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnRcbiAgICAgIHRoaXMuY3VycmVudCA9IHZhbFxuICAgIH1cbiAgICB1cGRhdGUoKVxuICB9LFxuICB0cmFuc2Zvcm06ZnVuY3Rpb24odmFsKXtcbiAgICByZXR1cm4gdmFsLl9wYXJlbnQucHJldiB8fCAwXG4gIH1cbn0pXG5cbmFwcC5zZWNvbmRQb3B1cCA9IG5ldyBWYWx1ZShmYWxzZSlcblxuYXBwLmhpZGVTdGF0dXNiYXIgPSBuZXcgVmFsdWUoe1xuICB2YWw6IGZhbHNlLFxuICB0cmFuc2Zvcm06IGFwcC5pc1BsYXlpbmdcbn0pXG5cbmNhc2VzLiRoYXNSZWNlaXZlci5vbihmdW5jdGlvbigpIHtcbiAgYXBwLmNzcyA9IHRoaXMudmFsID8ge1xuICAgIGFkZENsYXNzOiAnaGFzUmVjZWl2ZXInXG4gIH0gOiB7XG4gICAgcmVtb3ZlQ2xhc3M6ICdoYXNSZWNlaXZlcidcbiAgfVxufSlcblxuaWYoIWNhc2VzLiRpc1Bob25lKXtcbiAgY2FzZXMuJGlzUmVjZWl2ZXIub24oZnVuY3Rpb24oKXtcbiAgICBhcHAuc3RhdGUudmFsID0gdGhpcy52YWwgPyAnc2Vjb25kJyA6ICdpbmFjdGl2ZSdcbiAgfSlcbn0iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgQWN0b3JzID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvYWN0b3JzJylcbnZhciBEZXNjcmlwdGlvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2Rlc2NyaXB0aW9uJylcbnZhciBQcm9ncmVzcyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3NlZWtiYXInKS5CYXJcbnZhciBUaXRsZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3RpdGxlJylcbnZhciBQb2xsID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvcG9sbCcpXG52YXIgU3RhdGlzdGljcyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3N0YXRpc3RpY3MnKVxudmFyIFRyaXZpYSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3RyaXZpYScpXG52YXIgQ29udGVudCA9IHJlcXVpcmUoJy4uL2NvbnRlbnQnKVxudmFyIEJhciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2JhcicpXG52YXIgVHdlZXRzID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvdHdlZXRzJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ29udGVudCh7XG4gICdob2xkZXIucGFnZSc6IHtcbiAgICBjb250YWluZXI6e1xuICAgICAgJ21vZGVsLmZpZWxkJzonZ3VpZGUuMCcsXG4gICAgICB0aXRsZWJhcjpuZXcgQmFyKHtcbiAgICAgICAgY3NzOiAndWktYmFyJyxcbiAgICAgICAgYWNjZW50OiB7fSxcbiAgICAgICAgbGVmdDoge1xuICAgICAgICAgIHRpdGxlOm5ldyBUaXRsZSgpLFxuICAgICAgICAgIHRpbWVmaWxsZXI6IHtcbiAgICAgICAgICAgICdsZWZ0LnRleHQuZGF0YSc6J3N0YXJ0LXRpbWUnLFxuICAgICAgICAgICAgJ21pZGRsZS5maWxsZXInOiBuZXcgUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAnc2Vlay53JzogJzc1JSdcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgJ3JpZ2h0LnRleHQuZGF0YSc6J2VuZC10aW1lJyAgXG4gICAgICAgICAgfSAgXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgZGVzY3JpcHRpb246bmV3IERlc2NyaXB0aW9uKHtcbiAgICAgICAgZGlzcGxheTp7XG4gICAgICAgICAgZGF0YTonZGVzY3JpcHRpb24nLFxuICAgICAgICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgICAgICAgIHJldHVybiBjdiA/ICdibG9jaycgOiAnbm9uZSdcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgYWN0b3JzOm5ldyBBY3RvcnMoKSxcbiAgICAgIHBvbGw6bmV3IFBvbGwoKSxcbiAgICAgIHN0YXRpc3RpY3M6bmV3IFN0YXRpc3RpY3MoKSxcbiAgICAgIHRyaXZpYTpuZXcgVHJpdmlhKCksXG4gICAgICB0d2VldHM6bmV3IFR3ZWV0cygpLFxuICAgIH0sXG4gICAgY29sbGVjdGlvbjp7XG4gICAgICBkYXRhOidndWlkZScsXG4gICAgICBlbGVtZW50Om5ldyBCYXIoe1xuICAgICAgICBsZWZ0OiB7XG4gICAgICAgICAgdGl0bGU6bmV3IFRpdGxlKCksXG4gICAgICAgICAgaW5mbzoge1xuICAgICAgICAgICAgJ2xlZnQudGV4dCc6e1xuICAgICAgICAgICAgICBkYXRhOidzdGFydC10aW1lJyxcbiAgICAgICAgICAgICAgYWRkOltcbiAgICAgICAgICAgICAgICAnIC0gJyxcbiAgICAgICAgICAgICAgICB7ZGF0YTonZW5kLXRpbWUnfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAgXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59KS5DbGFzc1xuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBQbGF5ZXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL2FjdGl2ZS9wbGF5ZXInKVxudmFyIFRvcGJhciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvYWN0aXZlL3RvcGJhcicpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICdjb250ZW50LWl0ZW0nLFxuICB4OiB7XG4gICAgdHJhbnNsYXRlOiB0cnVlXG4gIH0sXG4gIHNjcm9sbGJhcjogJ3knLFxuICBob2xkZXI6IHtcbiAgICB5OiB7XG4gICAgICB2YWw6IDAsXG4gICAgICBhbmltYXRpb246IHtcbiAgICAgICAgdGltZTogMTgsXG4gICAgICAgIGVhc2luZzogJ291dEN1YmljJyxcbiAgICAgICAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgICBpZiAodGhpcy55LnZhbCA9PT0gLXRoaXMucGxheWVyLmgudmFsIC0gMSkge1xuICAgICAgICAgICAgaWYgKCFfdGhpcy5pc1N3aXBlZHVwLnZhbCkge1xuICAgICAgICAgICAgICBfdGhpcy5zd2lwZXVwLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghX3RoaXMudGltZW91dHkpIHtcbiAgICAgICAgICAgICAgX3RoaXMudGltZW91dHkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1N3aXBlZHVwLnZhbCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMuc3dpcGV1cC5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy50aW1lb3V0eSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgX3RoaXMueS52YWwgPSBfdGhpcy5pc1N3aXBlZHVwLnZhbCA/IC1fdGhpcy5wbGF5ZXIuaC52YWwgKyAzMCA6IDBcbiAgICAgICAgICAgICAgfSwgMClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHBsYXllcjogbmV3IFBsYXllcigpLFxuICAgIHN3aXBldXA6IHtcbiAgICAgIGRpc3BsYXk6ICdub25lJyxcbiAgICAgIG5lc3RlZDoge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdzogYXBwLncsXG4gICAgICAgIGg6IGFwcC5oLFxuICAgICAgICBtc2c6e1xuICAgICAgICAgIGljb246bmV3IEljb24oe1xuICAgICAgICAgICAgaWNvbjoncHVsbGJhY2snXG4gICAgICAgICAgfSksXG4gICAgICAgICAgdGV4dDogJ1Jlc3VtZSBIZXJlJ1xuICAgICAgICB9LFxuICAgICAgICAnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgYXBwLnVzZXIucmVjZWl2ZXIubWVkaWEuJHVzZXJPcmlnaW4gPSBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB2YWw6IGFwcC5oLFxuICAgICAgICBtdWx0aXBseTogLTFcbiAgICAgIH0sXG4gICAgICBoOiBhcHAuaFxuICAgIH0sXG4gICAgZXh0ZW5kOiB7XG4gICAgICBpc1N3aXBlZHVwOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlbmRlcmVkICYmIHZhbCAmJiB2YWwudmFsKSB7XG4gICAgICAgICAgdGhpcy5zd2lwZXVwLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgdGhpcy55ID0gLXRoaXMucGxheWVyLmgudmFsICsgMzBcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN3aXBldXAuZGlzcGxheS52YWwgPT09ICdibG9jaycpIHtcbiAgICAgICAgICB0aGlzLnkgPSAtdGhpcy5wbGF5ZXIuaC52YWwgLSAxXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy55ID0gdmFsLnZhbCA9PT0gdHJ1ZSA/IC10aGlzLnBsYXllci5oLnZhbCAtIDEgOiAwXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZWNlaXZlck1lZGlhOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnBhcmVudC5kYXRhXG4gICAgICAgIGlmKGRhdGEpe1xuICAgICAgICAgIHZhciBzd2lwZXVwID0gdGhpcy5pc1N3aXBlZHVwID0gdmFsLmZyb20gPT09IGRhdGEuZnJvbVxuICAgICAgICAgIGlmIChzd2lwZXVwKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXllci5wbGF5aW5nLmZyb20gPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGltZSA9IGRhdGEuZnJvbS5nZXQoJ3RpbWUnKVxuICAgICAgICAgICAgaWYgKHRpbWUudmFsIDwgMCkge1xuICAgICAgICAgICAgICBkYXRhLmZyb20uZ2V0KCd0aW1lJykudmFsID0gTWF0aC5hYnModGltZS52YWwpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoICcuL3N0eWxlLmxlc3MnIClcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBfZm9jdXNlZCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3V0aWwnKS5mb2N1c2VkXG52YXIgTGlzdCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0JylcblxudmFyIExpc3RIb2xkZXIgPSBuZXcgRWxlbWVudCgge1xuICAnaGVhZGVyLnRleHQnOntkYXRhOid0aXRsZSd9LFxuICAnZXZlbnRzLmRvd24nOiBmdW5jdGlvbiggZSApIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgdmFyIGhvbGRlciA9IHRoaXMucGFyZW50XG4gICAgdmFyIGVZID0gZS55XG4gICAgdmFyIGVYID0gZS54XG4gICAgdmFyIGlkID0gJ3Bhc3NDaGVjaydcblxuICAgIHRoaXMuYWRkRXZlbnQoICdtb3ZlJywgZnVuY3Rpb24oIGUgKSB7XG4gICAgICB2YXIgZFkgPSBlLnkgLSBlWVxuICAgICAgdmFyIGRYID0gZS54IC0gZVhcbiAgICAgIGlmICggTWF0aC5hYnMoIGRYICkgPiBNYXRoLmFicyggZFkgKSApIHtcbiAgICAgICAgaG9sZGVyLiRmb2N1cy4kdXNlck9yaWdpbiA9IF90aGlzLm5hbWVcbiAgICAgIH1cbiAgICAgIF90aGlzLnJlbW92ZUV2ZW50KCBmYWxzZSwgaWQgKVxuICAgIH0sIGlkIClcblxuICAgIHRoaXMuYWRkRXZlbnQoICd1cCcsIGZ1bmN0aW9uKCBlICkge1xuICAgICAgX3RoaXMucmVtb3ZlRXZlbnQoIGZhbHNlLCBpZCApXG4gICAgfSwgaWQgKVxuICB9XG59ICkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCgge1xuICBjc3M6ICdmaXJzdC1kaXNjb3ZlcicsXG4gIHNwb3RsaWdodDogbmV3IExpc3RIb2xkZXIoIHtcbiAgICBoZWFkZXI6ZmFsc2UsXG4gICAgbGlzdDogbmV3IExpc3QuU3BvdGxpZ2h0KHsnbW9kZWwuZmllbGQnOidzcG90bGlnaHQnfSksXG4gICAgZG90czogbmV3IExpc3QuRG90cygpXG4gIH0gKSxcbiAgY2hhbm5lbHM6IG5ldyBMaXN0SG9sZGVyKHtcbiAgICBtb2RlbDp7ZmllbGQ6J2NoYW5uZWxzJ30sXG4gICAgbGlzdDogbmV3IExpc3QuQ2hhbm5lbCgpXG4gIH0gKSxcbiAgd2F0Y2hpbmc6IG5ldyBMaXN0SG9sZGVyKCB7XG4gICAgbW9kZWw6e2ZpZWxkOid3YXRjaGluZyd9LFxuICAgIGxpc3Q6IG5ldyBMaXN0LldhdGNoaW5nKClcbiAgfSApLFxuICByZWxlYXNlczogbmV3IExpc3RIb2xkZXIoIHtcbiAgICBtb2RlbDp7ZmllbGQ6J3JlbGVhc2VzJ30sXG4gICAgbGlzdDogbmV3IExpc3QuUG9zdGVyKClcbiAgfSApLFxuICByZWNvbW1lbmRlZDogbmV3IExpc3RIb2xkZXIoIHtcbiAgICBtb2RlbDp7ZmllbGQ6J3JlY29tbWVuZGVkJ30sXG4gICAgbGlzdDogbmV3IExpc3QuUG9zdGVyKClcbiAgfSApLFxuICBleHRlbmQ6e1xuICAgICRmb2N1czogZnVuY3Rpb24oIHZhbCApIHtcbiAgICAgIHZhciBjaGlsZCA9IHR5cGVvZiB2YWwudmFsID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHRoaXNbdmFsLnZhbF1cbiAgICAgICAgOiB0aGlzLmNoaWxkcmVuWyB2YWwudmFsIHx8IDAgXVxuICAgICAgX2ZvY3VzZWQoIHRoaXMsIGNoaWxkIClcbiAgICB9XG4gIH0sXG4gIHNjcm9sbGJhcjogJ3knLFxuICAnZXZlbnRzLnNjcm9sbCc6IGZ1bmN0aW9uKCBlICkge1xuICAgIGlmKGV4cG9ydHMuaWdub3JlU2Nyb2xsKSByZXR1cm5cbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZVxuICAgIHZhciBmcmFjdGlvbiA9IChleHBvcnRzLnNjcm9sbFRvcCA9IG5vZGUuc2Nyb2xsVG9wKSAvICggbm9kZS5zY3JvbGxIZWlnaHQgLSBub2RlLm9mZnNldEhlaWdodCApXG4gICAgdmFyIGluZGV4ID0gTWF0aC5yb3VuZCggZnJhY3Rpb24gKiAoIHRoaXMuY2hpbGRyZW4ubGVuZ3RoIC0gMSApIClcbiAgICB2YXIgbmFtZSA9IHRoaXMuY2hpbGRyZW5baW5kZXhdLm5hbWVcbiAgICB0aGlzLiRmb2N1cy4kdXNlck9yaWdpbiA9IG5hbWVcbiAgfSxcbiAgc2V0U2V0dGluZzoge1xuICAgIG5hbWU6ICdwcmVwVmFsdWVzJyxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuICAgICAgdmFyIGNoaWxkXG4gICAgICB2YXIgZmllbGRcbiAgICAgIHZhciBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGhcbiAgICAgIHZhciBpID0gbGVuZ3RoIC0gMVxuICAgICAgdmFyIG9ialxuXG4gICAgICBmb3IgKCA7IGkgPj0gMDsgaS0tICkge1xuICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldXG4gICAgICAgIGZpZWxkID0gJ2ZvY3VzXycgKyBjaGlsZHJlbltpXS5uYW1lXG4gICAgICAgIGlmICggIWFwcC51c2VyWyBmaWVsZCBdICl7XG4gICAgICAgICAgb2JqID0ge31cbiAgICAgICAgICBvYmpbIGZpZWxkIF0gPSAwXG4gICAgICAgICAgYXBwLnVzZXIuc2V0KCBvYmogKVxuICAgICAgICB9XG4gICAgICAgIGNoaWxkLmxpc3QuJGZvY3VzID0gYXBwLnVzZXJbIGZpZWxkIF1cbiAgICAgICAgaWYoY2hpbGQuZG90cykgY2hpbGQuZG90cy5jb250YWluZXIuJGZvY3VzID0gYXBwLnVzZXJbIGZpZWxkIF1cbiAgICAgIH1cblxuICAgICAgaWYoZXhwb3J0cy5zY3JvbGxUb3Ape1xuICAgICAgICBleHBvcnRzLmlnbm9yZVNjcm9sbCA9IHRydWVcbiAgICAgICAgdGhpcy5ub2RlLnNjcm9sbFRvcCA9IGV4cG9ydHMuc2Nyb2xsVG9wXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgICAgICBleHBvcnRzLmlnbm9yZVNjcm9sbCA9IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpc1xuICAgICAgICBleHBvcnRzLmlnbm9yZVNjcm9sbCA9IHRydWVcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe1xuICAgICAgICAgIGV4cG9ydHMuaWdub3JlU2Nyb2xsID0gZmFsc2VcbiAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzLm5vZGVcbiAgICAgICAgICBpZihub2RlKXtcbiAgICAgICAgICAgIHZhciBmb2N1cyA9IF90aGlzLiRmb2N1cy52YWxcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KF90aGlzW2ZvY3VzXSlcbiAgICAgICAgICAgIG5vZGUuc2Nyb2xsVG9wID0gaW5kZXgvKGxlbmd0aCAtIDEpICogKCBub2RlLnNjcm9sbEhlaWdodCAtIG5vZGUub2Zmc2V0SGVpZ2h0IClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICB9XG4gIH1cbn0gKS5DbGFzc1xuXG5mdW5jdGlvbiBnZXRJbmRleCggX3RoaXMgKXtcbiAgaWYgKF90aGlzLl9pbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgdmFyIHNpYmxpbmdzID0gX3RoaXMucGFyZW50LmNoaWxkcmVuXG4gICAgZm9yICh2YXIgaSA9IHNpYmxpbmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBzaWJsaW5nc1tpXS5faW5kZXggPSBpXG4gICAgfVxuICB9XG4gIHJldHVybiBfdGhpcy5faW5kZXhcbn1cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBNb3ZpZSA9IHJlcXVpcmUoJy4uL21vdmllJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgTW92aWUoe1xuICAnaG9sZGVyLnBhZ2UnOiB7XG4gICAgJ2FjdG9ycy5ib2R5LmNvbGxlY3Rpb24uZGF0YSc6J3Nob3cuYWN0b3JzJyxcbiAgICAncmVjb21tZW5kYXRpb25zLmJvZHkuY29sbGVjdGlvbi5kYXRhJzonc2hvdy5yZWNvbW1lbmRhdGlvbnMnXG4gIH1cbn0pLkNsYXNzXG5cbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTUsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cbnJlcXVpcmUoICcuL3N0eWxlLmxlc3MnIClcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBjYXNlcyA9IGFwcC5jYXNlc1xudmFyIFRvcGJhciA9IHJlcXVpcmUoJy4vdG9wYmFyJylcbnZhciBNZW51ID0gcmVxdWlyZSgnLi9tZW51JylcbnZhciBSZW1vdGUgPSByZXF1aXJlKCcuL3JlbW90ZScpXG52YXIgUG9wdXBcbnZhciBGaXJzdFxuXG4vL2FwcCBhbGxlZW4gbWFhciB6byByZXF1aXJlbiB6b2RhdCBqZSBlcmJpaiBrYW4gdmFycyBtb2V0ZW4gYWx0aWpkIG1lZ2VnZXZiIHdpcmRlblxuLy9hcHAga2FuIGplIHVzZW4gdm9vciBkaW5nZW4gYWxzIGFwcC53LCBhcHAuaCBvZiBkZWZhdWx0IGNhc2VzXG5cbmlmICggY2FzZXMuJGlzUGhvbmUgKSB7XG5cbiAgdmFyIFN3aXRjaGVyID0gcmVxdWlyZSggJy4vc3dpdGNoZXInIClcblxuICBGaXJzdCA9IG5ldyBFbGVtZW50KHtcbiAgICAvLyB3OmFwcC53LFxuICAgIHk6e3ZhbDowLHRyYW5zbGF0ZTp0cnVlfSxcbiAgICAvLyBoOmFwcC5oLFxuICAgIGNzczogJ2ZpcnN0LXN0YXRlJyxcbiAgICBtZW51OiBuZXcgTWVudSh7XG4gICAgICBtZW51OiBhcHAubWVudVxuICAgIH0pLFxuICAgIG9uOiB7XG4gICAgICAvL3JlcGxhY2Ugb24gd2l0aCBleHRlbmRlZCB2YXJzIChuaWNlcikgbWF5YmUgbWFrZSBhIHR5cGUgZm9yIHRoaXMgKHZhbHVlIHRoYXQgYWxzbyB0cmllcyB0byBnZXQgcGFyZW50IGlmIGl0cyBubyBmdWxsKVxuICAgICAgLy92YWx1ZSB0aGF0IGhhcyBhIGZ1bmN0aW9uIG9uIGl0IHRoYXRzIGp1c3QgdGhlIGRlZmVyP1xuICAgICAgcG9wdXA6e1xuICAgICAgICBkZWZlcjpmdW5jdGlvbih1cGRhdGUpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgIHZhciBjYWxsZXIgPSB0aGlzLl9wYXJlbnQuX2NhbGxlclxuICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLnZhbCA9PT0gJ3N0cmluZycgfHwgdGhpcy5mcm9tLl9jb250ZW50VHlwZSA9PT0gJ2FjdG9ycycpIHtcbiAgICAgICAgICAgIGlmKCFjYWxsZXIucG9wdXApIHtcbiAgICAgICAgICAgICAgUG9wdXAgPSBQb3B1cCB8fCByZXF1aXJlKCcuL3BvcHVwJylcbiAgICAgICAgICAgICAgY2FsbGVyLnNldCh7XG4gICAgICAgICAgICAgICAgcG9wdXA6IG5ldyBQb3B1cCh7XG4gICAgICAgICAgICAgICAgICBwb3B1cDp0aGlzLl92YWxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2Vjb25kUG9wdXA6e1xuICAgICAgICBkZWZlcjpmdW5jdGlvbih1cGRhdGUpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKVxuICAgICAgICAgIHZhciBjYWxsZXIgPSB0aGlzLl9wYXJlbnQuX2NhbGxlclxuICAgICAgICAgIGlmKHR5cGVvZiB0aGlzLnZhbCA9PT0gJ3N0cmluZycgfHwgdGhpcy5mcm9tLl9jb250ZW50VHlwZSA9PT0gJ2FjdG9ycycpIHtcbiAgICAgICAgICAgIGlmKCFjYWxsZXIudm9sdW1lKSB7XG4gICAgICAgICAgICAgIFBvcHVwID0gUG9wdXAgfHwgcmVxdWlyZSgnLi9wb3B1cCcpXG4gICAgICAgICAgICAgIGNhbGxlci5zZXQoe1xuICAgICAgICAgICAgICAgIHZvbHVtZTogbmV3IFBvcHVwKHtcbiAgICAgICAgICAgICAgICAgIHBvcHVwOnRoaXMuX3ZhbFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGhvbGRlcjoge1xuICAgICAgY3NzOntcbiAgICAgICAgdmFsOiBhcHAubWVudSwgXG4gICAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odmFsLCBjdikge1xuICAgICAgICAgIHJldHVybiBjdiA/ICdvcGVuJyA6ICcnXG5cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHg6eyBcbiAgICAgICAgdmFsOiBhcHAubWVudSxcbiAgICAgICAgbXVsdGlwbHk6MzI1LFxuICAgICAgICBhbmltYXRpb246eyB0aW1lOiAxMiwgZWFzaW5nOidvdXRDdWJpYycgfSBcbiAgICAgIH0sXG4gICAgICB0b3BiYXI6IG5ldyBUb3BiYXIoKSxcbiAgICAgIC8vIHc6IHtcbiAgICAgIC8vICAgcGFyZW50OiAndydcbiAgICAgIC8vIH0sXG4gICAgICAvLyBoOntcbiAgICAgIC8vICAgcGFyZW50OiAnaCdcbiAgICAgIC8vIH0sXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgZG93bjpmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYoYXBwLm1lbnUudmFsKSB7XG4gICAgICAgICAgICBlLnByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICBhcHAubWVudS52YWwgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHN3aXRjaGVyOiBuZXcgU3dpdGNoZXIoe1xuICAgICAgICAvLyB3OmFwcC53LFxuICAgICAgICAvLyBoOnsgdmFsOmFwcC5oLHN1YjpUb3BiYXIuYmFzZS5oIH1cbiAgICAgIH0pLFxuICAgICAgbWluaXBsYXllcjogbmV3IFJlbW90ZSh7XG4gICAgICAgIFxuICAgICAgfSkgXG4gICAgfVxuICB9KS5DbGFzc1xuXG59IGVsc2Uge1xuXG4gIEZpcnN0ID0gbmV3IEVsZW1lbnQoe1xuICAgIHRleHQ6ICdvb3BzIG5vdCBwaG9uZSBpbiBmaXJzdHNjcmVlbidcbiAgfSkuQ2xhc3NcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZpcnN0IiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgSWNvbiA9IHJlcXVpcmUoJy4uLy4uL3NoYXJlZC9pY29uJylcblxudmFyIE1lbnVJdGVtID0gbmV3IEVsZW1lbnQoe1xuXHRpY29uOiBuZXcgSWNvbih7aWNvbjonc2VhcmNoJ30pLFxuXHRjc3M6J21lbnUtaXRlbScsXG5cdHRpdGxlOnt9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG5cdHc6YXBwLncsXG5cdGg6YXBwLmgsXG5cdGxvZ286IHt9LFxuXHRjc3M6J21lbnUnLFxuXHRleHRlbmQ6IHtcblx0XHRtZW51OmZ1bmN0aW9uKCl7fSxcblx0XHRuYXZpZ2F0aW9uOmZ1bmN0aW9uKCl7fVxuXHR9LFxuXHQvLyBzY3JvbGxiYXI6J3knLFxuXHRhcHBlbmQ6IFtcblx0XHRNZW51SXRlbSxcblx0XHR7ICd0aXRsZS50ZXh0Jzonc2VhcmNoJyxcblx0XHRcdCdpY29uLmljb24nOiAnc2VhcmNoTWVudScsXG5cdFx0XHQnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnQubmF2aWdhdGlvbi5mcm9tLnBhZ2UuJHVzZXJPcmlnaW4gPSAnc2VhcmNoJ1xuXHRcdFx0XHR0aGlzLnBhcmVudC5tZW51LmZyb20udmFsID0gZmFsc2Vcblx0XHRcdH1cblx0XHR9LFxuXHRcdHsgJ3RpdGxlLnRleHQnOidkaXNjb3ZlcicsXG5cdFx0XHQnaWNvbi5pY29uJzogJ2Rpc2NvdmVyJyxcblx0XHQgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Lm5hdmlnYXRpb24uZnJvbS5wYWdlLiR1c2VyT3JpZ2luID0gJ2Rpc2NvdmVyJ1xuXHRcdFx0XHR0aGlzLnBhcmVudC5tZW51LmZyb20udmFsID0gZmFsc2Vcblx0XHRcdH1cblx0XHR9LFxuXHRcdHtcblx0XHRcdCd0aXRsZS50ZXh0Jzonb24gZGVtYW5kJyxcblx0XHRcdCdpY29uLmljb24nOiAnc2hvd3MnLFxuXHRcdFx0Y3NzOidtZW51LWl0ZW0gaW5hY3RpdmUnXG5cdFx0fSxcblx0XHR7XG5cdFx0XHQndGl0bGUudGV4dCc6J2xpdmUgdHYnLFxuXHRcdFx0J2ljb24uaWNvbic6ICd0dicsXG5cdFx0ICBjc3M6J21lbnUtaXRlbSBpbmFjdGl2ZSdcblx0XHR9LFxuXHRcdHtcblx0XHRcdCd0aXRsZS50ZXh0JzonZ3VpZGUnLFxuXHRcdFx0J2ljb24uaWNvbic6ICdlcGcnLFxuXHRcdFx0Y3NzOidtZW51LWl0ZW0gaW5hY3RpdmUnXG5cdFx0fVxuXHRdLFxuXHRmb290ZXI6IHtcblx0XHRwcm9maWxlOnt9LFxuXHRcdHRpdGxlOiB7XG5cdFx0XHR0ZXh0OidLZXZpbiBUYWd1ZSdcblx0XHR9LFxuXHRcdHNldHRpbmdzOiBuZXcgSWNvbih7XG5cdFx0XHRpY29uOidzZXR0aW5ncydcblx0XHR9KVxuXHR9XG59KS5zZXQoe1xuXHRuYXZpZ2F0aW9uOntcblx0XHRkZWZlcjpmdW5jdGlvbih1cGRhdGUpIHtcblx0XHRcdGlmKHRoaXMuZnJvbS5wYWdlKSB7XG5cdFx0XHRcdGZvcih2YXIgaSBpbiB0aGlzLl9jYWxsZXIuY2hpbGRyZW4pIHtcblx0XHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLl9jYWxsZXIuY2hpbGRyZW5baV1cblx0XHRcdFx0XHR2YXIgdGl0bGUgPSBjaGlsZC50aXRsZSAmJiAgY2hpbGQudGl0bGUudGV4dC52YWxcblx0XHRcdFx0XHR2YXIgcGFnZSA9IHRoaXMuZnJvbS5wYWdlLnZhbFxuXG5cdFx0XHRcdFx0aWYoIHRpdGxlICYmIHRpdGxlPT09cGFnZSAmJiB0aGlzLl9mb2N1c2VkIT09Y2hpbGQpIHtcblx0XHRcdFx0XHRcdGlmKHRoaXMuX2ZvY3VzZWQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5fZm9jdXNlZC5jc3MgPSdtZW51LWl0ZW0nXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdHRoaXMuX2ZvY3VzZWQgPSB0aGlzLl9jYWxsZXIuY2hpbGRyZW5baV1cblx0XHRcdFx0XHRcdHRoaXMuX2ZvY3VzZWQuY3NzID0gJ21lbnUtaXRlbSBmb2N1c2VkJyBcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dXBkYXRlKClcblx0XHR9XG5cdH1cbn0pLkNsYXNzXG5cblxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvdGl0bGUnKVxudmFyIFN1YnRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3VidGl0bGUnKVxudmFyIERlc2NyaXB0aW9uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvZGVzY3JpcHRpb24nKVxudmFyIEJhciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2JhcicpXG52YXIgQWN0b3JzID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvYWN0b3JzJylcbnZhciBSZWNvbW1lbmRhdGlvbnMgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9yZWNvbW1lbmRhdGlvbnMnKVxudmFyIENvbnRlbnQgPSByZXF1aXJlKCcuLi9jb250ZW50JylcbnZhciBNcGFhID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvbXBhYScpXG52YXIgUmF0aW5nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvcmF0aW5nJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgQ29udGVudCh7XG4gICdob2xkZXIucGFnZSc6IHtcbiAgICB0aXRsZWJhcjpuZXcgQmFyKHtcbiAgICAgIGxlZnQ6e1xuICAgICAgICB0aXRsZTpuZXcgVGl0bGUoKSxcbiAgICAgICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKClcbiAgICAgIH0sXG4gICAgICByaWdodDp7XG4gICAgICAgIG1wYWE6bmV3IE1wYWEoKSxcbiAgICAgICAgcmF0aW5nOm5ldyBSYXRpbmcoKVxuICAgICAgfVxuICAgIH0pLFxuICAgIGRlc2NyaXB0aW9uOiBuZXcgRGVzY3JpcHRpb24oKSxcbiAgICBhY3RvcnM6bmV3IEFjdG9ycygpLFxuICAgIHJlY29tbWVuZGF0aW9uczpuZXcgUmVjb21tZW5kYXRpb25zKClcbiAgfVxufSkuQ2xhc3MiLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG5cbnZhciBGdWxsc2NyZWVuID0gbmV3IEVsZW1lbnQoe1xuICBpY29uOiBuZXcgSWNvbih7IGljb246ICdmdWxsc2NyZWVuJyB9KSxcbiAgZXZlbnRzOiB7XG4gICAgY2xpY2s6IGZ1bmN0aW9uKCl7XG4gICAgICBjb25zb2xlLmxvZygnZ28gZnVsbHNjcmVlbiEnKVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBGdWxsc2NyZWVuXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBWaWRlbyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8nKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBGdWxsc2NyZWVuID0gcmVxdWlyZSgnLi9mdWxsc2NyZWVuJylcbnZhciBTZWVrYmFyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc2Vla2JhcicpXG5cbnZhciBwb3N0cG9uZSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cy91dGlsJykucG9zdHBvbmVcblxudmFyIEFTU0VUUyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpLnBvaW50ZXJzLmFzc2V0c1xuXG52YXIgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG5cbnZhciBMb2FkZXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9sb2FkZXInKVxuXG52YXIgUGxheWVyID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J2ZpcnN0LXBsYXllcicsXG4gIHZpZGVvOiBuZXcgVmlkZW8oe1xuICAgIHBsYXllcjogcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8vaHRtbDUnICksXG4gICAgc3JjOiB7IGRhdGE6ICd2aWRlbycsIHByZXBlbmQ6IEFTU0VUUyB9LFxuICAgIGR1cmF0aW9uOiB7IGRhdGE6ICdkdXJhdGlvbicgfSxcbiAgICB2b2x1bWU6IDEsXG4gICAgdGltZTogeyBkYXRhOiAndGltZScgfSxcbiAgICBldmVudHM6e1xuICAgICAgc3RhbGxlZDpmdW5jdGlvbigpIHtcbiAgICAgICAgaWYoIHRoaXMucmVuZGVyZWQgKSB0aGlzLnBhcmVudC5wcmVsb2FkKHRydWUpXG4gICAgICB9LFxuXG5cbiAgICAgIHBsYXk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIGlmKGdhc3RvbikgZ2FzdG9uLmxvZygnaGV5IHBsYXkhJylcblxuICAgICAgICBpZih0aGlzLnJlbmRlcmVkICYmIHRoaXMuZ2V0QnVmZmVyKCk8MC4wMDEpIHtcbiAgICAgICAgICB0aGlzLnBhcmVudC5wcmVsb2FkKHRydWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjYW5wbGF5OmZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnBhcmVudC5wcmVsb2FkKGZhbHNlKVxuICAgICAgfSxcbiAgICAgIHByb2dyZXNzOiBmdW5jdGlvbihwLCBiKSB7XG5cbiAgICAgICAgLy9iZXR0ZXIgdG8gY2hlY2sgaWYgaXRzIGluY3JlYXNlZFxuICAgICAgICAvLyBpZih0aGlzLnByZWxvYWRpbmcgJiYgKGItcCkqdGhpcy5kdXJhdGlvbi52YWwgPiAyMCkge1xuXG4gICAgICAgIC8vIHRoaXMucGFyZW50LnRleHQgPSBwICsgJyAnICsgdGhpcy5wcmV2XG5cbiAgICAgICAgaWYodGhpcy5wcmV2ICYmIHAgPiB0aGlzLnByZXYgKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQucHJlbG9hZChmYWxzZSlcbiAgICAgICAgfSBcblxuICAgICAgICB0aGlzLnByZXYgPSBwXG5cbiAgICAgICAgLy9kaXQgZ2FhdCBlcnVpdFxuICAgICAgICBpZih0aGlzLmRhdGEuX2NvbnRlbnRUeXBlIT09J2NoYW5uZWxzJykge1xuICAgICAgICAgIHRoaXMuZGF0YS5mcm9tLnNldCgndGltZScsIC1NYXRoLmFicyhwKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSksXG4gIGg6MjEwLFxuICAvLyBsb2FkZXI6IHtcbiAgLy8gICAndyxoJzoyMDAsXG4gIC8vIH0sXG4gIG92ZXJsYXk6IHtcbiAgICBtaWRkbGU6IHtcbiAgICAgIGxlZnQ6IHsgcGxheToge1xuICAgICAgICAgIGljb246IG5ldyBJY29uKHsgXG4gICAgICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICAgIHZhbDogJ3BsYXknLFxuICAgICAgICAgICAgICAkaXNQbGF5aW5nOiAncGF1c2UnXG4gICAgICAgICAgICB9IFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHN1YnRpdGxlOiB7XG4gICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgIHZhbDogJ1BsYXknLFxuICAgICAgICAgICAgICAkaXNQbGF5aW5nOiAnUGF1c2UnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIGRvd246IGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICBpZih0aGlzLmNoZWNrUGFyZW50KCdvdmVybGF5Jyx0cnVlKS5vcGFjaXR5LnZhbCA+IDAuNSkge1xuICAgICAgICAgICAgICAgIHZhciBwbGF5aW5nID0gdGhpcy5jaGVja1BhcmVudCgnb3ZlcmxheScpLnBsYXlpbmcuZnJvbVxuICAgICAgICAgICAgICAgIHBsYXlpbmcudmFsID0gIXBsYXlpbmcudmFsXG4gICAgICAgICAgICAgICAgLy8gZS50ZW1wUHJldmVudCA9IHRydWVcbiAgICAgICAgICAgICAgICBlLnByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtaWRkbGU6IHsgXG4gICAgICAgIGxpbmU6IHt9LFxuICAgICAgICBkaXNwbGF5OiB7XG4gICAgICAgICAgdmFsOiAnbm9uZScsXG4gICAgICAgICAgJGhhc1JlY2VpdmVyOiAndGFibGUtY2VsbCcsXG4gICAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbigpe31cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJpZ2h0OiB7IFxuICAgICAgICBzd2lwZXVwOiB7XG4gICAgICAgICAgaWNvbjogbmV3IEljb24oeyBpY29uOiAnc3dpcGV1cCcgfSksXG4gICAgICAgICAgc3VidGl0bGU6IHtcbiAgICAgICAgICAgIHRleHQ6ICdQbGF5IG9uICdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgZG93bjogZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgIGlmKHRoaXMuY2hlY2tQYXJlbnQoJ292ZXJsYXknLHRydWUpLm9wYWNpdHkudmFsID4gMC41KSB7XG4gICAgICAgICAgICAgICAgYXBwLnVzZXIucmVjZWl2ZXIucGxheWluZy4kdXNlck9yaWdpbiA9IHRydWVcbiAgICAgICAgICAgICAgICBhcHAudXNlci5yZWNlaXZlci5tZWRpYS4kdXNlck9yaWdpbiA9IHRoaXMuY2hlY2tQYXJlbnQoJ2RhdGEnLHRydWUpLmZyb21cbiAgICAgICAgICAgICAgICBlLnByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGRpc3BsYXk6IHtcbiAgICAgICAgICB2YWw6ICdub25lJyxcbiAgICAgICAgICAkaGFzUmVjZWl2ZXI6ICd0YWJsZS1jZWxsJyxcbiAgICAgICAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKCl7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIGxlZnQ6IHsgXG4gICAgICAgIHRhYmxlOiB7XG4gICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgZGF0YTpmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgIHJldHVybiBkYXRhLl9jb250ZW50VHlwZT09PSdjaGFubmVscycgPyAnbm9uZScgOiAndGFibGUnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0aW1lOnsgaG9sZGVyOiB7IHRleHQ6e2RhdGE6J3RpbWUnLCBtdWx0aXBseTogeyBkYXRhOidkdXJhdGlvbid9LCBhYnM6dHJ1ZSwgJGNvbnZlcnRUaW1lOnRydWUgfSB9IH0sXG4gICAgICAgICAgaG9sZGVyIDp7XG4gICAgICAgICAgICBzZWVrYmFyOiBuZXcgU2Vla2Jhcih7XG4gICAgICAgICAgICAgYnV0dG9uOnt5Ont2YWw6LTgsdHJhbnNsYXRlOnRydWV9fVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGR1cmF0aW9uOnsgdGV4dDp7IGRhdGE6J2R1cmF0aW9uJywgJGNvbnZlcnRUaW1lOnRydWUgfSB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByaWdodDogeyBmdWxsc2NyZWVuOiBuZXcgRnVsbHNjcmVlbigpIH1cbiAgICB9LFxuICAgIG9wYWNpdHk6IHtcbiAgICAgIHZhbDoxLCBhbmltYXRpb246e1xuICAgICAgICB0aW1lOjE4LFxuICAgICAgICBlYXNpbmc6J291dEN1YmljJ1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVmaW5lOiB7XG4gICAgcHJlbG9hZDogZnVuY3Rpb24odmFsKSB7XG4gICAgICBpZih2YWw9PT10cnVlICYmIHRoaXMucmVuZGVyZWQpIHtcbiAgICAgICB0aGlzLnByZWxvYWRpbmcgPSB0cnVlXG4gICAgICAgdGhpcy5vdmVybGF5LmJvdHRvbS5sZWZ0LnRhYmxlLmhvbGRlci5zZWVrYmFyLmNzcyA9ICd1aS1zZWVrYmFyIGxvYWRpbmcnXG4gICAgICAgdGhpcy5vdmVybGF5Lm9wYWNpdHkgPSAxXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm92ZXJsYXkuYm90dG9tLmxlZnQudGFibGUuaG9sZGVyLnNlZWtiYXIuY3NzID0gJ3VpLXNlZWtiYXInXG5cblxuICAgICAgICBpZih0aGlzLnZpZGVvLiRwbGF5aW5nLnZhbD09PXRydWUgJiYgdGhpcy5wcmVsb2FkaW5nKSB7XG4gICAgICAgICAgdGhpcy5vdmVybGF5Lm9wYWNpdHkgPSAwXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcmVsb2FkaW5nID0gZmFsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGZhZGVPdXQ6cG9zdHBvbmUoZnVuY3Rpb24oKSB7XG4gICAgICBpZih0aGlzLnBsYXlpbmcgJiYgdGhpcy5wbGF5aW5nLnZhbD09PXRydWUgJiYgIXRoaXMucHJlbG9hZGluZykge1xuICAgICAgICB0aGlzLm92ZXJsYXkub3BhY2l0eSA9IDBcbiAgICAgIH1cbiAgICB9LDMwMDApXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIGRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmKHRoaXMub3ZlcmxheS5vcGFjaXR5LnZhbD09PTAgfHwgZS50ZW1wUHJldmVudCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkub3BhY2l0eSA9IDEgXG4gICAgICAgIGlmKHRoaXMucGxheWluZy52YWw9PT10cnVlKSB7XG4gICAgICAgICAgdGhpcy5mYWRlT3V0KClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKHRoaXMucGxheWluZy52YWw9PT10cnVlICYmICFlLnRlbXBQcmV2ZW50KSB7XG4gICAgICAgIHRoaXMub3ZlcmxheS5vcGFjaXR5ID0gMFxuICAgICAgfVxuICAgIH0sXG4gICAgbW92ZTpmdW5jdGlvbigpIHtcbiAgICAgIGlmKHRoaXMucGxheWluZy52YWw9PT10cnVlKSB7XG4gICAgICAgIHRoaXMuZmFkZU91dCgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBleHRlbmQ6e1xuICAgIHBsYXlpbmc6IHtcbiAgICAgIHNldDpmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdGhpcy52aWRlby4kcGxheWluZyA9IHZhbFxuICAgICAgICBpZih2YWwudmFsPT09dHJ1ZSkge1xuICAgICAgICAgIHRoaXMub3ZlcmxheS5vcGFjaXR5ID0gMFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3ZlcmxheS5vcGFjaXR5ID0gMVxuICAgICAgICB9XG4gICAgICAvLyBpZigpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlOmZ1bmN0aW9uKCkge1xuICAgICAgICBhcHAuaXNQbGF5aW5nLmZyb20gPSBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVjZWl2ZXI6IGZ1bmN0aW9uKHZhbCwgc3RhbXApIHtcbiAgICAgIGlmKGNhc2VzLiRoYXNSZWNlaXZlci52YWwpIHtcbiAgICAgICAgdmFyIHJlY2VpdmVyQ2xpZW50ID0gdmFsLmZyb21cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gUGxheWVyXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgUGFnZSA9IHJlcXVpcmUoJy4uL3BhZ2UuanMnKVxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgTGlzdCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2xpc3QnKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgUG9zdGVyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9pdGVtJykuUG9zdGVyXG52YXIgVHJpdmlhID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvdHJpdmlhJylcbnZhciBEZXNjcmlwdGlvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2Rlc2NyaXB0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IFBhZ2Uoe1xuICB3OiBhcHAudyxcbiAgaDoge1xuICAgIHZhbDogYXBwLmgsXG4gICAgc3ViOiA2MFxuICB9LFxuICBzY3JvbGxiYXI6ICd5JyxcbiAgY2Fyb3VzZWw6IHtcbiAgICBjb250YWluZXI6IG5ldyBMaXN0LkNhcm91c2VsKHtcbiAgICAgIGNvbGxlY3Rpb246IHtcbiAgICAgICAgZGF0YTogJ2ltZy5jb3ZlcicsXG4gICAgICAgIGVsZW1lbnQ6IG5ldyBFbGVtZW50KHtcbiAgICAgICAgICBjc3M6ICdmb2N1cy1pdGVtJyxcbiAgICAgICAgICBpbWc6IG5ldyBJbWcoe1xuICAgICAgICAgICAgb3ZlcmxheToge30sXG4gICAgICAgICAgICAnYmFja2dyb3VuZC5kYXRhJzogdHJ1ZVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAgJGZvY3VzOiB7XG4gICAgICAgIGRhdGE6ICdmb2N1cydcbiAgICAgIH1cbiAgICB9KSxcbiAgICBkb3RzOiBuZXcgTGlzdC5Eb3RzKHtcbiAgICAgIGNvbnRhaW5lcjoge1xuICAgICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgICAgZGF0YTogJ2ltZy5jb3ZlcicsXG4gICAgICAgICAgZWxlbWVudDogbmV3IEVsZW1lbnQoKVxuICAgICAgICB9LFxuICAgICAgICAkZm9jdXM6IHtcbiAgICAgICAgICBkYXRhOiAnZm9jdXMnLFxuICAgICAgICAgIGRlZmF1bHQ6MFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksXG4gICAgJ21vZGVsLnN1YnNjcmlwdGlvbic6IHtcbiAgICAgIGltZzoge1xuICAgICAgICBjb3Zlcjoge1xuICAgICAgICAgICQ6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYmlvOiBuZXcgRGVzY3JpcHRpb24oe1xuICAgICdoZWFkZXIudGV4dCc6ICdiaW8nLFxuICAgICdib2R5LnRleHQuZGF0YSc6ICdiaW8nXG4gIH0pLFxuICBmYW1vdXM6IHtcbiAgICAnaGVhZGVyLnRleHQnOiAnRmFtb3VzIEZvcicsXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgZGF0YTogJ2NhdGFsb2cnLFxuICAgICAgZWxlbWVudDogbmV3IFBvc3Rlcih7XG4gICAgICAgICdldmVudHMuY2xpY2snOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICBhcHAucG9wdXAuJHVzZXJPcmlnaW4gPSBmYWxzZVxuICAgICAgICAgIGFwcC51c2VyLm5hdmlnYXRpb24uY29udGVudC4kdXNlck9yaWdpbiA9IHRoaXMuZGF0YS5mcm9tXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICB0cml2aWE6IG5ldyBUcml2aWEoe1xuICAgIG1vZGVsOiB7XG4gICAgICBmaWVsZDogJ3RyaXZpYSdcbiAgICB9XG4gIH0pLFxuICBvbjoge1xuICAgICRwYXJlbnQ6IHtcbiAgICAgIGRlZmVyOiBmdW5jdGlvbih1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5fcGFyZW50Ll9jYWxsZXIucGFyZW50LnBhcmVudC50b3BiYXIubWlkZGxlLnRleHQgPSB0aGlzLl9wYXJlbnQuX2NhbGxlci5kYXRhLmdldCgndGl0bGUnKVxuICAgICAgICB1cGRhdGUoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGNhc2VzID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJyApXG52YXIgdWEgPSByZXF1aXJlKCAndmlnb3VyLWpzL2Jyb3dzZXIvdWEnIClcblxudmFyIHJhZiA9IHJlcXVpcmUoICd2aWdvdXItanMvYnJvd3Nlci9hbmltYXRpb24vcmFmJyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBJY29uID0gcmVxdWlyZSggJy4uLy4uLy4uL3NoYXJlZC9pY29uJyApXG5cbnZhciBEZXZpY2UgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ2RldmljZScsXG4gIGljb246IG5ldyBJY29uKHsgaWNvbjogeyBcbiAgICBkYXRhOiAnZGV2aWNlJ1xuICB9IH0pLFxuICBpbmZvOiB7XG4gICAgdGl0bGU6IHsgdGV4dDogeyBkYXRhOiAndGl0bGUnfSB9LFxuICAgIHN1YnRpdGxlOiB7IHRleHQ6IHsgZGF0YTogJ2luZm8nIH0gfVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCgge1xuICBjc3M6ICdhY3RpdmUgZGV2aWNlcycsXG4gIG15RGV2aWNlOiBuZXcgRGV2aWNlKHtcbiAgICBtb2RlbDogeyBpbmhlcml0OiBmYWxzZSB9LFxuICAgIG9uOiB7XG4gICAgICAkbmV3OiB7ZGVmZXI6IGZ1bmN0aW9uKHVwZGF0ZSl7XG4gICAgICAgIHRoaXMuX3BhcmVudC5fY2FsbGVyLmRhdGEgPSBhcHAuY2xvdWQuY2xpZW50XG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9fVxuICAgIH0sXG4gICAgaW5mbzoge1xuICAgICAgdGl0bGU6IHsgdGV4dDogJ1RoaXMgRGV2aWNlJyB9LFxuICAgICAgc3VidGl0bGU6IHsgdGV4dDogeyBkYXRhOiAndGl0bGUnIH0gfVxuICAgIH1cbiAgfSksXG4gIGxpc3RUaXRsZTogeyB0ZXh0OiAnQXZhaWxhYmxlIERldmljZXMnIH0sXG4gIG1pZGRsZToge1xuICAgIGRpc3BsYXk6IHtcbiAgICAgIHZhbDogJ2Jsb2NrJyxcbiAgICAgICRoYXNEZXZpY2VzOiAnbm9uZSdcbiAgICB9LFxuICAgIHRleHQ6ICdObyBEZXZpY2VzIEF2YWlsYWJsZSdcbiAgfSxcbiAgbGlzdDoge1xuICAgIGRpc3BsYXk6IHtcbiAgICAgIHZhbDogJ25vbmUnLFxuICAgICAgJGhhc0RldmljZXM6ICdibG9jaydcbiAgICB9LFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGVsZW1lbnQ6IG5ldyBEZXZpY2UoIHtcbiAgICAgICAgY3NzOiAnZGV2aWNlJyxcbiAgICAgICAgbW9kZWw6IGZ1bmN0aW9uKCBkYXRhICkge1xuICAgICAgICAgIGlmKCBkYXRhICYmIGRhdGEuZnJvbSAmJiBkYXRhLmZyb20uZGV2aWNlICYmIFxuICAgICAgICAgICAgICAvKHBob25lKS8udGVzdChcbiAgICAgICAgICAgICAgICBkYXRhLmZyb20uZGV2aWNlLnZhbCBcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLm9wYWNpdHkgPSAwLjVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB1c2VyID0gYXBwLnVzZXIvL3RoaXMuY2hlY2tQYXJlbnQoICdvbi51c2VyJywgdHJ1ZSApLl92YWxcbiAgICAgICAgICAgIHZhciBjbGllbnQgPSB0aGlzLmRhdGEuZnJvbVxuICAgICAgICAgICAgaWYoIC8odHYpfCh0YWJsZXQpfChJRkUpLy50ZXN0KCBcbiAgICAgICAgICAgICAgICAgIGNsaWVudC5kZXZpY2UudmFsIFxuICAgICAgICAgICAgICAgICkgXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICB1c2VyLnNldFJlY2VpdmVyKCBjbGllbnQgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSApLFxuICAgICAgZGF0YTogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgb246IHtcbiAgICAkcmVuZGVyOiB7XG4gICAgICBkZWZlcjogZnVuY3Rpb24odXBkYXRlKSB7XG4gICAgICAgIC8vIGZmIGJpbmRlbiBub2dcbiAgICAgICAgdmFyIGNhbGxlciA9IHRoaXMuX3BhcmVudC5fY2FsbGVyXG4gICAgICAgIGNhbGxlci5vbi5kZXZpY2VzLl92YWwuX3VwZGF0ZSgpXG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICAkcGFyZW50OntcbiAgICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuICAgICAgICB0aGlzLl9wYXJlbnQuX2NhbGxlci5wYXJlbnQucGFyZW50LnRvcGJhci5taWRkbGUudGV4dCA9ICdkZXZpY2VzJ1xuICAgICAgICB1cGRhdGUoKVxuICAgICAgfVxuICAgIH0sXG4gICAgZGV2aWNlczoge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKCB1cGRhdGUgKSB7XG4gICAgICAgIHZhciBjYWxsZXIgPSB0aGlzLl9wYXJlbnQuX2NhbGxlclxuICAgICAgICBjYWxsZXIub24ucmVjZWl2ZXIuX3VwZGF0ZSgpXG4gICAgICAgIGNhbGxlci5kYXRhID0gdGhpcy5mcm9tXG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICByZWNlaXZlcjoge1xuICAgICAgZGVmZXI6IGZ1bmN0aW9uKCB1cGRhdGUgKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXNcbiAgICAgICAgLy8gVE9ETzogZ2V0IHJpZCBvZiB0aGlzIHJhZlxuICAgICAgICByYWYoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmICggX3RoaXMuX3BhcmVudCApIHtcbiAgICAgICAgICAgIHZhciBjYWxsZXIgPSBfdGhpcy5fcGFyZW50Ll9jYWxsZXJcbiAgICAgICAgICAgIHZhciByZWNlaXZlciA9ICBfdGhpcy5mcm9tXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGVsZW0gPSBjYWxsZXIubGlzdC5maW5kKCAnX2QuZnJvbScsIHJlY2VpdmVyLmZyb20gKVxuICAgICAgICAgICAgaWYgKCBlbGVtICkge1xuICAgICAgICAgICAgICBpZiAoIF90aGlzLmZvY3VzICYmIF90aGlzLmZvY3VzLl9ub2RlICkge1xuICAgICAgICAgICAgICAgIF90aGlzLmZvY3VzLmNzcyA9IHtcbiAgICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzOiAnZm9jdXNlZCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX3RoaXMuZm9jdXMgPSBlbGVtXG4gICAgICAgICAgICAgIGVsZW0uY3NzID0ge1xuICAgICAgICAgICAgICAgIGFkZENsYXNzOiAnZm9jdXNlZCdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggX3RoaXMuZm9jdXMgKSB7XG4gICAgICAgICAgICAgIGlmICggX3RoaXMuZm9jdXMgJiYgX3RoaXMuZm9jdXMuX25vZGUgKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZm9jdXMuY3NzID0ge1xuICAgICAgICAgICAgICAgICAgcmVtb3ZlQ2xhc3M6ICdmb2N1c2VkJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5mb2N1cyA9IG51bGxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9IClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gKS5DbGFzc1xuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vc2hhcmVkL2ljb24nKVxuXG52YXIgUG9wdXAgPSByZXF1aXJlKCcuLi8uLi9zaGFyZWQvcG9wdXAnKVxuXG52YXIgQWN0b3JcbnZhciBWb2x1bWVcbnZhciBEZXZpY2VzXG52YXIgUmVtb3RlXG5cbi8vYmFzaXMgb2YgcG9wdXAgaXMgc2hhcmVkIChhbHNvIHVzZWQgZm9yIHJlbW90ZT8gb3IgaXMgcmVtb3RlIGEgcG9wdXAgdGhpbmc/KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgUG9wdXAoe1xuICBwb3B1cDp7XG4gICAgLy8gbWlzYzpmdW5jdGlvbih1cGRhdGUpIHtcbiAgICAvLyAgdmFyIHZhbCA9IHRoaXMudmFsXG4gICAgLy8gIC8vZGl0IGlzIGdlZGVlbGQgLS0gem91IG9vayB2YW51aXQgYXBwIGt1bm5lbiBldmVudHVlZWxcbiAgICAvLyB9LFxuICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSxhcmdzKSB7XG5cbiAgICAgIHRoaXMuY2xlYXJDYWNoZSgpXG4gICAgICBcbiAgICAgIHZhciB2YWwgPSB0aGlzLnZhbFxuICAgICAgdmFyIGVsZW1lbnRcbiAgICAgIHZhciBzd2l0Y2hlciA9IHRoaXMuX2NhbGxlciAmJiB0aGlzLl9jYWxsZXIuc3dpdGNoZXJcbiAgICAgIHZhciBwYXJhbXMgPSB7fVxuICAgICAgdmFyIHRvcGJhclBhcmFtc1xuXG4gICAgICBpZighc3dpdGNoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cblxuICAgICAgaWYodmFsID09PSBmYWxzZSkge1xuICAgICAgICAvLyBjb25zb2xlLmVycm9yKCd3dGYgaXMgaGFwcGVuaW4/Pz8/JylcbiAgICAgICAgdGhpcy5fY2FsbGVyLnkgPSBhcHAuaC52YWxcbiAgICAgIH0gZWxzZSBpZih0aGlzLmZyb20uX2NvbnRlbnRUeXBlID09PSAnYWN0b3JzJykgeyAvL2xpc3RlbiB0byBtaXNjIGRpZmZlcmVudCFcbiAgICAgICAgLy93b3JkIGlmIHRoaXMuX2NvbnRlbnRUeXBlID09PSAnYWN0b3InIC8vIGRvZSBkaXQgLS0gcG9wdXAudmFsIHdvcmQgb3AgZ2VsaXN0ZW5kIGluIGFwcFxuICAgICAgICBlbGVtZW50ID0gQWN0b3IgPSBBY3RvciB8fCByZXF1aXJlKCcuL2FjdG9yJylcbiAgICAgICAgcGFyYW1zID0geyBcbiAgICAgICAgICAvLyBjYXJvdXNlbDp7XG4gICAgICAgICAgLy8gICBjb250YWluZXI6e1xuICAgICAgICAgIC8vICAgICAkZm9jdXM6IHRoaXMuZnJvbS5nZXQoJ2ZvY3VzJywyKVxuICAgICAgICAgIC8vICAgfSxcbiAgICAgICAgICAvLyAgIGRvdHM6e1xuICAgICAgICAgIC8vICAgICBjb250YWluZXI6e1xuICAgICAgICAgIC8vICAgICAgICRmb2N1czogdGhpcy5mcm9tLmdldCgnZm9jdXMnLDIpXG4gICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAvLyB9LFxuICAgICAgICAgIGRhdGE6IHRoaXMuZnJvbVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYodmFsID09PSAndm9sdW1lJykgeyAvL2xpc3RlbiB0byBtaXNjIGRpZmZlcmVudCFcbiAgICAgICAgZWxlbWVudCA9IFZvbHVtZSA9IFZvbHVtZSB8fCByZXF1aXJlKCcuL3ZvbHVtZScpXG4gICAgICB9IGVsc2UgaWYodmFsID09PSAnZGV2aWNlcycpIHsgLy9saXN0ZW4gdG8gbWlzYyBkaWZmZXJlbnQhXG4gICAgICAgIC8vIHRvcGJhci5taWRkbGUudGV4dC52YWwgPSBhcHAuZGV2aWNlTWVzc2FnZVxuICAgICAgICBlbGVtZW50ID0gRGV2aWNlcyA9IERldmljZXMgfHwgcmVxdWlyZSgnLi9kZXZpY2VzJylcblxuICAgICAgICB2YXIgdXNlciA9IGFwcC51c2VyXG5cbiAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICBkZXZpY2VzOiB1c2VyLmRldmljZXMsXG4gICAgICAgICAgICByZWNlaXZlcjogdXNlci5yZWNlaXZlckNsaWVudFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmKHZhbCA9PT0gJ3JlbW90ZScpIHsgLy9saXN0ZW4gdG8gbWlzYyBkaWZmZXJlbnQhXG4gICAgICAgIGVsZW1lbnQgPSBSZW1vdGUgPSBSZW1vdGUgfHwgcmVxdWlyZSgnLi9yZW1vdGUnKVxuICAgICAgICB0b3BiYXJQYXJhbXMgPSB7XG4gICAgICAgICAgLy8gbGVmdDp7XG4gICAgICAgICAgLy8gICBpY29uOiduYXZEb3duJ1xuICAgICAgICAgIC8vIH0sXG4gICAgICAgICAgbWlkZGxlOntcbiAgICAgICAgICAgIHRleHQ6e2RhdGE6J3RpdGxlJ30sXG4gICAgICAgICAgICBkYXRhOmFwcC51c2VyLnJlY2VpdmVyLm1lZGlhXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHJpZ2h0OntcbiAgICAgICAgICAvLyAgIGRpc3BsYXk6J25vbmUnXG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICB9IFxuXG4gICAgICBpZihlbGVtZW50KSB7XG4gICAgICAgIHN3aXRjaGVyLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAkcGFyYW1zOiBwYXJhbXNcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZih0b3BiYXJQYXJhbXMpe1xuICAgICAgICBzd2l0Y2hlci5wYXJlbnQudG9wYmFyLnNldCh0b3BiYXJQYXJhbXMpXG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSgpXG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG5cbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcblxuLy9tYXliZSBhZGQgc2Nyb2xsLCBvbmx5IHdoZW4gbGlzdCBpcyB0b28gbGFyZ2Vcbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuLy8geDp7dHJhbnNsYXRlOnRydWV9XG4vLyAsIHNjcm9sbGJhcjoneSdcbn0pLkNsYXNzIiwidmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgY29uZmlnID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvY29uZmlnJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vLi4vc2hhcmVkL2ljb24nKVxudmFyIExpc3QgPSByZXF1aXJlKCcuLi8uLi8uLi9zaGFyZWQvbGlzdCcpXG52YXIgb2Zmc2V0ID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL29mZnNldCcpXG5cbnZhciB0aHVtYiA9IG5ldyBMaXN0Lkl0ZW0uSW5mbyh7XG5cdGNzczonY2Fyb3VzZWwtaXRlbScsXG5cdHNjYWxlOntcblx0XHRwYXJlbnQ6J3gnLFxuXHRcdHRyYW5zZm9ybTpmdW5jdGlvbigpe1xuXHRcdFx0dmFyIHJlY3QgPSB0aGlzLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblx0XHRcdHZhciBsZWZ0ID0gcmVjdC5sZWZ0XG5cdFx0XHR2YXIgcmlnaHQgPSByZWN0LnJpZ2h0XG5cdFx0XHR2YXIgbWlkZGxlID0gYXBwLncudmFsLzJcblx0XHRcdHZhciB3aWR0aCA9IHJlY3Qud2lkdGhcblx0XHRcdHZhciB2YWwgPSBNYXRoLm1heCgxIC0gTWF0aC5hYnMoKGxlZnQgKyB3aWR0aC8yKSAtIG1pZGRsZSkvMTAwMCwwLjgpXG5cdFx0XHR0aGlzLmNzcyA9IGxlZnQgPD0gbWlkZGxlICYmIHJpZ2h0ID49IG1pZGRsZVxuXHRcdFx0XHQ/XHQnY2Fyb3VzZWwtaXRlbSBmcm9udCdcblx0XHRcdFx0OiAnY2Fyb3VzZWwtaXRlbSdcblx0XHRcdHJldHVybiB2YWxcblx0XHR9XG5cdH0sXG4gICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKCkge1xuICBcdGFwcC5wb3B1cC4kdXNlck9yaWdpbiA9IGZhbHNlXG4gICAgYXBwLnVzZXIubmF2aWdhdGlvbi5jb250ZW50LiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhLmZyb21cbiAgfVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuXHR3OmFwcC53LFxuXHRoOjI0MCxcblx0ZXh0ZW5kOiB7XG5cdFx0bWVkaWE6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0Ly9sb29rIGZvciBmb2N1c1xuXHRcdFx0Ly9kb2UgZGF0IHBhcyBvbiBpcyBsb2FkZWRcblx0XHRcdC8vIGlmKHZhbC5mcm9tLl9jb250ZW50VHlwZT09PSdjaGFubmVscycpIHtcblxuXHRcdFx0dmFyIF90aGlzID0gdGhpc1xuXHRcdFx0dmFyIHNsaWRlciA9IHRoaXMuc2xpZGVyXG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBzbGlkZXIuY2hpbGRyZW5cblxuXHRcdFx0Zm9yKHZhciBpIGluIGNoaWxkcmVuKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldXG5cdFx0XHRcdGlmKGNoaWxkLmRhdGEgPT09IHZhbC5mcm9tICYmIHRoaXMuZm9jdXNlZCAhPT0gY2hpbGQpIHtcblx0XHRcdFx0XHRpZighc2xpZGVyLl9jaGVjayAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKXtcblx0XHRcdFx0XHRcdHNsaWRlci54Ll9wID0gdHJ1ZVxuXHRcdFx0XHRcdFx0c2xpZGVyLiRmb2N1cyA9IGlcblx0XHRcdFx0XHRcdHNsaWRlci54Ll9wID0gbnVsbFxuXHRcdFx0XHRcdFx0c2xpZGVyLl9jaGVjayA9IHRydWVcblx0XHRcdFx0XHR9ZWxzZXtcblx0XHRcdFx0XHRcdHNsaWRlci4kZm9jdXMgPSBpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKCF0aGlzLmxpc3RlbkZvY3VzKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmxpc3RlbkZvY3VzID0gdHJ1ZVxuXHRcdFx0XHRcdFx0c2xpZGVyLiRmb2N1cy5vbihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZvY3VzID0gc2xpZGVyLmNoaWxkcmVuW3RoaXMudmFsXS5kYXRhXG5cdFx0XHRcdFx0XHRcdGlmKHZhbC5mcm9tIT09Zm9jdXMgJiYgZm9jdXMpIHtcblx0XHRcdFx0XHRcdFx0XHQvL251IG1vZXQgZXIgZWVuIG9uY2UgbGlzdGVuZXIgb3AgdGltZVxuXHRcdFx0XHRcdFx0XHRcdGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLiR1c2VyT3JpZ2luID0gZm9jdXNcblx0XHRcdFx0XHRcdFx0XHRhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSBmb2N1c1xuXHRcdFx0XHRcdFx0XHRcdGZvY3VzLmdldCgndGltZScpLmlzKCdsb2FkZWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmKGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLmZyb209PT1mb2N1cykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzLnZhbCA9IE1hdGguYWJzKHRoaXMudmFsKVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyB9XG5cdFx0fVxuXHR9LFxuXHRzbGlkZXI6IG5ldyBMaXN0LkNhcm91c2VsKHtcblx0XHR4Ont2YWw6MjgwLTMwKzJ9LFxuXHRcdGNvbGxlY3Rpb246IHtcblx0XHRcdGRhdGE6dHJ1ZSxcblx0XHRcdGZpbHRlcjp0cnVlLFxuXHRcdFx0ZWxlbWVudDp0aHVtYlxuXHRcdH0sXG5cdFx0bW9kZWw6e1xuXHRcdFx0Y29tcGxldGU6ZnVuY3Rpb24oKXtcblx0XHRcdFx0aWYodGhpcy5jaGlsZHJlblsxXSAmJiB0aGlzLnBhcmVudC5tZWRpYSl7IC8vIGZvcmNlIGFuIHVwZGF0ZSB3aGVuIGNoaWxkcmVuIGFyZSByZWFkeVxuXHRcdFx0XHRcdHRoaXMueC5fcCA9IHRydWVcblx0XHRcdFx0XHR0aGlzLnBhcmVudC5tZWRpYS51cGRhdGUoKVxuXHRcdFx0XHRcdHRoaXMubW9kZWwgPSBmYWxzZVxuXHRcdFx0XHRcdHRoaXMueC5fcCA9IG51bGxcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSlcbn0pLkNsYXNzXG5cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBQYWdlID0gcmVxdWlyZSggJy4uL3BhZ2UuanMnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIFNlZWtiYXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zZWVrYmFyJylcblxudmFyIENhcm91c2VsID0gcmVxdWlyZSgnLi9jYXJvdXNlbCcpXG5cbnZhciBEZXNjcmlwdGlvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2Rlc2NyaXB0aW9uJylcblxudmFyIEd1aWRlID0gbmV3IEVsZW1lbnQoe1xuXHQnaGVhZGVyLnRleHQnOiAnVXAgTmV4dCcsXG5cdGl0ZW1zOiB7XG5cdFx0Y29sbGVjdGlvbjoge1xuXHRcdFx0ZGF0YTonZ3VpZGUnLFxuXHRcdFx0ZWxlbWVudDogbmV3IEVsZW1lbnQoe1xuXHRcdFx0XHRjc3M6J2JvZHknLFxuXHRcdFx0XHR0aXRsZTogeyB0ZXh0OiB7IGRhdGE6J3RpdGxlJyB9IH0sXG5cdFx0XHRcdHN1YnRpdGxlOiB7XG5cdFx0XHRcdFx0dGV4dDoge1xuXHRcdFx0XHRcdFx0ZGF0YTonc3RhcnQtdGltZScsXG5cdFx0XHRcdFx0XHRhZGQ6W1xuXHRcdFx0XHRcdFx0XHQnIC0gJyxcblx0XHRcdFx0XHRcdFx0eyBkYXRhOidlbmQtdGltZScgfVxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cdH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBQYWdlKHtcblx0Y3NzOidyZW1vdGUnLFxuXHQvLyB0ZXh0Ont2YWw6J3JlbW90ZWl0ISd9LFxuXHRjYXJvdXNlbDogbmV3IENhcm91c2VsKCksXG5cdGluZm86IHtcblxuXHR9LFxuXHRjb250cm9sczoge1xuXHRcdHRpdGxlOiB7IHRleHQ6eyBkYXRhOidndWlkZS4wLnRpdGxlJywgZGVmYXVsdDp7ZGF0YTondGl0bGUnfSB9fSxcblx0XHRzZWVrYmFyOiBuZXcgU2Vla2JhcigpLFxuXHRcdGJ1dHRvbnM6IHtcblx0XHRcdGxlZnQ6IG5ldyBJY29uKHtcblx0XHRcdFx0aWNvbjoncmV3aW5kJ1xuXHRcdFx0fSksXG5cdFx0XHRwbGF5OiBuZXcgSWNvbih7XG5cdFx0XHRcdGV4dGVuZDoge1xuXHRcdFx0XHRcdHBsYXlpbmc6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRcdFx0dGhpcy5pY29uID0gdmFsLnZhbCA9PT0gdHJ1ZSA/ICdwYXVzZScgOiAncGxheSdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGljb246J3BsYXknLFxuXHRcdFx0XHQnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLnBsYXlpbmcuJHVzZXJPcmlnaW4gPSAhdGhpcy5wbGF5aW5nLnZhbFxuXHRcdFx0XHR9XG5cdFx0XHR9KSxcblx0XHRcdHJpZ2h0OiBuZXcgSWNvbih7XG5cdFx0XHRcdGljb246J2Zhc3Rmb3J3YXJkJ1xuXHRcdFx0fSksXG5cdFx0XHR2b2x1bWU6IG5ldyBJY29uKHtcblx0XHRcdFx0aWNvbjondm9sdW1lJyxcblx0XHRcdFx0J2V2ZW50cy5jbGljayc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGFwcC5zZWNvbmRQb3B1cC52YWwgPSAndm9sdW1lJ1xuXHRcdFx0XHR9XG5cdFx0XHR9KVxuXHRcdH1cblx0fSxcblx0ZXh0ZW5kOiB7XG5cdFx0cmVjZWl2ZXJNZWRpYTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR2YXIgaW5mbyA9IHRoaXMuaW5mb1xuXHRcdFx0dmFyIGZyb20gPSB2YWwuZnJvbVxuXHRcdFx0dGhpcy5jb250cm9scy5kYXRhID0gdmFsLmZyb21cblx0XHRcdFxuXHRcdFx0Ly9idWcgZml4XG5cdFx0XHR2YXIgc2VlayA9IHRoaXMuY29udHJvbHMuc2Vla2Jhci5zZWVrXG5cdFx0XHRzZWVrLncudXBkYXRlKHNlZWspXG5cblx0XHRcdGlmKGZyb20uX2NvbnRlbnRUeXBlPT09J2NoYW5uZWxzJykge1xuXHRcdFx0XHRpZihpbmZvLmd1aWRlJiZpbmZvLmd1aWRlLmRhdGEgIT09IGZyb20pIHtcblx0XHRcdFx0XHRpbmZvLmVtcHR5KClcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighaW5mby5ndWlkZSkge1xuXHRcdFx0XHRcdGluZm8uZW1wdHkoKVxuXHRcdFx0XHRcdGluZm8uc2V0KHtcblx0XHRcdFx0XHRcdGd1aWRlOiBuZXcgR3VpZGUoe2RhdGE6ZnJvbX0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR0aGlzLmNhcm91c2VsLmRhdGEgPSBhcHAuY29udGVudC5nZXQoJ2NoYW5uZWxzJylcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmNhcm91c2VsLm1lZGlhID0gZnJvbVxuXG5cdFx0XHR9IGVsc2UgaWYoIGZyb20uX2NvbnRlbnRUeXBlICE9PSAncmVjZWl2ZXInKSB7XG5cdFx0XHRcdGlmKGluZm8uZGVzY3JpcHRpb24gJiYgaW5mby5kZXNjcmlwdGlvbi5kYXRhICE9PSBmcm9tKSB7XG5cdFx0XHRcdFx0aW5mby5lbXB0eSgpXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIWluZm8uZGVzY3JpcHRpb24pIHtcblx0XHRcdFx0XHRpbmZvLmVtcHR5KClcblx0XHRcdFx0XHRpbmZvLnNldCh7XG5cdFx0XHRcdFx0XHRkZXNjcmlwdGlvbjogbmV3IERlc2NyaXB0aW9uKHtkYXRhOmZyb219KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0aWYoZnJvbS5fY29udGVudFR5cGU9PT0nbW92aWVzJykge1xuXHRcdFx0XHRcdFx0dGhpcy5jYXJvdXNlbC5kYXRhID0gYXBwLmNvbnRlbnQuZ2V0KCdtb3ZpZXMnKVxuXHRcdFx0XHRcdFx0Ly9mb2N1cyBnYWF0IHdlaXJkIVxuXHRcdFx0XHRcdH0gZWxzZSBpZihmcm9tLl9jb250ZW50VHlwZSA9PT0gJ3NlcmllcycpIHtcblx0XHRcdFx0XHRcdC8vY29udGVudCB0eXBlIHdvcmQgZXBpc29kZSAtLS1cblx0XHRcdFx0XHRcdC8vaGFyZGVyIHRvIGRvXG5cdFx0XHRcdFx0XHR0aGlzLmNhcm91c2VsLmRhdGEgPSBhcHAuY29udGVudC5nZXQoJ3NlcmllcycpXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jYXJvdXNlbC5tZWRpYSA9IGZyb21cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdG9uOiB7XG5cdFx0JHBhcmVudDp7ZGVmZXI6ZnVuY3Rpb24odXBkYXRlKSB7XG5cdFx0XHR0aGlzLl9wYXJlbnQuX2NhbGxlci5wYXJlbnQucGFyZW50LnRvcGJhci5taWRkbGUudGV4dCA9ICdyZW1vdGUnXG5cdFx0XHR1cGRhdGUoKVxuXHRcdH19LFxuXHRcdCRuZXc6e2RlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuXHRcdFx0dGhpcy5fcGFyZW50Ll9jYWxsZXIucmVjZWl2ZXJNZWRpYSA9IGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhXG5cdFx0XHR0aGlzLl9wYXJlbnQuX2NhbGxlci5jb250cm9scy5idXR0b25zLnBsYXkucGxheWluZyA9IGFwcC51c2VyLnJlY2VpdmVyLnBsYXlpbmdcblx0XHRcdHVwZGF0ZSgpXG5cdFx0fX1cblx0fVxufSkuQ2xhc3NcblxuXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIFBhZ2UgPSByZXF1aXJlKCAnLi4vcGFnZS5qcycgKVxudmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi8uLi9zaGFyZWQvaWNvbicpXG52YXIgb2Zmc2V0ID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL29mZnNldCcpXG5cbnJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBQYWdlKHtcblx0dzphcHAudyxcblx0Y3NzOid2b2x1bWUnLFxuXHR0b3A6IHtcblx0XHR0aXRsZTogeyB0ZXh0OiAnMTAwJScgfSxcblx0XHR2b2x1bWU6IG5ldyBJY29uKHtcblx0XHRcdGljb246J3ZvbHVtZScsIFxuXHRcdFx0J2V2ZW50cy5jbGljayc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudC5wYXJlbnQudm9sdW1lLiR1c2VyT3JpZ2luID0gMVxuXHRcdFx0fVxuXHRcdH0pXG5cdH0sXG5cdGV4dGVuZDoge1xuXHRcdHZvbHVtZTpmdW5jdGlvbih2YWwpIHtcblx0XHRcdGlmKCF0aGlzLl92b2xzZXQgJiYgdmFsLmZyb20hPT12YWwpIHtcblx0XHRcdFx0dGhpcy5fdm9sc2V0ID0gdHJ1ZVxuXHRcdFx0XHR0aGlzLnNsaWRlci5ibG9jay55ID0gdmFsXG5cdFx0XHRcdHRoaXMuc2xpZGVyLmJsb2NrLm1pZGRsZS50ZXh0ID0gdmFsXG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRvbjoge1xuXHRcdCRuZXc6eyBcblx0XHRcdGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuXHRcdFx0XHR2YXIgY2FsbGVyID0gdGhpcy5fcGFyZW50Ll9jYWxsZXJcblx0XHRcdFx0aWYoIWNhbGxlci52b2x1bWUpIHtcblx0XHRcdFx0XHRjYWxsZXIudm9sdW1lID0gYXBwLnVzZXIucmVjZWl2ZXIudm9sdW1lXG5cdFx0XHRcdH1cblx0XHRcdFx0dXBkYXRlKClcblx0XHRcdH0gXG5cdFx0fSxcblx0XHQkcGFyZW50Ontcblx0XHRcdGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSkge1xuXHRcdFx0XHR0aGlzLl9wYXJlbnQuX2NhbGxlci5wYXJlbnQucGFyZW50LnRvcGJhci5taWRkbGUudGV4dC52YWwgPSAndm9sdW1lJ1xuXHRcdFx0XHR1cGRhdGUoKVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0c2xpZGVyOiB7XG5cdFx0dzogYXBwLncsXG5cdFx0aDp7dmFsOmFwcC5oLHN1YjozNTB9LFxuXHRcdHg6e21heDowLG1pbjowfSxcblx0XHRibG9jazoge1xuXHRcdFx0eTp7IFxuXHRcdFx0XHR0cmFuc2Zvcm06IGZ1bmN0aW9uKHYsY3YpIHtcblx0XHRcdFx0XHRjdiA9IGN2Pi0xID8gY3YgOiAxXG5cdFx0XHRcdFx0cmV0dXJuICh0aGlzLnBhcmVudCAmJiAodGhpcy5wYXJlbnQuaC52YWwtMzApLTYwKSooIDEtY3YgKSszMFxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZXZlbnRzOiB7XG5cdFx0XHRcdGRyYWc6ZnVuY3Rpb24oZSkge1xuXG5cdFx0XHRcdFx0aWYoICF0aGlzLl9vZmZzZXQgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQueSh0aGlzLnBhcmVudClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly9kcmFnc3RhcnRcblx0XHRcdFx0XHRpZighdGhpcy5fZHJhZ2luZm9zKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9kcmFnaW5mb3MgPSBlLnktb2Zmc2V0LnkodGhpcykrdGhpcy5fb2Zmc2V0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgY2FsYyA9IDEgLSAoIGUueSAtIHRoaXMuX2RyYWdpbmZvcyApIC8gKHRoaXMucGFyZW50LmgudmFsLTMwKVxuXHRcdFx0XHRcdGlmKGNhbGM+MSkgY2FsYyA9IDFcblx0XHRcdFx0XHRpZihjYWxjPDApIGNhbGMgPSAwXG5cdFx0XHRcdFx0dGhpcy5wYXJlbnQucGFyZW50LnZvbHVtZS4kdXNlck9yaWdpbiA9IGNhbGNcblx0XHRcdFx0fSxcblx0XHRcdFx0dXA6ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5fZHJhZ2luZm9zID0gZmFsc2Vcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGxlZnQ6IG5ldyBJY29uKHtcblx0XHRcdFx0aWNvbjogJ21lbnUnXG5cdFx0XHR9KSxcblx0XHRcdG1pZGRsZToge1xuXHRcdFx0XHR0ZXh0OiB7IFxuXHRcdFx0XHRcdHRyYW5zZm9ybTogZnVuY3Rpb24oYywgY3YpIHtcblx0XHRcdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKGN2KjEwMCkrJyUnXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmlnaHQ6IG5ldyBJY29uKHtcblx0XHRcdFx0aWNvbjogJ21lbnVSaWdodCdcblx0XHRcdH0pLFxuXHRcdFx0Ly8gdzp7dmFsOmFwcC53LHN1YjozMH0sXG5cdFx0XHRoOjYwXG5cdFx0fVxuXHR9LFxuXHRtdXRlOiB7XG5cdFx0bXV0ZWQ6IG5ldyBJY29uKHtpY29uOidtdXRlZCd9KSxcblx0XHQnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMucGFyZW50LnZvbHVtZS4kdXNlck9yaWdpbiA9IDBcblx0XHR9XG5cdH1cbn0pLkNsYXNzXG5cblxuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIGFwcCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwJyApXG52YXIgY29uZmlnID0gcmVxdWlyZSgndmlnb3VyLWpzL3V0aWwvY29uZmlnJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vc2hhcmVkL2ljb24nKVxudmFyIFN1YnRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3VidGl0bGUnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG5cdGNzczonbWluaS1yZW1vdGUnLFxuXHR5Ont2YWw6MCxhbmltYXRpb246eyB0aW1lOjEwLCBlYXNpbmc6J291dEN1YmljJ319LFxuXHRleHRlbmQ6IHtcblx0XHRwbGF5aW5nOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHRoaXMucmlnaHQuaWNvbiA9IHZhbC52YWwgPT09IHRydWUgPyAncGF1c2UnIDogJ3BsYXknXG5cdFx0fSxcblx0XHRtZWRpYTogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHZhbC5mcm9tLl9jb250ZW50VHlwZVxuXHRcdFx0aWYoIHR5cGUgPT09ICdtb3ZpZXMnIHx8IHR5cGUgPT09ICdjaGFubmVscycgfHwgdHlwZSA9PT0gJ3NlcmllcycgfHwgdHlwZSA9PT0gJ2VwaXNvZGVzJyApIHtcblx0XHRcdFx0dmFyIF90aGlzID0gdGhpc1xuXHRcdFx0XHQvLyBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBcdF90aGlzLnBhcmVudC5zd2l0Y2hlci5oID0geyBhZGQ6LTUwIH1cblx0XHRcdFx0Ly8gfSw1MDApXG5cblx0XHRcdFx0dGhpcy55ID0gMFxuXHRcdFx0XHRpZih0aGlzLmRhdGEhPT12YWwuZnJvbSkge1xuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IHZhbC5mcm9tXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHRoaXMucGFyZW50LnN3aXRjaGVyLmggPSB7IGFkZDowIH1cblx0XHRcdFx0dGhpcy55ID0gNTBcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdGxlZnQ6IHtcblx0XHRiYWNrZ3JvdW5kOiB7XG5cdFx0XHR2YWw6Y29uZmlnLnBvaW50ZXJzLmltZyxcblx0XHRcdGFkZDogeyBkYXRhOiAnaW1nLnRodW1iJyB9XG5cdFx0fVxuXHR9LFxuXHRtaWRkbGU6IHtcblx0XHR0aXRsZToge1xuXHRcdFx0dGV4dDp7ZGF0YTondGl0bGUnfVxuXHRcdH0sXG5cdFx0aW5mbzpuZXcgU3VidGl0bGUoKVxuXHR9LFxuXHRyaWdodDogbmV3IEljb24oe1xuXHRcdGljb246J3BsYXknLFxuXHRcdCdldmVudHMuY2xpY2snOmZ1bmN0aW9uKGUpIHtcblx0XHRcdGUucHJldmVudCA9IHRydWVcblx0XHRcdHRoaXMucGFyZW50LnBsYXlpbmcuJHVzZXJPcmlnaW4gPSAhdGhpcy5wYXJlbnQucGxheWluZy52YWxcblx0XHR9XG5cdFx0Ly9oaWVyIGZmIGRpZSBsaXN0ZW5pbmdcblx0fSksXG5cdCdldmVudHMuY2xpY2snOiBmdW5jdGlvbihlKSB7XG5cdFx0YXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gJ3JlbW90ZSdcblx0fVxufSkuQ2xhc3NcblxuXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbi8vIHZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKVxudmFyIHBvc3Rwb25lID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxudmFyIHRpbWVzdGFtcCA9IHJlcXVpcmUoJ21vbm90b25pYy10aW1lc3RhbXAnKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgVG9wYmFyID0gcmVxdWlyZSgnLi4vdG9wYmFyJylcbnZhciBzZWFyY2ggPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zZWFyY2gnKVxuXG4vL1RPRE86IHVzZSBkYXRhIGJvdW5kIHRvIGRpc3BsYXkgaW5zdGVhZCBvZiB0aGUgYmlnIGlmIHN0YXRlbWVudFxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczonZmlyc3Qtc2VhcmNoJyxcbiAgZXh0ZW5kOiB7XG4gICAgc2VhcmNoOiBmdW5jdGlvbigpe31cbiAgfSxcbiAgZGVmaW5lOiB7XG4gICAgYWRkUmVjZW50U2VhcmNoOiBwb3N0cG9uZShmdW5jdGlvbihzcmNoKSB7XG4gICAgICBpZighdGhpcy5ub2RlKSByZXR1cm5cbiAgICAgIGlmKCF0aGlzLnBhZ2UgfHwgIXRoaXMucGFnZS5yZWNlbnQuZGF0YSkgcmV0dXJuXG4gICAgICB2YXIga2V5cyA9IHRoaXMucGFnZS5yZWNlbnQuaG9sZGVyLmRhdGEua2V5c1xuICAgICAgdmFyIHJlY2VudHMgPSB0aGlzLnBhZ2UucmVjZW50LmhvbGRlci5kYXRhLiR1c2VyT3JpZ2luXG4gICAgICBpZihrZXlzLmxlbmd0aD41KSB7XG4gICAgICAgIHJlY2VudHNba2V5c1swXV0ucmVtb3ZlKClcbiAgICAgIH1cbiAgICAgIHZhciBmb3VuZFxuICAgICAgaWYocmVjZW50cykge1xuICAgICAgICByZWNlbnRzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYodGhpcy50aXRsZS52YWwgPT09IHNyY2gpIHtcbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBpZighZm91bmQpIHtcbiAgICAgICAgcmVjZW50cy5zZXQodGltZXN0YW1wKCkse3RpdGxlOnNyY2h9KVxuICAgICAgfVxuICAgIH0sMTAwMClcbiAgfSxcbiAgLy8gdG9wYmFyOiB7XG4gIC8vICAgbGVmdDogbmV3IEljb24oe1xuICAvLyAgICAgaWNvbjonbWVudScsXG4gIC8vICAgICBldmVudHM6IHtcbiAgLy8gICAgICAgZG93bjpmdW5jdGlvbihlKSB7XG4gIC8vICAgICAgICAgZS5wcmV2ZW50ID0gdHJ1ZVxuICAvLyAgICAgICAgIGFwcC5tZW51LnZhbCA9ICFhcHAubWVudS52YWxcbiAgLy8gICAgICAgfVxuICAvLyAgICAgfVxuICAvLyAgIH0pLFxuICAvLyAgIGZpZWxkOiBuZXcgSW5wdXQoe1xuICAvLyAgICAgZXZlbnRzOiB7XG4gIC8vICAgICAgIGZvY3Vzb3V0OiBmdW5jdGlvbihlKSB7XG4gIC8vICAgICAgICAgdmFyIG92ZXJsYXkgPSB0aGlzLnBhcmVudC5wYXJlbnQub3ZlcmxheVxuICAvLyAgICAgICAgIG92ZXJsYXkuZGlzcGxheSA9ICdub25lJ1xuICAvLyAgICAgICB9LFxuICAvLyAgICAgICBmb2N1czpmdW5jdGlvbihlKSB7XG4gIC8vICAgICAgICAgdGhpcy5wYXJlbnQucGFyZW50Lm92ZXJsYXkuc2V0KHtcbiAgLy8gICAgICAgICAgIGRpc3BsYXk6J2Jsb2NrJ1xuICAvLyAgICAgICAgIH0pXG4gIC8vICAgICAgIH1cbiAgLy8gICAgIH1cbiAgLy8gICB9KVxuICAvLyB9LFxuICBwYWdlOm5ldyBzZWFyY2guUmVzdWx0TGlzdCh7XG4gICAgc2Nyb2xsYmFyOid5JyxcbiAgICBhcHBlbmQ6e1xuICAgICAgdmFsOltcbiAgICAgICAgbmV3IEVsZW1lbnQoe1xuICAgICAgICAgIG5hbWU6J25vUmVzdWx0cycsXG4gICAgICAgICAgZGlzcGxheTonbm9uZScsXG4gICAgICAgICAgaWNvbjogbmV3IEljb24oe2ljb246J3dyb25nJ30pLFxuICAgICAgICAgICd0aXRsZS50ZXh0JzonTm8gcmVzdWx0cyEnLFxuICAgICAgICAgICdib2R5LnRleHQnOidQbGVhc2UgdHJ5IHRvIHJlZmluZSB5b3VyIHF1ZXJ5J1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IHNlYXJjaC5Ub3BSZXN1bHQoe1xuICAgICAgICAgIG5hbWU6J3RvcHJlc3VsdCdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBFbGVtZW50KHtcbiAgICAgICAgICBuYW1lOidyZWNlbnQnLFxuICAgICAgICAgIG1vZGVsOiB7XG4gICAgICAgICAgICBpbmhlcml0OmZhbHNlLFxuICAgICAgICAgICAgY29tcGxldGU6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIGlmKHRoaXMuZGF0YS5rZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9SZWNlbnQuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICAgIHRoaXMuaG9sZGVyLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub1JlY2VudC5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgICAgIHRoaXMuaG9sZGVyLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbm9SZWNlbnQ6e1xuICAgICAgICAgICAgaWNvbjogbmV3IEljb24oe2ljb246J3NlYXJjaE1lbnUnfSksXG4gICAgICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgICB0ZXh0OidTdGFydCBTZWFyY2hpbmchJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgICAgdGV4dDonRmluZCB5b3VyIGZhdm9yaXRlIG1vdmllcywgc2hvd3MgYW5kIGNoYW5uZWxzLidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGhvbGRlcjogbmV3IHNlYXJjaC5SZXN1bHRzKHtcbiAgICAgICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICAgIHRleHQ6J3JlY2VudCBzZWFyY2hlcydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb2xsZWN0aW9uOiB7XG4gICAgICAgICAgICAgIGRhdGE6dHJ1ZSxcbiAgICAgICAgICAgICAgZWxlbWVudDogbmV3IHNlYXJjaC5SZXN1bHQoe1xuICAgICAgICAgICAgICAgICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQYXJlbnQoJ3NlYXJjaCcsdHJ1ZSkuJHVzZXJPcmlnaW4gPSB0aGlzLmRhdGEudGl0bGUudmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZmlsdGVyOiB7XG4gICAgICAgICAgICAgICAgc29ydDp7IGZpZWxkOidfbmFtZScsIG9yZGVyOid6LWEnfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgIF0sXG4gICAgICBiZWZvcmU6J21vdmllcydcbiAgICB9XG4gIH0pLFxuICBvdmVybGF5OiB7XG4gICAgZGlzcGxheTonbm9uZSdcbiAgfSxcbiAgc2VhcmNoOntcbiAgICBkZWZlcjpmdW5jdGlvbih1cGRhdGUsIGFyZ3MpIHtcblxuICAgICAgaWYoIXRoaXMuZnJvbS5jbG91ZCkgcmV0dXJuIHRydWVcblxuICAgICAgdmFyIGNhbGxlciA9IHRoaXMuX2NhbGxlclxuICAgICAgdmFyIGVsZW0kXG5cbiAgICAgIHZhciBsaXN0ID0gW1xuICAgICAgICAgIGNhbGxlci5wYWdlLm1vdmllcyxcbiAgICAgICAgICBjYWxsZXIucGFnZS5zZXJpZXMsXG4gICAgICAgICAgY2FsbGVyLnBhZ2UuY2hhbm5lbHMsXG4gICAgICAgICAgY2FsbGVyLnBhZ2UuYWN0b3JzXG4gICAgICAgIF1cblxuICAgICAgLy8gaWYoIWNhbGxlci50b3BiYXIuZmllbGQuZGF0YSkge1xuICAgICAgLy8gICBjYWxsZXIudG9wYmFyLmZpZWxkLmRhdGEgPSB0aGlzLl92YWxcbiAgICAgIC8vIH1cbiAgICAgIFxuICAgICAgdGhpcy5jbGVhckNhY2hlKClcblxuICAgICAgaWYodGhpcy52YWwpIHtcbiAgICAgICAgdmFyIHNyY2ggPSBzZWFyY2gucGFyc2VTZWFyY2goIHRoaXMudmFsIClcbiAgICAgICAgaWYoIHNyY2ghPT1mYWxzZSApIHtcbiAgICAgICAgICBjYWxsZXIuYWRkUmVjZW50U2VhcmNoKHNyY2gpXG4gICAgICAgICAgZm9yKHZhciBpIGluIGxpc3QpIHtcbiAgICAgICAgICAgIHNlYXJjaC5maWx0ZXJDb2xsZWN0aW9uKCBsaXN0W2ldLCBzcmNoIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYWxsZXIucGFnZS5yZWNlbnQuZGlzcGxheSA9ICdub25lJ1xuXG4gICAgICAgICAgY2FsbGVyLmRhdGEuZ2V0KCdtb3ZpZXMnKS5pcyhmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmtleXMgJiYgdGhpcy5rZXlzLmxlbmd0aD4yIFxuICAgICAgICAgICAgICAgICYmIHRoaXMuZnJvbVswXSAmJiB0aGlzLmZyb21bMF0uYWN0b3JzXG4gICAgICAgICAgfSwgdHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmKGNhbGxlci5fbm9kZSkge1xuICAgICAgICAgICAgICBmb3IoZWxlbSQgaW4gbGlzdCkge1xuICAgICAgICAgICAgICAgIGxpc3RbZWxlbSRdLmRpc3BsYXkgPSBsaXN0W2VsZW0kXS5maWx0ZXIubGVuZ3RoID4gMCBcbiAgICAgICAgICAgICAgICAgID8gJ2Jsb2NrJyBcbiAgICAgICAgICAgICAgICAgIDogJ25vbmUnICBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHNlYXJjaC50b3BSZXN1bHQoIGxpc3QgKSBcbiAgICAgICAgICAgICAgY2FsbGVyLnBhZ2UudG9wcmVzdWx0LmRhdGEgPSByZXN1bHQgfHwgZmFsc2VcbiAgICAgICAgICAgICAgY2FsbGVyLnBhZ2UudG9wcmVzdWx0LmRpc3BsYXkgPSByZXN1bHQgPyAnYmxvY2snIDogJ25vbmUnXG4gICAgICAgICAgICAgIGNhbGxlci5wYWdlLm5vUmVzdWx0cy5kaXNwbGF5ID0gcmVzdWx0ID8gJ25vbmUnIDogJ2Jsb2NrJ1xuICAgICAgICAgICAgICAvL2lmIG5vIHJlc3VsdCB0aGVuIC0tLS1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvcihlbGVtJCBpbiBsaXN0KSB7XG4gICAgICAgICAgICBsaXN0W2VsZW0kXS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhbGxlci5wYWdlLnRvcHJlc3VsdC5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgY2FsbGVyLnBhZ2Uubm9SZXN1bHRzLmRpc3BsYXkgPSAnbm9uZScgXG4gICAgICAgICAgY2FsbGVyLnBhZ2UucmVjZW50LmRpc3BsYXkgPSAnYmxvY2snICBcbiAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yKGVsZW0kIGluIGxpc3QpIHtcbiAgICAgICAgICBsaXN0W2VsZW0kXS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgIH1cbiAgICAgICAgY2FsbGVyLnBhZ2UudG9wcmVzdWx0LmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgY2FsbGVyLnBhZ2Uubm9SZXN1bHRzLmRpc3BsYXkgPSAnbm9uZScgXG4gICAgICAgIGNhbGxlci5wYWdlLnJlY2VudC5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgfVxuICAgICAgdXBkYXRlKClcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE1LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG5cbnJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxudmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi9zaGFyZWQvaWNvbicpXG52YXIgTWVudSA9IHJlcXVpcmUoJy4uL21lbnUnKVxudmFyIERpc2NvdmVyXG52YXIgU2VhcmNoXG52YXIgQ2hhbm5lbFxudmFyIEVwaXNvZGVcbnZhciBNb3ZpZVxudmFyIGNhc2VzID0gYXBwLmNhc2VzXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBTd2l0Y2hlcih7XG4gIGNzczogJ2ZpcnN0LXN3aXRjaGVyJyxcbiAgJ2V4dGVuZC5uYXZpZ2F0aW9uJzogZnVuY3Rpb24oKSB7fSxcbiAgb25UcmFuc2l0aW9uOiAnc2xpZGUnLFxuICBsb2FkZXI6IG5ldyBFbGVtZW50KHtcbiAgICBjc3M6ICdmaXJzdC1sb2FkZXInLFxuICAgIHg6IHtcbiAgICAgIHRyYW5zbGF0ZTogdHJ1ZVxuICAgIH0sXG4gICAgbG9hZGljb246IG5ldyBJY29uKHtcbiAgICAgIGljb246ICdlcnJvcidcbiAgICB9KVxuICB9KSxcbiAgbmF2aWdhdGlvbjoge1xuICAgIGRlZmVyOiBmdW5jdGlvbih1cGRhdGUsIGFyZ3MpIHtcbiAgICAgIHZhciBuYXYgPSB0aGlzLmZyb21cblxuICAgICAgaWYgKCFuYXYgfHwgIW5hdi5sYXN0IHx8ICFuYXYubGFzdC5mcm9tLmtleSkgcmV0dXJuIHRydWVcblxuICAgICAgdmFyIGZpZWxkID0gbmF2Lmxhc3QuZnJvbS5rZXkudmFsXG4gICAgICB2YXIgcGFnZVxuICAgICAgdmFyIGVsZW1lbnRcbiAgICAgIHZhciBzd2l0Y2hlciA9IHRoaXMuX2NhbGxlclxuICAgICAgdmFyIHBhcmFtc1xuICAgICAgdmFyIG9wdGlvbnNcbiAgICAgIG5hdiA9IG5hdltmaWVsZF1cblxuICAgICAgaWYgKGZpZWxkID09PSAncGFnZScpIHtcblxuICAgICAgICB2YXIgcGFnZSA9IG5hdi52YWxcblxuICAgICAgICBpZiAocGFnZSA9PT0gJ2Rpc2NvdmVyJykge1xuICAgICAgICAgIGVsZW1lbnQgPSBEaXNjb3ZlciA9IERpc2NvdmVyIHx8IHJlcXVpcmUoJy4uL2Rpc2NvdmVyJylcbiAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAkZm9jdXM6IGFwcC51c2VyLmZvY3VzX3JvdyxcbiAgICAgICAgICAgIGRhdGE6IGFwcC5jb250ZW50LmdldCgnZGlzY292ZXInKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChwYWdlID09PSAnc2VhcmNoJykge1xuICAgICAgICAgIGVsZW1lbnQgPSBTZWFyY2ggPSBTZWFyY2ggfHwgcmVxdWlyZSgnLi4vc2VhcmNoJylcbiAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBhcHAuY2xvdWQuZGF0YSxcbiAgICAgICAgICAgIHNlYXJjaDogYXBwLnVzZXIuc2VhcmNoLFxuICAgICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgICByZWNlbnQ6IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBhcHAudXNlci5yZWNlbnRTZWFyY2hlcy5mcm9tXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIGlmIChmaWVsZCA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgIGlmICghc3dpdGNoZXIuX3N3RWxlbSB8fCBzd2l0Y2hlci5fc3dFbGVtLmRhdGEgIT09IG5hdi5mcm9tKSB7XG5cbiAgICAgICAgICB2YXIgdHlwZSA9IG5hdi5fY29udGVudFR5cGVcblxuICAgICAgICAgIGlmICh0eXBlID09PSAnbW92aWVzJykge1xuICAgICAgICAgICAgZWxlbWVudCA9IE1vdmllID0gTW92aWUgfHwgcmVxdWlyZSgnLi4vbW92aWUnKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2VwaXNvZGVzJykge1xuICAgICAgICAgICAgZWxlbWVudCA9IEVwaXNvZGUgPSBFcGlzb2RlIHx8IHJlcXVpcmUoJy4uL2VwaXNvZGUnKVxuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NoYW5uZWxzJykge1xuICAgICAgICAgICAgZWxlbWVudCA9IENoYW5uZWwgPSBDaGFubmVsIHx8IHJlcXVpcmUoJy4uL2NoYW5uZWwnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICBkYXRhOiBuYXYuZnJvbSxcbiAgICAgICAgICAgIGhvbGRlcjoge1xuICAgICAgICAgICAgICBwbGF5ZXI6IHtcbiAgICAgICAgICAgICAgICBwbGF5aW5nOiBhcHAuaXNQbGF5aW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVyOiBhcHAudXNlci5yZWNlaXZlclxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZWNlaXZlck1lZGlhOiBhcHAudXNlci5yZWNlaXZlci5tZWRpYVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHN3aXRjaGVyLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgZWxlbWVudDogZWxlbWVudCxcbiAgICAgICAgICAkcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgZGlyZWN0aW9uOiBhcHAubWVudS52YWwgPyAwIDogZmllbGQgPT09ICdjb250ZW50JyA/IDEgOiAtMSxcbiAgICAgICAgICAkb3B0aW9uczogb3B0aW9uc1xuICAgICAgICB9XG5cbiAgICAgIH1cblxuICAgICAgdXBkYXRlKClcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgYXBwID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAnIClcbnZhciB1c2VyID0gYXBwLnVzZXJcbnZhciBJY29uID0gcmVxdWlyZSgnLi4vLi4vc2hhcmVkL2ljb24nKVxudmFyIFRpdGxlID0gcmVxdWlyZSgnLi4vLi4vc2hhcmVkL3RpdGxlJylcbnZhciBJbnB1dCA9IHJlcXVpcmUoJy4vaW5wdXQnKVxuXG52YXIgc2VhcmNoRmllbGQgPSBuZXcgSW5wdXQoe1xuICBldmVudHM6IHtcbiAgICBmb2N1c291dDogZnVuY3Rpb24oZSkge1xuICAgICAgLy8gdmFyIG92ZXJsYXkgPSB0aGlzLnBhcmVudC5wYXJlbnQub3ZlcmxheVxuICAgICAgLy8gb3ZlcmxheS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgfSxcbiAgICBmb2N1czpmdW5jdGlvbihlKSB7XG4gICAgICAvLyB0aGlzLnBhcmVudC5wYXJlbnQub3ZlcmxheS5zZXQoe1xuICAgICAgLy8gICBkaXNwbGF5OidibG9jaydcbiAgICAgIC8vIH0pXG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG5cdGNzczondG9wYmFyJyxcblx0ZXh0ZW5kOntcblx0XHQkY3VycmVudDpmdW5jdGlvbih2YWwpe1xuXHRcdFx0dmFyIGN1cnJlbnQgPSB2YWwudmFsXG5cdFx0XHRpZihjdXJyZW50ID09PSAnc2VhcmNoJyl7XG5cdFx0XHRcdGlmKCF0aGlzLnNlYXJjaCl7XG5cdFx0XHRcdFx0dGhpcy5zZXQoe1xuXHRcdFx0XHRcdFx0Y3NzOid0b3BiYXIgc2VhcmNoaW5nJyxcblx0XHRcdFx0XHRcdGFkZDpbXG5cdFx0XHRcdFx0XHRcdG5ldyBzZWFyY2hGaWVsZCh7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogJ3NlYXJjaCcsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YTphcHAudXNlci5zZWFyY2hcblx0XHRcdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0XHRcdCdtaWRkbGUnXG5cdFx0XHRcdFx0XHRdXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2UgaWYodGhpcy5zZWFyY2gpe1xuXHRcdFx0XHR0aGlzLnNlYXJjaC5yZW1vdmUoKVxuXHRcdFx0XHR0aGlzLmNzcyA9ICd0b3BiYXInXG5cdFx0XHR9XG5cblx0XHRcdGlmKCBjdXJyZW50ID09PSAnY29udGVudCcgKXtcblx0XHRcdFx0dGhpcy5taWRkbGUuZGF0YSA9IHVzZXIubmF2aWdhdGlvbi5jb250ZW50LmZyb21cblx0XHRcdH1lbHNlIGlmKCBjdXJyZW50ID09PSAnZGlzY292ZXInICl7XG5cdFx0XHRcdHRoaXMubWlkZGxlLmRhdGEgPSB7IHRpdGxlOmN1cnJlbnQgfVxuXHRcdFx0fVxuXG5cdFx0fVxuXHR9LFxuXHRsZWZ0OiBuZXcgSWNvbih7IFxuXHRcdGljb246e1xuXHRcdFx0dmFsOmFwcC5jdXJyZW50LFxuXHRcdFx0dHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3VycmVudCl7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50ID09PSAnY29udGVudCcgPyAnYmFjaycgOiAnbWVudSdcblx0XHRcdH1cblx0XHR9LFxuXHRcdGV2ZW50czoge1xuXHRcdFx0ZG93bjpmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGUucHJldmVudCA9IHRydWVcblx0XHRcdFx0aWYoIHRoaXMuaWNvbi52YWwgPT09ICdtZW51JyApe1xuXHRcdFx0XHRcdGFwcC5tZW51LnZhbCA9ICFhcHAubWVudS52YWxcblx0XHRcdFx0fWVsc2V7XG5cdFx0XHRcdFx0dXNlci5uYXZpZ2F0aW9uLnBhZ2UuJHVzZXJPcmlnaW4gPSBhcHAucHJldmlvdXMudmFsIHx8ICdkaXNjb3Zlcidcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gXG5cdH0pLFxuXHRtaWRkbGU6bmV3IFRpdGxlLlNob3coKSxcblx0cmlnaHQ6IG5ldyBJY29uKHtcblx0XHRpY29uOidjYXN0Jyxcblx0XHQnZXZlbnRzLmNsaWNrJzpmdW5jdGlvbigpIHtcblx0XHRcdGFwcC5wb3B1cC4kdXNlck9yaWdpbiA9ICdkZXZpY2VzJ1xuXHRcdH1cblx0fSlcbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5DbGFzc1xuXG4iLCJyZXF1aXJlKCcuL3Jlc2V0Lmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIGV2ZW50cyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2V2ZW50cycpXG52YXIgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC8nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgbm9kZTogJ2Zvcm0nLFxuICBuYW1lOiAnc2VhcmNoJyxcbiAgY3NzOiAnc2VhcmNoLWZpZWxkJyxcbiAgbW9kZWw6IHtcbiAgICBpbmhlcml0OiBmYWxzZSxcbiAgICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnRhYmxlLmNsZWFyLmRpc3BsYXkgPSB0aGlzLmRhdGEudmFsID8gJ3RhYmxlLWNlbGwnIDogJ25vbmUnXG4gICAgfVxuICB9LFxuICB0YWJsZToge1xuICAgIGxlZnRpY29uOiBuZXcgSWNvbih7XG4gICAgICBpY29uOiAnc2VhcmNoJ1xuICAgIH0pLFxuICAgIGlucHV0RmllbGQ6IHtcbiAgICAgIG5vZGU6ICdpbnB1dCcsXG4gICAgICBhdHRyOiB7XG4gICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgbmFtZTogJ3NlYXJjaCcsXG4gICAgICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoJ1xuICAgICAgfSxcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgZGF0YTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBrZXlkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIH0sXG4gICAgICAgIGtleXVwOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgaWYgKGUua2V5Q29kZSAhPT0gOSkge1xuICAgICAgICAgICAgdmFyIHNyY2ggPSB0aGlzLm5vZGUudmFsdWUubGVuZ3RoID8gdGhpcy5ub2RlLnZhbHVlLnRyaW0oKSA6ICcnXG4gICAgICAgICAgICB0aGlzLmRhdGEuJHVzZXJPcmlnaW4gPSBzcmNoXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhcjogbmV3IEljb24oe1xuICAgICAgaWNvbjogJ2Nsb3NlU21hbGwnLFxuICAgICAgZGlzcGxheTogJ25vbmUnLFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICBlLnByZXZlbnQgPSB0cnVlXG4gICAgICAgICAgdGhpcy5wYXJlbnQuZnJvbURvd24gPSB0cnVlXG4gICAgICAgICAgICAvL1RPRE86IGZpZ3VyZSBvdXQgd2h5IHRoaXMucGFyZW50IGRvZXMgbm90IGhhdmUgZGF0YSBib3VuZCB0byBpdCFcbiAgICAgICAgICB0aGlzLnBhcmVudC5pbnB1dEZpZWxkLmRhdGEuJHVzZXJPcmlnaW4gPSAnJ1xuICAgICAgICAgICAgLy8gZm9jdXNvdXQuY2FsbCh0aGlzLnBhcmVudC5wYXJlbnQsZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIGV2ZW50czoge1xuICAgIGZvY3VzaW46IGZvY3VzXG4gIH1cbn0pLkNsYXNzXG5cbmZ1bmN0aW9uIGZvY3VzKGUpIHtcbiAgY29uc29sZS5sb2coJ3d0ZiB3dGYgd3RmJywgdGhpcy5wYXJlbnQpXG4gIGlmICh0aGlzLmV2ZW50cy5mb2N1cykge1xuICAgIHRoaXMuZXZlbnRzLmZvY3VzLl92YWwuY2FsbCh0aGlzLCBlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGZvY3Vzb3V0KGUpIHtcbiAgaWYgKHRoaXMuZXZlbnRzLmZvY3Vzb3V0KSB7XG4gICAgdGhpcy5ldmVudHMuZm9jdXNvdXQuX3ZhbC5jYWxsKHRoaXMsIGUpXG4gIH1cbn1cbiIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBTd2l0Y2hlciA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvc3dpdGNoZXInKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3NlY29uZC1iaW8nLFxuICAnZXh0ZW5kLiRmb2N1cyc6ZnVuY3Rpb24odmFsKXtcbiAgICB2YXIgaW5kZXggPSB2YWwudmFsXG4gICAgaWYoaW5kZXggIT09IHRoaXMuX2luZGV4KXtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhXG4gICAgICBpZihkYXRhKXtcbiAgICAgICAgdGhpcy5zd2l0Y2hlci50cmFuc2l0aW9uID0ge1xuICAgICAgICAgIGVsZW1lbnQ6SW1nLFxuICAgICAgICAgICRwYXJhbXM6e1xuICAgICAgICAgICAgb3BhY2l0eTowLFxuICAgICAgICAgICAgYmFja2dyb3VuZDpkYXRhLmZyb20uZ2V0KFsnaW1nJywnY292ZXInLGluZGV4IHx8IDBdLCcnKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJG9wdGlvbnM6e1xuICAgICAgICAgICAgZm9yY2U6dHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pbmRleCA9IGluZGV4XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAkZm9jdXM6e1xuICAgIGRhdGE6J2ZvY3VzJ1xuICB9LFxuICBzd2l0Y2hlcjpuZXcgU3dpdGNoZXIoe1xuICAgIG9uVHJhbnNpdGlvbjonZmFkZScsXG4gICAgLy8gYWRkOm5ldyBJbWcoe1xuICAgIC8vICAgJ2JhY2tncm91bmQuZGF0YSc6J2ltZy5jb3Zlci4wJ1xuICAgIC8vIH0pLFxuICB9KSwvL3dpbGwgc3dpdGNoIGJldHdlZW4gaW1hZ2VzXG4gIG92ZXJsYXk6e1xuICAgICdoZWFkZXIudGV4dC5kYXRhJzondGl0bGUnLFxuICAgIGJpbzp7XG4gICAgICAnaGVhZGVyLnRleHQnOidCaW8nLFxuICAgICAgJ2JvZHkudGV4dC5kYXRhJzonYmlvJ1xuICAgIH1cbiAgfSxcbiAgbW9kZWw6e1xuICAgIHN1YnNjcmlwdGlvbjp7XG4gICAgICBpbWc6e1xuICAgICAgICBjb3Zlcjp7XG4gICAgICAgICAgJDp0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicpXG52YXIgV2lkZ2V0ID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvd2lkZ2V0JylcbnZhciBDb250ZW50ID0gcmVxdWlyZSgnLi4vY29udGVudCcpXG52YXIgVHJhaWxlciA9IHJlcXVpcmUoJy4uL3RyYWlsZXInKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgQ29udGVudCh7XG4gIGNzczogJ3NlY29uZC1jaGFubmVsJyxcbiAgY29udGFpbmVyOiB7XG4gICAgbGVmdDoge1xuICAgICAgdHJhaWxlcjogbmV3IFRyYWlsZXIoe1xuICAgICAgICAndmlkZW8uc3JjLmRhdGEnOid2aWRlbydcbiAgICAgIH0pXG4gICAgfSxcbiAgICBtaWRkbGU6e1xuICAgICAgZ3VpZGU6IG5ldyBXaWRnZXQuR3VpZGUoKVxuICAgIH0sXG4gICAgcmlnaHQ6IG5ldyBTd2l0Y2hlcih7XG4gICAgICBvblRyYW5zaXRpb246IGZ1bmN0aW9uKGN1cnJlbnQsIGxhc3QpIHtcbiAgICAgICAgaWYobGFzdCkgbGFzdC5yZW1vdmUoKVxuICAgICAgICB0aGlzLmFkZChjdXJyZW50KVxuICAgICAgfSxcbiAgICAgIG1vZGVsOntcbiAgICAgICAgc3Vic2NyaXB0aW9uOntcbiAgICAgICAgICBndWlkZTp7XG4gICAgICAgICAgICAwOntcbiAgICAgICAgICAgICAgc3RhdGlzdGljczp7XG4gICAgICAgICAgICAgICAgdGl0bGU6dHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2YWw6ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgdmFyIHdpZGdldERhdGEgPSBkYXRhLmd1aWRlICYmIGRhdGEuZ3VpZGVbMF1cbiAgICAgICAgICBpZih3aWRnZXREYXRhKXtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICAgICAgZWxlbWVudDogd2lkZ2V0RGF0YS5zdGF0aXN0aWNzID8gV2lkZ2V0LlN0YXRzIDogV2lkZ2V0LkFib3V0LFxuICAgICAgICAgICAgICAkcGFyYW1zOnsgZGF0YTpkYXRhIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9LFxuICAnZXh0ZW5kLiRjb21wbGV0ZSc6ZnVuY3Rpb24odmFsKXtcbiAgICB2YXIgY29tcGxldGUgPSB2YWwudmFsXG4gICAgaWYoY29tcGxldGUgPT09IHRydWUpe1xuICAgICAgdGhpcy5jb250YWluZXIuc2V0KHtcbiAgICAgICAgbGVmdDp7XG4gICAgICAgICAgdHdpdHRlcjogbmV3IFdpZGdldC5Ud2l0dGVyKHtcbiAgICAgICAgICAgIGRhdGE6dGhpcy5kYXRhXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9ZWxzZSBpZihjb21wbGV0ZSA9PT0gZmFsc2Upe1xuICAgICAgLy8gdGhpcy5jb250YWluZXIuc2V0KHtcbiAgICAgIC8vICAgbGVmdDp7XG4gICAgICAvLyAgICAgdHdpdHRlcjogZmFsc2VcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfSlcbiAgICB9XG4gIH1cbn0pLkNsYXNzIiwidmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIENvdmVyID0gcmVxdWlyZSgnLi4vY292ZXInKVxudmFyIENoYW5uZWxcbnZhciBWb2RcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjb3ZlcjogbmV3IENvdmVyKCksXG4gICdleHRlbmQuJGFjdGl2ZSc6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHZhciBhY3RpdmUgPSB2YWwudmFsXG4gICAgaWYgKGFjdGl2ZSAhPT0gdm9pZCAwKSB7XG4gICAgICB2YXIgYmcgPSB0aGlzLmNvdmVyLmJnXG4gICAgICB2YXIgaW5mbyA9IHRoaXMuaW5mb1xuICAgICAgaWYgKGFjdGl2ZSkge1xuICAgICAgICBpZiAoYmcuX2xvYWRlZCkgYmcub3BhY2l0eSA9IGZhbHNlXG4gICAgICAgIGJnLiR3YWl0ID0gZmFsc2VcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJnLiR3YWl0ID0gdHJ1ZVxuICAgICAgICBiZy5vcGFjaXR5ID0gMFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJGFjdGl2ZTogdHJ1ZVxufSkuQ2xhc3NcblxuZXhwb3J0cy5zZWxlY3QgPSBmdW5jdGlvbihkYXRhLCB0eXBlKSB7XG4gIGlmICghdHlwZSkgdHlwZSA9IGRhdGEuX2NvbnRlbnRUeXBlXG5cbiAgcmV0dXJuIHR5cGUgPT09ICdjaGFubmVscycgPyB7XG4gICAgZWxlbWVudDogQ2hhbm5lbCA9IENoYW5uZWwgfHwgcmVxdWlyZSgnLi4vY2hhbm5lbCcpLFxuICAgICRwYXJhbXM6IHt9XG4gIH0gOiB7XG4gICAgZWxlbWVudDogVm9kID0gVm9kIHx8IHJlcXVpcmUoJy4uL3ZvZCcpLFxuICAgICRwYXJhbXM6IHtcbiAgICAgICRwb3B1cDogYXBwLnBvcHVwXG4gICAgfVxuICB9XG59XG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczonc2Vjb25kLWNvdmVyJyxcbiAgYmc6bmV3IEltZyh7XG4gICAgb3BhY2l0eTowLFxuICAgICR3YWl0OnRydWUsXG4gICAgYmFja2dyb3VuZDp7XG4gICAgICBkYXRhOidpbWcuY292ZXIuMCcsXG4gICAgICBhZGQ6e1xuICAgICAgICBkYXRhOidzaG93LmltZy5jb3Zlci4wJ1xuICAgICAgfVxuICAgIH1cbiAgfSksXG4gIG92ZXJsYXk6e31cbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgcG9zdHBvbmUgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG52YXIgQ29udGVudCA9IHJlcXVpcmUoJy4uL2NvbnRlbnQnKVxuXG52YXIgX3ByZXZpZXcgPSBwb3N0cG9uZShmdW5jdGlvbihzd2l0Y2hlcixmb2N1c0luZGV4KSB7IC8vbW92ZSB0aGlzIHRvIGFwcCBjb250cm9sIHN0dWZmXG4gIGlmKGZvY3VzSW5kZXggIT09IHZvaWQgMCl7XG4gICAgdmFyIGNsb3VkZGF0YSA9IGFwcC5jbG91ZC5kYXRhXG4gICAgdmFyIGZvY3Vzcm93ID0gYXBwLnVzZXIuZm9jdXNfcm93LnZhbFxuICAgIHZhciBkYXRhID0gY2xvdWRkYXRhLmdldChbJ2Rpc2NvdmVyJyxmb2N1c3JvdywnaXRlbXMnLGZvY3VzSW5kZXhdKVxuICAgIGFwcC5wcmV2aWV3LnZhbCA9IGRhdGFcbiAgICBpZihzd2l0Y2hlci5fc3dFbGVtKSBzd2l0Y2hlci5fc3dFbGVtLiRhY3RpdmUudmFsID0gdHJ1ZVxuICB9XG59LDQwMClcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU3dpdGNoZXIoe1xuICBjc3M6ICdzZWNvbmQtZGlzY292ZXInLFxuICBleHRlbmQ6e1xuICAgICRoaWdobGlnaHQ6ZnVuY3Rpb24odmFsKXtcbiAgICAgIHZhciBpbmRleCA9IHZhbC52YWxcbiAgICAgIHZhciBsYXN0ID0gdGhpcy5sYXN0XG4gICAgICBpZihpbmRleCAhPT0gZmFsc2Upe1xuICAgICAgICBpZighdGhpcy5mcm9tQ29udGVudCl7XG4gICAgICAgICAgaWYodGhpcy5fc3dFbGVtKSB0aGlzLl9zd0VsZW0uJGFjdGl2ZSA9IGZhbHNlXG4gICAgICAgICAgX3ByZXZpZXcodGhpcyxpbmRleClcbiAgICAgICAgICB0aGlzLmxhc3QgPSB2b2lkIDBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGhpcy5mcm9tQ29udGVudCA9IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICRwcmV2aWV3OmZ1bmN0aW9uKHZhbCl7XG4gICAgICB2YWwgPSB2YWwudmFsXG4gICAgICBpZih2YWwpe1xuICAgICAgICB2YXIgZGF0YSA9IHZhbC5mcm9tXG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gQ29udGVudC5zZWxlY3QoZGF0YSlcbiAgICAgICAgdHJhbnNpdGlvbi4kcGFyYW1zLmRhdGEgPSBkYXRhXG4gICAgICAgIHRyYW5zaXRpb24uJHBhcmFtcy4kY29tcGxldGUgPSBmYWxzZVxuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uXG4gICAgICB9XG4gICAgfSxcbiAgICAkY29udGVudDpmdW5jdGlvbih2YWwpe1xuICAgICAgdmFsID0gdmFsLnZhbFxuICAgICAgaWYodmFsKXtcbiAgICAgICAgdmFyIGRhdGEgPSB2YWwuZnJvbVxuICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IENvbnRlbnQuc2VsZWN0KGRhdGEpXG4gICAgICAgIHRyYW5zaXRpb24uJHBhcmFtcy5kYXRhID0gZGF0YVxuICAgICAgICB0cmFuc2l0aW9uLiRwYXJhbXMuJGNvbXBsZXRlID0gdHJ1ZVxuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uXG4gICAgICAgIHRoaXMuZnJvbUNvbnRlbnQgPSB0cnVlXG4gICAgICAgIGFwcC5wcmV2aWV3LnZhbCA9IGRhdGFcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG9uVHJhbnNpdGlvbjonZmFkZSdcbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicpXG4gICwgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG4gICwgRGlzY292ZXIgPSByZXF1aXJlKCcuL2Rpc2NvdmVyJylcbiAgLCBTZWFyY2ggPSByZXF1aXJlKCcuL3NlYXJjaCcpXG4gICwgU3RhdHVzYmFyID0gcmVxdWlyZSgnLi9zdGF0dXNiYXInKVxuICAsIGFwcCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9hcHAnKVxuICAsIE5hdmlnYXRpb24gPSByZXF1aXJlKCcuL25hdmlnYXRpb24nKVxuICAsIFBsYXllciA9IHJlcXVpcmUoJy4vcGxheWVyJylcbiAgLCBDb250ZW50ID0gcmVxdWlyZSgnLi9jb250ZW50JylcblxuLy9zZWNvbmRzY3JlZW4gdG9wbGV2ZWxcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOidzZWNvbmQtc3RhdGUnLFxuICB5Ont0cmFuc2xhdGU6dHJ1ZSx2YWw6MH0sXG4gIHN3aXRjaGVyOm5ldyBTd2l0Y2hlcih7IC8vIHN3aXRjaGVzIGJldHdlZW4gbWFpbiBhbmQgc2VhcmNoXG4gICAgb25UcmFuc2l0aW9uOidmYWRlJ1xuICB9KSxcbiAgbmF2aWdhdGlvbjpuZXcgTmF2aWdhdGlvbigpLFxuICBzdGF0dXNiYXI6bmV3IFN0YXR1c2JhcigpLFxuICBzZWFyY2g6bmV3IFNlYXJjaCgpLFxuICBleHRlbmQ6e1xuICAgICRoaWdobGlnaHQ6ZnVuY3Rpb24oIHZhbCApe30sXG4gICAgJHByZXZpZXc6ZnVuY3Rpb24oIHZhbCApe30sXG4gICAgJHBhZ2U6ZnVuY3Rpb24oIHZhbCwgc3RhbXAgKXtcblxuXG4gICAgICBpZih0aGlzLiRtZWRpYS52YWwgfHwgIXN0YW1wKSByZXR1cm5cbiAgICAgIHZhciBwYWdlID0gdmFsLnZhbFxuXG4gICAgICBhcHAudXNlci50cmFpbGVyTXV0ZWQuJHVzZXJPcmlnaW4gPSB0cnVlXG4gICAgICBhcHAuaGlkZVN0YXR1c2Jhci52YWwgPSBmYWxzZVxuICAgICAgXG4gICAgICBpZiggcGFnZSA9PT0gJ2Rpc2NvdmVyJyApe1xuICAgICAgICB0aGlzLnNldCh7XG4gICAgICAgICAgeTowLFxuICAgICAgICAgIHN3aXRjaGVyOntcbiAgICAgICAgICAgIHRyYW5zaXRpb246e1xuICAgICAgICAgICAgICBlbGVtZW50OkRpc2NvdmVyLFxuICAgICAgICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICAgICAgICAkcHJldmlldzp0aGlzLiRwcmV2aWV3Ll92YWwsXG4gICAgICAgICAgICAgICAgJGhpZ2hsaWdodDp0aGlzLiRoaWdobGlnaHQuX3ZhbCxcbiAgICAgICAgICAgICAgICAkY29udGVudDpmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBuYXZpZ2F0aW9uOntcbiAgICAgICAgICAgIGNvbnRhaW5lcjp7XG4gICAgICAgICAgICAgIHk6MFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1lbHNlIGlmKHBhZ2UgPT09ICdzZWFyY2gnKXtcbiAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgIHk6IC1hcHAuaC52YWwgKyA4MCxcbiAgICAgICAgICBzZWFyY2g6e1xuICAgICAgICAgICAgJHNlYXJjaDphcHAudXNlci5zZWFyY2gsXG4gICAgICAgICAgICAkbXV0ZWQ6YXBwLnVzZXIudHJhaWxlck11dGVkLFxuICAgICAgICAgICAgZGF0YTphcHAuY2xvdWQuZGF0YVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgIH0sXG4gICAgJGNvbnRlbnQ6ZnVuY3Rpb24oIHZhbCxzdGFtcCApe1xuXG4gICAgICAvLyBpZih0aGlzLiRtZWRpYS52YWwgfHwgIXN0YW1wKSByZXR1cm5cbiAgICAgIC8vIHZhciBkYXRhID0gdmFsLmZyb21cbiAgICAgIGlmKHRoaXMuJG1lZGlhLnZhbCB8fCAhc3RhbXApIHJldHVyblxuXG4gICAgICBhcHAuaGlkZVN0YXR1c2Jhci52YWwgPSBmYWxzZVxuXG4gICAgICB0aGlzLnNldCh7XG4gICAgICAgIHk6MCxcbiAgICAgICAgc3dpdGNoZXI6e1xuICAgICAgICAgIHRyYW5zaXRpb246IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6RGlzY292ZXIsXG4gICAgICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICAgICAgJHByZXZpZXc6ZmFsc2UsXG4gICAgICAgICAgICAgICRoaWdobGlnaHQ6ZmFsc2UsXG4gICAgICAgICAgICAgICRjb250ZW50OnZhbFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbmF2aWdhdGlvbjp7XG4gICAgICAgICAgY29udGFpbmVyOntcbiAgICAgICAgICAgIHk6NDIwXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgJG1lZGlhOmZ1bmN0aW9uKCB2YWwsIHN0YW1wICl7XG4gICAgICBpZih2YWwudmFsKXtcbiAgICAgICAgdGhpcy5zZXQoe1xuICAgICAgICAgIHk6MCxcbiAgICAgICAgICBzd2l0Y2hlcjp7XG4gICAgICAgICAgICB0cmFuc2l0aW9uOntcbiAgICAgICAgICAgICAgZWxlbWVudDpQbGF5ZXIsXG4gICAgICAgICAgICAgICRwYXJhbXM6e1xuICAgICAgICAgICAgICAgIG92ZXJsYXk6e1xuICAgICAgICAgICAgICAgICAgJHZvbHVtZTphcHAudm9sdW1lLFxuICAgICAgICAgICAgICAgICAgJHRpbWU6dmFsLnZhbC5nZXQoJ3RpbWUnKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGxheWluZzphcHAuaXNQbGF5aW5nLFxuICAgICAgICAgICAgICAgIGRhdGE6dmFsLiR1c2VyT3JpZ2luLFxuICAgICAgICAgICAgICAgIHZpZGVvOiB7XG4gICAgICAgICAgICAgICAgICB2b2x1bWU6IGFwcC52b2x1bWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdmlnYXRpb246e1xuICAgICAgICAgICAgY29udGFpbmVyOntcbiAgICAgICAgICAgICAgeTo0NjAgKyA4MFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1lbHNle1xuICAgICAgICBhcHAudXNlci51cGRhdGVOYXZpZ2F0aW9uKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHNldFNldHRpbmc6e1xuICAgIG5hbWU6J3VwZGF0ZU5hdicsXG4gICAgcGFyZW50OmZ1bmN0aW9uKCl7XG4gICAgICBhcHAudXNlci51cGRhdGVOYXZpZ2F0aW9uKClcbiAgICB9XG4gIH1cbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIGFwcCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9hcHAnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIExpc3QgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdCcpXG52YXIgcG9zdHBvbmUgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9ldmVudHMvdXRpbCcpLnBvc3Rwb25lXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIFByb2dyZXNzID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvcHJvZ3Jlc3MnKVxuXG52YXIgeUVsZW1lbnQgPSBuZXcgRWxlbWVudCh7XG4gIHk6IHtcbiAgICB0cmFuc2xhdGU6IHRydWUsXG4gICAgdmFsOjQyMFxuICB9XG59KS5DbGFzc1xuXG52YXIgdGl0bGVFbGVtZW50ID0gbmV3IHlFbGVtZW50KHtcbiAgJ3RleHQuZGF0YSc6ICd0aXRsZSdcbn0pLkNsYXNzXG5cbnZhciBtYXAgPSB7XG4gIHNwb3RsaWdodDoge1xuICAgIGluZGV4OiAwLFxuICAgIGxpc3Q6IExpc3QuV2F0Y2hpbmdcbiAgfSxcbiAgY2hhbm5lbHM6IHtcbiAgICBpbmRleDogMSxcbiAgICBsaXN0OiBMaXN0LkNoYW5uZWxcbiAgfSxcbiAgd2F0Y2hpbmc6IHtcbiAgICBpbmRleDogMixcbiAgICBsaXN0OiBMaXN0LldhdGNoaW5nXG4gIH0sXG4gIHJlbGVhc2VzOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGlzdDogTGlzdC5Qb3N0ZXJcbiAgfSxcbiAgcmVjb21tZW5kZWQ6IHtcbiAgICBpbmRleDogNCxcbiAgICBsaXN0OiBMaXN0LlBvc3RlclxuICB9XG59XG5cbnZhciBzd2l0Y2hGb2N1cyA9IGZ1bmN0aW9uKF90aGlzLCBpbmRleCwgZm9jdXNlZCwgdHlwZSkge1xuICB2YXIgZGlyZWN0aW9uID0gaW5kZXggPiBfdGhpcy5pbmRleCA/IC0xIDogMVxuICAgIC8vc3dpdGNoIHRoZSB0aXRsZVxuXG4gIF90aGlzLmNvbnRhaW5lci5zZXQoe1xuICAgIGJhcjoge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdHJhbnNpdGlvbjoge1xuICAgICAgICAgIGVsZW1lbnQ6IHRpdGxlRWxlbWVudCxcbiAgICAgICAgICBkaXJlY3Rpb246IGRpcmVjdGlvbixcbiAgICAgICAgICAkcGFyYW1zOiB7XG4gICAgICAgICAgICBkYXRhOiBmb2N1c2VkXG4gICAgICAgICAgfSxcbiAgICAgICAgICAkb3B0aW9uczoge1xuICAgICAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhcnJvd3M6IHtcbiAgICAgICAgdXA6IHtcbiAgICAgICAgICBvcGFjaXR5OmluZGV4ID09PSAwID8gMC41IDogMVxuICAgICAgICB9LFxuICAgICAgICBkb3duOiB7XG4gICAgICAgICAgb3BhY2l0eTppbmRleCA9PT0gNCA/IDAuNSA6IDFcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICBfdGhpcy5pbmRleCA9IGluZGV4XG5cbiAgbGlzdEZvY3VzKF90aGlzLCBpbmRleCwgZm9jdXNlZCwgdHlwZSwgZGlyZWN0aW9uKVxufVxuXG52YXIgbGlzdEZvY3VzID0gcG9zdHBvbmUoZnVuY3Rpb24oX3RoaXMsIGluZGV4LCBmb2N1c2VkLCB0eXBlLCBkaXJlY3Rpb24pIHtcbiAgdmFyIGxpc3RzID0gX3RoaXMuY29udGFpbmVyLmxpc3RzXG4gIHZhciBmb2N1c0l0ZW0gPSBhcHAudXNlclsnZm9jdXNfJyArIHR5cGVdXG5cbiAgaWYobGlzdHMpe1xuICAgIGxpc3RzLnRyYW5zaXRpb24gPSB7XG4gICAgICBlbGVtZW50OiBtYXBbdHlwZV0ubGlzdCxcbiAgICAgIGRpcmVjdGlvbjogZGlyZWN0aW9uLFxuICAgICAgJHBhcmFtczoge1xuICAgICAgICBkYXRhOiBmb2N1c2VkLFxuICAgICAgICAkZm9jdXM6IGFwcC5oaWdobGlnaHQudmFsID0gZm9jdXNJdGVtXG4gICAgICB9LFxuICAgICAgJG9wdGlvbnM6IHtcbiAgICAgICAgZm9yY2U6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0sIDIwMClcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3NlY29uZC1uYXZpZ2F0aW9uJyxcbiAgY29udGFpbmVyOiBuZXcgeUVsZW1lbnQoe1xuICAgIHByb2dyZXNzOiBuZXcgUHJvZ3Jlc3Moe1xuICAgICAgcGVyY2VudGFnZTp7XG4gICAgICAgIHRleHQ6e1xuICAgICAgICAgIHZhbDp7XG4gICAgICAgICAgICBwYXJlbnQ6J29uJyxcbiAgICAgICAgICAgIGFuaW1hdGlvbjp7XG4gICAgICAgICAgICAgIGVhc2luZzonb3V0Q3ViaWMnLFxuICAgICAgICAgICAgICB0aW1lOjE4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICAgICAgICByZXR1cm4gfn5jdiArICclJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1vZGVsOntcbiAgICAgICAgY29tcGxldGU6ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgdGhpcy5vbi51cGRhdGUodGhpcylcbiAgICAgICAgfSxcbiAgICAgICAgaW5oZXJpdDpmYWxzZVxuICAgICAgfSxcbiAgICAgIG9uOntcbiAgICAgICAgZGF0YTondGltZScsXG4gICAgICAgIGRlZmVyOmZ1bmN0aW9uKHVwZGF0ZSl7XG4gICAgICAgICAgaWYofn50aGlzLmZyb20udmFsKXtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxlci5vcGFjaXR5ID0gMVxuICAgICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxlci5vcGFjaXR5ID0gMFxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG11bHRpcGx5OjEwMFxuICAgICAgfVxuICAgIH0pLFxuICAgIGJhcjoge1xuICAgICAgdGl0bGU6IG5ldyBTd2l0Y2hlcih7XG4gICAgICAgIG9uVHJhbnNpdGlvbjogZnVuY3Rpb24oY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uKSB7XG4gICAgICAgICAgX3RyYW5zaXRpb24odGhpcywgNDAsIGN1cnJlbnQsIGxhc3QsIGRpcmVjdGlvbilcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBhcnJvd3M6IHtcbiAgICAgICAgdXA6bmV3IEljb24oe1xuICAgICAgICAgIGljb246J3VwTmF2JyxcbiAgICAgICAgICBvcGFjaXR5OjAuMVxuICAgICAgICB9KSxcbiAgICAgICAgZG93bjogbmV3IEljb24oe1xuICAgICAgICAgIGljb246J2Rvd25OYXYnXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICBsaXN0czogbmV3IFN3aXRjaGVyKHtcbiAgICAgIG9uVHJhbnNpdGlvbjogZnVuY3Rpb24oY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIF90cmFuc2l0aW9uKHRoaXMsIDQwMCwgY3VycmVudCwgbGFzdCwgZGlyZWN0aW9uKVxuICAgICAgfVxuICAgIH0pXG4gIH0pLFxuICAnbW9kZWwuc3Vic2NyaXB0aW9uLiQuJCc6IHRydWUsXG4gIGV4dGVuZDp7XG4gICAgJGZvY3VzOiBmdW5jdGlvbih2YWwpIHsgLy92YWwgPT09ICdzcG90bGlnaHQnLydyZWNvbW1lbmRlZCcgZXRjXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YVxuICAgICAgaWYoIWRhdGEpIHJldHVyblxuICAgICAgXG4gICAgICBpZighZGF0YS4kbGVuZ3RoLnZhbCkge1xuICAgICAgICBkYXRhLiRsZW5ndGgub25jZShmdW5jdGlvbigpIHtcbiAgICAgICAgICBfdGhpcy4kZm9jdXMudXBkYXRlKClcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHZhciBmb2N1c2VkID0gZGF0YVt2YWwudmFsXVxuICAgICAgaWYoZm9jdXNlZCkge1xuICAgICAgICBzd2l0Y2hGb2N1cyhfdGhpcywgbWFwW3ZhbC52YWxdLmluZGV4LCBmb2N1c2VkLCB2YWwudmFsKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2V0U2V0dGluZzoge1xuICAgIG5hbWU6ICdwcmVwVmFsdWVzJyxcbiAgICBwYXJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZm9yKHZhciB0eXBlIGluIG1hcCkge1xuICAgICAgICB2YXIgZmllbGQgPSAnZm9jdXNfJyArIHR5cGVcbiAgICAgICAgaWYoIWFwcC51c2VyW2ZpZWxkXSkge1xuICAgICAgICAgIHZhciBvYmogPSB7fVxuICAgICAgICAgIG9ialtmaWVsZF0gPSAwXG4gICAgICAgICAgYXBwLnVzZXIuc2V0KG9iailcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxuZnVuY3Rpb24gX3RyYW5zaXRpb24oX3RoaXMsIGRlbHRhLCBjdXJyZW50LCBsYXN0LCBkaXJlY3Rpb24pIHtcbiAgaWYobGFzdCkge1xuICAgIGxhc3QueSA9IGRlbHRhICogZGlyZWN0aW9uIC8vIHNob3VsZCBzdGlsbCByZW1vdmVcbiAgICBjdXJyZW50LnkgPSBkZWx0YSAqIC1kaXJlY3Rpb25cbiAgfVxuICBfdGhpcy5hZGQoY3VycmVudClcbiAgaWYoX3RoaXMuX3RpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KF90aGlzLl90aW1lcilcbiAgICBfdGhpcy5fdGltZXIgPSBudWxsXG4gIH1cbiAgX3RoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBfdGhpcy5fdGltZXIgPSBudWxsXG4gICAgZG9pdCgpXG4gIH0sIDUwKVxuXG4gIGZ1bmN0aW9uIGRvaXQoKXtcbiAgICBpZighY3VycmVudC5fYmxvY2tlZCkgY3VycmVudC55ID0gMFxuICAgIGVsc2Ugd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShkb2l0KVxuICB9XG59XG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBWaWRlbyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8nKVxudmFyIFByb2dyZXNzID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvaW5hY3RpdmUvcHJvZ3Jlc3MnKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIHBvc3Rwb25lID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZXZlbnRzL3V0aWwnKS5wb3N0cG9uZVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG5cbnZhciBmYWRlSWNvbiA9IHBvc3Rwb25lKGZ1bmN0aW9uKF90aGlzLCBmb3JjZSkge1xuICB2YXIgaWNvbiA9IF90aGlzLl9zd0VsZW0gJiYgX3RoaXMuX3N3RWxlbS5pY29uXG4gIGlmIChpY29uKSB7XG4gICAgaWNvbi5jc3MgPSAndWktaWNvbiBmYWRlLW91dCdcbiAgICBpY29uLm9wYWNpdHkgPSAwXG4gIH1cbn0sIDEwMDApXG5cbnZhciBmYWRlT3ZlcmxheSA9IHBvc3Rwb25lKGZ1bmN0aW9uKF90aGlzLCBmb3JjZSkge1xuICBpZiAoYXBwLmlzUGxheWluZy52YWwpIF90aGlzLm9wYWNpdHkgPSAwXG5cbn0sIDEwMDApXG5cbnZhciB1cGRhdGVQbGF5ID0gcG9zdHBvbmUoZnVuY3Rpb24oX3RoaXMpIHtcbiAgYXBwLmhpZGVTdGF0dXNiYXIudmFsID0gZmFsc2VcbiAgaWYgKF90aGlzLiRwbGF5aW5nKSBfdGhpcy4kcGxheWluZy51cGRhdGUoKVxufSwgMTAwMClcblxudmFyIE92ZXJsYXkgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3BsYXllci1vdmVybGF5JyxcbiAgb3BhY2l0eTogMCxcbiAgaWNvbjogbmV3IEljb24oe1xuICAgIG9wYWNpdHk6IDAsXG4gICAgaWNvbjoge1xuICAgICAgdmFsOiAncGF1c2UnLFxuICAgICAgJGlzUGxheWluZzogJ3BsYXknXG4gICAgfVxuICB9KSxcbiAgaW5mbzoge1xuICAgIHBvc3Rlcjoge1xuICAgICAgaW1nOiBuZXcgSW1nKHtcbiAgICAgICAgJ2JhY2tncm91bmQuZGF0YSc6ICdpbWcucG9zdGVyJ1xuICAgICAgfSlcbiAgICB9LFxuICAgIHRpdGxlczoge1xuICAgICAgJ25vd3BsYXlpbmcudGV4dCc6ICdOb3cgUGxheWluZycsXG4gICAgICAndGl0bGUudGV4dC5kYXRhJzogJ3RpdGxlJyxcbiAgICAgICdzdWJ0aXRsZS50ZXh0LmRhdGEnOiAnc3VidGl0bGUnXG4gICAgfVxuICB9LFxuICByZWNvbW1lbmRlZDoge1xuICAgICdoZWFkZXIudGV4dCc6ICdSZWNvbW1lbmRlZCcsXG4gICAgdGh1bWI6e1xuICAgICAgaW1nOm5ldyBJbWcoe1xuICAgICAgICBiYWNrZ3JvdW5kOntcbiAgICAgICAgICBkYXRhOidyZWNvbW1lbmRhdGlvbnMuMC5pbWcuc3BvdGxpZ2h0JyxcbiAgICAgICAgICBhZGQ6e1xuICAgICAgICAgICAgZGF0YTonc2hvdy5yZWNvbW1lbmRhdGlvbnMuMC5pbWcuc3BvdGxpZ2h0J1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZGlzcGxheTp7XG4gICAgICAgICAgdmFsOidibG9jaycsXG4gICAgICAgICAgd2hlbjp7c2VsZjonYmFja2dyb3VuZCd9LFxuICAgICAgICAgIG9yOidub25lJ1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcblxudmFyIEJhck92ZXJsYXkgPSBuZXcgRWxlbWVudCh7XG4gIG9wYWNpdHk6MCxcbiAgY29udGFpbmVyOiB7XG4gICAgdHh0OiB7fSxcbiAgICBwcm9ncmVzczogbmV3IFByb2dyZXNzKHtcbiAgICAgIGRpc3BsYXk6ZmFsc2VcbiAgICB9KVxuICB9LFxuICAnZXh0ZW5kLiR2YWx1ZSc6IGZ1bmN0aW9uKHZhbCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldCh7IC8vY2hhbmdlIHRoaXMgZm9yIGRhdGFcbiAgICAgIHR4dDoge1xuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIHRleHQ6IHZhbC52YWxcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByb2dyZXNzOiB7XG4gICAgICAgIG9uOiB2YWwudmFsXG4gICAgICB9XG4gICAgfSlcbiAgfVxufSkuQ2xhc3NcblxudmFyIFNlZWtPdmVybGF5ID0gbmV3IEJhck92ZXJsYXkoe1xuICBjc3M6ICdzZWVrLW92ZXJsYXknLFxuICAnY29udGFpbmVyLnR4dCc6IHtcbiAgICB0ZXh0OiAnU0VFS0lORyAnLFxuICAgICd2YWx1ZS50ZXh0Jzoge1xuICAgICAgZGF0YTogJ3RpbWUnLFxuICAgICAgbXVsdGlwbHk6IHtcbiAgICAgICAgZGF0YTogJ2R1cmF0aW9uJ1xuICAgICAgfSxcbiAgICAgICRjb252ZXJ0VGltZTogdHJ1ZSwgLy97ZGF0YTonZHVyYXRpb24nfSxcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbnZhciBWb2x1bWVPdmVybGF5ID0gbmV3IEJhck92ZXJsYXkoe1xuICBjc3M6ICd2b2x1bWUtb3ZlcmxheScsXG4gICdjb250YWluZXIudHh0Jzoge1xuICAgIHRleHQ6ICdWT0xVTUUgJyxcbiAgICAndmFsdWUudGV4dCc6IHtcbiAgICAgIHZhbDogMCxcbiAgICAgIHRyYW5zZm9ybTogZnVuY3Rpb24odiwgY3YpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoY3YgKiAxMDAgfHwgMCkgKyAnJSdcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pLkNsYXNzXG5cbnZhciBPdmVybGF5U3dpdGNoZXIgPSBuZXcgU3dpdGNoZXIoe1xuICBleHRlbmQ6IHtcbiAgICAkcGxheWluZzogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLm9wYWNpdHkgPSAxXG4gICAgICB0aGlzLnRyYW5zaXRpb24gPSB7XG4gICAgICAgIGVsZW1lbnQ6IE92ZXJsYXksXG4gICAgICAgICRwYXJhbXM6IHtcbiAgICAgICAgICBkYXRhOiB0aGlzLnBhcmVudC5kYXRhLFxuICAgICAgICAgIGljb246IHtcbiAgICAgICAgICAgIGNzczogJ3VpLWljb24gZmFkZS1pbicsXG4gICAgICAgICAgICBvcGFjaXR5OiAxXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoYXBwLmlzUGxheWluZy52YWwpIGZhZGVPdmVybGF5KHRoaXMpXG4gICAgICBmYWRlSWNvbih0aGlzKVxuICAgIH0sXG4gICAgJHRpbWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKGFyZ3VtZW50c1syXSA9PT0gdm9pZCAwIHx8IHZhbC52YWwgPCAwIHx8IGFwcC51c2VyLnJlY2VpdmVyLm1lZGlhLl9jb250ZW50VHlwZSA9PT0gJ2NoYW5uZWxzJykgcmV0dXJuXG4gICAgICB0aGlzLm9wYWNpdHkgPSAxXG4gICAgICB0aGlzLnRyYW5zaXRpb24gPSB7XG4gICAgICAgIGVsZW1lbnQ6IFNlZWtPdmVybGF5LFxuICAgICAgICAkcGFyYW1zOiB7XG4gICAgICAgICAgJHZhbHVlOiB2YWwudmFsXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGFwcC5oaWRlU3RhdHVzYmFyLnZhbCA9IHRydWVcblxuICAgICAgaWYgKGFwcC5pc1BsYXlpbmcudmFsKSB7XG4gICAgICAgIGZhZGVPdmVybGF5KHRoaXMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGVQbGF5KHRoaXMpXG4gICAgICB9XG5cbiAgICB9LFxuICAgICR2b2x1bWU6IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgaWYgKGFyZ3VtZW50c1syXSA9PT0gdm9pZCAwKSByZXR1cm5cbiAgICAgIHRoaXMub3BhY2l0eSA9IDFcbiAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgZWxlbWVudDogVm9sdW1lT3ZlcmxheSxcbiAgICAgICAgJHBhcmFtczoge1xuICAgICAgICAgICR2YWx1ZTogdmFsLnZhbFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhcHAuaGlkZVN0YXR1c2Jhci52YWwgPSB0cnVlXG4gICAgICBpZiAoYXBwLmlzUGxheWluZy52YWwpIGZhZGVPdmVybGF5KHRoaXMpXG4gICAgICBlbHNlIHVwZGF0ZVBsYXkodGhpcylcbiAgICB9XG4gIH0sXG4gIG9uVHJhbnNpdGlvbjogZnVuY3Rpb24oY3VycmVudCwgbGFzdCkge1xuICAgIGlmIChsYXN0KSBsYXN0LnJlbW92ZSgpXG4gICAgY3VycmVudC4kdGltZW91dCA9IHtcbiAgICAgIDUwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkZChjdXJyZW50KVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnc2Vjb25kLXBsYXllcicsXG4gIHZpZGVvOiBuZXcgVmlkZW8oe1xuICAgIHBsYXllcjogcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlby9odG1sNScpLFxuICAgIGR1cmF0aW9uOiB7XG4gICAgICBkYXRhOiAnZHVyYXRpb24nXG4gICAgfSxcbiAgICB0aW1lOiB7XG4gICAgICBkYXRhOiAndGltZSdcbiAgICB9LFxuICAgIHNyYzoge1xuICAgICAgcHJlcGVuZDogY29uZmlnLnBvaW50ZXJzLmFzc2V0cyxcbiAgICAgIGRhdGE6ICd2aWRlbydcbiAgICB9LFxuICAgIGV2ZW50czoge1xuICAgICAgcHJvZ3Jlc3M6IGZ1bmN0aW9uKHApIHtcbiAgICAgICAgdGhpcy5kYXRhLmZyb20uc2V0KCd0aW1lJywgLU1hdGguYWJzKHApKVxuICAgICAgfVxuICAgIH1cbiAgfSksXG4gIG92ZXJsYXk6IG5ldyBPdmVybGF5U3dpdGNoZXIoKSxcbiAgZXh0ZW5kOiB7XG4gICAgcGxheWluZzogZnVuY3Rpb24odmFsKSB7XG4gICAgICB0aGlzLm92ZXJsYXkuJHBsYXlpbmcgPSB2YWxcbiAgICAgIHRoaXMudmlkZW8uJHBsYXlpbmcgPSB2YWxcbiAgICB9XG4gIH1cbn0pLkNsYXNzXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuXHRjc3M6J3NlY29uZC1wcm9ncmVzcycsXG4gIG9uOntcbiAgICBkYXRhOid0aW1lJyxcbiAgXHRhYnM6dHJ1ZSxcbiAgICBtdWx0aXBseToxMDBcbiAgfSxcbiAgZGlzcGxheTp7XG4gICAgdmFsOmFwcC5wcmV2aWV3LFxuICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIHZhciBwb3B1cCA9IGFwcC5wb3B1cC52YWxcbiAgICAgIHJldHVybiAoY3YgJiYgY3YuX2NvbnRlbnRUeXBlID09PSAnY2hhbm5lbHMnKSB8fCAocG9wdXAgJiYgdHlwZW9mIHBvcHVwICE9PSAnc3RyaW5nJykgPyAnbm9uZScgOiAnYmxvY2snXG4gICAgfSxcbiAgICBsaXN0ZW46YXBwLnBvcHVwXG4gIH0sXG4gIHc6e1xuICAgIHNlbGY6J29uJyxcbiAgICB0cmFuc2Zvcm06ZnVuY3Rpb24odixjdil7XG4gICAgICByZXR1cm4gTWF0aC5tYXgofn5jdiwzKSArICclJ1xuICAgIH1cbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBUcmFpbGVyID0gcmVxdWlyZSgnLi4vdHJhaWxlcicpXG52YXIgc2VhcmNoID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL3NlYXJjaCcpXG52YXIgd2hlbiA9IHJlcXVpcmUoJ3Byb21pc2UnKS5hbGxcbnZhciBTdWJ0aXRsZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3N1YnRpdGxlJylcblxudmFyIE5vUmVzdWx0cyA9IG5ldyBFbGVtZW50KHtcbiAgY29udGFpbmVyOntcbiAgICAndGl0bGUudGV4dCc6J05vIFJlc3VsdHMhJyxcbiAgICAnc3VidGl0bGUudGV4dCc6J1BsZWFzZSB0cnkgdG8gcmVmaW5lIHlvdXIgcXVlcnknXG4gIH1cbn0pLkNsYXNzXG5cbnZhciBTdGFydFNlYXJjaGluZyA9IG5ldyBFbGVtZW50KHtcbiAgY29udGFpbmVyOntcbiAgICAndGl0bGUudGV4dCc6J1N0YXJ0IFNlYXJjaGluZyEnLFxuICAgICdzdWJ0aXRsZS50ZXh0JzonRmluZCB5b3VyIGZhdm9yaXRlIG1vdmllcywgc2hvd3MgYW5kIGNoYW5uZWxzJ1xuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAnc2Vjb25kLXNlYXJjaCcsXG4gIGV4dGVuZDp7XG4gICAgJHNlYXJjaDpmdW5jdGlvbiggdmFsICl7XG4gIFx0ICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgXHR2YXIgcmVzdWx0cyA9IHRoaXMucmVzdWx0c1xuICAgIFx0dmFyIGNoaWxkcmVuID0gcmVzdWx0cy5saXN0LmNoaWxkcmVuXG4gICAgXHR2YXIgcXVlcnkgPSBzZWFyY2gucGFyc2VTZWFyY2goIHZhbC52YWwgKVxuICAgIFx0dmFyIGNvbnRlbnQgPSBhcHAuY29udGVudFxuXG4gICAgXHR0aGlzLnNlYXJjaGJveC5xdWVyeS50ZXh0ID0gcXVlcnlcblxuICAgIFx0aWYocXVlcnkgIT09IGZhbHNlKXtcbiAgICBcdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgXHRcdFx0c2VhcmNoLmZpbHRlckNvbGxlY3Rpb24oIGNoaWxkcmVuW2ldLCBxdWVyeSApXG4gICAgXHRcdH1cbiAgICBcdH1cblxuICAgICAgaWYocXVlcnkpe1xuICAgICAgICBmdW5jdGlvbiBsb2FkZWQoKXtcbiAgICAgICAgICB2YXIga2V5cyA9IHRoaXMua2V5c1xuICAgICAgICAgIHZhciBmcm9tID0gdGhpcy5mcm9tXG4gICAgICAgICAgcmV0dXJuIGtleXMgJiYga2V5cy5sZW5ndGggPiAyXG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBkb25lKCl7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltqXVxuICAgICAgICAgICAgY2hpbGQuZGlzcGxheSA9IGNoaWxkLmZpbHRlci5sZW5ndGggPyAnYmxvY2snIDogJ25vbmUnXG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0b3BSZXN1bHQgPSBzZWFyY2gudG9wUmVzdWx0KCBjaGlsZHJlbiApXG4gICAgICAgICAgaWYoIHRvcFJlc3VsdCApe1xuICAgICAgICAgICAgcmVzdWx0cy5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICAgICAgcmVzdWx0cy50b3ByZXN1bHQuZGF0YSA9IHRvcFJlc3VsdFxuICAgICAgICAgICAgaWYoX3RoaXMubWVzc2FnZSl7XG4gICAgICAgICAgICAgIF90aGlzLm1lc3NhZ2UucmVtb3ZlKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHJlc3VsdHMuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgX3RoaXMuc2V0KHtcbiAgICAgICAgICAgICAgbWVzc2FnZTpuZXcgTm9SZXN1bHRzKClcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hlbihbXG4gICAgICAgICAgY29udGVudC5nZXQoJ21vdmllcycpLmlzKGxvYWRlZCksXG4gICAgICAgICAgY29udGVudC5nZXQoJ2FjdG9ycycpLmlzKGxvYWRlZCksXG4gICAgICAgICAgY29udGVudC5nZXQoJ3NlcmllcycpLmlzKGxvYWRlZCksXG4gICAgICAgICAgY29udGVudC5nZXQoJ2NoYW5uZWxzJykuaXMobG9hZGVkKVxuICAgICAgICBdKS5kb25lKGRvbmUpXG4gICAgICB9ZWxzZXtcbiAgICAgICAgcmVzdWx0cy5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgIHRoaXMuc2V0KHtcbiAgICAgICAgICBtZXNzYWdlOm5ldyBTdGFydFNlYXJjaGluZygpXG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICB9LFxuICAgICRtdXRlZDpmdW5jdGlvbih2YWwpe1xuICAgICAgdGhpcy5yZXN1bHRzLnRvcHJlc3VsdC5ib2R5LmNvbnRhaW5lci50cmFpbGVyLiRtdXRlZCA9IHZhbC52YWxcbiAgICB9XG4gIH0sXG4gIHNlYXJjaGJveDp7XG4gIFx0c2VhcmNoaWNvbjpuZXcgSWNvbih7XG4gIFx0XHRpY29uOidzZWFyY2gnXG4gIFx0fSksXG4gIFx0J3F1ZXJ5LnRleHQnOicnXG4gIH0sXG4gIHJlc3VsdHM6e1xuICBcdGxpc3Q6bmV3IHNlYXJjaC5SZXN1bHRMaXN0KCksXG4gIFx0dG9wcmVzdWx0OntcbiAgXHRcdG1vZGVsOntpbmhlcml0OmZhbHNlfSxcbiAgXHRcdGhlYWRlcjp7XG4gIFx0XHRcdHRleHQ6e1xuICBcdFx0XHRcdC8vIGRhdGE6J3RpdGxlJyxcbiAgXHRcdFx0XHRwcmVwZW5kOidUb3AgUmVzdWx0Jy8vIC0gJ1xuICBcdFx0XHR9XG4gIFx0XHR9LFxuICBcdFx0Ym9keTp7XG4gIFx0XHRcdGNvbnRhaW5lcjp7XG4gIFx0XHRcdFx0dHJhaWxlcjpuZXcgVHJhaWxlcigpLFxuICBcdFx0XHRcdGluZm86e1xuICBcdFx0XHRcdFx0J3RpdGxlLnRleHQuZGF0YSc6J3RpdGxlJyxcbiAgICAgICAgICAgIHN1YnRpdGxlOm5ldyBTdWJ0aXRsZSgpXG4gIFx0XHRcdFx0fVxuICBcdFx0XHR9LFxuICBcdFx0XHQnZGVzY3JpcHRpb24udGV4dC5kYXRhJzonZGVzY3JpcHRpb24nXG4gIFx0XHR9XG4gIFx0fVxuICB9XG59KS5DbGFzc1xuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcblxubW9kdWxlLmV4cG9ydHMgPSBhcHAuY2FzZXMuJGlzVGFibGV0IFxuPyBuZXcgRWxlbWVudCh7XG4gICAgY3NzOidzZWNvbmQtc3RhdHVzYmFyIGJyYW5kZWQnLFxuICAgIHk6e1xuICAgICAgdHJhbnNsYXRlOnRydWUsXG4gICAgICB2YWw6ODAsXG4gICAgICBtdWx0aXBseTphcHAuaGlkZVN0YXR1c2JhclxuICAgIH0sXG4gICAgcGFydG5lcjp7XG4gICAgICBsb2dvOnt9XG4gICAgfSxcbiAgICB3ZWF0aGVyOntcbiAgICAgIGFkZDpuZXcgSWNvbih7aWNvbjond2VhdGhlcid9KSxcbiAgICAgIHRleHQ6J1BhcnRpYWxseSBDbG91ZGVkJ1xuICAgIH0sXG4gICAgZXRhOntcbiAgICAgIGFkZDpuZXcgSWNvbih7aWNvbjonYWlycGxhbmUnfSksXG4gICAgICB0ZXh0OidUaW1lIHRvIExvcyBBbmdlbGVzOiA2aHInXG4gICAgfSxcbiAgICBiZXR3ZWVuOnt9LFxuICAgIGRpcmVjdHY6e1xuICAgICAgbG9nbzp7fVxuICAgIH1cbiAgfSkuQ2xhc3NcbjogbmV3IEVsZW1lbnQoe1xuICAgIGNzczonc2Vjb25kLXN0YXR1c2JhcicsXG4gICAgeTp7XG4gICAgXHR0cmFuc2xhdGU6dHJ1ZSxcbiAgICAgIHZhbDo4MCxcbiAgICAgIG11bHRpcGx5OmFwcC5oaWRlU3RhdHVzYmFyXG4gICAgfSxcbiAgICBkaXJlY3R2OntcbiAgICAgIGxvZ286e31cbiAgICB9LFxuICAgIHNlbmRlcjp7XG4gICAgICBpY29uOm5ldyBJY29uKHtpY29uOidwaG9uZSd9KSxcbiAgICAgIHRpdGxlOnt0ZXh0Oidjb250cm9sbGVkIGJ5IGlQaG9uZSd9XG4gICAgfVxuICB9KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBWaWRlbyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2VsZW1lbnQvdmlkZW8nKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBBU1NFVFMgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKS5wb2ludGVycy5hc3NldHNcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIE11dGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9tdXRlJylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3NlY29uZC10cmFpbGVyJyxcbiAgJ2V4dGVuZC4kbXV0ZWQnOmZ1bmN0aW9uKCl7fSxcbiAgJG11dGVkOnRydWUsXG4gIHZpZGVvOm5ldyBWaWRlbyh7XG4gICAgcGxheWVyOiByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvL2h0bWw1JyksXG4gICAgc3JjOntcbiAgICAgIGRhdGE6ICd0cmFpbGVyJyxcbiAgICAgIHByZXBlbmQ6IEFTU0VUU1xuICAgIH0sXG4gICAgZHVyYXRpb246IHRydWUsXG4gICAgdm9sdW1lOntcbiAgICAgIHBhcmVudDonJG11dGVkJyxcbiAgICAgIG11bHRpcGx5Oi0xLFxuICAgICAgYWRkOjFcbiAgICB9LFxuICAgIGxvb3A6IHRydWUsXG4gICAgYXV0b3BsYXk6IHRydWVcbiAgfSksXG4gIGxvZ286bmV3IEltZyh7XG4gICAgJ2JhY2tncm91bmQuZGF0YSc6J2ltZy5sb2dvJ1xuICB9KSxcbiAgbXV0ZWQ6bmV3IE11dGUoe1xuICAgIGljb246e1xuICAgICAgcGFyZW50OickbXV0ZWQnXG4gICAgfVxuICB9KVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgYXBwID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2FwcCcpXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyJylcbnZhciBJdGVtID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9pdGVtJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIENvbnRlbnQgPSByZXF1aXJlKCcuLi9jb250ZW50JylcbnZhciBTdWJ0aXRsZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3N1YnRpdGxlJylcbnZhciBUaXRsZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3RpdGxlJylcbnZhciBCaW8gPSByZXF1aXJlKCcuLi9iaW8nKVxuXG52YXIgT3ZlcnZpZXcgPSBuZXcgQ29udGVudCh7XG4gIGNzczonb3ZlcnZpZXcnLFxuICBjb250YWluZXI6e1xuICAgIHRvcDoge1xuICAgICAgJ2xlZnQucG9zdGVyJzpuZXcgSXRlbS5Qb3N0ZXIoe1xuICAgICAgICAnaW1nLmJhY2tncm91bmQnOntcbiAgICAgICAgICBhZGQ6e1xuICAgICAgICAgICAgZGF0YTonc2hvdy5pbWcucG9zdGVyJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pLFxuICAgICAgcmlnaHQ6IHtcbiAgICAgICAgdGl0bGU6bmV3IFRpdGxlKCksXG4gICAgICAgIHN1YnRpdGxlOm5ldyBTdWJ0aXRsZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICAnZGVzY3JpcHRpb24udGV4dC5kYXRhJzogJ2Rlc2NyaXB0aW9uJyxcbiAgICBzdGFycmluZzoge1xuICAgICAgZGlzcGxheTp7XG4gICAgICAgIHZhbDonYmxvY2snLFxuICAgICAgICB3aGVuOntkYXRhOidhY3RvcnMnfSxcbiAgICAgICAgb3I6J25vbmUnXG4gICAgICB9LFxuICAgICAgJ2hlYWRlci50ZXh0JzogJ1N0YXJyaW5nJyxcbiAgICAgICdhY3RvcnMuY29sbGVjdGlvbic6IHtcbiAgICAgICAgZGF0YTogJ2FjdG9ycycsXG4gICAgICAgIGVsZW1lbnQ6IEl0ZW0uUG9zdGVyXG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG52YXIgUHJldmlldyA9IG5ldyBDb250ZW50KHtcbiAgY3NzOidwcmV2aWV3JyxcbiAgJ2NvdmVyLmJnLmJhY2tncm91bmQnOntcbiAgICBkYXRhOiAnaW1nLmNvdmVyLjEnLFxuICAgIGFkZDp7XG4gICAgICBkYXRhOidzaG93LmltZy5jb3Zlci4yJ1xuICAgIH1cbiAgfSxcbiAgJ2NvbnRhaW5lci5pbmZvJzoge1xuICAgIHRpdGxlOm5ldyBUaXRsZS5TaG93KCksXG4gICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKCksXG4gICAgJ2Rlc2NyaXB0aW9uLnRleHQuZGF0YSc6ICdkZXNjcmlwdGlvbidcbiAgfVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgU3dpdGNoZXIoe1xuICBjc3M6ICdzZWNvbmQtdm9kJyxcbiAgb25UcmFuc2l0aW9uOidmYWRlJyxcbiAgZXh0ZW5kOntcbiAgICAkYWN0aXZlOmZ1bmN0aW9uKHZhbCl7XG4gICAgICBpZih0aGlzLl9zd0VsZW0pIHRoaXMuX3N3RWxlbS4kYWN0aXZlID0gdmFsLnZhbFxuICAgIH0sXG4gICAgJGNvbXBsZXRlOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgIHZhciBjb21wbGV0ZSA9IHZhbC52YWxcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhXG4gICAgICB2YXIgaXNFcGlzb2RlID0gZGF0YS5fY29udGVudFR5cGUgPT09ICdlcGlzb2RlcydcblxuICAgICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgICAgZGF0YTogZGF0YS5mcm9tLFxuICAgICAgICAkYWN0aXZlOnRoaXMuJGFjdGl2ZVxuICAgICAgfVxuXG4gICAgICBpZiAoY29tcGxldGUgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0ge1xuICAgICAgICAgIC8vIGVsZW1lbnQ6IGlzRXBpc29kZSA/IEVwaXNvZGVPdmVydmlldyA6IE92ZXJ2aWV3LFxuICAgICAgICAgIGVsZW1lbnQ6IE92ZXJ2aWV3LFxuICAgICAgICAgICRwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNvbXBsZXRlID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgLy8gZWxlbWVudDogaXNFcGlzb2RlID8gRXBpc29kZVByZXZpZXcgOiBQcmV2aWV3LFxuICAgICAgICAgIGVsZW1lbnQ6IFByZXZpZXcsXG4gICAgICAgICAgJHBhcmFtczogcGFyYW1zXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgICRwb3B1cDpmdW5jdGlvbih2YWwpe1xuICAgICAgdmFyIGRhdGEgPSB2YWwudmFsXG4gICAgICBpZihkYXRhICYmIHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyl7XG4gICAgICAgIHRoaXMudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICBlbGVtZW50OkJpbyxcbiAgICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICAgIGRhdGE6ZGF0YS5mcm9tXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9ZWxzZXtcbiAgICAgICAgaWYodGhpcy4kY29tcGxldGUpIHRoaXMuJGNvbXBsZXRlLnVwZGF0ZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBkYXRhOmZ1bmN0aW9uKHZhbCl7XG4gICAgICBpZih0aGlzLl9zd0VsZW0gJiYgIXRoaXMuX3N3RWxlbS5zd2l0Y2hlcil7XG4gICAgICAgIHRoaXMuX3N3RWxlbS5kYXRhID0gdmFsLnZhbFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgJGFjdGl2ZTp0cnVlXG59KS5DbGFzc1xuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIFZpZGVvID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC92aWRlbycpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nJylcbnZhciBJY29uID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG52YXIgTXBhYSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL21wYWEnKVxudmFyIFJhdGluZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3JhdGluZycpXG52YXIgU2NvcmUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdGF0aXN0aWNzJykuU2NvcmVcblxuZXhwb3J0cy5Ud2l0dGVyID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICd0d2l0dGVyLXdpZGdldCcsXG4gICdoZWFkZXIudGV4dCc6ICdUd2VldHMnLFxuICAndHdlZXRzLmNvbGxlY3Rpb24nOiB7XG4gICAgZGF0YTogJ2d1aWRlLjAudHdlZXRzJyxcbiAgICBlbGVtZW50OiBuZXcgRWxlbWVudCh7XG4gICAgICBjc3M6ICd0d2VldCcsXG4gICAgICBiaXJkOiBuZXcgSWNvbih7aWNvbjondHdpdHRlcid9KSxcbiAgICAgICdhdXRob3IudGV4dC5kYXRhJzogJ2F1dGhvcicsXG4gICAgICAnYm9keS50ZXh0LmRhdGEnOiAnYm9keSdcbiAgICB9KVxuICB9XG59KS5DbGFzc1xuXG5leHBvcnRzLkd1aWRlID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICdndWlkZS13aWRnZXQnLFxuICAnaGVhZGVyLnRleHQnOiAnR3VpZGUnLFxuICAncHJvZ3JhbXMuY29sbGVjdGlvbic6IHtcbiAgICBkYXRhOiAnZ3VpZGUnLFxuICAgIGVsZW1lbnQ6IG5ldyBFbGVtZW50KHtcbiAgICAgIGNzczogJ3Byb2dyYW0nLFxuICAgICAgJ3RpdGxlLnRleHQuZGF0YSc6ICd0aXRsZScsXG4gICAgICBwcm9ncmVzczoge1xuICAgICAgICAnc3RhcnQudGV4dC5kYXRhJzogJ3N0YXJ0LXRpbWUnLFxuICAgICAgICAnZGFzaC50ZXh0JzogJyAtICcsXG4gICAgICAgICdiYXIuc2Vlayc6IHt9LFxuICAgICAgICAnZW5kLnRleHQuZGF0YSc6ICdlbmQtdGltZSdcbiAgICAgIH1cbiAgICB9KVxuICB9XG59KS5DbGFzc1xuXG52YXIgUG9sbGVyID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICdwb2xsZXInLFxuICAnbGVmdC5sb2dvJzogbmV3IEltZygpLFxuICByaWdodDoge1xuICAgICd0aXRsZS50ZXh0LmRhdGEnOiAndGl0bGUnLFxuICAgIGJhcjoge1xuICAgICAgJ2V4dGVuZC4kYm9yZGVyVG9wQ29sb3InOiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYodmFsLnZhbCkgdGhpcy5ub2RlLnN0eWxlLmJvcmRlclRvcENvbG9yID0gdmFsLnZhbFxuICAgICAgfSxcbiAgICAgICckYm9yZGVyVG9wQ29sb3IuZGF0YSc6ICdjb2xvcicsXG4gICAgICB3OiB7XG4gICAgICAgIGRhdGE6ICd2b3RlcycsXG4gICAgICAgIGRpdmlkZTogMTAwMDAsXG4gICAgICAgIG11bHRpcGx5OiAxMDAsXG4gICAgICAgIGFkZDogJyUnXG4gICAgICB9XG4gICAgfSxcbiAgICAnc3VidGl0bGUudGV4dCc6IHtcbiAgICAgIGRhdGE6ICd2b3RlcycsXG4gICAgICBhZGQ6ICcgVk9URVMnXG4gICAgfVxuICB9LFxuICBzZXRTZXR0aW5nOiB7XG4gICAgbmFtZTogJ2JpbmR2b3RlcycsXG4gICAgcGFyZW50OiBmdW5jdGlvbihwYXJlbnQpIHtcbiAgICAgIHRoaXMucmlnaHQuYmFyLncgPSB7XG4gICAgICAgIGRpdmlkZTogcGFyZW50Lm9uXG4gICAgICB9XG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG52YXIgUG9sbCA9IG5ldyBFbGVtZW50KHtcbiAgb246IHsgLy8gc3RvcmUgdGhlIHRvdGFsdm90ZXNcbiAgICBkYXRhOiAncG9sbC4wLnZvdGVzJyxcbiAgICAnYWRkLmRhdGEnOiAncG9sbC4xLnZvdGVzJ1xuICB9LFxuICBhcHBlbmQ6IFtcbiAgICBQb2xsZXIsIHtcbiAgICAgICdtb2RlbC5maWVsZCc6ICdwb2xsLjAnXG4gICAgfSwge1xuICAgICAgJ21vZGVsLmZpZWxkJzogJ3BvbGwuMSdcbiAgICB9XG4gIF1cbn0pLkNsYXNzXG5cbmV4cG9ydHMuU3RhdHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3N0YXRzLXdpZGdldCcsXG4gICdoZWFkZXIudGV4dCc6ICdTdGF0aXN0aWNzJyxcbiAgY29udGFpbmVyOiB7XG4gICAgbW9kZWw6e2ZpZWxkOidndWlkZS4wJ30sXG4gICAgc2NvcmU6IG5ldyBTY29yZSgpLFxuICAgIGluZm86IHtcbiAgICAgICd0aXRsZS50ZXh0JzogJ1dobyB3aWxsIHdpbj8nLFxuICAgICAgJ3N1YnRpdGxlLnRleHQnOiAnVXNlIHBob25lIHRvIHZvdGUnXG4gICAgfSxcbiAgICBwb2xsOiBuZXcgUG9sbCgpXG4gIH1cbn0pLkNsYXNzXG5cbmV4cG9ydHMuQWJvdXQgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ2Fib3V0LXdpZGdldCcsXG4gICdoZWFkZXIudGV4dCc6ICdBYm91dCB0aGUgU2hvdycsXG4gIGNvbnRhaW5lcjoge1xuICAgIGltZzpuZXcgSW1nKHtcbiAgICAgICdiYWNrZ3JvdW5kLmRhdGEnOidpbWcudGh1bWInXG4gICAgfSksXG4gICAgaW5mbzp7XG4gICAgICAnbW9kZWwuZmllbGQnOidndWlkZS4wJyxcbiAgICAgIHRpdGxlczp7XG4gICAgICAgICd0aXRsZS50ZXh0LmRhdGEnOiAndGl0bGUnLFxuICAgICAgICAnc3VidGl0bGUudGV4dC5kYXRhJzogJ3N1YnRpdGxlJ1xuICAgICAgfSxcbiAgICAgIHN0aWNrZXJzOntcbiAgICAgICAgbXBhYTpuZXcgTXBhYSgpLFxuICAgICAgICByYXRpbmc6IG5ldyBSYXRpbmcoKVxuICAgICAgfVxuICAgIH0sXG4gICAgJ2Rlc2NyaXB0aW9uLnRleHQuZGF0YSc6J2d1aWRlLjAuZGVzY3JpcHRpb24nXG4gIH1cbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgUG9zdGVyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvbGlzdC9pdGVtJykuUG9zdGVyXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3VpLWFjdG9ycycsXG4gIGRpc3BsYXk6e1xuICAgIGRhdGE6J2FjdG9ycycsXG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsY3Ype1xuICAgICAgcmV0dXJuIGN2ID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgIH1cbiAgfSxcbiAgaGVhZGVyOiB7IHRleHQ6ICdTdGFycmluZycgfSxcbiAgYm9keToge1xuICAgIHNjcm9sbGJhcjogJ3gnLFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGRhdGE6ICdhY3RvcnMnLFxuICAgICAgZWxlbWVudDogbmV3IFBvc3Rlcih7XG4gICAgICAgICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFwcC5wb3B1cC4kdXNlck9yaWdpbiA9IHRoaXMuZGF0YS5mcm9tXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3VpLWJhcidcbn0pLkNsYXNzIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG5cbnZhciBEZXNjcmlwdGlvbiA9IG5ldyBFbGVtZW50KHtcblx0Y3NzOid1aS1kZXNjcmlwdGlvbicsXG4gIGhlYWRlcjogeyB0ZXh0OiAnRGVzY3JpcHRpb24nIH0sXG4gIGJvZHk6IHtcbiAgICB0ZXh0OiB7IGRhdGE6ICdkZXNjcmlwdGlvbicgfVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlc2NyaXB0aW9uXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG4gICwgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG4gICwgaWNvbiA9IG5ldyBFbGVtZW50KHsgY3NzOid1aS1pY29uJyB9KVxuICAsIG1hcCA9XG4gICAgeyBkaXNjb3ZlcjonXFx1ZTYwMCdcbiAgICAsIHNob3dzOidcXHVlNjAxJ1xuICAgICwgdHY6J1xcdWU2MDInXG4gICAgLCBzZXR0aW5nczonXFx1ZTYwMydcbiAgICAsIGNhc3Q6J1xcdWU2MDQnXG4gICAgLCBkZXNrdG9wOidcXHVlNjAyJ1xuICAgICwgcGxheTonXFx1ZTYwNSdcbiAgICAsIHBhdXNlOidcXHVlNjA2J1xuICAgICwgZnVsbHNjcmVlbjonXFx1ZTYwNydcbiAgICAsIGV4aXRmdWxsc2NyZWVuQWx0OidcXHVlNjA4J1xuICAgICwgcHVsbGJhY2s6J1xcdWU2MDknXG4gICAgLCBzd2lwZXVwOidcXHVlNjBhJ1xuICAgICwgYWxsQ2hhbm5lbHM6J1xcdWU2MGInXG4gICAgLCBkaXNjb25uZWN0ZWQ6J1xcdWU2MGMnXG4gICAgLCBtZW51OidcXHVlNjBkJ1xuICAgICwgSUZFOidcXHVlNjBlJ1xuICAgICwgYmFjazonXFx1ZTYwZidcbiAgICAsIGNsb3NlU21hbGw6J1xcdWU2MTAnXG4gICAgLCBjbG9zZTonXFx1ZTYxMSdcbiAgICAsIHdyb25nOidcXHVlNjEyJ1xuICAgICwgY29ycmVjdDonXFx1ZTYxMydcbiAgICAsIGZhY2Vib29rOidcXHVlNjE0J1xuICAgICwgdHdpdHRlcjonXFx1ZTYxNSdcbiAgICAsIHBob25lOidcXHVlNjE2J1xuICAgICwgdGFibGV0OidcXHVlNjE3J1xuICAgICwgdm9sdW1lOidcXHVlNjE4J1xuICAgICwgbXV0ZWQ6J1xcdWU2MTknXG4gICAgLCBwYXVzZUFsdDonXFx1ZTYxYSdcbiAgICAsIHBsYXlBbHQ6J1xcdWU2MWInXG4gICAgLCByZXdpbmQ6J1xcdWU2MWMnXG4gICAgLCBmYXN0Zm9yd2FyZDonXFx1ZTYxZCdcbiAgICAsIHByb2ZpbGU6J1xcdWU2MWUnXG4gICAgLCBkcm9wZG93bjonXFx1ZTYxZidcbiAgICAsIHJpZ2h0TmF2OidcXHVlNjIwJ1xuICAgICwgbGVmdE5hdjonXFx1ZTYyMSdcbiAgICAsIHJpZ2h0OidcXHVlNjIyJ1xuICAgICwgc2VhcmNoOidcXHVlNjIzJ1xuICAgICwgbm9SZXN1bHQ6J1xcdWU2MjQnXG4gICAgLCBzZWFyY2hNZW51OidcXHVlNjI1J1xuICAgICwgZXBnOidcXHVlNjI2J1xuICAgICwgdXBOYXY6J1xcdWU2MjcnXG4gICAgLCBkb3duTmF2OidcXHVlNjI4J1xuICAgICwgbWVudVJpZ2h0OidcXHVlNjI5J1xuICAgICwgYWlycGxhbmU6J1xcdWU2MmEnXG4gICAgLCBtdXRlZEFsdDonXFx1ZTYyYidcbiAgICAsIGxvY2tlZDonXFx1ZTYyYydcbiAgICAsIHdlYXRoZXI6J1xcdWU2MmQnXG4gICAgLCBlbXB0eTonICdcbiAgICB9XG5cbmljb24uZXh0ZW5kKHtcbiAgaWNvbjogZnVuY3Rpb24odmFsKSB7XG4gICAgdmFyIG5hbWUgPSBtYXBbdmFsLnZhbF1cbiAgICBpZihuYW1lKSB7XG4gICAgICB2YXIgdiA9ICc8c3Bhbj4nICsgbmFtZSArICc8L3NwYW4+JyxcbiAgICAgICAgdmFsdWUgPSB0aGlzLm5vZGUuaW5uZXJIVE1MLFxuICAgICAgICBkaXZpbmRleCA9IHZhbHVlLmluZGV4T2YoJzxkaXYnKVxuICAgICAgaWYofmRpdmluZGV4KSB2ICs9IHZhbHVlLnNsaWNlKGRpdmluZGV4KVxuICAgICAgdGhpcy5odG1sID0gdjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignaWNvbiBlcnJvcjogJywgdmFsLnZhbCwgJyBpcyBub3QgZGVmaW5lZCcpXG4gICAgfVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBpY29uLkNsYXNzXG5leHBvcnRzLm1hcCA9IG1hcFxuIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIEFTU0VUUyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpLnBvaW50ZXJzLmFzc2V0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgb3BhY2l0eTogMCxcbiAgYmFja2dyb3VuZDoge1xuICAgIGRhdGE6J2ltZycsXG4gICAgcHJlcGVuZDpBU1NFVFMsXG4gICAgbG9hZDogZnVuY3Rpb24odCkge1xuICAgICAgaWYodGhpcy4kd2FpdCAmJiB0aGlzLiR3YWl0LnZhbCl7XG4gICAgICAgIHRoaXMuJHdhaXQub25jZShmYWxzZSxmdW5jdGlvbigpe1xuICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xvYWRlZCA9IHRydWVcbiAgICAgIHQuX2xvYWRlZCA9IHRydWVcbiAgICB9XG4gIH0sXG4gICdleHRlbmQuJHdhaXQnOmZ1bmN0aW9uKCl7fVxufSkuQ2xhc3MiLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBMaXN0ID0gcmVxdWlyZSgnLi8nKVxudmFyIEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBMaXN0KHtcbiAgY29sbGVjdGlvbjoge1xuICAgIGRhdGE6ICdpdGVtcycsXG4gICAgZWxlbWVudDpJdGVtLkNoYW5uZWxcbiAgfVxufSkuQ2xhc3MiLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBfZm9jdXNlZCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3V0aWwnKS5mb2N1c2VkXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J2xpc3QtZG90cycsXG4gIGNvbnRhaW5lcjp7XG4gICAgY29sbGVjdGlvbjp7XG4gICAgICBkYXRhOidzcG90bGlnaHQuaXRlbXMnLFxuICAgICAgZWxlbWVudDpuZXcgRWxlbWVudCgpXG4gICAgfSxcbiAgICAnZXh0ZW5kLiRmb2N1cyc6IGZ1bmN0aW9uKCB2YWwgKSB7XG4gICAgICAvLyBhbGVydCh0eXBlb2YgdmFsLnZhbCA9PT0gJ3N0cmluZycpXG4gICAgICB2YXIgY2hpbGQgPSB0eXBlb2YgdmFsLnZhbCA9PT0gJ3N0cmluZydcbiAgICAgICAgPyB0aGlzW3ZhbC52YWxdXG4gICAgICAgIDogdGhpcy5jaGlsZHJlblsgdmFsLnZhbCB8fCAwIF1cbiAgICAgIF9mb2N1c2VkKCB0aGlzLCBjaGlsZCApXG4gICAgfSxcbiAgICBtb2RlbDp7IGNvbXBsZXRlOmZ1bmN0aW9uKCl7XG4gICAgICBpZiggdGhpcy5jaGlsZHJlblswXSApe1xuICAgICAgICBpZih0aGlzLiRmb2N1cykgdGhpcy4kZm9jdXMudXBkYXRlKClcbiAgICAgICAgdGhpcy5tb2RlbCA9IHsgY29tcGxldGU6bnVsbCB9XG4gICAgICB9XG4gICAgfX1cbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCAnLi9zdHlsZS5sZXNzJyApXG5cbnZhciBjYXNlcyA9IHJlcXVpcmUoICd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycgKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgdXRpbCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3V0aWwnKVxudmFyIF9mb2N1c2VkID0gdXRpbC5mb2N1c2VkXG52YXIgX3ByZXZlbnRBbmltYXRpb24gPSB1dGlsLnByZXZlbnRBbmltYXRpb25cblxudmFyIEJhc2UgPSBuZXcgRWxlbWVudCgge1xuICBjc3M6ICdiYXNlLWxpc3QnLFxuICBtb2RlbDogZnVuY3Rpb24oKSB7XG5cbiAgICBpZiAoIHRoaXMuY2hpbGRyZW5bIDAgXSApIHtcbiAgICAgIGlmKCAhdGhpcy4kZm9jdXMgKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RoaXMgbGlzdCBuZWVkcyBhICRmb2N1cyB2YWx1ZSEnKVxuICAgICAgICAvLyB0aGlzLiRmb2N1cyA9IDBcbiAgICAgIH1cbiAgICAgIF91cGRhdGVYKHRoaXMpXG4gICAgICB0aGlzLiRmb2N1cy51cGRhdGUoKVxuICAgICAgdGhpcy5tb2RlbCA9IGZhbHNlXG4gICAgfVxuICB9LFxuICBzZXRTZXR0aW5nOiB7XG4gICAgbmFtZTogJ3VwZGF0ZVgnLFxuICAgIHBhcmVudDogZnVuY3Rpb24oKSB7XG4gICAgICBfdXBkYXRlWCh0aGlzKVxuICAgIH1cbiAgfSxcbiAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oKXtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRcbiAgICBpZihwYXJlbnQucGFyZW50LiRmb2N1cykgcGFyZW50LnBhcmVudC4kZm9jdXMuZnJvbSA9IHBhcmVudC5fbmFtZVxuICAgIC8vIGNvbnNvbGUuZXJyb3IoJ3RoaXMhJyx0aGlzLnBhcmVudC5wYXJlbnQpXG4gIH1cbn0gKS5DbGFzc1xuXG52YXIgTGlzdCA9IG5ldyBCYXNlKCB7XG4gICdleHRlbmQuJGZvY3VzJzogZnVuY3Rpb24oIHZhbCApIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzXG4gICAgdmFyIG4gPSB2YWwudmFsIHx8IDBcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5wYXJlbnRcbiAgICBcbiAgICBfZm9jdXNlZCggdGhpcywgdGhpcy5jaGlsZHJlblsgbiBdIClcbiAgICBfYm91bmNlKCB0aGlzIClcblxuICAgIGlmKCAhY2FzZXMuJGlzUGhvbmUgJiYgcGFyZW50ICl7XG4gICAgICBcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlXG4gICAgICB2YXIgcGFyZW50VG9wID0gcGFyZW50Lm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICBpZihfdGhpcy5yYWZJZCkgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKF90aGlzLnJhZklkKVxuICAgICAgZnVuY3Rpb24gY2hlY2soKXtcbiAgICAgICAgdmFyIHRvcCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgIGlmKCF0b3AgfHwgdG9wID09PSBwYXJlbnRUb3ApIHtcbiAgICAgICAgICBfdGhpcy54ID0ge1xuICAgICAgICAgICAgbXVsdGlwbHk6IC1uXG4gICAgICAgICAgfVxuICAgICAgICAgIF90aGlzLnJhZklkID0gbnVsbFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBfdGhpcy5yYWZJZCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2hlY2spXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNoZWNrKClcblxuICAgIH1lbHNle1xuICAgICAgdGhpcy54ID0ge1xuICAgICAgICBtdWx0aXBseTogLW5cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHg6IHtcbiAgICB0cmFuc2xhdGU6IHRydWUsXG4gICAgdmFsOjAsXG4gICAgbXVsdGlwbHk6IDAsXG4gICAgZGVmZXI6IF9kZWZlclxuICB9LFxuICB5OntcbiAgICB0cmFuc2xhdGU6dHJ1ZSxcbiAgICB2YWw6MFxuICB9LFxuICAkaXNQaG9uZToge1xuICAgIHg6IHtcbiAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICB0aW1lOiAyNCxcbiAgICAgICAgZWFzaW5nOiAnb3V0Q3ViaWMnXG4gICAgICB9XG4gICAgfSxcbiAgICAnZXZlbnRzLmdyYWInOiB7XG4gICAgICB4OiB0cnVlLFxuICAgICAgcGFzczogX3Bhc3MsXG4gICAgICBtb3ZlOiBfaGlnaGxpZ2h0LFxuICAgICAgdXA6IF9wb3NpdGlvblxuICAgIH1cbiAgfVxufSApLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGNhc2VzLiRpc1Bob25lID8gbmV3IEJhc2UoIHtcbiAgLy8gbW9kZWw6ZnVuY3Rpb24oKXtcbiAgLy8gICBpZiAoIHRoaXMuY2hpbGRyZW5bIDAgXSApIHtcbiAgLy8gICAgIHZhciBuYW1lID0gdGhpcy5wYXJlbnQuX25hbWVcbiAgLy8gICAgIHZhciBzY3JvbGxMZWZ0ID0gZXhwb3J0c1tuYW1lXSAmJiBleHBvcnRzW25hbWVdLnNjcm9sbExlZnRcbiAgLy8gICAgIGlmKHNjcm9sbExlZnQpe1xuICAvLyAgICAgICBleHBvcnRzW25hbWVdLmlnbm9yZVNjcm9sbCA9IHRydWVcbiAgLy8gICAgICAgdGhpcy5ub2RlLnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0XG4gIC8vICAgICAgIGV4cG9ydHNbbmFtZV0uaWdub3JlU2Nyb2xsID0gZmFsc2VcbiAgLy8gICAgIH1lbHNle1xuICAvLyAgICAgICBpZiggIXRoaXMuJGZvY3VzICkge1xuICAvLyAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RoaXMgbGlzdCBuZWVkcyBhICRmb2N1cyB2YWx1ZSEnKVxuICAvLyAgICAgICAgIC8vIHRoaXMuJGZvY3VzID0gMFxuXG4gIC8vICAgICAgIH1cbiAgLy8gICAgICAgX3VwZGF0ZVgodGhpcylcbiAgLy8gICAgICAgdGhpcy4kZm9jdXMudXBkYXRlKClcbiAgLy8gICAgIH1cbiAgLy8gICAgIHRoaXMubW9kZWwgPSBmYWxzZVxuICAvLyAgIH1cbiAgLy8gfSxcbiAgJ2V4dGVuZC4kZm9jdXMnOiBmdW5jdGlvbiggdmFsICkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW5cbiAgICBfZm9jdXNlZCggdGhpcywgY2hpbGRyZW5bIHZhbC52YWwgfHwgMCBdIClcbiAgICBpZiAoICF0aGlzLm5vZGUuc2Nyb2xsTGVmdCAmJiB2YWwudmFsICkge1xuICAgICAgdGhpcy5ub2RlLnNjcm9sbExlZnQgPSB2YWwudmFsICogX3N0ZXAoIHRoaXMsIGNoaWxkcmVuIClcbiAgICB9XG4gIH0sXG4gIHNjcm9sbGJhcjogJ3gnLFxuICAnZXZlbnRzLnNjcm9sbCc6IGZ1bmN0aW9uKCBlICkge1xuICAgIC8vIHZhciBuYW1lID0gdGhpcy5wYXJlbnQuX25hbWVcbiAgICAvLyBpZighZXhwb3J0c1tuYW1lXSkgZXhwb3J0c1tuYW1lXSA9IHt9XG4gICAgLy8gZWxzZSBpZihleHBvcnRzW25hbWVdLmlnbm9yZVNjcm9sbCkgcmV0dXJuXG5cbiAgICBpZighdGhpcy5fY2hlY2tlZCl7IC8vYmxvY2sgdGhlIGZpcnN0XG4gICAgICB0aGlzLl9jaGVja2VkID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIF90aGlzID0gdGhpc1xuICAgIHZhciBub2RlID0gdGhpcy5ub2RlXG4gICAgdmFyIHNjcm9sbExlZnQgPSBub2RlLnNjcm9sbExlZnRcbiAgICB2YXIgZnJhY3Rpb24gPSBzY3JvbGxMZWZ0IC8gKCBub2RlLnNjcm9sbFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aCApXG4gICAgdmFyIGluZGV4ID0gTWF0aC5yb3VuZCggZnJhY3Rpb24gKiAoIF9sZW5ndGgoIHRoaXMgKSAtIDEgKSApXG4gICAgLy8gZXhwb3J0c1tuYW1lXS5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdFxuICAgIF90aGlzLiRmb2N1cy5mcm9tID0gaW5kZXhcbiAgfVxufSApLkNsYXNzIDogTGlzdFxuXG5leHBvcnRzLkNhcm91c2VsID0gTGlzdFxuZXhwb3J0cy5TcG90bGlnaHQgPSByZXF1aXJlKCAnLi9zcG90bGlnaHQnIClcbmV4cG9ydHMuQ2hhbm5lbCA9IHJlcXVpcmUoICcuL2NoYW5uZWwnIClcbmV4cG9ydHMuUG9zdGVyID0gcmVxdWlyZSggJy4vcG9zdGVyJyApXG5leHBvcnRzLldhdGNoaW5nID0gcmVxdWlyZSggJy4vd2F0Y2hpbmcnIClcbmV4cG9ydHMuRG90cyA9IHJlcXVpcmUoICcuL2RvdHMnIClcbmV4cG9ydHMuSXRlbSA9IHJlcXVpcmUoICcuL2l0ZW0nIClcblxudmFyIHRyZXNob2xkID0gNjBcbnZhciBmbGljayA9IDEwXG5cbmZ1bmN0aW9uIF9ib3VuY2UoIGxpc3QgKSB7XG4gIGlmICggbGlzdC54Ll9lICl7XG4gICAgbGlzdC54ID0ge1xuICAgICAgX2VzdWI6IGxpc3QueC5fZS5fdmFsXG4gICAgfVxuICAgIGxpc3QueC51cGRhdGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIF9oaWdobGlnaHQoIGUsIGQpe1xuICB2YXIgbGVuZ3RoID0gX2xlbmd0aCggdGhpcyApXG4gIHZhciBzdGVwID0gX3N0ZXAoIHRoaXMgKVxuICB2YXIgb2xkcG9zID0gdGhpcy5fc3RhcnRcbiAgdmFyIG5ld3BvcyA9IG9sZHBvc1xuICBpZiAoIGQueCA8IC10cmVzaG9sZCApIHtcbiAgICBuZXdwb3MgPSBNYXRoLm1heCggb2xkcG9zIC0gTWF0aC5jZWlsKCAoIC1kLnggKSAvIHN0ZXAgKSwgLWxlbmd0aCArIDEgKVxuICB9IGVsc2UgaWYgKCBkLnggPiB0cmVzaG9sZCApIHtcbiAgICBuZXdwb3MgPSBNYXRoLm1pbiggb2xkcG9zICsgTWF0aC5jZWlsKCBkLnggLyBzdGVwICksIDAgKVxuICB9XG4gIGlmKC1uZXdwb3MgIT09IHRoaXMuJGZvY3VzLnZhbCkgX3NldCggdGhpcywgbmV3cG9zIClcbn1cblxuZnVuY3Rpb24gX3Bhc3MoIGUsIGQgKSB7XG4gIGlmKE1hdGguYWJzKCBkLnggKSA+IE1hdGguYWJzKCBkLnkgKSl7XG4gICAgdGhpcy5fc3RhcnQgPSAtdGhpcy4kZm9jdXMudmFsIHx8IDBcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIF9wb3NpdGlvbiggZSwgZCwgbGQgKSB7IC8vIHVuaWZ5IHdpdGggc3dpdGNoZXJcbiAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlblxuICB2YXIgbGVuZ3RoID0gX2xlbmd0aCggdGhpcyApXG4gIHZhciBvbGRwb3MgPSB0aGlzLl9zdGFydCB8fCAwXG4gIHZhciBuZXdwb3NcbiAgdmFyIHN0ZXAgPSBfc3RlcCggdGhpcywgY2hpbGRyZW4gKVxuXG4gIGlmICggTWF0aC5hYnMoIGxkLnggKSA+IGZsaWNrICkge1xuICAgIGlmICggbGQueCA8IDAgJiYgZC54IDwgdHJlc2hvbGQgKSB7XG4gICAgICBuZXdwb3MgPSBNYXRoLm1heCggb2xkcG9zIC0gTWF0aC5jZWlsKCAoIC1kLnggKSAvIHN0ZXAgKSwgLWxlbmd0aCArIDEgKVxuICAgIH0gZWxzZSBpZiAoIGxkLnggPiAwICYmIGQueCA+IC10cmVzaG9sZCApIHtcbiAgICAgIG5ld3BvcyA9IE1hdGgubWluKCBvbGRwb3MgKyBNYXRoLmNlaWwoIGQueCAvIHN0ZXAgKSwgMCApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICggZC54IDwgLXRyZXNob2xkICkge1xuICAgICAgbmV3cG9zID0gTWF0aC5tYXgoIG9sZHBvcyAtIE1hdGguY2VpbCggKCAtZC54ICkgLyBzdGVwICksIC1sZW5ndGggKyAxIClcbiAgICB9IGVsc2UgaWYgKCBkLnggPiB0cmVzaG9sZCApIHtcbiAgICAgIG5ld3BvcyA9IE1hdGgubWluKCBvbGRwb3MgKyBNYXRoLmNlaWwoIGQueCAvIHN0ZXAgKSwgMCApXG4gICAgfVxuICB9XG5cbiAgaWYgKCBuZXdwb3MgIT09IHZvaWQgMCAmJiAtbmV3cG9zICE9PSB0aGlzLiRmb2N1cy52YWwgKSBfc2V0KCB0aGlzLCBuZXdwb3MgKVxuICBcbiAgX2JvdW5jZSggdGhpcyApXG59XG5cbmZ1bmN0aW9uIF9zdGVwKCBsaXN0LCBjaGlsZHJlbiwgY29ycmVjdGVkICkgeyAvLyB0aGlzIGNhbiBiZSBjbGVhbmVyXG4gIHZhciBub2RlXG5cbiAgaWYgKCAhY2hpbGRyZW4gKSBjaGlsZHJlbiA9IGxpc3QuY2hpbGRyZW5cbiAgaWYgKCBjaGlsZHJlblsgMCBdICkge1xuICAgIGlmICggIWxpc3QuX3N0ZXAgKSB7XG4gICAgICBub2RlID0gbGlzdC5ub2RlXG4gICAgICBsaXN0Ll9zdGVwID0gbm9kZS5zY3JvbGxXaWR0aCAvIF9sZW5ndGgoIGxpc3QgKSAvLyBcbiAgICB9XG4gICAgaWYgKCBjb3JyZWN0ZWQgKSB7XG4gICAgICBub2RlID0gbGlzdC5ub2RlXG4gICAgICByZXR1cm4gKCBub2RlLnNjcm9sbFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aCApIC8gKCBfbGVuZ3RoKCBsaXN0ICkgLSAxIClcbiAgICB9XG4gICAgcmV0dXJuIGxpc3QuX3N0ZXBcbiAgfVxufVxuXG5mdW5jdGlvbiBfbGVuZ3RoKCBfdGhpcyApe1xuICByZXR1cm4gX3RoaXMuY2hpbGRyZW4ubGVuZ3RoIC8vX3RoaXMuX2xlbmd0aCB8fCAoIF90aGlzLl9sZW5ndGggPSBfdGhpcy5jaGlsZHJlbi5sZW5ndGggKVxufVxuXG5mdW5jdGlvbiBfZGVmZXIoIHVwZGF0ZSwgYXJncyApIHtcbiAgdmFyIGxpc3QgPSB0aGlzLl9jYWxsZXJcbiAgdmFyIHN0ZXAgPSBfc3RlcCggbGlzdCwgbnVsbCwgdHJ1ZSApXG4gIGlmICggc3RlcCApIHtcbiAgICBpZighdGhpcy5fdmFsKSB0aGlzLnZhbCA9IHN0ZXBcbiAgICB0aGlzLl9mbGFnID0gbnVsbFxuICB9XG4gIHVwZGF0ZSgpXG59XG5cbmZ1bmN0aW9uIF91cGRhdGVYKCBfdGhpcyApe1xuICBpZiggX3RoaXMueCApe1xuICAgIF9wcmV2ZW50QW5pbWF0aW9uKF90aGlzLGZ1bmN0aW9uKCl7XG4gICAgICBfdGhpcy54Ll9wID0gdHJ1ZVxuICAgICAgX3RoaXMueC51cGRhdGUoKVxuICAgICAgX3RoaXMueC5fcCA9IG51bGxcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIF9zZXQoIF90aGlzLCBuZXdwb3MgKXtcbiAgdmFyIGZpZWxkID0gX3RoaXMuJGZvY3VzLl9mbGFnICYmIF90aGlzLiRmb2N1cy5fZmxhZy5kYXRhWzJdXG4gIHZhciBkYXRhID0gX3RoaXMuZGF0YVxuICBpZiggZmllbGQgJiYgZGF0YSApe1xuICAgIGRhdGEuZnJvbS5zZXQoZmllbGQsLW5ld3BvcylcbiAgfWVsc2UgX3RoaXMuJGZvY3VzLmZyb20gPSAtbmV3cG9zXG59IiwidmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pY29uJylcbnZhciBJbWcgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIFRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvdGl0bGUnKVxudmFyIFN1YnRpdGxlID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvc3VidGl0bGUnKVxudmFyIGJsb2NrZWQgPSAnYmxvY2tlZCdcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBpbWc6IG5ldyBJbWcoKSxcbiAgJ2V2ZW50cy5jbGljayc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBmb2N1cyA9IHRoaXMucGFyZW50LiRmb2N1c1xuICAgIGlmIChmb2N1cykgZm9jdXMuZnJvbSA9IHRoaXMuJGluZGV4XG4gICAgYXBwLnVzZXIubmF2aWdhdGlvbi5jb250ZW50LiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhLmZyb21cbiAgfSxcbiAgZXh0ZW5kOiBbe1xuICAgICAgbmFtZTogJyRpbmRleCcsXG4gICAgICB0eXBlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdmFyIHNpYmxpbmdzID0gdGhpcy5wYXJlbnQuY2hpbGRyZW5cbiAgICAgICAgICBmb3IgKHZhciBpID0gc2libGluZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHNpYmxpbmdzW2ldLl9pbmRleCA9IGlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgJGJsb2NrZWQ6IF9ibG9ja2VkXG4gICAgfV0sXG4gICckYmxvY2tlZC5kYXRhJzpibG9ja2VkXG59KS5DbGFzc1xuXG5leHBvcnRzLkluZm8gPSBuZXcgZXhwb3J0cyh7XG4gIGNzczogJ2luZm8taXRlbScsXG4gICdpbWcuYmFja2dyb3VuZC5kYXRhJzogJ2ltZy50aHVtYicsXG4gIGluZm86IHtcbiAgICB0aXRsZTogbmV3IFRpdGxlLlNob3coKSxcbiAgICBzdWJ0aXRsZTogbmV3IFN1YnRpdGxlKClcbiAgfVxufSkuQ2xhc3NcblxuZXhwb3J0cy5Qb3N0ZXIgPSBuZXcgZXhwb3J0cyh7XG4gIGNzczogJ3Bvc3Rlci1pdGVtJyxcbiAgJ2ltZy5iYWNrZ3JvdW5kLmRhdGEnOiAnaW1nLnBvc3RlcicsXG59KS5DbGFzc1xuXG5leHBvcnRzLkNoYW5uZWwgPSBuZXcgZXhwb3J0cy5JbmZvKHtcbiAgJ2xvZ28nOiBuZXcgSW1nKHtcbiAgICAnYmFja2dyb3VuZC5kYXRhJzogJ2ltZy5sb2dvJ1xuICB9KSxcbiAgJ2luZm8udGl0bGUudGV4dC5kYXRhJzogJ2d1aWRlLjAudGl0bGUnXG59KS5DbGFzc1xuXG5leHBvcnRzLkNhcm91c2VsID0gbmV3IEltZyh7XG4gIGNzczogJ3Nwb3RsaWdodC1pdGVtJyxcbiAgJ2V4dGVuZC4kYmxvY2tlZCc6IF9ibG9ja2VkLFxuICAnZXZlbnRzLmNsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgYXBwLnVzZXIubmF2aWdhdGlvbi5jb250ZW50LiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhLmZyb21cbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIGRhdGE6ICdpbWcuc3BvdGxpZ2h0J1xuICB9LFxuICAnJGJsb2NrZWQuZGF0YSc6YmxvY2tlZFxufSkuQ2xhc3NcblxuZnVuY3Rpb24gX2Jsb2NrZWQodmFsKXtcbiAgaWYodmFsLnZhbCl7XG4gICAgdGhpcy5hZGRFdmVudCgnY2xpY2snLGZ1bmN0aW9uKCl7XG4gICAgICAvLyBuZXcgQXVkaW8oJ2h0dHA6Ly93d3cubm9pc2VhZGRpY3RzLmNvbS9zYW1wbGVzXzF3NzJiODIwLzM3MzkubXAzJykucGxheSgpXG4gICAgICBhbGVydCgnVGhpcyBpdGVtIGlzIG5vdCBhdmFpbGFibGUnKVxuICAgIH0sYmxvY2tlZClcbiAgICB0aGlzLmNzcyA9IHsgYWRkQ2xhc3M6YmxvY2tlZCB9XG4gICAgdGhpcy5zZXQoe1xuICAgICAgbG9jazpuZXcgSWNvbih7aWNvbjonbG9ja2VkJ30pXG4gICAgfSlcbiAgfWVsc2V7XG4gICAgaWYodGhpcy5sb2NrKXtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnQoZmFsc2UsIGJsb2NrZWQpXG4gICAgICB0aGlzLmNzcyA9IHsgcmVtb3ZlQ2xhc3M6YmxvY2tlZCB9XG4gICAgICB0aGlzLmxvY2sucmVtb3ZlKClcbiAgICB9XG4gIH1cbn1cbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIExpc3QgPSByZXF1aXJlKCcuLycpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcCcpXG52YXIgSXRlbSA9IHJlcXVpcmUoJy4vaXRlbScpXG5cbkxpc3QuUG9zdGVyID0gbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IExpc3Qoe1xuICBjb2xsZWN0aW9uOiB7XG4gICAgZGF0YTogJ2l0ZW1zJyxcbiAgICBlbGVtZW50Om5ldyBJdGVtLlBvc3RlcigpXG4gIH1cbn0pLkNsYXNzXG5cbi8vIGV4cG9ydHMuZWxlbWVudCA9IGVsZW1lbnQiLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBMaXN0ID0gcmVxdWlyZSgnLi8nKVxudmFyIEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0nKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9jb21wb25lbnRzL3NoYXJlZC9pbWcnKVxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBMaXN0LkNhcm91c2VsKCB7XG4gIGNvbGxlY3Rpb246IHtcbiAgICBkYXRhOiAnaXRlbXMnLFxuICAgIGVsZW1lbnQ6SXRlbS5DYXJvdXNlbFxuICB9XG59ICkuQ2xhc3MiLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBMaXN0ID0gcmVxdWlyZSgnLi8nKVxudmFyIEl0ZW0gPSByZXF1aXJlKCcuL2l0ZW0nKVxudmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBMaXN0KHtcbiAgY29sbGVjdGlvbjoge1xuICAgIGRhdGE6ICdpdGVtcycsXG4gICAgZWxlbWVudDpuZXcgSXRlbS5JbmZvKHtcbiAgICAgIGJhcjp7XG4gICAgICAgIHc6e1xuICAgICAgICAgIGRhdGE6J3RpbWUnLFxuICAgICAgICAgIG11bHRpcGx5OjEwMCxcbiAgICAgICAgICBhYnM6dHJ1ZSxcbiAgICAgICAgICBhZGQ6JyUnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG59KS5DbGFzcyIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBTcHJpdGUgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL3Nwcml0ZScpXG4gICwgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG4gICwgY2FzZXMgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9jYXNlcycpXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IFNwcml0ZShcbnsgY3NzOid1aS1sb2FkZXInXG4sIHc6MzBcbiwgaDozMFxuLCBwYXJhbXM6eyBjb2xzOjEsIHJvd3M6MjYgfSAvLyBvbmNlOnRydWUgfVxufSkuQ2xhc3NcbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGJhY2tncm91bmQ6e1xuICAgIGRhdGE6J21wYWEnLFxuICAgIGFkZDp7ZGF0YTonc2hvdy5tcGFhJ30sXG4gICAgdHJhbnNmb3JtOmZ1bmN0aW9uKHYsIG1wYWEpe1xuICAgICAgaWYoIG1wYWEgKSByZXR1cm4gJ2Fzc2V0cy9pbWcvYXBwL21wYWFfJyArIG1wYWEudG9Mb3dlckNhc2UoKSArICcucG5nJ1xuICAgIH1cbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxubW9kdWxlLmV4cG9ydHMgPSBuZXcgSWNvbih7XG4gIGNzczondWktaWNvbiBzaGFyZWQtbXV0ZScsXG4gIGljb246e1xuICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIHJldHVybiBjdiA/ICdtdXRlZEFsdCcgOiAndm9sdW1lJ1xuICAgIH1cbiAgfVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBjb25maWcgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKVxudmFyIEJhciA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL3NlZWtiYXInKS5CYXJcblxudmFyIFZvdGVSb3cgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3VpLXZvdGVyb3cnLFxuICBsZWZ0OiB7XG4gICAgbG9nbzogeyBcbiAgICAgIGJhY2tncm91bmQ6IHsgXG4gICAgICAgIGRhdGE6ICdpbWcnLFxuICAgICAgICBwcmVwZW5kOiBjb25maWcucG9pbnRlcnMuYXNzZXRzXG4gICAgICB9LFxuICAgICAgJ2V2ZW50cy5jbGljayc6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuZGF0YS52b3Rlcy52YWwgKz0gMVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmlnaHQ6IHtcbiAgICBjb3VudDoge1xuICAgICAgbW9kZWw6ZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgIGlmKGRhdGEuX3BhcmVudCl7XG4gICAgICAgICAgdGhpcy5tb2RlbCA9IGZhbHNlXG4gICAgICAgICAgdGhpcy52b3RlZmlsbGVyLmRhdGEgPSBkYXRhLl9wYXJlbnRcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRlYW06IHsgdGV4dDogeyBkYXRhOiAndGl0bGUnIH0gfSxcbiAgICAgIHZvdGVzOiB7IHRleHQ6IHsgZGF0YTogJ3ZvdGVzJyAsYWRkOiAnIFZPVEVTJyB9IH0sXG4gICAgICB2b3RlZmlsbGVyOiBuZXcgQmFyKHtcbiAgICAgICAgc2Vlazoge1xuICAgICAgICAgIHc6e1xuICAgICAgICAgICAgZGF0YTp0cnVlLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBmdW5jdGlvbiggYywgY3YgKXtcbiAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5wYXJlbnQucGFyZW50XG4gICAgICAgICAgICAgIHZhciBteXZvdGVzID0gY291bnQuZGF0YSAmJiBjb3VudC5kYXRhLnZvdGVzICYmIGNvdW50LmRhdGEudm90ZXMudmFsXG4gICAgICAgICAgICAgIGlmKG15dm90ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdjEgPSBjdlswXS52b3Rlcy52YWxcbiAgICAgICAgICAgICAgICB2YXIgdjIgPSBjdlsxXS52b3Rlcy52YWxcbiAgICAgICAgICAgICAgICB2YXIgdG90YWwgPSB2MSArIHYyXG4gICAgICAgICAgICAgICAgcmV0dXJuICggbXl2b3RlcyAvIHRvdGFsICkgKiAxMDAgKyAnJSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2V4dGVuZC4kYmFja2dyb3VuZENvbG9yJzogZnVuY3Rpb24oIHZhbCApe1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5wYXJlbnQucGFyZW50XG4gICAgICAgICAgICB2YXIgbXljb2xvciA9IGNvdW50LmRhdGEgJiYgY291bnQuZGF0YS5jb2xvciAmJiBjb3VudC5kYXRhLmNvbG9yLnZhbFxuICAgICAgICAgICAgaWYobXljb2xvcikge1xuICAgICAgICAgICAgdGhpcy5ub2RlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG15Y29sb3JcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgICckYmFja2dyb3VuZENvbG9yLmRhdGEnOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG52YXIgUG9sbCA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAndWktcG9sbCcsXG4gIGRpc3BsYXk6e1xuICAgIHZhbDonYmxvY2snLFxuICAgIHdoZW46e2RhdGE6J3BvbGwuMC50aXRsZSd9LFxuICAgIG9yOidub25lJ1xuICB9LFxuICBoZWFkZXI6IHsgdGV4dDogeyBkYXRhOiAncG9sbC50aXRsZScgfSB9LFxuICBmaXJzdDogbmV3IFZvdGVSb3coe1xuICAgIG1vZGVsOiB7IGZpZWxkOiAncG9sbC4wJyB9XG4gIH0pLFxuICBzZWNvbmQ6IG5ldyBWb3RlUm93KHtcbiAgICBtb2RlbDogeyBmaWVsZDogJ3BvbGwuMScgfVxuICB9KVxufSkuQ2xhc3NcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsXG4iLCJ2YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIEljb24gPSByZXF1aXJlKCcuLi8uLi9zaGFyZWQvaWNvbicpXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicgKVxuICAgIC5pbmplY3QoIHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyL3RyYW5zaXRpb25zJyApIClcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3BvcHVwJyxcbiAgdG9wYmFyOntcbiAgICBsZWZ0Om5ldyBJY29uKHtpY29uOidsZWZ0J30pLFxuICAgIG1pZGRsZTogeyB0ZXh0Oidwb3B1cCcgfSxcbiAgICByaWdodDpuZXcgSWNvbih7XG4gICAgICBpY29uOidjbG9zZScsXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgY2xpY2s6ZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5wYXJlbnQucGFyZW50LnBvcHVwLiR1c2VyT3JpZ2luID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG4gIHc6YXBwLncsXG4gIGg6YXBwLmgsXG4gIHk6XG4gIHsgdmFsOjAsIFxuICAgIGFuaW1hdGlvbjpcbiAgICB7IHRpbWU6YXBwLmgudmFsIC8gMzBcbiAgICAsIHN0YXJ0OmFwcC5oXG4gICAgLCBlYXNpbmc6J291dEN1YmljJ1xuICAgICwgZG9uZTpmdW5jdGlvbihjdikge1xuICAgICAgICB2YXIgdCA9IHRoaXNcbiAgICAgICAgaWYoY3Y+PTEwMCkgdC5yZW1vdmUoKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc3dpdGNoZXI6bmV3IFN3aXRjaGVyKHtcbiAgICBvblRyYW5zaXRpb246IHtcbiAgICAgIHZhbDonZmFkZScsXG4gICAgICAkaGFzVG91Y2g6ICdzbGlkZSdcbiAgICB9LFxuICAgIGJhY2tGYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCd3dGYgbW9ldCBoaWVyLi4uYmFja2ZhbGxiYWNrJylcbiAgICB9XG4gIH0pLFxuICBleHRlbmQ6e1xuICAgIHBvcHVwOmZ1bmN0aW9uKCl7fVxuICB9XG59KS5DbGFzc1xuXG5cbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIHRleHQ6e2RhdGE6J3JhdGluZycsYWRkOntkYXRhOidzaG93LnJhdGluZyd9fVxufSkuQ2xhc3MiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBQb3N0ZXIgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9saXN0L2l0ZW0nKS5Qb3N0ZXJcbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcblxudmFyIFJlY29tbWVuZGF0aW9ucyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAndWktcmVjb21tZW5kYXRpb25zJyxcbiAgZGlzcGxheTp7XG4gICAgdmFsOidibG9jaycsXG4gICAgd2hlbjp7ZGF0YToncmVjb21tZW5kYXRpb25zJ30sXG4gICAgb3I6J25vbmUnXG4gIH0sXG4gIGhlYWRlcjogeyB0ZXh0OiAnWW91XFwnbGwgbG92ZSB0aGVzZScgfSxcbiAgYm9keToge1xuICAgIHNjcm9sbGJhcjogJ3gnLFxuICAgIGNvbGxlY3Rpb246IHtcbiAgICAgIGRhdGE6ICdyZWNvbW1lbmRhdGlvbnMnLFxuICAgICAgZWxlbWVudDogUG9zdGVyXG4gICAgfVxuICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY29tbWVuZGF0aW9uc1xuIiwidmFyIGFwcCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvJylcbnZhciBFbGVtZW50ID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JylcbnZhciBkaXNwbGF5ID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvZWxlbWVudC9wcm9wZXJ0aWVzL2NvbGxlY3Rpb24vZGlzcGxheScpXG52YXIgSWNvbiA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ljb24nKVxudmFyIEltZyA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL2ltZycpXG52YXIgU3VidGl0bGUgPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsL3NyYy9jb21wb25lbnRzL3NoYXJlZC9zdWJ0aXRsZScpXG52YXIgTXV0ZSA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2NvbXBvbmVudHMvc2hhcmVkL211dGUnKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG5cbnZhciBSZXN1bHQgPSBleHBvcnRzLlJlc3VsdCA9IGFwcC5jYXNlcy4kaXNQaG9uZSBcbj8gbmV3IEVsZW1lbnQoe1xuICAgIGNzczonc2VhcmNoLXJlc3VsdCcsXG4gICAgYm9keToge1xuICAgICAgdGl0bGU6IHtcbiAgICAgICAgdGV4dDp7ZGF0YTondGl0bGUnfSxcbiAgICAgIH0sXG4gICAgICBhcnJvd1JpZ2h0OiBuZXcgSWNvbih7IGljb246J3JpZ2h0JyB9KVxuICAgIH0sXG4gICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuICAgICAgYXBwLnVzZXIubmF2aWdhdGlvbi5jb250ZW50LiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhXG4gICAgIH1cbiAgfSkuQ2xhc3NcbjogbmV3IEVsZW1lbnQoe1xuICAgIGNzczonc2VhcmNoLXJlc3VsdCcsXG4gICAgJ3Bvc3Rlci5jb250YWluZXInOm5ldyBJbWcoe1xuICAgICAgJ2JhY2tncm91bmQuZGF0YSc6J2ltZy5wb3N0ZXInXG4gICAgfSksXG4gICAgYm9keTp7XG4gICAgICAndGl0bGUudGV4dC5kYXRhJzondGl0bGUnLFxuICAgICAgc3VidGl0bGU6bmV3IFN1YnRpdGxlKClcbiAgICB9XG4gIH0pLkNsYXNzXG5cbnZhciBSZXN1bHRzID0gZXhwb3J0cy5SZXN1bHRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3NlYXJjaC1yZXN1bHRzJyxcbiAgdGl0bGU6IHtcbiAgICB0ZXh0OidyZWNlbnQgc2VhcmNoZXMnXG4gIH0sXG4gIGNvbGxlY3Rpb246IHtcbiAgICBvcHRpb246ZGlzcGxheSxcbiAgICBlbGVtZW50OlJlc3VsdFxuICB9XG59KS5DbGFzc1xuXG52YXIgVG9wUmVzdWx0ID0gZXhwb3J0cy5Ub3BSZXN1bHQgPSBuZXcgRWxlbWVudCh7XG4gIHRpdGxlOiB7dGV4dDondG9wIHJlc3VsdCd9LFxuICBjc3M6J3NlYXJjaC10b3AtcmVzdWx0JyxcbiAgYm9keToge1xuICAgIHBvc3Rlcjp7XG4gICAgICBpbWc6IHtcbiAgICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICAgIHZhbDogY29uZmlnLnBvaW50ZXJzLmltZyxcbiAgICAgICAgICBhZGQ6IHsgZGF0YTonaW1nLnBvc3RlcicgfVxuICAgICAgICB9LFxuICAgICAgICBiYWNrZHJvcDp7fSxcbiAgICAgICAgbXV0ZTpuZXcgTXV0ZSh7XG4gICAgICAgICAgZGlzcGxheTp7XG4gICAgICAgICAgICB2YWw6J25vbmUnLFxuICAgICAgICAgICAgJGhhc1JlY2VpdmVyOidibG9jaydcbiAgICAgICAgICB9LFxuICAgICAgICAgIGljb246e1xuICAgICAgICAgICAgdmFsOmFwcC51c2VyLnRyYWlsZXJNdXRlZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgYXBwLnVzZXIudHJhaWxlck11dGVkLiR1c2VyT3JpZ2luID0gIWFwcC51c2VyLnRyYWlsZXJNdXRlZC52YWxcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfSxcbiAgICB0ZXh0SG9sZGVyOntcbiAgICAgIHRpdGxlOiB7IHRleHQ6eyBkYXRhOid0aXRsZScgfSB9LFxuICAgICAgaW5mbzogeyB0ZXh0OicxMTIgbWludXRlcycgfSxcbiAgICAgIHJhdGluZzoge1xuICAgICAgICB0ZXh0OiB7IGRhdGE6J3JhdGluZyd9XG4gICAgICB9LFxuICAgICAgZGVzY3JpcHRpb246IHsgdGV4dDogeyBkYXRhOiAnZGVzY3JpcHRpb24nfSB9LFxuICAgICAgJ2V2ZW50cy5jbGljayc6ZnVuY3Rpb24oZSkge1xuICAgICAgICBhcHAudXNlci5uYXZpZ2F0aW9uLmNvbnRlbnQuJHVzZXJPcmlnaW4gPSB0aGlzLnRpdGxlLmRhdGFcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vZGVsOiB7IGluaGVyaXQ6IGZhbHNlIH1cbiAgLy8gJ21vZGVsLmZpZWxkJzonbW92aWVzLjAnIC8vZGV6ZSBtb2V0IGR5bmFtaWNseSBjaGFuZ2VuIDooXG59KS5DbGFzc1xuXG5leHBvcnRzLlJlc3VsdExpc3QgPSBuZXcgRWxlbWVudCh7XG4gIG1vdmllczogbmV3IFJlc3VsdHMoe1xuICAgIHRpdGxlOiB7XG4gICAgICB0ZXh0Oidtb3ZpZXMnXG4gICAgfSxcbiAgICBjb2xsZWN0aW9uOiB7XG4gICAgICBlbGVtZW50OiBuZXcgUmVzdWx0KHtcbiAgICAgICAgbW9kZWw6IHtcbiAgICAgICAgICBzdWJzY3JpcHRpb246IHtcbiAgICAgICAgICAgIHRpdGxlOnRydWUsXG4gICAgICAgICAgICBhY3RvcnM6e1xuICAgICAgICAgICAgICAkOntcbiAgICAgICAgICAgICAgICB0aXRsZTp0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgZGF0YTonbW92aWVzJ1xuICAgIH1cbiAgfSksXG4gIHNlcmllczogbmV3IFJlc3VsdHMoe1xuICAgIHRpdGxlOiB7XG4gICAgICB0ZXh0OidzZXJpZXMnXG4gICAgfSxcbiAgICBjb2xsZWN0aW9uOiB7XG4gICAgICBkYXRhOidzZXJpZXMnXG4gICAgfVxuICB9KSxcbiAgY2hhbm5lbHM6IG5ldyBSZXN1bHRzKHtcbiAgICB0aXRsZToge1xuICAgICAgdGV4dDonY2hhbm5lbHMnXG4gICAgfSxcbiAgICBjb2xsZWN0aW9uOiB7XG4gICAgICBkYXRhOidjaGFubmVscydcbiAgICB9XG4gIH0pLFxuICBhY3RvcnM6IG5ldyBSZXN1bHRzKHtcbiAgICB0aXRsZToge1xuICAgICAgdGV4dDonYWN0b3JzJ1xuICAgIH0sXG4gICAgY29sbGVjdGlvbjoge1xuICAgICAgZGF0YTonYWN0b3JzJyxcbiAgICAgIGVsZW1lbnQ6IG5ldyBSZXN1bHQoe1xuICAgICAgICBtb2RlbDoge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbjoge1xuICAgICAgICAgICAgdGl0bGU6dHJ1ZSxcbiAgICAgICAgICAgIGNhdGFsb2c6e1xuICAgICAgICAgICAgICAkOntcbiAgICAgICAgICAgICAgICB0aXRsZTp0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgICdldmVudHMuY2xpY2snOmZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAvL21pc2NcbiAgICAgICAgICAvLyBhbGVydCgnPycpXG4gICAgICAgICAgYXBwLnBvcHVwLiR1c2VyT3JpZ2luID0gdGhpcy5kYXRhLmZyb21cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG59KS5DbGFzc1xuXG5leHBvcnRzLmZpbHRlckNvbGxlY3Rpb24gPSBmdW5jdGlvbiggZWxlbWVudCwgc3JjaCwgZmlsdGVyKSB7XG4gIGZpbHRlciA9IGZpbHRlciB8fCB7XG4gICAgY29uZGl0aW9uOiB7XG4gICAgICAkb3I6IFtcbiAgICAgIHsgdGl0bGU6eyAkY29udGFpbnM6c3JjaCB9IH0sXG4gICAgICB7IGNhdGFsb2c6eyAkOiB7IHRpdGxlOiB7ICRjb250YWluczpzcmNoIH0gfSB9IH0sXG4gICAgICB7IGFjdG9yczp7ICQ6IHsgdGl0bGU6IHsgJGNvbnRhaW5zOnNyY2ggfSB9IH0gfVxuICAgICAgXVxuICAgIH1cbiAgfVxuICBpZiggZWxlbWVudC5maWx0ZXIgKSB7XG4gICAgZWxlbWVudC5maWx0ZXIuZmlsdGVyID0gZmlsdGVyXG4gIH0gZWxzZSB7XG4gICAgZWxlbWVudC5jb2xsZWN0aW9uID0geyBmaWx0ZXI6IGZpbHRlciB9XG4gIH0gICAgXG59XG5cbmV4cG9ydHMudG9wUmVzdWx0ID0gZnVuY3Rpb24oIGxpc3QgKSB7XG4gIGZvcih2YXIgaSBpbiBsaXN0KSB7XG4gICAgaWYoIGxpc3RbaV0uZmlsdGVyICYmIGxpc3RbaV0uZmlsdGVyWzBdICkge1xuICAgICAgcmV0dXJuIGxpc3RbaV0uZmlsdGVyWzBdXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMucGFyc2VTZWFyY2ggPSBmdW5jdGlvbih2YWwpIHtcbiAgaWYodmFsICYmIHZhbC5fX3QgPT09IDIpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuICB2YWwgPSB2YWwgJiYgdmFsLnRyaW0oKSB8fCAnJ1xuICB2YXIgc3RyID0gJyc7XG4gIHJldHVybiB2YWxcbn0iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcpXG52YXIgYXBwID0gcmVxdWlyZSgndmlnb3VyLWpzL2FwcC8nKSAvLyAgcmVwbGFjZSBhcHAgc3R1ZmYgd2l0aCBwYXJlbnRcbnZhciB1YSA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL3VhJylcbnZhciBjYXNlcyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy9icm93c2VyL2Nhc2VzJylcbnZhciB2aWRlb1V0aWwgPSByZXF1aXJlKCd2aWdvdXItanMvYnJvd3Nlci9lbGVtZW50L3ZpZGVvL3V0aWwnKVxudmFyIEljb24gPSByZXF1aXJlKCcuLi9pY29uJylcbnZhciBfbGltaXRVcGRhdGVzID0gdWEucGxhdGZvcm0gPT09ICdpb3MnIHx8IHVhLnBsYXRmb3JtID09PSAnYW5kcm9pZCdcblxudmFyIEJhciA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOid1aS1zZWVrYmFyJyxcbiAgYmc6e30sXG4gIHNlZWs6e31cbn0pLkNsYXNzXG5cbnZhciBzZWVrYmFyID0gbmV3IEJhcih7IFxuICAnc2Vlay53Jzp7IFxuICAgIGRhdGE6J3RpbWUnLFxuICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIHJldHVybiBNYXRoLmFicyhjdikgKiAxMDAgKyAnJSdcbiAgICB9XG4gIH0sXG4gIGJnOiB7XG4gICAgbG9hZGVyYmFyOiB7XG4gICAgICAvLyBhcHBlbmQ6W0VsZW1lbnQse30se30se30se30se30se30se30se31dXG4gICAgfVxuICB9LFxuICBldmVudHM6XG4gIHsgZG93bjogZnVuY3Rpb24oZSkgeyBcbiAgICAgIGUudGVtcFByZXZlbnQgPSB0cnVlXG4gICAgICBzZXRUaW1lLmNhbGwodGhpcywgZSlcbiAgICB9LFxuICAgIGRyYWc6IHNldFRpbWUsXG4gICAgdXA6Y2FzZXMudG91Y2hcbiAgICA/IGZ1bmN0aW9uKGUpe1xuICAgICAgICB2YXIgb3ZlcmxheU9wYWNpdHkgPSB0aGlzLnBhcmVudC5wYXJlbnQucGFyZW50Lm9wYWNpdHlcbiAgICAgICAgaWYoIXRoaXMuX3NraXBVcCkgc2V0VGltZS5jYWxsKHRoaXMsIGUpXG4gICAgICAgIGVsc2UgdGhpcy5fc2tpcFVwID0gbnVsbFxuICAgICAgfVxuICAgIDogc2V0VGltZVxuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBzZWVrYmFyLkNsYXNzXG5cbmV4cG9ydHMuQmFyID0gQmFyXG5cbmZ1bmN0aW9uIHNldFRpbWUoZSkge1xuXG4gIC8vIGNvbnNvbGUuZXJyb3IoJ3h4eHgnKVxuXG4gIHZhciByZWN0ID0gdGhpcy5ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgLCB4XG4gICAgLCBuclxuXG4gIGlmKHRoaXMuX2xlZnQpe1xuICAgIHggPSByZWN0LnRvcFxuICAgIG5yID0gKGUueS14KS9yZWN0LmhlaWdodFxuICB9ZWxzZSBpZih0aGlzLl9yaWdodCl7XG4gICAgeCA9IHJlY3QudG9wXG4gICAgbnIgPSAocmVjdC5oZWlnaHQtKGUueS14KSkvcmVjdC5oZWlnaHRcbiAgfWVsc2V7XG4gICAgeCA9IHJlY3QubGVmdFxuICAgIG5yID0gKGUueC14KS8ocmVjdC5yaWdodC14KVxuICB9XG5cbiAgdmFyIHZhbCA9IG5yID4gMSA/IDEgOiBuciA8IDAgPyAwIDogbnJcbiAgaWYoIHZhbCAhPT0gdGhpcy5fcHJldlZhbCApXG4gIHtcbiAgICB0aGlzLnNlZWsuZGF0YS5mcm9tLnNldCgndGltZScsdmFsKVxuICAgIHRoaXMuX3ByZXZWYWwgPSB2YWxcbiAgfVxufSIsInJlcXVpcmUoJy4vc3R5bGUubGVzcycpXG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxudmFyIGNvbmZpZyA9IHJlcXVpcmUoJ3ZpZ291ci1qcy91dGlsL2NvbmZpZycpXG52YXIgSW1nID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvaW1nJylcblxudmFyIFNjb3JlID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3VpLXNjb3JlJyxcbiAgdG9wOiB7XG4gICAgaW5mbzoge1xuICAgICAgJ3RpdGxlLnRleHQuZGF0YSc6ICdzdGF0aXN0aWNzLnRpdGxlJyxcbiAgICAgICdzdWJ0aXRsZS50ZXh0LmRhdGEnOiAnc3RhdGlzdGljcy5kYXRlJ1xuICAgIH0sXG4gICAgdGVhbXM6IHtcbiAgICAgIGxlZnQ6IG5ldyBJbWcoe1xuICAgICAgICAnYmFja2dyb3VuZC5kYXRhJzogJ3N0YXRpc3RpY3MubGVmdC5pbWcnXG4gICAgICB9KSxcbiAgICAgIHJpZ2h0Om5ldyBJbWcoe1xuICAgICAgICAnYmFja2dyb3VuZC5kYXRhJzogJ3N0YXRpc3RpY3MucmlnaHQuaW1nJ1xuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gIGJvZHk6IHtcbiAgICAnbGVmdC50ZXh0LmRhdGEnOiAnc3RhdGlzdGljcy5sZWZ0LnBvaW50cycsXG4gICAgbWlkZGxlbGVmdDoge1xuICAgICAgJ3RpdGxlLnRleHQuZGF0YSc6ICdzdGF0aXN0aWNzLmxlZnQuYWNyb255bScsXG4gICAgICAnc3VidGl0bGUudGV4dC5kYXRhJzogJ3N0YXRpc3RpY3MubGVmdC5pbm5pbmdzJ1xuICAgIH0sXG4gICAgbWlkZGxlcmlnaHQ6IHtcbiAgICAgICd0aXRsZS50ZXh0LmRhdGEnOiAnc3RhdGlzdGljcy5yaWdodC5hY3JvbnltJyxcbiAgICAgICdzdWJ0aXRsZS50ZXh0LmRhdGEnOiAnc3RhdGlzdGljcy5yaWdodC5pbm5pbmdzJ1xuICAgIH0sXG4gICAgJ3JpZ2h0LnRleHQuZGF0YSc6ICdzdGF0aXN0aWNzLnJpZ2h0LnBvaW50cycsXG4gIH1cbn0pLkNsYXNzXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgY3NzOiAndWktc3RhdGlzdGljcycsXG4gIGRpc3BsYXk6e1xuICAgIGRhdGE6J3N0YXRpc3RpY3MudGl0bGUnLFxuICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIHJldHVybiBjdiA/ICdibG9jaycgOiAnbm9uZSdcbiAgICB9XG4gIH0sXG4gICdoZWFkZXIudGV4dCc6ICdTdGF0aXN0aWNzJyxcbiAgYm9keTpuZXcgU2NvcmUoKVxufSkuQ2xhc3NcblxuZXhwb3J0cy5TY29yZSA9IFNjb3JlIiwidmFyIEVsZW1lbnQgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBFbGVtZW50KHtcbiAgdGV4dDoge1xuICAgIGRhdGE6ICdzdWJ0aXRsZScsXG4gICAgYWRkOiBbXG4gICAgICAnLicsIHtcbiAgICAgICAgZGF0YTogJ3llYXInLFxuICAgICAgICBhZGQ6IFsnIC0gJywge1xuICAgICAgICAgIGRhdGE6ICdkdXJhdGlvbicsXG4gICAgICAgICAgZGl2aWRlOiA2MCxcbiAgICAgICAgICBmbG9vcjogdHJ1ZSxcbiAgICAgICAgICBhZGQ6ICcgTWludXRlcydcbiAgICAgICAgfV1cbiAgICAgIH0sXG4gICAgICAnLicsIHtcbiAgICAgICAgZGF0YTogJ2d1aWRlLjAuc3RhcnQtdGltZScsXG4gICAgICAgIGFkZDogWycgLSAnLCB7XG4gICAgICAgICAgZGF0YTogJ2d1aWRlLjAuZW5kLXRpbWUnXG4gICAgICAgIH1dXG4gICAgICB9XG4gICAgXSxcbiAgICB0cmFuc2Zvcm06IGZ1bmN0aW9uKHYsIGN2KSB7XG4gICAgICB2YXIgYXJyID0gY3Yuc3BsaXQoJy4nKVxuICAgICAgdmFyIGwgPSBhcnIubGVuZ3RoIC0gMVxuICAgICAgdmFyIHN0ciA9IGFycltsXVxuICAgICAgd2hpbGUgKHN0clsxXSA9PT0gJy0nIHx8IChzdHJbNV0gPT09ICctJyAmJiBzdHJbN10gPT09ICcgJykpIHsgLy9kaXJ0eSFcbiAgICAgICAgc3RyID0gYXJyWy0tbF1cbiAgICAgIH1cbiAgICAgIGlmIChzdHIpIHJldHVybiBzdHJcblxuICAgICAgdmFyIGZyb20gPSB0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmZyb21cbiAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgIHZhciBlcGlzb2RlID0gKGZyb20uX25hbWUgfCAwKSArIDFcbiAgICAgICAgdmFyIHNlYXNvbiA9IChmcm9tLl9wYXJlbnQuX3BhcmVudC5fbmFtZSB8IDApICsgMVxuICAgICAgICByZXR1cm4gJ1NlYXNvbiAnICsgc2Vhc29uICsgJyAtICcgKyAnRXBpc29kZSAnICsgZXBpc29kZVxuICAgICAgfVxuICAgIH1cbiAgfVxufSkuQ2xhc3NcbiIsInZhciBFbGVtZW50ID0gcmVxdWlyZSggJ3ZpZ291ci1qcy9hcHAvdWkvZWxlbWVudCcgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gICd0ZXh0LmRlZmF1bHQuZGF0YSc6J3RpdGxlJ1xufSkuQ2xhc3NcblxuZXhwb3J0cy5TaG93ID0gbmV3IGV4cG9ydHMoe1xuICAndGV4dC5kYXRhJzonc2hvdy50aXRsZSdcbn0pLkNsYXNzXG5cbi8vIGV4cG9ydHMuUHJvZ3JhbSA9IG5ldyBleHBvcnRzKHtcbi8vICAgJ3RleHQuZGF0YSc6J2d1aWRlLjAudGl0bGUnXG4vLyB9KS5DbGFzc1xuLy8gZXhwb3J0cy5Ub3BiYXIgPSBuZXcgZXhwb3J0cy5TaG93KHtcblxuLy8gfSkiLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcbnZhciBBU1NFVFMgPSByZXF1aXJlKCd2aWdvdXItanMvdXRpbC9jb25maWcnKS5wb2ludGVycy5hc3NldHNcblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRWxlbWVudCh7XG4gIGNzczogJ3VpLXRyaXZpYScsXG4gICdoZWFkZXIudGV4dCc6ICdUcml2aWEnLFxuICBkaXNwbGF5OntcbiAgICBkYXRhOid0cml2aWEudGl0bGUnLFxuICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgIHJldHVybiBjdiA/ICdibG9jaycgOiAnbm9uZSdcbiAgICB9XG4gIH0sXG4gIGJvZHk6IHtcbiAgICBiYWNrZ3JvdW5kOiB7IFxuICAgICAgZGF0YTogJ2ltZycsXG4gICAgICBwcmVwZW5kOiBBU1NFVFNcbiAgICB9LFxuICAgICd0aXRsZS50ZXh0LmRhdGEnOiAndHJpdmlhLnRpdGxlJyxcbiAgICAnc3VidGl0bGUudGV4dC5kYXRhJzogJ3RyaXZpYS5zdWJ0aXRsZScsXG4gICAgJ2Rlc2NyaXB0aW9uLnRleHQuZGF0YSc6ICd0cml2aWEuZGVzY3JpcHRpb24nXG4gIH1cbn0pLkNsYXNzXG4iLCJyZXF1aXJlKCcuL3N0eWxlLmxlc3MnKVxuXG52YXIgRWxlbWVudCA9IHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL2VsZW1lbnQnIClcblxudmFyIEljb24gPSByZXF1aXJlKCcvVXNlcnMvc2hhd24vV29yay9kaXJlY3R2LWZsLy9zcmMvY29tcG9uZW50cy9zaGFyZWQvaWNvbicpXG5cbnZhciBhcHAgPSByZXF1aXJlKCd2aWdvdXItanMvYXBwJylcblxudmFyIHR3ZWV0ID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6ICd0d2VldCcsXG4gIGljb246IG5ldyBJY29uKHtpY29uOid0d2l0dGVyJ30pLFxuICBmcm9tOiB7IHRleHQ6IHsgdmFsOiAnQCcsIGFkZDogeyBkYXRhOiAnYXV0aG9yJyB9IH0gfSxcbiAgbXNnOiB7IHRleHQ6IHsgZGF0YTogJ2JvZHknIH0gfSxcbiAgcmV0d2VldDogeyB0ZXh0OiAnUkVUV0VFVCcgfVxufSlcblxudmFyIFR3ZWV0cyA9IG5ldyBFbGVtZW50KHtcbiAgICBjc3M6ICd1aS10d2VldHMnLFxuICAgIGRpc3BsYXk6e1xuICAgICAgZGF0YTondHdlZXRzJyxcbiAgICAgIHRyYW5zZm9ybTpmdW5jdGlvbih2LGN2KXtcbiAgICAgICAgcmV0dXJuIGN2ID8gJ2Jsb2NrJyA6ICdub25lJ1xuICAgICAgfVxuICAgIH0sXG4gICAgaGVhZGVyOiB7IHRleHQ6ICdUd2VldHMnIH0sXG4gICAgaG9sZGVydDogeyAvL3dlaXJkIG5hbWUuLi4uIGhvbGRlciBpcyBhIGNsYXNzXG4gICAgICBzY3JvbGxiYXI6ICd4JyxcbiAgICAgIGJvZHk6IHtcbiAgICAgICAgY29sbGVjdGlvbjoge1xuICAgICAgICAgIGRhdGE6ICd0d2VldHMnLFxuICAgICAgICAgIGVsZW1lbnQ6IHR3ZWV0XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG59KS5DbGFzc1xuXG5tb2R1bGUuZXhwb3J0cyA9IFR3ZWV0c1xuIiwicmVxdWlyZSgnLi9zdHlsZS5sZXNzJylcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEVsZW1lbnQoe1xuICBjc3M6J3VpLXdhbGxwYXBlcidcbn0pLkNsYXNzXG4iLCIvKiFcbiAqIEBsaWNlbnNlIENvcHlyaWdodCAoYykgMjAxMi0yMDE1LCBWaWdvdXIuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBAYXV0aG9yOiBZb3VyaSBEYWFtZW4sIHlvdXJpQHZpZ291ci5pb1xuICovXG5cbnJlcXVpcmUoICcuL3N0eWxlLmxlc3MnIClcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9lbGVtZW50JyApXG52YXIgU3dpdGNoZXIgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcC91aS9zd2l0Y2hlcicgKVxuICAgIC5pbmplY3QoIHJlcXVpcmUoICd2aWdvdXItanMvYXBwL3VpL3N3aXRjaGVyL3RyYW5zaXRpb25zJyApIClcbnZhciBhcHAgPSByZXF1aXJlKCAndmlnb3VyLWpzL2FwcCcgKVxudmFyIGNhc2VzID0gYXBwLmNhc2VzXG52YXIgV2FsbHBhcGVyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC9zcmMvY29tcG9uZW50cy9zaGFyZWQvd2FsbHBhcGVyJylcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gbmV3IFN3aXRjaGVyKCB7XG4gIGNzczonYXBwLXN3aXRjaGVyJyxcbiAgb246IHtcbiAgICBzdGF0ZTogeyAvL3N0YXRlIGxla2tlciBleHRlbmRlZFxuICAgICAgZGVmZXI6IGZ1bmN0aW9uKCB1cGRhdGUgKSB7XG4gICAgICAgIHZhciBvbiA9IHRoaXMuX3BhcmVudFxuICAgICAgICB2YXIgc3dpdGNoZXIgPSBvbi5fY2FsbGVyXG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZnJvbS52YWxcbiAgICAgICAgXG4gICAgICAgIGlmKCBzdGF0ZT09PSdzZWNvbmQnICkge1xuXG4gICAgICAgICAgc3dpdGNoZXIudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6cmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvaW5hY3RpdmUnKSxcbiAgICAgICAgICAgICRwYXJhbXM6eyBcbiAgICAgICAgICAgICAgJGhpZ2hsaWdodDpvbi5oaWdobGlnaHQuX3ZhbCxcbiAgICAgICAgICAgICAgJHByZXZpZXc6b24ucHJldmlldy5fdmFsLFxuICAgICAgICAgICAgICAkbWVkaWE6YXBwLnVzZXIucmVjZWl2ZXIubWVkaWEsXG4gICAgICAgICAgICAgICRwYWdlOm9uLm5hdmlnYXRpb24uX3ZhbC5wYWdlLFxuICAgICAgICAgICAgICAkY29udGVudDpvbi5uYXZpZ2F0aW9uLl92YWwuY29udGVudCxcbiAgICAgICAgICAgICAgbmF2aWdhdGlvbjp7XG4gICAgICAgICAgICAgICAgZGF0YTphcHAuY29udGVudC5nZXQoJ2Rpc2NvdmVyJyksXG4gICAgICAgICAgICAgICAgJGZvY3VzOm9uLmZvY3VzLl92YWwsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyOntcbiAgICAgICAgICAgICAgICAgIHByb2dyZXNzOntcbiAgICAgICAgICAgICAgICAgICAgZGF0YTpvbi5wcmV2aWV3Ll92YWxcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gJHByb2dyZXNzOmFwcC5wcm9ncmVzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiggc3RhdGU9PT0nZmlyc3QnICkge1xuXG4gICAgICAgICAgc3dpdGNoZXIudHJhbnNpdGlvbiA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6cmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvYWN0aXZlJyksXG4gICAgICAgICAgICAkcGFyYW1zOntcbiAgICAgICAgICAgICAgbWVudToge1xuICAgICAgICAgICAgICAgIG5hdmlnYXRpb246IGFwcC51c2VyLm5hdmlnYXRpb25cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb246e1xuICAgICAgICAgICAgICAgIGZvY3VzOm9uLmZvY3VzLl92YWwsXG4gICAgICAgICAgICAgICAgcG9wdXA6b24ucG9wdXAuX3ZhbCxcbiAgICAgICAgICAgICAgICBzZWNvbmRQb3B1cDpvbi5zZWNvbmRQb3B1cC5fdmFsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGhvbGRlcjp7XG4gICAgICAgICAgICAgICAgdG9wYmFyOntcbiAgICAgICAgICAgICAgICAgICRjdXJyZW50OiBhcHAuY3VycmVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN3aXRjaGVyOntcbiAgICAgICAgICAgICAgICAgIG5hdmlnYXRpb246IGFwcC51c2VyLm5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1pbmlwbGF5ZXI6e1xuICAgICAgICAgICAgICAgICAgbWVkaWE6YXBwLnVzZXIucmVjZWl2ZXIubWVkaWEsXG4gICAgICAgICAgICAgICAgICBwbGF5aW5nOmFwcC51c2VyLnJlY2VpdmVyLnBsYXlpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmKCBzdGF0ZSA9PT0gJ2luYWN0aXZlJyl7XG4gICAgICAgIFxuICAgICAgICAgIHN3aXRjaGVyLnRyYW5zaXRpb24gPSB7XG4gICAgICAgICAgICBlbGVtZW50OldhbGxwYXBlcixcbiAgICAgICAgICAgICRwYXJhbXM6e31cbiAgICAgICAgICB9XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBvblRyYW5zaXRpb246J2ZhZGUnXG59ICkuQ2xhc3NcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IChjKSAyMDEyLTIwMTUsIFZpZ291ci4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBhdXRob3I6IFlvdXJpIERhYW1lbiwgeW91cmlAdmlnb3VyLmlvXG4gKi9cbmV4cG9ydHMuZm9jdXNlZCA9IGZ1bmN0aW9uKCBob2xkZXIsIGZvY3VzZWQsIG1ldGhvZCApIHtcbiAgaWYgKCBmb2N1c2VkICkge1xuICAgIFxuICAgIHZhciBwcmV2aW91cyA9IGhvbGRlci5fZm9jdXNlZFxuXG4gICAgaWYgKCBwcmV2aW91cyAhPT0gZm9jdXNlZCApIHtcblxuICAgICAgaWYgKCBwcmV2aW91cyApIHtcbiAgICAgICAgcHJldmlvdXMuY3NzID0ge1xuICAgICAgICAgIHJlbW92ZUNsYXNzOiAnZm9jdXNlZCdcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cy4kZm9jdXNlZCA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGZvY3VzZWQuY3NzID0ge1xuICAgICAgICBhZGRDbGFzczogJ2ZvY3VzZWQnXG4gICAgICB9XG5cbiAgICAgIGZvY3VzZWQuJGZvY3VzZWQgPSB0cnVlXG5cbiAgICAgIGlmICggbWV0aG9kICkgbWV0aG9kKCBmb2N1c2VkLCBwcmV2aW91cyApXG5cbiAgICAgIGhvbGRlci5fZm9jdXNlZCA9IGZvY3VzZWRcbiAgICB9XG5cbiAgfVxufVxuXG5leHBvcnRzLnByZXZlbnRBbmltYXRpb24gPSBmdW5jdGlvbiggX3RoaXMsIG1ldGhvZCwgZG9uZSApe1xuICBfdGhpcy5fYmxvY2tlZCA9IHRydWVcbiAgX3RoaXMuY3NzID0ge2FkZENsYXNzOidkb250QW5pbWF0ZSd9XG4gIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICBtZXRob2QoKVxuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtcbiAgICAgIF90aGlzLmNzcyA9IHtyZW1vdmVDbGFzczonZG9udEFuaW1hdGUnfVxuICAgICAgX3RoaXMuX2Jsb2NrZWQgPSBudWxsXG4gICAgICBpZiggZG9uZSApIGRvbmUoKVxuICAgIH0pXG4gIH0pXG59IiwidmFyIGFwcCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvc3JjL2FwcCcpXG52YXIgdXJsID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvbmV0d29yay91cmwnKVxudmFyIHVhID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvdWEnKVxudmFyIGRldmljZSA9IHVybC5wYXJhbXMuZGV2aWNlICYmIHVybC5wYXJhbXMuZGV2aWNlLnZhbCB8fCB1YS5kZXZpY2VcblxudmFyIGNsaWVudGluZm8gPSB7XG4gIHBob25lOiB7XG4gICAgdGl0bGU6ICdLZXZpblxcJ3MgaVBob25lJyxcbiAgICBpbmZvOiAnaVBob25lIDYnXG4gIH0sXG4gIGlwYWQ6IHtcbiAgICB0aXRsZTogJ0tldmluXFwncyBpUGFkJyxcbiAgICBpbmZvOiAnaVBhZCAyJyxcbiAgICBkZXZpY2U6ICd0YWJsZXQnXG4gIH0sXG4gIHR2OiB7XG4gICAgdGl0bGU6ICdTaGFycCcsXG4gICAgaW5mbzogJzUyXCIgTEVEIFRWJyxcbiAgICBkZXZpY2U6ICd0didcbiAgfSxcbiAgdGFibGV0OiB7XG4gICAgdGl0bGU6ICdVbml0ZWQgQWlybGluZXMnLFxuICAgIGluZm86ICdJbiBGbGlnaHQgRW50ZXJ0YWlubWVudCcsXG4gICAgZGV2aWNlOiAnSUZFJ1xuICB9LFxuICBkZWY6IHtcbiAgICB0aXRsZTogdWEucGxhdGZvcm0rJyAnK2RldmljZSxcbiAgICBpbmZvOiB1YS5wbGF0Zm9ybSsnICcrZGV2aWNlLFxuICAgIGRldmljZTpkZXZpY2VcbiAgfVxufVxuXG5hcHAuY2xvdWQuY2xpZW50LnZhbCA9IGNsaWVudGluZm9bZGV2aWNlXSB8fCBjbGllbnRpbmZvLmRlZiIsInJlcXVpcmUoJy4vdWFoYWNrJylcblxudmFyIGFwcCA9IHJlcXVpcmUoJy9Vc2Vycy9zaGF3bi9Xb3JrL2RpcmVjdHYtZmwvL3NyYy9hcHAnKVxudmFyIFN3aXRjaGVyID0gcmVxdWlyZSgnL1VzZXJzL3NoYXduL1dvcmsvZGlyZWN0di1mbC8vc3JjL2NvbXBvbmVudHMvc3dpdGNoZXInKVxudmFyIHVzZXIgPSBhcHAudXNlclxuXG5pZihhcHAuY2FzZXMuJGlzTmF0aXZlKXtcbiAgdmFyIHN0YXR1c0JhciA9IHJlcXVpcmUoJ3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyJylcbiAgc3RhdHVzQmFyLnNldCh7XG4gICAgc3R5bGU6J2xpZ2h0JyxcbiAgICB2aXNpYmlsaXR5OidvdmVybGF5J1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgYWxlcnQoXCJlcnJvciBzZXR0aW5nIHN0YXR1c0JhcjogXCIgK2VycilcbiAgfSlcbn1cblxuLy8gc3dpdGNoZXIgYmV0d2VlbiBmaXJzdC9zZWNvbmQvcGxheWVyXG5cbi8vIGFwcC5yZWFkeS5vbmNlKHRydWUsZnVuY3Rpb24oKXtcblxucmVxdWlyZSgnLi9jbGllbnRoYWNrJylcblxuLy8gYXBwLnJlYWR5Lm9uY2UodHJ1ZSxmdW5jdGlvbigpe1xuXG5hcHAuc2V0KHtcbiAgc3dpdGNoZXI6IG5ldyBTd2l0Y2hlcigge1xuICAgIG9uOiB7XG4gICAgICBuYXZpZ2F0aW9uOiB1c2VyLm5hdmlnYXRpb24sXG4gICAgICBwbGF5OiBhcHAucGxheWluZyxcbiAgICAgIHJlY2VpdmVyOiB1c2VyLnJlY2VpdmVyLFxuICAgICAgdXNhZ2U6IHVzZXIudXNhZ2UsXG4gICAgICBjb250ZW50OiBhcHAuY29udGVudCxcbiAgICAgIHNlYXJjaDogdXNlci5zZWFyY2gsXG4gICAgICBmb2N1czogdXNlci5mb2N1c19yb3csXG4gICAgICBwcmV2aWV3OiBhcHAucHJldmlldyxcbiAgICAgIGhpZ2hsaWdodDogYXBwLmhpZ2hsaWdodCxcbiAgICAgIHBvcHVwOmFwcC5wb3B1cCxcbiAgICAgIHNlY29uZFBvcHVwOmFwcC5zZWNvbmRQb3B1cCxcbiAgICAgIC8vbmF2IHdvcmQgZGlmZmVyZW50XG4gICAgICAvLyB3YXRjaGVkOiB1c2VyLndhdGNoZWQuZnJvbSxcbiAgICAgIHN0YXRlOiBhcHAuc3RhdGUsXG4gICAgICBvdmVybGF5OiBhcHAub3ZlcmxheSxcbiAgICAgIGxvYWRpbmc6IGFwcC5sb2FkaW5nLFxuICAgICAgYWN0aXZlQ2xpZW50OiB1c2VyLmFjdGl2ZUNsaWVudCxcbiAgICAgIHZvbHVtZTogYXBwLnZvbHVtZVxuICAgIH1cbiAgfSlcbn0pXG5cblxuLy8gVE9ETzogcmVuYW1lIGFwcC5pbml0aWFsaXplZD9cblxuLy8gYXBwLnBvcHVwLnZhbCA9ICdhY3Rvcidcbi8vIGFwcC5tZW51LnZhbCA9IHRydWVcbi8vIH0pXG5cbmFwcC5pbml0aWFsaXNlZC52YWwgPSB0cnVlXG5cblxuLy8gYXBwLnJlYWR5LmlzKHRydWUsZnVuY3Rpb24oKXtcbi8vICAgYXBwLnNlY29uZFBvcHVwLnZhbCA9ICd2b2x1bWUnXG4vLyB9LHRydWUpIiwidmFyIHVhID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvdWEnKVxudmFyIGNhc2VzID0gcmVxdWlyZSgndmlnb3VyLWpzL2Jyb3dzZXIvY2FzZXMnKVxuXG5jb25zb2xlLmxvZygnLS0tLS0tLS0tLS0tLS0tLSB1YSBoYWNraW5nIHRoYXQhJywgdWEpXG5cblxuaWYodWEuZGV2aWNlID09PSAnZGVza3RvcCcpIHtcbiAgY29uc29sZS5sb2coJ2hhY2sgZGF0IGRlc2t0b3AnKVxuICB1YS5kZXZpY2UgPSAndHYnXG4gIHVhLnBsYXRmb3JtID0gJ2ZhbmN5J1xuICBjYXNlcy4kaXNEZXNrdG9wID0gZmFsc2VcbiAgY29uc29sZS5sb2coJ2xvbCBzZXQgZGF0IHR2IHRyZXVzJylcbiAgY2FzZXMuJGlzVHYgPSB0cnVlXG5cbiAgd2luZG93LklOQUNUSVZFID0gdHJ1ZVxufSBlbHNlIGlmKHVhLmRldmljZSA9PT0gJ2lwYWQnKSB7XG4gIHdpbmRvdy5JTkFDVElWRSA9IHRydWVcblxufVxuIiwibW9kdWxlLmV4cG9ydHM9e1wibmFtZVwiOlwiZGlyZWN0di1mbFwiLFwidmVyc2lvblwiOlwiMjAxNS8wNi8xMCAxNTozMzoxNiBVVEMgKDEuMC4zKVwiLFwiZGVzY3JpcHRpb25cIjpcIlwiLFwibWFpblwiOlwiaW5kZXguanNcIixcInNjcmlwdHNcIjp7XCJzdGFydEdhc3RvblwiOlwiLi9ub2RlX21vZHVsZXMvLmJpbi9nYXN0b24gZGV2XCIsXCJzdGFydFwiOlwibnBtIHJ1biBzdGFydEdhc3RvblwiLFwidGVzdFwiOlwiZWNobyBcXFwiRXJyb3I6IG5vIHRlc3Qgc3BlY2lmaWVkXFxcIiAmJiBleGl0IDFcIixcInN5bWxpbmtcIjpcIm1rZGlyIC1wIG5vZGVfbW9kdWxlczsgbG4gLXNmICQocHdkKSAkKHB3ZCkvbm9kZV9tb2R1bGVzXCIsXCJzdGFydEh1YlwiOlwiLi9ub2RlX21vZHVsZXMvdmlnb3VyLWh1Yi9iaW4vaHViIC1kIC1jIGRpcmVjdHZcIixcInByZXN0YXJ0XCI6XCJucG0gcnVuIHN0YXJ0SHViICZcIixcImJ1aWxkXCI6XCJ2TmF0aXZlIGJ1aWxkXCIsXCJyZWxlYXNlXCI6XCJwYWNrZXIgLXIgLWMgcGFja2FnZS5qc29uLC5wYWNrYWdlLmpzb25cIn0sXCJyZXBvc2l0b3J5XCI6e1widHlwZVwiOlwiZ2l0XCIsXCJ1cmxcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vZGlyZWN0di1mbC5naXRcIixcImJyYW5jaFwiOlwic2hhd24tZGV2XCJ9LFwiYXV0aG9yXCI6XCJWaWdvdXJcIixcImJ1Z3NcIjp7XCJ1cmxcIjpcImh0dHBzOi8vZ2l0aHViLmNvbS92aWdvdXItaW8vZGlyZWN0di1mbC9pc3N1ZXNcIn0sXCJob21lcGFnZVwiOlwiaHR0cHM6Ly9naXRodWIuY29tL3ZpZ291ci1pby9kaXJlY3R2LWZsXCIsXCJkZXBlbmRlbmNpZXNcIjp7XCJ0aHJvdWdoMlwiOlwiKlwiLFwibG9kYXNoXCI6XCIzLjIuMFwiLFwibW9ub3RvbmljLXRpbWVzdGFtcFwiOlwiMC4wLjlcIixcInByb21pc2VcIjpcIl43LjAuMVwiLFwidmlnb3VyLWpzXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb206dmlnb3VyLWlvL3ZpZ291ci1qcy5naXQjZGlyZWN0dlwifSxcImRldkRlcGVuZGVuY2llc1wiOntcInZpZ291ci1uYXRpdmVcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbTp2aWdvdXItaW8vdmlnb3VyLW5hdGl2ZS5naXRcIixcInZpZ291ci1uYXRpdmUtc3RhdHVzQmFyXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb206dmlnb3VyLWlvL3ZpZ291ci1uYXRpdmUtc3RhdHVzQmFyLmdpdFwiLFwidmlnb3VyLXBhY2tlci1zZXJ2ZXJcIjpcImdpdCtzc2g6Ly9naXRAZ2l0aHViLmNvbTp2aWdvdXItaW8vdmlnb3VyLXBhY2tlci1zZXJ2ZXIuZ2l0XCIsXCJ2aWdvdXItaHViXCI6XCJnaXQrc3NoOi8vZ2l0QGdpdGh1Yi5jb206dmlnb3VyLWlvL3ZpZ291ci1odWIuZ2l0I2RpcmVjdHZcIixcImdhc3RvblwiOlwiZ2l0K3NzaDovL2dpdEBnaXRodWIuY29tOnZpZ291ci1pby9nYXN0b24uZ2l0XCJ9LFwidmlnb3VyXCI6e1wiY2xvdWRcIjpcImh0dHA6Ly9kaXJlY3R2Mi5kZXYudmlnb3VyLmlvOjgwXCIsXCJicmFuY2hlc1wiOntcInlvdXppLWRldlwiOntcImNsb3VkXCI6XCJodHRwOi8vbG9jYWxob3N0OjEwMDAxXCIsXCJwb2ludGVyc1wiOntcImltZ1wiOlwiaHR0cDovL2xvY2FsaG9zdDo4MDgwL1wiLFwiYXNzZXRzXCI6XCJodHRwOi8vbG9jYWxob3N0OjgwODAvXCJ9fSxcIm1hcmN1cy1kZXZcIjp7XCJjbG91ZFwiOlwiaHR0cDovLzEwLjAuMS4xOTk6MTAwMDFcIn0sXCJzaGF3bi1kZXZcIjp7XCJjbG91ZFwiOlwiaHR0cDovL2RpcmVjdHYyLmRldi52aWdvdXIuaW86ODBcIn19LFwiZGV2ZWxvcG1lbnRcIjp7XCJidXR0b25cIjpmYWxzZX0sXCJwb2ludGVyc1wiOntcImltZ1wiOlwiaHR0cDovL2RldmFzc2V0cy52aWdvdXIuaW8vXCIsXCJhc3NldHNcIjpcImh0dHA6Ly9kZXZhc3NldHMudmlnb3VyLmlvL1wifSxcInBhY2tlclwiOntcIndlYlwiOlwiaW5kZXguaHRtbFwiLFwiYXNzZXRzXCI6e1wiYnVuZGxlLmpzXCI6dHJ1ZSxcImJ1bmRsZS5jc3NcIjp0cnVlLFwiaW5kZXguaHRtbFwiOnRydWUsXCJhc3NldHNcIjpcIipcIixcImZvbnRzLmNzc1wiOnRydWV9LFwiZ2l0XCI6e1wib3duZXJcIjpcInZpZ291ci1pb1wiLFwicmVwb1wiOlwiZGlyZWN0di1mbFwifSxcIm1haWxcIjp7XCJmcm9tQWRkcmVzc1wiOlwic2hhd25Admlnb3VyLmlvXCIsXCJ0b1wiOlwic2hhd25Admlnb3VyLmlvXCJ9LFwic2xhY2tcIjp7fSxcInNlcnZlclwiOnt9fSxcIm5hdGl2ZVwiOntcInBsYXRmb3Jtc1wiOntcImlvc1wiOntcInByb2R1Y3ROYW1lXCI6XCJEaXJlY3QgVFYgLSBGdXR1cmUgTGFuZFwiLFwib3JnYW5pemF0aW9uTmFtZVwiOlwiVmlnb3VyXCIsXCJvcmdhbml6YXRpb25JZGVudGlmaWVyXCI6XCJpby52aWdvdXIuZGlyZWN0di1mbFwiLFwiYnVpbGROdW1iZXJcIjpcIjFcIixcImFwcEluZGV4UGF0aFwiOlwiaW5kZXguaHRtbFwiLFwiYXBwVXJsSWRlbnRpZmllclwiOlwiY29tLmRpcmVjdHYtZmwub3JnXCIsXCJhcHBVcmxTY2hlbWVcIjpcImRpcmVjdHYtZmxcIn19fX0sXCJnYXN0b25cIjp7XCJicm93c2VyaWZ5LXRyYW5zZm9ybXNcIjpbe1wicGF0aFwiOlwidmlnb3VyLWpzL3V0aWwvaW5mb3JtLXRyYW5zZm9ybVwiLFwib3B0aW9uc1wiOntcImdsb2JhbFwiOlwiZmFsc2VcIn19XSxcInJlcXVpcmUtcGF0aHNcIjp7XCJkdHZcIjpcInNyY1wiLFwic2hhcmVkXCI6XCJzcmMvY29tcG9uZW50cy9zaGFyZWRcIixcImR0di1jb21wb25lbnRzXCI6XCJzcmMvY29tcG9uZW50c1wiLFwiZHR2LWFjdGl2ZVwiOlwic3JjL2NvbXBvbmVudHMvYWN0aXZlXCIsXCJkdHYtaXRlbVwiOlwic3JjL2NvbXBvbmVudHMvYWN0aXZlL2NvbnRlbnQtaXRlbVwiLFwiZHR2LWNoYW5uZWxcIjpcInNyYy9jb21wb25lbnRzL2FjdGl2ZS9jb250ZW50LWl0ZW0vY2hhbm5lbFwiLFwiZHR2LWVwaXNvZGVcIjpcInNyYy9jb21wb25lbnRzL2FjdGl2ZS9jb250ZW50LWl0ZW0vZXBpc29kZVwiLFwiZHR2LW1vdmllXCI6XCJzcmMvY29tcG9uZW50cy9hY3RpdmUvY29udGVudC1pdGVtL21vdmllXCJ9fSxcInNoYVwiOlwiMS4wLjNcIn0iXX0=
